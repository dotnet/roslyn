// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System.Linq;
using Microsoft.CodeAnalysis;

namespace Metalama.Compiler;

/// <summary>
/// Exposes the <see cref="SyntaxAnnotation"/>s used by Metalama.Compiler.
/// </summary>
public static class MetalamaCompilerAnnotations
{
    internal const string OriginalLocationAnnotationKind = "Metalama.Compiler.OriginalLocation";

    private const string _sourceCodeAnnotationKind = "Metalama.Compiler.SourceCode";

    /// <summary>
    /// Name of the annotation that means that the code is generated. Metalama.Compiler uses this this annotation
    /// to change error messages when they are reported on generated code. Any syntax node under a node annotated
    /// with such annotation is considered as generated, unless it is under a node annotated with <see cref="SourceCodeAnnotation"/>.
    /// The annotation data is a human-readable text saying which component generated the code.
    /// </summary>
    public const string GeneratedCodeAnnotationKind = "Metalama.Compiler.GeneratedCode";


    /// <summary>
    /// Gets an annotation that means that the target syntax nodes and its children are source code, even if there is an annotation
    /// of kind <see cref="GeneratedCodeAnnotationKind"/> in a parent node.
    /// </summary>
    public static SyntaxAnnotation SourceCodeAnnotation { get; } = new(_sourceCodeAnnotationKind);

    /// <summary>
    /// Adds a <see cref="SyntaxAnnotation"/> to a node that maps the node to the location of another node in source code.
    /// </summary>
    public static T WithOriginalLocationAnnotationFrom<T>(this T node, SyntaxNode originalNode)
        where T : SyntaxNode
    {
#if METALAMA_COMPILER_INTERFACE
        return node;
#else
        var annotation = TreeTracker.GetAnnotationForNodeToBeModified(originalNode);
        if (annotation == null)
        {
            return node;
        }
        else
        {
            return node.WithAdditionalAnnotations(annotation);
        }
#endif
    }

    /*
    /// <summary>
    /// Adds a <see cref="SyntaxAnnotation"/> to a token that maps the token to the location of another token in source code.
    /// </summary>
    public static SyntaxToken WithOriginalLocationAnnotationFrom(this SyntaxToken token, SyntaxToken originalToken)
    {
#if METALAMA_COMPILER_INTERFACE
        return token;
#else
        if (!originalToken.HasAnnotations(OriginalLocationAnnotationKind))
        {
            return token;
        }
        else
        {
            return token.WithAdditionalAnnotations(originalToken.GetAnnotations(OriginalLocationAnnotationKind));
        }
#endif
    }
    */

    /// <summary>
    /// Creates a <see cref="SyntaxAnnotation"/> that can be added to syntax nodes to mean that they have been
    /// generated by some component, typically by an aspect.
    /// </summary>
    /// <param name="origin">A human-readable text that identifies the originating component (typically an aspect).</param>
    /// <returns>A <see cref="SyntaxAnnotation"/> that can be added to syntax.</returns>
    public static SyntaxAnnotation CreateGeneratedCodeAnnotation(string origin) => new(GeneratedCodeAnnotationKind, origin);

#if !METALAMA_COMPILER_INTERFACE
    internal static bool TryFindGeneratedCodeOrigin(this SyntaxNode node, out string? origin)
    {
        if (node.HasAnnotation(SourceCodeAnnotation))
        {
            origin = null;
            return false;
        }
        else if (node.GetAnnotations(GeneratedCodeAnnotationKind).FirstOrDefault() is { } annotation)
        {
            origin = annotation.Data;
            return true;
        }
        else if (node.Parent != null)
        {
            return node.Parent.TryFindGeneratedCodeOrigin(out origin);
        }
        else
        {
            origin = null;
            return false;
        }
    }
#endif

    internal const string IgnoreCodeCoverageAnnotationKind = "Metalama.Compiler.IgnoreCodeCoverage";
    internal const string RedirectCodeCoverageAnnotationKind = "Metalama.Compiler.RedirectCodeCoverage";    

    private static readonly SyntaxAnnotation _ignoreCodeCoverageAnnotation = new SyntaxAnnotation(IgnoreCodeCoverageAnnotationKind);

    public static T WithIgnoreCodeCoverageAnnotation<T>(this T syntaxNode)
    where T : SyntaxNode
        => syntaxNode.WithAdditionalAnnotations(_ignoreCodeCoverageAnnotation);
    public static T WithRedirectCodeCoverageAnnotation<T>(this T syntaxNode, ISymbol originalSymbol)
        where T : SyntaxNode
        => syntaxNode.WithAdditionalAnnotations(new SyntaxAnnotation(RedirectCodeCoverageAnnotationKind, DocumentationCommentId.CreateDeclarationId(originalSymbol)));

    public static bool TryGetCodeCoverageRedirectionFromAnnotation(this SyntaxNode syntaxNode, Compilation compilation,
        out ISymbol? redirectedSymbol)
    {
        var annotation = syntaxNode.GetAnnotations(RedirectCodeCoverageAnnotationKind).SingleOrDefault();
        if (annotation != null)
        {
            redirectedSymbol = DocumentationCommentId.GetFirstSymbolForDeclarationId(annotation.Data!, compilation);
            return true;
        }
        else
        {
            redirectedSymbol = null;
            return false;
        }
    }

    private const string _includeInReferenceAssemblyAnnotationKind = "Metalama.Compiler.IncludeInReferenceAssembly";

    /// <summary>
    /// Gets an annotation that means that the declaration of the target syntax node should be included in a reference assembly,
    /// even if it otherwise wouldn't be due to its accessibility.
    /// </summary>
    public static SyntaxAnnotation IncludeInReferenceAssemblyAnnotation { get; } = new(_includeInReferenceAssemblyAnnotationKind);

    /// <summary>
    /// Adds an annotation that means that the declaration of the target syntax node should be included in a reference assembly,
    /// even if it otherwise wouldn't be due to its accessibility.
    /// </summary>
    public static T WithIncludeInReferenceAssemblyAnnotation<T>(this T syntaxNode)
        where T : SyntaxNode
        => syntaxNode.WithAdditionalAnnotations(IncludeInReferenceAssemblyAnnotation);
}
