<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <OutputType>Exe</OutputType>
    <TargetFramework>$(NetVSCode)</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>

    <ServerGarbageCollection>true</ServerGarbageCollection>

    <!-- .NET Tool configuration -->
    <IsPackable>true</IsPackable>
    <PackAsTool>true</PackAsTool>
    <PackageId>roslyn-language-server</PackageId>
    <ToolCommandName>roslyn-language-server</ToolCommandName>

    <!-- Publishing settings -->
    <SelfContained>false</SelfContained>
    <PublishDir Condition="'$(RuntimeIdentifier)' != ''">$(ArtifactsDir)/LanguageServer/$(Configuration)/$(TargetFramework)/$(RuntimeIdentifier)</PublishDir>

    <!-- List of runtime identifiers that we want to publish an executable for. -->
    <!-- When building a VMR vertical, we don't need to pack everything. Just pack the passed in TargetRid or PortableTargetRid.
         TargetRid and PortableTargetRid are provided to roslyn via the build arguments passed in the VMR orchestrator's repo project.
         https://github.com/dotnet/dotnet/blob/main/repo-projects/roslyn.proj. For definitions of the TargetRid
         and other common properties, see https://github.com/dotnet/arcade/blob/main/Documentation/UnifiedBuild/Unified-Build-Controls.md -->
    <RuntimeIdentifiers Condition="'$(TargetRid)' != ''">$(TargetRid)</RuntimeIdentifiers>
    <RuntimeIdentifiers Condition="'$(PortableTargetRid)' != ''">$(PortableTargetRid)</RuntimeIdentifiers>
    <RuntimeIdentifiers Condition="'$(TargetRid)' == '' and '$(PortableTargetRid)' == ''">win-x64;win-arm64;linux-x64;linux-arm64;linux-musl-x64;linux-musl-arm64;osx-x64;osx-arm64</RuntimeIdentifiers>

    <!-- Publish ready to run executables when we're publishing platform specific executables. -->
    <PublishReadyToRun Condition="'$(Configuration)' == 'Release' ">true</PublishReadyToRun>

  </PropertyGroup>

  <ItemGroup>
    <!-- Include MIBC data if available.  This is produced by a separate profiling pipeline for the C# extension, and injected in official builds -->
    <PublishReadyToRunPgoFiles Condition="'$(VSCodeOptimizationDataRoot)'!=''" Include="$(VSCodeOptimizationDataRoot)\*.mibc" />

    <!-- Workaround https://github.com/dotnet/dotnet/issues/3995 -->
    <PublishReadyToRunExclude Include="Microsoft.VisualStudio.TestPlatform.Common.dll" />
  </ItemGroup>

  <Target Name="SetCrossgen2ExtraArgs" BeforeTargets="ResolveReadyToRunCompilers" Condition="'$(PublishReadyToRun)' == 'true'">
    <PropertyGroup>
      <!-- Define extra crossgen2 args.  This must be done in a target as TargetName isn't available in evaluation -->
      <PublishReadyToRunCrossgen2ExtraArgs>$(PublishReadyToRunCrossgen2ExtraArgs);--non-local-generics-module:"$(TargetName)"</PublishReadyToRunCrossgen2ExtraArgs>
    </PropertyGroup>
  </Target>

  <Target Name="AddCrossAssemblyOptimizationSwitch"
    DependsOnTargets="ResolveProjectReferences"
    AfterTargets="ResolveProjectReferences">
    <!-- We used to use - -opt-cross-module:* as a switch, but inlining code
         from the runtime led to exposing bugs in crossgen/runtime in not rejecting
         native code when the inlined code was stale.
         To avoid customer facing bugs in C# extension, we are now taking the more
         conservative approach of only inlining code from assemblies in the same
         "servicing bubble", which we can most closely approximate here by just
         inlining code in assemblies that come from project references. -->
    <ItemGroup>
      <_OptCrossModuleSwitch
        Condition="'%(_ResolvedProjectReferencePaths.ReferenceOutputAssembly)'=='true'"
        Include="@(_ResolvedProjectReferencePaths->'--opt-cross-module:%(FileName)')" />
    </ItemGroup>
    <PropertyGroup>
      <PublishReadyToRunCrossgen2ExtraArgs>$(PublishReadyToRunCrossgen2ExtraArgs);@(_OptCrossModuleSwitch)</PublishReadyToRunCrossgen2ExtraArgs>
    </PropertyGroup>
  </Target>

  <ItemGroup Label="Project References">
    <!-- An extern alias is necessary to prevent ambiguity between shared projects linked to both Workspace and BuildHost -->
    <ProjectReference Include="..\..\Workspaces\MSBuild\Core\Microsoft.CodeAnalysis.Workspaces.MSBuild.csproj" Aliases="MSBuildWorkspaces" />
    <ProjectReference Include="..\..\Workspaces\MSBuild\Contracts\Microsoft.CodeAnalysis.Workspaces.MSBuild.Contracts.csproj" Aliases="MSBuildWorkspacesContracts" />

    <ProjectReference Include="..\..\Workspaces\Remote\Core\Microsoft.CodeAnalysis.Remote.Workspaces.csproj" />
    <ProjectReference Include="..\Protocol\Microsoft.CodeAnalysis.LanguageServer.Protocol.csproj" />

    <!-- Dlls we don't directly reference but need to include to build the MEF composition -->
    <ProjectReference Include="..\..\Features\CSharp\Portable\Microsoft.CodeAnalysis.CSharp.Features.csproj" />

    <!-- Not directly referenced but needed for Razor source generators -->
    <ProjectReference Include="..\..\Tools\ExternalAccess\RazorCompiler\Microsoft.CodeAnalysis.ExternalAccess.RazorCompiler.csproj" />

    <!-- Not directly referenced but needed for Route embedded language features -->
    <ProjectReference Include="..\..\Features\ExternalAccess\AspNetCore\Microsoft.CodeAnalysis.ExternalAccess.AspNetCore.csproj" />
    <ProjectReference Include="..\..\Features\ExternalAccess\Copilot\Microsoft.CodeAnalysis.ExternalAccess.Copilot.csproj" />
    <ProjectReference Include="..\ExternalAccess\VisualDiagnostics\Microsoft.CodeAnalysis.ExternalAccess.VisualDiagnostics.csproj" />
    <ProjectReference Include="..\..\Tools\ExternalAccess\Xaml\Microsoft.CodeAnalysis.ExternalAccess.Xaml.csproj" />
    <ProjectReference Include="..\ExternalAccess\CompilerDeveloperSDK\Microsoft.CodeAnalysis.ExternalAccess.CompilerDeveloperSDK.csproj" />
    <ProjectReference Include="..\ExternalAccess\Copilot\Microsoft.CodeAnalysis.LanguageServer.ExternalAccess.Copilot.csproj" />
    <ProjectReference Include="..\..\Tools\ExternalAccess\Razor\Features\Microsoft.CodeAnalysis.ExternalAccess.Razor.Features.csproj" />
  </ItemGroup>

  <ItemGroup>
    <PackageReference Include="Microsoft.Extensions.FileSystemGlobbing" />
    <PackageReference Include="Microsoft.Extensions.Logging" />
    <PackageReference Include="Microsoft.Extensions.Logging.Abstractions" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" />
    <PackageReference Include="Microsoft.ServiceHub.Framework" />
    <PackageReference Include="Microsoft.TestPlatform.TranslationLayer" />
    <PackageReference Include="Microsoft.TestPlatform.ObjectModel" />
    <PackageReference Include="Microsoft.VisualStudio.Composition" />
    <PackageReference Include="NuGet.ProjectModel" />
    <PackageReference Include="System.CommandLine" />

    <!--
      Ensure we include the sqlite assemblies and their native dependencies in our package to enable persistent storage.
    -->
    <PackageReference Include="SQLitePCLRaw.core" />
    <PackageReference Include="SQLitePCLRaw.bundle_green" />
    <PackageReference Include="SQLitePCLRaw.provider.dynamic_cdecl" />
  </ItemGroup>

  <ItemGroup>
    <InternalsVisibleTo Include="Microsoft.CodeAnalysis.LanguageServer.UnitTests" />

    <!--
      Only allow C# DevKit to use types from Microsoft.CodeAnalysis.Contracts namespace. The contracts should not introduce breaking changes between versions,
      because the versions of C# DevKit and C# Extension might not be aligned.
    -->
    <RestrictedInternalsVisibleTo Include="Microsoft.VisualStudio.LanguageServices.DevKit" Namespace="Microsoft.CodeAnalysis.Contracts" />
  </ItemGroup>

  <ItemGroup>
    <RoslynVersionFile Include="$(OutDir)\RoslynVersion.txt" />
    <FileWrites Include="@(RoslynVersionFile)" />
  </ItemGroup>

  <ItemGroup>
    <EmbeddedResource Update="LanguageServerResources.resx" GenerateSource="true" />
  </ItemGroup>

  <Target Name="WriteRoslynVersion" AfterTargets="Build">
    <WriteLinesToFile File="@(RoslynVersionFile)" Lines="$(MicrosoftCodeAnalysisVersion)" Overwrite="true" />
  </Target>

  <Target Name="PublishRoslynVersion" AfterTargets="Publish">
    <Copy SourceFiles="@(RoslynVersionFile)" DestinationFolder="$(PublishDir)" />
  </Target>

  <!--
    Verify that the SymbolPublishingExclusionsFile.txt contains the required entries for the native SQLite library.
    These don't have symbols we need to publish and they cause symbol check to fail.
  -->
  <Target Name="ValidateSymbolPublishingExclusions"
          BeforeTargets="Build">
    <PropertyGroup>
      <_SymbolExclusionsFile>$(RepoRoot)eng\SymbolPublishingExclusionsFile.txt</_SymbolExclusionsFile>
      <_ExpectedArm64Entry>tools/$(TargetFramework)/linux-musl-arm64/libe_sqlite3.so</_ExpectedArm64Entry>
      <_ExpectedX64Entry>tools/$(TargetFramework)/linux-musl-x64/libe_sqlite3.so</_ExpectedX64Entry>
    </PropertyGroup>

    <ReadLinesFromFile File="$(_SymbolExclusionsFile)">
      <Output TaskParameter="Lines" ItemName="_SymbolExclusionLines" />
    </ReadLinesFromFile>

    <PropertyGroup>
      <_ExclusionFileContent>@(_SymbolExclusionLines)</_ExclusionFileContent>
      <_HasArm64Entry>$(_ExclusionFileContent.Contains('$(_ExpectedArm64Entry)'))</_HasArm64Entry>
      <_HasX64Entry>$(_ExclusionFileContent.Contains('$(_ExpectedX64Entry)'))</_HasX64Entry>
    </PropertyGroup>

    <Error Condition="!$(_HasArm64Entry)"
           Text="SymbolPublishingExclusionsFile.txt is missing required entry: $(_ExpectedArm64Entry). Please add this entry to $(_SymbolExclusionsFile) to exclude the native SQLite library from symbol publishing." />

    <Error Condition="!$(_HasX64Entry)"
           Text="SymbolPublishingExclusionsFile.txt is missing required entry: $(_ExpectedX64Entry). Please add this entry to $(_SymbolExclusionsFile) to exclude the native SQLite library from symbol publishing." />
  </Target>
</Project>
