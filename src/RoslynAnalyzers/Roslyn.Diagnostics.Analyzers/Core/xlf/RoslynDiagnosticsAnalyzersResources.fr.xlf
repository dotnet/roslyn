<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="fr" original="../RoslynDiagnosticsAnalyzersResources.resx">
    <body>
      <trans-unit id="AddSharedAttribute">
        <source>Add 'Shared' attribute</source>
        <target state="translated">Ajouter l'attribut 'Shared'</target>
        <note>{Locked="Shared"}</note>
      </trans-unit>
      <trans-unit id="ApplyTraitToContainingType">
        <source>Apply trait to containing type</source>
        <target state="translated">Appliquer la caractéristique au type conteneur</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOptSuffixForNullableEnableCodeCodeFixTitle">
        <source>Remove the 'Opt' suffix</source>
        <target state="translated">Supprimer le suffixe 'Opt'</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOptSuffixForNullableEnableCodeDescription">
        <source>Avoid the 'Opt' suffix in a nullable-enabled code.</source>
        <target state="translated">Évitez le suffixe 'Opt' dans du code pouvant accepter des valeurs null.</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOptSuffixForNullableEnableCodeMessage">
        <source>Avoid the 'Opt' suffix in a nullable-enabled code</source>
        <target state="translated">Éviter le suffixe 'Opt' dans du code pouvant accepter des valeurs null</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOptSuffixForNullableEnableCodeTitle">
        <source>Avoid the 'Opt' suffix</source>
        <target state="translated">Éviter le suffixe 'Opt'</target>
        <note />
      </trans-unit>
      <trans-unit id="CreateTestAccessorDescription">
        <source>This is a refactoring which simplifies the process of creating test accessors using the 'TestAccessor' pattern.</source>
        <target state="translated">Il s'agit d'une refactorisation qui simplifie le processus de création d'accesseurs de test à l'aide du modèle 'TestAccessor'.</target>
        <note />
      </trans-unit>
      <trans-unit id="CreateTestAccessorMessage">
        <source>Create test accessor</source>
        <target state="translated">Créer un accesseur de test</target>
        <note />
      </trans-unit>
      <trans-unit id="CreateTestAccessorTitle">
        <source>Create test accessor</source>
        <target state="translated">Créer un accesseur de test</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultableTypeShouldHaveDefaultableFieldsDescription">
        <source>Defaultable types should have defaultable fields.</source>
        <target state="translated">Les types par défaut doivent avoir des champs par défaut.</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultableTypeShouldHaveDefaultableFieldsMessage">
        <source>Defaultable type '{0}' has a non-defaultable field or auto-property '{1}'</source>
        <target state="translated">Le type par défaut '{0}' a un champ sans valeur par défaut ou une propriété automatique '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultableTypeShouldHaveDefaultableFieldsTitle">
        <source>Defaultable types should have defaultable fields</source>
        <target state="translated">Les types par défaut doivent avoir des champs par défaut</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallGetTestAccessorDescription">
        <source>'GetTestAccessor()' is a helper method reserved for testing. Production code must not call this member.</source>
        <target state="translated">'GetTestAccessor()' est une méthode d'assistance réservée aux tests. Le code de production ne doit pas appeler ce membre.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallGetTestAccessorMessage">
        <source>Do not call 'GetTestAccessor()' from production code</source>
        <target state="translated">N'appelez pas 'GetTestAccessor()' à partir du code de production</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallGetTestAccessorTitle">
        <source>Do not call 'GetTestAccessor()'</source>
        <target state="translated">Ne pas appeler 'GetTestAccessor()'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCapturePrimaryConstructorParametersDescription">
        <source>Primary constructor parameters should not be implicitly captured. Manually assign them to fields at the start of the type.</source>
        <target state="translated">Les paramètres du constructeur principal ne doivent pas être capturés implicitement. Affectez-les manuellement aux champs au début du type.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCapturePrimaryConstructorParametersMessage">
        <source>Primary constructor parameter '{0}' should not be implicitly captured</source>
        <target state="translated">Le paramètre de constructeur principal '{0}' ne doit pas être capturé implicitement</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCapturePrimaryConstructorParametersTitle">
        <source>Do not capture primary constructor parameters</source>
        <target state="translated">Ne pas capturer les paramètres du constructeur principal</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueAvoidNullableWrapperDescription">
        <source>Avoid nullable wrapper.</source>
        <target state="translated">Évitez le wrapper nullable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueAvoidNullableWrapperMessage">
        <source>Do not wrap non-copyable type '{0}' in '{1}' operation</source>
        <target state="translated">Ne pas inclure dans un wrapper le type '{0}' non copiable dans l'opération '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueDescription">
        <source>Do not copy value.</source>
        <target state="translated">Ne copiez pas de valeur.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueMessage">
        <source>Do not copy value</source>
        <target state="translated">Ne pas copier la valeur</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoAssignValueFromReferenceDescription">
        <source>Cannot assign a value from a reference to a non-copyable type.</source>
        <target state="translated">Impossible d'affecter une valeur à partir d'une référence à un type non copiable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoAssignValueFromReferenceMessage">
        <source>Cannot assign a value from a reference to non-copyable type '{0}'</source>
        <target state="translated">Impossible d'affecter une valeur à partir d'une référence au type non copiable '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoAutoPropertyDescription">
        <source>Auto-properties always copy values, so they cannot be declared with non-copyable types.</source>
        <target state="translated">Les propriétés automatiques copient toujours les valeurs, elles ne peuvent donc pas être déclarées avec des types non copiables.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoAutoPropertyMessage">
        <source>Auto-property '{1}' cannot have non-copyable type '{0}'</source>
        <target state="translated">La propriété automatique '{1}' ne peut pas avoir le type non copiable '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoBoxingDescription">
        <source>Do not box non-copyable value types.</source>
        <target state="translated">N'effectue pas de conversion boxing des types valeur non copiables.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoBoxingMessage">
        <source>Do not box non-copyable type '{0}'</source>
        <target state="translated">Ne pas effectuer de conversion boxing du type non copiable '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoFieldOfCopyableTypeDescription">
        <source>A field with a non-copyable type cannot be a member of a copyable type. The containing type can be made non-copyable or converted to a reference type, or the field can be removed or converted to a copyable type.</source>
        <target state="translated">Un champ avec un type non copiable ne peut pas être membre d'un type copiable. Le type conteneur peut être rendu non copiable ou être converti en type référence. De même, le champ peut être supprimé ou converti en type copiable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoFieldOfCopyableTypeMessage">
        <source>Copyable field '{1}' cannot have non-copyable type '{0}'</source>
        <target state="translated">La champ copiable '{1}' ne peut pas avoir le type non copiable '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoReturnValueFromReferenceDescription">
        <source>Cannot return a value from a reference to a non-copyable type.</source>
        <target state="translated">Impossible de retourner une valeur à partir d'une référence à un type non copiable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoReturnValueFromReferenceMessage">
        <source>Cannot return a value from a reference to non-copyable type '{0}'</source>
        <target state="translated">Impossible de retourner une valeur à partir d'une référence au type non copiable '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoUnboxingDescription">
        <source>Do not unbox non-copyable value types.</source>
        <target state="translated">N'effectue pas de conversion unboxing des types valeur non copiables.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoUnboxingMessage">
        <source>Do not unbox non-copyable type '{0}'</source>
        <target state="translated">Ne pas effectuer de conversion unboxing du type '{0}' non copiable</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueTitle">
        <source>Do not copy value</source>
        <target state="translated">Ne pas copier la valeur</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueUnsupportedUseDescription">
        <source>Unsupported use of non-copyable type.</source>
        <target state="translated">Utilisation non prise en charge d'un type non copiable.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueUnsupportedUseMessage">
        <source>Unsupported use of non-copyable type '{0}' in '{1}' operation</source>
        <target state="translated">Utilisation non prise en charge du type '{0}' non copiable dans l'opération '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInterpolatedStringsWithDebugAssertCodeFix">
        <source>Use 'RoslynDebug.Assert'.</source>
        <target state="new">Use 'RoslynDebug.Assert'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInterpolatedStringsWithDebugAssertDescription">
        <source>'Debug.Assert' on .NET Framework eagerly creates the string value. This can cause OOMs in tests, particularly for strings that involve syntax nodes. Use 'RoslynDebug.Assert' instead, which will only create the string if required.</source>
        <target state="new">'Debug.Assert' on .NET Framework eagerly creates the string value. This can cause OOMs in tests, particularly for strings that involve syntax nodes. Use 'RoslynDebug.Assert' instead, which will only create the string if required.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInterpolatedStringsWithDebugAssertMessage">
        <source>Do not use interpolated strings with 'Debug.Assert'. Use 'RoslynDebug.Assert' instead.</source>
        <target state="new">Do not use interpolated strings with 'Debug.Assert'. Use 'RoslynDebug.Assert' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInterpolatedStringsWithDebugAssertTitle">
        <source>Do not use interpolated strings with 'Debug.Assert'</source>
        <target state="new">Do not use interpolated strings with 'Debug.Assert'</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_ImplicitConstructor">
        <source>Explicitly define the importing constructor</source>
        <target state="translated">Définir explicitement le constructeur d'importation</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_MissingAttribute">
        <source>Add 'ImportingConstructor' attribute</source>
        <target state="translated">Ajouter l'attribut 'ImportingConstructor'</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_NonPublicConstructor">
        <source>Make constructor public</source>
        <target state="translated">Rendre le constructeur public</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorDescription">
        <source>Exported parts should be marked with 'ImportingConstructorAttribute'.</source>
        <target state="translated">Les parties exportées doivent être marquées avec 'ImportingConstructorAttribute'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorMessage">
        <source>'{0}' is MEF-exported and should have a single, public importing constructor of the correct form</source>
        <target state="translated">'{0}' est exporté avec MEF et doit avoir un seul constructeur d'importation de la forme appropriée.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorTitle">
        <source>Exported parts should have a public constructor marked with 'ImportingConstructorAttribute'</source>
        <target state="translated">Les parties exportées doivent avoir un constructeur public marqué avec 'ImportingConstructorAttribute'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExposeMemberForTestingDescription">
        <source>Expose member for testing.</source>
        <target state="translated">Exposez le membre à des fins de test.</target>
        <note />
      </trans-unit>
      <trans-unit id="ExposeMemberForTestingMessage">
        <source>Expose member for testing</source>
        <target state="translated">Exposer un membre à des fins de test</target>
        <note />
      </trans-unit>
      <trans-unit id="ExposeMemberForTestingTitle">
        <source>Expose member for testing</source>
        <target state="translated">Exposer un membre à des fins de test</target>
        <note />
      </trans-unit>
      <trans-unit id="FixNumberedComments">
        <source>Fix numbered comments</source>
        <target state="translated">Corriger les commentaires numérotés</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_ErrorSetToFalse">
        <source>Set 'ObsoleteAttribute.Error' to 'true'</source>
        <target state="translated">Affectez la valeur 'true' à 'ObsoleteAttribute.Error'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_IncorrectDescription">
        <source>Use correct 'ObsoleteAttribute' message.</source>
        <target state="translated">Utilisez le message 'ObsoleteAttribute' approprié.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingAttribute">
        <source>Add 'ObsoleteAttribute'</source>
        <target state="translated">Ajouter 'ObsoleteAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingDescription">
        <source>Configure 'ObsoleteAttribute' for importing constructor.</source>
        <target state="translated">Configurez 'ObsoleteAttribute' pour le constructeur d'importation.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingError">
        <source>Set 'ObsoleteAttribute.Error' to 'true'</source>
        <target state="translated">Affectez la valeur 'true' à 'ObsoleteAttribute.Error'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteDescription">
        <source>Importing constructor should be marked with 'ObsoleteAttribute'.</source>
        <target state="translated">Le constructeur d'importation doit être marqué avec 'ObsoleteAttribute'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteMessage">
        <source>Importing constructor should be marked with 'ObsoleteAttribute'</source>
        <target state="translated">Le constructeur d'importation doit être marqué avec 'ObsoleteAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteTitle">
        <source>Importing constructor should be marked with 'ObsoleteAttribute'</source>
        <target state="translated">Le constructeur d'importation doit être marqué avec 'ObsoleteAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="Place_statement_on_following_line">
        <source>Place statement on following line</source>
        <target state="translated">Placer l'instruction sur la ligne suivante</target>
        <note />
      </trans-unit>
      <trans-unit id="NamedTypeFullNameNotNullSuppressorJustification">
        <source>The 'Type.FullName' property is never null when using the syntax 'typeof(T).FullName'</source>
        <target state="translated">La propriété 'Type.FullName' n'a jamais de valeur null quand la syntaxe 'typeof(T).FullName' est utilisée</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferNullLiteralCodeFix">
        <source>Use 'null' instead of 'default'</source>
        <target state="translated">Utilisez 'null' à la place de 'default'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferNullLiteralDescription">
        <source>Use 'null' instead of 'default' for nullable types.</source>
        <target state="translated">Utilisez 'null' à la place de 'default' pour les types Nullable.</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferNullLiteralMessage">
        <source>Use 'null' instead of 'default' for nullable types</source>
        <target state="translated">Utiliser 'null' à la place de 'default' pour les types Nullable</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferNullLiteralTitle">
        <source>Prefer null literal</source>
        <target state="translated">Préférez un littéral ayant une valeur null</target>
        <note />
      </trans-unit>
      <trans-unit id="RelaxTestNamingSuppressorJustification">
        <source>Asynchronous test methods do not require the 'Async' suffix</source>
        <target state="translated">Les méthodes de test asynchrones ne nécessitent pas le suffixe 'Async'</target>
        <note />
      </trans-unit>
      <trans-unit id="Run iterations">
        <source>Run iterations</source>
        <target state="translated">Exécuter les itérations</target>
        <note />
      </trans-unit>
      <trans-unit id="TemporaryArrayAsRefDescription">
        <source>Instance of TemporaryArray&lt;T&gt;.AsRef() must be a 'using' variable.</source>
        <target state="translated">L'instance de TemporaryArray&lt;T&gt;.AsRef() doit être une variable 'using'.</target>
        <note>{Locked="TemporaryArray&lt;T&gt;.AsRef()"}{Locked="using"}</note>
      </trans-unit>
      <trans-unit id="TemporaryArrayAsRefMessage">
        <source>Instance of TemporaryArray&lt;T&gt;.AsRef() must be a 'using' variable</source>
        <target state="translated">L'instance de TemporaryArray&lt;T&gt;.AsRef() doit être une variable 'using'</target>
        <note>{Locked="TemporaryArray&lt;T&gt;.AsRef()"}{Locked="using"}</note>
      </trans-unit>
      <trans-unit id="TemporaryArrayAsRefTitle">
        <source>Instance of TemporaryArray&lt;T&gt;.AsRef() must be a 'using' variable</source>
        <target state="translated">L'instance de TemporaryArray&lt;T&gt;.AsRef() doit être une variable 'using'</target>
        <note>{Locked="TemporaryArray&lt;T&gt;.AsRef()"}{Locked="using"}</note>
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableCodeFix">
        <source>Apply 'PartNotDiscoverableAttribute'</source>
        <target state="translated">Appliquer 'PartNotDiscoverableAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableDescription">
        <source>Test exports should not be discoverable.</source>
        <target state="translated">Les exportations de test ne doivent pas être détectables.</target>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableMessage">
        <source>'{0}' is exported for test purposes and should be marked with 'PartNotDiscoverableAttribute'</source>
        <target state="translated">'{0}' est exporté à des fins de test et doit être marqué avec 'PartNotDiscoverableAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableTitle">
        <source>Test exports should not be discoverable</source>
        <target state="translated">Les exportations de test ne doivent pas être découvrables</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableTitle">
        <source>Use 'SpecializedCollections.EmptyEnumerable()'</source>
        <target state="translated">Utiliser 'SpecializedCollections.EmptyEnumerable()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableMessage">
        <source>Use 'SpecializedCollections.EmptyEnumerable()'</source>
        <target state="translated">Utiliser 'SpecializedCollections.EmptyEnumerable()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableTitle">
        <source>Use 'SpecializedCollections.SingletonEnumerable()'</source>
        <target state="translated">Utiliser 'SpecializedCollections.SingletonEnumerable()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableMessage">
        <source>Use 'SpecializedCollections.SingletonEnumerable()'</source>
        <target state="translated">Utiliser 'SpecializedCollections.SingletonEnumerable()'</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsTitle">
        <source>Invoke the correct property to ensure correct use site diagnostics</source>
        <target state="translated">Appeler la propriété appropriée pour garantir une utilisation adéquate des diagnostics de site</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsMessage">
        <source>Invoke the correct property to ensure correct use site diagnostics</source>
        <target state="translated">Appeler la propriété appropriée pour garantir une utilisation adéquate des diagnostics de site</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionTitle">
        <source>Do not use generic 'CodeAction.Create' to create 'CodeAction'</source>
        <target state="translated">N'utilisez pas de 'CodeAction.Create' générique pour créer 'CodeAction'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionMessage">
        <source>Do not use generic 'CodeAction.Create' to create 'CodeAction'</source>
        <target state="translated">N'utilisez pas de 'CodeAction.Create' générique pour créer 'CodeAction'</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableTitle">
        <source>Override 'Object.Equals(object)' when implementing 'IEquatable'</source>
        <target state="translated">Substituer 'Object.Equals(object)' au moment de l'implémentation de 'IEquatable'</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableMessage">
        <source>Override 'Object.Equals(object)' when implementing 'IEquatable'</source>
        <target state="translated">Substituer 'Object.Equals(object)' au moment de l'implémentation de 'IEquatable'</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsTitle">
        <source>'SymbolDeclaredEvent' must be generated for source symbols</source>
        <target state="translated">'SymbolDeclaredEvent' doit être généré pour les symboles sources</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsDescription">
        <source>Compilation event queue is required to generate symbol declared events for all declared source symbols. Hence, every source symbol type or one of its base types must generate a symbol declared event.</source>
        <target state="translated">Une file d'attente d'événements de compilation est nécessaire afin de générer les événements de déclaration de symbole pour tous les symboles sources déclarés. Ainsi, chaque type de symbole source ou l'un de ses types de base doit générer un événement de déclaration de symbole.</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsMessage">
        <source>'SymbolDeclaredEvent' must be generated for source symbols</source>
        <target state="translated">'SymbolDeclaredEvent' doit être généré pour les symboles sources</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFTitle">
        <source>Do not mix attributes from different versions of MEF</source>
        <target state="translated">Ne pas mélanger les attributs de différentes versions de MEF</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFDescription">
        <source>Do not mix attributes from different versions of MEF.</source>
        <target state="translated">Ne mélangez pas les attributs de différentes versions de MEF.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFMessage">
        <source>Attribute '{0}' comes from a different version of MEF than the export attribute on '{1}'</source>
        <target state="translated">L'attribut '{0}' provient d'une autre version de MEF que l'attribut d'exportation sur '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedTitle">
        <source>Parts exported with MEFv2 must be marked with 'SharedAttribute'</source>
        <target state="translated">Les parties exportées avec MEFv2 doivent être marquées avec 'SharedAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedDescription">
        <source>Part exported with MEFv2 must be marked with the 'SharedAttribute'.</source>
        <target state="translated">La partie exportée avec MEFv2 doit être marquée avec 'SharedAttribute'.</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedMessage">
        <source>'{0}' is exported with MEFv2 and hence must be marked with 'SharedAttribute'</source>
        <target state="translated">'{0}' est exporté avec MEFv2 et doit donc être marqué avec 'SharedAttribute'</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>