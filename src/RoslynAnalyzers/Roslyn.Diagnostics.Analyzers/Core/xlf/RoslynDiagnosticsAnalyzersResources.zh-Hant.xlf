<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../RoslynDiagnosticsAnalyzersResources.resx">
    <body>
      <trans-unit id="AddSharedAttribute">
        <source>Add 'Shared' attribute</source>
        <target state="translated">新增 'Shared' 屬性</target>
        <note>{Locked="Shared"}</note>
      </trans-unit>
      <trans-unit id="ApplyTraitToContainingType">
        <source>Apply trait to containing type</source>
        <target state="translated">將特徵套用至包含的型別</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOptSuffixForNullableEnableCodeCodeFixTitle">
        <source>Remove the 'Opt' suffix</source>
        <target state="translated">移除 'Opt' 尾碼</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOptSuffixForNullableEnableCodeDescription">
        <source>Avoid the 'Opt' suffix in a nullable-enabled code.</source>
        <target state="translated">避免在可為 null 的程式碼中使用 'Opt' 尾碼。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOptSuffixForNullableEnableCodeMessage">
        <source>Avoid the 'Opt' suffix in a nullable-enabled code</source>
        <target state="translated">避免在可為 null 的程式碼中使用 'Opt' 尾碼</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidOptSuffixForNullableEnableCodeTitle">
        <source>Avoid the 'Opt' suffix</source>
        <target state="translated">避免 'Opt' 尾碼</target>
        <note />
      </trans-unit>
      <trans-unit id="CreateTestAccessorDescription">
        <source>This is a refactoring which simplifies the process of creating test accessors using the 'TestAccessor' pattern.</source>
        <target state="translated">此為重構作業，可簡化使用 'TestAccessor' 模式建立測試存取子的流程。</target>
        <note />
      </trans-unit>
      <trans-unit id="CreateTestAccessorMessage">
        <source>Create test accessor</source>
        <target state="translated">建立測試存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="CreateTestAccessorTitle">
        <source>Create test accessor</source>
        <target state="translated">建立測試存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultableTypeShouldHaveDefaultableFieldsDescription">
        <source>Defaultable types should have defaultable fields.</source>
        <target state="translated">可設為預設的類型應具有可設為預設的欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultableTypeShouldHaveDefaultableFieldsMessage">
        <source>Defaultable type '{0}' has a non-defaultable field or auto-property '{1}'</source>
        <target state="translated">可設定預設值的類型 '{0}'，有無法設定預設值的欄位或自動屬性 '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DefaultableTypeShouldHaveDefaultableFieldsTitle">
        <source>Defaultable types should have defaultable fields</source>
        <target state="translated">可設定預設值的類型應要有可設定預設值的欄位</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallGetTestAccessorDescription">
        <source>'GetTestAccessor()' is a helper method reserved for testing. Production code must not call this member.</source>
        <target state="translated">'GetTestAccessor()' 是保留供測試的協助程式方法。實際執行程式碼不得呼叫此成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallGetTestAccessorMessage">
        <source>Do not call 'GetTestAccessor()' from production code</source>
        <target state="translated">請勿從實際執行程式碼呼叫 'GetTestAccessor()'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCallGetTestAccessorTitle">
        <source>Do not call 'GetTestAccessor()'</source>
        <target state="translated">請勿呼叫 'GetTestAccessor()'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCapturePrimaryConstructorParametersDescription">
        <source>Primary constructor parameters should not be implicitly captured. Manually assign them to fields at the start of the type.</source>
        <target state="translated">不應隱含擷取主要建構函式參數。在型別的開頭，手動將它們指派給欄位。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCapturePrimaryConstructorParametersMessage">
        <source>Primary constructor parameter '{0}' should not be implicitly captured</source>
        <target state="translated">不應隱含擷取主要建構函式參數 '{0}'。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCapturePrimaryConstructorParametersTitle">
        <source>Do not capture primary constructor parameters</source>
        <target state="translated">請勿擷取主要建構函式參數</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueAvoidNullableWrapperDescription">
        <source>Avoid nullable wrapper.</source>
        <target state="translated">避免使用可為 Null 的包裝函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueAvoidNullableWrapperMessage">
        <source>Do not wrap non-copyable type '{0}' in '{1}' operation</source>
        <target state="translated">請勿在 '{1}' 作業中包裝無法複製的類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueDescription">
        <source>Do not copy value.</source>
        <target state="translated">請勿複製值。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueMessage">
        <source>Do not copy value</source>
        <target state="translated">請勿複製值</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoAssignValueFromReferenceDescription">
        <source>Cannot assign a value from a reference to a non-copyable type.</source>
        <target state="translated">無法將參考的值指派到無法複製的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoAssignValueFromReferenceMessage">
        <source>Cannot assign a value from a reference to non-copyable type '{0}'</source>
        <target state="translated">無法將參考的值指派到無法複製的類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoAutoPropertyDescription">
        <source>Auto-properties always copy values, so they cannot be declared with non-copyable types.</source>
        <target state="translated">自動屬性一律會複製值，因此不得以不可複製型別宣告。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoAutoPropertyMessage">
        <source>Auto-property '{1}' cannot have non-copyable type '{0}'</source>
        <target state="translated">自動屬性 '{1}' 不得具有不可複製型別 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoBoxingDescription">
        <source>Do not box non-copyable value types.</source>
        <target state="translated">請勿對無法複製的值類型進行 Box 處理。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoBoxingMessage">
        <source>Do not box non-copyable type '{0}'</source>
        <target state="translated">請勿對無法複製的類型 '{0}' 進行 Box 處理</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoFieldOfCopyableTypeDescription">
        <source>A field with a non-copyable type cannot be a member of a copyable type. The containing type can be made non-copyable or converted to a reference type, or the field can be removed or converted to a copyable type.</source>
        <target state="translated">具有不可複製型別的欄位，不能是可複製型別的成員。可將包含的型別設為不可複製或轉換為參考型別，或將欄位移除或轉換為可複製型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoFieldOfCopyableTypeMessage">
        <source>Copyable field '{1}' cannot have non-copyable type '{0}'</source>
        <target state="translated">可複製欄位 '{1}' 不能具有不可複製型別 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoReturnValueFromReferenceDescription">
        <source>Cannot return a value from a reference to a non-copyable type.</source>
        <target state="translated">無法將參考的值傳回無法複製的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoReturnValueFromReferenceMessage">
        <source>Cannot return a value from a reference to non-copyable type '{0}'</source>
        <target state="translated">無法將參考的值傳回無法複製的類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoUnboxingDescription">
        <source>Do not unbox non-copyable value types.</source>
        <target state="translated">請勿對無法複製的值類型進行 Unbox 處理。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueNoUnboxingMessage">
        <source>Do not unbox non-copyable type '{0}'</source>
        <target state="translated">請勿對無法複製的類型 '{0}' 進行 Unbox 處理</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueTitle">
        <source>Do not copy value</source>
        <target state="translated">請勿複製值</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueUnsupportedUseDescription">
        <source>Unsupported use of non-copyable type.</source>
        <target state="translated">不支援使用無法複製的類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotCopyValueUnsupportedUseMessage">
        <source>Unsupported use of non-copyable type '{0}' in '{1}' operation</source>
        <target state="translated">不支援在 '{1}' 作業中使用無法複製的類型 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInterpolatedStringsWithDebugAssertCodeFix">
        <source>Use 'RoslynDebug.Assert'.</source>
        <target state="new">Use 'RoslynDebug.Assert'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInterpolatedStringsWithDebugAssertDescription">
        <source>'Debug.Assert' on .NET Framework eagerly creates the string value. This can cause OOMs in tests, particularly for strings that involve syntax nodes. Use 'RoslynDebug.Assert' instead, which will only create the string if required.</source>
        <target state="new">'Debug.Assert' on .NET Framework eagerly creates the string value. This can cause OOMs in tests, particularly for strings that involve syntax nodes. Use 'RoslynDebug.Assert' instead, which will only create the string if required.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInterpolatedStringsWithDebugAssertMessage">
        <source>Do not use interpolated strings with 'Debug.Assert'. Use 'RoslynDebug.Assert' instead.</source>
        <target state="new">Do not use interpolated strings with 'Debug.Assert'. Use 'RoslynDebug.Assert' instead.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseInterpolatedStringsWithDebugAssertTitle">
        <source>Do not use interpolated strings with 'Debug.Assert'</source>
        <target state="new">Do not use interpolated strings with 'Debug.Assert'</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_ImplicitConstructor">
        <source>Explicitly define the importing constructor</source>
        <target state="translated">明確定義匯入建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_MissingAttribute">
        <source>Add 'ImportingConstructor' attribute</source>
        <target state="translated">新增 'ImportingConstructor' 屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorCodeFix_NonPublicConstructor">
        <source>Make constructor public</source>
        <target state="translated">將建構函式設為公用</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorDescription">
        <source>Exported parts should be marked with 'ImportingConstructorAttribute'.</source>
        <target state="translated">匯出的組件應標記為 'ImportingConstructorAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorMessage">
        <source>'{0}' is MEF-exported and should have a single, public importing constructor of the correct form</source>
        <target state="translated">'{0}' 屬於 MEF 匯出，應有格式正確的單一且公用之匯入建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ExportedPartsShouldHaveImportingConstructorTitle">
        <source>Exported parts should have a public constructor marked with 'ImportingConstructorAttribute'</source>
        <target state="translated">匯出的組件應擁有標記為 'ImportingConstructorAttribute' 的公用建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ExposeMemberForTestingDescription">
        <source>Expose member for testing.</source>
        <target state="translated">公開要進行測試的成員。</target>
        <note />
      </trans-unit>
      <trans-unit id="ExposeMemberForTestingMessage">
        <source>Expose member for testing</source>
        <target state="translated">公開要測試的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ExposeMemberForTestingTitle">
        <source>Expose member for testing</source>
        <target state="translated">公開要測試的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="FixNumberedComments">
        <source>Fix numbered comments</source>
        <target state="translated">修正已編號的註解</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_ErrorSetToFalse">
        <source>Set 'ObsoleteAttribute.Error' to 'true'</source>
        <target state="translated">將 'ObsoleteAttribute.Error' 設定為 'true'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_IncorrectDescription">
        <source>Use correct 'ObsoleteAttribute' message.</source>
        <target state="translated">使用正確的 'ObsoleteAttribute' 訊息。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingAttribute">
        <source>Add 'ObsoleteAttribute'</source>
        <target state="translated">新增 'ObsoleteAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingDescription">
        <source>Configure 'ObsoleteAttribute' for importing constructor.</source>
        <target state="translated">請設定 'ObsoleteAttribute' 以匯入建構函式。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteCodeFix_MissingError">
        <source>Set 'ObsoleteAttribute.Error' to 'true'</source>
        <target state="translated">將 'ObsoleteAttribute.Error' 設定為 'true'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteDescription">
        <source>Importing constructor should be marked with 'ObsoleteAttribute'.</source>
        <target state="translated">匯入的建構函式應標記為 'ObsoleteAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteMessage">
        <source>Importing constructor should be marked with 'ObsoleteAttribute'</source>
        <target state="translated">匯入的建構函式應標記為 'ObsoleteAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="ImportingConstructorShouldBeObsoleteTitle">
        <source>Importing constructor should be marked with 'ObsoleteAttribute'</source>
        <target state="translated">匯入的建構函式應標記為 'ObsoleteAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="Place_statement_on_following_line">
        <source>Place statement on following line</source>
        <target state="translated">將陳述式放在下一行</target>
        <note />
      </trans-unit>
      <trans-unit id="NamedTypeFullNameNotNullSuppressorJustification">
        <source>The 'Type.FullName' property is never null when using the syntax 'typeof(T).FullName'</source>
        <target state="translated">使用語法 'typeof(T).FullName' 時，'Type.FullName' 屬性絕不會為 Null</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferNullLiteralCodeFix">
        <source>Use 'null' instead of 'default'</source>
        <target state="translated">使用 'null'，而不要使用 'default'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferNullLiteralDescription">
        <source>Use 'null' instead of 'default' for nullable types.</source>
        <target state="translated">對可為 Null 的型別使用 'null'，而不要使用 'default'。</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferNullLiteralMessage">
        <source>Use 'null' instead of 'default' for nullable types</source>
        <target state="translated">對可為 Null 的型別使用 'null'，而不要使用 'default'</target>
        <note />
      </trans-unit>
      <trans-unit id="PreferNullLiteralTitle">
        <source>Prefer null literal</source>
        <target state="translated">建議使用 Null 常值</target>
        <note />
      </trans-unit>
      <trans-unit id="RelaxTestNamingSuppressorJustification">
        <source>Asynchronous test methods do not require the 'Async' suffix</source>
        <target state="translated">非同步測試方法不需要 'Async' 尾碼</target>
        <note />
      </trans-unit>
      <trans-unit id="Run iterations">
        <source>Run iterations</source>
        <target state="translated">執行反覆項目</target>
        <note />
      </trans-unit>
      <trans-unit id="TemporaryArrayAsRefDescription">
        <source>Instance of TemporaryArray&lt;T&gt;.AsRef() must be a 'using' variable.</source>
        <target state="translated">TemporaryArray&lt;T&gt;.AsRef() 的執行個體必須是 'using' 變數。</target>
        <note>{Locked="TemporaryArray&lt;T&gt;.AsRef()"}{Locked="using"}</note>
      </trans-unit>
      <trans-unit id="TemporaryArrayAsRefMessage">
        <source>Instance of TemporaryArray&lt;T&gt;.AsRef() must be a 'using' variable</source>
        <target state="translated">TemporaryArray&lt;T&gt;.AsRef() 的執行個體必須是 'using' 變數</target>
        <note>{Locked="TemporaryArray&lt;T&gt;.AsRef()"}{Locked="using"}</note>
      </trans-unit>
      <trans-unit id="TemporaryArrayAsRefTitle">
        <source>Instance of TemporaryArray&lt;T&gt;.AsRef() must be a 'using' variable</source>
        <target state="translated">TemporaryArray&lt;T&gt;.AsRef() 的執行個體必須是 'using' 變數</target>
        <note>{Locked="TemporaryArray&lt;T&gt;.AsRef()"}{Locked="using"}</note>
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableCodeFix">
        <source>Apply 'PartNotDiscoverableAttribute'</source>
        <target state="translated">套用 'PartNotDiscoverableAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableDescription">
        <source>Test exports should not be discoverable.</source>
        <target state="translated">應無法搜尋到測試匯出。</target>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableMessage">
        <source>'{0}' is exported for test purposes and should be marked with 'PartNotDiscoverableAttribute'</source>
        <target state="translated">匯出 '{0}' 之目的僅供測試之用，因此應標記為 'PartNotDiscoverableAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="TestExportsShouldNotBeDiscoverableTitle">
        <source>Test exports should not be discoverable</source>
        <target state="translated">測試匯出不應為可搜尋的</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableTitle">
        <source>Use 'SpecializedCollections.EmptyEnumerable()'</source>
        <target state="translated">使用 'SpecializedCollections.EmptyEnumerable()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsEmptyEnumerableMessage">
        <source>Use 'SpecializedCollections.EmptyEnumerable()'</source>
        <target state="translated">使用 'SpecializedCollections.EmptyEnumerable()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableTitle">
        <source>Use 'SpecializedCollections.SingletonEnumerable()'</source>
        <target state="translated">使用 'SpecializedCollections.SingletonEnumerable()'</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="UseSpecializedCollectionsSingletonEnumerableMessage">
        <source>Use 'SpecializedCollections.SingletonEnumerable()'</source>
        <target state="translated">使用 'SpecializedCollections.SingletonEnumerable()'</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsTitle">
        <source>Invoke the correct property to ensure correct use site diagnostics</source>
        <target state="translated">請叫用正確的屬性，確保網站診斷的使用正確</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="InvokeTheCorrectPropertyToEnsureCorrectUseSiteDiagnosticsMessage">
        <source>Invoke the correct property to ensure correct use site diagnostics</source>
        <target state="translated">請叫用正確的屬性，確保網站診斷的使用正確</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionTitle">
        <source>Do not use generic 'CodeAction.Create' to create 'CodeAction'</source>
        <target state="translated">請勿使用泛型 'CodeAction.Create' 來建立 'CodeAction'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotUseGenericCodeActionCreateToCreateCodeActionMessage">
        <source>Do not use generic 'CodeAction.Create' to create 'CodeAction'</source>
        <target state="translated">請勿使用泛型 'CodeAction.Create' 來建立 'CodeAction'</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableTitle">
        <source>Override 'Object.Equals(object)' when implementing 'IEquatable'</source>
        <target state="translated">實作 'IEquatable' 時覆寫 'Object.Equals(object)'</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableDescription">
        <source>#N/A</source>
        <target state="translated">#N/A</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideObjectEqualsObjectWhenImplementingIequatableMessage">
        <source>Override 'Object.Equals(object)' when implementing 'IEquatable'</source>
        <target state="translated">實作 'IEquatable' 時覆寫 'Object.Equals(object)'</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsTitle">
        <source>'SymbolDeclaredEvent' must be generated for source symbols</source>
        <target state="translated">必須為來源符號產生 'SymbolDeclaredEvent'</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsDescription">
        <source>Compilation event queue is required to generate symbol declared events for all declared source symbols. Hence, every source symbol type or one of its base types must generate a symbol declared event.</source>
        <target state="translated">必須要有編譯事件佇列，才可為所有宣告的來源符號產生符號宣告事件。因此，每個來源符號類型或它的其中一個基底類型，必須產生符號宣告事件。</target>
        <note />
      </trans-unit>
      <trans-unit id="SymbolDeclaredEventMustBeGeneratedForSourceSymbolsMessage">
        <source>'SymbolDeclaredEvent' must be generated for source symbols</source>
        <target state="translated">必須為來源符號產生 'SymbolDeclaredEvent'</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFTitle">
        <source>Do not mix attributes from different versions of MEF</source>
        <target state="translated">請勿混合來自不同 MEF 版本的屬性</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFDescription">
        <source>Do not mix attributes from different versions of MEF.</source>
        <target state="translated">請勿混合來自不同 MEF 版本的屬性。</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotMixAttributesFromDifferentVersionsOfMEFMessage">
        <source>Attribute '{0}' comes from a different version of MEF than the export attribute on '{1}'</source>
        <target state="translated">屬性 '{0}' 來自與 '{1}' 上的匯出屬性不同的 MEF 版本</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedTitle">
        <source>Parts exported with MEFv2 must be marked with 'SharedAttribute'</source>
        <target state="translated">使用 MEFv2 匯出的組件，必須標記為 'SharedAttribute'</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedDescription">
        <source>Part exported with MEFv2 must be marked with the 'SharedAttribute'.</source>
        <target state="translated">使用 MEFv2 匯出的組件，必須標記為 'SharedAttribute'。</target>
        <note />
      </trans-unit>
      <trans-unit id="PartsExportedWithMEFv2MustBeMarkedAsSharedMessage">
        <source>'{0}' is exported with MEFv2 and hence must be marked with 'SharedAttribute'</source>
        <target state="translated">匯出 '{0}' 時使用的是 MEFv2，因此必須標記為 'SharedAttribute'</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>