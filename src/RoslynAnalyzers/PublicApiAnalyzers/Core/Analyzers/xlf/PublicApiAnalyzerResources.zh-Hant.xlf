<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hant" original="../PublicApiAnalyzerResources.resx">
    <body>
      <trans-unit id="AddAllItemsInDocumentToTheApiTitle">
        <source>Add all items in document '{0}' to the API</source>
        <target state="translated">將文件 '{0}' 中的所有項目新增至 API</target>
        <note />
      </trans-unit>
      <trans-unit id="AddAllItemsInProjectToTheApiTitle">
        <source>Add all items in project '{0}' to the API</source>
        <target state="translated">將專案 '{0}' 中的所有項目新增至 API</target>
        <note />
      </trans-unit>
      <trans-unit id="AddAllItemsInTheSolutionToTheApiTitle">
        <source>Add all items in the solution to the API</source>
        <target state="translated">將解決方案中的所有項目新增至 API</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotateInternalApiDescription">
        <source>All internal types and members should be declared with nullability annotations in InternalAPI.txt. This draws attention to API nullability changes in the code reviews and source control history, and helps prevent breaking changes.</source>
        <target state="translated">應在 InternalAPI.txt 中宣告所有內部類型與成員並加上可 NULL 性註釋。這麼做會讓您注意到程式碼檢閱與原始檔控制歷程記錄中的 API 可 NULL 性變更，同時有助於避免重大變更。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotateInternalApiMessage">
        <source>Symbol '{0}' is missing nullability annotations in the declared API</source>
        <target state="translated">在宣告的 API 中，符號 '{0}' 缺少可為 Null 的註釋</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotateInternalApiTitle">
        <source>Annotate nullability of internal types and members in the declared API</source>
        <target state="translated">標註已宣告 API 中內部類型和成員的可 NULL 性</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotatePublicApiDescription">
        <source>All public types and members should be declared with nullability annotations in PublicAPI.txt. This draws attention to API nullability changes in the code reviews and source control history, and helps prevent breaking changes.</source>
        <target state="translated">在 PublicAPI.txt 中宣告所有公用類型與成員時，應提供可 NULL 性註釋。此動作會引起對程式碼檢閱與原始檔控制記錄中 API 可 NULL 性變更的注意，有助於避免發生中斷性變更。</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotatePublicApiMessage">
        <source>Symbol '{0}' is missing nullability annotations in the declared API</source>
        <target state="translated">在宣告的 API 中，符號 '{0}' 缺少可為 Null 的註釋</target>
        <note />
      </trans-unit>
      <trans-unit id="AnnotatePublicApiTitle">
        <source>Annotate nullability of public types and members in the declared API</source>
        <target state="translated">標註已宣告 API 中公用類型和成員的可 NULL 性</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidMultipleOverloadsWithOptionalParametersMessage">
        <source>Symbol '{0}' violates the backcompat requirement: 'Do not add multiple overloads with optional parameters'. See '{1}' for details.</source>
        <target state="translated">符號 '{0}' 違反回溯相容性需求:「請勿新增具備選擇性參數的多項多載」。請參閱 '{1}' 以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="AvoidMultipleOverloadsWithOptionalParametersTitle">
        <source>Do not add multiple public overloads with optional parameters</source>
        <target state="translated">無法新增多個具有選擇性參數的公用多載</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareInternalApiDescription">
        <source>All internal types and members should be declared in InternalAPI.txt. This draws attention to API changes in the code reviews and source control history, and helps prevent breaking changes.</source>
        <target state="translated">應在 InternalAPI.txt 中宣告所有內部類型與成員。這麼做會讓您注意到程式碼檢閱與原始檔控制歷程記錄中的 API 變更，同時有助於避免重大變更。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareInternalApiMessage">
        <source>Symbol '{0}' is not part of the declared API</source>
        <target state="translated">符號 '{0}' 並非宣告 API 的一部分</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclareInternalApiTitle">
        <source>Add internal types and members to the declared API</source>
        <target state="translated">為宣告的 API 新增公用類型與成員</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclarePublicApiDescription">
        <source>All public types and members should be declared in PublicAPI.txt. This draws attention to API changes in the code reviews and source control history, and helps prevent breaking changes.</source>
        <target state="translated">應在 PublicAPI.txt 中宣告所有公用類型與成員。此舉會讓您注意到程式碼檢閱與原始檔控制歷程記錄中的 API 變更，同時有助於避免發生中斷性變更。</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclarePublicApiMessage">
        <source>Symbol '{0}' is not part of the declared public API</source>
        <target state="translated">符號 '{0}' 並非宣告的公用 API 的一部分</target>
        <note />
      </trans-unit>
      <trans-unit id="DeclarePublicApiTitle">
        <source>Add public types and members to the declared API</source>
        <target state="translated">為宣告的 API 新增公用類型與成員</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateSymbolsInInternalApiFilesMessage">
        <source>The symbol '{0}' appears more than once in the internal API files</source>
        <target state="translated">內部 API 檔案中出現多次符號 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateSymbolsInInternalApiFilesTitle">
        <source>Do not duplicate symbols in internal API files</source>
        <target state="translated">不要複製內部 API 檔案中的符號</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateSymbolsInPublicApiFilesMessage">
        <source>The symbol '{0}' appears more than once in the public API files</source>
        <target state="translated">公用 API 檔案中出現多次符號 '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="DuplicateSymbolsInPublicApiFilesTitle">
        <source>Do not duplicate symbols in public API files</source>
        <target state="translated">請勿在公用 API 檔案中使用重複的符號</target>
        <note />
      </trans-unit>
      <trans-unit id="EnableNullableInProjectToTheApiTitle">
        <source>Enable nullability annotations in the API for project '{0}'</source>
        <target state="translated">啟用 API 中專案 '{0}' 的可 NULL 性註釋</target>
        <note />
      </trans-unit>
      <trans-unit id="EnableNullableInTheSolutionToTheApiTitle">
        <source>Enable nullability annotations in the API for the solution</source>
        <target state="translated">啟用 API 中解決方案的可 NULL 性註釋</target>
        <note />
      </trans-unit>
      <trans-unit id="ExposedNoninstantiableTypeMessage">
        <source>Constructor makes its noninheritable base class inheritable, thereby exposing its protected members</source>
        <target state="translated">建構函式會讓無法繼承的基底類別變成可繼承，進而會公開其受保護的成員</target>
        <note />
      </trans-unit>
      <trans-unit id="ExposedNoninstantiableTypeTitle">
        <source>Constructor make noninheritable base class inheritable</source>
        <target state="translated">建構函式可將無法繼承的基底類別變成為可繼承</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplicitConstructorErrorMessageName">
        <source>implicit constructor for '{0}'</source>
        <target state="translated">'{0}' 的隱含建構函式</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplicitGetAccessor">
        <source>implicit get-accessor for '{0}'</source>
        <target state="translated">'{0}' 的隱含 get 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="ImplicitSetAccessor">
        <source>implicit set-accessor for '{0}'</source>
        <target state="translated">'{0}' 的隱含 set 存取子</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalApiFileMissingMessage">
        <source>Internal API file '{0}' is missing or not marked as an additional analyzer file</source>
        <target state="translated">遺失內部 API 檔案 '{0}'，或未將其標示為額外的分析器檔案</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalApiFileMissingTitle">
        <source>Missing shipped or unshipped internal API file</source>
        <target state="translated">遺失隨附或未隨附的內部 API 檔案</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalApiFilesInvalidMessage">
        <source>The contents of the internal API files are invalid: {0}</source>
        <target state="translated">內部 API 檔案的內容無效: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalApiFilesInvalidTitle">
        <source>The contents of the internal API files are invalid</source>
        <target state="translated">內部 API 檔案的內容無效</target>
        <note />
      </trans-unit>
      <trans-unit id="ObliviousInternalApiDescription">
        <source>All internal members should use either nullable or non-nullable reference types, but no oblivious reference types.</source>
        <target state="translated">所有內部成員都應使用可為 Null 或不可為 Null 的參考類型，但不可使用無警示的參考類型。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObliviousInternalApiMessage">
        <source>Symbol '{0}' uses some oblivious reference types</source>
        <target state="translated">符號 '{0}' 使用了部分無必要的參考型別</target>
        <note />
      </trans-unit>
      <trans-unit id="ObliviousInternalApiTitle">
        <source>Internal members should not use oblivious types</source>
        <target state="translated">內部成員不應使用無警示的類型</target>
        <note />
      </trans-unit>
      <trans-unit id="ObliviousPublicApiDescription">
        <source>All public members should use either nullable or non-nullable reference types, but no oblivious reference types.</source>
        <target state="translated">所有公開成員都應使用可為 Null 或不可為 Null 的參考型別，但不可使用無警示的參考型別。</target>
        <note />
      </trans-unit>
      <trans-unit id="ObliviousPublicApiMessage">
        <source>Symbol '{0}' uses some oblivious reference types</source>
        <target state="translated">符號 '{0}' 使用了部分無必要的參考型別</target>
        <note />
      </trans-unit>
      <trans-unit id="ObliviousPublicApiTitle">
        <source>Public members should not use oblivious types</source>
        <target state="translated">公開成員不應使用無警示類型</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadWithOptionalParametersShouldHaveMostParametersMessage">
        <source>'{0}' violates the backcompat requirement: 'API with optional parameter(s) should have the most parameters amongst its public overloads'. See '{1}' for details.</source>
        <target state="translated">'{0}' 違反回溯相容性需求:「具有選擇性參數的 API，大部分的參數應位於其公用多載之間」。請參閱 '{1}' 以取得詳細資料。</target>
        <note />
      </trans-unit>
      <trans-unit id="OverloadWithOptionalParametersShouldHaveMostParametersTitle">
        <source>API with optional parameter(s) should have the most parameters amongst its public overloads</source>
        <target state="translated">具有選擇性參數的 API，大部分的參數應位於其公用多載之間</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicApiFileMissingMessage">
        <source>Public API file '{0}' is missing or not marked as an additional analyzer file</source>
        <target state="translated">遺失公用 API 檔案 '{0}'，或未將其標示為額外的分析器檔案</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicApiFileMissingTitle">
        <source>Missing shipped or unshipped public API file</source>
        <target state="translated">遺失隨附或未隨附的公用 API 檔案</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicApiFilesInvalidMessage">
        <source>The contents of the public API files are invalid: {0}</source>
        <target state="translated">公用 API 檔案的內容無效: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="PublicApiFilesInvalidTitle">
        <source>The contents of the public API files are invalid</source>
        <target state="translated">公用 API 檔案的內容無效</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveDeletedInternalApiDescription">
        <source>When removing a internal type or member, put that entry in InternalAPI.Unshipped.txt with '*REMOVED*' prefix. This draws attention to API changes in the code reviews and source control history, and helps prevent breaking changes.</source>
        <target state="translated">移除內部類型或成員時，請將該項目放在 InternalAPI.Unshipped.txt 中並包含 '*REMOVED*' 前置詞。這麼做會讓您注意到程式碼檢閱與原始檔控制歷程記錄中的 API 變更，同時有助於避免重大變更。</target>
        <note>{Locked="*REMOVED*"}</note>
      </trans-unit>
      <trans-unit id="RemoveDeletedInternalApiMessage">
        <source>Symbol '{0}' is part of the declared internal API, but is either not internal or could not be found</source>
        <target state="translated">符號 '{0}' 是宣告的內部 API 的一部分，但可能非內部或找不到</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveDeletedInternalApiTitle">
        <source>Remove deleted types and members from the declared internal API</source>
        <target state="translated">從宣告的內部 API 移除已刪除的類型和成員</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveDeletedPublicApiDescription">
        <source>When removing a public type or member, put that entry in PublicAPI.Unshipped.txt with '*REMOVED*' prefix. This draws attention to API changes in the code reviews and source control history, and helps prevent breaking changes.</source>
        <target state="translated">移除公用類型或成員時，請將該項目放在 PublicAPI.Unshipped.txt 中並包含 '*REMOVED*' 前置詞。如此會讓您注意到在程式碼檢閱以及原始檔控制歷程記錄中 API 的變更，同時有助於避免發生中斷性變更。</target>
        <note>{Locked="*REMOVED*"}</note>
      </trans-unit>
      <trans-unit id="RemoveDeletedPublicApiMessage">
        <source>Symbol '{0}' is part of the declared API, but is either not public or could not be found</source>
        <target state="translated">符號 '{0}' 是宣告 API 的一部分，但可能找不到或並非公用</target>
        <note />
      </trans-unit>
      <trans-unit id="RemoveDeletedPublicApiTitle">
        <source>Remove deleted types and members from the declared API</source>
        <target state="translated">從宣告的 API 移除已刪除的類型與成員</target>
        <note />
      </trans-unit>
      <trans-unit id="RemovedApiIsNotActuallyRemovedMessage">
        <source>Symbol '{0}' is marked as removed but it isn't deleted in source code</source>
        <target state="translated">符號 '{0}' 標記為已移除，但未在原始程式碼中刪除</target>
        <note />
      </trans-unit>
      <trans-unit id="RemovedApiIsNotActuallyRemovedTitle">
        <source>API is marked as removed but it exists in source code</source>
        <target state="translated">API 標記為已移除，但存在於原始程式碼中</target>
        <note />
      </trans-unit>
      <trans-unit id="ShouldAnnotateInternalApiFilesDescription">
        <source>InternalAPI.txt files should have `#nullable enable` to track nullability information, or this diagnostic should be suppressed. With nullability enabled, InternalAPI.txt records which types are nullable (suffix `?` on type) or non-nullable (suffix `!`). It also tracks any API that is still using an oblivious reference type (prefix `~` on line).</source>
        <target state="translated">InternalAPI.txt 檔案應該具備 `#nullable enable`，才能追蹤可為 NULL 的資訊，否則應隱藏此診斷。若啟用可為 NULL，InternalAPI.txt 便能記錄可為 Null (類型的尾碼為 `?`) 或不可為 Null (尾碼為 `!`) 的類型。其也會追蹤仍在使用無警示參考類型的任何 API (行的首碼為 `~`)。</target>
        <note />
      </trans-unit>
      <trans-unit id="ShouldAnnotateInternalApiFilesMessage">
        <source>InternalAPI.txt is missing '#nullable enable', so the nullability annotations of API isn't recorded. It is recommended to enable this tracking.</source>
        <target state="translated">InternalAPI.txt 遺失 '#nullable enable'，因此未記錄 API 的可 NULL 性註釋。建議啟用此追蹤。</target>
        <note />
      </trans-unit>
      <trans-unit id="ShouldAnnotateInternalApiFilesTitle">
        <source>Enable tracking of nullability of reference types in the declared API</source>
        <target state="translated">在宣告 API 中啟用參考型別的可為 Null 追蹤</target>
        <note />
      </trans-unit>
      <trans-unit id="ShouldAnnotatePublicApiFilesDescription">
        <source>PublicAPI.txt files should have `#nullable enable` to track nullability information, or this diagnostic should be suppressed. With nullability enabled, PublicAPI.txt records which types are nullable (suffix `?` on type) or non-nullable (suffix `!`). It also tracks any API that is still using an oblivious reference type (prefix `~` on line).</source>
        <target state="translated">PublicAPI.txt 檔案必須具備 '#nullable enable'，才能追蹤可為 NULL 的資訊，否則應隱藏此診斷。若啟用可為 NULL，PublicAPI.txt 便能記錄型可為 Null (類型的尾碼為 '?') 或不可為 Null (尾碼為 '!') 的類型。其也會追蹤仍在使用未經察覺之參考型別的任何 API (行的首碼為 '~')。</target>
        <note />
      </trans-unit>
      <trans-unit id="ShouldAnnotatePublicApiFilesMessage">
        <source>PublicAPI.txt is missing '#nullable enable', so the nullability annotations of API isn't recorded. It is recommended to enable this tracking.</source>
        <target state="translated">PublicAPI.txt 缺少 '#nullable enable'，因此未記錄 API 的可 NULL 性註釋。建議啟用此追蹤。</target>
        <note />
      </trans-unit>
      <trans-unit id="ShouldAnnotatePublicApiFilesTitle">
        <source>Enable tracking of nullability of reference types in the declared API</source>
        <target state="translated">在宣告 API 中啟用參考型別的可為 Null 追蹤</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>