' Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

'-----------------------------------------------------------------------------------------------------------
' This is the code that actually outputs the VB code that defines the tree. It is passed a read and validated
' ParseTree, and outputs the code to defined the node classes for that tree, and also additional data
' structures like the kinds, visitor, etc.
'-----------------------------------------------------------------------------------------------------------

Imports System.IO
Imports exts

Public Class TestWriter
    Inherits WriteUtils

    Private ReadOnly _checksum As String
    Private _writer As TextWriter    'output is sent here.
    Private Const s_externalSourceDirectiveString As String = "ExternalSourceDirective"

    ' Initialize the class with the parse tree to write.
    Public Sub New(parseTree As ParseTree, checksum As String)
        MyBase.New(parseTree)
        _checksum = checksum
    End Sub

    ' Write out the code defining the tree to the give file.
    Public Sub WriteTestCode(writer As TextWriter)
        _writer = writer

        GenerateFile()
    End Sub

    Private Sub GenerateFile()
        _writer.WriteLine(
$"' Tests for parse trees.
' Generated by a tool from SHA256 content {_checksum}
' DO NOT HAND EDIT
")

        GenerateNamespace()
    End Sub

    Private Sub GenerateNamespace()
        With _writer
            .WriteLine(
"
Namespace Microsoft.CodeAnalysis.VisualBasic.UnitTests

Partial Public Class GeneratedTests

#region ""Green Factory Calls""")
            GenerateFactoryCalls(True)
 .WriteLine(
"#end region

#region ""Green Factory Tests""")
            GenerateFactoryCallTests(True)
            .WriteLine(
"#end region

#region ""Green Rewriter Tests""")
            GenerateRewriterTests(True)
            .WriteLine(
"#end region

#region ""Green Visitor Tests""")
            GenerateVisitorTests(True)
            .WriteLine(
"#end region

#region ""Red Factory Calls""")
            GenerateFactoryCalls(False)
            .WriteLine(
"#end region

#region ""Red Factory Tests""")
            GenerateFactoryCallTests(False)
.WriteLine(
"#end region

#region ""Red Rewriter Tests""")
            GenerateRewriterTests(False)
.WriteLine(
"#end region

End Class
End Namespace")
        End With
    End Sub

    Private Sub GenerateFactoryCalls(isGreen As Boolean)
        For Each nodeStructure In _parseTree.NodeStructures.Values
            If Not nodeStructure.Abstract AndAlso Not nodeStructure.NoFactory Then

                If nodeStructure.Name.IsNoneOf("KeywordSyntax", "PunctuationSyntax") Then
                    GenerateFactoryCall(isGreen, nodeStructure)
                End If
            End If
        Next
    End Sub

    Private Sub GenerateFactoryCall(isGreen As Boolean, nodeStructure As ParseNodeStructure)
        For Each kind In nodeStructure.NodeKinds
            GenerateFactoryCall(isGreen, nodeStructure, kind)
        Next

        'If nodeStructure.NodeKinds.Count > 1 Then
        '    GenerateFactoryCall(isGreen, nodeStructure, Nothing)
        'End If

    End Sub

    Private Sub GenerateFactoryCall(isGreen As Boolean, nodeStructure As ParseNodeStructure, nodeKind As ParseNodeKind)
        If nodeKind.Name = "AttributeTarget" AndAlso Not isGreen Then
            Dim x = 0
        End If

        If nodeKind.Name.Contains(s_externalSourceDirectiveString) Then
            Return ' check for fix
        End If

        Dim namespacePrefix As String = If(isGreen, "InternalSyntax.", String.Empty)

        With _writer
            .Write("        Private Shared Function ")

            Dim functionName As String = If(nodeKind Is Nothing, FactoryName(nodeStructure), FactoryName(nodeKind))

            .Write(If(isGreen, "GenerateGreen", "GenerateRed"))
            .Write(functionName)
            If isGreen Then
                .WriteLine($"() As {namespacePrefix}{nodeStructure.Name}")
            Else
                If nodeStructure.IsToken Then
                    .WriteLine("() As SyntaxToken")
                ElseIf nodeStructure.IsTrivia Then
                    .WriteLine("() As SyntaxTrivia")
                Else
                    .WriteLine($"() As {StructureTypeName(nodeStructure)}")
                End If
            End If

            Dim first As Boolean = True

            Dim callTokens As New List(Of String)()
            Dim anePositions As New List(Of Integer)()
            Dim aePositions As New List(Of Integer)()
            Dim KindNonePositions As New List(Of Integer)()

            Dim currentLine = 1

            callTokens.Add($"{namespacePrefix}SyntaxFactory.{If(nodeKind Is Nothing, nodeStructure.Name, nodeKind.Name)}(")

            If nodeStructure.IsToken Then

                If isGreen Then
                    If nodeStructure.IsTerminal Then
                        callTokens.Add("String.Empty")
                        first = False
                    End If
                Else
                    If Not first Then callTokens.Add(", ")
                    first = False

                    callTokens.Add($"{namespacePrefix}SyntaxFactory.TriviaList(SyntaxFactory.SyntaxTrivia(SyntaxKind.WhitespaceTrivia, "" ""))")

                    'If nodeStructure.Name.Contains("Xml") Then
                    '    callTokens.Add("String.Empty")
                    '    first = False
                    'End If
                    With nodeKind.Name
                        If .EndsWith("LiteralToken", StringComparison.Ordinal) OrElse
                           .EndsWith("XmlNameToken", StringComparison.Ordinal) OrElse
                           .EndsWith("DocumentationCommentLineBreakToken", StringComparison.Ordinal) OrElse
                           nodeKind.Name = "InterpolatedStringTextToken" _
                        Then
                            If Not first Then callTokens.Add(", ")
                            callTokens.Add("String.Empty")
                            first = False
                        End If
                    End With
                End If

                Dim fields = GetAllFieldsOfStructure(nodeStructure)

                For Each field In fields

                    If Not first Then callTokens.Add(", ")
                    first = False

                    Dim fieldType = FieldTypeRef(field)
                    callTokens.Add(GetInitValueForType(fieldType))

                Next

                If Not first Then callTokens.Add(", ")
                first = False

                If isGreen Then
                    callTokens.Add(namespacePrefix & "SyntaxFactory.SyntaxTrivia(SyntaxKind.WhitespaceTrivia, "" ""), ")
                    callTokens.Add(namespacePrefix & "SyntaxFactory.SyntaxTrivia(SyntaxKind.WhitespaceTrivia, "" ""))")
                Else
                    callTokens.Add(namespacePrefix & "SyntaxFactory.TriviaList(SyntaxFactory.SyntaxTrivia(SyntaxKind.WhitespaceTrivia, "" "")))")
                End If

                If isGreen Then
                    .Write("            return ")
                    callTokens.ForEach(AddressOf _writer.Write)
                    .WriteLine()
                Else
                    .WriteLine("            Dim exceptionTest as boolean = false")

                    For exceptionChecks = 0 To anePositions.Count - 1

                        .WriteLine("            Try")

                        For i = 0 To callTokens.Count - 1
                            If (i <> anePositions(exceptionChecks)) Then
                                .Write(callTokens(i))
                            Else
                                .Write("Nothing")
                            End If
                        Next

                        WriteCatchOfException()
                    Next

                    ' quick hack to cover more code in keyword factories ...
                    If nodeStructure.IsTerminal AndAlso Not nodeStructure.IsTrivia AndAlso nodeStructure.Name = "KeywordSyntax" Then

                        .Write("            Dim node1 = ")
                        For i = 0 To callTokens.Count - 1
                            .Write(callTokens(i))
                            If i = 0 Then _writer.Write("String.Empty, ")
                        Next i
                        .WriteLine()

                        .Write("            dim node2 = ")
                        callTokens.ForEach(AddressOf _writer.Write)
                        .WriteLine("
            Debug.Assert(node1.GetText() = String.Empty)
            Debug.Assert(node2.GetText() <> String.Empty)
")
                        ' make parameter = nothing to cause exceptions
                        .WriteLine("            Try
            exceptionTest = false")

                        For i = 0 To callTokens.Count - 1
                            .Write(callTokens(i))
                            If i = 0 Then _writer.Write("Nothing, ")
                        Next i
                        .WriteLine("
            catch e as ArgumentNullException
            exceptionTest = true
            End Try
            Debug.Assert(exceptionTest)
            return node2")
                    Else
                        .Write("            return ")
                        callTokens.ForEach(AddressOf _writer.Write)
                        .WriteLine()

                    End If

                End If

            Else

                Dim children = GetAllFactoryChildrenOfStructure(nodeStructure)

                If nodeStructure.IsTrivia Then
                    callTokens.Add("String.Empty")
                    anePositions.Add(callTokens.Count - 1)
                    first = False
                End If

                For Each child In children
                    If Not first Then
                        callTokens.Add(", ")
                    End If

                    If child.IsOptional Then
                        ' Hack: remove when the factory methods have been fixed to not contain overloads.
                        If nodeStructure.Name = "MemberAccessExpressionSyntax" Then
                            If first Then
                                callTokens.Add(String.Format("CType(Nothing, {0}{1})", namespacePrefix, ChildFieldTypeRef(child)))
                            End If
                        Else
                            callTokens.Add("Nothing")
                        End If

                        ' TODO: remove
                        first = False

                        Continue For
                    End If

                    ' TODO: move up.
                    first = False

                    Dim childNodeKind As ParseNodeKind = If(Not child Is Nothing, TryCast(child.ChildKind, ParseNodeKind), Nothing)

                    If TypeOf child.ChildKind Is List(Of ParseNodeKind) Then childNodeKind = child.ChildKind(nodeKind.Name)

                    childNodeKind = If(childNodeKind, DirectCast(child.ChildKind, List(Of ParseNodeKind)).Item(0))

                    If child.IsList AndAlso child.IsSeparated Then
                        Dim childKindStructure = child.ParseTree.NodeStructures(childNodeKind.StructureId)
                        childKindStructure = If(Not childKindStructure.ParentStructure Is Nothing, childKindStructure.ParentStructure, childKindStructure)
                        callTokens.Add($"New {ChildFactoryTypeRef(nodeStructure, child, isGreen, True)}()")
                    Else
                        Dim structureOfchild = child.ParseTree.NodeStructures(childNodeKind.StructureId)
                        If structureOfchild.Name = "PunctuationSyntax" OrElse structureOfchild.Name = "KeywordSyntax" Then

                            If isGreen Then
                                callTokens.Add($"new InternalSyntax.{structureOfchild.Name}(")
                                callTokens.Add($"SyntaxKind.{childNodeKind.Name}, String.Empty, Nothing, Nothing)")
                            Else
                                Dim token = $"SyntaxFactory.Token(SyntaxKind.{childNodeKind.Name})"
                                If child.IsList Then
                                    token = $"SyntaxTokenList.Create({token})"
                                End If
                                callTokens.Add(token)

                                ' add none kind here
                                If Not TypeOf child.ChildKind Is List(Of ParseNodeKind) Then
                                    If child.IsOptional Then KindNonePositions.Add(callTokens.Count - 1)
                                Else
                                    If Not child.IsList Then aePositions.Add(callTokens.Count - 1)
                                End If
                            End If
                        Else
                            If isGreen Then
                                callTokens.Add($"GenerateGreen{FactoryName(childNodeKind)}()")
                            Else
                                Dim result = $"GenerateRed{FactoryName(childNodeKind)}()"
                                If structureOfchild.IsToken AndAlso child.IsList Then
                                    result = $"SyntaxTokenList.Create({result})"
                                ElseIf child.IsSeparated Then
                                    result = $"SyntaxFactory.SingletonSeparatedList(Of {BaseTypeReference(child)}({result})"
                                ElseIf child.IsList Then
                                    result = $"SyntaxFactory.SingletonList(Of {BaseTypeReference(child)})({result})"
                                End If
                                callTokens.Add(result)
                            End If
                        End If

                        If Not KindTypeStructure(child.ChildKind).IsToken AndAlso Not child.IsList Then
                            anePositions.Add(callTokens.Count - 1)
                        ElseIf KindTypeStructure(child.ChildKind).IsToken And Not child.IsList Then
                            aePositions.Add(callTokens.Count - 1)
                        End If
                    End If
                Next

                callTokens.Add(")")

                ' TODO: remove extra conditions
                If isGreen OrElse nodeStructure.Name.IsAnyOf("CaseBlockSyntax", "IfPartSyntax", "MultiLineIfBlockSyntax") Then
                    .Write("            return ")
                    callTokens.ForEach(AddressOf _writer.Write)
                    .WriteLine()
                Else
                    _writer.WriteLine("            Dim exceptionTest as boolean = false")

                    WriteExceptionChecks0(callTokens, aePositions)

                    WriteExceptionChecks1(callTokens, aePositions)

                    WriteKindNodePositiions(callTokens, KindNonePositions)

                    .Write("            return ")
                    callTokens.ForEach(AddressOf _writer.Write)
                    .WriteLine()
                End If

            End If

            .WriteLine("        End Function")
            .WriteLine()
        End With
    End Sub

    Private Sub WriteCatchOfException()
        _writer.WriteLine("
            catch e as ArgumentNullException
            exceptionTest = true
            End Try
            Debug.Assert(exceptionTest)
            exceptionTest = false
")
    End Sub

    Private Sub WriteExceptionChecks(other As String, callTokens As List(Of String), anePositions As List(Of Integer))
        With _writer
            For exceptionChecks = 0 To anePositions.Count - 1

                .WriteLine("            Try")

                .Write("            ")
                For i = 0 To callTokens.Count - 1
                    If (i <> anePositions(exceptionChecks)) Then
                        _writer.Write(callTokens(i))
                    Else
                        _writer.Write(other)
                    End If
                Next
                WriteCatchOfException()
            Next
        End With
    End Sub

    Private Sub WriteExceptionChecks0(callTokens As List(Of String), anePositions As List(Of Integer))
        WriteExceptionChecks("Nothing", callTokens, anePositions)
    End Sub

    Private Sub WriteExceptionChecks1(callTokens As List(Of String), anePositions As List(Of Integer))
        ' this syntaxtoken should not be legal anywhere in the tests
        WriteExceptionChecks("SyntaxFactory.Token(SyntaxKind.ExternalSourceKeyword)", callTokens, anePositions)
    End Sub

    Private Sub WriteKindNodePositiions(callTokens As List(Of String), KindNonePositions As List(Of Integer))
        For exceptionChecks = 0 To KindNonePositions.Count - 1
            _writer.Write("            ")
            For i = 0 To callTokens.Count - 1
                If (i <> KindNonePositions(exceptionChecks)) Then
                    _writer.Write(callTokens(i))
                Else
                    _writer.Write("New SyntaxToken(Nothing, New InternalSyntax.KeywordSyntax(SyntaxKind.None, Nothing, Nothing, """", Nothing, Nothing), 0, 0)")
                End If
            Next
            _writer.WriteLine()
            _writer.WriteLine()
        Next
    End Sub

    Private Sub GenerateFactoryCallTests(isGreen As Boolean)
        For Each nodeStructure In _parseTree.NodeStructures.Values
            If Not nodeStructure.Abstract AndAlso Not nodeStructure.NoFactory Then
                If nodeStructure.Name.IsNoneOf("KeywordSyntax", "PunctuationSyntax") Then
                    GenerateFactoryCallTest(isGreen, nodeStructure)
                End If
            End If
        Next
    End Sub

    Private Sub GenerateFactoryCallTest(isGreen As Boolean, nodeStructure As ParseNodeStructure)
        For Each kind In nodeStructure.NodeKinds
            GenerateFactoryCallTest(isGreen, nodeStructure, kind)
        Next
    End Sub

    Private Sub GenerateFactoryCallTest(isGreen As Boolean, nodeStructure As ParseNodeStructure, nodeKind As ParseNodeKind)

        If nodeKind.Name.Contains(s_externalSourceDirectiveString) Then Return ' check for fix

        Dim funcNamePart = If(isGreen, "Green", "Red"), _factoryName = FactoryName(nodeKind)
        With _writer

            .WriteLine(
$"        <Fact>
        Public Sub Test{funcNamePart}{_factoryName}()
            dim objectUnderTest = Generate{funcNamePart}{_factoryName}()")

            'Dim children = GetAllChildrenOfStructure(nodeStructure)
            If isGreen Then
                .WriteLine("            AttachAndCheckDiagnostics(objectUnderTest)")
            Else
                Dim withStat As New Text.StringBuilder()
                For Each child In GetAllChildrenOfStructure(nodeStructure)
                    If Not child.IsOptional Then
                        .WriteLine($"            Assert.NotNull(objectUnderTest.{LowerFirstCharacter(child.Name)})")
                    End If
                    withStat.AppendLine($".With{ child.Name}(objectUnderTest.{child.Name})")
                Next
                If withStat.Length > 0 Then
                    .WriteLine($"            Dim withObj = objectUnderTest{withStat.ToString}
             Assert.Equal(withobj, objectUnderTest)")
                End If
            End If

            .WriteLine("        End Sub")
            .WriteLine()
        End With
    End Sub

    Private Sub GenerateRewriterTests(isGreen As Boolean)
        For Each nodeStructure In _parseTree.NodeStructures.Values
            If Not nodeStructure.Abstract AndAlso Not nodeStructure.NoFactory AndAlso Not nodeStructure.IsToken AndAlso Not nodeStructure.IsTrivia Then
                GenerateRewriterTest(isGreen, nodeStructure)
            End If
        Next
    End Sub

    Private Sub GenerateRewriterTest(isGreen As Boolean, nodeStructure As ParseNodeStructure)
        For Each kind In nodeStructure.NodeKinds
            GenerateRewriterTest(isGreen, nodeStructure, kind)
        Next
    End Sub

    Private Sub GenerateRewriterTest(isGreen As Boolean, nodeStructure As ParseNodeStructure, nodeKind As ParseNodeKind)

        If nodeKind.Name.Contains(s_externalSourceDirectiveString) Then Return ' check for fix

        Dim funcNamePart = If(isGreen, "Green", "Red"), _factoryName = FactoryName(nodeKind)
        With _writer
            .WriteLine(
$"        <Fact>
        Public Sub Test{funcNamePart}{_factoryName}Rewriter()
            Dim oldNode = Generate{funcNamePart}{_factoryName}()
            Dim rewriter = New {funcNamePart}IdentityRewriter()
            Dim newNode = rewriter.Visit(oldNode)
            Assert.Equal(oldNode, newNode)
        End Sub
")
        End With
    End Sub

    Private Sub GenerateVisitorTests(isGreen As Boolean)
        For Each nodeStructure In _parseTree.NodeStructures.Values
            If Not nodeStructure.Abstract AndAlso
               Not nodeStructure.NoFactory AndAlso
               Not nodeStructure.IsToken AndAlso
               Not nodeStructure.IsTrivia Then
                GenerateVisitorTest(isGreen, nodeStructure)
            End If
        Next
    End Sub

    Private Sub GenerateVisitorTest(isGreen As Boolean, nodeStructure As ParseNodeStructure)
        For Each kind In nodeStructure.NodeKinds
            GenerateVisitorTest(isGreen, nodeStructure, kind)
        Next
    End Sub

    Private Sub GenerateVisitorTest(isGreen As Boolean, nodeStructure As ParseNodeStructure, nodeKind As ParseNodeKind)

        If nodeKind.Name.Contains(s_externalSourceDirectiveString) Then Return ' check for fix

        Dim funcNamePart = If(isGreen, "Green", "Red"), _factoryName = FactoryName(nodeKind)
        With _writer
            .WriteLine(
$"        <Fact>
        Public Sub Test{funcNamePart & _factoryName}Visitor()
            Dim oldNode = Generate{funcNamePart & _factoryName}()
            Dim visitor = New {funcNamePart}NodeVisitor()
            visitor.Visit(oldNode)
        End Sub
")
        End With
    End Sub

    Public Function GetInitValueForType(fieldType As String) As String
        Select Case fieldType
            Case "Integer"
                Return "23"
            Case "String"
                Return """Bar"""
            Case "Char"
                Return """E""C"
            Case "DateTime"
                Return "New DateTime(2008,11,04)"
            Case "System.Decimal"
                Return "42"
            Case "TypeCharacter"
                Return "TypeCharacter.DecimalLiteral"
            Case "SyntaxKind"
                Return "SyntaxKind.IdentifierName"
            Case Else
                Return "Unknown Type"
        End Select
    End Function

    Public Sub AddHandwrittenFactoryCall(baseType As String)
        With _writer
            Select Case baseType
                Case "IdentifierTokenSyntax"
                    .Write("new InternalSyntax.SimpleIdentifierSyntax(SyntaxKind.IdentifierToken, Nothing, Nothing, ""text"",")
                Case "IntegerLiteralTokenSyntax"
                    .Write("new InternalSyntax.IntegerLiteralToken(""42"", LiteralBase.Decimal, TypeCharacter.None, 42,")
                Case Else
                    Exit Sub
            End Select
            .Write("InternalSyntax.SyntaxFactory.SyntaxTrivia(SyntaxKind.WhitespaceTrivia, "" ""), ")
            .Write("InternalSyntax.SyntaxFactory.SyntaxTrivia(SyntaxKind.WhitespaceTrivia, "" ""))")
        End With
    End Sub

End Class
