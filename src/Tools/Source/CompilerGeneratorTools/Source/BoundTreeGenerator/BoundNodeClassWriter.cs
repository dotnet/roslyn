// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace BoundTreeGenerator
{
    internal enum TargetLanguage
    {
        VB,
        CSharp
    }

    internal enum NullHandling
    {
        Allow,
        Disallow,
        Always,
        NotApplicable // for value types
    }

    internal abstract class BoundNodeClassWriter
    {
        protected readonly TextWriter _writer;
        protected readonly Tree _tree;
        protected readonly Dictionary<string, string> _typeMap;
        protected Dictionary<string, bool> _valueTypes;
        protected readonly TargetLanguage _targetLang;

        internal BoundNodeClassWriter(TextWriter writer, Tree tree, TargetLanguage targetLang)
        {
            _writer = writer;
            _tree = tree;
            _targetLang = targetLang;
            _typeMap = tree.Types.Where(t => !(t is EnumType || t is ValueType)).ToDictionary(n => n.Name, n => n.Base);
            _typeMap.Add(tree.Root, null);

            InitializeValueTypes();
        }

        virtual protected void InitializeValueTypes(ref Dictionary<string, bool> _valueTypes) { }

        protected void InitializeValueTypes()
        {
            _valueTypes = new Dictionary<string, bool>();
            foreach (ValueType t in _tree.Types.Where(t => t is ValueType))
                _valueTypes.Add(t.Name, true);
            InitializeValueTypes(ref _valueTypes);

            _valueTypes.Add("Int8", true);
            _valueTypes.Add("Int16", true);
            _valueTypes.Add("Int32", true);
            _valueTypes.Add("Int64", true);
            _valueTypes.Add("UInt8", true);
            _valueTypes.Add("UInt16", true);
            _valueTypes.Add("UInt32", true);
            _valueTypes.Add("UInt64", true);
            _valueTypes.Add("ImmutableArray", true);
            _valueTypes.Add("PropertyAccessKind", true);
        }


        public static void Write(TextWriter writer, Tree tree, TargetLanguage targetLang)
        {
            switch (targetLang)
            {
                case TargetLanguage.CSharp: new BoundNodeClassWriter_CS(writer, tree).WriteFile(); break;
                case TargetLanguage.VB:     new BoundNodeClassWriter_VB(writer, tree).WriteFile(); break;
                default:
                    throw new ArgumentException("Unexpected target language", nameof(_targetLang));
            }
        }

        protected int _indent;
        protected bool _needsIndent = true;

        protected void Write(string text)
        {
            if (_needsIndent)
            {
                _writer.Write(new string(' ', _indent * 4));
                _needsIndent = false;
            }
            _writer.Write(text);
        }
        protected void WriteLine(string text)
        {
            Write(text);
            _writer.WriteLine();
            _needsIndent = true;
        }
        protected void Blank()
        {
            _writer.WriteLine();
            _needsIndent = true;
        }

        protected void Brace()
        {
            WriteLine("{{");
            Indent();
        }

        protected void Unbrace()
        {
            Outdent();
            WriteLine("}}");
        }

        protected void Indent() => ++_indent;

        protected void Outdent() => --_indent;

        protected virtual void Write_AutoGenerated() => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected void WriteFile()
        {
            Write_AutoGenerated();

            Blank();
            WriteUsing("System");
            WriteUsing("System.Collections");
            WriteUsing("System.Collections.Generic");
            WriteUsing("System.Collections.Immutable");
            WriteUsing("System.Diagnostics");
            WriteUsing("System.Linq");
            WriteUsing("System.Runtime.CompilerServices");
            WriteUsing("System.Threading");
            WriteUsing("System.Text");
            WriteUsing("Microsoft.CodeAnalysis.Collections");
            WriteUsing("Roslyn.Utilities");

            Blank();
            WriteStartNamespace();
            WriteKinds();
            WriteTypes();
            WriteVisitor();
            WriteWalker();
            WriteRewriter();
            WriteTreeDumperNodeProducer();
            WriteEndNamespace();
        }

        protected virtual void WriteUsing(string nsName) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected virtual void WriteStartNamespace() => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected virtual void WriteEndNamespace() => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected virtual void WriteKinds() => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected void WriteTypes()
        {
            foreach (var node in _tree.Types.Where(n => !(n is PredefinedNode)))
            {
                Blank();
                WriteType(node);
            }
        }

        protected bool CanBeSealed(TreeType node)
        {
            // Is this type the base type of anything?
            return !_typeMap.Values.Contains(node.Name);
        }

        protected virtual void WriteClassHeader(TreeType node) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected virtual void WriteClassFooter(TreeType node) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected void Paren() => Write("(");

        protected void UnParen() => Write(")");

        protected void SeparatedList<T>(string separator, IEnumerable<T> items, Func<T, string> func)
        {
            var first = true;
            foreach (T item in items)
            {
                if (!first) _writer.Write(separator);
                first = false;
                _writer.Write(func(item));
            }
        }

        protected void Comma<T>(IEnumerable<T> items, Func<T, string> func) => SeparatedList(", ", items, func);

        protected virtual void Or<T>(IEnumerable<T> items, Func<T, string> func) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected void ParenList<T>(IEnumerable<T> items, Func<T, string> func)
        {
            Paren();
            Comma(items, func);
            UnParen();
        }

        protected void ParenList(IEnumerable<string> items)
        {
            Paren();
            Comma(items, x => x);
            UnParen();
        }

        protected void WriteConstructor(TreeType node, bool isPublic, bool hasChildNodes)
        {
            if (hasChildNodes)
            {
                WriteConstructorWithHasErrors(node, isPublic, hasErrorsIsOptional: true);
            }
            else
            {
                WriteConstructorWithHasErrors(node, isPublic, hasErrorsIsOptional: false);
                WriteConstructorWithoutHasErrors(node, isPublic);
            }
        }

        protected virtual void WriteConstructorWithHasErrors(TreeType node, bool isPublic, bool hasErrorsIsOptional) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        // This constructor should only be created if no node or list fields, since it just calls base class constructor
        // without merging hasErrors.
        protected virtual void WriteConstructorWithoutHasErrors(TreeType node, bool isPublic) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected virtual void WriteNullCheck(bool isROArray, Field field) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        // Write the null checks for any fields that can't be null.
        protected void WriteNullChecks(TreeType node)
        {
            IEnumerable<Field> nullCheckFields = AllFields(node).Where(f => FieldNullHandling(node, f.Name) == NullHandling.Disallow);

            if (nullCheckFields.Any())
            {
                Blank();

                foreach (Field field in nullCheckFields)
                {
                    bool isROArray = (GetGenericType(field.Type) == "ImmutableArray");
                    WriteNullCheck(isROArray, field);
                }

                Blank();
            }
        }

        protected static IEnumerable<Field> Fields(TreeType node)
        {
            if (node is Node nn)          return from n in nn.Fields where !n.Override select n;
            if (node is AbstractNode an)  return from n in an.Fields where !n.Override select n;
            return Enumerable.Empty<Field>();
        }

        protected static IEnumerable<Field> FieldsIncludingOverrides(TreeType node)
        {
            if (node is Node n)           return n.Fields;
            if (node is AbstractNode an)  return an.Fields;
            return Enumerable.Empty<Field>();
        }

        protected TreeType BaseType(TreeType node)
        {
            string name = _typeMap[node.Name];
            if (name == _tree.Root)  return null;
            return _tree.Types.Single(t => t.Name == name);
        }

        protected static bool HasValidate(TreeType node) => node.HasValidate != null && string.Compare(node.HasValidate, "true", true) == 0;

        protected IEnumerable<TreeType> TypeAndBaseTypes(TreeType node)
        {
            var n = node;
            while (n != null)
            {
                yield return n;
                n = BaseType(n);
            }
        }

        protected IEnumerable<Field> AllFields(TreeType node)
        {
            return (node == null) ? Enumerable.Empty<Field>() 
                                  :  from t in TypeAndBaseTypes(node)
                                     from f in Fields(t)
                                     select f;
        }

        // AlwaysNull fields are those that have Null="Always" specified (possibly in an override).
        protected IEnumerable<Field> AllAlwaysNullFields(TreeType node) => from f in AllFields(node) where FieldNullHandling(node, f.Name) == NullHandling.Always select f;

        // Specifiable fields are those that aren't always null.
        protected IEnumerable<Field> AllSpecifiableFields(TreeType node) => from f in AllFields(node) where FieldNullHandling(node, f.Name) != NullHandling.Always select f;
        protected IEnumerable<Field> AllNodeOrNodeListFields(TreeType node) => AllFields(node).Where(field => IsDerivedOrListOfDerived("BoundNode", field.Type));
        protected IEnumerable<Field> AllTypeFields(TreeType node) => AllFields(node).Where(field => field.Type == "TypeSymbol");

        protected NullHandling FieldNullHandling(TreeType node, string fieldName)
        {
            Field f = GetField(node, fieldName);

            if (f.Null != null)
            {
                switch (f.Null.ToUpperInvariant())
                {
                    case    "ALLOW":  return NullHandling.Allow;
                    case "DISALLOW":  return NullHandling.Disallow;
                    case   "ALWAYS":  return NullHandling.Always;
                    case "NOTAPPLICABLE":  return NullHandling.NotApplicable;
                    case "":  break;
                    default:  throw new ArgumentException("Unexpected value", nameof(f.Null));
                }
            }

            if (f.Override)
                return FieldNullHandling(BaseType(node), fieldName);
            else if (!IsValueType(f.Type) || GetGenericType(f.Type) == "ImmutableArray")
                return NullHandling.Disallow; // default is to disallow nulls.
            else
                return NullHandling.NotApplicable;   // value types can't check nulls.
        }

        protected Field GetField(TreeType node, string fieldName)
        {
            var fieldsWithName = from f in FieldsIncludingOverrides(node) where f.Name == fieldName select f;
            if (fieldsWithName.Any())
                return fieldsWithName.Single();
            else if (BaseType(node) != null)
                return GetField(BaseType(node), fieldName);
            else
                throw new InvalidOperationException($"Field {fieldName} not found in type {node.Name}");
        }

        virtual protected void WriteField(Field field) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        virtual protected void WriteAccept(string name) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected void WriteType(TreeType node)
        {
            if (!(node is AbstractNode) && !(node is Node))  return;
            WriteClassHeader(node);

            bool unsealed = !CanBeSealed(node);
            bool concrete = !(node is AbstractNode);
            bool hasChildNodes = AllNodeOrNodeListFields(node).Any();

            if (unsealed)  WriteConstructor(node, false, hasChildNodes);
            if (concrete)  WriteConstructor(node, true, hasChildNodes);

            foreach (var field in Fields(node))
                WriteField(field);

            if (node is Node)
            {
                WriteAccept(node.Name);
                WriteUpdateMethod(node as Node);
            }

            WriteClassFooter(node);
        }

        virtual protected void WriteUpdateMethod(Node node, Boolean emitNew) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected void WriteUpdateMethod(Node node)
        {
            if (!AllFields(node).Any())  return;
            bool emitNew = (!Fields(node).Any()) && !(BaseType(node) is AbstractNode);
            WriteUpdateMethod(node, emitNew);
        }

        protected string StripBound(string name) => (name.StartsWith("Bound", StringComparison.Ordinal)) ? name.Substring(5) : name;

        protected virtual void WriteVisitor() => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected virtual void WriteWalker() => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected virtual void WriteTreeDumperNodeProducer() => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected virtual void WriteRewriter() => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected bool IsDerivedOrListOfDerived(string baseType, string derivedType) => IsDerivedType(baseType, derivedType) || IsListOfDerived(baseType, derivedType);

        protected bool IsListOfDerived(string baseType, string derivedType) => IsNodeList(derivedType) && IsDerivedType(baseType, GetElementType(derivedType));

        protected virtual bool IsImmutableArray(string typeName) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected virtual bool IsNodeList(string typeName) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        public bool IsNodeOrNodeList(string typeName) => IsNode(typeName) || IsNodeList(typeName);

        protected virtual string GetGenericType(string typeName) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));
        protected virtual string GetElementType(string typeName) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected bool IsAnyList(string typeName) => IsNodeList(typeName);

        protected bool IsValueType(string typeName)
        {
            string genericType = GetGenericType(typeName);
            return (_valueTypes.TryGetValue(genericType, out bool isValueType)) ? isValueType : false;
        }

        protected bool IsDerivedType(string typeName, string derivedTypeName)
        {
            if (typeName == derivedTypeName)  return true;
            if (derivedTypeName != null && _typeMap.TryGetValue(derivedTypeName, out var baseType)) return IsDerivedType(typeName, baseType);
            return false;
        }

        protected static bool IsRoot(Node n) => n.Root != null && string.Compare(n.Root, "true", true) == 0;
        protected bool IsNode(string typeName) => _typeMap.ContainsKey(typeName);
        protected static bool IsNew(Field f) => f.New != null && string.Compare(f.New, "true", true) == 0;

        protected static bool IsPropertyOverrides(Field f) => f.PropertyOverrides != null && string.Compare(f.PropertyOverrides, "true", true) == 0;

        protected static bool SkipInVisitor(Field f) => f.SkipInVisitor != null && string.Compare(f.SkipInVisitor, "true", true) == 0;

        protected string ToCamelCase(string name) => char.IsUpper(name[0]) ? char.ToLowerInvariant(name[0]) + name.Substring(1) : FixKeyword(name);

        protected virtual string EscapeKeyword(string name) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));

        protected string FixKeyword(string name) => IsKeyword(name) ? EscapeKeyword(name) : name;

        protected virtual bool IsKeyword(string name) => throw new ArgumentException("Unexpected target language", nameof(_targetLang));
    }

    internal static class Extensions
    {
        public static bool IsCSharpKeyword(this string name)
        {
            switch (name)
            {
                case "bool":
                case "byte":
                case "sbyte":
                case "short":
                case "ushort":
                case "int":
                case "uint":
                case "long":
                case "ulong":
                case "double":
                case "float":
                case "decimal":
                case "string":
                case "char":
                case "object":
                case "typeof":
                case "sizeof":
                case "null":
                case "true":
                case "false":
                case "if":
                case "else":
                case "while":
                case "for":
                case "foreach":
                case "do":
                case "switch":
                case "case":
                case "default":
                case "lock":
                case "try":
                case "throw":
                case "catch":
                case "finally":
                case "goto":
                case "break":
                case "continue":
                case "return":
                case "public":
                case "private":
                case "internal":
                case "protected":
                case "static":
                case "readonly":
                case "sealed":
                case "const":
                case "new":
                case "override":
                case "abstract":
                case "virtual":
                case "partial":
                case "ref":
                case "out":
                case "in":
                case "where":
                case "params":
                case "this":
                case "base":
                case "namespace":
                case "using":
                case "class":
                case "struct":
                case "interface":
                case "delegate":
                case "checked":
                case "get":
                case "set":
                case "add":
                case "remove":
                case "operator":
                case "implicit":
                case "explicit":
                case "fixed":
                case "extern":
                case "event":
                case "enum":
                case "unsafe":
                    return true;
                default:
                    return false;
            }
        }

        public static bool IsVBKeyword(this string name)
        {
            switch (name.ToLowerInvariant())
            {
                case "addhandler":
                case "addressof":
                case "alias":
                case "and":
                case "andalso":
                case "as":
                case "boolean":
                case "byref":
                case "byte":
                case "byval":
                case "call":
                case "case":
                case "catch":
                case "cbool":
                case "cbyte":
                case "cchar":
                case "cdate":
                case "cdbl":
                case "cdec":
                case "char":
                case "cint":
                case "class":
                case "clng":
                case "cobj":
                case "const":
                case "continue":
                case "csbyte":
                case "cshort":
                case "csng":
                case "cstr":
                case "ctype":
                case "cuint":
                case "culng":
                case "cushort":
                case "date":
                case "decimal":
                case "declare":
                case "default":
                case "delegate":
                case "dim":
                case "directcast":
                case "do":
                case "double":
                case "each":
                case "else":
                case "elseif":
                case "end":
                case "endif":
                case "enum":
                case "erase":
                case "error":
                case "event":
                case "exit":
                case "false":
                case "finally":
                case "for":
                case "friend":
                case "function":
                case "get":
                case "gettype":
                case "getxmlnamespace":
                case "global":
                case "gosub":
                case "goTo":
                case "handles":
                case "if":
                case "implements":
                case "imports":
                case "in":
                case "inherits":
                case "integer":
                case "interface":
                case "is":
                case "isnot":
                case "let":
                case "lib":
                case "like":
                case "long":
                case "loop":
                case "me":
                case "mod":
                case "module":
                case "mustinherit":
                case "mustoverride":
                case "mybase":
                case "myclass":
                case "namespace":
                case "narrowing":
                case "new":
                case "next":
                case "not":
                case "nothing":
                case "notinheritable":
                case "notoverridable":
                case "object":
                case "of":
                case "on":
                case "operator":
                case "option":
                case "optional":
                case "or":
                case "orelse":
                case "overloads":
                case "overridable":
                case "overrides":
                case "paramArray":
                case "partial":
                case "private":
                case "property":
                case "protected":
                case "public":
                case "raiseevent":
                case "readonly":
                case "redim":
                case "rem":
                case "removehandler":
                case "resume":
                case "return":
                case "sbyte":
                case "select":
                case "set":
                case "shadows":
                case "shared":
                case "short":
                case "single":
                case "static":
                case "step":
                case "stop":
                case "string":
                case "structure":
                case "sub":
                case "synclock":
                case "then":
                case "throw":
                case "to":
                case "true":
                case "try":
                case "trycast":
                case "typeof":
                case "uinteger":
                case "ulong":
                case "ushort":
                case "using":
                case "variant":
                case "wend":
                case "when":
                case "while":
                case "widening":
                case "with":
                case "withevents":
                case "writeonly":
                case "xor":
                    return true;
                default:
                    return false;
            }
        }
    }
}
