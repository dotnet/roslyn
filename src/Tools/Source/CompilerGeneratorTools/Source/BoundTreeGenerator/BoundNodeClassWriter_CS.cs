// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace BoundTreeGenerator
{
    internal sealed class BoundNodeClassWriter_CS : BoundNodeClassWriter
    {
        internal BoundNodeClassWriter_CS(TextWriter writer, Tree tree) : base(writer, tree, TargetLanguage.CSharp)
        {
        }

        protected override void InitializeValueTypes(ref Dictionary<string, bool> _valueTypes)
        {
            _valueTypes.Add("bool", true);
            _valueTypes.Add("int", true);
            _valueTypes.Add("uint", true);
            _valueTypes.Add("short", true);
            _valueTypes.Add("ushort", true);
            _valueTypes.Add("long", true);
            _valueTypes.Add("ulong", true);
            _valueTypes.Add("byte", true);
            _valueTypes.Add("sbyte", true);
            _valueTypes.Add("char", true);
            _valueTypes.Add("Boolean", true);
        }

        protected override void Write_AutoGenerated() => WriteLine("// <auto-generated />");

        protected override void WriteUsing(string nsName) => WriteLine("using {0};", nsName);

        protected override void WriteStartNamespace()
        {
            WriteLine("using Microsoft.CodeAnalysis.Text;");
            WriteLine("using Microsoft.CodeAnalysis.CSharp.Symbols;");
            WriteLine("using Microsoft.CodeAnalysis.CSharp.Syntax;");
            Blank();
            WriteLine("namespace Microsoft.CodeAnalysis.CSharp");
            Brace();
        }

        protected override void WriteEndNamespace() => Unbrace();

        protected override void WriteKinds()
        {
            WriteLine("internal enum BoundKind: byte");
            Brace();
            foreach (var node in _tree.Types.OfType<Node>())
                WriteLine("{0},", FixKeyword(StripBound(node.Name)));
            Unbrace();
        }


        protected override void WriteClassHeader(TreeType node)
        {
            string abstr = "";
            if (node is AbstractNode)
                abstr = "abstract ";
            else if (CanBeSealed(node))
                abstr = "sealed ";
            WriteLine("internal {2}partial class {0} : {1}", node.Name, node.Base, abstr);
            Brace();

        }

        protected override void WriteClassFooter(TreeType node) => Unbrace();
        protected override void Or<T>(IEnumerable<T> items, Func<T, string> func) => SeparatedList(" || ", items, func);

        protected override void WriteConstructorWithHasErrors(TreeType node, bool isPublic, bool hasErrorsIsOptional)
        {
            // A public constructor does not have an explicit kind parameter.
            Write("{0} {1}", isPublic ? "public" : "protected", node.Name);
            IEnumerable<string> fields = isPublic ? new[] { "SyntaxNode syntax" } : new[] { "BoundKind kind", "SyntaxNode syntax" };
            fields = fields.Concat(from field in AllSpecifiableFields(node)
                                   select field.Type + " " + ToCamelCase(field.Name));

            if (hasErrorsIsOptional)
                fields = fields.Concat(new[] { "bool hasErrors = false" });
            else
                fields = fields.Concat(new[] { "bool hasErrors" });

            ParenList(fields, x => x);
            Blank();
            Indent();
            Write(": base(");
            if (isPublic)
            {
                // Base call has bound kind, syntax, all fields in base type, plus merged HasErrors.
                Write(string.Format("BoundKind.{0}", StripBound(node.Name)));
                Write(", syntax, ");
                foreach (Field baseField in AllSpecifiableFields(BaseType(node)))
                    Write("{0}, ", FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "null" : ToCamelCase(baseField.Name));
                Or((new[] { "hasErrors" })
                    .Concat(from field in AllNodeOrNodeListFields(node)
                            select ToCamelCase(field.Name) + ".HasErrors()"), x => x);
            }
            else
            {
                // Base call has kind, syntax, and hasErrors. No merging of hasErrors because derived class already did the merge.
                Write("kind, syntax, ");
                foreach (Field baseField in AllSpecifiableFields(BaseType(node)))
                    Write("{0}, ", FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "null" : ToCamelCase(baseField.Name));
                Write("hasErrors");
            }
            Write(")");
            Blank();
            Outdent();
            Brace();

            WriteNullChecks(node);

            foreach (var field in Fields(node))
            {
                if (IsPropertyOverrides(field))
                {
                    WriteLine("this._{0} = {1};", field.Name, FieldNullHandling(node, field.Name) == NullHandling.Always ? "null" : ToCamelCase(field.Name));
                }
                else
                {
                    WriteLine("this.{0} = {1};", field.Name, FieldNullHandling(node, field.Name) == NullHandling.Always ? "null" : ToCamelCase(field.Name));
                }
            }
            Unbrace();
            Blank();
        }

        // This constructor should only be created if no node or list fields, since it just calls base class constructor
        // without merging hasErrors.
        protected override void WriteConstructorWithoutHasErrors(TreeType node, bool isPublic)
        {
            // A public constructor does not have an explicit kind parameter.
            Write("{0} {1}", isPublic ? "public" : "protected", node.Name);
            IEnumerable<string> fields = isPublic ? new[] { "SyntaxNode syntax" } : new[] { "BoundKind kind", "SyntaxNode syntax" };
            fields = fields.Concat(from field in AllSpecifiableFields(node)
                                   select field.Type + " " + ToCamelCase(field.Name));
            ParenList(fields, x => x);
            Blank();
            Indent();
            Write(": base(");
            if (isPublic)
            {
                // Base call has bound kind, syntax, fields.
                Write(string.Format("BoundKind.{0}", StripBound(node.Name)));
                Write(", syntax");
                foreach (Field baseField in AllSpecifiableFields(BaseType(node)))
                    Write(", {0}", FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "null" : ToCamelCase(baseField.Name));
            }
            else
            {
                // Base call has kind, syntax, fields
                Write("kind, syntax");
                foreach (Field baseField in AllSpecifiableFields(BaseType(node)))
                    Write(", {0}", FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "null" : ToCamelCase(baseField.Name));
            }
            Write(")");
            Blank();
            Outdent();
            Brace();

            WriteNullChecks(node);

            foreach (var field in Fields(node))
            {
                if (IsPropertyOverrides(field))
                {
                    WriteLine("this._{0} = {1};", field.Name, FieldNullHandling(node, field.Name) == NullHandling.Always ? "null" : ToCamelCase(field.Name));
                }
                else
                {
                    WriteLine("this.{0} = {1};", field.Name, FieldNullHandling(node, field.Name) == NullHandling.Always ? "null" : ToCamelCase(field.Name));
                }
            }
            Unbrace();
            Blank();
        }

        protected override void WriteNullCheck(bool isROArray, Field field)
        {
            if (isROArray)
                WriteLine("Debug.Assert(!{0}.IsDefault, \"Field '{0}' cannot be null (use Null=\\\"allow\\\" in BoundNodes.xml to remove this check)\");", ToCamelCase(field.Name));
            else
                WriteLine("Debug.Assert({0} != null, \"Field '{0}' cannot be null (use Null=\\\"allow\\\" in BoundNodes.xml to remove this check)\");", ToCamelCase(field.Name));
        }

        protected override void WriteField(Field field)
        {
            Blank();
            if (IsPropertyOverrides(field))
            {
                WriteLine("private readonly {0} _{1};", field.Type, field.Name);
                WriteLine("public override {0}{1} {2} {{ get {{ return _{2};}} }}", (IsNew(field) ? "new " : ""), field.Type, field.Name);
            }
            else
            {
                WriteLine("public {0}{1} {2} {{ get; }}", (IsNew(field) ? "new " : ""), field.Type, field.Name);
            }
        }

        protected override void WriteAccept(string name)
        {
            //Blank();
            //WriteLine("public override R Accept<A, R>(BoundTreeVisitor<A, R> visitor, A arg)");
            //Brace();
            //WriteLine("return visitor.Visit{0}(this, arg);", StripBound(name));
            //Unbrace();

            Blank();
            WriteLine("public override BoundNode Accept(BoundTreeVisitor visitor)");
            Brace();
            WriteLine("return visitor.Visit{0}(this);", StripBound(name));
            Unbrace();
        }
        protected override void WriteUpdateMethod(Node node, Boolean emitNew)
        {
            Blank();
            Write("public{1} {0} Update", node.Name, emitNew ? " new" : "");
            Paren();
            Comma(AllSpecifiableFields(node), field => string.Format("{0} {1}", field.Type, ToCamelCase(field.Name)));
            UnParen();
            Blank();
            Brace();
            if (AllSpecifiableFields(node).Any())
            {
                Write("if ");
                Paren();
                Or(AllSpecifiableFields(node),
                    field => string.Format("{0} != this.{1}", ToCamelCase(field.Name), field.Name));
                UnParen();
                Blank();
                Brace();
                Write("var result = new {0}", node.Name);
                var fields = new[] { "this.Syntax" }.Concat(AllSpecifiableFields(node).Select(f => ToCamelCase(f.Name))).Concat(new[] { "this.HasErrors" });
                ParenList(fields);
                WriteLine(";");
                WriteLine("result.WasCompilerGenerated = this.WasCompilerGenerated;");
                WriteLine("return result;");
                Unbrace();
            }
            WriteLine("return this;");
            Unbrace();
        }

        protected override void WriteVisitor()
        {
            Blank();
            WriteLine("internal abstract partial class BoundTreeVisitor<A,R>");
            Brace();

            Blank();
            WriteLine("[MethodImpl(MethodImplOptions.NoInlining)]");
            WriteLine("internal R VisitInternal(BoundNode node, A arg)");
            Brace();
            WriteLine("switch (node.Kind)");
            Brace();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine("case BoundKind.{0}: ", FixKeyword(StripBound(node.Name)));
                Indent();
                WriteLine("return Visit{0}(node as {1}, arg);", StripBound(node.Name), node.Name);
                Outdent();
            }
            Unbrace();
            Blank(); // end switch
            WriteLine("return default(R);");
            Unbrace(); // end method
            Unbrace(); // end class

            //Blank();
            //WriteLine("internal abstract partial class BoundTreeVisitor");
            //Brace();

            //Blank();
            //WriteLine("[MethodImpl(MethodImplOptions.NoInlining)]");
            //WriteLine("internal BoundNode VisitInternal(BoundNode node)");
            //Brace();
            //WriteLine("switch (node.Kind)");
            //Brace();
            //foreach (var node in tree.Types.OfType<Node>())
            //{
            //    WriteLine("case BoundKind.{0}: ", FixKeyword(StripBound(node.Name)));
            //    Indent();
            //    WriteLine("return Visit{0}(node as {1});", StripBound(node.Name), node.Name);
            //    Outdent();
            //}
            //Unbrace(); // end switch
            //Blank();
            //WriteLine("return null;");
            //Unbrace(); // end method
            //Unbrace(); // end class

            Blank();
            WriteLine("internal abstract partial class BoundTreeVisitor<A,R>");
            Brace();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine("public virtual R Visit{0}({1} node, A arg)", StripBound(node.Name), node.Name);
                Brace();
                WriteLine("return this.DefaultVisit(node, arg);");
                Unbrace();
            }
            Unbrace();

            Blank();
            WriteLine("internal abstract partial class BoundTreeVisitor");
            Brace();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine("public virtual BoundNode Visit{0}({1} node)", StripBound(node.Name), node.Name);
                Brace();
                WriteLine("return this.DefaultVisit(node);");
                Unbrace();
            }
            Unbrace();
        }

        protected override void WriteWalker()
        {
            Blank();
            WriteLine("internal abstract partial class BoundTreeWalker: BoundTreeVisitor");
            Brace();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine("public override BoundNode Visit{0}({1} node)", StripBound(node.Name), node.Name);
                Brace();
                foreach (Field field in AllFields(node).Where(f => IsDerivedOrListOfDerived("BoundNode", f.Type) && !SkipInVisitor(f)))
                {
                    WriteLine("this.Visit{1}(node.{0});", field.Name, IsNodeList(field.Type) ? "List" : "");
                }
                WriteLine("return null;");
                Unbrace();
            }
            Unbrace();
        }

        protected override void WriteTreeDumperNodeProducer()
        {
            Blank();
            WriteLine("internal sealed class BoundTreeDumperNodeProducer : BoundTreeVisitor<object, TreeDumperNode>");
            Brace();
            WriteLine("private BoundTreeDumperNodeProducer()");
            Brace();
            Unbrace();
            WriteLine("public static TreeDumperNode MakeTree(BoundNode node)");
            Brace();
            WriteLine("return (new BoundTreeDumperNodeProducer()).Visit(node, null);");
            Unbrace();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine("public override TreeDumperNode Visit{0}({1} node, object arg)", StripBound(node.Name), node.Name);
                Brace();
                Write("return new TreeDumperNode(\"{0}\", null, ", ToCamelCase(StripBound(node.Name)));
                var allFields = AllFields(node).ToArray();
                if (allFields.Length > 0)
                {
                    WriteLine("new TreeDumperNode[]");
                    Brace();
                    for (int i = 0; i < allFields.Length; ++i)
                    {
                        Field field = allFields[i];
                        if (IsDerivedType("BoundNode", field.Type))
                            Write("new TreeDumperNode(\"{0}\", null, new TreeDumperNode[] {{ Visit(node.{1}, null) }})", ToCamelCase(field.Name), field.Name);
                        else if (IsListOfDerived("BoundNode", field.Type))
                        {
                            if (IsImmutableArray(field.Type) && FieldNullHandling(node, field.Name) == NullHandling.Disallow)
                            {
                                Write("new TreeDumperNode(\"{0}\", null, from x in node.{1} select Visit(x, null))", ToCamelCase(field.Name), field.Name);
                            }
                            else
                            {
                                Write("new TreeDumperNode(\"{0}\", null, node.{1}.IsDefault ? Array.Empty<TreeDumperNode>() : from x in node.{1} select Visit(x, null))", ToCamelCase(field.Name), field.Name);
                            }
                        }
                        else
                            Write("new TreeDumperNode(\"{0}\", node.{1}, null)", ToCamelCase(field.Name), field.Name);

                        if (i == allFields.Length - 1)
                            WriteLine("");
                        else
                            WriteLine(",");
                    }
                    Unbrace();
                }
                else
                {
                    WriteLine("Array.Empty<TreeDumperNode>()");
                }
                WriteLine(");");
                Unbrace();
            }
            Unbrace();
        }

        protected override void WriteRewriter()
        {
            Blank();
            WriteLine("internal abstract partial class BoundTreeRewriter : BoundTreeVisitor");
            Brace();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine("public override BoundNode Visit{0}({1} node)", StripBound(node.Name), node.Name);
                Brace();
                bool hadField = false;
                foreach (Field field in AllNodeOrNodeListFields(node))
                {
                    hadField = true;
                    if (SkipInVisitor(field))
                    {
                        WriteLine("{2} {0} = node.{1};", ToCamelCase(field.Name), field.Name, field.Type);
                    }
                    else
                    {
                        WriteLine("{3} {0} = ({3})this.Visit{2}(node.{1});", ToCamelCase(field.Name), field.Name, IsNodeList(field.Type) ? "List" : "", field.Type);
                    }
                }
                foreach (Field field in AllTypeFields(node))
                {
                    hadField = true;
                    WriteLine("TypeSymbol {0} = this.VisitType(node.{1});", ToCamelCase(field.Name), field.Name);
                }
                if (hadField)
                {
                    Write("return node.Update");
                    ParenList(AllSpecifiableFields(node), field => IsDerivedOrListOfDerived("BoundNode", field.Type) || field.Type == "TypeSymbol" ? ToCamelCase(field.Name) : string.Format("node.{0}", field.Name));
                    WriteLine(";");
                }
                else
                {
                    WriteLine("return node;");
                }

                Unbrace();
            }
            Unbrace();
        }

        protected override bool IsImmutableArray(string typeName) => typeName.StartsWith("ImmutableArray<", StringComparison.Ordinal);
 
        protected override bool IsNodeList(string typeName) => typeName.StartsWith("IList<", StringComparison.Ordinal) ||
                                                               typeName.StartsWith("ImmutableArray<", StringComparison.Ordinal);

        protected override string GetGenericType(string typeName)
        {

            if (!typeName.Contains("<"))
                return typeName;
            int iStart = typeName.IndexOf('<');
            return typeName.Substring(0, iStart);
        }

        protected override string GetElementType(string typeName)
        {

            if (!typeName.Contains("<"))
                return string.Empty;
            int iStart = typeName.IndexOf('<');
            int iEnd = typeName.IndexOf('>', iStart + 1);
            if (iEnd < iStart)
                return string.Empty;
            var sub = typeName.Substring(iStart + 1, iEnd - iStart - 1);
            return sub;
        }

        protected override string EscapeKeyword(string name) => "@" + name;

        protected override bool IsKeyword(string name) => name.IsCSharpKeyword();
    
    }
}
