// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace BoundTreeGenerator
{
    internal sealed class BoundNodeClassWriter_CS : BoundNodeClassWriter
    {
        internal BoundNodeClassWriter_CS(TextWriter writer, Tree tree)
            : base(writer, tree, TargetLanguage.CSharp) { }

        protected override void InitializeValueTypes(ref Dictionary<string, bool> _valueTypes)
        {
            _valueTypes.Add("bool", true);
            _valueTypes.Add("int", true);
            _valueTypes.Add("uint", true);
            _valueTypes.Add("short", true);
            _valueTypes.Add("ushort", true);
            _valueTypes.Add("long", true);
            _valueTypes.Add("ulong", true);
            _valueTypes.Add("byte", true);
            _valueTypes.Add("sbyte", true);
            _valueTypes.Add("char", true);
            _valueTypes.Add("Boolean", true);
        }

        protected override void Write_AutoGenerated() => WriteLine("// <auto-generated />");

        protected override void WriteUsing(string nsName) => WriteLine($"using {nsName};");

        protected override void WriteStartNamespace()
        {
            WriteLine("using Microsoft.CodeAnalysis.Text;");
            WriteLine("using Microsoft.CodeAnalysis.CSharp.Symbols;");
            WriteLine("using Microsoft.CodeAnalysis.CSharp.Syntax;");
            Blank();
            WriteLine("namespace Microsoft.CodeAnalysis.CSharp");
            Brace();
        }

        protected override void WriteEndNamespace() => Unbrace();

        protected override void WriteKinds()
        {
            WriteLine("internal enum BoundKind: byte");
            Brace();
            foreach (var node in _tree.Types.OfType<Node>())
                WriteLine($"{FixKeyword(StripBound(node.Name))},");
            Unbrace();
        }

        protected override void WriteClassHeader(TreeType node)
        {
            string abstr = "";
            if (node is AbstractNode)
                abstr = "abstract ";
            else if (CanBeSealed(node))
                abstr = "sealed ";
            WriteLine($"internal {abstr}partial class {node.Name} : {node.Base}");
            Brace();
        }

        protected override void WriteClassFooter(TreeType node) => Unbrace();
        protected override void Or<T>(IEnumerable<T> items, Func<T, string> func) => SeparatedList(" || ", items, func);

        protected override void WriteConstructorWithHasErrors(TreeType node, bool isPublic, bool hasErrorsIsOptional)
        {
            // A public constructor does not have an explicit kind parameter.
            var porp = isPublic ? "public" : "protected";
            Write($"{porp} {node.Name}");
            IEnumerable<string> fields = isPublic ? new[] { "SyntaxNode syntax" } : new[] { "BoundKind kind", "SyntaxNode syntax" };
            fields = fields.Concat(from field in AllSpecifiableFields(node)
                                   select field.Type + " " + ToCamelCase(field.Name));

            if (hasErrorsIsOptional)
                fields = fields.Concat(new[] { "bool hasErrors = false" });
            else
                fields = fields.Concat(new[] { "bool hasErrors" });

            ParenList(fields, x => x);
            Blank();
            Indent();
            Write(": base(");
            if (isPublic)
            {
                // Base call has bound kind, syntax, all fields in base type, plus merged HasErrors.
                Write($"BoundKind.{StripBound(node.Name)}");
                Write(", syntax, ");
                WriteFields("", AllSpecifiableFields(BaseType(node)), node, ", ");
                Or((new[] { "hasErrors" })
                    .Concat(from field in AllNodeOrNodeListFields(node)
                            select ToCamelCase(field.Name) + ".HasErrors()"), x => x);
            }
            else
            {
                // Base call has kind, syntax, and hasErrors. No merging of hasErrors because derived class already did the merge.
                Write("kind, syntax, ");
                WriteFields("", AllSpecifiableFields(BaseType(node)), node, ", ");
                Write("hasErrors");
            }
            Write(")");
            Blank();
            Outdent();
            Brace();

            WriteNullChecks(node);

            foreach (var field in Fields(node))
            {
                var value = FieldNullHandling(node, field.Name) == NullHandling.Always ? "null" : ToCamelCase(field.Name);
                if (IsPropertyOverrides(field))
                {
                    WriteLine($"this._{field.Name} = {value};");
                }
                else
                {
                    WriteLine($"this.{field.Name} = {value};");
                }
            }
            Unbrace();
            Blank();
        }

        // This constructor should only be created if no node or list fields, since it just calls base class constructor
        // without merging hasErrors.
        protected override void WriteConstructorWithoutHasErrors(TreeType node, bool isPublic)
        {
            // A public constructor does not have an explicit kind parameter.
            var porp = isPublic ? "public" : "protected";
            Write($"{porp} {node.Name}");
            IEnumerable<string> fields = isPublic ? new[] { "SyntaxNode syntax" } : new[] { "BoundKind kind", "SyntaxNode syntax" };
            fields = fields.Concat(from field in AllSpecifiableFields(node)
                                   select field.Type + " " + ToCamelCase(field.Name));
            ParenList(fields, x => x);
            Blank();
            Indent();
            Write(": base(");
            if (isPublic)
            {
                // Base call has bound kind, syntax, fields.
                Write($"BoundKind.{StripBound(node.Name)}");
                Write(", syntax");
                WriteFields(", ", AllSpecifiableFields(BaseType(node)), node, "");
            }
            else
            {
                // Base call has kind, syntax, fields
                Write("kind, syntax");
                WriteFields(", ", AllSpecifiableFields(BaseType(node)), node, "");
            }
            Write(")");
            Blank();
            Outdent();
            Brace();

            WriteNullChecks(node);

            foreach (var field in Fields(node))
            {
                var value = FieldNullHandling(node, field.Name) == NullHandling.Always ? "null" : ToCamelCase(field.Name);
                if (IsPropertyOverrides(field))
                {
                    WriteLine($"this._{field.Name} = {value};");
                }
                else
                {
                    WriteLine($"this.{field.Name} = {value};");
                }
            }
            Unbrace();
            Blank();
        }

        private void WriteFields(string prefix, IEnumerable<Field> fx, TreeType node, string postfix)
        {
            foreach (Field baseField in fx)
            {
                var value = FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "null" : ToCamelCase(baseField.Name);
                Write($"{prefix}{value}{postfix}");
            }
        }

        protected override void WriteNullCheck(bool isROArray, Field field)
        {
            Write("Debug.Assert(");
            var member = ToCamelCase(field.Name);
            if (isROArray)
                Write($"!{member}.IsDefault");
            else
                Write($"{member} != null");

            WriteLine($", \"Field '{member}' cannot be null (use Null=\\\"allow\\\" in BoundNodes.xml to remove this check)\");");
        }

        protected override void WriteField(Field field)
        {
            Blank();
            var newobj = (IsNew(field) ? "new " : "");
            if (IsPropertyOverrides(field))
            {
                WriteLine($"private readonly {field.Type} _{field.Name};");
                WriteLine($"public override {newobj}{field.Type} {field.Name} {{ get {{ return _{field.Name};}} }}");
            }
            else
            {
                WriteLine($"public {newobj}{field.Type} {field.Name} {{ get; }}");
            }
        }

        protected override void WriteAccept(string name)
        {
            //Blank();
            //WriteLine("public override R Accept<A, R>(BoundTreeVisitor<A, R> visitor, A arg)");
            //Brace();
            //WriteLine("return visitor.Visit{0}(this, arg);", StripBound(name));
            //Unbrace();

            Blank();
            WriteLine("public override BoundNode Accept(BoundTreeVisitor visitor)");
            Brace();
            WriteLine($"return visitor.Visit{StripBound(name)}(this);");
            Unbrace();
        }
        protected override void WriteUpdateMethod(Node node, Boolean emitNew)
        {
            Blank();
            var newobj = emitNew ? " new" : "";
            Write($"public{newobj} {node.Name} Update");
            Paren();
            Comma(AllSpecifiableFields(node), field => $"{field.Type} {ToCamelCase(field.Name)}");
            UnParen();
            Blank();
            Brace();
            if (AllSpecifiableFields(node).Any())
            {
                Write("if ");
                Paren();
                Or(AllSpecifiableFields(node),  field => $"{ToCamelCase(field.Name)} != this.{field.Name}");
                UnParen();
                Blank();
                Brace();
                Write($"var result = new {node.Name}");
                var fields = new[] { "this.Syntax" }.Concat(AllSpecifiableFields(node).Select(f => ToCamelCase(f.Name))).Concat(new[] { "this.HasErrors" });
                ParenList(fields);
                WriteLine(";");
                WriteLine("result.WasCompilerGenerated = this.WasCompilerGenerated;");
                WriteLine("return result;");
                Unbrace();
            }
            WriteLine("return this;");
            Unbrace();
        }

        protected override void WriteVisitor()
        {
            Blank();
            WriteLine("internal abstract partial class BoundTreeVisitor<A,R>");
            Brace();

            Blank();
            WriteLine("[MethodImpl(MethodImplOptions.NoInlining)]");
            WriteLine("internal R VisitInternal(BoundNode node, A arg)");
            Brace();
            WriteLine("switch (node.Kind)");
            Brace();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                var strip = StripBound(node.Name);
                WriteLine($"case BoundKind.{FixKeyword(strip)}: ");
                Indent();
                WriteLine($"return Visit{strip}(node as {node.Name}, arg);");
                Outdent();
            }
            Unbrace();
            Blank(); // end switch
            WriteLine("return default(R);");
            Unbrace(); // end method
            Unbrace(); // end class

            //Blank();
            //WriteLine("internal abstract partial class BoundTreeVisitor");
            //Brace();

            //Blank();
            //WriteLine("[MethodImpl(MethodImplOptions.NoInlining)]");
            //WriteLine("internal BoundNode VisitInternal(BoundNode node)");
            //Brace();
            //WriteLine("switch (node.Kind)");
            //Brace();
            //foreach (var node in tree.Types.OfType<Node>())
            //{
            //    WriteLine("case BoundKind.{0}: ", FixKeyword(StripBound(node.Name)));
            //    Indent();
            //    WriteLine("return Visit{0}(node as {1});", StripBound(node.Name), node.Name);
            //    Outdent();
            //}
            //Unbrace(); // end switch
            //Blank();
            //WriteLine("return null;");
            //Unbrace(); // end method
            //Unbrace(); // end class

            Blank();
            WriteLine("internal abstract partial class BoundTreeVisitor<A,R>");
            Brace();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine($"public virtual R Visit{StripBound(node.Name)}({node.Name} node, A arg)");
                Brace();
                WriteLine("return this.DefaultVisit(node, arg);");
                Unbrace();
            }
            Unbrace();

            Blank();
            WriteLine("internal abstract partial class BoundTreeVisitor");
            Brace();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine($"public virtual BoundNode Visit{StripBound(node.Name)}({node.Name} node)");
                Brace();
                WriteLine("return this.DefaultVisit(node);");
                Unbrace();
            }
            Unbrace();
        }

        protected override void WriteWalker()
        {
            Blank();
            WriteLine("internal abstract partial class BoundTreeWalker : BoundTreeVisitor");
            Brace();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine($"public override BoundNode Visit{StripBound(node.Name)}({node.Name} node)");
                Brace();
                foreach (Field field in AllFields(node).Where(f => IsDerivedOrListOfDerived("BoundNode", f.Type) && !SkipInVisitor(f)))
                {
                    var member = IsNodeList(field.Type) ? "List" : "";
                    WriteLine($"this.Visit{member}(node.{field.Name});");
                }
                WriteLine("return null;");
                Unbrace();
            }
            Unbrace();
        }

        protected override void WriteTreeDumperNodeProducer()
        {
            Blank();
            WriteLine("internal sealed class BoundTreeDumperNodeProducer : BoundTreeVisitor<object, TreeDumperNode>");
            Brace();
            WriteLine("private BoundTreeDumperNodeProducer()");
            Brace();
            Unbrace();
            WriteLine("public static TreeDumperNode MakeTree(BoundNode node)");
            Brace();
            WriteLine("return (new BoundTreeDumperNodeProducer()).Visit(node, null);");
            Unbrace();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                var strip = StripBound(node.Name);
                WriteLine($"public override TreeDumperNode Visit{strip}({node.Name} node, object arg)");
                Brace();
                Write($"return new TreeDumperNode(\"{ToCamelCase(strip)}\", null, ");
                var allFields = AllFields(node).ToArray();
                if (allFields.Length > 0)
                {
                    WriteLine("new TreeDumperNode[]");
                    Brace();
                    for (int i = 0; i < allFields.Length; ++i)
                    {
                        Field field = allFields[i];
                        Write($"new TreeDumperNode(\"{ToCamelCase(field.Name)}\", ");
                        if (IsDerivedType("BoundNode", field.Type))
                            Write($"null, new TreeDumperNode[] {{ Visit(node.{field.Name}, null) }})");
                        else if (IsListOfDerived("BoundNode", field.Type))
                        {
                            if (IsImmutableArray(field.Type) && FieldNullHandling(node, field.Name) == NullHandling.Disallow)
                            {
                                Write($"null, from x in node.{field.Name} select Visit(x, null))");
                            }
                            else
                            {
                                Write($"null, node.{field.Name}.IsDefault ? Array.Empty<TreeDumperNode>() : from x in node.{field.Name} select Visit(x, null))");
                            }
                        }
                        else
                            Write($"node.{ field.Name}, null)");

                        if (i == allFields.Length - 1)
                            WriteLine("");
                        else
                            WriteLine(",");
                    }
                    Unbrace();
                }
                else
                {
                    WriteLine("Array.Empty<TreeDumperNode>()");
                }
                WriteLine(");");
                Unbrace();
            }
            Unbrace();
        }

        protected override void WriteRewriter()
        {
            Blank();
            WriteLine("internal abstract partial class BoundTreeRewriter : BoundTreeVisitor");
            Brace();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine($"public override BoundNode Visit{StripBound(node.Name)}({node.Name} node)");
                Brace();
                bool hadField = false;
                foreach (Field field in AllNodeOrNodeListFields(node))
                {
                    var camel = ToCamelCase(field.Name);
                    hadField = true;
                    if (SkipInVisitor(field))
                    {
                        WriteLine($"{field.Type} {camel} = node.{field.Name};");
                    }
                    else
                    {
                        var member = IsNodeList(field.Type) ? "List" : "";
                        WriteLine($"{field.Type} {camel} = ({field.Type})this.Visit{member}(node.{field.Name});");
                    }
                }
                foreach (Field field in AllTypeFields(node))
                {
                    hadField = true;
                    WriteLine($"TypeSymbol {ToCamelCase(field.Name)} = this.VisitType(node.{field.Name});");
                }
                if (hadField)
                {
                    Write("return node.Update");
                    ParenList(AllSpecifiableFields(node), field => IsDerivedOrListOfDerived("BoundNode", field.Type) || field.Type == "TypeSymbol" ? ToCamelCase(field.Name) : $"node.{field.Name}");
                    WriteLine(";");
                }
                else
                {
                    WriteLine("return node;");
                }

                Unbrace();
            }
            Unbrace();
        }

        protected override bool IsImmutableArray(string typeName) => typeName.StartsWith("ImmutableArray<", StringComparison.Ordinal);

        protected override bool IsNodeList(string typeName) => typeName.StartsWith("IList<", StringComparison.Ordinal) ||
                                                               typeName.StartsWith("ImmutableArray<", StringComparison.Ordinal);

        protected override string GetGenericType(string typeName)
        {
            if (!typeName.Contains("<"))  return typeName;
            int iStart = typeName.IndexOf('<');
            return typeName.Substring(0, iStart);
        }

        protected override string GetElementType(string typeName)
        {
            if (!typeName.Contains("<")) return string.Empty;
            int iStart = typeName.IndexOf('<');
            int iEnd = typeName.IndexOf('>', iStart + 1);
            if (iEnd < iStart)  return string.Empty;
            return typeName.Substring(iStart + 1, iEnd - iStart - 1);
        }

        protected override string EscapeKeyword(string name) => "@" + name;

        protected override bool IsKeyword(string name) => name.IsCSharpKeyword();

    }
}
