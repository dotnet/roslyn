// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace BoundTreeGenerator
{
    internal sealed class BoundNodeClassWriter_VB : BoundNodeClassWriter
    {
        internal BoundNodeClassWriter_VB(TextWriter writer, Tree tree) : base(writer, tree, TargetLanguage.VB)
        {
        }
        protected override void InitializeValueTypes(ref Dictionary<string, bool> _valueTypes)
        {
            _valueTypes.Add("Boolean", true);
            _valueTypes.Add("Integer", true);
            _valueTypes.Add("UInteger", true);
            _valueTypes.Add("Short", true);
            _valueTypes.Add("UShort", true);
            _valueTypes.Add("Long", true);
            _valueTypes.Add("ULong", true);
            _valueTypes.Add("Byte", true);
            _valueTypes.Add("SByte", true);
            _valueTypes.Add("Char", true);
        }

        protected override void Write_AutoGenerated() => WriteLine("' <auto-generated />");

        protected override void WriteUsing(string nsName) => WriteLine("Imports {0}", nsName);

        protected override void WriteStartNamespace()
        {
            WriteLine("Imports Microsoft.CodeAnalysis.Text");
            WriteLine("Imports Microsoft.CodeAnalysis.VisualBasic.Symbols");
            WriteLine("Imports Microsoft.CodeAnalysis.VisualBasic.Syntax");
            Blank();
            WriteLine("Namespace Microsoft.CodeAnalysis.VisualBasic");
            Indent();
        }

        protected override void WriteEndNamespace()
        {
            Outdent();
            WriteLine("End Namespace");
        }

        protected override void WriteKinds()
        {
            WriteLine("Friend Enum BoundKind as Byte");
            Indent();
            foreach (var node in _tree.Types.OfType<Node>())
                WriteLine("{0}", FixKeyword(StripBound(node.Name)));
            Outdent();
            WriteLine("End Enum");
        }

        protected override void WriteClassHeader(TreeType node)
        {
            string abstr = "";
            if (node is AbstractNode)
                abstr = "MustInherit ";
            else if (CanBeSealed(node))
                abstr = "NotInheritable ";
            WriteLine("Friend {1}Partial Class {0}", node.Name, abstr);
            Indent();
            WriteLine("Inherits {0}", node.Base);
            Blank();
        }

        protected override void WriteClassFooter(TreeType node)
        {
            Outdent();
            WriteLine("End Class");
        }

        protected override void Or<T>(IEnumerable<T> items, Func<T, string> func)
        {
            SeparatedList(" OrElse ", items, func);
        }


        protected override void WriteConstructorWithHasErrors(TreeType node, bool isPublic, bool hasErrorsIsOptional)
        {
            // A public constructor does not have an explicit kind parameter.
            Write("{0} {1}", isPublic ? "Public" : "Protected", "Sub New");
            IEnumerable<string> fields = isPublic ? new[] { "syntax As SyntaxNode" } : new[] { "kind As BoundKind", "syntax as SyntaxNode" };
            fields = fields.Concat(from field in AllSpecifiableFields(node)
                                   select ToCamelCase(field.Name) + " As " + field.Type);

            if (hasErrorsIsOptional)
                fields = fields.Concat(new[] { "Optional hasErrors As Boolean = False" });
            else
                fields = fields.Concat(new[] { "hasErrors As Boolean" });

            ParenList(fields, x => x);
            Blank();
            Indent();
            Write("MyBase.New(");
            if (isPublic)
            {
                // Base call has bound kind, syntax, all fields in base type, plus merged HasErrors.
                Write(string.Format("BoundKind.{0}", StripBound(node.Name)));
                Write(", syntax, ");
                foreach (Field baseField in AllSpecifiableFields(BaseType(node)))
                    Write("{0}, ", FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(baseField.Name));
                Or((new[] { "hasErrors" })
                    .Concat(from field in AllNodeOrNodeListFields(node)
                            select ToCamelCase(field.Name) + ".NonNullAndHasErrors()"), x => x);
            }
            else
            {
                // Base call has kind, syntax, and hasErrors. No merging of hasErrors because derived class already did the merge.
                Write("kind, syntax, ");
                foreach (Field baseField in AllSpecifiableFields(BaseType(node)))
                    Write("{0}, ", FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(baseField.Name));
                Write("hasErrors");
            }
            Write(")");
            Blank();

            WriteNullChecks(node);

            foreach (var field in Fields(node))
                WriteLine("Me._{0} = {1}", field.Name, FieldNullHandling(node, field.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(field.Name));

            bool hasValidate = HasValidate(node);

            if (hasValidate)
            {
                Blank();
                WriteLine("Validate()");
            }

            Outdent();
            WriteLine("End Sub");
            Blank();

            if (hasValidate)
            {
                WriteLine("Private Partial Sub Validate()");
                WriteLine("End Sub");
                Blank();
            }
        }

        // This constructor should only be created if no node or list fields, since it just calls base class constructor
        // without merging hasErrors.
        protected override void WriteConstructorWithoutHasErrors(TreeType node, bool isPublic)
        {
            // A public constructor does not have an explicit kind parameter.
            Write("{0} {1}", isPublic ? "Public" : "Protected", "Sub New");
            IEnumerable<string> fields = isPublic ? new[] { "syntax As SyntaxNode" } : new[] { "kind As BoundKind", "syntax as SyntaxNode" };
            fields = fields.Concat(from field in AllSpecifiableFields(node)
                                   select ToCamelCase(field.Name) + " As " + field.Type);
            ParenList(fields, x => x);
            Blank();
            Indent();
            Write("MyBase.New(");
            if (isPublic)
            {
                // Base call has bound kind, syntax, fields.
                Write(string.Format("BoundKind.{0}", StripBound(node.Name)));
                Write(", syntax");
                foreach (Field baseField in AllSpecifiableFields(BaseType(node)))
                    Write(", {0}", FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(baseField.Name));
            }
            else
            {
                // Base call has kind, syntax, fields
                Write("kind, syntax");
                foreach (Field baseField in AllSpecifiableFields(BaseType(node)))
                    Write(", {0}", FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(baseField.Name));
            }
            Write(")");
            Blank();

            WriteNullChecks(node);

            foreach (var field in Fields(node))
                WriteLine("Me._{0} = {1}", field.Name, FieldNullHandling(node, field.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(field.Name));

            if (HasValidate(node))
            {
                Blank();
                WriteLine("Validate()");
            }

            Outdent();
            WriteLine("End Sub");
            Blank();
        }

        protected override void WriteNullCheck(bool isROArray, Field field)
        {
            if (isROArray)
                WriteLine("Debug.Assert(Not ({0}.IsDefault), \"Field '{0}' cannot be null (use Null=\"\"allow\"\" in BoundNodes.xml to remove this check)\")", ToCamelCase(field.Name));
            else
                WriteLine("Debug.Assert({0} IsNot Nothing, \"Field '{0}' cannot be null (use Null=\"\"allow\"\" in BoundNodes.xml to remove this check)\")", ToCamelCase(field.Name));

        }

        protected override void WriteField(Field field)
        {
            Blank();
            WriteLine("Private {0}ReadOnly _{2} As {1}", (IsNew(field) ? "Shadows " : ""), field.Type, field.Name);
            WriteLine("Public {0}ReadOnly Property {2} As {1}", (IsNew(field) ? "Shadows " : IsPropertyOverrides(field) ? "Overrides " : ""), field.Type, field.Name);
            Indent();
            WriteLine("Get");
            Indent();
            WriteLine("Return _{0}", field.Name);
            Outdent();
            WriteLine("End Get");
            Outdent();
            WriteLine("End Property");
        }

        protected override void WriteAccept(string name)
        {
            //Blank();
            //WriteLine("Public Overrides Function Accept(Of A, R)(visitor as BoundTreeVisitor(Of A, R), arg As A) As R");
            //Indent();
            //WriteLine("Return visitor.Visit{0}(Me, arg)", StripBound(name));
            //Outdent();
            //WriteLine("End Function");

            Blank();
            WriteLine("Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode");
            Indent();
            WriteLine("Return visitor.Visit{0}(Me)", StripBound(name));
            Outdent();
            WriteLine("End Function");
        }

        protected override void WriteUpdateMethod(Node node, Boolean emitNew)
        {


            Blank();
            Write("Public{0} Function Update", emitNew ? " Shadows" : "");
            Paren();
            Comma(AllSpecifiableFields(node), field => string.Format("{1} As {0}", field.Type, ToCamelCase(field.Name)));
            UnParen();
            WriteLine(" As {0}", node.Name);
            Indent();

            if (AllSpecifiableFields(node).Any())
            {
                Write("If ");
                Or(AllSpecifiableFields(node),
                    field => IsValueType(field.Type) ?
                                string.Format("{0} <> Me.{1}", ToCamelCase(field.Name), field.Name) :
                                string.Format("{0} IsNot Me.{1}", ToCamelCase(field.Name), field.Name));
                WriteLine(" Then");
                Indent();
                Write("Dim result = New {0}", node.Name);
                var fields = new[] { "Me.Syntax" }.Concat(AllSpecifiableFields(node).Select(f => ToCamelCase(f.Name))).Concat(new[] { "Me.HasErrors" });
                ParenList(fields);
                WriteLine("");
                WriteLine("");
                WriteLine("If Me.WasCompilerGenerated Then");
                Indent();
                WriteLine("result.SetWasCompilerGenerated()");
                Outdent();
                WriteLine("End If");
                WriteLine("");
                WriteLine("Return result");
                Outdent();
                WriteLine("End If");
            }
            WriteLine("Return Me");

            Outdent();
            WriteLine("End Function");
        }

        protected override void WriteVisitor()
        {
            Blank();
            WriteLine("Friend MustInherit Partial Class BoundTreeVisitor(Of A,R)");
            Indent();

            Blank();
            WriteLine("<MethodImpl(MethodImplOptions.NoInlining)>");
            WriteLine("Friend Function VisitInternal(node As BoundNode, arg As A) As R");
            Indent();
            WriteLine("Select Case node.Kind");
            Indent();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine("Case BoundKind.{0}: ", FixKeyword(StripBound(node.Name)));
                Indent();
                WriteLine("Return Visit{0}(CType(node, {1}), arg)", StripBound(node.Name), node.Name);
                Outdent();
            }
            Outdent();
            WriteLine("End Select");
            WriteLine("Return DefaultVisit(node, arg)");
            Outdent();
            WriteLine("End Function");

            Blank();
            Outdent();
            WriteLine("End Class");

            //Blank();
            //WriteLine("Friend MustInherit Partial Class BoundTreeVisitor");
            //Indent();

            //Blank();
            //WriteLine("<MethodImpl(MethodImplOptions.NoInlining)>");
            //WriteLine("Friend Function VisitInternal(node As BoundNode) As BoundNode");
            //Indent();
            //WriteLine("Select Case node.Kind");
            //Indent();
            //foreach (var node in tree.Types.OfType<Node>())
            //{
            //    WriteLine("Case BoundKind.{0}: ", FixKeyword(StripBound(node.Name)));
            //    Indent();
            //    WriteLine("Return Visit{0}(CType(node, {1}))", StripBound(node.Name), node.Name);
            //    Outdent();
            //}
            //Outdent();
            //WriteLine("End Select");
            //WriteLine("Return DefaultVisit(node)");
            //Outdent();
            //WriteLine("End Function");

            //Blank();
            //Outdent();
            //WriteLine("End Class");

            Blank();
            WriteLine("Friend MustInherit Partial Class BoundTreeVisitor(Of A,R)");
            Indent();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine("Public Overridable Function Visit{0}(node As {1}, arg As A) As R", StripBound(node.Name), node.Name);
                Indent();
                WriteLine("Return Me.DefaultVisit(node, arg)");
                Outdent();
                WriteLine("End Function");
                Blank();
            }
            Outdent();
            WriteLine("End Class");

            Blank();
            WriteLine("Friend MustInherit Partial Class BoundTreeVisitor");
            Indent();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine("Public Overridable Function Visit{0}(node As {1}) As BoundNode", StripBound(node.Name), node.Name);
                Indent();
                WriteLine("Return Me.DefaultVisit(node)");
                Outdent();
                WriteLine("End Function");
                Blank();
            }
            Outdent();
            WriteLine("End Class");
        }

        protected override void WriteWalker()
        {
            Blank();
            WriteLine("Friend MustInherit Partial Class BoundTreeWalker");
            Indent();
            WriteLine("Inherits BoundTreeVisitor");
            Blank();

            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine("Public Overrides Function Visit{0}(node as {1}) As BoundNode", StripBound(node.Name), node.Name);
                Indent();
                foreach (Field field in AllFields(node).Where(f => IsDerivedOrListOfDerived("BoundNode", f.Type) && !SkipInVisitor(f)))
                    WriteLine("Me.Visit{1}(node.{0})", field.Name, IsNodeList(field.Type) ? "List" : "");
                WriteLine("Return Nothing");
                Outdent();
                WriteLine("End Function");
                Blank();
            }

            Outdent();
            WriteLine("End Class");
        }

        protected override void WriteTreeDumperNodeProducer()
        {
            Blank();
            WriteLine("Friend NotInheritable Class BoundTreeDumperNodeProducer");
            Indent();
            WriteLine("Inherits BoundTreeVisitor(Of Object, TreeDumperNode)");
            Blank();
            WriteLine("Private Sub New()");
            WriteLine("End Sub");
            Blank();
            WriteLine("Public Shared Function MakeTree(node As BoundNode) As TreeDumperNode");
            Indent();
            WriteLine("Return (New BoundTreeDumperNodeProducer()).Visit(node, Nothing)");
            Outdent();
            WriteLine("End Function");
            Blank();

            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine("Public Overrides Function Visit{0}(node As {1}, arg As Object) As TreeDumperNode", StripBound(node.Name), node.Name);
                Indent();
                Write("Return New TreeDumperNode(\"{0}\", Nothing, ", ToCamelCase(StripBound(node.Name)));
                var allFields = AllFields(node).ToArray();
                if (allFields.Length > 0)
                {
                    WriteLine("New TreeDumperNode() {{");
                    Indent();
                    for (int i = 0; i < allFields.Length; ++i)
                    {
                        Field field = allFields[i];
                        if (IsDerivedType("BoundNode", field.Type))
                            Write("New TreeDumperNode(\"{0}\", Nothing, new TreeDumperNode() {{ Visit(node.{1}, Nothing) }})", ToCamelCase(field.Name), field.Name);
                        else if (IsListOfDerived("BoundNode", field.Type))
                            Write("New TreeDumperNode(\"{0}\", Nothing, From x In node.{1} Select Visit(x, Nothing))", ToCamelCase(field.Name), field.Name);
                        else
                            Write("New TreeDumperNode(\"{0}\", node.{1}, Nothing)", ToCamelCase(field.Name), field.Name);

                        if (i == allFields.Length - 1)
                            WriteLine("");
                        else
                            WriteLine(",");
                    }
                    Outdent();
                    WriteLine("}})");
                }
                else
                {
                    WriteLine("Array.Empty(Of TreeDumperNode)())");
                }
                Outdent();
                WriteLine("End Function");
                Blank();
            }
            Outdent();
            WriteLine("End Class");
        }

        protected override void WriteRewriter()
        {
            Blank();
            WriteLine("Friend MustInherit Partial Class BoundTreeRewriter");
            Indent();
            WriteLine("Inherits BoundTreeVisitor");
            Blank();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine("Public Overrides Function Visit{0}(node As {1}) As BoundNode", StripBound(node.Name), node.Name);
                Indent();

                bool hadField = false;
                foreach (Field field in AllNodeOrNodeListFields(node))
                {
                    hadField = true;

                    if (SkipInVisitor(field))
                        WriteLine("Dim {0} As {2} = node.{1}", ToCamelCase(field.Name), field.Name, field.Type);
                    else if (IsNodeList(field.Type))
                        WriteLine("Dim {0} As {2} = Me.VisitList(node.{1})", ToCamelCase(field.Name), field.Name, field.Type);
                    else
                        WriteLine("Dim {0} As {2} = DirectCast(Me.Visit(node.{1}), {2})", ToCamelCase(field.Name), field.Name, field.Type);
                }
                foreach (Field field in AllTypeFields(node))
                {
                    hadField = true;
                    WriteLine("Dim {0} as TypeSymbol = Me.VisitType(node.{1})", ToCamelCase(field.Name), field.Name);
                }

                if (hadField)
                {
                    Write("Return node.Update");
                    ParenList(AllSpecifiableFields(node), field => IsDerivedOrListOfDerived("BoundNode", field.Type) || field.Type == "TypeSymbol" ? ToCamelCase(field.Name) : string.Format("node.{0}", field.Name));
                    WriteLine("");
                }
                else
                {
                    WriteLine("Return node");
                }

                Outdent();
                WriteLine("End Function");
                Blank();
            }
            Outdent();
            WriteLine("End Class");
        }

        protected override bool IsImmutableArray(string typeName) => typeName.StartsWith("ImmutableArray(Of", StringComparison.OrdinalIgnoreCase);

        protected override bool IsNodeList(string typeName) => typeName.StartsWith("IList(Of", StringComparison.OrdinalIgnoreCase) ||
                                                    typeName.StartsWith("ImmutableArray(Of", StringComparison.OrdinalIgnoreCase);

        protected override string GetGenericType(string typeName)
        {
            int iStart = typeName.IndexOf("(Of", StringComparison.OrdinalIgnoreCase);

            if (iStart == -1)
                return typeName;

            return typeName.Substring(0, iStart);
        }

        protected override string GetElementType(string typeName)
        {
            int iStart = typeName.IndexOf("(Of", StringComparison.OrdinalIgnoreCase);

            if (iStart == -1)
                return string.Empty;

            int iEnd = typeName.IndexOf(')', iStart + 3);
            if (iEnd < iStart)
                return string.Empty;
            var sub = typeName.Substring(iStart + 3, iEnd - iStart - 3).Trim();
            return sub;
        }

        protected override string EscapeKeyword(string name) => "[" + name + "]";

         protected override bool IsKeyword(string name) => name.IsVBKeyword();
    }
}
