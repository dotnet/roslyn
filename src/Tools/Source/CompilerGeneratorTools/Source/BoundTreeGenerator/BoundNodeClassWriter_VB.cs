// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace BoundTreeGenerator
{
    internal sealed class BoundNodeClassWriter_VB : BoundNodeClassWriter
    {
        internal BoundNodeClassWriter_VB(TextWriter writer, Tree tree)
            : base(writer, tree, TargetLanguage.VB) { }

        protected override void InitializeValueTypes(ref Dictionary<string, bool> _valueTypes)
        {
            _valueTypes.Add("Boolean", true);
            _valueTypes.Add("Integer", true);
            _valueTypes.Add("UInteger", true);
            _valueTypes.Add("Short", true);
            _valueTypes.Add("UShort", true);
            _valueTypes.Add("Long", true);
            _valueTypes.Add("ULong", true);
            _valueTypes.Add("Byte", true);
            _valueTypes.Add("SByte", true);
            _valueTypes.Add("Char", true);
        }

        protected override void Write_AutoGenerated() => WriteLine("' <auto-generated />");

        protected override void WriteUsing(string nsName) => WriteLine($"Imports {nsName}");

        protected override void WriteStartNamespace()
        {
            WriteLine("Imports Microsoft.CodeAnalysis.Text");
            WriteLine("Imports Microsoft.CodeAnalysis.VisualBasic.Symbols");
            WriteLine("Imports Microsoft.CodeAnalysis.VisualBasic.Syntax");
            Blank();
            WriteLine("Namespace Microsoft.CodeAnalysis.VisualBasic");
            Indent();
        }

        protected override void WriteEndNamespace()
        {
            Outdent();
            WriteLine("End Namespace");
        }

        protected override void WriteKinds()
        {
            WriteLine("Friend Enum BoundKind as Byte");
            Indent();
            foreach (var node in _tree.Types.OfType<Node>())
                WriteLine(FixKeyword(StripBound(node.Name)));
            Outdent();
            WriteLine("End Enum");
        }

        protected override void WriteClassHeader(TreeType node)
        {
            string abstr = "";
            if (node is AbstractNode)
                abstr = "MustInherit ";
            else if (CanBeSealed(node))
                abstr = "NotInheritable ";
            WriteLine($"Friend {abstr}Partial Class {node.Name}");
            Indent();
            WriteLine($"Inherits {node.Base}");
            Blank();
        }

        protected override void WriteClassFooter(TreeType node)
        {
            Outdent();
            WriteLine("End Class");
        }

        protected override void Or<T>(IEnumerable<T> items, Func<T, string> func) => SeparatedList(" OrElse ", items, func);

        protected override void WriteConstructorWithHasErrors(TreeType node, bool isPublic, bool hasErrorsIsOptional)
        {
            // A public constructor does not have an explicit kind parameter.
            var porp = isPublic ? "Public" : "Protected";
            Write($"{porp} Sub New");
            IEnumerable<string> fields = isPublic ? new[] { "syntax As SyntaxNode" } : new[] { "kind As BoundKind", "syntax as SyntaxNode" };
            fields = fields.Concat(from field in AllSpecifiableFields(node)
                                   select ToCamelCase(field.Name) + " As " + field.Type);

            if (hasErrorsIsOptional)
                fields = fields.Concat(new[] { "Optional hasErrors As Boolean = False" });
            else
                fields = fields.Concat(new[] { "hasErrors As Boolean" });

            ParenList(fields, x => x);
            Blank();
            Indent();
            Write("MyBase.New(");
            if (isPublic)
            {
                // Base call has bound kind, syntax, all fields in base type, plus merged HasErrors.
                Write($"BoundKind.{StripBound(node.Name)}");
                Write(", syntax, ");
                WriteFields("", AllSpecifiableFields(BaseType(node)), node, ", ");


                Or((new[] { "hasErrors" })
                    .Concat(from field in AllNodeOrNodeListFields(node)
                            select ToCamelCase(field.Name) + ".NonNullAndHasErrors()"), x => x);
            }
            else
            {
                // Base call has kind, syntax, and hasErrors. No merging of hasErrors because derived class already did the merge.
                Write("kind, syntax, ");
                WriteFields("", AllSpecifiableFields(BaseType(node)), node, ", ");
                Write("hasErrors");
            }
            Write(")");
            Blank();

            WriteNullChecks(node);

            foreach (var field in Fields(node))
            {
                var value = FieldNullHandling(node, field.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(field.Name);
                WriteLine($"Me._{field.Name} = {value}");
            }

            bool hasValidate = HasValidate(node);

            if (hasValidate)
            {
                Blank();
                WriteLine("Validate()");
            }

            Outdent();
            WriteLine("End Sub");
            Blank();

            if (hasValidate)
            {
                WriteLine("Private Partial Sub Validate()");
                WriteLine("End Sub");
                Blank();
            }
        }

        // This constructor should only be created if no node or list fields, since it just calls base class constructor
        // without merging hasErrors.
        protected override void WriteConstructorWithoutHasErrors(TreeType node, bool isPublic)
        {
            // A public constructor does not have an explicit kind parameter.
            var porp = isPublic ? "Public" : "Protected";
            Write($"{porp}  Sub New");
            IEnumerable<string> fields = isPublic ? new[] { "syntax As SyntaxNode" } : new[] { "kind As BoundKind", "syntax as SyntaxNode" };
            fields = fields.Concat(from field in AllSpecifiableFields(node)
                                   select ToCamelCase(field.Name) + " As " + field.Type);
            ParenList(fields, x => x);
            Blank();
            Indent();
            Write("MyBase.New(");
            if (isPublic)
            {
                // Base call has bound kind, syntax, fields.
                Write($"BoundKind.{StripBound(node.Name)}");
                Write(", syntax");
                WriteFields(", ", AllSpecifiableFields(BaseType(node)), node,"");
            }
            else
            {
                // Base call has kind, syntax, fields
                Write("kind, syntax");
                WriteFields(", ", AllSpecifiableFields(BaseType(node)),node, "");
            }
            Write(")");
            Blank();

            WriteNullChecks(node);

            foreach (var field in Fields(node))
            {
                var value = FieldNullHandling(node, field.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(field.Name);
                WriteLine($"Me._{field.Name} = {value}");
            }

            if (HasValidate(node))
            {
                Blank();
                WriteLine("Validate()");
            }

            Outdent();
            WriteLine("End Sub");
            Blank();
        }

        private void WriteFields(string prefix,IEnumerable<Field> fx,TreeType node,string postfix)
        {
            foreach (Field baseField in fx)
            {
                var value = FieldNullHandling(node, baseField.Name) == NullHandling.Always ? "Nothing" : ToCamelCase(baseField.Name);
                Write($"{prefix}{value}{postfix}");
            }
        }

        protected override void WriteNullCheck(bool isROArray, Field field)
        {
            var fieldName = ToCamelCase(field.Name);
            if (isROArray)
                Write($"Debug.Assert(Not {fieldName}.IsDefault");
            else
                Write($"Debug.Assert({fieldName} IsNot Nothing");
            WriteLine($", \"Field '{fieldName}' cannot be null (use Null=\"\"allow\"\" in BoundNodes.xml to remove this check)\")");
        }

        protected override void WriteField(Field field)
        {
            Blank();
            var Shadows = (IsNew(field) ? "Shadows " : "");
            WriteLine($"Private {Shadows}ReadOnly _{field.Name} As {field.Type}");
            Shadows = (IsNew(field) ? "Shadows " : IsPropertyOverrides(field) ? "Overrides " : "");
            WriteLine($"Public {Shadows}ReadOnly Property {field.Name} As {field.Type}");
            Indent();
            WriteLine("Get");
            Indent();
            WriteLine($"Return _{field.Name}");
            Outdent();
            WriteLine("End Get");
            Outdent();
            WriteLine("End Property");
        }

        protected override void WriteAccept(string name)
        {
            //Blank();
            //WriteLine("Public Overrides Function Accept(Of A, R)(visitor as BoundTreeVisitor(Of A, R), arg As A) As R");
            //Indent();
            //WriteLine("Return visitor.Visit{0}(Me, arg)", StripBound(name));
            //Outdent();
            //WriteLine("End Function");

            Blank();
            WriteLine("Public Overrides Function Accept(visitor as BoundTreeVisitor) As BoundNode");
            Indent();
            WriteLine($"Return visitor.Visit{StripBound(name)}(Me)");
            Outdent();
            WriteLine("End Function");
        }

        protected override void WriteUpdateMethod(Node node, Boolean emitNew)
        {
            Blank();
            var Shadows = emitNew ? " Shadows" : "";
            Write($"Public{Shadows} Function Update");
            Paren();
            Comma(AllSpecifiableFields(node), field => $"{ToCamelCase(field.Name)} As {field.Type}");
            UnParen();
            WriteLine($" As { node.Name}");
            Indent();

            if (AllSpecifiableFields(node).Any())
            {
                Write("If ");
                Or(AllSpecifiableFields(node),
                    field => IsValueType(field.Type) ?
                                $"{ToCamelCase(field.Name)} <> Me.{field.Name}" :
                                $"{ToCamelCase(field.Name)} IsNot Me.{field.Name}");
                WriteLine(" Then");
                Indent();
                Write($"Dim result = New {node.Name}");
                var fields = new[] { "Me.Syntax" }.Concat(AllSpecifiableFields(node).Select(f => ToCamelCase(f.Name))).Concat(new[] { "Me.HasErrors" });
                ParenList(fields);
                WriteLine("");
                WriteLine("");
                WriteLine("If Me.WasCompilerGenerated Then");
                Indent();
                WriteLine("result.SetWasCompilerGenerated()");
                Outdent();
                WriteLine("End If");
                WriteLine("");
                WriteLine("Return result");
                Outdent();
                WriteLine("End If");
            }
            WriteLine("Return Me");

            Outdent();
            WriteLine("End Function");
        }

        protected override void WriteVisitor()
        {
            Blank();
            WriteLine("Friend MustInherit Partial Class BoundTreeVisitor(Of A,R)");
            Indent();

            Blank();
            WriteLine("<MethodImpl(MethodImplOptions.NoInlining)>");
            WriteLine("Friend Function VisitInternal(node As BoundNode, arg As A) As R");
            Indent();
            WriteLine("Select Case node.Kind");
            Indent();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine($"Case BoundKind.{FixKeyword(StripBound(node.Name))}: ");
                Indent();
                WriteLine($"Return Visit{StripBound(node.Name)}(CType(node, {node.Name}), arg)");
                Outdent();
            }
            Outdent();
            WriteLine("End Select");
            WriteLine("Return DefaultVisit(node, arg)");
            Outdent();
            WriteLine("End Function");

            Blank();
            Outdent();
            WriteLine("End Class");

            //Blank();
            //WriteLine("Friend MustInherit Partial Class BoundTreeVisitor");
            //Indent();

            //Blank();
            //WriteLine("<MethodImpl(MethodImplOptions.NoInlining)>");
            //WriteLine("Friend Function VisitInternal(node As BoundNode) As BoundNode");
            //Indent();
            //WriteLine("Select Case node.Kind");
            //Indent();
            //foreach (var node in tree.Types.OfType<Node>())
            //{
            //    WriteLine("Case BoundKind.{0}: ", FixKeyword(StripBound(node.Name)));
            //    Indent();
            //    WriteLine("Return Visit{0}(CType(node, {1}))", StripBound(node.Name), node.Name);
            //    Outdent();
            //}
            //Outdent();
            //WriteLine("End Select");
            //WriteLine("Return DefaultVisit(node)");
            //Outdent();
            //WriteLine("End Function");

            //Blank();
            //Outdent();
            //WriteLine("End Class");

            Blank();
            WriteLine("Friend MustInherit Partial Class BoundTreeVisitor(Of A,R)");
            Indent();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine($"Public Overridable Function Visit{StripBound(node.Name)}(node As {node.Name}, arg As A) As R");
                Indent();
                WriteLine("Return Me.DefaultVisit(node, arg)");
                Outdent();
                WriteLine("End Function");
                Blank();
            }
            Outdent();
            WriteLine("End Class");

            Blank();
            WriteLine("Friend MustInherit Partial Class BoundTreeVisitor");
            Indent();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine($"Public Overridable Function Visit{StripBound(node.Name)}(node As {node.Name}) As BoundNode");
                Indent();
                WriteLine("Return Me.DefaultVisit(node)");
                Outdent();
                WriteLine("End Function");
                Blank();
            }
            Outdent();
            WriteLine("End Class");
        }

        protected override void WriteWalker()
        {
            Blank();
            WriteLine("Friend MustInherit Partial Class BoundTreeWalker");
            Indent();
            WriteLine("Inherits BoundTreeVisitor");
            Blank();

            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine($"Public Overrides Function Visit{StripBound(node.Name)}(node as { node.Name}) As BoundNode");
                Indent();
                foreach (Field field in AllFields(node).Where(f => IsDerivedOrListOfDerived("BoundNode", f.Type) && !SkipInVisitor(f)))
                {
                    var member = IsNodeList(field.Type) ? "List" : "";
                    WriteLine($"Me.Visit{member}(node.{field.Name})");
                }
                WriteLine("Return Nothing");
                Outdent();
                WriteLine("End Function");
                Blank();
            }

            Outdent();
            WriteLine("End Class");
        }

        protected override void WriteTreeDumperNodeProducer()
        {
            Blank();
            WriteLine("Friend NotInheritable Class BoundTreeDumperNodeProducer");
            Indent();
            WriteLine("Inherits BoundTreeVisitor(Of Object, TreeDumperNode)");
            Blank();
            WriteLine("Private Sub New()");
            WriteLine("End Sub");
            Blank();
            WriteLine("Public Shared Function MakeTree(node As BoundNode) As TreeDumperNode");
            Indent();
            WriteLine("Return (New BoundTreeDumperNodeProducer()).Visit(node, Nothing)");
            Outdent();
            WriteLine("End Function");
            Blank();

            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine($"Public Overrides Function Visit{StripBound(node.Name)}(node As {node.Name}, arg As Object) As TreeDumperNode");
                Indent();
                Write($"Return New TreeDumperNode(\"{ToCamelCase(StripBound(node.Name))}\", Nothing, ");
                var allFields = AllFields(node).ToArray();
                if (allFields.Length > 0)
                {
                    WriteLine("New TreeDumperNode() {");
                    Indent();
                    for (int i = 0; i < allFields.Length; ++i)
                    {
                        Field field = allFields[i];
                        Write($"New TreeDumperNode(\"{ToCamelCase(field.Name)}\", ");
                        if (IsDerivedType("BoundNode", field.Type))
                            Write("Nothing, new TreeDumperNode() {{ Visit(node.{field.Name}, Nothing) }})");
                        else if (IsListOfDerived("BoundNode", field.Type))
                            Write("Nothing, From x In node.{field.Name} Select Visit(x, Nothing))");
                        else
                            Write("node.{field.Name}, Nothing)");

                        if (i == allFields.Length - 1)
                            WriteLine("");
                        else
                            WriteLine(",");
                    }
                    Outdent();
                    WriteLine("})");
                }
                else
                {
                    WriteLine("Array.Empty(Of TreeDumperNode)())");
                }
                Outdent();
                WriteLine("End Function");
                Blank();
            }
            Outdent();
            WriteLine("End Class");
        }

        protected override void WriteRewriter()
        {
            Blank();
            WriteLine("Friend MustInherit Partial Class BoundTreeRewriter");
            Indent();
            WriteLine("Inherits BoundTreeVisitor");
            Blank();
            foreach (var node in _tree.Types.OfType<Node>())
            {
                WriteLine($"Public Overrides Function Visit{StripBound(node.Name)}(node As {node.Name}) As BoundNode");
                Indent();

                bool hadField = false;
                foreach (Field field in AllNodeOrNodeListFields(node))
                {
                    hadField = true;
                    Write($"Dim {ToCamelCase(field.Name)} As {field.Type} = ");
                    if (SkipInVisitor(field))
                        WriteLine($"node.{field.Name}");
                    else if (IsNodeList(field.Type))
                        WriteLine($"Me.VisitList(node.{field.Name})");
                    else
                        WriteLine($"DirectCast(Me.Visit(node.{field.Name}), {field.Type})");
                }
                foreach (Field field in AllTypeFields(node))
                {
                    hadField = true;
                    WriteLine($"Dim {ToCamelCase(field.Name)} as TypeSymbol = Me.VisitType(node.{field.Name})");
                }

                if (hadField)
                {
                    Write("Return node.Update");
                    ParenList(AllSpecifiableFields(node), field => IsDerivedOrListOfDerived("BoundNode", field.Type) || field.Type == "TypeSymbol" ? ToCamelCase(field.Name) : $"node.{field.Name}");
                    WriteLine("");
                }
                else
                {
                    WriteLine("Return node");
                }

                Outdent();
                WriteLine("End Function");
                Blank();
            }
            Outdent();
            WriteLine("End Class");
        }

        protected override bool IsImmutableArray(string typeName) => typeName.StartsWith("ImmutableArray(Of", StringComparison.OrdinalIgnoreCase);

        protected override bool IsNodeList(string typeName) => typeName.StartsWith("IList(Of", StringComparison.OrdinalIgnoreCase) ||
                                                               typeName.StartsWith("ImmutableArray(Of", StringComparison.OrdinalIgnoreCase);

        protected override string GetGenericType(string typeName)
        {
            int iStart = typeName.IndexOf("(Of", StringComparison.OrdinalIgnoreCase);
            return (iStart == -1) ? typeName : typeName.Substring(0, iStart);
        }

        protected override string GetElementType(string typeName)
        {
            int iStart = typeName.IndexOf("(Of", StringComparison.OrdinalIgnoreCase);
            if (iStart == -1)  return string.Empty;
            int iEnd = typeName.IndexOf(')', iStart + 3);
            if (iEnd < iStart)  return string.Empty;
            return typeName.Substring(iStart + 3, iEnd - iStart - 3).Trim();
        }

        protected override string EscapeKeyword(string name) => "[" + name + "]";

        protected override bool IsKeyword(string name) => name.IsVBKeyword();
    }
}
