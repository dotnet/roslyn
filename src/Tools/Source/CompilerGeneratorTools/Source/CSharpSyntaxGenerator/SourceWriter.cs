// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

#nullable disable

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Xml;
using Microsoft.CodeAnalysis.CSharp;

namespace CSharpSyntaxGenerator
{
    using static FileWriter;

    internal sealed class SourceWriter(Tree tree, CancellationToken cancellationToken = default)
    {
        private readonly FileWriter _fileWriter = new(tree, cancellationToken);

        public static void WriteMain(TextWriter writer, Tree tree, CancellationToken cancellationToken = default)
            => new SourceWriter(tree, cancellationToken).WriteMain(writer);

        public static void WriteInternal(TextWriter writer, Tree tree, CancellationToken cancellationToken = default)
            => new SourceWriter(tree, cancellationToken).WriteInternal(writer);

        public static void WriteSyntax(TextWriter writer, Tree tree, CancellationToken cancellationToken = default)
            => new SourceWriter(tree, cancellationToken).WriteSyntax(writer);

        private static void WriteFileHeader(IndentingStringBuilder builder)
        {
            builder.WriteLine("// <auto-generated />");
            builder.WriteLine();
            builder.WriteLine("#nullable enable");
            builder.WriteLine();
            builder.WriteLine("using System;");
            builder.WriteLine("using System.Collections.Generic;");
            builder.WriteLine("using System.Diagnostics.CodeAnalysis;");
            builder.WriteLine("using Microsoft.CodeAnalysis.Syntax.InternalSyntax;");
            builder.WriteLine("using Roslyn.Utilities;");
            builder.WriteLine("using CoreSyntax = Microsoft.CodeAnalysis.Syntax.InternalSyntax;");
            builder.WriteLine();
        }

        private void WriteInternal(TextWriter writer)
        {
            using var builder = new IndentingStringBuilder();

            WriteFileHeader(builder);
            builder.WriteLine("namespace Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax;");
            WriteGreenTypes(builder);
            WriteGreenVisitors(builder);
            WriteGreenRewriter(builder);
            WriteContextualGreenFactories(builder);
            WriteStaticGreenFactories(builder);

            writer.Write(builder.ToString());
        }

        private void WriteSyntax(TextWriter writer)
        {
            using var builder = new IndentingStringBuilder();

            WriteFileHeader(builder);
            builder.WriteLine("namespace Microsoft.CodeAnalysis.CSharp.Syntax;");
            WriteRedTypes(builder);

            writer.Write(builder.ToString());
        }

        private void WriteMain(TextWriter writer)
        {
            using var builder = new IndentingStringBuilder();

            WriteFileHeader(builder);
            builder.WriteLine("namespace Microsoft.CodeAnalysis.CSharp;");
            builder.WriteLine("using System.Diagnostics.CodeAnalysis;");
            builder.WriteLine("using Microsoft.CodeAnalysis.CSharp.Syntax;");
            WriteRedVisitors(builder);
            WriteRedRewriter(builder);
            WriteRedFactories(builder);

            writer.Write(builder.ToString());
        }

        private void WriteGreenTypes(IndentingStringBuilder builder)
        {
            foreach (var node in _fileWriter.Tree.Types.Where(n => n is not PredefinedNode))
            {
                builder.WriteLine();
                WriteGreenType(builder, node);
            }
        }

        private void WriteGreenType(IndentingStringBuilder builder, TreeType node)
        {
            WriteComment(builder, node.TypeComment);

            if (node is AbstractNode abstractNode)
            {
                builder.WriteLine($"internal abstract partial class {node.Name} : {node.Base}");
                using (builder.EnterBlock())
                {
                    // ctor with diagnostics and annotations
                    builder.WriteLine($"internal {node.Name}(SyntaxKind kind, DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)");
                    builder.WriteLine("  : base(kind, diagnostics, annotations)");
                    using (builder.EnterBlock())
                    {
                        if (node.Name == "DirectiveTriviaSyntax")
                            builder.WriteLine("this.flags |= NodeFlags.ContainsDirectives;");
                    }

                    builder.WriteLine();
                    // ctor without diagnostics and annotations
                    builder.WriteLine($"internal {node.Name}(SyntaxKind kind)");
                    builder.WriteLine("  : base(kind)");

                    using (builder.EnterBlock())
                    {
                        if (node.Name == "DirectiveTriviaSyntax")
                            builder.WriteLine("this.flags |= NodeFlags.ContainsDirectives;");
                    }

                    var valueFields = abstractNode.Fields.Where(n => !_fileWriter.IsNodeOrNodeList(n.Type)).ToList();
                    var nodeFields = abstractNode.Fields.Where(n => _fileWriter.IsNodeOrNodeList(n.Type)).ToList();

                    foreach (var field in nodeFields)
                    {
                        if (_fileWriter.IsNodeOrNodeList(field.Type))
                        {
                            builder.WriteLine();
                            WriteComment(builder, field.PropertyComment);

                            if (IsSeparatedNodeList(field.Type) ||
                                IsNodeList(field.Type))
                            {
                                builder.WriteLine($"public abstract {(IsNew(field) ? "new " : "")}CoreSyntax.{field.Type} {field.Name} {{ get; }}");
                            }
                            else
                            {
                                builder.WriteLine($"public abstract {(IsNew(field) ? "new " : "")}{(GetFieldType(field, green: true))} {field.Name} {{ get; }}");
                            }
                        }
                    }

                    foreach (var field in valueFields)
                    {
                        builder.WriteLine();
                        WriteComment(builder, field.PropertyComment);

                        builder.WriteLine($"public abstract {(IsNew(field) ? "new " : "")}{field.Type} {field.Name} {{ get; }}");
                    }
                }
            }
            else if (node is Node concreteNode)
            {
                builder.WriteLine($"internal sealed partial class {node.Name} : {node.Base}");
                using (builder.EnterBlock())
                {
                    var valueFields = concreteNode.Fields.Where(n => !_fileWriter.IsNodeOrNodeList(n.Type)).ToList();
                    var nodeFields = concreteNode.Fields.Where(n => _fileWriter.IsNodeOrNodeList(n.Type)).ToList();

                    foreach (var field in nodeFields)
                    {
                        var type = GetFieldType(field, green: true);
                        builder.WriteLine($"internal readonly {type} {CamelCase(field.Name)};");
                    }

                    foreach (var field in valueFields)
                    {
                        builder.WriteLine($"internal readonly {field.Type} {CamelCase(field.Name)};");
                    }

                    // write constructor with diagnostics and annotations
                    builder.WriteLine();
                    builder.Write($"internal {node.Name}(SyntaxKind kind");

                    WriteGreenNodeConstructorArgs(builder, nodeFields, valueFields);

                    builder.WriteLine(", DiagnosticInfo[]? diagnostics, SyntaxAnnotation[]? annotations)");
                    builder.WriteLine("  : base(kind, diagnostics, annotations)");
                    using (builder.EnterBlock())
                        WriteCtorBody(builder, valueFields, nodeFields);

                    // write constructor with async
                    builder.WriteLine();
                    builder.Write($"internal {node.Name}(SyntaxKind kind");

                    WriteGreenNodeConstructorArgs(builder, nodeFields, valueFields);

                    builder.WriteLine(", SyntaxFactoryContext context)");
                    builder.WriteLine("  : base(kind)");
                    using (builder.EnterBlock())
                    {
                        builder.WriteLine("this.SetFactoryContext(context);");
                        WriteCtorBody(builder, valueFields, nodeFields);
                    }

                    // write constructor without diagnostics and annotations
                    builder.WriteLine();
                    builder.Write($"internal {node.Name}(SyntaxKind kind");

                    WriteGreenNodeConstructorArgs(builder, nodeFields, valueFields);

                    builder.WriteLine(")");
                    builder.WriteLine("  : base(kind)");
                    using (builder.EnterBlock())
                        WriteCtorBody(builder, valueFields, nodeFields);

                    builder.WriteLine();

                    // property accessors
                    foreach (var field in nodeFields)
                    {
                        WriteComment(builder, field.PropertyComment);
                        if (IsNodeList(field.Type))
                        {
                            var type = $"CoreSyntax.{field.Type}";
                            builder.WriteLine($"public {OverrideOrNewModifier(field)}{type} {field.Name} => new {type}(this.{CamelCase(field.Name)});");
                        }
                        else if (IsSeparatedNodeList(field.Type))
                        {
                            var type = $"CoreSyntax.{field.Type}";
                            builder.WriteLine($"public {OverrideOrNewModifier(field)}{type} {field.Name} => new {type}(new CoreSyntax.SyntaxList<CSharpSyntaxNode>(this.{CamelCase(field.Name)}));");
                        }
                        else if (field.Type == "SyntaxNodeOrTokenList")
                        {
                            var type = $"CoreSyntax.SyntaxList<CSharpSyntaxNode>";
                            builder.WriteLine($"public {OverrideOrNewModifier(field)}{type} {field.Name} => new {type}(this.{CamelCase(field.Name)});");
                        }
                        else
                        {
                            builder.WriteLine($"public {OverrideOrNewModifier(field)}{(GetFieldType(field, green: true))} {field.Name} => {CamelCase(field.Name)};");
                        }
                    }

                    foreach (var field in valueFields)
                    {
                        WriteComment(builder, field.PropertyComment);
                        builder.WriteLine($"public {OverrideOrNewModifier(field)}{field.Type} {field.Name} => {CamelCase(field.Name)};");
                    }

                    // GetSlot
                    builder.WriteLine();
                    builder.Write("internal override GreenNode? GetSlot(int index)");

                    if (nodeFields.Count == 0)
                    {
                        builder.WriteLine(" => null;");
                    }
                    else if (nodeFields.Count == 1)
                    {
                        builder.WriteLine();
                        using (builder.EnterIndentedRegion())
                            builder.WriteLine($"=> index == 0 ? {CamelCase(nodeFields[0].Name)} : null;");
                    }
                    else
                    {
                        builder.WriteLine();
                        using (builder.EnterIndentedRegion())
                        {
                            builder.WriteLine("=> index switch");
                            using (builder.EnterIndentedRegion("{", "};"))
                            {
                                for (int i = 0, n = nodeFields.Count; i < n; i++)
                                {
                                    var field = nodeFields[i];
                                    builder.WriteLine($"{i} => {CamelCase(field.Name)},");
                                }

                                builder.WriteLine("_ => null,");
                            }
                        }
                    }

                    builder.WriteLine();
                    builder.WriteLine($"internal override SyntaxNode CreateRed(SyntaxNode? parent, int position) => new CSharp.Syntax.{node.Name}(this, parent, position);");

                    WriteGreenAcceptMethods(builder, concreteNode);
                    WriteGreenUpdateMethod(builder, concreteNode);
                    WriteSetDiagnostics(builder, concreteNode);
                    WriteSetAnnotations(builder, concreteNode);
                }
            }
        }

        private static void WriteGreenNodeConstructorArgs(IndentingStringBuilder builder, List<Field> nodeFields, List<Field> valueFields)
        {
            foreach (var field in nodeFields)
                builder.Write($", {(GetFieldType(field, green: true))} {CamelCase(field.Name)}");

            foreach (var field in valueFields)
                builder.Write($", {field.Type} {CamelCase(field.Name)}");
        }

        private static void WriteCtorBody(IndentingStringBuilder builder, List<Field> valueFields, List<Field> nodeFields)
        {
            // constructor body
            builder.WriteLine($"this.SlotCount = {nodeFields.Count};");

            foreach (var field in nodeFields)
            {
                if (IsAnyList(field.Type) || IsOptional(field))
                {
                    builder.WriteLine($"if ({CamelCase(field.Name)} != null)");
                    using (builder.EnterBlock())
                    {
                        builder.WriteLine($"this.AdjustFlagsAndWidth({CamelCase(field.Name)});");
                        builder.WriteLine($"this.{CamelCase(field.Name)} = {CamelCase(field.Name)};");
                    }
                }
                else
                {
                    builder.WriteLine($"this.AdjustFlagsAndWidth({CamelCase(field.Name)});");
                    builder.WriteLine($"this.{CamelCase(field.Name)} = {CamelCase(field.Name)};");
                }
            }

            foreach (var field in valueFields)
            {
                builder.WriteLine($"this.{CamelCase(field.Name)} = {CamelCase(field.Name)};");
            }
        }

        private static void WriteSetAnnotations(IndentingStringBuilder builder, Node node)
        {
            builder.WriteLine();
            builder.WriteLine("internal override GreenNode SetAnnotations(SyntaxAnnotation[]? annotations)");
            builder.Write($"    => new {node.Name}(");
            builder.WriteCommaSeparated([
                "this.Kind",
                .. node.Fields.Select(f => $"this.{CamelCase(f.Name)}"),
                "GetDiagnostics()",
                "annotations"]);
            builder.WriteLine(");");
        }

        private static void WriteSetDiagnostics(IndentingStringBuilder builder, Node node)
        {
            builder.WriteLine();
            builder.WriteLine("internal override GreenNode SetDiagnostics(DiagnosticInfo[]? diagnostics)");
            builder.Write($"    => new {node.Name}(");
            builder.WriteCommaSeparated([
                "this.Kind",
                .. node.Fields.Select(f => $"this.{CamelCase(f.Name)}"),
                "diagnostics",
                "GetAnnotations()"]);
            builder.WriteLine(");");
        }

        private static void WriteGreenAcceptMethods(IndentingStringBuilder builder, Node node)
        {
            builder.WriteLine();
            builder.WriteLine($"public override void Accept(CSharpSyntaxVisitor visitor) => visitor.Visit{StripPost(node.Name, "Syntax")}(this);");
            builder.WriteLine($"public override TResult Accept<TResult>(CSharpSyntaxVisitor<TResult> visitor) => visitor.Visit{StripPost(node.Name, "Syntax")}(this);");
        }

        private void WriteGreenVisitors(IndentingStringBuilder builder)
        {
            WriteGreenVisitor(builder, withResult: true);
            WriteGreenVisitor(builder, withResult: false);
        }

        private void WriteGreenVisitor(IndentingStringBuilder builder, bool withResult)
        {
            var nodes = _fileWriter.Tree.Types.Where(n => n is not PredefinedNode).ToList();

            builder.WriteLine();
            builder.WriteLine("internal partial class CSharpSyntaxVisitor" + (withResult ? "<TResult>" : ""));
            using (builder.EnterBlock())
            {
                foreach (var node in nodes.OfType<Node>())
                    builder.WriteLine($"public virtual {(withResult ? "TResult" : "void")} Visit{StripPost(node.Name, "Syntax")}({node.Name} node) => DefaultVisit(node);");
            }
        }

        private void WriteGreenUpdateMethod(IndentingStringBuilder builder, Node node)
        {
            builder.WriteLine();
            builder.Write($"public {node.Name} Update(");
            builder.WriteCommaSeparated(node.Fields.Select(f =>
            {
                var type =
                    f.Type == "SyntaxNodeOrTokenList" ? "CoreSyntax.SyntaxList<CSharpSyntaxNode>" :
                    f.Type == "SyntaxTokenList" ? "CoreSyntax.SyntaxList<SyntaxToken>" :
                    IsNodeList(f.Type) ? "CoreSyntax." + f.Type :
                    IsSeparatedNodeList(f.Type) ? "CoreSyntax." + f.Type :
                    f.Type;

                return $"{type} {CamelCase(f.Name)}";
            }));
            builder.WriteLine(")");

            using (builder.EnterBlock())
            {
                builder.Write("if (");
                builder.WriteSeparated(
                    node.Fields.Where(field =>
                        _fileWriter.IsDerivedOrListOfDerived("SyntaxNode", field.Type) ||
                        _fileWriter.IsDerivedOrListOfDerived("SyntaxToken", field.Type) ||
                        field.Type == "SyntaxNodeOrTokenList"),
                    " || ",
                    static (builder, field) => builder.Write($"{CamelCase(field.Name)} != {field.Name}"));

                builder.WriteLine(")");
                using (builder.EnterBlock())
                {
                    builder.Write($"var newNode = SyntaxFactory.{StripPost(node.Name, "Syntax")}(");
                    builder.WriteCommaSeparated([
                        .. node.Kinds.Count > 1 ? ["this.Kind"] : Array.Empty<string>(),
                        .. node.Fields.Select(f => CamelCase(f.Name))]);
                    builder.WriteLine(");");
                    builder.WriteLine("var diags = GetDiagnostics();");
                    builder.WriteLine("if (diags?.Length > 0)");
                    builder.WriteLine("    newNode = newNode.WithDiagnosticsGreen(diags);");
                    builder.WriteLine("var annotations = GetAnnotations();");
                    builder.WriteLine("if (annotations?.Length > 0)");
                    builder.WriteLine("    newNode = newNode.WithAnnotationsGreen(annotations);");
                    builder.WriteLine("return newNode;");
                }

                builder.WriteLine();
                builder.WriteLine("return this;");
            }
        }

        private void WriteGreenRewriter(IndentingStringBuilder builder)
        {
            var nodes = _fileWriter.Tree.Types.Where(n => n is not PredefinedNode).ToList();

            builder.WriteLine();
            builder.WriteLine("internal partial class CSharpSyntaxRewriter : CSharpSyntaxVisitor<CSharpSyntaxNode>");
            using (builder.EnterBlock())
            {
                builder.WriteBlankLineSeparated(
                    nodes.OfType<Node>(),
                    static (builder, node, @this) =>
                    {
                        var nodeFields = node.Fields.Where(nd => @this._fileWriter.IsNodeOrNodeList(nd.Type)).ToList();

                        builder.WriteLine($"public override CSharpSyntaxNode Visit{StripPost(node.Name, "Syntax")}({node.Name} node)");
                        using (builder.EnterIndentedRegion())
                        {
                            if (nodeFields.Count == 0)
                            {
                                builder.WriteLine("=> node;");
                            }
                            else
                            {
                                builder.Write("=> node.Update(");
                                builder.WriteCommaSeparated(node.Fields.Select(f =>
                                {
                                    if (IsAnyList(f.Type))
                                        return $"VisitList(node.{f.Name})";
                                    else if (@this._fileWriter.IsNode(f.Type))
                                        return $"({f.Type})Visit(node.{f.Name})";
                                    else
                                        return $"node.{f.Name}";
                                }));
                                builder.WriteLine(");");
                            }
                        }
                    }, this);
            }
        }

        private void WriteContextualGreenFactories(IndentingStringBuilder builder)
        {
            var nodes = _fileWriter.Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode).ToList();
            builder.WriteLine();
            builder.WriteLine("internal partial class ContextAwareSyntax");
            using (builder.EnterBlock())
            {
                builder.WriteLine();
                builder.WriteLine("private SyntaxFactoryContext context;");

                builder.WriteLine();
                builder.WriteLine("public ContextAwareSyntax(SyntaxFactoryContext context)");
                builder.WriteLine("    => context = context;");

                WriteGreenFactories(builder, nodes, withSyntaxFactoryContext: true);
            }
        }

        private void WriteStaticGreenFactories(IndentingStringBuilder builder)
        {
            var nodes = _fileWriter.Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode).ToList();
            builder.WriteLine();
            builder.WriteLine("internal static partial class SyntaxFactory");
            using (builder.EnterBlock())
                WriteGreenFactories(builder, nodes);
        }

        private void WriteGreenFactories(IndentingStringBuilder builder, List<TreeType> nodes, bool withSyntaxFactoryContext = false)
        {
            foreach (var node in nodes.OfType<Node>())
            {
                builder.WriteLine();
                WriteGreenFactory(builder, node, withSyntaxFactoryContext);
            }
        }

        private void WriteGreenFactory(IndentingStringBuilder builder, Node nd, bool withSyntaxFactoryContext = false)
        {
            var valueFields = nd.Fields.Where(n => !_fileWriter.IsNodeOrNodeList(n.Type)).ToList();
            var nodeFields = nd.Fields.Where(n => _fileWriter.IsNodeOrNodeList(n.Type)).ToList();

            builder.Write($"public {(withSyntaxFactoryContext ? "" : "static ")}{nd.Name} {StripPost(nd.Name, "Syntax")}(");
            WriteGreenFactoryParameters(builder, nd);
            builder.WriteLine(")");
            using (builder.EnterBlock())
            {
                // validate kind
                if (nd.Kinds.Count >= 2)
                {
                    builder.WriteLine("switch (kind)");
                    using (builder.EnterBlock())
                    {
                        var kinds = nd.Kinds.Distinct().ToList();
                        foreach (var kind in kinds)
                            builder.WriteLine($"case SyntaxKind.{kind.Name}:{(kind == kinds.Last() ? " break;" : "")}");

                        builder.WriteLine("default: throw new ArgumentException(nameof(kind));");
                    }
                }

                // validate parameters
                builder.WriteLine("#if DEBUG", skipIndent: true);
                foreach (var field in nodeFields)
                {
                    var pname = CamelCase(field.Name);

                    if (!IsAnyList(field.Type) && !IsOptional(field))
                        builder.WriteLine($"if ({CamelCase(field.Name)} == null) throw new ArgumentNullException(nameof({CamelCase(field.Name)}));");

                    if (field.Type == "SyntaxToken" && field.Kinds != null && field.Kinds.Count > 0)
                    {
                        if (IsOptional(field))
                        {
                            builder.WriteLine($"if ({CamelCase(field.Name)} != null)");
                            builder.WriteLine("{");
                            builder.IncreaseIndent();
                        }

                        if (field.Kinds.Count == 1 && !IsOptional(field))
                        {
                            builder.WriteLine($"if ({pname}.Kind != SyntaxKind.{field.Kinds[0].Name}) throw new ArgumentException(nameof({pname}));");
                        }
                        else
                        {
                            builder.WriteLine($"switch ({pname}.Kind)");
                            using (builder.EnterBlock())
                            {
                                var kinds = field.Kinds.Distinct().ToList();

                                //we need to check for Kind=None as well as node == null because that's what the red factory will pass
                                if (IsOptional(field))
                                {
                                    kinds.Add(new Kind { Name = "None" });
                                }

                                foreach (var kind in kinds)
                                {
                                    builder.WriteLine($"case SyntaxKind.{kind.Name}:{(kind == kinds.Last() ? " break;" : "")}");
                                }

                                builder.WriteLine($"default: throw new ArgumentException(nameof({pname}));");
                            }
                        }

                        if (IsOptional(field))
                        {
                            builder.DecreaseIndent();
                            builder.WriteLine("}");
                        }
                    }
                }

                builder.WriteLine("#endif", skipIndent: true);

                if (nd.Name != "SkippedTokensTriviaSyntax" &&
                    nd.Name != "DocumentationCommentTriviaSyntax" &&
                    nd.Name != "IncompleteMemberSyntax" &&
                    valueFields.Count + nodeFields.Count <= 3)
                {
                    builder.WriteLine();
                    builder.WriteLine("int hash;");
                    if (withSyntaxFactoryContext)
                    {
                        builder.Write("var cached = CSharpSyntaxNodeCache.TryGetNode((int)");
                    }
                    else
                    {
                        builder.Write("var cached = SyntaxNodeCache.TryGetNode((int)");
                    }

                    WriteCtorArgList(builder, nd, withSyntaxFactoryContext, valueFields, nodeFields);
                    builder.WriteLine(", out hash);");
                    builder.WriteLine($"if (cached != null) return ({nd.Name})cached;");
                    builder.WriteLine();

                    builder.Write($"var result = new {nd.Name}(");
                    WriteCtorArgList(builder, nd, withSyntaxFactoryContext, valueFields, nodeFields);
                    builder.WriteLine(");");

                    builder.WriteLine("if (hash >= 0)");
                    using (builder.EnterBlock())
                        builder.WriteLine("SyntaxNodeCache.AddNode(result, hash);");

                    builder.WriteLine();

                    //return result;
                    builder.WriteLine("return result;");
                }
                else
                {
                    builder.WriteLine();
                    builder.Write($"return new {nd.Name}(");
                    WriteCtorArgList(builder, nd, withSyntaxFactoryContext, valueFields, nodeFields);
                    builder.WriteLine(");");
                }
            }
        }

        private static void WriteGreenFactoryParameters(IndentingStringBuilder builder, Node nd)
        {
            builder.WriteCommaSeparated([
                .. nd.Kinds.Count > 1 ? ["SyntaxKind kind"] : Array.Empty<string>(),
                .. nd.Fields.Select(f =>
                {
                    var type = f.Type switch
                    {
                        "SyntaxNodeOrTokenList" => "CoreSyntax.SyntaxList<CSharpSyntaxNode>",
                        _ when IsSeparatedNodeList(f.Type) || IsNodeList(f.Type) => $"CoreSyntax.{f.Type}",
                        _ => GetFieldType(f, green: true),
                    };

                    return $"{type} {CamelCase(f.Name)}";
                })]);
        }

        private static void WriteCtorArgList(IndentingStringBuilder builder, Node nd, bool withSyntaxFactoryContext, List<Field> valueFields, List<Field> nodeFields)
        {
            builder.WriteCommaSeparated([
                nd.Kinds.Count == 1 ? $"SyntaxKind.{nd.Kinds[0].Name}" : "kind",
                .. nodeFields.Select(f =>
                    f.Type == "SyntaxList<SyntaxToken>" || IsAnyList(f.Type)
                        ? $"{CamelCase(f.Name)}.Node"
                        : CamelCase(f.Name)),
                // values are at end
                .. valueFields.Select(f => CamelCase(f.Name)),
                .. withSyntaxFactoryContext ? ["this.context"] : Array.Empty<string>()]);
        }

        private void WriteRedTypes(IndentingStringBuilder builder)
        {
            var nodes = _fileWriter.Tree.Types.Where(n => n is not PredefinedNode).ToList();
            foreach (var node in nodes)
            {
                builder.WriteLine();
                WriteRedType(builder, node);
            }
        }

        private List<Field> GetNodeOrNodeListFields(TreeType node)
            => node is AbstractNode an
                ? an.Fields.Where(n => _fileWriter.IsNodeOrNodeList(n.Type)).ToList()
                : node is Node nd
                    ? nd.Fields.Where(n => _fileWriter.IsNodeOrNodeList(n.Type)).ToList()
                    : new List<Field>();

        private void WriteRedType(IndentingStringBuilder builder, TreeType node)
        {
            WriteComment(builder, node.TypeComment);

            if (node is AbstractNode abstractNode)
            {
                builder.WriteLine($"public abstract partial class {node.Name} : {node.Base}");
                using (builder.EnterBlock())
                {
                    builder.WriteLine($"internal {node.Name}(InternalSyntax.CSharpSyntaxNode green, SyntaxNode? parent, int position)");
                    builder.WriteLine("  : base(green, parent, position)");
                    using (builder.EnterBlock())
                    {
                    }

                    var valueFields = abstractNode.Fields.Where(n => !_fileWriter.IsNodeOrNodeList(n.Type)).ToList();
                    var nodeFields = GetNodeOrNodeListFields(abstractNode);

                    foreach (var field in nodeFields)
                    {
                        if (_fileWriter.IsNodeOrNodeList(field.Type))
                        {
                            //red SyntaxLists can't contain tokens, so we switch to SyntaxTokenList
                            var fieldType = GetRedFieldType(field);
                            builder.WriteLine();
                            WriteComment(builder, field.PropertyComment);
                            builder.WriteLine($"{"public"} abstract {(IsNew(field) ? "new " : "")}{fieldType} {field.Name} {{ get; }}");
                            builder.WriteLine($"public {node.Name} With{field.Name}({fieldType} {CamelCase(field.Name)}) => With{field.Name}Core({CamelCase(field.Name)});");
                            builder.WriteLine($"internal abstract {node.Name} With{field.Name}Core({fieldType} {CamelCase(field.Name)});");

                            if (IsAnyList(field.Type))
                            {
                                var argType = GetElementType(field.Type);
                                builder.WriteLine();
                                builder.WriteLine($"public {node.Name} Add{field.Name}(params {argType}[] items) => Add{field.Name}Core(items);");
                                builder.WriteLine($"internal abstract {node.Name} Add{field.Name}Core(params {argType}[] items);");
                            }
                            else
                            {
                                var referencedNode = TryGetNodeForNestedList(field);
                                if (referencedNode != null)
                                {
                                    foreach (var referencedNodeField in referencedNode.Fields)
                                    {
                                        if (IsAnyList(referencedNodeField.Type))
                                        {
                                            var argType = GetElementType(referencedNodeField.Type);

                                            builder.WriteLine();
                                            builder.WriteLine($"public {node.Name} Add{StripPost(field.Name, "Opt")}{referencedNodeField.Name}(params {argType}[] items) => Add{StripPost(field.Name, "Opt")}{referencedNodeField.Name}Core(items);");
                                            builder.WriteLine($"internal abstract {node.Name} Add{StripPost(field.Name, "Opt")}{referencedNodeField.Name}Core(params {argType}[] items);");
                                        }
                                    }
                                }
                            }
                        }
                    }

                    foreach (var field in valueFields)
                    {
                        builder.WriteLine();
                        WriteComment(builder, field.PropertyComment);
                        builder.WriteLine($"{"public"} abstract {(IsNew(field) ? "new " : "")}{field.Type} {field.Name} {{ get; }}");
                    }

                    var baseType = _fileWriter.GetTreeType(node.Base);
                    if (baseType != null)
                    {
                        var baseNodeFields = GetNodeOrNodeListFields(baseType);
                        if (baseNodeFields.Count > 0)
                        {
                            builder.WriteLine();
                        }

                        foreach (var baseField in baseNodeFields)
                        {
                            builder.WriteLine($"public new {node.Name} With{baseField.Name}({GetRedFieldType(baseField)} {CamelCase(baseField.Name)}) => ({node.Name})With{baseField.Name}Core({CamelCase(baseField.Name)});");
                        }

                        foreach (var baseField in baseNodeFields)
                        {
                            if (IsAnyList(baseField.Type))
                            {
                                var argType = GetElementType(baseField.Type);
                                builder.WriteLine();
                                builder.WriteLine($"public new {node.Name} Add{baseField.Name}(params {argType}[] items) => ({node.Name})Add{baseField.Name}Core(items);");
                            }
                            else
                            {
                                var referencedNode = TryGetNodeForNestedList(baseField);
                                if (referencedNode != null)
                                {
                                    // look for list members...
                                    foreach (var referencedNodeField in referencedNode.Fields)
                                    {
                                        if (IsAnyList(referencedNodeField.Type))
                                        {
                                            var argType = GetElementType(referencedNodeField.Type);

                                            builder.WriteLine();
                                            builder.WriteLine($"public new {baseType.Name} Add{StripPost(baseField.Name, "Opt")}{referencedNodeField.Name}(params {argType}[] items) => Add{StripPost(baseField.Name, "Opt")}{referencedNodeField.Name}Core(items);");
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            else if (node is Node concreteNode)
            {
                WriteComment(builder, $"<remarks>");
                WriteComment(builder, $"<para>This node is associated with the following syntax kinds:</para>");
                WriteComment(builder, $"<list type=\"bullet\">");

                foreach (var kind in concreteNode.Kinds)
                {
                    WriteComment(builder, $"<item><description><see cref=\"SyntaxKind.{kind.Name}\"/></description></item>");
                }

                WriteComment(builder, $"</list>");
                WriteComment(builder, $"</remarks>");
                builder.WriteLine($"public sealed partial class {node.Name} : {node.Base}");
                using (builder.EnterBlock())
                {
                    var valueFields = concreteNode.Fields.Where(n => !_fileWriter.IsNodeOrNodeList(n.Type)).ToList();
                    var nodeFields = concreteNode.Fields.Where(n => _fileWriter.IsNodeOrNodeList(n.Type)).ToList();

                    foreach (var field in nodeFields)
                    {
                        if (field.Type is not "SyntaxToken"
                            and not "SyntaxList<SyntaxToken>")
                        {
                            if (IsSeparatedNodeList(field.Type) || field.Type == "SyntaxNodeOrTokenList")
                            {
                                builder.WriteLine($"private SyntaxNode? {CamelCase(field.Name)};");
                            }
                            else
                            {
                                var type = GetFieldType(field, green: false);
                                builder.WriteLine($"private {type} {CamelCase(field.Name)};");
                            }
                        }
                    }

                    // write constructor
                    builder.WriteLine();
                    builder.WriteLine($"internal {node.Name}(InternalSyntax.CSharpSyntaxNode green, SyntaxNode? parent, int position)");
                    builder.WriteLine("  : base(green, parent, position)");
                    using (builder.EnterBlock())
                    {
                    }

                    builder.WriteLine();

                    // property accessors
                    for (int i = 0, n = nodeFields.Count; i < n; i++)
                    {
                        var field = nodeFields[i];
                        if (field.Type == "SyntaxToken")
                        {
                            WriteComment(builder, field.PropertyComment);
                            builder.Write($"public {OverrideOrNewModifier(field)}{GetRedPropertyType(field)} {field.Name}");
                            if (IsOptional(field))
                            {
                                builder.WriteLine();
                                using (builder.EnterBlock())
                                {
                                    builder.WriteLine("get");
                                    using (builder.EnterBlock())
                                    {
                                        builder.WriteLine($"var slot = ((Syntax.InternalSyntax.{node.Name})this.Green).{CamelCase(field.Name)};");
                                        builder.WriteLine($"return slot != null ? new SyntaxToken(this, slot, {GetChildPosition(i)}, {GetChildIndex(i)}) : default;");
                                    }
                                }
                            }
                            else
                            {
                                builder.WriteLine($" => new SyntaxToken(this, ((InternalSyntax.{node.Name})this.Green).{CamelCase(field.Name)}, {GetChildPosition(i)}, {GetChildIndex(i)});");
                            }
                        }
                        else if (field.Type == "SyntaxList<SyntaxToken>")
                        {
                            WriteComment(builder, field.PropertyComment);
                            builder.WriteLine($"public {OverrideOrNewModifier(field)}SyntaxTokenList {field.Name}");
                            using (builder.EnterBlock())
                            {
                                builder.WriteLine("get");
                                using (builder.EnterBlock())
                                {
                                    builder.WriteLine($"var slot = Green.GetSlot({i});");
                                    builder.WriteLine($"return slot != null ? new SyntaxTokenList(this, slot, {GetChildPosition(i)}, {GetChildIndex(i)}) : default;");
                                }
                            }
                        }
                        else
                        {
                            WriteComment(builder, field.PropertyComment);
                            builder.Write($"public {OverrideOrNewModifier(field)}{GetRedPropertyType(field)} {field.Name}");

                            if (IsNodeList(field.Type))
                            {
                                builder.WriteLine($" => new {field.Type}(GetRed(ref {CamelCase(field.Name)}, {i}));");
                            }
                            else if (IsSeparatedNodeList(field.Type))
                            {
                                builder.WriteLine();
                                using (builder.EnterBlock())
                                {
                                    builder.WriteLine("get");
                                    using (builder.EnterBlock())
                                    {
                                        builder.WriteLine($"var red = GetRed(ref {CamelCase(field.Name)}, {i});");
                                        builder.WriteLine($"return red != null ? new {field.Type}(red, {GetChildIndex(i)}) : default;");
                                    }
                                }
                            }
                            else if (field.Type == "SyntaxNodeOrTokenList")
                            {
                                throw new InvalidOperationException("field cannot be a random SyntaxNodeOrTokenList");
                            }
                            else
                            {
                                var suffix = IsOptional(field) ? "" : "!";
                                if (i == 0)
                                {
                                    builder.WriteLine($" => GetRedAtZero(ref {CamelCase(field.Name)}){suffix};");
                                }
                                else
                                {
                                    builder.WriteLine($" => GetRed(ref {CamelCase(field.Name)}, {i}){suffix};");
                                }
                            }
                        }

                        builder.WriteLine();
                    }

                    foreach (var field in valueFields)
                    {
                        WriteComment(builder, field.PropertyComment);
                        builder.WriteLine($"{"public"} {OverrideOrNewModifier(field)}{field.Type} {field.Name} => ((InternalSyntax.{node.Name})this.Green).{field.Name};");
                        builder.WriteLine();
                    }

                    {
                        //GetNodeSlot forces creation of a red node.
                        builder.Write("internal override SyntaxNode? GetNodeSlot(int index)");

                        var relevantNodes = nodeFields.Select((field, index) => (field, index))
                                                      .Where(t => t.field.Type is not "SyntaxToken" and not "SyntaxList<SyntaxToken>");
                        if (!relevantNodes.Any())
                        {
                            builder.WriteLine(" => null;");
                        }
                        else if (relevantNodes.Count() == 1)
                        {
                            var (field, index) = relevantNodes.Single();
                            var whenTrue = index == 0
                                ? $"GetRedAtZero(ref {CamelCase(field.Name)})"
                                : $"GetRed(ref {CamelCase(field.Name)}, {index})";

                            var suffix = IsOptional(field) ? "" : "!";
                            builder.WriteLine($" => index == {index} ? {whenTrue}{suffix} : null;");
                        }
                        else
                        {
                            builder.WriteLine();
                            using (builder.EnterIndentedRegion())
                            {
                                builder.WriteLine("=> index switch");
                                using (builder.EnterIndentedRegion("{", "};"))
                                {
                                    foreach (var (field, index) in relevantNodes)
                                    {
                                        var suffix = IsOptional(field) ? "" : "!";
                                        if (index == 0)
                                        {
                                            builder.WriteLine($"{index} => GetRedAtZero(ref {CamelCase(field.Name)}){suffix},");
                                        }
                                        else
                                        {
                                            builder.WriteLine($"{index} => GetRed(ref {CamelCase(field.Name)}, {index}){suffix},");
                                        }
                                    }

                                    builder.WriteLine("_ => null,");
                                }
                            }
                        }
                    }

                    builder.WriteLine();

                    {
                        //GetCachedSlot returns a red node if we have it.
                        builder.Write("internal override SyntaxNode? GetCachedSlot(int index)");

                        var relevantNodes = nodeFields.Select((field, index) => (field, index))
                                                      .Where(t => t.field.Type is not "SyntaxToken" and not "SyntaxList<SyntaxToken>");
                        if (!relevantNodes.Any())
                        {
                            builder.WriteLine(" => null;");
                        }
                        else if (relevantNodes.Count() == 1)
                        {
                            var (field, index) = relevantNodes.Single();
                            builder.WriteLine($" => index == {index} ? {CamelCase(field.Name)} : null;");
                        }
                        else
                        {
                            builder.WriteLine();
                            using (builder.EnterIndentedRegion())
                            {
                                builder.WriteLine("=> index switch");
                                using (builder.EnterIndentedRegion("{", "};"))
                                {
                                    foreach (var (field, index) in relevantNodes)
                                        builder.WriteLine($"{index} => {CamelCase(field.Name)},");

                                    builder.WriteLine("_ => null,");
                                }
                            }
                        }
                    }

                    WriteRedAcceptMethods(builder, concreteNode);
                    WriteRedUpdateMethod(builder, concreteNode);
                    WriteRedWithMethods(builder, concreteNode);
                    WriteRedListHelperMethods(builder, concreteNode);
                }
            }
        }

        private string GetRedFieldType(Field field)
        {
            if (field.Type == "SyntaxList<SyntaxToken>")
                return "SyntaxTokenList";

            if (IsOptional(field) && _fileWriter.IsNode(field.Type) && field.Type != "SyntaxToken")
                return field.Type + "?";

            return field.Type;
        }

        private static string GetChildPosition(int i)
            => i == 0 ? "Position" : "GetChildPosition(" + i + ")";

        private static string GetChildIndex(int i)
            => i == 0 ? "0" : "GetChildIndex(" + i + ")";

        private static void WriteRedAcceptMethods(IndentingStringBuilder builder, Node node)
        {
            builder.WriteLine();
            WriteRedAcceptMethod(builder, node, false);
            WriteRedAcceptMethod(builder, node, true);
        }

        private static void WriteRedAcceptMethod(IndentingStringBuilder builder, Node node, bool genericResult)
        {
            string genericArgs = genericResult ? "<TResult>" : "";
            builder.WriteLine($"public override {(genericResult ? "TResult?" : "void")} Accept{genericArgs}(CSharpSyntaxVisitor{genericArgs} visitor){(genericResult ? " where TResult : default" : "")} => visitor.Visit{StripPost(node.Name, "Syntax")}(this);");
        }

        private void WriteRedVisitors(IndentingStringBuilder builder)
        {
            WriteRedVisitor(builder, genericResult: true);
            WriteRedVisitor(builder, genericResult: false);
        }

        private void WriteRedVisitor(IndentingStringBuilder builder, bool genericResult)
        {
            string genericArgs = genericResult ? "<TResult>" : "";
            var nodes = _fileWriter.Tree.Types.Where(n => n is not PredefinedNode).ToList();

            builder.WriteLine();
            builder.WriteLine("public partial class CSharpSyntaxVisitor" + genericArgs);
            using (builder.EnterBlock())
            {
                builder.WriteBlankLineSeparated(
                    nodes.OfType<Node>(),
                    static (builder, node, genericResult) =>
                    {
                        WriteComment(builder, $"<summary>Called when the visitor visits a {node.Name} node.</summary>");
                        builder.WriteLine($"public virtual {(genericResult ? "TResult?" : "void")} Visit{StripPost(node.Name, "Syntax")}({node.Name} node) => DefaultVisit(node);");
                    },
                    genericResult);
            }
        }

        private void WriteRedUpdateMethod(IndentingStringBuilder builder, Node node)
        {
            builder.WriteLine();
            builder.Write($"public {node.Name} Update(");
            builder.WriteCommaSeparated(
                node.Fields.Select(f => $"{GetRedPropertyType(f)} {CamelCase(f.Name)}"));
            builder.WriteLine(")");

            using (builder.EnterBlock())
            {
                builder.Write("if (");
                builder.WriteSeparated(
                    node.Fields.Where(field =>
                        _fileWriter.IsDerivedOrListOfDerived("SyntaxNode", field.Type) ||
                        _fileWriter.IsDerivedOrListOfDerived("SyntaxToken", field.Type) ||
                        field.Type == "SyntaxNodeOrTokenList"),
                    " || ",
                    static (builder, field) => builder.Write($"{CamelCase(field.Name)} != {field.Name}"));

                builder.WriteLine(")");
                using (builder.EnterBlock())
                {
                    builder.Write($"var newNode = SyntaxFactory.{StripPost(node.Name, "Syntax")}(");
                    builder.WriteCommaSeparated([
                        .. node.Kinds.Count > 1 ? ["this.Kind()"] : Array.Empty<string>(),
                        .. node.Fields.Select(f => CamelCase(f.Name))]);
                    builder.WriteLine(");");
                    builder.WriteLine("var annotations = GetAnnotations();");
                    builder.WriteLine("return annotations?.Length > 0 ? newNode.WithAnnotations(annotations) : newNode;");
                }

                builder.WriteLine();
                builder.WriteLine("return this;");
            }
        }

        private void WriteRedWithMethods(IndentingStringBuilder builder, Node node)
        {
            foreach (var field in node.Fields)
            {
                var type = GetRedPropertyType(field);

                if (field == node.Fields.First())
                {
                    builder.WriteLine();
                }

                var isNew = false;
                if (IsOverride(field))
                {
                    var (baseType, baseField) = GetHighestBaseTypeWithField(node, field.Name);
                    if (baseType != null)
                    {
                        builder.Write($"internal override {baseType.Name} With{field.Name}Core({GetRedPropertyType(baseField)} {CamelCase(field.Name)}) => With{field.Name}({CamelCase(field.Name)}");
                        if (baseField.Type != "SyntaxToken" && IsOptional(baseField) && !IsOptional(field))
                            builder.Write($" ?? throw new ArgumentNullException(nameof({CamelCase(field.Name)}))");

                        builder.WriteLine(");");

                        isNew = true;
                    }
                }

                builder.Write(
                    $"public{(isNew ? " new " : " ")}{node.Name} With{StripPost(field.Name, "Opt")}({type} {CamelCase(field.Name)})" +
                    " => Update(");

                // call update inside each setter
                builder.WriteCommaSeparated(node.Fields.Select(f =>
                    f == field ? CamelCase(f.Name) : $"this.{f.Name}"));
                builder.WriteLine(");");
            }
        }

        private (TreeType type, Field field) GetHighestBaseTypeWithField(TreeType node, string name)
        {
            TreeType bestType = null;
            Field bestField = null;
            for (var current = node; current != null; current = TryGetBaseType(current))
            {
                var fields = GetNodeOrNodeListFields(current);
                var field = fields.FirstOrDefault(f => f.Name == name);
                if (field != null)
                {
                    bestType = current;
                    bestField = field;
                }
            }

            return (bestType, bestField);
        }

        private TreeType TryGetBaseType(TreeType node)
            => node is AbstractNode an
                ? _fileWriter.GetTreeType(an.Base)
                : node is Node n
                    ? _fileWriter.GetTreeType(n.Base)
                    : null;

        private void WriteRedListHelperMethods(IndentingStringBuilder builder, Node node)
        {
            var first = true;
            foreach (var field in node.Fields)
            {
                if (IsAnyList(field.Type))
                {
                    if (first)
                        builder.EnsureBlankLine();

                    first = false;
                    WriteRedListHelperMethods(builder, node, field);
                }
                else
                {
                    var referencedNode = TryGetNodeForNestedList(field);
                    if (referencedNode != null)
                    {
                        // look for list members...
                        foreach (var referencedNodeField in referencedNode.Fields)
                        {
                            if (IsAnyList(referencedNodeField.Type))
                            {
                                if (first)
                                    builder.EnsureBlankLine();

                                first = false;
                                WriteRedNestedListHelperMethods(builder, node, field, referencedNode, referencedNodeField);
                            }
                        }
                    }
                }
            }
        }

        private Node TryGetNodeForNestedList(Field field)
        {
            Node referencedNode = _fileWriter.GetNode(field.Type);
            if (referencedNode != null && (!IsOptional(field) || RequiredFactoryArgumentCount(referencedNode) == 0))
            {
                return referencedNode;
            }

            return null;
        }

        private void WriteRedListHelperMethods(IndentingStringBuilder builder, Node node, Field field)
        {
            var argType = GetElementType(field.Type);

            var isNew = false;
            if (IsOverride(field))
            {
                var (baseType, baseField) = GetHighestBaseTypeWithField(node, field.Name);
                if (baseType != null)
                {
                    var baseArgType = GetElementType(baseField.Type);
                    builder.WriteLine($"internal override {baseType.Name} Add{field.Name}Core(params {baseArgType}[] items) => Add{field.Name}(items);");
                    isNew = true;
                }
            }

            builder.WriteLine($"public{(isNew ? " new " : " ")}{node.Name} Add{field.Name}(params {argType}[] items) => With{StripPost(field.Name, "Opt")}(this.{field.Name}.AddRange(items));");
        }

        private void WriteRedNestedListHelperMethods(IndentingStringBuilder builder, Node node, Field field, Node referencedNode, Field referencedNodeField)
        {
            var argType = GetElementType(referencedNodeField.Type);

            var isNew = false;
            if (IsOverride(field))
            {
                var (baseType, _) = GetHighestBaseTypeWithField(node, field.Name);
                if (baseType != null)
                {
                    builder.WriteLine($"internal override {baseType.Name} Add{StripPost(field.Name, "Opt")}{referencedNodeField.Name}Core(params {argType}[] items) => Add{StripPost(field.Name, "Opt")}{referencedNodeField.Name}(items);");
                    isNew = true;
                }
            }

            // AddBaseListTypes
            builder.Write($"public{(isNew ? " new " : " ")}{node.Name} Add{StripPost(field.Name, "Opt")}{referencedNodeField.Name}(params {argType}[] items)");

            if (IsOptional(field))
            {
                builder.WriteLine();
                using (builder.EnterBlock())
                {
                    var factoryName = StripPost(referencedNode.Name, "Syntax");
                    var varName = StripPost(CamelCase(field.Name), "Opt");
                    builder.WriteLine($"var {varName} = {field.Name} ?? SyntaxFactory.{factoryName}();");
                    builder.WriteLine($"return With{StripPost(field.Name, "Opt")}({varName}.With{StripPost(referencedNodeField.Name, "Opt")}({varName}.{referencedNodeField.Name}.AddRange(items)));");
                }
            }
            else
            {
                builder.WriteLine($" => With{StripPost(field.Name, "Opt")}(this.{field.Name}.With{StripPost(referencedNodeField.Name, "Opt")}(this.{field.Name}.{referencedNodeField.Name}.AddRange(items)));");
            }
        }

        private void WriteRedRewriter(IndentingStringBuilder builder)
        {
            var nodes = _fileWriter.Tree.Types.Where(n => n is not PredefinedNode).ToList();

            builder.WriteLine();
            builder.WriteLine("public partial class CSharpSyntaxRewriter : CSharpSyntaxVisitor<SyntaxNode?>");
            using (builder.EnterBlock())
            {
                builder.WriteBlankLineSeparated(
                    nodes.OfType<Node>(),
                    static (builder, node, @this) =>
                    {
                        builder.WriteLine($"public override SyntaxNode? Visit{StripPost(node.Name, "Syntax")}({node.Name} node)");

                        if (node.Fields.Count == 0)
                        {
                            builder.WriteLine("    => node;");
                        }
                        else
                        {
                            builder.Write("    => node.Update(");
                            builder.WriteCommaSeparated(
                                node.Fields,
                                static (builder, f, @this) =>
                                {
                                    if (@this._fileWriter.IsNodeOrNodeList(f.Type))
                                    {
                                        if (IsAnyList(f.Type))
                                            builder.Write($"VisitList(node.{f.Name})");
                                        else if (f.Type == "SyntaxToken")
                                            builder.Write($"VisitToken(node.{f.Name})");
                                        else if (IsOptional(f))
                                            builder.Write($"({(GetFieldType(f, green: false))})Visit(node.{f.Name})");
                                        else
                                            builder.Write($@"({(GetFieldType(f, green: false))})Visit(node.{f.Name}) ?? throw new ArgumentNullException(""{CamelCase(f.Name)}"")");
                                    }
                                    else
                                    {
                                        builder.Write($"node.{f.Name}");
                                    }
                                }, @this);

                            builder.WriteLine(");");
                        }
                    },
                    this);
            }
        }

        private void WriteRedFactories(IndentingStringBuilder builder)
        {
            var nodes = _fileWriter.Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode).OfType<Node>().ToList();
            builder.WriteLine();
            builder.WriteLine("public static partial class SyntaxFactory");
            using (builder.EnterBlock())
            {
                foreach (var node in nodes)
                {
                    WriteRedFactory(builder, node);
                    bool skipConvenienceFactories = node.SkipConvenienceFactories != null && string.Compare(node.SkipConvenienceFactories, "true", true) == 0;
                    if (!skipConvenienceFactories)
                    {
                        WriteRedFactoryWithNoAutoCreatableTokens(builder, node);
                        WriteRedMinimalFactory(builder, node);
                        WriteRedMinimalFactory(builder, node, withStringNames: true);
                    }

                    WriteKindConverters(builder, node);
                }
            }
        }

        private bool CanBeAutoCreated(Node node, Field field)
            => IsAutoCreatableToken(node, field) || IsAutoCreatableNode(field);

        private static bool IsAutoCreatableToken(Node node, Field field)
        {
            return field.Type == "SyntaxToken"
                && field.Kinds != null
                && ((field.Kinds.Count == 1 && field.Kinds[0].Name != "IdentifierToken" && !field.Kinds[0].Name.EndsWith("LiteralToken", StringComparison.Ordinal)) || (field.Kinds.Count > 1 && field.Kinds.Count == node.Kinds.Count));
        }

        private bool IsAutoCreatableNode(Field field)
        {
            var referencedNode = _fileWriter.GetNode(field.Type);
            return (referencedNode != null && RequiredFactoryArgumentCount(referencedNode) == 0);
        }

        private bool IsRequiredFactoryField(Node node, Field field)
        {
            return (!IsOptional(field) && !IsAnyList(field.Type) && !CanBeAutoCreated(node, field)) || IsValueField(field);
        }

        private bool IsValueField(Field field)
        {
            return !_fileWriter.IsNodeOrNodeList(field.Type);
        }

        private int RequiredFactoryArgumentCount(Node nd, bool includeKind = true)
        {
            int count = 0;

            // kind must be specified in factory
            if (nd.Kinds.Count > 1 && includeKind)
            {
                count++;
            }

            foreach (var field in nd.Fields)
            {
                if (IsRequiredFactoryField(nd, field))
                {
                    count++;
                }
            }

            return count;
        }

        private int OptionalFactoryArgumentCount(Node nd)
        {
            int count = 0;
            foreach (var field in nd.Fields)
            {
                if (IsOptional(field) || CanBeAutoCreated(nd, field) || IsAnyList(field.Type))
                {
                    count++;
                }
            }

            return count;
        }

        // full factory signature with nothing optional
        private void WriteRedFactory(IndentingStringBuilder builder, Node nd)
        {
            builder.WriteLine();

            var valueFields = nd.Fields.Where(n => IsValueField(n)).ToList();
            var nodeFields = nd.Fields.Where(n => !IsValueField(n)).ToList();

            WriteComment(builder, $"<summary>Creates a new {nd.Name} instance.</summary>");

            builder.Write($"public static {nd.Name} {StripPost(nd.Name, "Syntax")}(");
            WriteRedFactoryParameters(builder, nd);

            builder.WriteLine(")");
            using (builder.EnterBlock())
            {
                // validate kinds
                if (nd.Kinds.Count >= 2)
                {
                    builder.WriteLine("switch (kind)");
                    using (builder.EnterBlock())
                    {
                        var kinds = nd.Kinds.Distinct().ToList();
                        foreach (var kind in kinds)
                            builder.WriteLine($"case SyntaxKind.{kind.Name}:{(kind == kinds.Last() ? " break;" : "")}");

                        builder.WriteLine("default: throw new ArgumentException(nameof(kind));");
                    }
                }

                // validate parameters
                foreach (var field in nodeFields)
                {
                    var pname = CamelCase(field.Name);

                    if (field.Type == "SyntaxToken")
                    {
                        var fieldKinds = _fileWriter.GetKindsOfFieldOrNearestParent(nd, field);
                        if (fieldKinds != null && fieldKinds.Count > 0)
                        {
                            var kinds = fieldKinds.ToList();
                            if (IsOptional(field))
                            {
                                kinds.Add(new Kind { Name = "None" });
                            }

                            if (kinds.Count == 1)
                            {
                                builder.WriteLine($"if ({pname}.Kind() != SyntaxKind.{kinds[0].Name}) throw new ArgumentException(nameof({pname}));");
                            }
                            else
                            {
                                builder.WriteLine($"switch ({pname}.Kind())");
                                using (builder.EnterBlock())
                                {
                                    foreach (var kind in kinds)
                                        builder.WriteLine($"case SyntaxKind.{kind.Name}:{(kind == kinds.Last() ? " break;" : "")}");

                                    builder.WriteLine($"default: throw new ArgumentException(nameof({pname}));");
                                }
                            }
                        }
                    }
                    else if (!IsAnyList(field.Type) && !IsOptional(field))
                    {
                        builder.WriteLine($"if ({CamelCase(field.Name)} == null) throw new ArgumentNullException(nameof({CamelCase(field.Name)}));");
                    }
                }

                builder.Write($"return ({nd.Name})Syntax.InternalSyntax.SyntaxFactory.{StripPost(nd.Name, "Syntax")}(");
                builder.WriteCommaSeparated([
                    .. nd.Kinds.Count > 1 ? ["kind"] : Array.Empty<string>(),
                    .. nodeFields.Select(f =>
                    {
                        if (f.Type == "SyntaxToken")
                        {
                            if (IsOptional(f))
                                return $"(Syntax.InternalSyntax.SyntaxToken?){CamelCase(f.Name)}.Node";
                            else
                                // We know the GreenNode is not null because it gets a type check earlier in the generated method
                                return $"(Syntax.InternalSyntax.SyntaxToken){CamelCase(f.Name)}.Node!";
                        }
                        else if (f.Type == "SyntaxList<SyntaxToken>")
                            return $"{CamelCase(f.Name)}.Node.ToGreenList<Syntax.InternalSyntax.SyntaxToken>()";
                        else if (IsNodeList(f.Type))
                            return $"{CamelCase(f.Name)}.Node.ToGreenList<Syntax.InternalSyntax.{GetElementType(f.Type)}>()";
                        else if (IsSeparatedNodeList(f.Type))
                            return $"{CamelCase(f.Name)}.Node.ToGreenSeparatedList<Syntax.InternalSyntax.{GetElementType(f.Type)}>()";
                        else if (f.Type == "SyntaxNodeOrTokenList")
                            return $"{CamelCase(f.Name)}.Node.ToGreenList<Syntax.InternalSyntax.CSharpSyntaxNode>()";
                        else if (IsOptional(f))
                            return $"{CamelCase(f.Name)} == null ? null : (Syntax.InternalSyntax.{f.Type}){CamelCase(f.Name)}.Green";
                        else
                            return $"(Syntax.InternalSyntax.{f.Type}){CamelCase(f.Name)}.Green";
                    }),
                    // values are at end
                    .. valueFields.Select(f => CamelCase(f.Name))]);

                builder.WriteLine(").CreateRed();");
            }
        }

        private void WriteRedFactoryParameters(IndentingStringBuilder builder, Node nd)
        {
            builder.WriteCommaSeparated([
                .. nd.Kinds.Count > 1 ? ["SyntaxKind kind"] : Array.Empty<string>(),
                .. nd.Fields.Select(f => $"{this.GetRedPropertyType(f)} {CamelCase(f.Name)}")]);
        }

        private string GetRedPropertyType(Field field)
        {
            if (field.Type == "SyntaxList<SyntaxToken>")
                return "SyntaxTokenList";
            if (IsOptional(field) && _fileWriter.IsNode(field.Type) && field.Type != "SyntaxToken")
                return field.Type + "?";
            return field.Type;
        }

        private string GetDefaultValue(Node nd, Field field)
        {
            System.Diagnostics.Debug.Assert(!IsRequiredFactoryField(nd, field));

            if (IsOptional(field) || IsAnyList(field.Type))
            {
                var type = GetRedPropertyType(field);
                return type == "SyntaxTokenList" ? "default(SyntaxTokenList)" : "default";
            }
            else if (field.Type == "SyntaxToken")
            {
                // auto construct token?
                if (field.Kinds.Count == 1)
                {
                    return $"SyntaxFactory.Token(SyntaxKind.{field.Kinds[0].Name})";
                }
                else
                {
                    return $"SyntaxFactory.Token(Get{StripPost(nd.Name, "Syntax")}{StripPost(field.Name, "Opt")}Kind(kind))";
                }
            }
            else
            {
                var referencedNode = _fileWriter.GetNode(field.Type);
                return $"SyntaxFactory.{StripPost(referencedNode.Name, "Syntax")}()";
            }
        }

        // Writes Get<Property>Kind() methods for converting between node kind and member token kinds...
        private void WriteKindConverters(IndentingStringBuilder builder, Node nd)
        {
            foreach (var field in nd.Fields)
            {
                if (field.Type == "SyntaxToken" && CanBeAutoCreated(nd, field) && field.Kinds.Count > 1)
                {
                    builder.WriteLine();
                    builder.WriteLine($"private static SyntaxKind Get{StripPost(nd.Name, "Syntax")}{StripPost(field.Name, "Opt")}Kind(SyntaxKind kind)");
                    using (builder.EnterIndentedRegion())
                    {
                        builder.WriteLine("=> kind switch");
                        using (builder.EnterIndentedRegion("{", "};"))
                        {
                            for (int k = 0; k < field.Kinds.Count; k++)
                                builder.WriteLine($"SyntaxKind.{nd.Kinds[k].Name} => SyntaxKind.{field.Kinds[k].Name},");

                            builder.WriteLine("_ => throw new ArgumentOutOfRangeException(),");
                        }
                    }
                }
            }
        }

        private static IEnumerable<Field> DetermineRedFactoryWithNoAutoCreatableTokenFields(Node nd)
        {
            return nd.Fields.Where(f => !IsAutoCreatableToken(nd, f));
        }

        // creates a factory without auto-creatable token arguments
        private void WriteRedFactoryWithNoAutoCreatableTokens(IndentingStringBuilder builder, Node nd)
        {
            var nAutoCreatableTokens = nd.Fields.Count(f => IsAutoCreatableToken(nd, f));
            if (nAutoCreatableTokens == 0)
                return; // already handled by general factory

            var factoryWithNoAutoCreatableTokenFields = new HashSet<Field>(DetermineRedFactoryWithNoAutoCreatableTokenFields(nd));
            var minimalFactoryFields = DetermineMinimalFactoryFields(nd);
            if (minimalFactoryFields != null && factoryWithNoAutoCreatableTokenFields.SetEquals(minimalFactoryFields))
            {
                return; // will be handled in minimal factory case
            }

            builder.WriteLine();

            WriteComment(builder, $"<summary>Creates a new {nd.Name} instance.</summary>");
            builder.Write($"public static {nd.Name} {StripPost(nd.Name, "Syntax")}(");
            builder.WriteCommaSeparated([
                .. nd.Kinds.Count > 1 ? ["SyntaxKind kind"] : Array.Empty<string>(),
                .. nd.Fields.Where(factoryWithNoAutoCreatableTokenFields.Contains).Select(
                    f => $"{GetRedPropertyType(f)} {CamelCase(f.Name)}")]);
            builder.WriteLine(")");

            builder.Write($"    => SyntaxFactory.{StripPost(nd.Name, "Syntax")}(");
            builder.WriteCommaSeparated([
                .. nd.Kinds.Count > 1 ? ["kind"] : Array.Empty<string>(),
                .. nd.Fields.Select(f => factoryWithNoAutoCreatableTokenFields.Contains(f)
                    ? CamelCase(f.Name)
                    : GetDefaultValue(nd, f))]);

            builder.WriteLine(");");
        }

        private Field DetermineMinimalOptionalField(Node nd)
        {
            // first if there is a single list, then choose the list because it would not have been optional
            int listCount = nd.Fields.Count(f => IsAnyNodeList(f.Type) && !IsAttributeOrModifiersList(f));
            if (listCount == 1)
            {
                return nd.Fields.First(f => IsAnyNodeList(f.Type) && !IsAttributeOrModifiersList(f));
            }
            else
            {
                // otherwise, if there is a single optional node, use that..
                int nodeCount = nd.Fields.Count(f => _fileWriter.IsNode(f.Type) && f.Type != "SyntaxToken");
                if (nodeCount == 1)
                {
                    return nd.Fields.First(f => _fileWriter.IsNode(f.Type) && f.Type != "SyntaxToken");
                }
                else
                {
                    return null;
                }
            }
        }

        private static bool IsAttributeOrModifiersList(Field f)
        {
            return f.Name is "AttributeLists" or "Modifiers";
        }

        private IEnumerable<Field> DetermineMinimalFactoryFields(Node nd)
        {
            // special case to allow a single optional argument if there would have been no arguments
            // and we can determine a best single argument.
            Field allowOptionalField = null;

            var optionalCount = OptionalFactoryArgumentCount(nd);
            if (optionalCount == 0)
            {
                return null; // no fields...
            }

            var requiredCount = RequiredFactoryArgumentCount(nd, includeKind: false);
            if (requiredCount == 0 && optionalCount > 1)
            {
                allowOptionalField = DetermineMinimalOptionalField(nd);
            }

            return nd.Fields.Where(f => IsRequiredFactoryField(nd, f) || allowOptionalField == f);
        }

        // creates a factory with only the required arguments (everything else is defaulted)
        private void WriteRedMinimalFactory(IndentingStringBuilder builder, Node nd, bool withStringNames = false)
        {
            var optionalCount = OptionalFactoryArgumentCount(nd);
            if (optionalCount == 0)
                return; // already handled w/ general factory method

            var minimalFactoryFields = new HashSet<Field>(DetermineMinimalFactoryFields(nd));

            if (withStringNames && !minimalFactoryFields.Any(f => IsRequiredFactoryField(nd, f) && CanAutoConvertFromString(f)))
                return; // no string-name overload necessary

            builder.WriteLine();

            var hasOptional = minimalFactoryFields.Any(f => !IsRequiredFactoryField(nd, f));
            var hasAttributeOrModifiersList = nd.Fields.Any(f => IsAttributeOrModifiersList(f));

            if (hasOptional && hasAttributeOrModifiersList)
            {
                builder.WriteLine("#pragma warning disable RS0027", skipIndent: true);
            }

            WriteComment(builder, $"<summary>Creates a new {nd.Name} instance.</summary>");
            builder.Write($"public static {nd.Name} {StripPost(nd.Name, "Syntax")}(");
            builder.WriteCommaSeparated([
                .. nd.Kinds.Count > 1 ? ["SyntaxKind kind"] : Array.Empty<string>(),
                .. nd.Fields.Where(minimalFactoryFields.Contains).Select(f =>
                {
                    var type = GetRedPropertyType(f);

                    if (IsRequiredFactoryField(nd, f))
                    {
                        if (withStringNames && CanAutoConvertFromString(f))
                            type = "string";

                        return $"{type} {CamelCase(f.Name)}";
                    }
                    else
                    {
                        if (_fileWriter.IsNode(f.Type) && !IsOptional(f) && f.Type != "SyntaxToken")
                            type += "?";

                        return $"{type} {CamelCase(f.Name)} = default";
                    }
                })]);
            builder.WriteLine(")");

            builder.Write($"    => SyntaxFactory.{StripPost(nd.Name, "Syntax")}(");

            builder.WriteCommaSeparated([
                .. nd.Kinds.Count > 1 ? ["kind"] : Array.Empty<string>(),
                .. nd.Fields.Select(f =>
                {
                    if (minimalFactoryFields.Contains(f))
                    {
                        if (IsRequiredFactoryField(nd, f))
                        {
                            if (withStringNames && CanAutoConvertFromString(f))
                                return $"{GetStringConverterMethod(f)}({CamelCase(f.Name)})";
                            else
                                return CamelCase(f.Name);
                        }
                        else
                        {
                            if (IsOptional(f) || IsAnyList(f.Type))
                                return CamelCase(f.Name);
                            else
                                return $"{CamelCase(f.Name)} ?? {GetDefaultValue(nd, f)}";
                        }
                    }

                    return GetDefaultValue(nd, f);
                })]);

            builder.WriteLine(");");

            if (hasOptional && hasAttributeOrModifiersList)
            {
                builder.WriteLine("#pragma warning restore RS0027", skipIndent: true);
            }
        }

        private static bool CanAutoConvertFromString(Field field)
        {
            return IsIdentifierToken(field) || IsIdentifierNameSyntax(field);
        }

        private static bool IsIdentifierToken(Field field)
        {
            return field.Type == "SyntaxToken" && field.Kinds != null && field.Kinds.Count == 1 && field.Kinds[0].Name == "IdentifierToken";
        }

        private static bool IsIdentifierNameSyntax(Field field)
        {
            return field.Type == "IdentifierNameSyntax";
        }

        private static string GetStringConverterMethod(Field field)
        {
            if (IsIdentifierToken(field))
            {
                return "SyntaxFactory.Identifier";
            }
            else if (IsIdentifierNameSyntax(field))
            {
                return "SyntaxFactory.IdentifierName";
            }
            else
            {
                throw new NotSupportedException();
            }
        }

        /// <summary>
        /// Anything inside a &lt;Comment&gt; tag gets written out (escaping untouched) as the
        /// XML doc comment.  Line breaks will be preserved.
        /// </summary>
        private static void WriteComment(IndentingStringBuilder builder, string comment)
        {
            if (comment != null)
            {
                var lines = comment.Split(new string[] { "\r", "\n", "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                foreach (var line in lines.Where(l => !string.IsNullOrWhiteSpace(l)))
                {
                    builder.WriteLine($"/// {line.TrimStart()}");
                }
            }
        }

        /// <summary>
        /// Anything inside a &lt;Comment&gt; tag gets written out (escaping untouched) as the
        /// XML doc comment.  Line breaks will be preserved.
        /// </summary>
        private static void WriteComment(IndentingStringBuilder builder, Comment comment)
        {
            if (comment != null)
            {
                foreach (XmlElement element in comment.Body)
                {
                    string[] lines = element.OuterXml.Split(new string[] { "\r", "\n", "\r\n" }, StringSplitOptions.RemoveEmptyEntries);
                    foreach (string line in lines.Where(l => !string.IsNullOrWhiteSpace(l)))
                    {
                        builder.WriteLine($"/// {line.TrimStart()}");
                    }
                }
            }
        }
    }
}
