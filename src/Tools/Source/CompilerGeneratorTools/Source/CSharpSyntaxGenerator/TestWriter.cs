// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

#nullable disable

using System.IO;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.PooledObjects;

namespace CSharpSyntaxGenerator
{
    using static FileWriter;

    internal sealed class TestWriter
    {
        private readonly FileWriter _fileWriter;

        private TestWriter(Tree tree, CancellationToken cancellationToken = default)
        {
            _fileWriter = new FileWriter(tree, cancellationToken);
        }

        public static void Write(TextWriter writer, Tree tree)
        {
            new TestWriter(tree).WriteFile(writer);
        }

        private void WriteFile(TextWriter writer)
        {
            using var builder = new IndentingStringBuilder();

            builder.WriteLine("// <auto-generated />");
            builder.WriteLine();
            builder.WriteLine("using Microsoft.CodeAnalysis.CSharp.Syntax;");
            builder.WriteLine("using Roslyn.Utilities;");
            builder.WriteLine("using Xunit;");
            builder.WriteLine("using InternalSyntaxFactory = Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactory;");
            builder.WriteLine();

            builder.WriteLine("namespace Microsoft.CodeAnalysis.CSharp.UnitTests");
            using (builder.EnterBlock())
            {
                builder.WriteLine("public partial class GreenNodeTests");
                using (builder.EnterBlock())
                {
                    builder.WriteLine("#region Green Generators");
                    WriteNodeGenerators(builder, isGreen: true);
                    builder.WriteLine("#endregion Green Generators");
                    builder.WriteLine();
                    builder.WriteLine("#region Green Factory and Property Tests");
                    WriteFactoryPropertyTests(builder, isGreen: true);
                    builder.WriteLine("#endregion Green Factory and Property Tests");
                    builder.WriteLine();
                    builder.WriteLine("#region Green Rewriters");
                    WriteRewriterTests(builder);
                    builder.WriteLine("#endregion Green Rewriters");
                }

                builder.WriteLine();

                builder.WriteLine("public partial class RedNodeTests");
                using (builder.EnterBlock())
                {
                    builder.WriteLine("#region Red Generators");
                    WriteNodeGenerators(builder, isGreen: false);
                    builder.WriteLine("#endregion Red Generators");
                    builder.WriteLine();
                    builder.WriteLine("#region Red Factory and Property Tests");
                    WriteFactoryPropertyTests(builder, isGreen: false);
                    builder.WriteLine("#endregion Red Factory and Property Tests");
                    builder.WriteLine();
                    builder.WriteLine("#region Red Rewriters");
                    WriteRewriterTests(builder);
                    builder.WriteLine("#endregion Red Rewriters");
                }
            }

            writer.Write(builder.ToString());
        }

        private void WriteNodeGenerators(IndentingStringBuilder builder, bool isGreen)
        {
            builder.WriteBlankLineSeparated(
                _fileWriter.Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode),
                static (builder, node, tuple) => tuple.@this.WriteNodeGenerator(builder, (Node)node, tuple.isGreen),
                (@this: this, isGreen));
        }

        private void WriteNodeGenerator(IndentingStringBuilder builder, Node node, bool isGreen)
        {
            var valueFields = node.Fields.Where(n => !_fileWriter.IsNodeOrNodeList(n.Type));
            var nodeFields = node.Fields.Where(n => _fileWriter.IsNodeOrNodeList(n.Type));

            var internalNamespace = isGreen ? "Microsoft.CodeAnalysis.Syntax.InternalSyntax." : "";
            var csharpNamespace = isGreen ? "Syntax.InternalSyntax." : "";
            var syntaxFactory = isGreen ? "InternalSyntaxFactory" : "SyntaxFactory";

            var strippedName = StripPost(node.Name, "Syntax");

            builder.WriteLine($"private static {csharpNamespace}{node.Name} Generate{strippedName}()");
            builder.Write($"    => {syntaxFactory}.{strippedName}(");
            //instantiate node

            var arguments = ArrayBuilder<string>.GetInstance();

            if (node.Kinds.Count > 1)
                arguments.Add($"SyntaxKind.{node.Kinds[0].Name}"); //TODO: other kinds?

            foreach (var field in nodeFields)
            {
                if (IsOptional(field))
                {
                    if (isGreen)
                    {
                        arguments.Add("null");
                    }
                    else
                    {
                        arguments.Add($"default({field.Type})");
                    }
                }
                else if (IsAnyList(field.Type))
                {
                    var typeName = isGreen
                        ? internalNamespace + field.Type.Replace("<", "<" + csharpNamespace)
                        : (field.Type == "SyntaxList<SyntaxToken>") ? "SyntaxTokenList" : field.Type;
                    arguments.Add($"new {typeName}()");
                }
                else if (field.Type == "SyntaxToken")
                {
                    var kind = ChooseValidKind(field, node);
                    var leadingTrivia = isGreen ? "null, " : string.Empty;
                    var trailingTrivia = isGreen ? ", null" : string.Empty;
                    if (kind == "IdentifierToken")
                    {
                        arguments.Add($"{syntaxFactory}.Identifier(\"{field.Name}\")");
                    }
                    else if (kind == "StringLiteralToken")
                    {
                        arguments.Add($"{syntaxFactory}.Literal({leadingTrivia}\"string\", \"string\"{trailingTrivia})");
                    }
                    else if (kind == "CharacterLiteralToken")
                    {
                        arguments.Add($"{syntaxFactory}.Literal({leadingTrivia}\"a\", 'a'{trailingTrivia})");
                    }
                    else if (kind == "NumericLiteralToken")
                    {
                        builder.Write($"{syntaxFactory}.Literal({leadingTrivia}\"1\", 1{trailingTrivia})");
                    }
                    else
                    {
                        arguments.Add($"{syntaxFactory}.Token(SyntaxKind.{kind})");
                    }
                }
                else if (field.Type == "CSharpSyntaxNode")
                {
                    arguments.Add($"{syntaxFactory}.IdentifierName({syntaxFactory}.Identifier(\"{field.Name}\"))");
                }
                else
                {
                    //drill down to a concrete type
                    var type = field.Type;
                    while (true)
                    {
                        var subTypes = _fileWriter.ChildMap[type];
                        if (!subTypes.Any())
                        {
                            break;
                        }

                        type = subTypes.First();
                    }

                    arguments.Add($"Generate{StripPost(type, "Syntax")}()");
                }
            }

            foreach (var field in valueFields)
                arguments.Add($"new {field.Type}()");

            builder.WriteCommaSeparated(
                arguments,
                static (builder, argument) => builder.Write(argument));

            builder.WriteLine(");");
            arguments.Free();
        }

        private void WriteFactoryPropertyTests(IndentingStringBuilder builder, bool isGreen)
        {
            builder.WriteBlankLineSeparated(
                _fileWriter.Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode),
                static (builder, node, tuple) => tuple.@this.WriteFactoryPropertyTest(builder, (Node)node, tuple.isGreen),
                (@this: this, isGreen));
        }

        private void WriteFactoryPropertyTest(IndentingStringBuilder builder, Node node, bool isGreen)
        {
            var valueFields = node.Fields.Where(n => !_fileWriter.IsNodeOrNodeList(n.Type));
            var nodeFields = node.Fields.Where(n => _fileWriter.IsNodeOrNodeList(n.Type));

            var strippedName = StripPost(node.Name, "Syntax");

            builder.WriteLine("[Fact]");
            builder.WriteLine($"public void Test{strippedName}FactoryAndProperties()");
            using (builder.EnterBlock())
            {
                builder.WriteLine($"var node = Generate{strippedName}();");
                builder.WriteLine();

                //check properties
                {
                    string withStat = null;
                    foreach (var field in nodeFields)
                    {
                        if (IsOptional(field))
                        {
                            if (!isGreen && field.Type == "SyntaxToken")
                            {
                                builder.WriteLine($"Assert.Equal(SyntaxKind.None, node.{field.Name}.Kind());");
                            }
                            else
                            {
                                builder.WriteLine($"Assert.Null(node.{field.Name});");
                            }
                        }
                        else if (field.Type == "SyntaxToken")
                        {
                            var kind = ChooseValidKind(field, node);
                            if (!isGreen)
                            {
                                builder.WriteLine($"Assert.Equal(SyntaxKind.{kind}, node.{field.Name}.Kind());");
                            }
                            else
                            {
                                builder.WriteLine($"Assert.Equal(SyntaxKind.{kind}, node.{field.Name}.Kind);");
                            }
                        }
                        else
                        {
                            if (field.Type == "SyntaxToken")
                            {
                                builder.WriteLine($"Assert.NotEqual(default, node.{field.Name});");
                            }
                            else if (
                                field.Type == "SyntaxTokenList" ||
                                field.Type.StartsWith("SyntaxList<") ||
                                field.Type.StartsWith("SeparatedSyntaxList<"))
                            {
                                builder.WriteLine($"Assert.Equal(default, node.{field.Name});");
                            }
                            else
                            {
                                builder.WriteLine($"Assert.NotNull(node.{field.Name});");
                            }
                        }

                        if (!isGreen)
                        {
                            withStat += $".With{field.Name}(node.{field.Name})";
                        }
                    }

                    foreach (var field in valueFields)
                    {
                        builder.WriteLine($"Assert.Equal(new {field.Type}(), node.{field.Name});");
                        if (!isGreen)
                        {
                            withStat += $".With{field.Name}(node.{field.Name})";
                        }
                    }

                    if (!isGreen && withStat != null)
                    {
                        builder.WriteLine($"var newNode = node{withStat};");
                        builder.WriteLine("Assert.Equal(node, newNode);");
                    }
                }

                if (isGreen)
                {
                    builder.EnsureBlankLine();
                    builder.WriteLine("AttachAndCheckDiagnostics(node);");
                }
            }
        }

        private void WriteRewriterTests(IndentingStringBuilder builder)
        {
            builder.WriteBlankLineSeparated(
                _fileWriter.Tree.Types.Where(n => n is not PredefinedNode and not AbstractNode),
                static (builder, node, @this) =>
                {
                    @this.WriteTokenDeleteRewriterTest(builder, (Node)node);
                    builder.WriteLine();
                    @this.WriteIdentityRewriterTest(builder, (Node)node);
                },
                this);
        }

        private void WriteTokenDeleteRewriterTest(IndentingStringBuilder builder, Node node)
        {
            var strippedName = StripPost(node.Name, "Syntax");

            builder.WriteLine("[Fact]");
            builder.WriteLine($"public void Test{strippedName}TokenDeleteRewriter()");
            using (builder.EnterBlock())
            {
                builder.WriteLine($"var oldNode = Generate{strippedName}();");
                builder.WriteLine("var rewriter = new TokenDeleteRewriter();");
                builder.WriteLine("var newNode = rewriter.Visit(oldNode);");
                builder.WriteLine();
                builder.WriteLine("if(!oldNode.IsMissing)");
                using (builder.EnterBlock())
                {
                    builder.WriteLine("Assert.NotEqual(oldNode, newNode);");
                }

                builder.WriteLine();
                builder.WriteLine("Assert.NotNull(newNode);");
                builder.WriteLine("Assert.True(newNode.IsMissing, \"No tokens => missing\");");
            }
        }

        private void WriteIdentityRewriterTest(IndentingStringBuilder builder, Node node)
        {
            var strippedName = StripPost(node.Name, "Syntax");

            builder.WriteLine("[Fact]");
            builder.WriteLine($"public void Test{strippedName}IdentityRewriter()");
            using (builder.EnterBlock())
            {
                builder.WriteLine($"var oldNode = Generate{strippedName}();");
                builder.WriteLine("var rewriter = new IdentityRewriter();");
                builder.WriteLine("var newNode = rewriter.Visit(oldNode);");
                builder.WriteLine();
                builder.WriteLine("Assert.Same(oldNode, newNode);");
            }
        }

        //guess a reasonable kind if there are no constraints
        private string ChooseValidKind(Field field, Node nd)
        {
            var fieldKinds = _fileWriter.GetKindsOfFieldOrNearestParent(nd, field);
            return fieldKinds?.Any() == true ? fieldKinds[0].Name : "IdentifierToken";
        }
    }
}
