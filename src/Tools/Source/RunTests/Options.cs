// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.Collections.Generic;
using System.IO;
using System.Runtime.InteropServices;
using Mono.Options;

namespace RunTests
{
    internal class Options
    {
        public string ArtifactsDirectory { get; }

        /// <summary>
        /// Whether or not to collect dumps on crashes and timeouts.
        /// </summary>
        public bool CollectDumps { get; set; }

        /// <summary>
        /// The path to procdump.exe
        /// </summary>
        public string? ProcDumpFilePath { get; set; }

        /// <summary>
        /// Path to the dotnet executable we should use for running dotnet test
        /// </summary>
        public string DotnetFilePath { get; set; }

        /// <summary>
        /// Directory to hold dump files and other log files created while running tests.
        /// </summary>
        public string LogFilesDirectory { get; set; }

        /// <summary>
        /// Additional arguments to pass to dotnet test.
        /// Includes information like architecture, blame, test filters, etc.
        /// </summary>
        public string? DotnetTestArgs { get; set; }

        /// <summary>
        /// Path to the file containing all the assemblies to test.
        /// </summary>
        public string TestAssembliesPath { get; set; }

        public Options(
            string dotnetFilePath,
            string artifactsDirectory,
            string logFilesDirectory,
            string testAssembliesPath,
            string? dotnetTestArgs)
        {
            DotnetFilePath = dotnetFilePath;
            ArtifactsDirectory = artifactsDirectory;
            LogFilesDirectory = logFilesDirectory;
            DotnetTestArgs = dotnetTestArgs;
            TestAssembliesPath = testAssembliesPath;
        }

        internal static Options? Parse(string[] args)
        {
            string? dotnetFilePath = null;
            string? logFileDirectory = null;
            var collectDumps = false;
            string? procDumpFilePath = null;
            string? artifactsPath = null;
            string? dotnetTestArgs = null;
            string? testAssembliesPath = null;
            var optionSet = new OptionSet()
            {
                { "dotnet=", "Path to dotnet", (string s) => dotnetFilePath = s },
                { "logs=", "Log file directory", (string s) => logFileDirectory = s },
                { "artifactsPath=", "Path to the artifacts directory", (string s) => artifactsPath = s },
                { "procdumpPath=", "Path to procdump", (string s) => procDumpFilePath = s },
                { "collectDumps", "Whether or not to gather dumps on timeouts and crashes", o => collectDumps = o is object },
                { "dotnetTestArgs=", "Additional arguments to pass to dotnet test including architecture, additional filters, etc.", (string s) => dotnetTestArgs = s },
                { "testAssembliesPath=", "File path to the list of test assemblies generated by TestAssemblyFinder", (string s) => testAssembliesPath = s },
            };

            List<string> assemblyList;
            try
            {
                assemblyList = optionSet.Parse(args);
            }
            catch (OptionException e)
            {
                ConsoleUtil.WriteLine($"Error parsing command line arguments: {e.Message}");
                optionSet.WriteOptionDescriptions(Console.Out);
                return null;
            }

            artifactsPath ??= TryGetArtifactsPath();
            if (artifactsPath is null || !Directory.Exists(artifactsPath))
            {
                ConsoleUtil.WriteLine($"Did not find artifacts directory at {artifactsPath}");
                return null;
            }

            dotnetFilePath ??= TryGetDotNetPath();
            if (dotnetFilePath is null || !File.Exists(dotnetFilePath))
            {
                ConsoleUtil.WriteLine($"Did not find 'dotnet' at {dotnetFilePath}");
                return null;
            }

            logFileDirectory ??= Path.Combine(artifactsPath, "TestResults");

            if (procDumpFilePath is { } && !collectDumps)
            {
                ConsoleUtil.WriteLine($"procdumppath was specified without collectdumps hence it will not be used");
            }

            if (testAssembliesPath is null || !File.Exists(testAssembliesPath))
            {
                ConsoleUtil.WriteLine($"Did not find list of test assemblies at {testAssembliesPath}.  Do you need to run TestAssemblyFinder?");
                return null;
            }

            return new Options(
                dotnetFilePath: dotnetFilePath,
                artifactsDirectory: artifactsPath,
                logFilesDirectory: logFileDirectory,
                testAssembliesPath: testAssembliesPath,
                dotnetTestArgs: dotnetTestArgs)
            {
                ProcDumpFilePath = procDumpFilePath,
                CollectDumps = collectDumps,
            };

            static string? TryGetArtifactsPath()
            {
                var path = AppContext.BaseDirectory;
                while (path is object && Path.GetFileName(path) != "artifacts")
                {
                    path = Path.GetDirectoryName(path);
                }

                return path;
            }

            static string? TryGetDotNetPath()
            {
                var dir = RuntimeEnvironment.GetRuntimeDirectory();
                var programName = RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "dotnet.exe" : "dotnet";

                while (dir != null && !File.Exists(Path.Combine(dir, programName)))
                {
                    dir = Path.GetDirectoryName(dir);
                }

                return dir == null ? null : Path.Combine(dir, programName);
            }
        }
    }
}
