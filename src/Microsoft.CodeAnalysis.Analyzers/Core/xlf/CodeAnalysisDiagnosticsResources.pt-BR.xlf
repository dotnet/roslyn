<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="pt-BR" original="../CodeAnalysisDiagnosticsResources.resx">
    <body>
      <trans-unit id="MissingAttributeMessage">
        <source>Missing '{0}' attribute.</source>
        <target state="translated">Atributo '{0}' ausente.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingDiagnosticAnalyzerAttributeTitle">
        <source>Missing diagnostic analyzer attribute.</source>
        <target state="translated">Atributo do analisador de diagnóstico ausente.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingDiagnosticAnalyzerAttributeDescription">
        <source>Non-abstract sub-types of DiagnosticAnalyzer should be marked with DiagnosticAnalyzerAttribute(s). The argument to this attribute(s), if any, determine the supported languages for the analyzer. Analyzer types without this attribute will be ignored by the analysis engine.</source>
        <target state="translated">Subtipos não abstratos de DiagnosticAnalyzer devem ser marcados com DiagnosticAnalyzerAttribute(s). O argumento para estes atributos, se houver, determina as linguagens com suporte para o analisador. Os tipos de analisador sem este atributo serão ignorados pelo mecanismo de análise.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddLanguageSupportToAnalyzerMessage">
        <source>Diagnostic analyzer '{0}' may be able to support both C# and Visual Basic. Consider adding an argument to DiagnosticAnalyzerAttribute for '{1}' language support.</source>
        <target state="translated">Talvez o analisador de diagnóstico '{0}' possa dar suporte a C# e a Visual Basic. Considere adicionar um argumento a DiagnosticAnalyzerAttribute para obter suporte à linguagem '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddLanguageSupportToAnalyzerTitle">
        <source>Recommend adding language support to diagnostic analyzer.</source>
        <target state="translated">Recomende adicionar suporte à linguagem ao analisador de diagnóstico.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddLanguageSupportToAnalyzerDescription">
        <source>Diagnostic analyzer is marked as supporting only one language, but the analyzer assembly doesn't seem to refer to any language specific CodeAnalysis assemblies, and so is likely to work for more than one language. Consider adding an additional language argument to DiagnosticAnalyzerAttribute.</source>
        <target state="translated">O analisador de diagnóstico é marcado como dando suporte a apenas uma linguagem, mas o assembly do analisador não parece referenciar nenhum assembly CodeAnalysis específico a uma linguagem e, portanto, é provável que ele funcione para mais de uma linguagem. Considere adicionar um argumento de linguagem adicional a DiagnosticAnalyzerAttribute.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyDiagnosticAnalyzerAttribute_1">
        <source>Apply DiagnosticAnalyzer attribute for '{0}'.</source>
        <target state="translated">Aplique o atributo DiagnosticAnalyzer para '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyDiagnosticAnalyzerAttribute_2">
        <source>Apply DiagnosticAnalyzer attribute for both '{0}' and '{1}'.</source>
        <target state="translated">Aplique o atributo DiagnosticAnalyzer para '{0}' e para '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingSymbolKindArgumentToRegisterActionMessage">
        <source>Specify at least one SymbolKind of interest when registering a symbol analyzer action.</source>
        <target state="translated">Especifique pelo menos um SymbolKind de interesse ao registrar uma ação de analisador de símbolo.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingSyntaxKindArgumentToRegisterActionMessage">
        <source>Specify at least one SyntaxKind of interest when registering a syntax node analyzer action.</source>
        <target state="translated">Especifique pelo menos um SyntaxKind de interesse ao registrar uma ação de analisador de nó de sintaxe.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingOperationKindArgumentToRegisterActionMessage">
        <source>Specify at least one OperationKind of interest when registering an operation analyzer action.</source>
        <target state="translated">Especifique pelo menos um OperationKind de interesse ao registrar uma ação de analisador de operações.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingKindArgumentToRegisterActionTitle">
        <source>Missing kind argument when registering an analyzer action.</source>
        <target state="translated">Argumento kind ausente ao registrar uma ação do analisador.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingKindArgumentToRegisterActionDescription">
        <source>You must specify at least one syntax, symbol or operation kind when registering a syntax, symbol, or operation analyzer action respectively. Otherwise, the registered action will never be invoked during analysis.</source>
        <target state="translated">É necessário especificar pelo menos um tipo de sintaxe, de símbolo ou de operação ao registrar uma ação de analisador de sintaxe, símbolo ou operação, respectivamente. Caso contrário, a ação registrada nunca será invocada durante a análise.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSymbolKindArgumentToRegisterActionMessage">
        <source>SymbolKind '{0}' is not supported for symbol analyzer actions.</source>
        <target state="translated">Não há suporte para SymbolKind '{0}' para ações de analisador de símbolo.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSymbolKindArgumentToRegisterActionTitle">
        <source>Unsupported SymbolKind argument when registering a symbol analyzer action.</source>
        <target state="translated">Argumento SymbolKind sem suporte ao registrar uma ação de analisador de símbolo.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReportDiagnosticMessage">
        <source>ReportDiagnostic invoked with an unsupported DiagnosticDescriptor '{0}'.</source>
        <target state="translated">ReportDiagnostic invocado com um '{0}' DiagnosticDescriptor sem suporte.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReportDiagnosticTitle">
        <source>ReportDiagnostic invoked with an unsupported DiagnosticDescriptor.</source>
        <target state="translated">ReportDiagnostic invocado com um DiagnosticDescriptor sem suporte.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReportDiagnosticDescription">
        <source>ReportDiagnostic should only be invoked with supported DiagnosticDescriptors that are returned from DiagnosticAnalyzer.SupportedDiagnostics property. Otherwise, the reported diagnostic will be filtered out by the analysis engine.</source>
        <target state="translated">ReportDiagnostic só deve ser invocado com DiagnosticDescriptors com suporte retornados da propriedade DiagnosticAnalyzer.SupportedDiagnostics. Caso contrário, o diagnóstico reportado será filtrado pelo mecanismo de análise.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSyntaxKindTypeArgumentMessage">
        <source>Type argument '{0}' for type parameter '{1}' of method '{2}' is not a SyntaxKind enum.</source>
        <target state="translated">O argumento de tipo '{0}' para o parâmetro de tipo '{1}' do método '{2}' não é uma enum SyntaxKind.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSyntaxKindTypeArgumentTitle">
        <source>Invalid type argument for DiagnosticAnalyzer's Register method.</source>
        <target state="translated">Argumento de tipo inválido para o método Register de DiagnosticAnalyzer.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSyntaxKindTypeArgumentDescription">
        <source>DiagnosticAnalyzer's language-specific Register methods, such as RegisterSyntaxNodeAction, RegisterCodeBlockStartAction and RegisterCodeBlockEndAction, expect a language-specific 'SyntaxKind' type argument for it's '{0}' type parameter. Otherwise, the registered analyzer action can never be invoked during analysis.</source>
        <target state="translated">Os métodos Register específicos a um idioma do DiagnosticAnalyzer, como RegisterSyntaxNodeAction, RegisterCodeBlockStartAction e RegisterCodeBlockEndAction esperam um argumento de tipo 'SyntaxKind' específico a um idioma para o parâmetro de tipo '{0}' dele. Caso contrário, a ação do analisador registrada nunca pode ser invocada durante a análise.</target>
        <note />
      </trans-unit>
      <trans-unit id="StartActionWithOnlyEndActionTitle">
        <source>Start action has no registered non-end actions.</source>
        <target state="translated">A ação inicial não tem ações não finais registradas.</target>
        <note />
      </trans-unit>
      <trans-unit id="StartActionWithNoRegisteredActionsMessage">
        <source>'{0}' does not register any analyzer actions. Consider moving actions registered in '{1}' that depend on this start action to '{0}'.</source>
        <target state="translated">'{0}' não registra nenhuma ação do analisador. Considere mover ações registradas em '{1}' que dependem desta ação inicial para '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="StartActionWithNoRegisteredActionsTitle">
        <source>Start action has no registered actions.</source>
        <target state="translated">A ação inicial não tem ações registradas.</target>
        <note />
      </trans-unit>
      <trans-unit id="StartActionWithOnlyEndActionMessage">
        <source>'{0}' does not register any analyzer actions, except for a '{1}'. Consider replacing this start/end action pair with a '{2}' or moving actions registered in '{3}' that depend on this start action to '{0}'.</source>
        <target state="translated">'{0}' não registra nenhuma ação do analisador, exceto por um '{1}'. Considere substituir este par de ações iniciais/finais com um '{2}' ou mover as ações registradas em '{3}' que dependem dessa ação inicial para '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulAnalyzerRegisterActionsDescription">
        <source>An analyzer start action enables performing stateful analysis over a given code unit, such as a code block, compilation, etc. Careful design is necessary to achieve efficient analyzer execution without memory leaks. Use the following guidelines for writing such analyzers:
1. Define a new scope for the registered start action, possibly with a private nested type for analyzing each code unit.
2. If required, define and initialize state in the start action.
3. Register at least one non-end action that refers to this state in the start action. If no such action is necessary, consider replacing the start action with a non-start action. For example, a CodeBlockStartAction with no registered actions or only a registered CodeBlockEndAction should be replaced with a CodeBlockAction.
4. If required, register an end action to report diagnostics based on the final state.
</source>
        <target state="translated">Uma ação inicial do analisador permite realizar análises com estado em uma determinada unidade de código, como um bloco de código, compilação, etc. É necessário projetar cuidadosamente para realizar a execução eficiente do analisador sem perdas de memória. Use as seguintes diretrizes para gravar esses analisadores:
1. Defina um novo escopo para a ação inicial registrada, possivelmente com um tipo aninhado privado para analisar cada unidade de código.
2. Se necessário, defina e inicialize o estado na ação inicial.
3. Registre pelo menos uma ação não final que referencia esse estado na ação inicial. Se nenhuma ação assim for necessária, considere substituir a ação inicial por uma ação não inicial. Por exemplo, um CodeBlockStartAction com ações não registradas ou apenas um CodeBlockEndAction registrado deve ser substituído por um CodeBlockAction.
4. Se necessário, registre uma ação final para relatar o diagnóstico com base no estado final.
</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLocalizableStringsInDescriptorMessage">
        <source>Consider providing localizable arguments of type '{0}' to diagnostic descriptor constructor to ensure the descriptor is localizable.</source>
        <target state="translated">Considere fornecer argumentos localizáveis do tipo '{0}' para o construtor de descritor de diagnóstico para garantir que o descritor seja localizável.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLocalizableStringsInDescriptorTitle">
        <source>Provide localizable arguments to diagnostic descriptor constructor.</source>
        <target state="translated">Forneça argumentos localizáveis para o construtor de descritor de diagnóstico.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLocalizableStringsInDescriptorDescription">
        <source>If your diagnostic analyzer and it's reported diagnostics need to be localizable, then the supported DiagnosticDescriptors used for constructing the diagnostics must also be localizable. If so, then localizable argument(s) must be provided for parameter 'title' (and optionally 'description') to the diagnostic descriptor constructor to ensure that the descriptor is localizable.</source>
        <target state="translated">Se seu analisador de diagnóstico e o respectivo diagnóstico reportado precisarem ser localizáveis, então o DiagnosticDescriptors com suporte usado para construir o diagnóstico também deverá ser localizável. Em caso afirmativo, os argumentos localizáveis deverão ser fornecidos do "título" (e opcionalmente para a "descrição") de parâmetro para o construtor de descritor de diagnóstico para garantir que o descritor seja localizável.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStorePerCompilationDataOntoFieldsMessage">
        <source>Avoid storing per-compilation data of type '{0}' into the fields of a diagnostic analyzer.</source>
        <target state="translated">Evite armazenar dados por compilação do tipo '{0}' nos campos de um analisador de diagnóstico.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStorePerCompilationDataOntoFieldsTitle">
        <source>Avoid storing per-compilation data into the fields of a diagnostic analyzer.</source>
        <target state="translated">Evite armazenar dados por compilação nos campos de um analisador de diagnóstico.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStorePerCompilationDataOntoFieldsDescription">
        <source>Instance of a diagnostic analyzer might outlive the lifetime of compilation. Hence, storing per-compilation data, such as symbols, into the fields of a diagnostic analyzer might cause stale compilations to stay alive and cause memory leaks.  Instead, you should store this data on a separate type instantiated in a compilation start action, registered using '{0}.{1}' API. An instance of this type will be created per-compilation and it won't outlive compilation's lifetime, hence avoiding memory leaks.</source>
        <target state="translated">A instância de um analisador de diagnóstico pode sobreviver ao tempo de vida de compilação. Portanto, armazenar dados por compilação, como símbolos, nos campos de um analisador de diagnóstico pode fazer compilações obsoletas permanecerem ativas e causar perdas de memória.  Em vez disso, você deve armazenar esses dados em um tipo separado cuja instância foi criada em uma ação inicial de compilação, registrada usando a API do '{0}.{1}'. Uma instância desse tipo será criada por compilação e não sobreviverá ao tempo de vida da compilação, evitando, portanto, perdas de memória.</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalImplementationOnlyDescription">
        <source>The author of this interface did not intend to have third party implementations of this interface and reserves the right to change it. Implementing this interface could therefore result in a source or binary compatibility issue with a future version of this interface.</source>
        <target state="translated">O autor dessa interface não pretendia ter implementações de terceiros dessa interface e reserva-se o direito de alterá-la. Implementar essa interface poderia, portanto, resultar em um problema de compatibilidade de origem ou binária com uma versão futura dessa interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalImplementationOnlyMessage">
        <source>Type {0} cannot implement interface {1} because {1} is not available for public implementation.</source>
        <target state="translated">O tipo {0} não pode implementar a interface {1}, porque {1} não está disponível para implementação pública.</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalImplementationOnlyTitle">
        <source>Only internal implementations of this interface are allowed.</source>
        <target state="translated">São permitidas apenas implementações internas dessa interface.</target>
        <note />
      </trans-unit>
      <trans-unit id="CodeActionNeedsEquivalenceKeyDescription">
        <source>A CodeFixProvider that intends to support fix all occurrences must classify the registered code actions into equivalence classes by assigning it an explicit, non-null equivalence key which is unique across all registered code actions by this fixer. This enables the FixAllProvider to fix all diagnostics in the required scope by applying code actions from this fixer that are in the equivalence class of the trigger code action.</source>
        <target state="translated">Um CodeFixProvider que pretende dar suporte à correção de todas as ocorrências deve classificar as ações de código registradas em classes de equivalência, atribuindo a ela uma chave de equivalência explícita e não nula, exclusiva em todas as ações de código registradas por este reparador. Isso permite que o FixAllProvider corrija todos os diagnósticos no escopo necessário aplicando ações de código desse reparador que estão na classe de equivalência da ação de código do gatilho.</target>
        <note />
      </trans-unit>
      <trans-unit id="CreateCodeActionWithEquivalenceKeyMessage">
        <source>Provide an explicit argument for optional parameter '{0}', which is non-null and unique across all code actions created by this fixer.</source>
        <target state="translated">Forneça um argumento explícito para o parâmetro '{0}' opcional, que é exclusivo e não nulo em todas as ações de código criadas por este reparador.</target>
        <note />
      </trans-unit>
      <trans-unit id="CreateCodeActionWithEquivalenceKeyTitle">
        <source>Create code actions should have a unique EquivalenceKey for FixAll occurrences support.</source>
        <target state="translated">Criar ações de código deve ter um EquivalenceKey exclusivo para o suporte a ocorrências FixAll.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideCodeActionEquivalenceKeyMessage">
        <source>'{0}' has the default value of 'null' for property '{1}'. Either override this property on '{0}' to return a non-null and unique value across all code actions per-fixer or use such an existing code action.</source>
        <target state="translated">'{0}' tem o valor padrão de 'null' para a propriedade '{1}'. Substitua essa propriedade em '{0}' para retornar um valor único e não nulo em todas as ações de código por reparador ou use essa ação de código existente.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideCodeActionEquivalenceKeyTitle">
        <source>Use code actions that have a unique EquivalenceKey for FixAll occurrences support.</source>
        <target state="translated">Use ações de código que têm um EquivalenceKey exclusivo para o suporte a ocorrências FixAll.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationDescription">
        <source>Many objects exposed by Roslyn are immutable. The return value from a method invocation on these objects should not be ignored.</source>
        <target state="translated">Muitos objetos expostos pelo Roslyn são imutáveis. O valor retornado de uma invocação de método nesses objetos não deve ser ignorado.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationMessage">
        <source>'{0}' is immutable and '{1}' will not have any effect on it. Consider using the return value from '{1}'.</source>
        <target state="translated">'{0}' é imutável e '{1}' não terá nenhum efeito nele. Considere usar o valor retornado de '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationTitle">
        <source>Do not ignore values returned by methods on immutable objects.</source>
        <target state="translated">Não ignore valores retornados por métodos em objetos imutáveis.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>