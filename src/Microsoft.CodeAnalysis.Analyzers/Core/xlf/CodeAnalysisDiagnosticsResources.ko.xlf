<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../CodeAnalysisDiagnosticsResources.resx">
    <body>
      <trans-unit id="MissingAttributeMessage">
        <source>Missing '{0}' attribute.</source>
        <target state="translated">'{0}' 특성이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingDiagnosticAnalyzerAttributeTitle">
        <source>Missing diagnostic analyzer attribute.</source>
        <target state="translated">진단 분석기 특성이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingDiagnosticAnalyzerAttributeDescription">
        <source>Non-abstract sub-types of DiagnosticAnalyzer should be marked with DiagnosticAnalyzerAttribute(s). The argument to this attribute(s), if any, determine the supported languages for the analyzer. Analyzer types without this attribute will be ignored by the analysis engine.</source>
        <target state="translated">DiagnosticAnalyzer의 비추상 하위 형식은 DiagnosticAnalyzerAttribute로 표시되어야 합니다. 이 특성에 대한 인수가 있는 경우 해당 인수가 분석기에 지원되는 언어를 결정합니다. 이 특성이 없는 분석기 형식은 분석 엔진에 의해 무시됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddLanguageSupportToAnalyzerMessage">
        <source>Diagnostic analyzer '{0}' may be able to support both C# and Visual Basic. Consider adding an argument to DiagnosticAnalyzerAttribute for '{1}' language support.</source>
        <target state="translated">'{0}' 진단 분석기는 C# 및 Visual Basic을 모두 지원할 수 있습니다. '{1}' 언어 지원을 위해 DiagnosticAnalyzerAttribute에 대한 인수를 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddLanguageSupportToAnalyzerTitle">
        <source>Recommend adding language support to diagnostic analyzer.</source>
        <target state="translated">진단 분석기에 언어 지원을 추가하는 것이 좋습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AddLanguageSupportToAnalyzerDescription">
        <source>Diagnostic analyzer is marked as supporting only one language, but the analyzer assembly doesn't seem to refer to any language specific CodeAnalysis assemblies, and so is likely to work for more than one language. Consider adding an additional language argument to DiagnosticAnalyzerAttribute.</source>
        <target state="translated">진단 분석기는 1개의 언어만 지원하는 것으로 표시되지만, 분석기 어셈블리가 언어 특정 CodeAnalysis 어셈블리를 참조하지 않는 것으로 보이므로 2개 이상의 언어로 작업할 가능성이 있습니다. DiagnosticAnalyzerAttribute에 언어 인수를 추가하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyDiagnosticAnalyzerAttribute_1">
        <source>Apply DiagnosticAnalyzer attribute for '{0}'.</source>
        <target state="translated">'{0}'에 대한 DiagnosticAnalyzer 특성을 적용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="ApplyDiagnosticAnalyzerAttribute_2">
        <source>Apply DiagnosticAnalyzer attribute for both '{0}' and '{1}'.</source>
        <target state="translated">'{0}' 및 '{1}'에 대한 DiagnosticAnalyzer 특성을 적용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingSymbolKindArgumentToRegisterActionMessage">
        <source>Specify at least one SymbolKind of interest when registering a symbol analyzer action.</source>
        <target state="translated">기호 분석기 작업을 등록할 때 관심 있는 SymbolKind를 하나 이상 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingSyntaxKindArgumentToRegisterActionMessage">
        <source>Specify at least one SyntaxKind of interest when registering a syntax node analyzer action.</source>
        <target state="translated">구문 노드 분석기 작업을 등록할 때 관심 있는 SyntaxKind를 하나 이상 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingOperationKindArgumentToRegisterActionMessage">
        <source>Specify at least one OperationKind of interest when registering an operation analyzer action.</source>
        <target state="translated">작업 분석기 작업을 등록할 때 관심 있는 OperationKind를 하나 이상 지정하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingKindArgumentToRegisterActionTitle">
        <source>Missing kind argument when registering an analyzer action.</source>
        <target state="translated">분석기 작업을 등록할 때 지정할 종류 인수가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="MissingKindArgumentToRegisterActionDescription">
        <source>You must specify at least one syntax, symbol or operation kind when registering a syntax, symbol, or operation analyzer action respectively. Otherwise, the registered action will never be invoked during analysis.</source>
        <target state="translated">구문, 기호 또는 작업 분석기 작업을 각각 등록할 때 하나 이상의 구문, 기호 또는 작업 종류를 지정해야 합니다. 지정하지 않으면 등록된 작업이 분석하는 동안 호출되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSymbolKindArgumentToRegisterActionMessage">
        <source>SymbolKind '{0}' is not supported for symbol analyzer actions.</source>
        <target state="translated">SymbolKind '{0}'이(가) 기호 분석기 작업에 대해 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="UnsupportedSymbolKindArgumentToRegisterActionTitle">
        <source>Unsupported SymbolKind argument when registering a symbol analyzer action.</source>
        <target state="translated">기호 분석기 작업을 등록할 때 지원되지 않는 SymbolKind 인수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReportDiagnosticMessage">
        <source>ReportDiagnostic invoked with an unsupported DiagnosticDescriptor '{0}'.</source>
        <target state="translated">지원되지 않는 DiagnosticDescriptor '{0}'을(를) 사용하여 호출된 ReportDiagnostic입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReportDiagnosticTitle">
        <source>ReportDiagnostic invoked with an unsupported DiagnosticDescriptor.</source>
        <target state="translated">지원되지 않는 DiagnosticDescriptor를 사용하여 호출된 ReportDiagnostic입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidReportDiagnosticDescription">
        <source>ReportDiagnostic should only be invoked with supported DiagnosticDescriptors that are returned from DiagnosticAnalyzer.SupportedDiagnostics property. Otherwise, the reported diagnostic will be filtered out by the analysis engine.</source>
        <target state="translated">ReportDiagnostic은 DiagnosticAnalyzer.SupportedDiagnostics 속성에서 반환된 지원되는 DiagnosticDescriptors를 통해서만 호출되어야 합니다. 그러지 않으면 보고된 진단이 분석 엔진에 의해 필터링됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSyntaxKindTypeArgumentMessage">
        <source>Type argument '{0}' for type parameter '{1}' of method '{2}' is not a SyntaxKind enum.</source>
        <target state="translated">'{2}' 메서드의 '{1}' 형식 매개 변수에 대한 '{0}' 형식 인수는 SyntaxKind 열거형이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSyntaxKindTypeArgumentTitle">
        <source>Invalid type argument for DiagnosticAnalyzer's Register method.</source>
        <target state="translated">DiagnosticAnalyzer의 Register 메서드에 대한 형식 인수가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InvalidSyntaxKindTypeArgumentDescription">
        <source>DiagnosticAnalyzer's language-specific Register methods, such as RegisterSyntaxNodeAction, RegisterCodeBlockStartAction and RegisterCodeBlockEndAction, expect a language-specific 'SyntaxKind' type argument for it's '{0}' type parameter. Otherwise, the registered analyzer action can never be invoked during analysis.</source>
        <target state="translated">RegisterSyntaxNodeAction, RegisterCodeBlockStartAction 및 RegisterCodeBlockEndAction 등의 DiagnosticAnalyzer의 언어 특정 Register 메서드에는 '{0}' 형식 매개 변수에 대한 언어 특정 'SyntaxKind' 형식 인수를 사용해야 합니다. 그러지 않으면 등록된 분석기 작업이 분석하는 동안 호출되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StartActionWithOnlyEndActionTitle">
        <source>Start action has no registered non-end actions.</source>
        <target state="translated">시작 작업에 등록된 비종료 작업이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StartActionWithNoRegisteredActionsMessage">
        <source>'{0}' does not register any analyzer actions. Consider moving actions registered in '{1}' that depend on this start action to '{0}'.</source>
        <target state="translated">'{0}'은(는) 분석기 작업을 등록하지 않습니다. 이 시작 작업에 종속된 '{1}'에 등록된 작업을 '{0}'(으)로 이동하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="StartActionWithNoRegisteredActionsTitle">
        <source>Start action has no registered actions.</source>
        <target state="translated">시작 작업에 등록된 작업이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="StartActionWithOnlyEndActionMessage">
        <source>'{0}' does not register any analyzer actions, except for a '{1}'. Consider replacing this start/end action pair with a '{2}' or moving actions registered in '{3}' that depend on this start action to '{0}'.</source>
        <target state="translated">'{0}'은(는) '{1}'을(를) 제외하고 분석기 작업을 등록하지 않았습니다. 이 시작/종료 작업 쌍을 '{2}'(으)로 바꾸거나 이 시작 작업에 종속된 '{3}'에 등록된 작업을 '{0}'(으)로 이동하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="StatefulAnalyzerRegisterActionsDescription">
        <source>An analyzer start action enables performing stateful analysis over a given code unit, such as a code block, compilation, etc. Careful design is necessary to achieve efficient analyzer execution without memory leaks. Use the following guidelines for writing such analyzers:
1. Define a new scope for the registered start action, possibly with a private nested type for analyzing each code unit.
2. If required, define and initialize state in the start action.
3. Register at least one non-end action that refers to this state in the start action. If no such action is necessary, consider replacing the start action with a non-start action. For example, a CodeBlockStartAction with no registered actions or only a registered CodeBlockEndAction should be replaced with a CodeBlockAction.
4. If required, register an end action to report diagnostics based on the final state.
</source>
        <target state="translated">분석기 시작 작업을 통해 코드 블록, 컴파일 등의 특정 코드 단위에서 상태 저장 분석을 수행할 수 있습니다. 분석기를 메모리 손실 없이 효율적으로 실행하려면 신중한 설계가 필요합니다. 이러한 분석기를 쓰려면 다음 지침을 사용하세요.
1. 등록된 시작 작업에 대해 각 코드 단위를 분석하기 위한 private 중첩 형식이 있는 새 범위를 정의합니다.
2. 필요한 경우 시작 작업에서 상태를 정의하고 초기화합니다.
3. 시작 작업에서 이 상태를 참조하는 비종료 작업을 하나 이상 등록합니다. 이러한 작업이 필요하지 않은 경우 시작 작업을 비종료 작업으로 바꾸세요. 예를 들어 등록된 작업이 없는 CodeBlockStartAction 또는 등록된 CodeBlockEndAction만 CodeBlockAction으로 바꿀 수 있습니다.
4. 필요한 경우 종료 작업을 등록하여 최종 상태를 기준으로 진단을 보고합니다.
</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLocalizableStringsInDescriptorMessage">
        <source>Consider providing localizable arguments of type '{0}' to diagnostic descriptor constructor to ensure the descriptor is localizable.</source>
        <target state="translated">'{0}' 형식의 현지화할 수 있는 인수를 진단 설명자 생성자에 제공하여 설명자를 현지화할 수 있는지 확인하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLocalizableStringsInDescriptorTitle">
        <source>Provide localizable arguments to diagnostic descriptor constructor.</source>
        <target state="translated">현지화할 수 있는 인수를 진단 설명자 생성자에 제공하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="UseLocalizableStringsInDescriptorDescription">
        <source>If your diagnostic analyzer and it's reported diagnostics need to be localizable, then the supported DiagnosticDescriptors used for constructing the diagnostics must also be localizable. If so, then localizable argument(s) must be provided for parameter 'title' (and optionally 'description') to the diagnostic descriptor constructor to ensure that the descriptor is localizable.</source>
        <target state="translated">진단 분석기 및 보고된 진단을 현지화해야 하는 경우 진단을 생성하는 데 사용된 지원되는 DiagnosticDescriptors도 현지화할 수 있어야 합니다. 이 경우 매개 변수 '제목'(선택적으로 '설명')에 대해 현지화할 수 있는 인수를 진단 설명자 생성자에 제공하여 설명자를 현지화할 수 있는지 확인해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStorePerCompilationDataOntoFieldsMessage">
        <source>Avoid storing per-compilation data of type '{0}' into the fields of a diagnostic analyzer.</source>
        <target state="translated">'{0}' 형식의 컴파일당 데이터를 진단 분석기의 필드에 저장하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStorePerCompilationDataOntoFieldsTitle">
        <source>Avoid storing per-compilation data into the fields of a diagnostic analyzer.</source>
        <target state="translated">컴파일당 데이터를 진단 분석기의 필드에 저장하지 마세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotStorePerCompilationDataOntoFieldsDescription">
        <source>Instance of a diagnostic analyzer might outlive the lifetime of compilation. Hence, storing per-compilation data, such as symbols, into the fields of a diagnostic analyzer might cause stale compilations to stay alive and cause memory leaks.  Instead, you should store this data on a separate type instantiated in a compilation start action, registered using '{0}.{1}' API. An instance of this type will be created per-compilation and it won't outlive compilation's lifetime, hence avoiding memory leaks.</source>
        <target state="translated">진단 분석기의 인스턴스는 컴파일 수명보다 더 오래 활성화될 수 있습니다. 그러므로 기호와 같은 컴파일당 데이터를 진단 분석기 필드에 저장하면 활성화된 컴파일의 상태가 부실하여 메모리 손실 문제를 일으킬 수 있습니다.  대신 인스턴스화된 별도 형식의 데이터를 '{0}.{1}' API를 사용하여 등록된 컴파일 시작 작업에 저장해야 합니다. 이 형식의 컴파일당 인스턴스가 만들어지며 컴파일의 수명보다 오래 활성화되지 않아 메모리 손실을 방지할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalImplementationOnlyDescription">
        <source>The author of this interface did not intend to have third party implementations of this interface and reserves the right to change it. Implementing this interface could therefore result in a source or binary compatibility issue with a future version of this interface.</source>
        <target state="translated">이 인터페이스 작성자는 이 인터페이스를 타사에서 구현하도록 의도하지 않았으며 변경할 권리를 갖습니다. 그러므로 이 인터페이스를 구현하면 향후 버전에서 소스 또는 이진 호환성 문제가 발생할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalImplementationOnlyMessage">
        <source>Type {0} cannot implement interface {1} because {1} is not available for public implementation.</source>
        <target state="translated">{1}을(를) 공용 구현할 수 없으므로 {0} 형식은 {1} 인터페이스를 구현할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="InternalImplementationOnlyTitle">
        <source>Only internal implementations of this interface are allowed.</source>
        <target state="translated">이 인터페이스의 내부 구현만 허용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CodeActionNeedsEquivalenceKeyDescription">
        <source>A CodeFixProvider that intends to support fix all occurrences must classify the registered code actions into equivalence classes by assigning it an explicit, non-null equivalence key which is unique across all registered code actions by this fixer. This enables the FixAllProvider to fix all diagnostics in the required scope by applying code actions from this fixer that are in the equivalence class of the trigger code action.</source>
        <target state="translated">모든 발생 수정을 지원하는 CodeFixProvider에 이 수정 도구에서 만들어진 등록된 모든 코드에서 고유한 명시적이고 null이 아닌 동등 키를 할당하여 등록된 코드 작업을 동등 클래스로 분류해야 합니다. 이렇게 하면 FixAllProvider가 트리거 코드 작업의 동등 클래스에 있는 수정 도구의 코드 작업을 적용하여 필수 범위에서 모든 진단을 수정할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="CreateCodeActionWithEquivalenceKeyMessage">
        <source>Provide an explicit argument for optional parameter '{0}', which is non-null and unique across all code actions created by this fixer.</source>
        <target state="translated">이 수정 도구에서 만들어진 모든 코드 작업에서 고유하고 null이 아닌 선택적 매개 변수 '{0}'에 대한 명시적 인수를 제공하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="CreateCodeActionWithEquivalenceKeyTitle">
        <source>Create code actions should have a unique EquivalenceKey for FixAll occurrences support.</source>
        <target state="translated">코드 만들기 작업에는 FixAll 발생 지원을 위한 고유 EquivalenceKey가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideCodeActionEquivalenceKeyMessage">
        <source>'{0}' has the default value of 'null' for property '{1}'. Either override this property on '{0}' to return a non-null and unique value across all code actions per-fixer or use such an existing code action.</source>
        <target state="translated">'{0}'에는 '{1}' 속성에 대한 'null'의 기본값이 있습니다. '{0}'의 속성을 재정의하여 수정 도구당 모든 코드 작업에서 null이 아닌 고유 값을 반환하거나 기존 코드 작업을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="OverrideCodeActionEquivalenceKeyTitle">
        <source>Use code actions that have a unique EquivalenceKey for FixAll occurrences support.</source>
        <target state="translated">FixAll 발생 지원을 위한 고유 EquivalenceKey가 있는 코드 작업을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationDescription">
        <source>Many objects exposed by Roslyn are immutable. The return value from a method invocation on these objects should not be ignored.</source>
        <target state="translated">Roslyn에서 노출한 대부분의 개체는 변경할 수 없습니다. 이 개체에 대한 메서드 호출의 반환 값은 무시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationMessage">
        <source>'{0}' is immutable and '{1}' will not have any effect on it. Consider using the return value from '{1}'.</source>
        <target state="translated">'{0}'을(를) 변경할 수 없으며 '{1}'은(는) 아무런 영향을 주지 않습니다. '{1}'의 반환 값을 사용하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="DoNotIgnoreReturnValueOnImmutableObjectMethodInvocationTitle">
        <source>Do not ignore values returned by methods on immutable objects.</source>
        <target state="translated">변경할 수 없는 개체의 메서드에서 반환된 값을 무시하지 마세요.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>