<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="cs" original="../FeaturesResources.resx">
    <body>
      <trans-unit id="AM_PM_abbreviated">
        <source>AM/PM (abbreviated)</source>
        <target state="translated">AM/PM (zkráceno)</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_abbreviated_description">
        <source>The "t" custom format specifier represents the first character of the AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property of the current or specific culture. The AM designator is used for all times from 0:00:00 (midnight) to 11:59:59.999. The PM designator is used for all times from 12:00:00 (noon) to 23:59:59.999.

If the "t" format specifier is used without other custom format specifiers, it's interpreted as the "t" standard date and time format specifier.</source>
        <target state="translated">Specifikátor vlastního formátu t představuje první znak údaje dop/odp. Správný lokalizovaný údaj se načítá z vlastnosti DateTimeFormatInfo.AMDesignator nebo DateTimeFormatInfo.PMDesignator aktuální nebo konkrétní jazykové verze. Údaj dop se používá pro časy od 0:00:00 (půlnoc) do 11:59:59.999. Údaj odp se používá pro časy od 12:00:00 (poledne) do 23:59:59.999.

Pokud se specifikátor formátu t použije bez dalších vlastních specifikátorů formátu, interpretuje se jako standardní specifikátor formátu data a času t.</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_full">
        <source>AM/PM (full)</source>
        <target state="translated">AM/PM (úplné)</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_full_description">
        <source>The "tt" custom format specifier (plus any number of additional "t" specifiers) represents the entire AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property of the current or specific culture. The AM designator is used for all times from 0:00:00 (midnight) to 11:59:59.999. The PM designator is used for all times from 12:00:00 (noon) to 23:59:59.999.

Make sure to use the "tt" specifier for languages for which it's necessary to maintain the distinction between AM and PM. An example is Japanese, for which the AM and PM designators differ in the second character instead of the first character.</source>
        <target state="translated">Specifikátor vlastního formátu tt (a jakýkoli počet dalších specifikátorů t) představuje celý údaj dop/odp. Správný lokalizovaný údaj se načítá z vlastnosti DateTimeFormatInfo.AMDesignator nebo DateTimeFormatInfo.PMDesignator aktuální nebo konkrétní jazykové verze. Údaj dop se používá pro časy od 0:00:00 (půlnoc) do 11:59:59.999. Údaj odp se používá pro časy od 12:00:00 (poledne) do 23:59:59.999.

Ujistěte se, že specifikátor tt použijete pro jazyky, pro které je nezbytné zachovat rozlišení mezi dop a odp. Příkladem může být japonština, pro kterou se údaje dop a odp liší namísto prvního znaku ve znaku sekundy.</target>
        <note />
      </trans-unit>
      <trans-unit id="A_subtraction_must_be_the_last_element_in_a_character_class">
        <source>A subtraction must be the last element in a character class</source>
        <target state="translated">Odčítání musí být posledním prvkem ve třídě znaků.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-[b]-c]</note>
      </trans-unit>
      <trans-unit id="Add_DebuggerDisplay_attribute">
        <source>Add 'DebuggerDisplay' attribute</source>
        <target state="translated">Přidat atribut DebuggerDisplay</target>
        <note>{Locked="DebuggerDisplay"} "DebuggerDisplay" is a BCL class and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Add_explicit_cast">
        <source>Add explicit cast</source>
        <target state="translated">Přidat explicitní přetypování</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_member_name">
        <source>Add member name</source>
        <target state="translated">Přidat název členu</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_null_checks_for_all_parameters">
        <source>Add null checks for all parameters</source>
        <target state="translated">Přidat kontroly hodnot null u všech parametrů</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_optional_parameter_to_constructor">
        <source>Add optional parameter to constructor</source>
        <target state="translated">Přidat volitelný parametr do konstruktoru</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_parameter_to_0_and_overrides_implementations">
        <source>Add parameter to '{0}' (and overrides/implementations)</source>
        <target state="translated">Přidat parametr do {0} (a přepsání/implementace)</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_parameter_to_constructor">
        <source>Add parameter to constructor</source>
        <target state="translated">Přidat parametr do konstruktoru</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_project_reference_to_0">
        <source>Add project reference to '{0}'.</source>
        <target state="translated">Přidat odkaz na projekt do {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_reference_to_0">
        <source>Add reference to '{0}'.</source>
        <target state="translated">Přidat odkaz do {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Actions_can_not_be_empty">
        <source>Actions can not be empty.</source>
        <target state="translated">Akce nemůžou zůstat prázdné.</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_tuple_element_name_0">
        <source>Add tuple element name '{0}'</source>
        <target state="translated">Přidat název elementu řazené kolekce členů {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_a_generic_type_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' into a generic type will prevent the debug session from continuing.</source>
        <target state="new">Adding '{0}' into a generic type will prevent the debug session from continuing.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_an_interface_method_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' into an interface method will prevent the debug session from continuing.</source>
        <target state="translated">Přidání prvku {0} do metody rozhraní zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_an_interface_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' into an interface will prevent the debug session from continuing.</source>
        <target state="translated">Přidání prvku {0} do rozhraní zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_method_with_explicit_interface_specifier_will_prevernt_the_debug_session_from_continuing">
        <source>Adding a method with an explicit interface specifier will prevent the debug session from continuing.</source>
        <target state="translated">Přidání metody s explicitním specifikátorem rozhraní zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Align_wrapped_arguments">
        <source>Align wrapped arguments</source>
        <target state="translated">Zarovnat zalomené argumenty</target>
        <note />
      </trans-unit>
      <trans-unit id="Align_wrapped_parameters">
        <source>Align wrapped parameters</source>
        <target state="translated">Zarovnat zalomené parametry</target>
        <note />
      </trans-unit>
      <trans-unit id="Alternation_conditions_cannot_be_comments">
        <source>Alternation conditions cannot be comments</source>
        <target state="translated">Podmínky alternativního výrazu nemůžou být komentáře.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a|(?#b)</note>
      </trans-unit>
      <trans-unit id="Alternation_conditions_do_not_capture_and_cannot_be_named">
        <source>Alternation conditions do not capture and cannot be named</source>
        <target state="translated">Podmínky alternativního výrazu nezachytávají a nejde je pojmenovat.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(?'x'))</note>
      </trans-unit>
      <trans-unit id="An_active_statement_has_been_removed_from_its_original_method_You_must_revert_your_changes_to_continue_or_restart_the_debugging_session">
        <source>An active statement has been removed from its original method. You must revert your changes to continue or restart the debugging session.</source>
        <target state="new">An active statement has been removed from its original method. You must revert your changes to continue or restart the debugging session.</target>
        <note />
      </trans-unit>
      <trans-unit id="Awaited_task_returns_0">
        <source>Awaited task returns '{0}'</source>
        <target state="translated">Očekávaná úloha vrací {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Awaited_task_returns_no_value">
        <source>Awaited task returns no value</source>
        <target state="translated">Očekávaná úloha nevrací žádnou hodnotu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Base_classes_contain_inaccessible_unimplemented_members">
        <source>Base classes contain inaccessible unimplemented members</source>
        <target state="translated">Základní třídy obsahují nepřístupné nenaimplementované členy.</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotApplyChangesUnexpectedError">
        <source>Cannot apply changes -- unexpected error: '{0}'</source>
        <target state="translated">Změny se nedají použít – neočekávaná chyba: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_include_class_0_in_character_range">
        <source>Cannot include class \{0} in character range</source>
        <target state="translated">Do rozsahu znaků nejde zahrnout třídu \{0}.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-\w]. {0} is the invalid class (\w here)</note>
      </trans-unit>
      <trans-unit id="Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue">
        <source>Capture group numbers must be less than or equal to Int32.MaxValue</source>
        <target state="translated">Čísla skupin digitalizace musí být menší nebo rovny hodnotě Int32.MaxValue</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{2147483648}</note>
      </trans-unit>
      <trans-unit id="Capture_number_cannot_be_zero">
        <source>Capture number cannot be zero</source>
        <target state="translated">Počet zachytávání nemůže být nulový</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;0&gt;a)</note>
      </trans-unit>
      <trans-unit id="ChangeSignature_NewParameterInferValue">
        <source>&lt;infer&gt;</source>
        <target state="translated">&lt;vyvodit&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeSignature_NewParameterIntroduceTODOVariable">
        <source>TODO</source>
        <target state="translated">TODO</target>
        <note>"TODO" is an indication that there is work still to be done.</note>
      </trans-unit>
      <trans-unit id="ChangeSignature_NewParameterOmitValue">
        <source>&lt;omit&gt;</source>
        <target state="translated">&lt;vynechat&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_namespace_to_0">
        <source>Change namespace to '{0}'</source>
        <target state="translated">Změnit obor názvů na {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_to_global_namespace">
        <source>Change to global namespace</source>
        <target state="translated">Změnit na globální obor názvů</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangesDisallowedWhileStoppedAtException">
        <source>Changes are not allowed while stopped at exception</source>
        <target state="translated">Když se běh zastaví na výjimce, změny se nepovolují.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangesNotAppliedWhileRunning">
        <source>Changes made in project '{0}' will not be applied while the application is running</source>
        <target state="translated">Změny provedené v projektu {0} se nepoužijí, dokud je aplikace spuštěná.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_0_from_asynchronous_to_synchronous_will_prevent_the_debug_session_from_continuing">
        <source>Changing '{0}' from asynchronous to synchronous will prevent the debug session from continuing.</source>
        <target state="translated">Pokud se změní {0} z asynchronního na synchronní, relace ladění nebude moct pokračovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_0_to_1_will_prevent_the_debug_session_from_continuing_because_it_changes_the_shape_of_the_state_machine">
        <source>Changing '{0}' to '{1}' will prevent the debug session from continuing because it changes the shape of the state machine.</source>
        <target state="translated">Pokud se změní {0} na {1}, relace ladění nebude moct pokračovat, protože dojde ke změně tvaru stavového počítače.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_visibility_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Changing visibility of {0} will prevent the debug session from continuing.</source>
        <target state="new">Changing visibility of {0} will prevent the debug session from continuing.</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_0_code_style">
        <source>Configure {0} code style</source>
        <target state="translated">Nakonfigurovat styl kódu {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_0_severity">
        <source>Configure {0} severity</source>
        <target state="translated">Nakonfigurovat závažnost {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_severity_for_all_0_analyzers">
        <source>Configure severity for all '{0}' analyzers</source>
        <target state="translated">Nakonfigurujte závažnost pro všechny analyzátory {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_severity_for_all_analyzers">
        <source>Configure severity for all analyzers</source>
        <target state="translated">Nakonfigurujte závažnost pro všechny analyzátory.</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_linq">
        <source>Convert to LINQ</source>
        <target state="translated">Převést na LINQ</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_to_0">
        <source>Add to '{0}'</source>
        <target state="translated">Přidat do {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_class">
        <source>Convert to class</source>
        <target state="translated">Převést na třídu</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_linq_call_form">
        <source>Convert to LINQ (call form)</source>
        <target state="translated">Převést na LINQ (volání formuláře)</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_record">
        <source>Convert to record</source>
        <target state="translated">Převést na záznam</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_struct">
        <source>Convert to struct</source>
        <target state="translated">Převést na strukturu</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_type_to_0">
        <source>Convert type to '{0}'</source>
        <target state="translated">Převést typ na {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_field_0">
        <source>Create and assign field '{0}'</source>
        <target state="translated">Vytvořit a přiřadit pole {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_property_0">
        <source>Create and assign property '{0}'</source>
        <target state="translated">Vytvořit a přiřadit vlastnost {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_remaining_as_fields">
        <source>Create and assign remaining as fields</source>
        <target state="translated">Vytvořit a přiřadit zbývající položky jako pole</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_remaining_as_properties">
        <source>Create and assign remaining as properties</source>
        <target state="translated">Vytvořit a přiřadit zbývající položky jako vlastnosti</target>
        <note />
      </trans-unit>
      <trans-unit id="Do_not_change_this_code_Put_cleanup_code_in_0_method">
        <source>Do not change this code. Put cleanup code in '{0}' method</source>
        <target state="translated">Neměňte tento kód. Kód pro vyčištění vložte do metody {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="DocumentIsOutOfSyncWithDebuggee">
        <source>The current content of source file '{0}' does not match the built source. Any changes made to this file while debugging won't be applied until its content matches the built source.</source>
        <target state="translated">Aktuální obsah zdrojového souboru {0} se neshoduje se sestaveným zdrojem. Případné změny provedené v tomto souboru během ladění se nepoužijí, dokud se jeho obsah nebude shodovat se sestaveným zdrojem.</target>
        <note />
      </trans-unit>
      <trans-unit id="Document_must_be_contained_in_the_workspace_that_created_this_service">
        <source>Document must be contained in the workspace that created this service</source>
        <target state="translated">Dokument musí být obsažený v pracovním prostoru, který vytvořil tuto datovou službu</target>
        <note />
      </trans-unit>
      <trans-unit id="EditAndContinue">
        <source>Edit and Continue</source>
        <target state="translated">Upravit a pokračovat</target>
        <note />
      </trans-unit>
      <trans-unit id="EditAndContinueDisallowedByModule">
        <source>Edit and Continue disallowed by module</source>
        <target state="translated">Modul zakázal funkci Upravit a pokračovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="EditAndContinueDisallowedByProject">
        <source>Changes made in project '{0}' will prevent the debug session from continuing: {1}</source>
        <target state="translated">Změny provedené v projektu {0} znemožní relaci ladění pokračovat dále: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorReadingFile">
        <source>Error while reading file '{0}': {1}</source>
        <target state="translated">Při čtení souboru {0} došlo k chybě: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Error_creating_instance_of_CodeFixProvider">
        <source>Error creating instance of CodeFixProvider</source>
        <target state="translated">Při vytváření instance CodeFixProvider došlo k chybě.</target>
        <note />
      </trans-unit>
      <trans-unit id="Error_creating_instance_of_CodeFixProvider_0">
        <source>Error creating instance of CodeFixProvider '{0}'</source>
        <target state="translated">Při vytváření instance CodeFixProvider {0} došlo k chybě.</target>
        <note />
      </trans-unit>
      <trans-unit id="Example">
        <source>Example:</source>
        <target state="translated">Příklad:</target>
        <note>Singular form when we want to show an example, but only have one to show.</note>
      </trans-unit>
      <trans-unit id="Examples">
        <source>Examples:</source>
        <target state="translated">Příklady:</target>
        <note>Plural form when we have multiple examples to show.</note>
      </trans-unit>
      <trans-unit id="Extract_base_class">
        <source>Extract base class...</source>
        <target state="translated">Extrahovat základní třídu...</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_interface">
        <source>Extract interface...</source>
        <target state="translated">Extrahovat rozhraní...</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_local_function">
        <source>Extract local function</source>
        <target state="translated">Extrahovat lokální funkci</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_method">
        <source>Extract method</source>
        <target state="translated">Extrahovat metodu</target>
        <note />
      </trans-unit>
      <trans-unit id="Failed_to_analyze_data_flow_for_0">
        <source>Failed to analyze data-flow for: {0}</source>
        <target state="translated">Nepovedlo se analyzovat tok dat pro: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_formatting">
        <source>Fix formatting</source>
        <target state="translated">Opravit formátování</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_typo_0">
        <source>Fix typo '{0}'</source>
        <target state="translated">Opravit překlep {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Formatting_document">
        <source>Formatting document</source>
        <target state="translated">Formátuje se dokument.</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_comparison_operators">
        <source>Generate comparison operators</source>
        <target state="translated">Vygenerovat operátory porovnání</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constructor_in_0_with_fields">
        <source>Generate constructor in '{0}' (with fields)</source>
        <target state="translated">Vygenerovat konstruktor v {0} (s poli)</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constructor_in_0_with_properties">
        <source>Generate constructor in '{0}' (with properties)</source>
        <target state="translated">Vygenerovat konstruktor v {0} (s vlastnostmi)</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_for_0">
        <source>Generate for '{0}'</source>
        <target state="translated">Vygenerovat pro {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_parameter_0">
        <source>Generate parameter '{0}'</source>
        <target state="translated">Generovat parametr {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_parameter_0_and_overrides_implementations">
        <source>Generate parameter '{0}' (and overrides/implementations)</source>
        <target state="translated">Generovat parametr {0} (a přepsání/implementace)</target>
        <note />
      </trans-unit>
      <trans-unit id="Illegal_backslash_at_end_of_pattern">
        <source>Illegal \ at end of pattern</source>
        <target state="translated">Znak \ na konci vzorku je neplatný.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \</note>
      </trans-unit>
      <trans-unit id="Illegal_x_y_with_x_less_than_y">
        <source>Illegal {x,y} with x &gt; y</source>
        <target state="translated">Neplatné {x,y} s x &gt; y</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{1,0}</note>
      </trans-unit>
      <trans-unit id="Implement_0_explicitly">
        <source>Implement '{0}' explicitly</source>
        <target state="translated">Implementovat rozhraní {0} explicitně</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_0_implicitly">
        <source>Implement '{0}' implicitly</source>
        <target state="translated">Implementovat rozhraní {0} implicitně</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_abstract_class">
        <source>Implement abstract class</source>
        <target state="translated">Implementovat abstraktní třídu</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_all_interfaces_explicitly">
        <source>Implement all interfaces explicitly</source>
        <target state="translated">Implementovat všechna rozhraní explicitně</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_all_interfaces_implicitly">
        <source>Implement all interfaces implicitly</source>
        <target state="translated">Implementovat všechna rozhraní implicitně</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_all_members_explicitly">
        <source>Implement all members explicitly</source>
        <target state="translated">Implementovat všechny členy explicitně</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_explicitly">
        <source>Implement explicitly</source>
        <target state="translated">Implementovat explicitně</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_implicitly">
        <source>Implement implicitly</source>
        <target state="translated">Implementovat implicitně</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_remaining_members_explicitly">
        <source>Implement remaining members explicitly</source>
        <target state="translated">Implementovat zbývající členy explicitně</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_through_0">
        <source>Implement through '{0}'</source>
        <target state="translated">Implementovat přes {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Incomplete_character_escape">
        <source>Incomplete \p{X} character escape</source>
        <target state="translated">Neúplné uvození znaků \p{X}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{ Cc }</note>
      </trans-unit>
      <trans-unit id="Indent_all_arguments">
        <source>Indent all arguments</source>
        <target state="translated">Odsadit všechny argumenty</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_all_parameters">
        <source>Indent all parameters</source>
        <target state="translated">Odsadit všechny parametry</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_wrapped_arguments">
        <source>Indent wrapped arguments</source>
        <target state="translated">Odsadit zalomené argumenty</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_wrapped_parameters">
        <source>Indent wrapped parameters</source>
        <target state="translated">Odsadit zalomené parametry</target>
        <note />
      </trans-unit>
      <trans-unit id="Inline_0">
        <source>Inline '{0}'</source>
        <target state="translated">Inline refaktoring metody {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Inline_and_keep_0">
        <source>Inline and keep '{0}'</source>
        <target state="translated">Inline refaktoring metody {0} se zachováním deklarace</target>
        <note />
      </trans-unit>
      <trans-unit id="Insufficient_hexadecimal_digits">
        <source>Insufficient hexadecimal digits</source>
        <target state="translated">Nedostatek šestnáctkových číslic</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \x</note>
      </trans-unit>
      <trans-unit id="Introduce_constant">
        <source>Introduce constant</source>
        <target state="translated">Zavést konstantu</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_field">
        <source>Introduce field</source>
        <target state="translated">Zavést pole</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local">
        <source>Introduce local</source>
        <target state="translated">Zavést místní</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_query_variable">
        <source>Introduce query variable</source>
        <target state="translated">Zavést proměnnou dotazu</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_group_name_Group_names_must_begin_with_a_word_character">
        <source>Invalid group name: Group names must begin with a word character</source>
        <target state="translated">Neplatný název skupiny: Názvy skupin musí začínat znakem slova.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;a &gt;a)</note>
      </trans-unit>
      <trans-unit id="Make_class_abstract">
        <source>Make class 'abstract'</source>
        <target state="translated">Nastavit třídu jako abstract</target>
        <note />
      </trans-unit>
      <trans-unit id="Make_member_static">
        <source>Make static</source>
        <target state="translated">Nastavit jako statickou</target>
        <note />
      </trans-unit>
      <trans-unit id="Invert_conditional">
        <source>Invert conditional</source>
        <target state="translated">Převrátit podmínku</target>
        <note />
      </trans-unit>
      <trans-unit id="Malformed">
        <source>malformed</source>
        <target state="translated">chybný formát</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0</note>
      </trans-unit>
      <trans-unit id="Malformed_character_escape">
        <source>Malformed \p{X} character escape</source>
        <target state="translated">Chybně formátovaná řídicí sekvence znaků \p{X}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p {Cc}</note>
      </trans-unit>
      <trans-unit id="Malformed_named_back_reference">
        <source>Malformed \k&lt;...&gt; named back reference</source>
        <target state="translated">Chybně naformátovaný pojmenovaný zpětný odkaz \k&lt;...&gt;</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k'</note>
      </trans-unit>
      <trans-unit id="Merge_with_nested_0_statement">
        <source>Merge with nested '{0}' statement</source>
        <target state="translated">Sloučit s vnořeným příkazem {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Merge_with_next_0_statement">
        <source>Merge with next '{0}' statement</source>
        <target state="translated">Sloučit s dalším příkazem {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Merge_with_outer_0_statement">
        <source>Merge with outer '{0}' statement</source>
        <target state="translated">Sloučit s vnějším příkazem {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Merge_with_previous_0_statement">
        <source>Merge with previous '{0}' statement</source>
        <target state="translated">Sloučit s předchozím příkazem {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodMustReturnStreamThatSupportsReadAndSeek">
        <source>{0} must return a stream that supports read and seek operations.</source>
        <target state="translated">Metoda {0} musí vrátit stream, který podporuje operace čtení a hledání.</target>
        <note />
      </trans-unit>
      <trans-unit id="Missing_control_character">
        <source>Missing control character</source>
        <target state="translated">Chybí řídicí znak</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \c</note>
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_a_switch_expression_will_prevent_the_debug_session_from_continuing">
        <source>Modifying '{0}' which contains a switch expression will prevent the debug session from continuing.</source>
        <target state="translated">Pokud se změní {0} obsahující výraz switch, relace ladění nebude moct pokračovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_body_of_member_will_prevent_the_debug_session_from_continuing_because_the_body_has_too_many_statements">
        <source>Modifying the body of '{0}' will prevent the debug session from continuing because the body has too many statements.</source>
        <target state="translated">Když se upraví tělo funkce {0}, ladicí relace nebude moct pokračovat, protože tělo má příliš mnoho příkazů.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_body_of_member_will_prevent_the_debug_session_from_continuing_due_to_internal_error">
        <source>Modifying the body of '{0}' will prevent the debug session from continuing due to internal error: {1}</source>
        <target state="translated">Po změně těla funkce {0} nebude moct ladicí relace pokračovat z důvodu interní chyby: {1}</target>
        <note>{1} is a multi-line exception message including a stacktrace. Place it at the end of the message and don’t add any punctation after or around {1}</note>
      </trans-unit>
      <trans-unit id="Modifying_source_file_will_prevent_the_debug_session_from_continuing_because_the_file_is_too_big">
        <source>Modifying source file '{0}' will prevent the debug session from continuing because the file is too big.</source>
        <target state="translated">Když se upraví zdrojový soubor {0}, ladicí relace nebude moct pokračovat, protože soubor je příliš velký.</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_contents_to_namespace">
        <source>Move contents to namespace...</source>
        <target state="translated">Přesunout obsah do oboru názvů...</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_file_to_0">
        <source>Move file to '{0}'</source>
        <target state="translated">Přesunout soubor do: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_file_to_project_root_folder">
        <source>Move file to project root folder</source>
        <target state="translated">Přesunout soubor do kořenové složky projektu</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_to_namespace">
        <source>Move to namespace...</source>
        <target state="translated">Přesunout do oboru názvů...</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_source_file_will_prevent_the_debug_session_from_continuing_due_to_internal_error">
        <source>Modifying source file '{0}' will prevent the debug session from continuing due to internal error: {1}</source>
        <target state="translated">Když se upraví zdrojový soubor {0}, ladicí relace nebude moct pokračovat kvůli vnitřní chybě: {1}</target>
        <note>{1} is a multi-line exception message including a stacktrace. Place it at the end of the message and don’t add any punctation after or around {1}</note>
      </trans-unit>
      <trans-unit id="Nested_quantifier_0">
        <source>Nested quantifier {0}</source>
        <target state="translated">Vnořený kvantifikátor {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a**. In this case {0} will be '*', the extra unnecessary quantifier.</note>
      </trans-unit>
      <trans-unit id="No_valid_location_to_insert_method_call">
        <source>No valid location to insert method call.</source>
        <target state="translated">Není k dispozici žádné platné umístění, kam vložit volání metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="Not_enough_close_parens">
        <source>Not enough )'s</source>
        <target state="translated">Nedostatek znaků )</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (a</note>
      </trans-unit>
      <trans-unit id="Property_reference_cannot_be_updated">
        <source>Property reference cannot be updated</source>
        <target state="translated">Odkaz na vlastnost se nedá aktualizovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_0_up">
        <source>Pull '{0}' up</source>
        <target state="translated">Povýšit {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_0_up_to_1">
        <source>Pull '{0}' up to '{1}'</source>
        <target state="translated">Povýšit {0} na {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_members_up_to_base_type">
        <source>Pull members up to base type...</source>
        <target state="translated">Povýšit členy na základní typ...</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_members_up_to_new_base_class">
        <source>Pull member(s) up to new base class...</source>
        <target state="translated">Načíst členy do nové základní třídy...</target>
        <note />
      </trans-unit>
      <trans-unit id="Quantifier_x_y_following_nothing">
        <source>Quantifier {x,y} following nothing</source>
        <target state="translated">Před kvantifikátorem {x,y} není nic uvedeno.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: *</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group">
        <source>reference to undefined group</source>
        <target state="translated">odkaz na nedefinovanou skupinu</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(1))</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_name_0">
        <source>Reference to undefined group name {0}</source>
        <target state="translated">Odkaz na nedefinovaný název skupiny {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k&lt;a&gt;. Here, {0} will be the name of the undefined group ('a')</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_number_0">
        <source>Reference to undefined group number {0}</source>
        <target state="translated">Odkaz na nedefinované číslo skupiny {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;-1&gt;). Here, {0} will be the number of the undefined group ('1')</note>
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_long">
        <source>All control characters. This includes the Cc, Cf, Cs, Co, and Cn categories.</source>
        <target state="translated">Všechny řídicí znaky. Patří k nim kategorie Cc, Cf, Cs, Co a Cn.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_short">
        <source>all control characters</source>
        <target state="translated">všechny řídicí znaky</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_long">
        <source>All diacritic marks. This includes the Mn, Mc, and Me categories.</source>
        <target state="translated">Všechny značky diakritických znamének. Patří k nim kategorie Mn, Mc a Me.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_short">
        <source>all diacritic marks</source>
        <target state="translated">všechny značky diakritických znamének</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_long">
        <source>All letter characters. This includes the Lu, Ll, Lt, Lm, and Lo characters.</source>
        <target state="translated">Všechny znaky písmen. Patří k nim znaky Lu, Ll, Lt, Lm a Lo.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_short">
        <source>all letter characters</source>
        <target state="translated">všechny znaky písmen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_long">
        <source>All numbers. This includes the Nd, Nl, and No categories.</source>
        <target state="translated">Všechna čísla. Patří k nim kategorie Nd, Nl a No.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_short">
        <source>all numbers</source>
        <target state="translated">všechna čísla</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_long">
        <source>All punctuation characters. This includes the Pc, Pd, Ps, Pe, Pi, Pf, and Po categories.</source>
        <target state="translated">Všechny znaky interpunkce. Patří k nim kategorie Pc, Pd, Ps, Pe, Pi, Pf a Po.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_short">
        <source>all punctuation characters</source>
        <target state="translated">všechny znaky interpunkce</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_long">
        <source>All separator characters. This includes the Zs, Zl, and Zp categories.</source>
        <target state="translated">Všechny oddělovací znaky. Patří k nim kategorie Zs, Zl a Zp.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_short">
        <source>all separator characters</source>
        <target state="translated">všechny oddělovací znaky</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_long">
        <source>All symbols. This includes the Sm, Sc, Sk, and So categories.</source>
        <target state="translated">Všechny symboly. Patří k nim kategorie Sm, Sc, Sk a So.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_short">
        <source>all symbols</source>
        <target state="translated">všechny symboly</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_long">
        <source>You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.</source>
        <target state="translated">Můžete použít znak svislé čáry (|), pokud se má položka shodovat s libovolným vzorem z řady, ve které znak | odděluje jednotlivé vzory.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_short">
        <source>alternation</source>
        <target state="translated">alternace</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_long">
        <source>The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified by the 's' option, . matches any character.</source>
        <target state="translated">Znak tečky (.) odpovídá libovolnému znaku s výjimkou \n (znak nového řádku \u000A). Pokud je vzor regulárního výrazu modifikovaný možností RegexOptions.Singleline nebo pokud je část vzoru obsahující třídu znaků tečky modifikovaná parametrem s, pak znak tečky odpovídá libovolnému znaku.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_short">
        <source>any character</source>
        <target state="translated">libovolný znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_atomic_group_long">
        <source>Atomic groups (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression) disable backtracking. The regular expression engine will match as many characters in the input string as it can. When no further match is possible, it will not backtrack to attempt alternate pattern matches. (That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)

This option is recommended if you know that backtracking will not succeed. Preventing the regular expression engine from performing unnecessary searching improves performance.</source>
        <target state="translated">Atomové skupiny (označované v některých jiných modulech regulárních výrazů jako podvýrazy bez zpětného vyhledávání, atomické podvýrazy nebo jednorázové podvýrazy) zakazují zpětné vyhledávání. Modul regulárních výrazů najde shodu s co nejvíce znaky ve vstupním řetězci. Pokud se žádná další shoda nenajde, neprovede se zpětné vyhledávání za účelem pokusu o porovnávání alternativního vzoru. (To znamená, že dílčí výraz najde shodu jenom s řetězci, které by odpovídaly samotnému dílčímu výrazu. Nepokusí se porovnávat řetězec na základě dílčího výrazu a jakýchkoli dílčích výrazů, které následují.)

Tato možnost se doporučuje, pokud víte, že zpětné vyhledávání nepovede k úspěchu. Když zabráníte, aby modul regulárních výrazů prováděl zbytečná hledání, zlepší se výkon.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_atomic_group_short">
        <source>atomic group</source>
        <target state="translated">atomová skupina</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_long">
        <source>Matches a backspace character, \u0008</source>
        <target state="translated">Shoda se znakem Backspace \u0008</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_short">
        <source>backspace character</source>
        <target state="translated">znak Backspace</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_long">
        <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.
    
'name1' is the current group (optional), 'name2' is a previously defined group, and 'subexpression' is any valid regular expression pattern. The balancing group definition deletes the definition of name2 and stores the interval between name2 and name1 in name1. If no name2 group is defined, the match backtracks. Because deleting the last definition of name2 reveals the previous definition of name2, this construct lets you use the stack of captures for group name2 as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.

The balancing group definition uses 'name2' as a stack. The beginning character of each nested construct is placed in the group and in its Group.Captures collection. When the closing character is matched, its corresponding opening character is removed from the group, and the Captures collection is decreased by one. After the opening and closing characters of all nested constructs have been matched, 'name1' is empty.</source>
        <target state="translated">Definice vyrovnávací skupiny odstraní definici dříve definované skupiny a uloží interval mezi dříve definovanou skupinou a aktuální skupinou do aktuální skupiny.
    
Skupina name1 je aktuální skupina (volitelná), skupina name2 je dříve definovaná skupina a subexpression je libovolný platný vzor regulárního výrazu. Definice vyrovnávací skupiny odstraní definici skupiny name2 a uloží interval mezi skupinami name2 a name1 do skupiny name1. Pokud není definována žádná skupina name2, porovnávání se vrátí zpět. Vzhledem k tomu, že odstraněním poslední definice skupiny name2 se odkryje předchozí definice skupiny name2, umožňuje tento konstruktor použít zásobník zachycení pro skupinu name2 jako čítač pro uchování přehledu o vnořených konstruktorech, jako jsou kulaté nebo hranaté otevírací a uzavírací závorky.

Definice vyrovnávací skupiny používá jako zásobník skupinu name2. Počáteční znak každého vnořeného konstruktoru se umístí do této skupiny a do její kolekce Group.Captures. Po nalezení uzavíracího znaku se odpovídající otevírací znak odebere ze skupiny a kolekce Captures se zmenší o jednu položku. Po nalezení otevíracích a uzavíracích znaků všech vnořených konstruktorů bude skupina name1 prázdná.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_short">
        <source>balancing group</source>
        <target state="translated">vyrovnávací skupina</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_base_group">
        <source>base-group</source>
        <target state="translated">základní skupina</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_long">
        <source>Matches a bell (alarm) character, \u0007</source>
        <target state="translated">Shoda se znakem zvonku \u0007</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_short">
        <source>bell character</source>
        <target state="translated">znak zvonku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_long">
        <source>Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n.</source>
        <target state="translated">Shoda se znakem návratu na začátek řádku \u000D. Upozorňujeme, že \r není ekvivalentem znaku nového řádku \n.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_short">
        <source>carriage-return character</source>
        <target state="translated">znak návratu na začátek řádku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_long">
        <source>Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.

'base_group' is a positive or negative character group or range. The 'excluded_group' component is another positive or negative character group, or another character class subtraction expression (that is, you can nest character class subtraction expressions).</source>
        <target state="translated">Odčítání třídy znaků poskytuje sadu znaků, která je výsledkem vyloučení znaků v jedné třídě znaků z jiné třídy znaků.

Base_group je pozitivní nebo negativní skupina znaků nebo rozsah. Komponenta excluded_group je jiná pozitivní nebo negativní skupina znaků nebo jiný výraz odčítání třídy znaků (to znamená, že výrazy odčítání třídy znaků lze vnořovat).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_short">
        <source>character class subtraction</source>
        <target state="translated">odčítání třídy znaků</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_group">
        <source>character-group</source>
        <target state="translated">skupina znaků</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_comment">
        <source>comment</source>
        <target state="translated">komentář</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.

'expression' is the initial pattern to match, 'yes' is the pattern to match if expression is matched, and 'no' is the optional pattern to match if expression is not matched.</source>
        <target state="translated">Tento element jazyka se pokusí najít shodu s jedním ze dvou vzorů na základě toho, jestli se najde shoda s počátečním vzorem.

Expression je počáteční vzor, pro který se hledá shoda, yes je vzor, pro který se hledá shoda, pokud se pro expression najde shoda, a no je volitelný vzor, pro který se hledá shoda, pokud se pro expression nenajde shoda.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_short">
        <source>conditional expression match</source>
        <target state="translated">podmíněná shoda výrazu</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.

'name' is the name (or number) of a capturing group, 'yes' is the expression to match if 'name' (or 'number') has a match, and 'no' is the optional expression to match if it does not.</source>
        <target state="translated">Tento element jazyka se pokusí najít shodu s jedním ze dvou vzorů na základě toho, jestli se najde shoda se zadanou zachycující skupinou.

Name je název (nebo číslo) zachycující skupiny, yes je výraz, pro který se hledá shoda, pokud se daný název (nebo číslo) najde, a no je volitelný výraz, pro který se hledá shoda, pokud se tato položka nenajde.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_short">
        <source>conditional group match</source>
        <target state="translated">podmíněná shoda skupiny</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_long">
        <source>The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.</source>
        <target state="translated">Ukotvení \G určuje, že ke shodě musí dojít v místě, kde bylo předchozí porovnávání ukončeno. Pokud použijete toto ukotvení s metodou Regex.Matches nebo Match.NextMatch, zajistí se, že všechna porovnávání budou souvislá.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_short">
        <source>contiguous matches</source>
        <target state="translated">souvislá porovnávání</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_long">
        <source>Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C.</source>
        <target state="translated">Shoda s řídicím znakem ASCII, kde X je písmeno řídicího znaku. Například \cC je CTRL-C.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_short">
        <source>control character</source>
        <target state="translated">řídicí znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_long">
        <source>\d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.

If ECMAScript-compliant behavior is specified, \d is equivalent to [0-9]</source>
        <target state="translated">\d odpovídá libovolné desítkové číslici. Jde o ekvivalent vzoru regulárního výrazu \p{Nd}, který zahrnuje standardní desítkové číslice 0–9 a také desítkové číslice některých jiných znakových sad.

Pokud je zadané chování kompatibilní s ECMAScriptem, je \d ekvivalentem [0-9].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_short">
        <source>decimal-digit character</source>
        <target state="translated">znak desítkové číslice</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_long">
        <source>A number sign (#) marks an x-mode comment, which starts at the unescaped # character at the end of the regular expression pattern and continues until the end of the line. To use this construct, you must either enable the x option (through inline options) or supply the RegexOptions.IgnorePatternWhitespace value to the option parameter when instantiating the Regex object or calling a static Regex method.</source>
        <target state="translated">Symbol čísla (#) označuje komentář v režimu X, který začíná znakem #, který není řídicím znakem, na konci vzoru regulárního výrazu a pokračuje do konce řádku. Pokud chcete použít tento konstruktor, musíte buď povolit možnost x (prostřednictvím vložených možností), nebo při vytváření instance objektu Regex nebo volání statické metody Regex zadat pro parametr možnosti hodnotu RegexOptions.IgnorePatternWhitespace.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_short">
        <source>end-of-line comment</source>
        <target state="translated">komentář na konci řádku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_long">
        <source>The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, it can only match the last line of the input string.</source>
        <target state="translated">Ukotvení \z určuje, že ke shodě musí dojít na konci vstupního řetězce. Podobně jako element jazyka $ i \z ignoruje možnost RegexOptions.Multiline. Na rozdíl od elementu jazyka \Z nenajde \z shodu se znakem \n na konci řetězce. Proto může hledat shodu jenom v posledním řádku vstupního řetězce.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_short">
        <source>end of string only</source>
        <target state="translated">jen konec řetězce</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_long">
        <source>The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can only match the end of the last line, or the last line before \n.

The \Z anchor matches \n but does not match \r\n (the CR/LF character combination). To match CR/LF, include \r?\Z in the regular expression pattern.</source>
        <target state="translated">Ukotvení \Z určuje, že ke shodě musí dojít na konci vstupního řetězce nebo před \n na konci vstupního řetězce. Je identické s ukotvením $, kromě toho, že \Z ignoruje možnost RegexOptions.Multiline. Proto ve víceřádkovém řetězci může najít shodu jenom na konci posledního řádku nebo v posledním řádku před \n.

Ukotvení \Z najde shodu s \n, ale nenajde shodu s \r\n (kombinace znaků CR/LF). Pokud chcete hledat znaky CR/LF, zadejte do vzoru regulárního výrazu \r?\Z.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_short">
        <source>end of string or before ending newline</source>
        <target state="translated">konec řetězce nebo před koncem nového řádku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_long">
        <source>The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string. If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line.

The $ anchor matches \n but does not match \r\n (the combination of carriage return and newline characters, or CR/LF). To match the CR/LF character combination, include \r?$ in the regular expression pattern.</source>
        <target state="translated">Ukotvení $ určuje, že se předchozí vzor musí vyskytovat na konci vstupního řetězce nebo před \n na konci vstupního řetězce. Pokud použijete $ s možností RegexOptions.Multiline, může ke shodě dojít i na konci řádku.

Ukotvení $ najde shodu s \n, ale nenajde shodu s \r\n (kombinace znaků návratu na začátek řádku a nového řádku, tedy znaků CR/LF). Pokud chcete hledat kombinaci znaků CR/LF, zadejte do vzoru regulárního výrazu \r?$.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_short">
        <source>end of string or line</source>
        <target state="translated">konec řetězce nebo řádku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_long">
        <source>Matches an escape character, \u001B</source>
        <target state="translated">Shoda s řídicím znakem \u001B</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_short">
        <source>escape character</source>
        <target state="translated">řídicí znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_excluded_group">
        <source>excluded-group</source>
        <target state="translated">vyloučená skupina</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_expression">
        <source>expression</source>
        <target state="translated">výraz</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_long">
        <source>Matches a form-feed character, \u000C</source>
        <target state="translated">Shoda se znakem pro novou stránku \u000C</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_short">
        <source>form-feed character</source>
        <target state="translated">znak pro novou stránku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_long">
        <source>This grouping construct applies or disables the specified options within a subexpression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly
	named or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">Tento seskupovací konstruktor povoluje nebo zakazuje možnosti zadané v rámci výrazu subexpression. Možnosti, které se povolují, se zadávají za otazník a možnosti, které se zakazují, za symbol minus. Povolené možnosti:

    i	Použije se porovnávání bez rozlišování malých a velkých písmen.
    m	Použije se víceřádkový režim, kde ^ a $ odpovídají začátku a konci každého řádku
	(místo začátku a konce vstupního řetězce).
    s	Použije se jednořádkový režim, kde tečka (.) odpovídá každému znaku
	(místo každému znaku kromě \n).
    n	Nezachytává nepojmenované skupiny. Jediná platná zachycení představují explicitně
	pojmenované nebo číslované skupiny formuláře (? &lt;name&gt; subexpression).
    x	Vyloučí ze vzoru prázdné znaky, které nejsou řídicími znaky, a povolí komentáře
	za symbolem čísla (#).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_short">
        <source>group options</source>
        <target state="translated">seskupovací možnosti</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_long">
        <source>Matches an ASCII character, where ## is a two-digit hexadecimal character code.</source>
        <target state="translated">Shoda se znakem ASCII, kde ## je dvouciferný šestnáctkový kód znaku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_short">
        <source>hexadecimal escape</source>
        <target state="translated">šestnáctkový únikový znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_long">
        <source>The (?# comment) construct lets you include an inline comment in a regular expression. The regular expression engine does not use any part of the comment in pattern matching, although the comment is included in the string that is returned by the Regex.ToString method. The comment ends at the first closing parenthesis.</source>
        <target state="translated">Konstruktor (?# komentář) umožňuje zahrnout vložený komentář do regulárního výrazu. Modul regulárních výrazů nepoužije při porovnávání vzorů žádnou část komentáře, i když je komentář obsažený v řetězci, který vrací metoda Regex.ToString. Komentář končí první uzavírací závorkou.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_short">
        <source>inline comment</source>
        <target state="translated">vložený komentář</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_long">
        <source>Enables or disables specific pattern matching options for the remainder of a regular expression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly named
	or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">Povoluje nebo zakazuje specifické možnosti pro porovnávání vzorů pro zbytek regulárního výrazu. Možnosti, které se povolují, se zadávají za otazník a možnosti, které se zakazují, za symbol minus. Povolené možnosti:

    i	Použije se porovnávání bez rozlišování malých a velkých písmen.
    m	Použije se víceřádkový režim, kde ^ a $ odpovídají začátku a konci každého řádku
	(místo začátku a konce vstupního řetězce).
    s	Použije se jednořádkový režim, kde tečka (.) odpovídá každému znaku
	(místo každému znaku kromě \n).
    n	Nezachytává nepojmenované skupiny. Jediná platná zachycení představují explicitně
	pojmenované nebo číslované skupiny formuláře (? &lt;name&gt; subexpression).
    x	Vyloučí ze vzoru prázdné znaky, které nejsou řídicími znaky, a povolí komentáře
	za symbolem čísla (#).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_short">
        <source>inline options</source>
        <target state="translated">vložené možnosti</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_issue_0">
        <source>Regex issue: {0}</source>
        <target state="translated">Problém s regulárním výrazem: {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. {0} will be the actual text of one of the above Regular Expression errors.</note>
      </trans-unit>
      <trans-unit id="Regex_letter_lowercase">
        <source>letter, lowercase</source>
        <target state="translated">písmeno, malá písmena</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_modifier">
        <source>letter, modifier</source>
        <target state="translated">písmeno, modifikátor</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_other">
        <source>letter, other</source>
        <target state="translated">písmeno, jiné</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_titlecase">
        <source>letter, titlecase</source>
        <target state="translated">písmeno, velká počáteční písmena</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_uppercase">
        <source>letter, uppercase</source>
        <target state="translated">písmeno, velká písmena</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_enclosing">
        <source>mark, enclosing</source>
        <target state="translated">značka, uzavření</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_nonspacing">
        <source>mark, nonspacing</source>
        <target state="translated">značka, bez mezer</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_spacing_combining">
        <source>mark, spacing combining</source>
        <target state="translated">značka, kombinování mezer</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_long">
        <source>The {n,}? quantifier matches the preceding element at least n times, where n is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,}</source>
        <target state="translated">Kvantifikátor {n,}? najde shodu předchozího elementu nejméně n-krát, kde n je celé číslo, ale co nejméněkrát. Jedná se o líný protějšek hladového kvantifikátoru {n,}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">shoda nejméně n-krát (líný režim)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_long">
        <source>The {n,} quantifier matches the preceding element at least n times, where n is any integer. {n,} is a greedy quantifier whose lazy equivalent is {n,}?</source>
        <target state="translated">Kvantifikátor {n,} najde shodu předchozího elementu nejméně n-krát, kde n je celé číslo. {n,} je hladový kvantifikátor, jehož líným ekvivalentem je {n,}?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_short">
        <source>match at least 'n' times</source>
        <target state="translated">shoda nejméně n-krát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_long">
        <source>The {n,m}? quantifier matches the preceding element between n and m times, where n and m are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,m}</source>
        <target state="translated">Kvantifikátor {n,m}? najde shodu předchozího elementu v rozmezí n-krát a m-krát, kde n a m jsou celá čísla, ale co nejméněkrát. Jedná se o líný protějšek hladového kvantifikátoru {n,m}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">shoda nejméně n-krát (líný režim)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_long">
        <source>The {n,m} quantifier matches the preceding element at least n times, but no more than m times, where n and m are integers. {n,m} is a greedy quantifier whose lazy equivalent is {n,m}?</source>
        <target state="translated">Kvantifikátor {n,m} najde shodu předchozího elementu nejméně n-krát, ale nejvíce m-krát, kde n a m jsou celá čísla. {n,m} je hladový kvantifikátor, jehož líným ekvivalentem je {n,m}?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_short">
        <source>match between 'm' and 'n' times</source>
        <target state="translated">shoda v rozmezí m-krát a n-krát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_long">
        <source>The {n}? quantifier matches the preceding element exactly n times, where n is any integer. It is the lazy counterpart of the greedy quantifier {n}+</source>
        <target state="translated">Kvantifikátor {n}? najde shodu předchozího elementu přesně n-krát, kde n je celé číslo. Jedná se o líný protějšek hladového kvantifikátoru {n}+.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_short">
        <source>match exactly 'n' times (lazy)</source>
        <target state="translated">shoda přesně n-krát (líný režim)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_long">
        <source>The {n} quantifier matches the preceding element exactly n times, where n is any integer. {n} is a greedy quantifier whose lazy equivalent is {n}?</source>
        <target state="translated">Kvantifikátor {n} najde shodu předchozího elementu přesně n-krát, kde n je libovolné celé číslo. {n} je hladový kvantifikátor, jehož líným ekvivalentem je {n}?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_short">
        <source>match exactly 'n' times</source>
        <target state="translated">shoda přesně n-krát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_long">
        <source>The +? quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier +</source>
        <target state="translated">Kvantifikátor +? najde shodu předchozího elementu 1krát nebo vícekrát, ale co nejméněkrát. Jedná se o líný protějšek hladového kvantifikátoru +.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_short">
        <source>match one or more times (lazy)</source>
        <target state="translated">shoda 1krát nebo vícekrát (líný režim)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_long">
        <source>The + quantifier matches the preceding element one or more times. It is equivalent to the {1,} quantifier. + is a greedy quantifier whose lazy equivalent is +?.</source>
        <target state="translated">Kvantifikátor + najde shodu předchozího elementu 1krát nebo vícekrát. Jedná se o ekvivalent kvantifikátoru {1,}. + je hladový kvantifikátor, jehož líným ekvivalentem je +?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_short">
        <source>match one or more times</source>
        <target state="translated">shoda 1krát nebo vícekrát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_long">
        <source>The *? quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier *</source>
        <target state="translated">Kvantifikátor *? najde shodu předchozího elementu 0krát nebo vícekrát, ale co nejméněkrát. Jedná se o líný protějšek hladového kvantifikátoru *.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_short">
        <source>match zero or more times (lazy)</source>
        <target state="translated">shoda 0krát nebo vícekrát (líný režim)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_long">
        <source>The * quantifier matches the preceding element zero or more times. It is equivalent to the {0,} quantifier. * is a greedy quantifier whose lazy equivalent is *?.</source>
        <target state="translated">Kvantifikátor * najde shodu předchozího elementu 0krát nebo vícekrát. Jedná se o ekvivalent kvantifikátoru {0,}. * je hladový kvantifikátor, jehož líným ekvivalentem je *?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_short">
        <source>match zero or more times</source>
        <target state="translated">shoda 0krát nebo vícekrát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_long">
        <source>The ?? quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier ?</source>
        <target state="translated">Kvantifikátor ?? najde shodu předchozího elementu 0krát nebo 1krát, ale co nejméněkrát. Jedná se o líný protějšek hladového kvantifikátoru ?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_short">
        <source>match zero or one time (lazy)</source>
        <target state="translated">shoda 0krát nebo 1krát (líný režim)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_long">
        <source>The ? quantifier matches the preceding element zero or one time. It is equivalent to the {0,1} quantifier. ? is a greedy quantifier whose lazy equivalent is ??.</source>
        <target state="translated">Kvantifikátor ? najde shodu předchozího elementu 0krát nebo 1krát. Jedná se o ekvivalent kvantifikátoru {0,1}. ? je hladový kvantifikátor, jehož líným ekvivalentem je ??.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_short">
        <source>match zero or one time</source>
        <target state="translated">shoda 0krát nebo 1krát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_long">
        <source>This grouping construct captures a matched 'subexpression', where 'subexpression' is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one. The capture that is numbered zero is the text matched by the entire regular expression pattern.</source>
        <target state="translated">Tento seskupovací konstruktor zachytává porovnávaný dílčí výraz, kde dílčí výraz je libovolný platný vzor regulárního výrazu. Zachycení, která používají závorky, jsou automaticky číslována zleva doprava podle pořadí otevíracích závorek v regulárním výrazu, počínaje od hodnoty jedna. Zachycení s číslem nula je text odpovídající celému vzoru regulárního výrazu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_short">
        <source>matched subexpression</source>
        <target state="translated">porovnávaný dílčí výraz</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name">
        <source>name</source>
        <target state="translated">název</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name1">
        <source>name1</source>
        <target state="translated">name1</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name2">
        <source>name2</source>
        <target state="translated">name2</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name_or_number">
        <source>name-or-number</source>
        <target state="translated">název nebo číslo</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_long">
        <source>A named or numbered backreference.

'name' is the name of a capturing group defined in the regular expression pattern.</source>
        <target state="translated">Pojmenovaná nebo číslovaná zpětná reference.

Název představuje název zachycující skupiny definované ve vzoru regulárního výrazu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_short">
        <source>named backreference</source>
        <target state="translated">pojmenovaná zpětná reference</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_long">
        <source>Captures a matched subexpression and lets you access it by name or by number.

'name' is a valid group name, and 'subexpression' is any valid regular expression pattern. 'name' must not contain any punctuation characters and cannot begin with a number.

If the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the only way to capture a subexpression is to explicitly name capturing groups.</source>
        <target state="translated">Zachytává porovnávaný dílčí výraz a umožňuje k němu přístup pomocí názvu nebo čísla.

Název je platný název skupiny a dílčí výraz je libovolný platný vzor regulárního výrazu. Název nesmí obsahovat znaky interpunkce a nesmí začínat číslicí.

Pokud parametr RegexOptions metody odpovídající vzoru regulárního výrazu obsahuje příznak RegexOptions.ExplicitCapture nebo pokud je u daného dílčího výrazu použitá možnost n, je jediným způsobem, jak zachytit dílčí výraz, explicitní pojmenování zachycujících skupin.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_short">
        <source>named matched subexpression</source>
        <target state="translated">pojmenovaný porovnávaný dílčí výraz</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_long">
        <source>A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters are specified individually.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">Negativní skupina znaků určuje seznam znaků, které se nesmí vyskytovat ve vstupním řetězci, aby došlo ke shodě. Seznam znaků se zadává jednotlivě.

Je možné zřetězit dva nebo více rozsahů znaků. Pokud chcete například zadat rozsah desítkových číslic od 0 do 9, rozsah malých písmen od a do f a rozsah velkých písmen od A do F, použijte [0-9A-fA-F].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_short">
        <source>negative character group</source>
        <target state="translated">negativní skupina znaků</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_range_long">
        <source>A negative character range specifies a list of characters that must not appear in an input string for a match to occur. 'firstCharacter' is the character that begins the range, and 'lastCharacter' is the character that ends the range.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">Negativní rozsah znaků určuje seznam znaků, které se nesmí vyskytovat ve vstupním řetězci, aby došlo ke shodě. firstCharacter je znak, kterým rozsah začíná, a lastCharacter je znak, kterým rozsah končí.

Je možné zřetězit dva nebo více rozsahů znaků. Pokud chcete například zadat rozsah desítkových číslic od 0 do 9, rozsah malých písmen od a do f a rozsah velkých písmen od A do F, použijte [0-9A-fA-F].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_range_short">
        <source>negative character range</source>
        <target state="translated">negativní rozsah znaků</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_long">
        <source>The regular expression construct \P{ name } matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">Konstruktor regulárního výrazu \P{ name } odpovídá libovolnému znaku, který nepatří do obecné kategorie Unicode nebo pojmenovaného bloku, kde name je zkratka pro kategorii nebo název pojmenovaného bloku.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_short">
        <source>negative unicode category</source>
        <target state="translated">negativní kategorie Unicode</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_long">
        <source>Matches a new-line character, \u000A</source>
        <target state="translated">Shoda se znakem pro nový řádek \u000A</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_short">
        <source>new-line character</source>
        <target state="translated">znak pro nový řádek</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_no">
        <source>no</source>
        <target state="translated">ne</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_long">
        <source>\D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.

If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9]</source>
        <target state="translated">\D odpovídá libovolnému nečíselnému znaku. Je ekvivalentem vzoru regulárního výrazu \P{Nd}.

Pokud je zadané chování kompatibilní s ECMAScriptem, je \D ekvivalentem [^0-9].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_short">
        <source>non-digit character</source>
        <target state="translated">nečíselný znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_long">
        <source>\S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.

If ECMAScript-compliant behavior is specified, \S is equivalent to [^ \f\n\r\t\v]</source>
        <target state="translated">\S odpovídá libovolnému neprázdnému znaku. Je ekvivalentem vzoru regulárního výrazu [^\f\n\r\t\v\x85\p{Z}] nebo opakem vzoru regulárního výrazu, který je ekvivalentem \s, který najde prázdné znaky.

Pokud je zadané chování kompatibilní s ECMAScriptem, je \S ekvivalentem [^ \f\n\r\t\v].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_short">
        <source>non-white-space character</source>
        <target state="translated">neprázdný znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_long">
        <source>The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor.</source>
        <target state="translated">Ukotvení \B určuje, že shoda se nesmí vyskytovat na hranici slova. Jedná se o opak ukotvení \b.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_short">
        <source>non-word boundary</source>
        <target state="translated">mimo hranici slova</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_character_long">
        <source>\W matches any non-word character. It matches any character except for those in the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \W is equivalent to [^a-zA-Z_0-9]</source>
        <target state="translated">\W odpovídá jakémukoli znaku, který není znakem slova. Odpovídá libovolnému znaku s výjimkou znaků v následujících kategoriích Unicode:

    Ll	písmeno, malá písmena
    Lu	písmeno, velká písmena
    Lt	písmeno, velká počáteční písmena
    Lo	písmeno, jiné
    Lm	písmeno, modifikátor
    Mn	značka, bez mezer
    Nd	číslo, desítkové číslo
    Pc	interpunkce, spojovník

Pokud je zadané chování kompatibilní s ECMAScriptem, je \W ekvivalentem [^a-zA-Z_0-9].</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized. </note>
      </trans-unit>
      <trans-unit id="Regex_non_word_character_short">
        <source>non-word character</source>
        <target state="translated">znak, který není znakem slova</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_long">
        <source>This construct does not capture the substring that is matched by a subexpression:

The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.

If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
        <target state="translated">Tento konstruktor nezachycuje dílčí řetězec, který odpovídá dílčímu výrazu:

Konstruktor nezachycující skupiny se obvykle používá, když se kvantifikátor aplikuje pro skupinu, ale dílčí řetězce zachycené skupinou uživatele nezajímají.

Pokud regulární výraz obsahuje vnořené seskupovací konstruktory, vnější konstruktor nezachycující skupiny se neaplikuje na vnitřní vnořené konstruktory skupiny.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_short">
        <source>noncapturing group</source>
        <target state="translated">nezachycující skupina</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_decimal_digit">
        <source>number, decimal digit</source>
        <target state="translated">číslo, desítkové číslo</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_letter">
        <source>number, letter</source>
        <target state="translated">číslo, písmeno</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_other">
        <source>number, other</source>
        <target state="translated">číslo, jiné</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_long">
        <source>A numbered backreference, where 'number' is the ordinal position of the capturing group in the regular expression. For example, \4 matches the contents of the fourth capturing group.

There is an ambiguity between octal escape codes (such as \16) and \number backreferences that use the same notation. If the ambiguity is a problem, you can use the \k&lt;name&gt; notation, which is unambiguous and cannot be confused with octal character codes. Similarly, hexadecimal codes such as \xdd are unambiguous and cannot be confused with backreferences.</source>
        <target state="translated">Číslovaná zpětná reference, kde číslo je pořadové umístění zachycující skupiny v regulárním výrazu. Například \4 odpovídá obsahu čtvrté zachycující skupiny.

Existuje nejednoznačnost mezi osmičkovými řídicími kódy (například \16) a zpětnými referencemi \číslo, které používají stejný zápis. Pokud nejednoznačnost způsobuje potíže, můžete použít zápis \k&lt;name&gt;, který je jednoznačný a nedá se zaměnit s osmičkovými kódy znaků. Stejně tak šestnáctkové kódy, například \xdd, jsou jednoznačné a nedají se zaměnit se zpětnými referencemi.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_short">
        <source>numbered backreference</source>
        <target state="translated">číslovaná zpětná reference</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_control">
        <source>other, control</source>
        <target state="translated">jiné, řídicí</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_format">
        <source>other, format</source>
        <target state="translated">jiné, formát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_not_assigned">
        <source>other, not assigned</source>
        <target state="translated">jiné, nepřiřazeno</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_private_use">
        <source>other, private use</source>
        <target state="translated">jiné, privátní použití</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_surrogate">
        <source>other, surrogate</source>
        <target state="translated">jiné, náhradní</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_long">
        <source>A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur.</source>
        <target state="translated">Pozitivní skupina znaků určuje seznam znaků, z nichž kterýkoli se může objevit ve vstupním řetězci, aby došlo ke shodě.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_short">
        <source>positive character group</source>
        <target state="translated">pozitivní skupina znaků</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_long">
        <source>A positive character range specifies a range of characters, any one of which may appear in an input string for a match to occur.  'firstCharacter' is the character that begins the range and 'lastCharacter' is the character that ends the range. </source>
        <target state="translated">Pozitivní rozsah znaků určuje rozsah znaků, z nichž kterýkoli se může objevit ve vstupním řetězci, aby došlo ke shodě. firstCharacter je znak, kterým rozsah začíná, a lastCharacter je znak, kterým rozsah končí.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_short">
        <source>positive character range</source>
        <target state="translated">pozitivní rozsah znaků</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_close">
        <source>punctuation, close</source>
        <target state="translated">interpunkce, uzavření</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_connector">
        <source>punctuation, connector</source>
        <target state="translated">interpunkce, spojovník</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_dash">
        <source>punctuation, dash</source>
        <target state="translated">interpunkce, pomlčka</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_final_quote">
        <source>punctuation, final quote</source>
        <target state="translated">interpunkce, koncová uvozovka</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_initial_quote">
        <source>punctuation, initial quote</source>
        <target state="translated">interpunkce, počáteční uvozovka</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_open">
        <source>punctuation, open</source>
        <target state="translated">interpunkce, otevření</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_other">
        <source>punctuation, other</source>
        <target state="translated">interpunkce, jiné</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_line">
        <source>separator, line</source>
        <target state="translated">oddělovač, čára</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_paragraph">
        <source>separator, paragraph</source>
        <target state="translated">oddělovač, odstavec</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_space">
        <source>separator, space</source>
        <target state="translated">oddělovač, mezera</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_long">
        <source>The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input string.</source>
        <target state="translated">Ukotvení \A určuje, že ke shodě musí dojít na začátku vstupního řetězce. Je identické s ukotvením ^, kromě toho, že \A ignoruje možnost RegexOptions.Multiline. Proto může hledat shodu jenom na začátku prvního řádku ve víceřádkovém vstupním řetězci.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_short">
        <source>start of string only</source>
        <target state="translated">jen začátek řetězce</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_long">
        <source>The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.</source>
        <target state="translated">Ukotvení ^ určuje, že následující vzor musí začínat na pozici prvního znaku řetězce. Pokud použijete ^ s možností RegexOptions.Multiline, musí ke shodě dojít na začátku každého řádku.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_short">
        <source>start of string or line</source>
        <target state="translated">začátek řetězce nebo řádku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_subexpression">
        <source>subexpression</source>
        <target state="translated">dílčí výraz</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_currency">
        <source>symbol, currency</source>
        <target state="translated">symbol, měna</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_math">
        <source>symbol, math</source>
        <target state="translated">symbol, matematický</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_modifier">
        <source>symbol, modifier</source>
        <target state="translated">symbol, modifikátor</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_other">
        <source>symbol, other</source>
        <target state="translated">symbol, jiné</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_long">
        <source>Matches a tab character, \u0009</source>
        <target state="translated">Shoda se znakem tabulátoru \u0009</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_short">
        <source>tab character</source>
        <target state="translated">znak tabulátoru</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_long">
        <source>The regular expression construct \p{ name } matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">Konstruktor regulárního výrazu \p{ name } odpovídá libovolnému znaku, který patří do obecné kategorie Unicode nebo pojmenovaného bloku, kde name je zkratka pro kategorii nebo název pojmenovaného bloku.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_short">
        <source>unicode category</source>
        <target state="translated">kategorie Unicode</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_long">
        <source>Matches a UTF-16 code unit whose value is #### hexadecimal.</source>
        <target state="translated">Shoda s jednotkou kódu UTF-16, jejíž šestnáctková hodnota je ####</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_short">
        <source>unicode escape</source>
        <target state="translated">řídicí znak Unicode</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_general_category_0">
        <source>Unicode General Category: {0}</source>
        <target state="translated">Obecná kategorie Unicode: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_long">
        <source>Matches a vertical-tab character, \u000B</source>
        <target state="translated">Shoda se znakem svislého tabulátoru \u000B</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_short">
        <source>vertical-tab character</source>
        <target state="translated">znak svislého tabulátoru</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_long">
        <source>\s matches any white-space character. It is equivalent to the following escape sequences and Unicode categories:

    \f	The form feed character, \u000C
    \n	The newline character, \u000A
    \r	The carriage return character, \u000D
    \t	The tab character, \u0009
    \v	The vertical tab character, \u000B
    \x85	The ellipsis or NEXT LINE (NEL) character (…), \u0085
    \p{Z}	Matches any separator character

If ECMAScript-compliant behavior is specified, \s is equivalent to [ \f\n\r\t\v]</source>
        <target state="translated">\s odpovídá jakémukoli prázdnému znaku. Je ekvivalentem následujících řídicích sekvencí a kategorií Unicode:

    \f	znak pro novou stránku \u000C
    \n	znak nového řádku \u000A
    \r	znak návratu na začátek řádku \u000D
    \t	znak tabulátoru \u0009
    \v	znak svislého tabulátoru \u000B
    \x85	znak tří teček nebo dalšího řádku (...) \u0085
    \p{Z}	shoda s libovolným znakem oddělovače

Pokud je zadané chování kompatibilní s ECMAScriptem, je \s ekvivalentem [ \f\n\r\t\v].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_short">
        <source>white-space character</source>
        <target state="translated">prázdný znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_long">
        <source>The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore. The match may also occur on a word boundary at the beginning or end of the string.

The \b anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
        <target state="translated">Ukotvení \b určuje, že ke shodě musí dojít na hranici mezi znakem slova (element jazyka \w) a znakem, který není znakem slova (element jazyka \W). Mezi znaky slova patří alfanumerické znaky a podtržítka. Znak, který není znakem slova, je jakýkoli znak, který není alfanumerický ani podtržítko. Ke shodě může dojít i na hranici slova na začátku nebo na konci řetězce.

Ukotvení \b se často používá k ověření, že dílčí výraz odpovídá celému slovu, nikoli jenom začátku nebo konci slova.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_short">
        <source>word boundary</source>
        <target state="translated">hranice slova</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_character_long">
        <source>\w matches any word character. A word character is a member of any of the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \w is equivalent to [a-zA-Z_0-9]</source>
        <target state="translated">\w odpovídá jakémukoli znaku slova. Znak slova je členem libovolné z následujících kategorií Unicode:

    Ll	písmeno, malá písmena
    Lu	písmeno, velká písmena
    Lt	písmeno, velká počáteční písmena
    Lo	písmeno, jiné
    Lm	písmeno, modifikátor
    Mn	značka, bez mezer
    Nd	číslo, desítkové číslo
    Pc	interpunkce, spojovník

Pokud je zadané chování kompatibilní s ECMAScriptem, je \w ekvivalentem [a-zA-Z_0-9].</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized.</note>
      </trans-unit>
      <trans-unit id="Regex_word_character_short">
        <source>word character</source>
        <target state="translated">znak slova</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_yes">
        <source>yes</source>
        <target state="translated">ano</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_long">
        <source>A zero-width negative lookahead assertion, where for the match to be successful, the input string must not match the regular expression pattern in subexpression. The matched string is not included in the match result.

A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression. At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched. In this case, it is often used to limit backtracking. At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
        <target state="translated">Negativní kontrolní výraz dopředného vyhledávání s nulovou délkou, při kterém úspěšná shoda nastane v případě, že vstupní řetězec neodpovídá vzoru regulárního výrazu v dílčím výrazu. Hledaný řetězec se do výsledku porovnávání nezahrnuje.

Negativní kontrolní výraz dopředného vyhledávání s nulovou délkou se obvykle používá na začátku nebo na konci regulárního výrazu. Na začátku regulárního výrazu může definovat konkrétní vzor, který by se neměl shodovat, pokud začátek regulárního výrazu definuje podobný, ale obecnější vzor, který se má shodovat. V tomto případě se často používá k omezení zpětného vyhledávání. Na konci regulárního výrazu může definovat dílčí výraz, který se nesmí vyskytovat na konci hledaného řetězce.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_short">
        <source>zero-width negative lookahead assertion</source>
        <target state="translated">negativní kontrolní výraz dopředného vyhledávání s nulovou délkou</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_long">
        <source>A zero-width negative lookbehind assertion, where for a match to be successful, 'subexpression' must not occur at the input string to the left of the current position. Any substring that does not match 'subexpression' is not included in the match result.

Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define precludes a match in the string that follows. They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</source>
        <target state="translated">Negativní kontrolní výraz zpětného vyhledávání s nulovou délkou, při kterém úspěšná shoda nastane v případě, že se dílčí výraz nenachází ve vstupním řetězci nalevo od aktuální pozice. Dílčí řetězce, které neodpovídají dílčímu výrazu, se do výsledku porovnávání nezahrnují.

Negativní kontrolní výrazy zpětného vyhledávání s nulovou délkou se obvykle používají na začátku regulárních výrazů. Vzor, který definují, vylučuje shodu v řetězci, který následuje. Používají se také k omezení zpětného vyhledávání, pokud poslední znak nebo znaky v zachycující skupině nesmí představovat jeden nebo více znaků, které odpovídají vzoru regulárního výrazu dané skupiny.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_short">
        <source>zero-width negative lookbehind assertion</source>
        <target state="translated">negativní kontrolní výraz zpětného vyhledávání s nulovou délkou</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_long">
        <source>A zero-width positive lookahead assertion, where for a match to be successful, the input string must match the regular expression pattern in 'subexpression'. The matched substring is not included in the match result. A zero-width positive lookahead assertion does not backtrack.

Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern. It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match. It is also useful for preventing excessive backtracking. You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</source>
        <target state="translated">Pozitivní kontrolní výraz dopředného vyhledávání s nulovou délkou, při kterém úspěšná shoda nastane v případě, že vstupní řetězec odpovídá vzoru regulárního výrazu v dílčím výrazu. Odpovídající dílčí řetězec se do výsledku porovnávání nezahrnuje. Pozitivní kontrolní výraz dopředného vyhledávání s nulovou délkou neprovádí zpětné vyhledávání.

Pozitivní kontrolní výraz dopředného vyhledávání s nulovou délkou se obvykle nachází na konci vzoru regulárního výrazu. Definuje dílčí řetězec, který musí být nalezen na konci řetězce, aby došlo ke shodě, ale který by shoda neměla zahrnovat. Je také užitečný k zabránění nadměrnému zpětnému vyhledávání. Pomocí pozitivního kontrolního výrazu dopředného vyhledávání s nulovou délkou můžete zajistit, aby určitá zachycující skupina začínala textem, který odpovídá podmnožině vzoru definovaného pro danou zachycující skupinu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_short">
        <source>zero-width positive lookahead assertion</source>
        <target state="translated">pozitivní kontrolní výraz dopředného vyhledávání s nulovou délkou</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_long">
        <source>A zero-width positive lookbehind assertion, where for a match to be successful, 'subexpression' must occur at the input string to the left of the current position. 'subexpression' is not included in the match result. A zero-width positive lookbehind assertion does not backtrack.

Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
        <target state="translated">Pozitivní kontrolní výraz zpětného vyhledávání s nulovou délkou, při kterém úspěšná shoda nastane v případě, že se dílčí výraz nachází ve vstupním řetězci nalevo od aktuální pozice. Dílčí výraz se do výsledku porovnávání nezahrnuje. Pozitivní kontrolní výraz zpětného vyhledávání s nulovou délkou neprovádí zpětné navracení.

Pozitivní kontrolní výrazy zpětného vyhledávání s nulovou délkou se obvykle používají na začátku regulárních výrazů. Vzor, který definují, je podmínkou pro shodu, i když není součástí výsledku porovnávání.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_short">
        <source>zero-width positive lookbehind assertion</source>
        <target state="translated">pozitivní kontrolní výraz zpětného vyhledávání s nulovou délkou</target>
        <note />
      </trans-unit>
      <trans-unit id="Related_method_signatures_found_in_metadata_will_not_be_updated">
        <source>Related method signatures found in metadata will not be updated.</source>
        <target state="translated">Podpisy souvisejících metod nalezené v metadatech se nebudou aktualizovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removal_of_document_not_supported">
        <source>Removal of document not supported</source>
        <target state="translated">Odebrání dokumentu se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_async_modifier">
        <source>Remove 'async' modifier</source>
        <target state="translated">Odebrat modifikátor async</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_1">
        <source>Replace '{0}' with '{1}' </source>
        <target state="translated">Místo {0} použijte {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Resolve_conflict_markers">
        <source>Resolve conflict markers</source>
        <target state="translated">Vyřešit značky konfliktů</target>
        <note />
      </trans-unit>
      <trans-unit id="RudeEdit">
        <source>Rude edit</source>
        <target state="translated">Hrubá úprava</target>
        <note />
      </trans-unit>
      <trans-unit id="Split_into_consecutive_0_statements">
        <source>Split into consecutive '{0}' statements</source>
        <target state="translated">Rozdělit do následných příkazů {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Split_into_nested_0_statements">
        <source>Split into nested '{0}' statements</source>
        <target state="translated">Rozdělit do vnořených příkazů {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamMustSupportReadAndSeek">
        <source>Stream must support read and seek operations.</source>
        <target state="translated">Stream musí podporovat operace read a seek.</target>
        <note />
      </trans-unit>
      <trans-unit id="Suppress_0">
        <source>Suppress {0}</source>
        <target state="translated">Potlačit {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="TODO_colon_free_unmanaged_resources_unmanaged_objects_and_override_finalizer">
        <source>TODO: free unmanaged resources (unmanaged objects) and override finalizer</source>
        <target state="translated">TODO: Uvolněte nespravované prostředky (nespravované objekty) a přepište finalizační metodu.</target>
        <note />
      </trans-unit>
      <trans-unit id="TODO_colon_override_finalizer_only_if_0_has_code_to_free_unmanaged_resources">
        <source>TODO: override finalizer only if '{0}' has code to free unmanaged resources</source>
        <target state="translated">TODO: Finalizační metodu přepište, jen pokud metoda {0} obsahuje kód pro uvolnění nespravovaných prostředků.</target>
        <note />
      </trans-unit>
      <trans-unit id="Target_type_matches">
        <source>Target type matches</source>
        <target state="translated">Shody cílového typu</target>
        <note />
      </trans-unit>
      <trans-unit id="The_assembly_0_containing_type_1_references_NET_Framework">
        <source>The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.</source>
        <target state="translated">Sestavení {0}, které obsahuje typ {1}, se odkazuje na architekturu .NET Framework, což se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_selection_contains_a_local_function_call_without_its_declaration">
        <source>The selection contains a local function call without its declaration.</source>
        <target state="translated">Výběr obsahuje volání lokální funkce, aniž by byla deklarovaná.</target>
        <note />
      </trans-unit>
      <trans-unit id="Too_many_bars_in_conditional_grouping">
        <source>Too many | in (?()|)</source>
        <target state="translated">Příliš mnoho znaků | ve výrazu (?()|)</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0)a|b|)</note>
      </trans-unit>
      <trans-unit id="Too_many_close_parens">
        <source>Too many )'s</source>
        <target state="translated">Příliš mnoho znaků )</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: )</note>
      </trans-unit>
      <trans-unit id="UnableToReadSourceFileOrPdb">
        <source>Unable to read source file '{0}' or the PDB built for the containing project. Any changes made to this file while debugging won't be applied until its content matches the built source.</source>
        <target state="translated">Není možné přečíst zdrojový soubor {0} nebo soubor PDB sestavený pro projekt, který tyto soubory obsahuje. Případné změny provedené v tomto souboru během ladění se nepoužijí, dokud se jeho obsah nebude shodovat se sestaveným zdrojem.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_property">
        <source>Unknown property</source>
        <target state="translated">Neznámá vlastnost</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{}</note>
      </trans-unit>
      <trans-unit id="Unknown_property_0">
        <source>Unknown property '{0}'</source>
        <target state="translated">Neznámá vlastnost {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{xxx}. Here, {0} will be the name of the unknown property ('xxx')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_control_character">
        <source>Unrecognized control character</source>
        <target state="translated">Nerozpoznaný řídicí znak</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [\c]</note>
      </trans-unit>
      <trans-unit id="Unrecognized_escape_sequence_0">
        <source>Unrecognized escape sequence \{0}</source>
        <target state="translated">Nerozpoznaná řídicí sekvence \{0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \m. Here, {0} will be the unrecognized character ('m')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_grouping_construct">
        <source>Unrecognized grouping construct</source>
        <target state="translated">Nerozpoznaný seskupovací konstrukt</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;</note>
      </trans-unit>
      <trans-unit id="Unterminated_character_class_set">
        <source>Unterminated [] set</source>
        <target state="translated">Nedokončená sada []</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [</note>
      </trans-unit>
      <trans-unit id="Unterminated_regex_comment">
        <source>Unterminated (?#...) comment</source>
        <target state="translated">Neukončený komentář (?#...)</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?#</note>
      </trans-unit>
      <trans-unit id="Unwrap_all_arguments">
        <source>Unwrap all arguments</source>
        <target state="translated">Zrušit zalomení všech argumentů</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_all_parameters">
        <source>Unwrap all parameters</source>
        <target state="translated">Zrušit zalomení všech parametrů</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_and_indent_all_arguments">
        <source>Unwrap and indent all arguments</source>
        <target state="translated">Zrušit zalomení všech argumentů a odsadit je</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_and_indent_all_parameters">
        <source>Unwrap and indent all parameters</source>
        <target state="translated">Zrušit zalomení všech parametrů a odsadit je</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_argument_list">
        <source>Unwrap argument list</source>
        <target state="translated">Zrušit zalomení seznamu argumentů</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_call_chain">
        <source>Unwrap call chain</source>
        <target state="translated">Zrušit zalomení posloupnosti volání</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_expression">
        <source>Unwrap expression</source>
        <target state="translated">Zrušit zalomení výrazu</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_parameter_list">
        <source>Unwrap parameter list</source>
        <target state="translated">Zrušit zalomení seznamu parametrů</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_a_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Updating a '{0}' around an active statement will prevent the debug session from continuing.</source>
        <target state="translated">Pokud se aktualizuje {0} v okolí aktivního příkazu, relace ladění nebude moct pokračovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_block_body_for_lambda_expressions">
        <source>Use block body for lambda expressions</source>
        <target state="translated">Pro lambda výrazy používat text bloku</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_expression_body_for_lambda_expressions">
        <source>Use expression body for lambda expressions</source>
        <target state="translated">Používat text výrazu pro lambda výrazy</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_interpolated_verbatim_string">
        <source>Use interpolated verbatim string</source>
        <target state="translated">Použít interpolovaný doslovný řetězec</target>
        <note />
      </trans-unit>
      <trans-unit id="Value_colon">
        <source>Value:</source>
        <target state="translated">Hodnota:</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_changing_namespace_may_produce_invalid_code_and_change_code_meaning">
        <source>Warning: Changing namespace may produce invalid code and change code meaning.</source>
        <target state="translated">Upozornění: Změna oboru názvů může vést k vytvoření neplatného kódu a změnit význam kódu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_semantics_may_change_when_converting_statement">
        <source>Warning: Semantics may change when converting statement.</source>
        <target state="translated">Upozornění: Při převodu příkazu se může změnit sémantika.</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_and_align_call_chain">
        <source>Wrap and align call chain</source>
        <target state="translated">Zalomit a zarovnat posloupnost volání</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_and_align_expression">
        <source>Wrap and align expression</source>
        <target state="translated">Výraz pro zabalení a zarovnání</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_and_align_long_call_chain">
        <source>Wrap and align long call chain</source>
        <target state="translated">Zalomit a zarovnat dlouhou posloupnost volání</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_call_chain">
        <source>Wrap call chain</source>
        <target state="translated">Zalomit posloupnost volání</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_every_argument">
        <source>Wrap every argument</source>
        <target state="translated">Zalomit každý argument</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_every_parameter">
        <source>Wrap every parameter</source>
        <target state="translated">Zalomit každý parametr</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_expression">
        <source>Wrap expression</source>
        <target state="translated">Zalomit výraz</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_argument_list">
        <source>Wrap long argument list</source>
        <target state="translated">Zalomit dlouhý seznam argumentů</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_call_chain">
        <source>Wrap long call chain</source>
        <target state="translated">Zalomit dlouhou posloupnost volání</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_parameter_list">
        <source>Wrap long parameter list</source>
        <target state="translated">Zalomit dlouhý seznam parametrů</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrapping">
        <source>Wrapping</source>
        <target state="translated">Zalamování</target>
        <note />
      </trans-unit>
      <trans-unit id="You_can_use_the_navigation_bar_to_switch_contexts">
        <source>You can use the navigation bar to switch contexts.</source>
        <target state="new">You can use the navigation bar to switch contexts.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_cannot_be_null_or_empty">
        <source>'{0}' cannot be null or empty.</source>
        <target state="translated">Hodnota {0} nemůže být nulová a toto pole nemůže být prázdné.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_cannot_be_null_or_whitespace">
        <source>'{0}' cannot be null or whitespace.</source>
        <target state="translated">Hodnota {0} nemůže být null ani prázdný znak.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_dash_1">
        <source>{0} - {1}</source>
        <target state="translated">{0} - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_null_here">
        <source>'{0}' is not null here.</source>
        <target state="translated">{0} tady není null.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_may_be_null_here">
        <source>'{0}' may be null here.</source>
        <target state="translated">{0} tady může být null.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second">
        <source>10,000,000ths of a second</source>
        <target state="translated">Desetimiliontiny sekundy</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second_description">
        <source>The "fffffff" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value.

Although it's possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Specifikátor vlastního formátu fffffff představuje sedm platných číslic zlomku sekundy. To znamená, že v hodnotě data a času představuje desetimiliontiny sekundy.

Ačkoli je možné tuto část sekundy hodnoty času zobrazit, nemusí tato hodnota být významná. Přesnost hodnot data a času závisí na rozlišení systémových hodin. V operačních systémech Windows NT 3.5 (a novějších) a Windows Vista je rozlišení hodin přibližně 10–15 milisekund.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second_non_zero">
        <source>10,000,000ths of a second (non-zero)</source>
        <target state="translated">Desetimiliontiny sekundy (nenulové)</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second_non_zero_description">
        <source>The "FFFFFFF" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value. However, trailing zeros or seven zero digits aren't displayed.

Although it's possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Specifikátor vlastního formátu FFFFFFF představuje sedm platných číslic zlomku sekundy. To znamená, že v hodnotě data a času představuje desetimiliontiny sekundy. Nezobrazují se ale nuly na konci ani sedm nulových číslic.

Ačkoli je možné tuto část sekundy hodnoty času zobrazit, nemusí tato hodnota být významná. Přesnost hodnot data a času závisí na rozlišení systémových hodin. V operačních systémech Windows NT 3.5 (a novějších) a Windows Vista je rozlišení hodin přibližně 10–15 milisekund.</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second">
        <source>1,000,000ths of a second</source>
        <target state="translated">Miliontiny sekundy</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second_description">
        <source>The "ffffff" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value.

Although it's possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Specifikátor vlastního formátu ffffff představuje šest platných číslic zlomku sekundy. To znamená, že v hodnotě data a času představuje miliontiny sekundy.

Ačkoli je možné tuto část sekundy hodnoty času zobrazit, nemusí tato hodnota být významná. Přesnost hodnot data a času závisí na rozlišení systémových hodin. V operačních systémech Windows NT 3.5 (a novějších) a Windows Vista je rozlišení hodin přibližně 10–15 milisekund.</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second_non_zero">
        <source>1,000,000ths of a second (non-zero)</source>
        <target state="translated">Miliontiny sekundy (nenulové)</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second_non_zero_description">
        <source>The "FFFFFF" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value. However, trailing zeros or six zero digits aren't displayed.

Although it's possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Specifikátor vlastního formátu FFFFFF představuje šest platných číslic zlomku sekundy. To znamená, že v hodnotě data a času představuje miliontiny sekundy. Nezobrazují se ale nuly na konci ani šest nulových číslic.

Ačkoli je možné tuto část sekundy hodnoty času zobrazit, nemusí tato hodnota být významná. Přesnost hodnot data a času závisí na rozlišení systémových hodin. V operačních systémech Windows NT 3.5 (a novějších) a Windows Vista je rozlišení hodin přibližně 10–15 milisekund.</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second">
        <source>100,000ths of a second</source>
        <target state="translated">Stotisíciny sekundy</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second_description">
        <source>The "fffff" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value.

Although it's possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Specifikátor vlastního formátu fffff představuje pět platných číslic zlomku sekundy. To znamená, že v hodnotě data a času představuje stotisíciny sekundy.

Ačkoli je možné tuto část sekundy hodnoty času zobrazit, nemusí tato hodnota být významná. Přesnost hodnot data a času závisí na rozlišení systémových hodin. V operačních systémech Windows NT 3.5 (a novějších) a Windows Vista je rozlišení hodin přibližně 10–15 milisekund.</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second_non_zero">
        <source>100,000ths of a second (non-zero)</source>
        <target state="translated">Stotisíciny sekundy (nenulové)</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second_non_zero_description">
        <source>The "FFFFF" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value. However, trailing zeros or five zero digits aren't displayed.

Although it's possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Specifikátor vlastního formátu FFFFF představuje pět platných číslic zlomku sekundy. To znamená, že v hodnotě data a času představuje stotisíciny sekundy. Nezobrazují se ale nuly na konci ani pět nulových číslic.

Ačkoli je možné tuto část sekundy hodnoty času zobrazit, nemusí tato hodnota být významná. Přesnost hodnot data a času závisí na rozlišení systémových hodin. V operačních systémech Windows NT 3.5 (a novějších) a Windows Vista je rozlišení hodin přibližně 10–15 milisekund.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second">
        <source>10,000ths of a second</source>
        <target state="translated">Desetitisíciny sekundy</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second_description">
        <source>The "ffff" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value.

Although it's possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT version 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Specifikátor vlastního formátu ffff představuje čtyři platných číslic zlomku sekundy. To znamená, že v hodnotě data a času představuje desetitisíciny sekundy.

Ačkoli je možné tuto část sekundy hodnoty času zobrazit, nemusí tato hodnota být významná. Přesnost hodnot data a času závisí na rozlišení systémových hodin. V operačních systémech Windows NT verze 3.5 (a novějších) a Windows Vista je rozlišení hodin přibližně 10–15 milisekund.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second_non_zero">
        <source>10,000ths of a second (non-zero)</source>
        <target state="translated">Desetitisíciny sekundy (nenulové)</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second_non_zero_description">
        <source>The "FFFF" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value. However, trailing zeros or four zero digits aren't displayed.

Although it's possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Specifikátor vlastního formátu FFFF představuje čtyři platné číslice zlomku sekundy. To znamená, že v hodnotě data a času představuje desetitisíciny sekundy. Nezobrazují se ale nuly na konci ani čtyři nulové číslice.

Ačkoli je možné tuto část sekundy hodnoty času zobrazit, nemusí tato hodnota být významná. Přesnost hodnot data a času závisí na rozlišení systémových hodin. V operačních systémech Windows NT 3.5 (a novějších) a Windows Vista je rozlišení hodin přibližně 10–15 milisekund.</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second">
        <source>1,000ths of a second</source>
        <target state="translated">Tisíciny sekundy</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second_description">
        <source>The "fff" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value.</source>
        <target state="translated">Specifikátor vlastního formátu fff představuje tři platné číslice zlomku sekundy. To znamená, že v hodnotě data a času představuje milisekundy.</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second_non_zero">
        <source>1,000ths of a second (non-zero)</source>
        <target state="translated">Tisíciny sekundy (nenulové)</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second_non_zero_description">
        <source>The "FFF" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value. However, trailing zeros or three zero digits aren't displayed.</source>
        <target state="translated">Specifikátor vlastního formátu FFF představuje tři platné číslice zlomku sekundy. To znamená, že v hodnotě data a času představuje milisekundy. Nezobrazují se ale nuly na konci ani tři nulové číslice.</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second">
        <source>100ths of a second</source>
        <target state="translated">Setiny sekundy</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second_description">
        <source>The "ff" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value.</source>
        <target state="translated">Specifikátor vlastního formátu ff představuje dvě platné číslice zlomku sekundy. To znamená, že v hodnotě data a času představuje setiny sekundy.</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second_non_zero">
        <source>100ths of a second (non-zero)</source>
        <target state="translated">Setiny sekundy (nenulové)</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second_non_zero_description">
        <source>The "FF" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value. However, trailing zeros or two zero digits aren't displayed.</source>
        <target state="translated">Specifikátor vlastního formátu FF představuje dvě platné číslice zlomku sekundy. To znamená, že v hodnotě data a času představuje setiny sekundy. Nezobrazují se ale nuly na konci ani dvě nulové číslice.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second">
        <source>10ths of a second</source>
        <target state="translated">Desetiny sekundy</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second_description">
        <source>The "f" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value.

If the "f" format specifier is used without other format specifiers, it's interpreted as the "f" standard date and time format specifier.

When you use "f" format specifiers as part of a format string supplied to the ParseExact, TryParseExact, ParseExact, or TryParseExact method, the number of "f" format specifiers indicates the number of most significant digits of the seconds fraction that must be present to successfully parse the string.</source>
        <target state="translated">Specifikátor vlastního formátu f představuje platné číslici zlomku sekund. To znamená, že v hodnotě data a času představuje desetiny sekundy.

Pokud se specifikátor formátu f použije bez jiných specifikátorů formátu, interpretuje se jako standardní specifikátor formátu data a času f.

Když specifikátor formátu f použijete v rámci řetězce formátu, který se předává metodám ParseExact, TryParseExact, ParseExact nebo TryParseExact, počet specifikátorů formátu f určuje počet platných číslic zlomku sekundy, který musí být k dispozici pro úspěšné parsování řetězce.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second_non_zero">
        <source>10ths of a second (non-zero)</source>
        <target state="translated">Desetiny sekundy (nenulové)</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second_non_zero_description">
        <source>The "F" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value. Nothing is displayed if the digit is zero.

If the "F" format specifier is used without other format specifiers, it's interpreted as the "F" standard date and time format specifier.

The number of "F" format specifiers used with the ParseExact, TryParseExact, ParseExact, or TryParseExact method indicates the maximum number of most significant digits of the seconds fraction that can be present to successfully parse the string.</source>
        <target state="translated">Specifikátor vlastního formátu F představuje platné číslici zlomku sekund. To znamená, že v hodnotě data a času představuje desetiny sekundy. Pokud je číslicí nula, nic se nezobrazí.

Pokud se specifikátor formátu F použije bez jiných specifikátorů formátu, interpretuje se jako standardní specifikátor formátu data a času F.

Počet specifikátorů formátu F použitý v metodě ParseExact, TryParseExact, ParseExact nebo TryParseExact udává maximální počet platných číslic zlomku sekundy, který může být k dispozici pro úspěšné parsování řetězce.</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_1_2_digits">
        <source>12 hour clock (1-2 digits)</source>
        <target state="translated">12hodinový formát (1–2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_1_2_digits_description">
        <source>The "h" custom format specifier represents the hour as a number from 1 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour after midnight is indistinguishable from the same hour after noon. The hour is not rounded, and a single-digit hour is formatted without a leading zero. For example, given a time of 5:43 in the morning or afternoon, this custom format specifier displays "5".

If the "h" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">Specifikátor vlastního formátu h reprezentuje hodinu jako číslo od 1 do 12. To znamená, že hodina je reprezentována ve 12hodinovém formátu, který počítá celé hodiny od půlnoci do poledne. Konkrétní hodina po půlnoci se nijak neliší od stejné hodiny po poledni. Hodina se nezaokrouhluje a jednočíselná hodina se formátuje bez nuly na začátku. Když je například ráno nebo odpoledne 5:43, tento specifikátor vlastního formátu zobrazí 5.

Pokud se specifikátor formátu h zadá bez jiných specifikátorů vlastního formátu, interpretuje se jako standardní specifikátor formátu data a času a vyvolá FormatException.</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_2_digits">
        <source>12 hour clock (2 digits)</source>
        <target state="translated">12hodinový formát (2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_2_digits_description">
        <source>The "hh" custom format specifier (plus any number of additional "h" specifiers) represents the hour as a number from 01 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour after midnight is indistinguishable from the same hour after noon. The hour is not rounded, and a single-digit hour is formatted with a leading zero. For example, given a time of 5:43 in the morning or afternoon, this format specifier displays "05".</source>
        <target state="translated">Specifikátor vlastního formátu hh (a libovolný počet dalších specifikátorů h) reprezentuje hodinu jako číslo od 01 do 12. To znamená, že hodina je reprezentována ve 12hodinovém formátu, který počítá celé hodiny od půlnoci do poledne. Konkrétní hodina po půlnoci se nijak neliší od stejné hodiny po poledni. Hodina se nezaokrouhluje a jednočíselná hodina se formátuje s nulou na začátku. Když je například ráno nebo odpoledne 5:43, tento specifikátor vlastního formátu zobrazí 05.</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_1_2_digits">
        <source>24 hour clock (1-2 digits)</source>
        <target state="translated">24hodinový formát (1–2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_1_2_digits_description">
        <source>The "H" custom format specifier represents the hour as a number from 0 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is formatted without a leading zero.

If the "H" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">Specifikátor vlastního formátu H reprezentuje hodinu jako číslo od 0 do 23. To znamená, že hodina je reprezentována ve 24hodinovém formátu, který začíná na nule a počítá hodiny od půlnoci. Hodina s jednou číslicí se formátuje bez nuly na začátku.

Pokud se specifikátor formátu H použije bez dalších specifikátorů vlastního formátu, interpretuje se jako standardní specifikátor formátu data a čas a vyvolá FormatException.</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_2_digits">
        <source>24 hour clock (2 digits)</source>
        <target state="translated">24hodinový formát (2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_2_digits_description">
        <source>The "HH" custom format specifier (plus any number of additional "H" specifiers) represents the hour as a number from 00 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is formatted with a leading zero.</source>
        <target state="translated">Specifikátor vlastního formátu HH reprezentuje hodinu jako číslo od 00 do 23. To znamená, že hodina je reprezentována ve 24hodinovém formátu, který začíná na nule a počítá hodiny od půlnoci. Hodina s jednou číslicí se formátuje s nulou na začátku.</target>
        <note />
      </trans-unit>
      <trans-unit id="code">
        <source>code</source>
        <target state="new">code</target>
        <note />
      </trans-unit>
      <trans-unit id="date_separator">
        <source>date separator</source>
        <target state="translated">oddělovač data</target>
        <note />
      </trans-unit>
      <trans-unit id="date_separator_description">
        <source>The "/" custom format specifier represents the date separator, which is used to differentiate years, months, and days. The appropriate localized date separator is retrieved from the DateTimeFormatInfo.DateSeparator property of the current or specified culture.

Note: To change the date separator for a particular date and time string, specify the separator character within a literal string delimiter. For example, the custom format string mm'/'dd'/'yyyy produces a result string in which "/" is always used as the date separator. To change the date separator for all dates for a culture, either change the value of the DateTimeFormatInfo.DateSeparator property of the current culture, or instantiate a DateTimeFormatInfo object, assign the character to its DateSeparator property, and call an overload of the formatting method that includes an IFormatProvider parameter.

If the "/" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">Specifikátor vlastního formátu / představuje oddělovač data, pomocí kterého se odlišují roky, měsíce a dny. Správný lokalizovaný oddělovač data se načítá z vlastnosti DateTimeFormatInfo.DateSeparator aktuální nebo zadané jazykové verze.

Poznámka: Pokud chcete změnit oddělovač data pro konkrétní řetězec data a času, zadejte znak oddělovače v oddělovači literálního řetězce. Například řetězec s vlastním formátem mm'/'dd'/'yyyy vytvoří výsledný řetězec, ve kterém se / vždy použije jako oddělovač data. Pokud chcete oddělovač data změnit pro všechna data v jazykové verzi, buď změňte hodnotu vlastnosti DateTimeFormatInfo.DateSeparator aktuální jazykové verze, nebo vytvořte instanci objektu DateTimeFormatInfo, přiřaďte znak do jeho vlastnosti DateSeparator a zavolejte přetížení metody formátování, která zahrnuje parametr IFormatProvider.

Pokud se specifikátor formátu / použije bez dalších specifikátorů vlastního formátu, interpretuje se jako standardní specifikátor formátu data a času a vyvolá FormatException.</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_1_2_digits">
        <source>day of the month (1-2 digits)</source>
        <target state="translated">den v měsíci (1–2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_1_2_digits_description">
        <source>The "d" custom format specifier represents the day of the month as a number from 1 through 31. A single-digit day is formatted without a leading zero.

If the "d" format specifier is used without other custom format specifiers, it's interpreted as the "d" standard date and time format specifier.</source>
        <target state="translated">Specifikátor vlastního formátu d reprezentuje den v měsíci jako číslo od 1 do 31. Den s jednou číslicí se formátuje bez nuly na začátku.

Pokud se specifikátor formátu d použije bez dalších specifikátorů vlastního formátu, interpretuje se jako standardní specifikátor formátu data a času d.</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_2_digits">
        <source>day of the month (2 digits)</source>
        <target state="translated">den v měsíci (2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_2_digits_description">
        <source>The "dd" custom format string represents the day of the month as a number from 01 through 31. A single-digit day is formatted with a leading zero.</source>
        <target state="translated">Specifikátor vlastního formátu dd reprezentuje den v měsíci jako číslo od 01 do 31. Den s jednou číslicí se formátuje s nulou na začátku.</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_abbreviated">
        <source>day of the week (abbreviated)</source>
        <target state="translated">den v týdnu (zkrácený)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_abbreviated_description">
        <source>The "ddd" custom format specifier represents the abbreviated name of the day of the week. The localized abbreviated name of the day of the week is retrieved from the DateTimeFormatInfo.AbbreviatedDayNames property of the current or specified culture.</source>
        <target state="translated">Specifikátor vlastního formátu ddd reprezentuje zkrácený název dne v týdnu. Lokalizovaný zkrácený název dne v týdnu se načítá z vlastnosti DateTimeFormatInfo.AbbreviatedDayNames aktuální nebo zadané jazykové verze.</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_full">
        <source>day of the week (full)</source>
        <target state="translated">den v týdnu (úplný)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_full_description">
        <source>The "dddd" custom format specifier (plus any number of additional "d" specifiers) represents the full name of the day of the week. The localized name of the day of the week is retrieved from the DateTimeFormatInfo.DayNames property of the current or specified culture.</source>
        <target state="translated">Specifikátor vlastního formátu dddd (a libovolný počet dalších specifikátorů d) reprezentuje celý název dne v týdnu. Lokalizovaný název dne v týdnu se načítá z vlastnosti DateTimeFormatInfo.DayNames aktuální nebo zadané jazykové verze.</target>
        <note />
      </trans-unit>
      <trans-unit id="discard">
        <source>discard</source>
        <target state="translated">proměnná typu discard</target>
        <note />
      </trans-unit>
      <trans-unit id="from_metadata">
        <source>from metadata</source>
        <target state="translated">z metadat</target>
        <note />
      </trans-unit>
      <trans-unit id="full_long_date_time">
        <source>full long date/time</source>
        <target state="translated">celé dlouhé datum a čas</target>
        <note />
      </trans-unit>
      <trans-unit id="full_long_date_time_description">
        <source>The "F" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.FullDateTimePattern property. For example, the custom format string for the invariant culture is "dddd, dd MMMM yyyy HH:mm:ss".</source>
        <target state="translated">Specifikátor standardního formátu F představuje řetězec vlastního formátu data a času, který se definuje pomocí vlastnosti DateTimeFormatInfo.FullDateTimePattern. Například řetězec vlastního formátu pro invariantní jazykovou verzi je dddd, dd MMMM yyyy HH:mm:ss.</target>
        <note />
      </trans-unit>
      <trans-unit id="full_short_date_time">
        <source>full short date/time</source>
        <target state="translated">celé krátké datum a čas</target>
        <note />
      </trans-unit>
      <trans-unit id="full_short_date_time_description">
        <source>The Full Date Short Time ("f") Format Specifier

The "f" standard format specifier represents a combination of the long date ("D") and short time ("t") patterns, separated by a space.</source>
        <target state="translated">Specifikátor formátu úplného data a krátkého času (f)

Specifikátor standardního formátu f představuje kombinaci vzorů dlouhého data (D) a krátkého času (t) oddělených mezerou.</target>
        <note />
      </trans-unit>
      <trans-unit id="general_long_date_time">
        <source>general long date/time</source>
        <target state="translated">obecné dlouhé datum a čas</target>
        <note />
      </trans-unit>
      <trans-unit id="general_long_date_time_description">
        <source>The "G" standard format specifier represents a combination of the short date ("d") and long time ("T") patterns, separated by a space.</source>
        <target state="translated">Specifikátor standardního formátu G představuje kombinaci vzorů krátkého data (d) a dlouhého času (T) oddělených mezerou.</target>
        <note />
      </trans-unit>
      <trans-unit id="general_short_date_time">
        <source>general short date/time</source>
        <target state="translated">obecné krátké datum a čas</target>
        <note />
      </trans-unit>
      <trans-unit id="general_short_date_time_description">
        <source>The "g" standard format specifier represents a combination of the short date ("d") and short time ("t") patterns, separated by a space.</source>
        <target state="translated">Specifikátor standardního formátu g představuje kombinaci vzorů krátkého data (d) a krátkého času (t) oddělených mezerou.</target>
        <note />
      </trans-unit>
      <trans-unit id="generic_overload">
        <source>generic overload</source>
        <target state="translated">obecné přetížení</target>
        <note />
      </trans-unit>
      <trans-unit id="generic_overloads">
        <source>generic overloads</source>
        <target state="translated">obecná přetížení</target>
        <note />
      </trans-unit>
      <trans-unit id="in_0_1_2">
        <source>in {0} ({1} - {2})</source>
        <target state="translated">v {0} ({1}–{2})</target>
        <note />
      </trans-unit>
      <trans-unit id="in_Source_attribute">
        <source>in Source (attribute)</source>
        <target state="translated">in Source (atribut)</target>
        <note />
      </trans-unit>
      <trans-unit id="long_date">
        <source>long date</source>
        <target state="translated">dlouhé datum</target>
        <note />
      </trans-unit>
      <trans-unit id="long_date_description">
        <source>The "D" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.LongDatePattern property. For example, the custom format string for the invariant culture is "dddd, dd MMMM yyyy".</source>
        <target state="translated">Specifikátor standardního formátu D představuje řetězec vlastního formátu data a času, který se definuje pomocí vlastnosti DateTimeFormatInfo.LongDatePattern. Například řetězec vlastního formátu pro invariantní jazykovou verzi je dddd, dd MMMM yyyy.</target>
        <note />
      </trans-unit>
      <trans-unit id="long_time">
        <source>long time</source>
        <target state="translated">dlouhý čas</target>
        <note />
      </trans-unit>
      <trans-unit id="long_time_description">
        <source>The "T" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.LongTimePattern property. For example, the custom format string for the invariant culture is "HH:mm:ss".</source>
        <target state="translated">Specifikátor standardního formátu T představuje řetězec vlastního formátu data a času, který se definuje pomocí vlastnosti DateTimeFormatInfo.LongTimePattern konkrétní jazykové verze. Například řetězec vlastního formátu pro invariantní jazykovou verzi je HH:mm:ss.</target>
        <note />
      </trans-unit>
      <trans-unit id="member_kind_and_name">
        <source>{0} '{1}'</source>
        <target state="new">{0} '{1}'</target>
        <note>e.g. "method 'M'"</note>
      </trans-unit>
      <trans-unit id="minute_1_2_digits">
        <source>minute (1-2 digits)</source>
        <target state="translated">minuta (1–2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_1_2_digits_description">
        <source>The "m" custom format specifier represents the minute as a number from 0 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted without a leading zero.

If the "m" format specifier is used without other custom format specifiers, it's interpreted as the "m" standard date and time format specifier.</source>
        <target state="translated">Specifikátor vlastního formátu m reprezentuje minutu jako číslo od 0 do 59. Minuta představuje celé minuty, které uplynuly od poslední hodiny. Minuta s jednou číslicí se formátuje bez nuly na začátku.

Pokud se specifikátor formátu m použije bez dalších specifikátorů vlastního formátu, interpretuje se jako standardní specifikátor formátu data a času m.</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_2_digits">
        <source>minute (2 digits)</source>
        <target state="translated">minuta (2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_2_digits_description">
        <source>The "mm" custom format specifier (plus any number of additional "m" specifiers) represents the minute as a number from 00 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted with a leading zero.</source>
        <target state="translated">Specifikátor vlastního formátu mm (a libovolný počet dalších specifikátorů m) reprezentuje minutu jako číslo od 00 do 59. Minuta představuje celé minuty, které uplynuly od poslední hodiny. Minuta s jednou číslicí se formátuje s nulou na začátku.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_1_2_digits">
        <source>month (1-2 digits)</source>
        <target state="translated">měsíc (1–2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_1_2_digits_description">
        <source>The "M" custom format specifier represents the month as a number from 1 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted without a leading zero.

If the "M" format specifier is used without other custom format specifiers, it's interpreted as the "M" standard date and time format specifier.</source>
        <target state="translated">Specifikátor vlastního formátu M reprezentuje měsíc jako číslo od 1 do 12 (nebo od 1 do 13 pro kalendáře, které mají 13 měsíců). Den s jednou číslicí se formátuje bez nuly na začátku.

Pokud se specifikátor formátu M použije bez dalších specifikátorů vlastního formátu, interpretuje se jako standardní specifikátor formátu data a času M.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_2_digits">
        <source>month (2 digits)</source>
        <target state="translated">měsíc (2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_2_digits_description">
        <source>The "MM" custom format specifier represents the month as a number from 01 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted with a leading zero.</source>
        <target state="translated">Specifikátor vlastního formátu MM reprezentuje den v měsíci jako číslo od 01 do 12 (nebo od 01 do 13 pro kalendáře, které mají 13 měsíců). Den s jednou číslicí se formátuje s nulou na začátku.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_abbreviated">
        <source>month (abbreviated)</source>
        <target state="translated">měsíc (zkrácený)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_abbreviated_description">
        <source>The "MMM" custom format specifier represents the abbreviated name of the month. The localized abbreviated name of the month is retrieved from the DateTimeFormatInfo.AbbreviatedMonthNames property of the current or specified culture.</source>
        <target state="translated">Specifikátor vlastního formátu MMM reprezentuje zkrácený název měsíce. Lokalizovaný zkrácený název měsíce se načítá z vlastnosti DateTimeFormatInfo.AbbreviatedMonthNames aktuální nebo zadané jazykové verze.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_day">
        <source>month day</source>
        <target state="translated">den v měsíci</target>
        <note />
      </trans-unit>
      <trans-unit id="month_day_description">
        <source>The "M" or "m" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.MonthDayPattern property. For example, the custom format string for the invariant culture is "MMMM dd".</source>
        <target state="translated">Specifikátor standardního formátu M nebo m představuje řetězec vlastního formátu data a času, který se definuje pomocí vlastnosti DateTimeFormatInfo.MonthDayPattern. Například řetězec vlastního formátu pro invariantní jazykovou verzi je MMMM dd.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_full">
        <source>month (full)</source>
        <target state="translated">měsíc (úplný)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_full_description">
        <source>The "MMMM" custom format specifier represents the full name of the month. The localized name of the month is retrieved from the DateTimeFormatInfo.MonthNames property of the current or specified culture.</source>
        <target state="translated">Specifikátor vlastního formátu MMMM reprezentuje celý název měsíce. Lokalizovaný název měsíce se načítá z vlastnosti DateTimeFormatInfo.MonthNames aktuální nebo zadané jazykové verze.</target>
        <note />
      </trans-unit>
      <trans-unit id="overload">
        <source>overload</source>
        <target state="translated">přetížení</target>
        <note />
      </trans-unit>
      <trans-unit id="overloads_">
        <source>overloads</source>
        <target state="translated">přetížení</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_Keyword">
        <source>{0} Keyword</source>
        <target state="translated">Klíčové slovo {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_field_colon_0_and_use_property">
        <source>Encapsulate field: '{0}' (and use property)</source>
        <target state="translated">Zapouzdřit pole: {0} (a použít vlastnost)</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_field_colon_0_but_still_use_field">
        <source>Encapsulate field: '{0}' (but still use field)</source>
        <target state="translated">Zapouzdřit pole: {0} (ale dál používat pole)</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_fields_and_use_property">
        <source>Encapsulate fields (and use property)</source>
        <target state="translated">Zapouzdřit pole (a použít vlastnost)</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_fields_but_still_use_field">
        <source>Encapsulate fields (but still use field)</source>
        <target state="translated">Zapouzdřit pole (ale dál používat pole)</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_extract_interface_colon_The_selection_is_not_inside_a_class_interface_struct">
        <source>Could not extract interface: The selection is not inside a class/interface/struct.</source>
        <target state="translated">Nejde extrahovat rozhraní: Výběr nespadá do třídy/rozhraní/struktury.</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_extract_interface_colon_The_type_does_not_contain_any_member_that_can_be_extracted_to_an_interface">
        <source>Could not extract interface: The type does not contain any member that can be extracted to an interface.</source>
        <target state="translated">Nejde extrahovat rozhraní: Typ neobsahuje žádný člen, který by se dal extrahovat do rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="can_t_not_construct_final_tree">
        <source>can't not construct final tree</source>
        <target state="translated">nejde konstruovat finální strom</target>
        <note />
      </trans-unit>
      <trans-unit id="Parameters_type_or_return_type_cannot_be_an_anonymous_type_colon_bracket_0_bracket">
        <source>Parameters' type or return type cannot be an anonymous type : [{0}]</source>
        <target state="translated">Typ nebo návratový typ parametrů nemůže být anonymní: [{0}].</target>
        <note />
      </trans-unit>
      <trans-unit id="The_selection_contains_no_active_statement">
        <source>The selection contains no active statement.</source>
        <target state="translated">Výběr neobsahuje žádný aktivní příkaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_selection_contains_an_error_or_unknown_type">
        <source>The selection contains an error or unknown type.</source>
        <target state="translated">Výběr obsahuje chybu nebo neznámý typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="Type_parameter_0_is_hidden_by_another_type_parameter_1">
        <source>Type parameter '{0}' is hidden by another type parameter '{1}'.</source>
        <target state="translated">Parametr typu {0} je skrytý jiným parametrem typu {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_address_of_a_variable_is_used_inside_the_selected_code">
        <source>The address of a variable is used inside the selected code.</source>
        <target state="translated">Adresa proměnné se používá ve vybraném kódu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Assigning_to_readonly_fields_must_be_done_in_a_constructor_colon_bracket_0_bracket">
        <source>Assigning to readonly fields must be done in a constructor : [{0}].</source>
        <target state="translated">Přiřazování k polím jen pro čtení se musí dělat v konstruktoru: [{0}].</target>
        <note />
      </trans-unit>
      <trans-unit id="generated_code_is_overlapping_with_hidden_portion_of_the_code">
        <source>generated code is overlapping with hidden portion of the code</source>
        <target state="translated">Vygenerovaný kód se překrývá se skrytou částí kódu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_optional_parameters_to_0">
        <source>Add optional parameters to '{0}'</source>
        <target state="translated">Přidat volitelné parametry do {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_parameters_to_0">
        <source>Add parameters to '{0}'</source>
        <target state="translated">Přidat parametry do {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_delegating_constructor_0_1">
        <source>Generate delegating constructor '{0}({1})'</source>
        <target state="translated">Generovat delegující konstruktor {0}({1})</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constructor_0_1">
        <source>Generate constructor '{0}({1})'</source>
        <target state="translated">Generovat konstruktor {0}({1})</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_field_assigning_constructor_0_1">
        <source>Generate field assigning constructor '{0}({1})'</source>
        <target state="translated">Generovat konstruktor přiřazující pole {0}({1})</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_Equals_and_GetHashCode">
        <source>Generate Equals and GetHashCode</source>
        <target state="translated">Generovat Equals a GetHashCode</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_Equals_object">
        <source>Generate Equals(object)</source>
        <target state="translated">Generovat Equals(objekt)</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_GetHashCode">
        <source>Generate GetHashCode()</source>
        <target state="translated">Generovat GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constructor_in_0">
        <source>Generate constructor in '{0}'</source>
        <target state="translated">Generovat konstruktor v: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_all">
        <source>Generate all</source>
        <target state="translated">Generovat všechno</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_enum_member_1_0">
        <source>Generate enum member '{1}.{0}'</source>
        <target state="translated">Generovat člena výčtu {1}.{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constant_1_0">
        <source>Generate constant '{1}.{0}'</source>
        <target state="translated">Generovat konstantu {1}.{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_read_only_property_1_0">
        <source>Generate read-only property '{1}.{0}'</source>
        <target state="translated">Generovat vlastnost jen pro čtení {1}.{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_property_1_0">
        <source>Generate property '{1}.{0}'</source>
        <target state="translated">Generovat vlastnost {1}.{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_read_only_field_1_0">
        <source>Generate read-only field '{1}.{0}'</source>
        <target state="translated">Generovat pole jen pro čtení {1}.{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_field_1_0">
        <source>Generate field '{1}.{0}'</source>
        <target state="translated">Generovat pole {1}.{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_local_0">
        <source>Generate local '{0}'</source>
        <target state="translated">Generovat místní: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_0_1_in_new_file">
        <source>Generate {0} '{1}' in new file</source>
        <target state="translated">Generovat {0} {1} v novém souboru</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_nested_0_1">
        <source>Generate nested {0} '{1}'</source>
        <target state="translated">Generovat vnořené {0} {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Global_Namespace">
        <source>Global Namespace</source>
        <target state="translated">Globální obor názvů</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_interface_abstractly">
        <source>Implement interface abstractly</source>
        <target state="translated">Implementovat rozhraní abstraktně</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_interface_through_0">
        <source>Implement interface through '{0}'</source>
        <target state="translated">Implementovat rozhraní přes {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_interface">
        <source>Implement interface</source>
        <target state="translated">Implementujte rozhraní.</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_field_for_0">
        <source>Introduce field for '{0}'</source>
        <target state="translated">Zavést pole pro {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_for_0">
        <source>Introduce local for '{0}'</source>
        <target state="translated">Zavést lokální proměnnou pro {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_constant_for_0">
        <source>Introduce constant for '{0}'</source>
        <target state="translated">Zavést konstantu pro {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_constant_for_0">
        <source>Introduce local constant for '{0}'</source>
        <target state="translated">Zavést místní konstantu pro {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_field_for_all_occurrences_of_0">
        <source>Introduce field for all occurrences of '{0}'</source>
        <target state="translated">Zavést pole pro všechny výskyty položky {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_for_all_occurrences_of_0">
        <source>Introduce local for all occurrences of '{0}'</source>
        <target state="translated">Zavést lokální proměnnou pro všechny výskyty položky {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_constant_for_all_occurrences_of_0">
        <source>Introduce constant for all occurrences of '{0}'</source>
        <target state="translated">Zavést konstantu pro všechny výskyty položky {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_constant_for_all_occurrences_of_0">
        <source>Introduce local constant for all occurrences of '{0}'</source>
        <target state="translated">Zavést místní konstantu pro všechny výskyty položky {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_query_variable_for_all_occurrences_of_0">
        <source>Introduce query variable for all occurrences of '{0}'</source>
        <target state="translated">Zavést proměnnou dotazu pro všechny výskyty položky {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_query_variable_for_0">
        <source>Introduce query variable for '{0}'</source>
        <target state="translated">Zavést proměnnou dotazu pro {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Anonymous_Types_colon">
        <source>Anonymous Types:</source>
        <target state="translated">Anonymní typy:</target>
        <note />
      </trans-unit>
      <trans-unit id="is_">
        <source>is</source>
        <target state="translated">je</target>
        <note />
      </trans-unit>
      <trans-unit id="Represents_an_object_whose_operations_will_be_resolved_at_runtime">
        <source>Represents an object whose operations will be resolved at runtime.</source>
        <target state="translated">Představuje objekty, jejichž operace se vyhodnotí za běhu.</target>
        <note />
      </trans-unit>
      <trans-unit id="constant">
        <source>constant</source>
        <target state="translated">konstanta</target>
        <note />
      </trans-unit>
      <trans-unit id="field">
        <source>field</source>
        <target state="translated">pole</target>
        <note />
      </trans-unit>
      <trans-unit id="local_constant">
        <source>local constant</source>
        <target state="translated">lokální konstanta</target>
        <note />
      </trans-unit>
      <trans-unit id="local_variable">
        <source>local variable</source>
        <target state="translated">lokální proměnná</target>
        <note />
      </trans-unit>
      <trans-unit id="label">
        <source>label</source>
        <target state="translated">popisek</target>
        <note />
      </trans-unit>
      <trans-unit id="period_era">
        <source>period/era</source>
        <target state="translated">období</target>
        <note />
      </trans-unit>
      <trans-unit id="period_era_description">
        <source>The "g" or "gg" custom format specifiers (plus any number of additional "g" specifiers) represents the period or era, such as A.D. The formatting operation ignores this specifier if the date to be formatted doesn't have an associated period or era string.

If the "g" format specifier is used without other custom format specifiers, it's interpreted as the "g" standard date and time format specifier.</source>
        <target state="translated">Specifikátory vlastního formátu g nebo gg (a libovolný počet dalších specifikátorů g) představují období, třeba př. n. l. Pokud datum, které se má formátovat, nemá přidružený řetězec období, operace formátování tento specifikátor ignoruje.

Pokud se specifikátor formátu g použije bez dalších specifikátorů vlastního formátu, interpretuje se jako standardní specifikátor formátu data a času g.</target>
        <note />
      </trans-unit>
      <trans-unit id="range_variable">
        <source>range variable</source>
        <target state="translated">proměnná rozsahu</target>
        <note />
      </trans-unit>
      <trans-unit id="parameter">
        <source>parameter</source>
        <target state="translated">parametr</target>
        <note />
      </trans-unit>
      <trans-unit id="in_">
        <source>in</source>
        <target state="translated">v</target>
        <note />
      </trans-unit>
      <trans-unit id="Summary_colon">
        <source>Summary:</source>
        <target state="translated">Souhrn:</target>
        <note />
      </trans-unit>
      <trans-unit id="Locals_and_parameters">
        <source>Locals and parameters</source>
        <target state="translated">Místní hodnoty a parametry</target>
        <note />
      </trans-unit>
      <trans-unit id="Type_parameters_colon">
        <source>Type parameters:</source>
        <target state="translated">Vložit parametry:</target>
        <note />
      </trans-unit>
      <trans-unit id="Returns_colon">
        <source>Returns:</source>
        <target state="translated">Vrácení:</target>
        <note />
      </trans-unit>
      <trans-unit id="Exceptions_colon">
        <source>Exceptions:</source>
        <target state="translated">Výjimky:</target>
        <note />
      </trans-unit>
      <trans-unit id="Remarks_colon">
        <source>Remarks:</source>
        <target state="translated">Poznámky:</target>
        <note />
      </trans-unit>
      <trans-unit id="generating_source_for_symbols_of_this_type_is_not_supported">
        <source>generating source for symbols of this type is not supported</source>
        <target state="translated">Generování zdroje pro symboly tohoto typu se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Assembly">
        <source>Assembly</source>
        <target state="translated">sestavení</target>
        <note />
      </trans-unit>
      <trans-unit id="location_unknown">
        <source>location unknown</source>
        <target state="translated">neznámé umístění</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace prvku {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_a_complex_statement_containing_an_await_expression_will_prevent_the_debug_session_from_continuing">
        <source>Updating a complex statement containing an await expression will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace komplexního příkazu, který obsahuje výraz await, znemožní relaci ladění pokračovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="Capturing_variable_0_that_hasn_t_been_captured_before_will_prevent_the_debug_session_from_continuing">
        <source>Capturing variable '{0}' that hasn't been captured before will prevent the debug session from continuing.</source>
        <target state="translated">Zachycení proměnné {0}, která se nezachytila dřív, zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Ceasing_to_capture_variable_0_will_prevent_the_debug_session_from_continuing">
        <source>Ceasing to capture variable '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Ukončení zachycování proměnné {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_captured_variable_0_will_prevent_the_debug_session_from_continuing">
        <source>Deleting captured variable '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Odstranění zachycené proměnné {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_type_of_a_captured_variable_0_previously_of_type_1_will_prevent_the_debug_session_from_continuing">
        <source>Changing the type of a captured variable '{0}' previously of type '{1}' will prevent the debug session from continuing.</source>
        <target state="translated">Změna typu zachycené proměnné {0}, která měla dřív typ {1}, zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_parameters_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Changing the parameters of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Změna parametrů pro {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_return_type_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Changing the return type of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Změna návratového typu pro {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_type_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Changing the type of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Změna typu pro {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_declaration_scope_of_a_captured_variable_0_will_prevent_the_debug_session_from_continuing">
        <source>Changing the declaration scope of a captured variable '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Změna oboru deklarace zachycené proměnné {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Accessing_captured_variable_0_that_hasn_t_been_accessed_before_in_1_will_prevent_the_debug_session_from_continuing">
        <source>Accessing captured variable '{0}' that hasn't been accessed before in {1} will prevent the debug session from continuing.</source>
        <target state="translated">Přístup k zachycené proměnné {0}, ke které se nepřistupovalo dřív v {1}, zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Ceasing_to_access_captured_variable_0_in_1_will_prevent_the_debug_session_from_continuing">
        <source>Ceasing to access captured variable '{0}' in {1} will prevent the debug session from continuing.</source>
        <target state="translated">Ukončení přístupu k zachycené proměnné {0} v {1} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_that_accesses_captured_variables_1_and_2_declared_in_different_scopes_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' that accesses captured variables '{1}' and '{2}' declared in different scopes will prevent the debug session from continuing.</source>
        <target state="translated">Pokud se přidá {0} (přistupující k zachyceným proměnným {1} a {2} deklarovaným v různých oborech), zabrání se tím v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_0_that_accessed_captured_variables_1_and_2_declared_in_different_scopes_will_prevent_the_debug_session_from_continuing">
        <source>Removing '{0}' that accessed captured variables '{1}' and '{2}' declared in different scopes will prevent the debug session from continuing.</source>
        <target state="translated">Pokud se odebere {0} (dříve přistupující k zachyceným proměnným {1} a {2} deklarovaným v různých oborech), zabrání se tím v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_a_1_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' into a '{1}' will prevent the debug session from continuing.</source>
        <target state="translated">Přidání prvku {0} do {1} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_a_class_with_explicit_or_sequential_layout_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' into a class with explicit or sequential layout will prevent the debug session from continuing.</source>
        <target state="translated">Přidání prvku {0} do třídy s explicitním nebo sekvenčním rozložením zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_modifiers_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the modifiers of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace modifikátorů pro {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_Handles_clause_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the Handles clause of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace klauzule Handles pro {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_with_the_Handles_clause_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' with the Handles clause will prevent the debug session from continuing.</source>
        <target state="translated">Přidání prvku {0} s klauzulí Handles zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_Implements_clause_of_a_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the Implements clause of a '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace klauzule Implements pro {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_constraint_from_0_to_1_will_prevent_the_debug_session_from_continuing">
        <source>Changing the constraint from '{0}' to '{1}' will prevent the debug session from continuing.</source>
        <target state="translated">Změna omezení z {0} na {1} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_variance_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the variance of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace odchylky pro {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_type_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the type of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace typu pro {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_initializer_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the initializer of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace inicializátoru pro {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_size_of_a_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the size of a '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace velikosti pro {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_underlying_type_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the underlying type of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace základního typu pro {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_base_class_and_or_base_interface_s_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the base class and/or base interface(s) of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace základní třídy nebo základních rozhraní pro {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_a_field_to_an_event_or_vice_versa_will_prevent_the_debug_session_from_continuing">
        <source>Updating a field to an event or vice versa will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace pole na událost nebo naopak zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_kind_of_a_type_will_prevent_the_debug_session_from_continuing">
        <source>Updating the kind of a type will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace tohoto druhu typu zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_kind_of_an_property_event_accessor_will_prevent_the_debug_session_from_continuing">
        <source>Updating the kind of an property/event accessor will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace druhu přistupujícího objektu pro vlastnost/událost zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_kind_of_a_method_Sub_Function_will_prevent_the_debug_session_from_continuing">
        <source>Updating the kind of a method (Sub/Function) will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace tohoto druhu metody (Sub/Function) zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_library_name_of_Declare_Statement_will_prevent_the_debug_session_from_continuing">
        <source>Updating the library name of Declare Statement will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace názvu knihovny pro deklaraci příkazu zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_alias_of_Declare_Statement_will_prevent_the_debug_session_from_continuing">
        <source>Updating the alias of Declare Statement will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace aliasu pro deklaraci příkazu zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Renaming_0_will_prevent_the_debug_session_from_continuing">
        <source>Renaming '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Přejmenování prvku {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Přidání prvku {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_an_abstract_0_or_overriding_an_inherited_0_will_prevent_the_debug_session_from_continuing">
        <source>Adding an abstract '{0}' or overriding an inherited '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Přidání abstraktu {0} nebo přepsání zděděného {0} znemožní relaci ladění pokračovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_MustOverride_0_or_overriding_an_inherited_0_will_prevent_the_debug_session_from_continuing">
        <source>Adding a MustOverride '{0}' or overriding an inherited '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Přidání MustOverride {0} nebo přepsání zděděného {0} znemožní relaci ladění pokračovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_an_extern_0_will_prevent_the_debug_session_from_continuing">
        <source>Adding an extern '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Přidání externího prvku {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_an_imported_method_will_prevent_the_debug_session_from_continuing">
        <source>Adding an imported method will prevent the debug session from continuing.</source>
        <target state="translated">Přidání importované metody zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_user_defined_0_will_prevent_the_debug_session_from_continuing">
        <source>Adding a user defined '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Přidání uživatelem definovaného prvku {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_generic_0_will_prevent_the_debug_session_from_continuing">
        <source>Adding a generic '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Přidání obecného prvku {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' around an active statement will prevent the debug session from continuing.</source>
        <target state="translated">Přidání prvku {0} v okolí aktivního příkazu zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Moving_0_will_prevent_the_debug_session_from_continuing">
        <source>Moving '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Přesunutí prvku {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_0_will_prevent_the_debug_session_from_continuing">
        <source>Deleting {0} will prevent the debug session from continuing.</source>
        <target state="needs-review-translation">Odstranění prvku {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Deleting '{0}' around an active statement will prevent the debug session from continuing.</source>
        <target state="translated">Odstranění prvku {0} v okolí aktivního příkazu zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_method_body_will_prevent_the_debug_session_from_continuing">
        <source>Adding a method body will prevent the debug session from continuing.</source>
        <target state="translated">Přidání těla metody zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_a_method_body_will_prevent_the_debug_session_from_continuing">
        <source>Deleting a method body will prevent the debug session from continuing.</source>
        <target state="translated">Odstranění těla metody zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_async_or_iterator_modifier_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Updating async or iterator modifier around an active statement will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace modifikátoru async nebo iterator kolem aktivního příkazu bude bránit relaci ladění v tom, aby pokračovala.</target>
        <note>{Locked="async"}{Locked="iterator"} "async" and "iterator" are C#/VB keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Modifying_a_generic_method_will_prevent_the_debug_session_from_continuing">
        <source>Modifying a generic method will prevent the debug session from continuing.</source>
        <target state="translated">Modifikace obecné metody zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_whitespace_or_comments_in_a_generic_0_will_prevent_the_debug_session_from_continuing">
        <source>Modifying whitespace or comments in a generic '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">Modifikace prázdné mezery nebo komentářů v obecné metodě {0} zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_method_inside_the_context_of_a_generic_type_will_prevent_the_debug_session_from_continuing">
        <source>Modifying a method inside the context of a generic type will prevent the debug session from continuing.</source>
        <target state="translated">Modifikace metody v kontextu obecného typu zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_whitespace_or_comments_in_0_inside_the_context_of_a_generic_type_will_prevent_the_debug_session_from_continuing">
        <source>Modifying whitespace or comments in '{0}' inside the context of a generic type will prevent the debug session from continuing.</source>
        <target state="translated">Modifikace prázdné mezery nebo komentářů v {0} v kontextu obecného typu zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_the_initializer_of_0_in_a_generic_type_will_prevent_the_debug_session_from_continuing">
        <source>Modifying the initializer of '{0}' in a generic type will prevent the debug session from continuing.</source>
        <target state="translated">Modifikace inicializátoru pro {0} v obecném typu zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_constructor_to_a_type_with_a_field_or_property_initializer_that_contains_an_anonymous_function_will_prevent_the_debug_session_from_continuing">
        <source>Adding a constructor to a type with a field or property initializer that contains an anonymous function will prevent the debug session from continuing.</source>
        <target state="translated">Přidáním konstruktoru do typu s inicializátorem pole nebo vlastnosti obsahujícím anonymní funkci zabráníte ladicí relaci v pokračování.</target>
        <note />
      </trans-unit>
      <trans-unit id="Renaming_a_captured_variable_from_0_to_1_will_prevent_the_debug_session_from_continuing">
        <source>Renaming a captured variable, from '{0}' to '{1}' will prevent the debug session from continuing.</source>
        <target state="translated">Přejmenováním zachycené proměnné z {0} na {1} zabráníte ladicí relaci v pokračování.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_catch_finally_handler_with_an_active_statement_in_the_try_block_will_prevent_the_debug_session_from_continuing">
        <source>Modifying a catch/finally handler with an active statement in the try block will prevent the debug session from continuing.</source>
        <target state="translated">Modifikace obslužné rutiny catch/finally pomocí aktivního příkazu v bloku try zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_try_catch_finally_statement_when_the_finally_block_is_active_will_prevent_the_debug_session_from_continuing">
        <source>Modifying a try/catch/finally statement when the finally block is active will prevent the debug session from continuing.</source>
        <target state="translated">Modifikace příkazu try/catch/finally, když je aktivní blok finally, zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_catch_handler_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Modifying a catch handler around an active statement will prevent the debug session from continuing.</source>
        <target state="translated">Modifikace obslužné rutiny catch kolem aktivního příkazu zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_the_stackalloc_operator_will_prevent_the_debug_session_from_continuing">
        <source>Modifying '{0}' which contains the 'stackalloc' operator will prevent the debug session from continuing.</source>
        <target state="translated">Modifikace prvku {0}, který obsahuje operátor stackalloc, zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_an_active_0_which_contains_On_Error_or_Resume_statements_will_prevent_the_debug_session_from_continuing">
        <source>Modifying an active '{0}' which contains 'On Error' or 'Resume' statements will prevent the debug session from continuing.</source>
        <target state="translated">Modifikace aktivního prvku {0}, který obsahuje příkazy On Error nebo Resume, zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_an_Aggregate_Group_By_or_Join_query_clauses_will_prevent_the_debug_session_from_continuing">
        <source>Modifying '{0}' which contains an Aggregate, Group By, or Join query clauses will prevent the debug session from continuing.</source>
        <target state="translated">Pokud se změní {0} obsahující klauzule dotazu Aggregate, Group By nebo Join, zabrání se tím v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_source_with_experimental_language_features_enabled_will_prevent_the_debug_session_from_continuing">
        <source>Modifying source with experimental language features enabled will prevent the debug session from continuing.</source>
        <target state="translated">Modifikace zdroje s aktivovanými experimentálními jazykovými funkcemi zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Updating an active statement will prevent the debug session from continuing.</source>
        <target state="translated">Aktualizace aktivního příkazu zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_0_that_contains_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Removing {0} that contains an active statement will prevent the debug session from continuing.</source>
        <target state="needs-review-translation">Odebrání prvku {0}, který obsahuje aktivní příkaz, zabrání v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_new_file_will_prevent_the_debug_session_from_continuing">
        <source>Adding a new file will prevent the debug session from continuing.</source>
        <target state="translated">Když přidáte nový soubor, relace ladění nebude moct pokračovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="Attribute_0_is_missing_Updating_an_async_method_or_an_iterator_will_prevent_the_debug_session_from_continuing">
        <source>Attribute '{0}' is missing. Updating an async method or an iterator will prevent the debug session from continuing.</source>
        <target state="translated">Chybí atribut {0}. Aktualizace asynchronní metody nebo iterátoru zabrání relaci ladění v pokračování.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unexpected_interface_member_kind_colon_0">
        <source>Unexpected interface member kind: {0}</source>
        <target state="translated">Neočekávaný druh člena rozhraní: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_symbol_kind">
        <source>Unknown symbol kind</source>
        <target state="translated">Neznámý druh symbolu</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_abstract_property_1_0">
        <source>Generate abstract property '{1}.{0}'</source>
        <target state="translated">Generovat abstraktní vlastnost {1}.{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_abstract_method_1_0">
        <source>Generate abstract method '{1}.{0}'</source>
        <target state="translated">Generovat abstraktní metodu {1}.{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_method_1_0">
        <source>Generate method '{1}.{0}'</source>
        <target state="translated">Generovat metodu {1}.{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Requested_assembly_already_loaded_from_0">
        <source>Requested assembly already loaded from '{0}'.</source>
        <target state="translated">Požadované sestavení je už načtené z {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_symbol_does_not_have_an_icon">
        <source>The symbol does not have an icon.</source>
        <target state="translated">Symbol nemá ikonu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Asynchronous_method_cannot_have_ref_out_parameters_colon_bracket_0_bracket">
        <source>Asynchronous method cannot have ref/out parameters : [{0}]</source>
        <target state="translated">Asynchronní metody nemůžou mít parametry ref/out: [{0}].</target>
        <note />
      </trans-unit>
      <trans-unit id="The_member_is_defined_in_metadata">
        <source>The member is defined in metadata.</source>
        <target state="translated">Člen je definovaný v metadatech.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_can_only_change_the_signature_of_a_constructor_indexer_method_or_delegate">
        <source>You can only change the signature of a constructor, indexer, method or delegate.</source>
        <target state="translated">Můžete změnit jenom signaturu konstruktoru, indexeru, metody nebo delegáta.</target>
        <note />
      </trans-unit>
      <trans-unit id="This_symbol_has_related_definitions_or_references_in_metadata_Changing_its_signature_may_result_in_build_errors_Do_you_want_to_continue">
        <source>This symbol has related definitions or references in metadata. Changing its signature may result in build errors.

Do you want to continue?</source>
        <target state="translated">Tento symbol má přidružené definice nebo odkazy v metadatech. Změna jeho podpisu může vést k chybám sestavení.

Chcete pokračovat?</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_signature">
        <source>Change signature...</source>
        <target state="translated">Změnit signaturu...</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_new_type">
        <source>Generate new type...</source>
        <target state="translated">Generovat nový typ...</target>
        <note />
      </trans-unit>
      <trans-unit id="User_Diagnostic_Analyzer_Failure">
        <source>User Diagnostic Analyzer Failure.</source>
        <target state="translated">Selhání uživatelského diagnostického analyzátoru</target>
        <note />
      </trans-unit>
      <trans-unit id="Analyzer_0_threw_an_exception_of_type_1_with_message_2">
        <source>Analyzer '{0}' threw an exception of type '{1}' with message '{2}'.</source>
        <target state="translated">Analyzátor {0} způsobil výjimku typu {1} se zprávou {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Analyzer_0_threw_the_following_exception_colon_1">
        <source>Analyzer '{0}' threw the following exception:
'{1}'.</source>
        <target state="translated">Analyzátor {0} vrátil následující výjimku:
{1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Simplify_Names">
        <source>Simplify Names</source>
        <target state="translated">Zjednodušit názvy</target>
        <note />
      </trans-unit>
      <trans-unit id="Simplify_Member_Access">
        <source>Simplify Member Access</source>
        <target state="translated">Zjednodušit přístup ke členům</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_qualification">
        <source>Remove qualification</source>
        <target state="translated">Odebrat kvalifikaci</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_error_occurred">
        <source>Unknown error occurred</source>
        <target state="translated">Došlo k neznámé chybě.</target>
        <note />
      </trans-unit>
      <trans-unit id="Available">
        <source>Available</source>
        <target state="translated">K dispozici</target>
        <note />
      </trans-unit>
      <trans-unit id="Not_Available">
        <source>Not Available ⚠</source>
        <target state="needs-review-translation">Není k dispozici</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_1">
        <source>    {0} - {1}</source>
        <target state="translated">    {0} – {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="in_Source">
        <source>in Source</source>
        <target state="translated">ve zdroji</target>
        <note />
      </trans-unit>
      <trans-unit id="in_Suppression_File">
        <source>in Suppression File</source>
        <target state="translated">V souboru potlačení</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_Suppression_0">
        <source>Remove Suppression {0}</source>
        <target state="translated">Odebrat potlačení {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_Suppression">
        <source>Remove Suppression</source>
        <target state="translated">Odebrat potlačení</target>
        <note />
      </trans-unit>
      <trans-unit id="Pending">
        <source>&lt;Pending&gt;</source>
        <target state="translated">&lt;Čeká&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="Note_colon_Tab_twice_to_insert_the_0_snippet">
        <source>Note: Tab twice to insert the '{0}' snippet.</source>
        <target state="translated">Poznámka: Pro vložení fragmentu {0} stiskněte dvakrát tabulátor.</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_interface_explicitly_with_Dispose_pattern">
        <source>Implement interface explicitly with Dispose pattern</source>
        <target state="translated">Implementovat rozhraní explicitně se vzorem Dispose</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_interface_with_Dispose_pattern">
        <source>Implement interface with Dispose pattern</source>
        <target state="translated">Implementovat rozhraní se vzorem Dispose</target>
        <note />
      </trans-unit>
      <trans-unit id="Re_triage_0_currently_1">
        <source>Re-triage {0}(currently '{1}')</source>
        <target state="translated">Nové určení priorit podle dostupnosti zdrojů {0}(aktuálně {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="Argument_cannot_have_a_null_element">
        <source>Argument cannot have a null element.</source>
        <target state="translated">Argument nemůže mít element, který je null.</target>
        <note />
      </trans-unit>
      <trans-unit id="Argument_cannot_be_empty">
        <source>Argument cannot be empty.</source>
        <target state="translated">Argument nemůže být prázdný.</target>
        <note />
      </trans-unit>
      <trans-unit id="Reported_diagnostic_with_ID_0_is_not_supported_by_the_analyzer">
        <source>Reported diagnostic with ID '{0}' is not supported by the analyzer.</source>
        <target state="translated">Ohlášená diagnostika s ID {0} se v analyzátoru nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Computing_fix_all_occurrences_code_fix">
        <source>Computing fix all occurrences code fix...</source>
        <target state="translated">Vypočítává se oprava kódu pro opravu všech výskytů...</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_occurrences">
        <source>Fix all occurrences</source>
        <target state="translated">Opravit všechny výskyty</target>
        <note />
      </trans-unit>
      <trans-unit id="Document">
        <source>Document</source>
        <target state="translated">Dokument</target>
        <note />
      </trans-unit>
      <trans-unit id="Project">
        <source>Project</source>
        <target state="translated">Projekt</target>
        <note />
      </trans-unit>
      <trans-unit id="Solution">
        <source>Solution</source>
        <target state="translated">Řešení</target>
        <note />
      </trans-unit>
      <trans-unit id="TODO_colon_dispose_managed_state_managed_objects">
        <source>TODO: dispose managed state (managed objects)</source>
        <target state="translated">TODO: Uvolněte spravovaný stav (spravované objekty).</target>
        <note />
      </trans-unit>
      <trans-unit id="TODO_colon_set_large_fields_to_null">
        <source>TODO: set large fields to null</source>
        <target state="translated">TODO: Nastavte velká pole na hodnotu null.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_a_static_variable_will_prevent_the_debug_session_from_continuing">
        <source>Modifying '{0}' which contains a static variable will prevent the debug session from continuing.</source>
        <target state="translated">Pokud se změní {0} obsahující statickou proměnnou, zabrání se tím v pokračování relace ladění.</target>
        <note />
      </trans-unit>
      <trans-unit id="Compiler2">
        <source>Compiler</source>
        <target state="translated">Kompilátor</target>
        <note />
      </trans-unit>
      <trans-unit id="Live">
        <source>Live</source>
        <target state="translated">Živě</target>
        <note />
      </trans-unit>
      <trans-unit id="enum_value">
        <source>enum value</source>
        <target state="translated">hodnota enum</target>
        <note>{Locked="enum"} "enum" is a C#/VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="const_field">
        <source>const field</source>
        <target state="translated">Pole const</target>
        <note>{Locked="const"} "const" is a C#/VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="method">
        <source>method</source>
        <target state="translated">metoda</target>
        <note />
      </trans-unit>
      <trans-unit id="operator_">
        <source>operator</source>
        <target state="translated">operátor</target>
        <note />
      </trans-unit>
      <trans-unit id="constructor">
        <source>constructor</source>
        <target state="translated">konstruktor</target>
        <note />
      </trans-unit>
      <trans-unit id="auto_property">
        <source>auto-property</source>
        <target state="translated">automatická vlastnost</target>
        <note />
      </trans-unit>
      <trans-unit id="property_">
        <source>property</source>
        <target state="translated">vlastnost</target>
        <note />
      </trans-unit>
      <trans-unit id="event_accessor">
        <source>event accessor</source>
        <target state="translated">přístupový objekt události</target>
        <note />
      </trans-unit>
      <trans-unit id="rfc1123_date_time">
        <source>rfc1123 date/time</source>
        <target state="translated">datum a čas rfc1123</target>
        <note />
      </trans-unit>
      <trans-unit id="rfc1123_date_time_description">
        <source>The "R" or "r" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.RFC1123Pattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'". When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.</source>
        <target state="translated">Specifikátory standardního formátu R nebo r představují řetězec vlastního formátu data a času, který se definuje pomocí vlastnosti DateTimeFormatInfo.RFC1123Pattern. Vzor dodržuje definovaný standard a vlastnost je určená jen pro čtení. Proto je vždy stejná, bez ohledu na používanou jazykovou verzi nebo zadaného poskytovatele formátu. Řetězec vlastního formátu je ddd, dd MMM yyyy HH':'mm':'ss 'GMT'. Když se tento specifikátor standardního formátu použije, operace formátování nebo parsování vždy použije invariantní jazykovou verzi.</target>
        <note />
      </trans-unit>
      <trans-unit id="round_trip_date_time">
        <source>round-trip date/time</source>
        <target state="translated">datum a čas typu round-trip</target>
        <note />
      </trans-unit>
      <trans-unit id="round_trip_date_time_description">
        <source>The "O" or "o" standard format specifier represents a custom date and time format string using a pattern that preserves time zone information and emits a result string that complies with ISO 8601. For DateTime values, this format specifier is designed to preserve date and time values along with the DateTime.Kind property in text. The formatted string can be parsed back by using the DateTime.Parse(String, IFormatProvider, DateTimeStyles) or DateTime.ParseExact method if the styles parameter is set to DateTimeStyles.RoundtripKind.

The "O" or "o" standard format specifier corresponds to the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" custom format string for DateTime values and to the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffzzz" custom format string for DateTimeOffset values. In this string, the pairs of single quotation marks that delimit individual characters, such as the hyphens, the colons, and the letter "T", indicate that the individual character is a literal that cannot be changed. The apostrophes do not appear in the output string.

The "O" or "o" standard format specifier (and the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" custom format string) takes advantage of the three ways that ISO 8601 represents time zone information to preserve the Kind property of DateTime values:

    The time zone component of DateTimeKind.Local date and time values is an offset from UTC (for example, +01:00, -07:00). All DateTimeOffset values are also represented in this format.

    The time zone component of DateTimeKind.Utc date and time values uses "Z" (which stands for zero offset) to represent UTC.

    DateTimeKind.Unspecified date and time values have no time zone information.

Because the "O" or "o" standard format specifier conforms to an international standard, the formatting or parsing operation that uses the specifier always uses the invariant culture and the Gregorian calendar.

Strings that are passed to the Parse, TryParse, ParseExact, and TryParseExact methods of DateTime and DateTimeOffset can be parsed by using the "O" or "o" format specifier if they are in one of these formats. In the case of DateTime objects, the parsing overload that you call should also include a styles parameter with a value of DateTimeStyles.RoundtripKind. Note that if you call a parsing method with the custom format string that corresponds to the "O" or "o" format specifier, you won't get the same results as "O" or "o". This is because parsing methods that use a custom format string can't parse the string representation of date and time values that lack a time zone component or use "Z" to indicate UTC.</source>
        <target state="translated">Specifikátory standardního formátu O nebo o představují řetězec vlastního formátu data a času, který používá vzor, který zachovává informaci o časovém pásmu a generuje výsledný řetězec podle standardu ISO 8601. Pro hodnoty DateTime je tento specifikátor formátu navržený tak, aby v textu zachoval hodnoty data a času spolu s vlastností DateTime.Kind. Pokud se parametr styles nastaví na DateTimeStyles.RoundtripKind, formátovaný řetězec se dá parsovat zpět pomocí metod DateTime.Parse(String, IFormatProvider, DateTimeStyles) nebo DateTime.ParseExact.

Specifikátory standardního formátu O nebo o odpovídají řetězci vlastního formátu yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK pro hodnoty DateTime a řetězci vlastního formátu yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffzzz pro hodnoty DateTimeOffset. V tomto řetězci dvojice jednoduchých uvozovek, které oddělují jednotlivé znaky (třeba spojovníky, dvojtečky a písmeno T), označují, že jednotlivé znaky jsou literály a nedají se změnit. Apostrofy se ve výstupním řetězci nezobrazují.

Specifikátory vlastního formátu O nebo o (a řetězec vlastního formátu yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK) využívá tři způsoby, kterými standard ISO 8601 reprezentuje informace o časovém pásmu, aby se zachovala vlastnost Kind hodnot DateTime:

    Složka časového pásma hodnot data a času DateTimeKind.Local je posun oproti UTC (například +01:00, -07:00). V tomto formátu se reprezentují všechny hodnoty DateTimeOffset.

    Složka časového pásma hodnot data a času DateTimeKind.Utc používá Z (což znamená nulový (zero) posun), pomocí kterého představuje čas UTC.

    Hodnoty data a času DateTimeKind.Unspecified nemají žádnou informaci o časovém pásmu.

Vzhledem k tomu, že specifikátory standardního formátu O nebo o dodržují mezinárodní standard, operace formátování nebo parsování, která daný specifikátor používá, vždy používá invariantní jazykovou verzi a Gregoriánský kalendář.

Řetězce, které se předávají metodám Parse, TryParse, ParseExact a TryParseExact typů DateTime a DateTimeOffset, se dají pomocí specifikátoru formátu O nebo o parsovat v případě, že mají jeden z těchto formátů. V případě objektů DateTime by přetížení parsování, které zavoláte, mělo navíc zahrnovat parametr styles s hodnotou DateTimeStyles.RoundtripKind. Poznámka: Pokud metodu parsování zavoláte s řetězcem vlastního formátu, který odpovídá specifikátoru formátu O nebo o, nedostanete výsledky shodné s O nebo o. Důvodem je to, že metody parsování, které používají řetězec vlastního formátu, nemůžou parsovat řetězcové reprezentace hodnot data a času, kterým chybí složka časového pásma nebo které označují UTC pomocí Z.</target>
        <note />
      </trans-unit>
      <trans-unit id="second_1_2_digits">
        <source>second (1-2 digits)</source>
        <target state="translated">sekunda (1–2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="second_1_2_digits_description">
        <source>The "s" custom format specifier represents the seconds as a number from 0 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted without a leading zero.

If the "s" format specifier is used without other custom format specifiers, it's interpreted as the "s" standard date and time format specifier.</source>
        <target state="translated">Specifikátor vlastního formátu s reprezentuje sekundy jako číslo od 0 do 59. Výsledek představuje celé sekundy, které uplynuly od poslední minuty. Sekunda s jednou číslicí se formátuje bez nuly na začátku.

Pokud se specifikátor formátu s použije bez dalších specifikátorů vlastního formátu, interpretuje se jako standardní specifikátor formátu data a času s.</target>
        <note />
      </trans-unit>
      <trans-unit id="second_2_digits">
        <source>second (2 digits)</source>
        <target state="translated">sekunda (2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="second_2_digits_description">
        <source>The "ss" custom format specifier (plus any number of additional "s" specifiers) represents the seconds as a number from 00 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted with a leading zero.</source>
        <target state="translated">Specifikátor vlastního formátu ss (a libovolný počet dalších specifikátorů s) reprezentuje sekundu jako číslo od 00 do 59. Výsledek představuje celé sekundy, které uplynuly od poslední minuty. Sekunda s jednou číslicí se formátuje s nulou na začátku.</target>
        <note />
      </trans-unit>
      <trans-unit id="short_date">
        <source>short date</source>
        <target state="translated">krátké datum</target>
        <note />
      </trans-unit>
      <trans-unit id="short_date_description">
        <source>The "d" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.ShortDatePattern property. For example, the custom format string that is returned by the ShortDatePattern property of the invariant culture is "MM/dd/yyyy".</source>
        <target state="translated">Specifikátor standardního formátu d představuje řetězec vlastního formátu data a času, který se definuje pomocí vlastnosti DateTimeFormatInfo.ShortDatePattern konkrétní jazykové verze. Například řetězec vlastního formátu, který se vrátí pomocí vlastnosti ShortDatePattern pro invariantní jazykovou verzi, je MM/dd/yyyy.</target>
        <note />
      </trans-unit>
      <trans-unit id="short_time">
        <source>short time</source>
        <target state="translated">krátký čas</target>
        <note />
      </trans-unit>
      <trans-unit id="short_time_description">
        <source>The "t" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.ShortTimePattern property. For example, the custom format string for the invariant culture is "HH:mm".</source>
        <target state="translated">Specifikátor standardního formátu t představuje řetězec vlastního formátu data a času, který se definuje pomocí aktuální vlastnosti DateTimeFormatInfo.ShortTimePattern. Například řetězec vlastního formátu pro invariantní jazykovou verzi je HH:mm.</target>
        <note />
      </trans-unit>
      <trans-unit id="sortable_date_time">
        <source>sortable date/time</source>
        <target state="translated">seřaditelné datum a čas</target>
        <note />
      </trans-unit>
      <trans-unit id="sortable_date_time_description">
        <source>The "s" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.SortableDateTimePattern property. The pattern reflects a defined standard (ISO 8601), and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "yyyy'-'MM'-'dd'T'HH':'mm':'ss".

The purpose of the "s" format specifier is to produce result strings that sort consistently in ascending or descending order based on date and time values. As a result, although the "s" standard format specifier represents a date and time value in a consistent format, the formatting operation does not modify the value of the date and time object that is being formatted to reflect its DateTime.Kind property or its DateTimeOffset.Offset value. For example, the result strings produced by formatting the date and time values 2014-11-15T18:32:17+00:00 and 2014-11-15T18:32:17+08:00 are identical.

When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.</source>
        <target state="translated">Specifikátor standardního formátu s představuje řetězec vlastního formátu data a času, který se definuje pomocí vlastnosti DateTimeFormatInfo.SortableDateTimePattern. Vzor dodržuje definovaný standard (ISO 8601) a vlastnost je určená jen pro čtení. Proto je vždy stejná, bez ohledu na používanou jazykovou verzi nebo zadaného poskytovatele formátu. Řetězec vlastního formátu je yyyy'-'MM'-'dd'T'HH':'mm':'ss.

Účelem specifikátoru formátu s je vytvořit výsledné řetězce, které budou konzistentně seřazené vzestupně nebo sestupně podle hodnot data a času. Z toho důvodu operace formátování neupraví hodnotu formátovaného objektu data a času tak, aby odrážela vlastnost DateTime.Kind nebo její vlastnost DateTimeOffset.Offset, i když specifikátor standardního formátu s představuje hodnotu data a času v konzistentním formátu. Například výsledné řetězce vytvořené formátováním hodnot data a času 2014-11-15T18:32:17+00:00 a 2014-11-15T18:32:17+08:00 jsou totožné.

Když se tento specifikátor standardního formátu použije, operace formátování nebo parsování vždy použije invariantní jazykovou verzi.</target>
        <note />
      </trans-unit>
      <trans-unit id="static_constructor">
        <source>static constructor</source>
        <target state="new">static constructor</target>
        <note />
      </trans-unit>
      <trans-unit id="symbol_cannot_be_a_namespace">
        <source>'symbol' cannot be a namespace.</source>
        <target state="translated">'Symbol nemůže být obor názvů.</target>
        <note />
      </trans-unit>
      <trans-unit id="time_separator">
        <source>time separator</source>
        <target state="translated">oddělovač času</target>
        <note />
      </trans-unit>
      <trans-unit id="time_separator_description">
        <source>The ":" custom format specifier represents the time separator, which is used to differentiate hours, minutes, and seconds. The appropriate localized time separator is retrieved from the DateTimeFormatInfo.TimeSeparator property of the current or specified culture.

Note: To change the time separator for a particular date and time string, specify the separator character within a literal string delimiter. For example, the custom format string hh'_'dd'_'ss produces a result string in which "_" (an underscore) is always used as the time separator. To change the time separator for all dates for a culture, either change the value of the DateTimeFormatInfo.TimeSeparator property of the current culture, or instantiate a DateTimeFormatInfo object, assign the character to its TimeSeparator property, and call an overload of the formatting method that includes an IFormatProvider parameter.

If the ":" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">Specifikátor vlastního formátu : představuje oddělovač času, pomocí kterého se odlišují hodiny, minuty a sekundy. Správný lokalizovaný oddělovač data se načítá z vlastnosti DateTimeFormatInfo.TimeSeparator aktuální nebo zadané jazykové verze.

Poznámka: Pokud chcete změnit oddělovač času pro konkrétní řetězec data a času, zadejte znak oddělovače v oddělovači literálního řetězce. Například řetězec s vlastním formátem hh'_'dd'_'ss vytvoří výsledný řetězec, ve kterém se _ (podtržítko) vždy použije jako oddělovač času. Pokud chcete oddělovač času změnit pro všechna data v jazykové verzi, buď změňte hodnotu vlastnosti DateTimeFormatInfo.TimeSeparator aktuální jazykové verze, nebo vytvořte instanci objektu DateTimeFormatInfo, přiřaďte znak do jeho vlastnosti TimeSeparator a zavolejte přetížení metody formátování, která zahrnuje parametr IFormatProvider.

Pokud se specifikátor formátu : použije bez dalších specifikátorů vlastního formátu, interpretuje se jako standardní specifikátor formátu data a času a vyvolá FormatException.</target>
        <note />
      </trans-unit>
      <trans-unit id="time_zone">
        <source>time zone</source>
        <target state="translated">časové pásmo</target>
        <note />
      </trans-unit>
      <trans-unit id="time_zone_description">
        <source>The "K" custom format specifier represents the time zone information of a date and time value. When this format specifier is used with DateTime values, the result string is defined by the value of the DateTime.Kind property:

    For the local time zone (a DateTime.Kind property value of DateTimeKind.Local), this specifier is equivalent to the "zzz" specifier and produces a result string containing the local offset from Coordinated Universal Time (UTC); for example, "-07:00".

    For a UTC time (a DateTime.Kind property value of DateTimeKind.Utc), the result string includes a "Z" character to represent a UTC date.

    For a time from an unspecified time zone (a time whose DateTime.Kind property equals DateTimeKind.Unspecified), the result is equivalent to String.Empty.

For DateTimeOffset values, the "K" format specifier is equivalent to the "zzz" format specifier, and produces a result string containing the DateTimeOffset value's offset from UTC.

If the "K" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">Specifikátor vlastního formátu K představuje informaci o časovém pásmu hodnoty data a času. Když se tento specifikátor formátu použije spolu s hodnotami DateTime, výsledný řetězec je definovaný hodnotou vlastnosti DateTime.Kind:

    Pro místní časové pásmo (hodnota vlastnosti DateTime.Kind DateTimeKind.Local) je tento specifikátor ekvivalentní specifikátoru zzz a vytvoří výsledný řetězec, který bude obsahovat místní posun od koordinovaného univerzálního času (UTC), třeba -07:00.

    Pro čas UTC (hodnota vlastnosti DateTime.Kind DateTimeKind.Utc) výsledný řetězec zahrnuje znak Z, který představuje datum UTC.

    Pro čas z neurčeného časového pásma (čas, jehož vlastnost DateTime.Kind se rovná DateTimeKind.Unspecified) je výsledek ekvivalentní k String.Empty.

Pro hodnoty DateTimeOffset je specifikátor formátu K ekvivalentní specifikátoru formátu zzz a vytváří výsledný řetězec, který obsahuje posun hodnoty DateTimeOffset proti UTC.

Pokud se specifikátor formátu K použije bez dalších specifikátorů vlastního formátu, interpretuje se jako standardní specifikátor formátu data a času a vyvolá FormatException.</target>
        <note />
      </trans-unit>
      <trans-unit id="type_constraint">
        <source>type constraint</source>
        <target state="translated">omezení typu</target>
        <note />
      </trans-unit>
      <trans-unit id="type_parameter">
        <source>type parameter</source>
        <target state="translated">parametr typu</target>
        <note />
      </trans-unit>
      <trans-unit id="attribute">
        <source>attribute</source>
        <target state="translated">atribut</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_and_1_with_property">
        <source>Replace '{0}' and '{1}' with property</source>
        <target state="translated">Nahradit {0} a {1} vlastností</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_property">
        <source>Replace '{0}' with property</source>
        <target state="translated">Nahradit {0} vlastností</target>
        <note />
      </trans-unit>
      <trans-unit id="Method_referenced_implicitly">
        <source>Method referenced implicitly</source>
        <target state="translated">Implicitně odkazovaná metoda</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_type_0">
        <source>Generate type '{0}'</source>
        <target state="translated">Generovat typ {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_0_1">
        <source>Generate {0} '{1}'</source>
        <target state="translated">Generovat {0} {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_0_to_1">
        <source>Change '{0}' to '{1}'.</source>
        <target state="translated">Změnit {0} na {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Non_invoked_method_cannot_be_replaced_with_property">
        <source>Non-invoked method cannot be replaced with property.</source>
        <target state="translated">Nevyvolávaná metoda nejde nahradit vlastností.</target>
        <note />
      </trans-unit>
      <trans-unit id="Only_methods_with_a_single_argument_which_is_not_an_out_variable_declaration_can_be_replaced_with_a_property">
        <source>Only methods with a single argument, which is not an out variable declaration, can be replaced with a property.</source>
        <target state="translated">Vlastností jdou nahradit jenom metody s jedním argumentem, který nepředstavuje deklaraci externí proměnné.</target>
        <note />
      </trans-unit>
      <trans-unit id="Roslyn_HostError">
        <source>Roslyn.HostError</source>
        <target state="translated">Roslyn.HostError</target>
        <note />
      </trans-unit>
      <trans-unit id="An_instance_of_analyzer_0_cannot_be_created_from_1_colon_2">
        <source>An instance of analyzer {0} cannot be created from {1}: {2}.</source>
        <target state="translated">Instance analyzátoru {0} nejde vytvořit z {1}: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_assembly_0_does_not_contain_any_analyzers">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">Sestavení {0} neobsahuje žádné analyzátory.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unable_to_load_Analyzer_assembly_0_colon_1">
        <source>Unable to load Analyzer assembly {0}: {1}</source>
        <target state="translated">Nejde načíst sestavení analyzátoru {0}: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Make_method_synchronous">
        <source>Make method synchronous</source>
        <target state="translated">Nastavit metodu jako synchronní</target>
        <note />
      </trans-unit>
      <trans-unit id="from_0">
        <source>from {0}</source>
        <target state="translated">z: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Find_and_install_latest_version">
        <source>Find and install latest version</source>
        <target state="translated">Najít a nainstalovat nejnovější verzi</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_local_version_0">
        <source>Use local version '{0}'</source>
        <target state="translated">Použít místní verzi {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_locally_installed_0_version_1_This_version_used_in_colon_2">
        <source>Use locally installed '{0}' version '{1}'
This version used in: {2}</source>
        <target state="translated">Použít místně nainstalovanou {0} verzi {1}.
Tato verze se používá zde: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Find_and_install_latest_version_of_0">
        <source>Find and install latest version of '{0}'</source>
        <target state="translated">Najít a nainstalovat nejnovější verzi aplikace {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_with_package_manager">
        <source>Install with package manager...</source>
        <target state="translated">Nainstalovat s použitím Správce balíčků...</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_0_1">
        <source>Install '{0} {1}'</source>
        <target state="translated">Nainstalovat {0} {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_version_0">
        <source>Install version '{0}'</source>
        <target state="translated">Nainstalovat verzi {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_variable_0">
        <source>Generate variable '{0}'</source>
        <target state="translated">Generovat proměnnou {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes">
        <source>Classes</source>
        <target state="translated">Třídy</target>
        <note />
      </trans-unit>
      <trans-unit id="Constants">
        <source>Constants</source>
        <target state="translated">Konstanty</target>
        <note />
      </trans-unit>
      <trans-unit id="Delegates">
        <source>Delegates</source>
        <target state="translated">Delegáti</target>
        <note />
      </trans-unit>
      <trans-unit id="Enums">
        <source>Enums</source>
        <target state="translated">Výčty</target>
        <note />
      </trans-unit>
      <trans-unit id="Events">
        <source>Events</source>
        <target state="translated">Události</target>
        <note />
      </trans-unit>
      <trans-unit id="Extension_methods">
        <source>Extension methods</source>
        <target state="translated">Metody rozšíření</target>
        <note />
      </trans-unit>
      <trans-unit id="Fields">
        <source>Fields</source>
        <target state="translated">Pole</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces">
        <source>Interfaces</source>
        <target state="translated">Rozhraní</target>
        <note />
      </trans-unit>
      <trans-unit id="Locals">
        <source>Locals</source>
        <target state="translated">Místní hodnoty</target>
        <note />
      </trans-unit>
      <trans-unit id="Methods">
        <source>Methods</source>
        <target state="translated">Metody</target>
        <note />
      </trans-unit>
      <trans-unit id="Modules">
        <source>Modules</source>
        <target state="translated">Moduly</target>
        <note />
      </trans-unit>
      <trans-unit id="Namespaces">
        <source>Namespaces</source>
        <target state="translated">Obory názvů</target>
        <note />
      </trans-unit>
      <trans-unit id="Properties">
        <source>Properties</source>
        <target state="translated">Vlastnosti</target>
        <note />
      </trans-unit>
      <trans-unit id="Structures">
        <source>Structures</source>
        <target state="translated">Struktury</target>
        <note />
      </trans-unit>
      <trans-unit id="Parameters_colon">
        <source>Parameters:</source>
        <target state="translated">Parametry:</target>
        <note />
      </trans-unit>
      <trans-unit id="Variadic_SignatureHelpItem_must_have_at_least_one_parameter">
        <source>Variadic SignatureHelpItem must have at least one parameter.</source>
        <target state="translated">Variadické SignatureHelpItem musí mít nejmíň jeden parametr.</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_method">
        <source>Replace '{0}' with method</source>
        <target state="translated">Nahradit {0} metodou</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_methods">
        <source>Replace '{0}' with methods</source>
        <target state="translated">Nahradit {0} metodami</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_referenced_implicitly">
        <source>Property referenced implicitly</source>
        <target state="translated">Na vlastnost se odkazuje implicitně.</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_cannot_safely_be_replaced_with_a_method_call">
        <source>Property cannot safely be replaced with a method call</source>
        <target state="translated">Vlastnost se nedá bezpečně nahradit voláním metody.</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_interpolated_string">
        <source>Convert to interpolated string</source>
        <target state="translated">Převést na interpolovaný řetězec</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_type_to_0">
        <source>Move type to {0}</source>
        <target state="translated">Přesunout typ do {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Rename_file_to_0">
        <source>Rename file to {0}</source>
        <target state="translated">Přejmenovat soubor na {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Rename_type_to_0">
        <source>Rename type to {0}</source>
        <target state="translated">Přejmenovat typ na {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_tag">
        <source>Remove tag</source>
        <target state="translated">Odebrat značku</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_missing_param_nodes">
        <source>Add missing param nodes</source>
        <target state="translated">Přidat chybějící uzly parametrů</target>
        <note />
      </trans-unit>
      <trans-unit id="Make_containing_scope_async">
        <source>Make containing scope async</source>
        <target state="translated">Převést obsažený obor na asynchronní</target>
        <note />
      </trans-unit>
      <trans-unit id="Make_containing_scope_async_return_Task">
        <source>Make containing scope async (return Task)</source>
        <target state="translated">Převést obsažený obor na asynchronní (návratová hodnota Task)</target>
        <note />
      </trans-unit>
      <trans-unit id="paren_Unknown_paren">
        <source>(Unknown)</source>
        <target state="translated">(neznámé)</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_framework_type">
        <source>Use framework type</source>
        <target state="translated">Použít typ architektury</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_package_0">
        <source>Install package '{0}'</source>
        <target state="translated">Nainstalovat balíček {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="project_0">
        <source>project {0}</source>
        <target state="translated">projekt {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Fully_qualify_0">
        <source>Fully qualify '{0}'</source>
        <target state="translated">Plně kvalifikovat: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_reference_to_0">
        <source>Remove reference to '{0}'.</source>
        <target state="translated">Odebrat odkaz na {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Keywords">
        <source>Keywords</source>
        <target state="translated">Klíčová slova</target>
        <note />
      </trans-unit>
      <trans-unit id="Snippets">
        <source>Snippets</source>
        <target state="translated">Fragmenty</target>
        <note />
      </trans-unit>
      <trans-unit id="All_lowercase">
        <source>All lowercase</source>
        <target state="translated">Všechna písmena malá</target>
        <note />
      </trans-unit>
      <trans-unit id="All_uppercase">
        <source>All uppercase</source>
        <target state="translated">Všechna písmena velká</target>
        <note />
      </trans-unit>
      <trans-unit id="First_word_capitalized">
        <source>First word capitalized</source>
        <target state="translated">Velké první písmeno prvního slova</target>
        <note />
      </trans-unit>
      <trans-unit id="Pascal_Case">
        <source>Pascal Case</source>
        <target state="translated">PascalCase</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_document_0">
        <source>Remove document '{0}'</source>
        <target state="translated">Odebrat dokument {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_document_0">
        <source>Add document '{0}'</source>
        <target state="translated">Přidat dokument {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_argument_name_0">
        <source>Add argument name '{0}'</source>
        <target state="translated">Přidat název argumentu {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Take_0">
        <source>Take '{0}'</source>
        <target state="translated">Vzít {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Take_both">
        <source>Take both</source>
        <target state="translated">Vzít obojí</target>
        <note />
      </trans-unit>
      <trans-unit id="Take_bottom">
        <source>Take bottom</source>
        <target state="translated">Vzít dolní</target>
        <note />
      </trans-unit>
      <trans-unit id="Take_top">
        <source>Take top</source>
        <target state="translated">Vzít horní</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unused_variable">
        <source>Remove unused variable</source>
        <target state="translated">Odebrat nepoužívanou proměnnou</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_binary">
        <source>Convert to binary</source>
        <target state="translated">Převést do binární soustavy</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_decimal">
        <source>Convert to decimal</source>
        <target state="translated">Převést do desítkové soustavy</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_hex">
        <source>Convert to hex</source>
        <target state="translated">Převést do šestnáctkové soustavy</target>
        <note />
      </trans-unit>
      <trans-unit id="Separate_thousands">
        <source>Separate thousands</source>
        <target state="translated">Oddělit tisíce</target>
        <note />
      </trans-unit>
      <trans-unit id="Separate_words">
        <source>Separate words</source>
        <target state="translated">Oddělit slova</target>
        <note />
      </trans-unit>
      <trans-unit id="Separate_nibbles">
        <source>Separate nibbles</source>
        <target state="translated">Oddělit nibbly</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_separators">
        <source>Remove separators</source>
        <target state="translated">Odebrat oddělovače</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_parameter_to_0">
        <source>Add parameter to '{0}'</source>
        <target state="translated">Přidat parametr do {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constructor">
        <source>Generate constructor...</source>
        <target state="translated">Generovat konstruktor...</target>
        <note />
      </trans-unit>
      <trans-unit id="Pick_members_to_be_used_as_constructor_parameters">
        <source>Pick members to be used as constructor parameters</source>
        <target state="translated">Vyberte členy, kteří se mají použít jako parametry konstruktoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="Pick_members_to_be_used_in_Equals_GetHashCode">
        <source>Pick members to be used in Equals/GetHashCode</source>
        <target state="translated">Vyberte členy, kteří se mají použít v Equals/GetHashCode.</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_overrides">
        <source>Generate overrides...</source>
        <target state="translated">Generovat přepsání...</target>
        <note />
      </trans-unit>
      <trans-unit id="Pick_members_to_override">
        <source>Pick members to override</source>
        <target state="translated">Vyberte členy, které chcete přepsat.</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_null_check">
        <source>Add null check</source>
        <target state="translated">Přidat kontrolu hodnot null</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_string_IsNullOrEmpty_check">
        <source>Add 'string.IsNullOrEmpty' check</source>
        <target state="translated">Přidat kontrolu metody string.IsNullOrEmpty</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_string_IsNullOrWhiteSpace_check">
        <source>Add 'string.IsNullOrWhiteSpace' check</source>
        <target state="translated">Přidat kontrolu metody string.IsNullOrWhiteSpace</target>
        <note />
      </trans-unit>
      <trans-unit id="Initialize_field_0">
        <source>Initialize field '{0}'</source>
        <target state="translated">Inicializovat pole {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Initialize_property_0">
        <source>Initialize property '{0}'</source>
        <target state="translated">Inicializovat vlastnost {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_null_checks">
        <source>Add null checks</source>
        <target state="translated">Přidat kontroly hodnot null</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_operators">
        <source>Generate operators</source>
        <target state="translated">Generovat operátory</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_0">
        <source>Implement {0}</source>
        <target state="translated">Implementovat {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Reported_diagnostic_0_has_a_source_location_in_file_1_which_is_not_part_of_the_compilation_being_analyzed">
        <source>Reported diagnostic '{0}' has a source location in file '{1}', which is not part of the compilation being analyzed.</source>
        <target state="translated">Zdroj vykazované diagnostiky {0} je umístěný v souboru {1}, který není součástí analyzované kompilace.</target>
        <note />
      </trans-unit>
      <trans-unit id="Reported_diagnostic_0_has_a_source_location_1_in_file_2_which_is_outside_of_the_given_file">
        <source>Reported diagnostic '{0}' has a source location '{1}' in file '{2}', which is outside of the given file.</source>
        <target state="translated">Zdroj vykazované diagnostiky {0} má umístění {1} v souboru {2}, což je mimo daný soubor.</target>
        <note />
      </trans-unit>
      <trans-unit id="in_0_project_1">
        <source>in {0} (project {1})</source>
        <target state="translated">v {0} (projekt {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_accessibility_modifiers">
        <source>Add accessibility modifiers</source>
        <target state="translated">Přidat Modifikátory dostupnosti</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_declaration_near_reference">
        <source>Move declaration near reference</source>
        <target state="translated">Přesunout deklaraci do blízkosti odkazu</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_full_property">
        <source>Convert to full property</source>
        <target state="translated">Převést na celou vlastnost</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_Method_overrides_symbol_from_metadata">
        <source>Warning: Method overrides symbol from metadata</source>
        <target state="translated">Upozornění: Metoda potlačí symbol z metadat.</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_0">
        <source>Use {0}</source>
        <target state="translated">Použít {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Switching_between_lambda_and_local_function_will_prevent_the_debug_session_from_continuing">
        <source>Switching between a lambda and a local function will prevent the debug session from continuing.</source>
        <target state="translated">Přepínání mezi lambda a lokální funkcí zabrání v pokračování ladicí relace.</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_argument_name_0_including_trailing_arguments">
        <source>Add argument name '{0}' (including trailing arguments)</source>
        <target state="translated">Přidat název argumentu {0} (včetně koncových argumentů)</target>
        <note />
      </trans-unit>
      <trans-unit id="local_function">
        <source>local function</source>
        <target state="translated">lokální funkce</target>
        <note />
      </trans-unit>
      <trans-unit id="indexer_">
        <source>indexer</source>
        <target state="translated">indexer</target>
        <note />
      </trans-unit>
      <trans-unit id="Alias_ambiguous_type_0">
        <source>Alias ambiguous type '{0}'</source>
        <target state="translated">Alias nejednoznačného typu {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_Collection_was_modified_during_iteration">
        <source>Warning: Collection was modified during iteration.</source>
        <target state="translated">Upozornění: Během iterace se kolekce změnila.</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_Iteration_variable_crossed_function_boundary">
        <source>Warning: Iteration variable crossed function boundary.</source>
        <target state="translated">Upozornění: Proměnná iterace překročila hranici funkce.</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_Collection_may_be_modified_during_iteration">
        <source>Warning: Collection may be modified during iteration.</source>
        <target state="translated">Upozornění: Během iterace se kolekce může změnit.</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_full_date_time">
        <source>universal full date/time</source>
        <target state="translated">univerzální datum a čas</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_full_date_time_description">
        <source>The "U" standard format specifier represents a custom date and time format string that is defined by a specified culture's DateTimeFormatInfo.FullDateTimePattern property. The pattern is the same as the "F" pattern. However, the DateTime value is automatically converted to UTC before it is formatted.</source>
        <target state="translated">Specifikátor standardního formátu U představuje řetězec vlastního formátu data a času definovaný vlastností DateTimeFormatInfo.FullDateTimePattern konkrétní jazykové verze. Vzor je stejný jako vzor F. Hodnota DateTime se ale před formátováním automaticky převede na UTC.</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_sortable_date_time">
        <source>universal sortable date/time</source>
        <target state="translated">univerzální seřaditelné datum a čas</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_sortable_date_time_description">
        <source>The "u" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.UniversalSortableDateTimePattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "yyyy'-'MM'-'dd HH':'mm':'ss'Z'". When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.

Although the result string should express a time as Coordinated Universal Time (UTC), no conversion of the original DateTime value is performed during the formatting operation. Therefore, you must convert a DateTime value to UTC by calling the DateTime.ToUniversalTime method before formatting it.</source>
        <target state="translated">Specifikátor standardního formátu u představuje řetězec vlastního formátu data a času, který se definuje pomocí vlastnosti DateTimeFormatInfo.UniversalSortableDateTimePattern. Vzor dodržuje definovaný standard a vlastnost je určená jen pro čtení. Proto je vždy stejná, bez ohledu na používanou jazykovou verzi nebo zadaného poskytovatele formátu. Řetězec vlastního formátu je yyyy'-'MM'-'dd HH':'mm':'ss'Z'. Když se tento specifikátor standardního formátu použije, operace formátování nebo parsování vždy použije invariantní jazykovou verzi.

I když by výsledný řetězec měl vyjadřovat čas ve formátu UTC (Coordinated Universal Time), během operace formátování se původní hodnota DateTime nijak nepřevádí. Proto je nutné ji před formátováním převést na UTC pomocí metody DateTime.ToUniversalTime.</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_containing_member">
        <source>updating usages in containing member</source>
        <target state="translated">aktualizace použití v obsahujícím členu</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_containing_project">
        <source>updating usages in containing project</source>
        <target state="translated">aktualizace použití v obsahujícím projektu</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_containing_type">
        <source>updating usages in containing type</source>
        <target state="translated">aktualizace použití v obsahujícím typu</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_dependent_projects">
        <source>updating usages in dependent projects</source>
        <target state="translated">aktualizace použití v závislých projektech</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_and_minute_offset">
        <source>utc hour and minute offset</source>
        <target state="translated">posun hodiny a minuty proti UTC</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_and_minute_offset_description">
        <source>With DateTime values, the "zzz" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours and minutes. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "zzz" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours and minutes.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted with a leading zero.</source>
        <target state="translated">U hodnot DateTime specifikátor vlastního formátu zzz představuje posun časového pásma místního operačního systému od UTC se znaménkem, který se měří v hodinách a minutách. Neodráží hodnotu vlastnosti DateTime.Kind instance. Z toho důvodu se specifikátor formátu zzz nedoporučuje používat s hodnotami DateTime.

U hodnot DateTimeOffset tento specifikátor formátu představuje posun hodnoty DateTimeOffset od času UTC v hodinách a minutách.

Posun se vždy zobrazuje se znaménkem na začátku. Znaménko plus (+) označuje hodiny před UTC a znaménko minus (-) pak hodiny za UTC. Posun s jednou číslicí se formátuje s nulou na začátku.</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_1_2_digits">
        <source>utc hour offset (1-2 digits)</source>
        <target state="translated">posun hodin proti UTC (1–2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_1_2_digits_description">
        <source>With DateTime values, the "z" custom format specifier represents the signed offset of the local operating system's time zone from Coordinated Universal Time (UTC), measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "z" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted without a leading zero.

If the "z" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">U hodnot DateTime specifikátor vlastního formátu z představuje posun časového pásma místního operačního systému od koordinovaného univerzálního času (UTC) se znaménkem, který se měří v hodinách. Neodráží hodnotu vlastnosti DateTime.Kind instance. Z toho důvodu se specifikátor formátu z nedoporučuje používat s hodnotami DateTime.

U hodnot DateTimeOffset tento specifikátor formátu představuje posun hodnoty DateTimeOffset od času UTC v hodinách.

Posun se vždy zobrazuje se znaménkem na začátku. Znaménko plus (+) označuje hodiny před UTC a znaménko minus (-) pak hodiny za UTC. Posun s jednou číslicí se formátuje bez nuly na začátku.

Pokud se specifikátor formátu z použije bez dalších specifikátorů vlastního formátu, interpretuje se jako standardní specifikátor formátu data a času a vyvolá FormatException.</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_2_digits">
        <source>utc hour offset (2 digits)</source>
        <target state="translated">posun hodin proti UTC (2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_2_digits_description">
        <source>With DateTime values, the "zz" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "zz" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted with a leading zero.</source>
        <target state="translated">U hodnot DateTime specifikátor vlastního formátu zz představuje posun časového pásma místního operačního systému od UTC se znaménkem, který se měří v hodinách. Neodráží hodnotu vlastnosti DateTime.Kind instance. Z toho důvodu se specifikátor formátu zz nedoporučuje používat s hodnotami DateTime.

U hodnot DateTimeOffset tento specifikátor formátu představuje posun hodnoty DateTimeOffset od času UTC v hodinách.

Posun se vždy zobrazuje se znaménkem na začátku. Znaménko plus (+) označuje hodiny před UTC a znaménko minus (-) pak hodiny za UTC. Posun s jednou číslicí se formátuje s nulou na začátku.</target>
        <note />
      </trans-unit>
      <trans-unit id="x_y_range_in_reverse_order">
        <source>[x-y] range in reverse order</source>
        <target state="translated">Rozsah [x-y] je v obráceném pořadí.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [b-a]</note>
      </trans-unit>
      <trans-unit id="year_1_2_digits">
        <source>year (1-2 digits)</source>
        <target state="translated">rok (1–2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_1_2_digits_description">
        <source>The "y" custom format specifier represents the year as a one-digit or two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the first digit of a two-digit year begins with a zero (for example, 2008), the number is formatted without a leading zero.

If the "y" format specifier is used without other custom format specifiers, it's interpreted as the "y" standard date and time format specifier.</source>
        <target state="translated">Specifikátor vlastního formátu y reprezentuje rok jako jedno- nebo dvoumístné číslo. Pokud má rok více než dvě číslice, ve výsledku se budou nacházet jen dvě číslice nižšího řádu. Pokud první číslice dvoumístného roku začíná nulou (třeba 2008), číslo se formátuje bez nuly na začátku.

Pokud se specifikátor formátu y použije bez dalších specifikátorů vlastního formátu, interpretuje se jako standardní specifikátor formátu data a času y.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_2_digits">
        <source>year (2 digits)</source>
        <target state="translated">rok (2 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_2_digits_description">
        <source>The "yy" custom format specifier represents the year as a two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the two-digit year has fewer than two significant digits, the number is padded with leading zeros to produce two digits.

In a parsing operation, a two-digit year that is parsed using the "yy" custom format specifier is interpreted based on the Calendar.TwoDigitYearMax property of the format provider's current calendar. The following example parses the string representation of a date that has a two-digit year by using the default Gregorian calendar of the en-US culture, which, in this case, is the current culture. It then changes the current culture's CultureInfo object to use a GregorianCalendar object whose TwoDigitYearMax property has been modified.</source>
        <target state="translated">Specifikátor vlastního formátu yy reprezentuje rok jako dvoumístné číslo. Pokud má rok více než dvě číslice, ve výsledku se budou nacházet jen dvě číslice nižšího řádu. Pokud má dvoumístný rok méně než dvě platné číslice, číslo se doplní nulami na začátku, aby mělo dvě číslice.

Při operaci parsování se dvoumístný rok parsovaný pomocí specifikátoru vlastního formátu interpretuje podle vlastnosti Calendar.TwoDigitYearMax aktuálního kalendáře poskytovatele formátu. Následující příklad parsuje řetězcovou reprezentaci data, která má dvoumístný rok, pomocí výchozího Gregoriánského kalendáře jazykové verze en-US, která je v tomto případě zároveň aktuální jazykovou verzí. Pak změní objekt CultureInfo aktuální jazykové verze tak, aby používala objekt GregorianCalendar, jehož vlastnost TwoDigitYearMax bude upravená.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_3_4_digits">
        <source>year (3-4 digits)</source>
        <target state="translated">rok (3–4 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_3_4_digits_description">
        <source>The "yyy" custom format specifier represents the year with a minimum of three digits. If the year has more than three significant digits, they are included in the result string. If the year has fewer than three digits, the number is padded with leading zeros to produce three digits.</source>
        <target state="translated">Specifikátor vlastního formátu yyy představuje rok s nejméně třemi číslicemi. Pokud má rok více než tři platné číslice, zahrnou se do výsledného řetězce. Pokud má rok méně než tři číslice, číslo se doplní nulami na začátku, aby mělo tři číslice.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_4_digits">
        <source>year (4 digits)</source>
        <target state="translated">rok (4 číslice)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_4_digits_description">
        <source>The "yyyy" custom format specifier represents the year with a minimum of four digits. If the year has more than four significant digits, they are included in the result string. If the year has fewer than four digits, the number is padded with leading zeros to produce four digits.</source>
        <target state="translated">Specifikátor vlastního formátu yyyy představuje rok s nejméně čtyřmi číslicemi. Pokud má rok více než čtyři platné číslice, zahrnou se do výsledného řetězce. Pokud má rok méně než čtyři číslice, číslo se doplní nulami na začátku, aby mělo čtyři číslice.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_5_digits">
        <source>year (5 digits)</source>
        <target state="translated">rok (5 číslic)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_5_digits_description">
        <source>The "yyyyy" custom format specifier (plus any number of additional "y" specifiers) represents the year with a minimum of five digits. If the year has more than five significant digits, they are included in the result string. If the year has fewer than five digits, the number is padded with leading zeros to produce five digits.

If there are additional "y" specifiers, the number is padded with as many leading zeros as necessary to produce the number of "y" specifiers.</source>
        <target state="translated">Specifikátor vlastního formátu yyyyy (a libovolný počet dalších specifikátorů y) představuje rok s nejméně pěti číslicemi. Pokud má rok více než pět platných číslic, zahrnou se do výsledného řetězce. Pokud má rok méně než pět číslic, číslo se doplní nulami na začátku, aby mělo pět číslice.

Pokud se použijí další specifikátory y, číslo se doplní tolika nulami na začátku, kolik jich je potřeba, aby vzniklo číslo odpovídající specifikátorům y.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_month">
        <source>year month</source>
        <target state="translated">měsíc v roce</target>
        <note />
      </trans-unit>
      <trans-unit id="year_month_description">
        <source>The "Y" or "y" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.YearMonthPattern property of a specified culture. For example, the custom format string for the invariant culture is "yyyy MMMM".</source>
        <target state="translated">Specifikátory standardního formátu Y nebo y představují řetězec vlastního formátu data a času, který se definuje pomocí vlastnosti DateTimeFormatInfo.ShortTimePattern zadané jazykové verze. Například řetězec vlastního formátu pro invariantní jazykovou verzi je yyyy MMMM.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>