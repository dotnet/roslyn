<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ru" original="../FeaturesResources.resx">
    <body>
      <trans-unit id="0_directive">
        <source>#{0} directive</source>
        <target state="translated">Директива #{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_abbreviated">
        <source>AM/PM (abbreviated)</source>
        <target state="translated">AM/PM (сокращенно)</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_abbreviated_description">
        <source>The "t" custom format specifier represents the first character of the AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property of the current or specific culture. The AM designator is used for all times from 0:00:00 (midnight) to 11:59:59.999. The PM designator is used for all times from 12:00:00 (noon) to 23:59:59.999.

If the "t" format specifier is used without other custom format specifiers, it's interpreted as the "t" standard date and time format specifier.</source>
        <target state="translated">Описатель пользовательского формата "t" представляет первый символ указателя AM/PM. Соответствующий локализованный указатель извлекается из свойства DateTimeFormatInfo.AMDesignator или DateTimeFormatInfo.PMDesignator текущих или заданных языка и региональных параметров. Указатель AM используется для всех значений времени с 0:00:00 (полночь) до 11:59:59,999. Указатель PM используется для всех значений времени с 12:00:00 (полдень) до 23:59:59,999.

Если описатель формата "t" используется без других описателей пользовательского формата, он интерпретируется как описатель "t" стандартного формата даты и времени.</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_full">
        <source>AM/PM (full)</source>
        <target state="translated">AM/PM (полностью)</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_full_description">
        <source>The "tt" custom format specifier (plus any number of additional "t" specifiers) represents the entire AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property of the current or specific culture. The AM designator is used for all times from 0:00:00 (midnight) to 11:59:59.999. The PM designator is used for all times from 12:00:00 (noon) to 23:59:59.999.

Make sure to use the "tt" specifier for languages for which it's necessary to maintain the distinction between AM and PM. An example is Japanese, for which the AM and PM designators differ in the second character instead of the first character.</source>
        <target state="translated">Описатель пользовательского формата "tt" (плюс любое число дополнительных описателей "t") представляет весь указатель AM/PM. Соответствующий локализованный указатель извлекается из свойства DateTimeFormatInfo.AMDesignator или DateTimeFormatInfo.PMDesignator текущих или заданных языка и региональных параметров. Указатель AM используется для всех значений времени с 0:00:00 (полночь) до 11:59:59,999. Указатель PM используется для всех значений времени с 12:00:00 (полдень) до 23:59:59,999.

Используйте описатель "tt" для языков, где необходимо сохранить различие между AM и PM. В качестве примера можно привести японский язык, в котором указатели AM и PM различаются вторым, а не первым символом.</target>
        <note />
      </trans-unit>
      <trans-unit id="A_subtraction_must_be_the_last_element_in_a_character_class">
        <source>A subtraction must be the last element in a character class</source>
        <target state="translated">Вычитание должно быть последним элементом в классе символов</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-[b]-c]</note>
      </trans-unit>
      <trans-unit id="Add_DebuggerDisplay_attribute">
        <source>Add 'DebuggerDisplay' attribute</source>
        <target state="translated">Добавить атрибут "DebuggerDisplay"</target>
        <note>{Locked="DebuggerDisplay"} "DebuggerDisplay" is a BCL class and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Add_null_checks_for_all_parameters">
        <source>Add null checks for all parameters</source>
        <target state="translated">Добавление проверки NULL для всех параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_optional_parameter_to_constructor">
        <source>Add optional parameter to constructor</source>
        <target state="translated">Добавить необязательный параметр в конструктор</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_parameter_to_constructor">
        <source>Add parameter to constructor</source>
        <target state="translated">Добавить параметр в конструктор</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_project_reference_to_0">
        <source>Add project reference to '{0}'.</source>
        <target state="translated">Добавьте ссылку на проект в "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_reference_to_0">
        <source>Add reference to '{0}'.</source>
        <target state="translated">Добавьте ссылку в "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Actions_can_not_be_empty">
        <source>Actions can not be empty.</source>
        <target state="translated">Действия не могут быть пустыми.</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_tuple_element_name_0">
        <source>Add tuple element name '{0}'</source>
        <target state="translated">Добавить имя элемента кортежа "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_around_an_active_statement_requires_restarting_the_application">
        <source>Adding {0} around an active statement requires restarting the application.</source>
        <target state="translated">Для добавления {0} вокруг активного оператора требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_an_interface_method_requires_restarting_the_application">
        <source>Adding {0} into an interface method requires restarting the application.</source>
        <target state="translated">Для добавления {0} в метод интерфейса требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_an_interface_requires_restarting_the_application">
        <source>Adding {0} into an interface requires restarting the application.</source>
        <target state="translated">Для добавления {0} в интерфейс требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_requires_restarting_the_application">
        <source>Adding {0} requires restarting the application.</source>
        <target state="translated">Для добавления {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_with_the_Handles_clause_requires_restarting_the_application">
        <source>Adding {0} with the Handles clause requires restarting the application.</source>
        <target state="translated">Для добавления {0} с предложением Handles требуется перезапустить приложение.</target>
        <note>{Locked="Handles"} "Handles" is VB keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Adding_a_MustOverride_0_or_overriding_an_inherited_0_requires_restarting_the_application">
        <source>Adding a MustOverride {0} or overriding an inherited {0} requires restarting the application.</source>
        <target state="translated">Для добавления MustOverride {0} или переопределение унаследованного {0} требуется перезапустить приложение.</target>
        <note>{Locked="MustOverride"} "MustOverride" is VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Adding_a_constructor_to_a_type_with_a_field_or_property_initializer_that_contains_an_anonymous_function_requires_restarting_the_application">
        <source>Adding a constructor to a type with a field or property initializer that contains an anonymous function requires restarting the application.</source>
        <target state="translated">Для добавления конструктора к типу с инициализатором поля или свойства, содержащим анонимную функцию, требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_method_with_an_explicit_interface_specifier_requires_restarting_the_application">
        <source>Adding a method with an explicit interface specifier requires restarting the application.</source>
        <target state="translated">Для добавления метода с явным описателем интерфейса требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_new_file_requires_restarting_the_application">
        <source>Adding a new file requires restarting the application.</source>
        <target state="translated">Для добавления нового файла требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_user_defined_0_requires_restarting_the_application">
        <source>Adding a user defined {0} requires restarting the application.</source>
        <target state="translated">Для добавления пользовательского {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_an_abstract_0_or_overriding_an_inherited_0_requires_restarting_the_application">
        <source>Adding an abstract {0} or overriding an inherited {0} requires restarting the application.</source>
        <target state="translated">Для добавления абстрактного {0} или переопределения унаследованного {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_an_extern_0_requires_restarting_the_application">
        <source>Adding an extern {0} requires restarting the application.</source>
        <target state="translated">Для добавления extern {0} требуется перезапустить приложение.</target>
        <note>{Locked="extern"} "extern" is C# keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Adding_an_imported_method_requires_restarting_the_application">
        <source>Adding an imported method requires restarting the application.</source>
        <target state="translated">Для добавления импортированного метода требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_or_moving_0_of_1_requires_restarting_the_application">
        <source>Adding or moving {0} of {1} requires restarting the application.</source>
        <target state="translated">Добавление или {0} {1} требует перезапуска приложения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_or_moving_0_of_1_with_explicit_or_sequential_layout_requires_restarting_the_application">
        <source>Adding or moving {0} of {1} with explicit or sequential layout requires restarting the application.</source>
        <target state="translated">Добавление или перемещение {0} из {1} с явной или последовательной компоновкой требует перезапуска приложения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_or_moving_0_of_a_COM_interface_requires_restarting_the_application">
        <source>Adding or moving {0} of a COM interface requires restarting the application.</source>
        <target state="translated">Чтобы добавить или {0} com-интерфейса, необходимо перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Align_wrapped_arguments">
        <source>Align wrapped arguments</source>
        <target state="translated">Выровнять свернутые аргументы</target>
        <note />
      </trans-unit>
      <trans-unit id="Align_wrapped_parameters">
        <source>Align wrapped parameters</source>
        <target state="translated">Выровнять свернутые параметры</target>
        <note />
      </trans-unit>
      <trans-unit id="Alternation_conditions_cannot_be_comments">
        <source>Alternation conditions cannot be comments</source>
        <target state="translated">Условия чередования не могут быть комментариями</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a|(?#b)</note>
      </trans-unit>
      <trans-unit id="Alternation_conditions_do_not_capture_and_cannot_be_named">
        <source>Alternation conditions do not capture and cannot be named</source>
        <target state="translated">Условия чередования не выполняют запись, и им невозможно присвоить имя</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(?'x'))</note>
      </trans-unit>
      <trans-unit id="An_update_that_causes_the_return_type_of_implicit_main_to_change_requires_restarting_the_application">
        <source>An update that causes the return type of the implicit Main method to change requires restarting the application.</source>
        <target state="translated">Для обновления, приводящего к изменению возвращаемого типа неявного метода Main, требуется перезапустить приложение.</target>
        <note>{Locked="Main"} is C# keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Apply_auto_property_preferences">
        <source>Apply auto property preferences</source>
        <target state="translated">Применить настройки для автосвойства</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_blank_line_preferences_experimental">
        <source>Apply blank line preferences (experimental)</source>
        <target state="translated">Применить настройки для пустой строки (экспериментальная функция)</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_coalesce_expression_preferences">
        <source>Apply coalesce expression preferences</source>
        <target state="translated">Применить настройки для выражения объединения</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_compound_assignment_preferences">
        <source>Apply compound assignment preferences</source>
        <target state="translated">Применить настройки для составного назначения</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_conditional_expression_preferences">
        <source>Apply conditional expression preferences</source>
        <target state="translated">Применить настройки для условного выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_file_header_preferences">
        <source>Apply file header preferences</source>
        <target state="translated">Применить параметры заголовка файла</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_inferred_anonymous_type_member_names_preferences">
        <source>Apply inferred anonymous type member names preferences</source>
        <target state="translated">Применить настройки для выводимых имен членов анонимного типа</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_language_framework_type_preferences">
        <source>Apply language/framework type preferences</source>
        <target state="translated">Применять предпочтения для типа языка или платформы</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_namespace_matches_folder_preferences">
        <source>Apply namespace matches folder preferences</source>
        <target state="translated">Применить настройки для пространства имен, соответствующего папке</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_null_checking_preferences">
        <source>Apply null checking preferences</source>
        <target state="translated">Применить настройки проверки \"null\"</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_null_propagation_preferences">
        <source>Apply null propagation preferences</source>
        <target state="translated">Применить настройки для распространения значений NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_object_collection_initialization_preferences">
        <source>Apply object/collection initialization preferences</source>
        <target state="translated">Применять предпочтения для инициализации объекта или коллекции</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_object_initializer_preferences">
        <source>Apply object initializer preferences</source>
        <target state="translated">Применить настройки для инициализатора объектов</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_parentheses_preferences">
        <source>Apply parentheses preferences</source>
        <target state="translated">Применить настройки для круглых скобок</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_simplify_boolean_expression_preferences">
        <source>Apply simplify boolean expression preferences</source>
        <target state="translated">Применить настройки для упрощения логических выражений</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_statement_after_block_preferences_experimental">
        <source>Apply statement after block preferences (experimental)</source>
        <target state="translated">Применить настройки для инструкции после блока (экспериментальная функция)</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_string_interpolation_preferences">
        <source>Apply string interpolation preferences</source>
        <target state="translated">Применить настройки для интерполяции строк</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_tuple_name_preferences">
        <source>Apply tuple name preferences</source>
        <target state="translated">Применить настройки для имен кортежей</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_unused_value_preferences">
        <source>Apply unused value preferences</source>
        <target state="translated">Применить настройки для неиспользуемых значений</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_using_directive_placement_preferences">
        <source>Apply using directive placement preferences</source>
        <target state="translated">Применить настройки для размещения директивы using</target>
        <note />
      </trans-unit>
      <trans-unit id="Applying_source_changes_while_the_application_is_running_is_not_supported_by_the_runtime">
        <source>Applying source changes while the application is running is not supported by the runtime.</source>
        <target state="translated">Применение изменений источника во время выполнения приложения не поддерживается средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Attribute_0_is_missing_Updating_an_async_method_or_an_iterator_requires_restarting_the_application">
        <source>Attribute '{0}' is missing. Updating an async method or an iterator requires restarting the application.</source>
        <target state="translated">Атрибут "{0}" отсутствует. Для обновления асинхронного метода или итератора требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Asynchronously_waits_for_the_task_to_finish">
        <source>Asynchronously waits for the task to finish.</source>
        <target state="translated">Асинхронно ожидает окончания задачи.</target>
        <note />
      </trans-unit>
      <trans-unit id="Await_the_preceding_expression">
        <source>Await the preceding expression</source>
        <target state="translated">Ожидание предыдущего выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="Await_the_preceding_expression_and_add_ConfigureAwait_0">
        <source>Await the preceding expression and add ConfigureAwait({0}).</source>
        <target state="translated">Ожидание предыдущего выражения и добавление ConfigureAwait({0}).</target>
        <note>{Locked="ConfigureAwait"} "ConfigureAwait" is an api name and should not be localized. {0} is a placeholder for the language specific keyword 'false'.</note>
      </trans-unit>
      <trans-unit id="Awaited_task_returns_0">
        <source>Awaited task returns {0}</source>
        <target state="translated">Ожидаемая задача возвращает {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Awaited_task_returns_no_value">
        <source>Awaited task returns no value</source>
        <target state="translated">Ожидаемая задача не возвращает значение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Built_in_Copilot_analysis">
        <source>Built-in Copilot analysis</source>
        <target state="new">Built-in Copilot analysis</target>
        <note />
      </trans-unit>
      <trans-unit id="CSharp_VisualBasic_References">
        <source>C# and Visual Basic References</source>
        <target state="translated">Справочники по C# и Visual Basic</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotApplyChangesUnexpectedError">
        <source>Cannot apply changes -- unexpected error: '{0}'</source>
        <target state="translated">Не удается применить изменения, так как возникла непредвиденная ошибка: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_determine_valid_range_of_statements_to_extract">
        <source>Cannot determine valid range of statements to extract</source>
        <target state="translated">Невозможно определить допустимый диапазон операторов для извлечения</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_include_class_0_in_character_range">
        <source>Cannot include class \{0} in character range</source>
        <target state="translated">Невозможно включить класс \{0} в диапазон символов</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-\w]. {0} is the invalid class (\w here)</note>
      </trans-unit>
      <trans-unit id="Cannot_navigate_to_the_symbol_under_the_caret">
        <source>Cannot navigate to the symbol under the caret.</source>
        <target state="translated">Не удается перейти к символу, на котором находится курсор.</target>
        <note />
      </trans-unit>
      <trans-unit id="Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue">
        <source>Capture group numbers must be less than or equal to Int32.MaxValue</source>
        <target state="new">Capture group numbers must be less than or equal to Int32.MaxValue</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{2147483648}</note>
      </trans-unit>
      <trans-unit id="Capture_number_cannot_be_zero">
        <source>Capture number cannot be zero</source>
        <target state="translated">Номер записи не может быть равен нулю</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;0&gt;a)</note>
      </trans-unit>
      <trans-unit id="Capturing_primary_constructor_parameter_0_that_hasn_t_been_captured_before_requires_restarting_the_application">
        <source>Capturing primary constructor parameter '{0}' that hasn't been capture before requires restarting the application.</source>
        <target state="translated">Для фиксации параметра первичной конструкции "{0}", который ранее не был зафиксирован, требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Ceasing_to_capture_primary_constructor_parameter_0_of_1_requires_restarting_the_application">
        <source>Ceasing to capture primary constructor parameter '{0}' of '{1}' requires restarting the application.</source>
        <target state="translated">Для прекращения фиксации параметра первичной конструкции "{0}" "{1}" требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeSignature_NewParameterInferValue">
        <source>&lt;infer&gt;</source>
        <target state="translated">&lt;вывести&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeSignature_NewParameterIntroduceTODOVariable">
        <source>TODO</source>
        <target state="translated">TODO</target>
        <note>"TODO" is an indication that there is work still to be done.</note>
      </trans-unit>
      <trans-unit id="ChangeSignature_NewParameterOmitValue">
        <source>&lt;omit&gt;</source>
        <target state="translated">&lt;пропустить&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_namespace_to_0">
        <source>Change namespace to '{0}'</source>
        <target state="translated">Изменить пространство имен на "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_to_global_namespace">
        <source>Change to global namespace</source>
        <target state="translated">Изменить на глобальное пространство имен</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangesDisallowedWhileStoppedAtException">
        <source>Changes are not allowed while stopped at exception</source>
        <target state="translated">Изменения запрещены, когда выполнение остановлено при исключении</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangesRequiredSynthesizedType">
        <source>One or more changes result in a new type being created by the compiler, which requires restarting the application because it is not supported by the runtime</source>
        <target state="translated">Одно или несколько изменений приведут к созданию нового типа компилятором. Это не поддерживается средой выполнения, поэтому требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_0_from_asynchronous_to_synchronous_requires_restarting_the_application">
        <source>Changing {0} from asynchronous to synchronous requires restarting the application.</source>
        <target state="translated">Для изменения {0} с асинхронного на синхронный требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_0_might_not_have_any_effect_until_the_application_is_restarted">
        <source>Changing '{0}' might not have any effect until the application is restarted.</source>
        <target state="translated">Изменение "{0}" может не иметь эффекта до перезапуска приложения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_0_to_1_requires_restarting_the_application_because_it_changes_the_shape_of_the_state_machine">
        <source>Changing '{0}' to '{1}' requires restarting the application because it changes the shape of the state machine.</source>
        <target state="translated">Для изменения "{0}" на "{1}" требуется перезапустить приложение, так как при этом изменяется форма конечного автомата.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_a_field_to_an_event_or_vice_versa_requires_restarting_the_application">
        <source>Changing a field to an event or vice versa requires restarting the application.</source>
        <target state="translated">Для изменения поля на событие или наоборот требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_attribute_0_requires_restarting_the_application">
        <source>Changing attribute '{0}' requires restarting the application.</source>
        <target state="translated">Для изменения атрибута "{0}" требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_constraints_of_0_requires_restarting_the_application">
        <source>Changing constraints of {0} requires restarting the application.</source>
        <target state="translated">Для изменения ограничений {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_name_or_signature_of_0_that_contains_an_active_statement_requires_restarting_the_application">
        <source>Changing attribute '{0}' requires restarting the application.</source>
        <target state="translated">Для изменения атрибута "{0}" требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_parameter_types_of_0_requires_restarting_the_application">
        <source>Changing parameter types of {0} requires restarting the application.</source>
        <target state="translated">Для изменения типов параметров {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_pseudo_custom_attribute_0_of_1_requires_restarting_th_application">
        <source>Changing pseudo-custom attribute '{0}' of {1} requires restarting the application</source>
        <target state="translated">Для изменения псевдонастраиваемого атрибута "{0}" для {1} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_containing_namespace_of_0_from_1_to_2_requires_restarting_th_application">
        <source>Changing the containing namespace of '{0}' from '{1}' to '{2}' requires restarting the application</source>
        <target state="translated">Чтобы изменить содержащее пространство имен "{0}" с "{1}" на "{2}", необходимо перезапустить приложение</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_declaration_scope_of_a_captured_variable_0_requires_restarting_the_application">
        <source>Changing the declaration scope of a captured variable '{0}' requires restarting the application.</source>
        <target state="translated">Для изменения области объявления зафиксированной переменной "{0}" требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_parameters_of_0_requires_restarting_the_application">
        <source>Changing the parameters of {0} requires restarting the application.</source>
        <target state="translated">Для изменения параметров {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_return_type_of_0_requires_restarting_the_application">
        <source>Changing the return type of {0} requires restarting the application.</source>
        <target state="translated">Для изменения типа возвращаемого значения {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_signature_of_0_requires_restarting_the_application">
        <source>Changing the signature of {0} requires restarting the application.</source>
        <target state="translated">Изменение подписи {0} требует перезапуска приложения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_signature_of_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
        <source>Changing the signature of {0} requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">Для изменения подписи {0} требуется перезапустить приложение, так как это не поддерживается средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_type_of_a_captured_variable_0_previously_of_type_1_requires_restarting_the_application">
        <source>Changing the type of a captured variable '{0}' previously of type '{1}' requires restarting the application.</source>
        <target state="translated">Для изменения типа зафиксированной переменной "{0}", ранее имевшей тип "{1}", требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_type_parameters_of_0_requires_restarting_the_application">
        <source>Changing type parameters of {0} requires restarting the application.</source>
        <target state="translated">Для изменения параметров типа {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_visibility_of_0_requires_restarting_the_application">
        <source>Changing visibility of {0} requires restarting the application.</source>
        <target state="translated">Для изменения видимости {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Chosen_version_0">
        <source>Chosen version: '{0}'</source>
        <target state="translated">Выбранная версия: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Code_snippet_for_0">
        <source>Code snippet for '{0}'</source>
        <target state="translated">Фрагмент кода для "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Comments_not_allowed">
        <source>Comments not allowed</source>
        <target state="translated">Комментарии не разрешены</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_0_code_style">
        <source>Configure {0} code style</source>
        <target state="translated">Настройка стиля кода {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_0_severity">
        <source>Configure {0} severity</source>
        <target state="translated">Настройка серьезности {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_severity_for_all_0_analyzers">
        <source>Configure severity for all '{0}' analyzers</source>
        <target state="translated">Настройка серьезности для всех анализаторов ("{0}")</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_severity_for_all_analyzers">
        <source>Configure severity for all analyzers</source>
        <target state="translated">Настройка серьезности для всех анализаторов</target>
        <note />
      </trans-unit>
      <trans-unit id="Conflict_s_detected">
        <source>Conflict(s) detected.</source>
        <target state="translated">Обнаружены конфликты.</target>
        <note />
      </trans-unit>
      <trans-unit id="Constructors_not_allowed">
        <source>Constructors not allowed</source>
        <target state="translated">Конструкторы не разрешены</target>
        <note />
      </trans-unit>
      <trans-unit id="Containing_Member">
        <source>Containing Member</source>
        <target state="translated">Содержащий член</target>
        <note />
      </trans-unit>
      <trans-unit id="Containing_Type">
        <source>Containing Type</source>
        <target state="translated">Содержащий тип</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_number">
        <source>Convert number</source>
        <target state="translated">Преобразовать число</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_linq">
        <source>Convert to LINQ</source>
        <target state="translated">Преобразовать в LINQ</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_class">
        <source>Convert to class</source>
        <target state="translated">Преобразовать в класс</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_linq_call_form">
        <source>Convert to LINQ (call form)</source>
        <target state="translated">Преобразовать в LINQ (форма вызова)</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_record">
        <source>Convert to record</source>
        <target state="translated">Преобразовать в запись</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_record_struct">
        <source>Convert to record struct</source>
        <target state="translated">Преобразовать в структуру записей</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_struct">
        <source>Convert to struct</source>
        <target state="translated">Преобразовать в структуру</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_tuple">
        <source>Convert to tuple</source>
        <target state="translated">Преобразовать в кортеж</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_find_PDB_on_disk_or_embedded">
        <source>Could not find portable PDB on disk or embedded.</source>
        <target state="translated">Не удалось найти переносимый PDB-файл на диске или во внедренном источнике.</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_find_PDB_on_disk_or_embedded_or_server">
        <source>Could not find PDB on disk, or embedded, or on a symbol server.</source>
        <target state="translated">Не удалось найти PDB-файл на диске, во внедренном источнике или на сервере символов.</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_find_by_name_0">
        <source>Could not find by name: '{0}'</source>
        <target state="translated">Не удалось найти по имени: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_find_implementation_of_symbol_0">
        <source>Could not find implementation of symbol '{0}'</source>
        <target state="translated">Не найдена реализация символа "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_field_0">
        <source>Create and assign field '{0}'</source>
        <target state="translated">Создать и назначить поле "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_property_0">
        <source>Create and assign property '{0}'</source>
        <target state="translated">Создать и назначить свойство "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_remaining_as_fields">
        <source>Create and assign remaining as fields</source>
        <target state="translated">Создать и назначить оставшиеся как поля</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_remaining_as_properties">
        <source>Create and assign remaining as properties</source>
        <target state="translated">Создать и назначить оставшиеся как свойства</target>
        <note />
      </trans-unit>
      <trans-unit id="Debug_All_Tests">
        <source>Debug All Tests</source>
        <target state="translated">Отладить все тесты</target>
        <note />
      </trans-unit>
      <trans-unit id="Debug_Test">
        <source>Debug Test</source>
        <target state="translated">Отладка теста</target>
        <note />
      </trans-unit>
      <trans-unit id="Decompilation_log">
        <source>Decompilation log</source>
        <target state="translated">Журнал декомпиляции</target>
        <note />
      </trans-unit>
      <trans-unit id="Decompiled">
        <source>decompiled</source>
        <target state="translated">декомпилировано</target>
        <note />
      </trans-unit>
      <trans-unit id="Deconstruct_locals_for_0">
        <source>Deconstruct locals for '{0}'</source>
        <target state="translated">Деконструировать локальные объекты для "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_0_around_an_active_statement_requires_restarting_the_application">
        <source>Deleting {0} around an active statement requires restarting the application.</source>
        <target state="translated">Для удаления {0} вокруг активного оператора требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_0_requires_restarting_the_application">
        <source>Deleting {0} requires restarting the application.</source>
        <target state="translated">Для удаления {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_0_requires_restarting_the_application_because_is_not_supported_by_the_runtime">
        <source>Deleting {0} requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">Для удаления {0} требуется перезапустить приложение, поскольку удаление не поддерживается средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Directives_from_0">
        <source>Directives from '{0}'</source>
        <target state="translated">Директивы из "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Dismiss">
        <source>Dismiss</source>
        <target state="translated">Отклонить</target>
        <note />
      </trans-unit>
      <trans-unit id="DocumentIsOutOfSyncWithDebuggee">
        <source>The current content of source file '{0}' does not match the built source. Any changes made to this file while debugging won't be applied until its content matches the built source.</source>
        <target state="translated">Текущее содержимое исходного файла "{0}" не соответствует созданному источнику. Все изменения, внесенные в этот файл во время отладки, не будут применены, пока содержимое файла не будет соответствовать созданному источнику.</target>
        <note />
      </trans-unit>
      <trans-unit id="Document_must_be_contained_in_the_workspace_that_created_this_service">
        <source>Document must be contained in the workspace that created this service</source>
        <target state="translated">Документ должен находиться в рабочей области, в которой была создана эта служба.</target>
        <note />
      </trans-unit>
      <trans-unit id="EditAndContinue">
        <source>Edit and Continue</source>
        <target state="translated">Операция "Изменить и продолжить"</target>
        <note />
      </trans-unit>
      <trans-unit id="EditAndContinueDisallowedByProject">
        <source>Changes made in project '{0}' require restarting the application: {1}</source>
        <target state="translated">После внесения изменений в проект "{0}" необходимо перезапустить приложение: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Enable_all_JSON_editor_features">
        <source>Enable all JSON editor features</source>
        <target state="translated">Включить все функции редактора JSON</target>
        <note />
      </trans-unit>
      <trans-unit id="Enum_members">
        <source>Enum members</source>
        <target state="translated">Элементы перечисления</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorReadingFile">
        <source>Error while reading file '{0}': {1}</source>
        <target state="translated">Ошибка при чтении файла "{0}": {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Error_creating_instance_of_CodeFixProvider">
        <source>Error creating instance of CodeFixProvider</source>
        <target state="translated">Ошибка при создании экземпляра CodeFixProvider.</target>
        <note />
      </trans-unit>
      <trans-unit id="Error_creating_instance_of_CodeFixProvider_0">
        <source>Error creating instance of CodeFixProvider '{0}'</source>
        <target state="translated">Ошибка при создании экземпляра CodeFixProvider "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Error_parsing_comment">
        <source>Error parsing comment</source>
        <target state="translated">Ошибка разбора комментария</target>
        <note />
      </trans-unit>
      <trans-unit id="Error_reading_PDB_0">
        <source>Error reading PDB: '{0}'</source>
        <target state="translated">Ошибка чтения PDB-файла: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Example">
        <source>Example:</source>
        <target state="translated">Пример:</target>
        <note>Singular form when we want to show an example, but only have one to show.</note>
      </trans-unit>
      <trans-unit id="Examples">
        <source>Examples:</source>
        <target state="translated">Примеры:</target>
        <note>Plural form when we have multiple examples to show.</note>
      </trans-unit>
      <trans-unit id="Extract_base_class">
        <source>Extract base class...</source>
        <target state="translated">Извлечь базовый класс...</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_base_record">
        <source>Extract base record...</source>
        <target state="translated">Извлечь базовый объект record...</target>
        <note>{Locked="record"} "record" is a language construct for C# and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Extract_interface">
        <source>Extract interface...</source>
        <target state="translated">Извлечение интерфейса…</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_local_function">
        <source>Extract local function</source>
        <target state="translated">Извлечение локальной функции</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_method">
        <source>Extract method</source>
        <target state="translated">Извлечь метод</target>
        <note />
      </trans-unit>
      <trans-unit id="Failed_to_analyze_data_flow_for_0">
        <source>Failed to analyze data-flow for: {0}</source>
        <target state="translated">Не удалось проанализировать поток данных для: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Find_All_References_not_invoked_on_applicable_symbol">
        <source>'Find All References' not invoked on applicable symbol</source>
        <target state="translated">Метод "Найти все ссылки" не вызван для применимого символа</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_All_0">
        <source>Fix All: {0}</source>
        <target state="translated">Исправить все: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_typo_0">
        <source>Fix typo '{0}'</source>
        <target state="translated">Исправьте опечатку "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Fixing_0">
        <source>Fixing '{0}'</source>
        <target state="translated">Исправление "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Formatting_document">
        <source>Formatting document</source>
        <target state="translated">Форматирование документа</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_0_assemblies_for_1">
        <source>Found '{0}' assemblies for '{1}':</source>
        <target state="translated">Обнаружены сборки ("{0}") для "{1}":</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_PDB_file_at_0">
        <source>Found PDB file at '{0}'</source>
        <target state="translated">Найден PDB-файл в "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_PDB_on_symbol_server">
        <source>Found PDB on symbol server.</source>
        <target state="translated">Найден PDB-файл на сервере символов.</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_PDB_on_symbol_server_but_could_not_read_file">
        <source>Found PDB on symbol server but could not read file.</source>
        <target state="translated">Найден PDB-файл на сервере символов, но не удалось прочитать файл.</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_embedded_PDB_file">
        <source>Found embedded PDB file.</source>
        <target state="translated">Найден внедренный PDB-файл.</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_exact_match_0">
        <source>Found exact match: '{0}'</source>
        <target state="translated">Обнаружено точное совпадение: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_higher_version_match_0">
        <source>Found higher version match: '{0}'</source>
        <target state="translated">Обнаружено более высокое совпадение версий: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_single_assembly_0">
        <source>Found single assembly: '{0}'</source>
        <target state="translated">Найдена одна сборка: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_comparison_operators">
        <source>Generate comparison operators</source>
        <target state="translated">Создать операторы сравнения</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constructor_from_members">
        <source>Generate constructor from members...</source>
        <target state="translated">Создать конструктор из элементов...</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_for_0">
        <source>Generate for '{0}'</source>
        <target state="translated">Создать для "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Illegal_backslash_at_end_of_pattern">
        <source>Illegal \ at end of pattern</source>
        <target state="translated">Недопустимый символ "\" в конце шаблона</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \</note>
      </trans-unit>
      <trans-unit id="Illegal_string_character">
        <source>Illegal string character</source>
        <target state="translated">Недопустимый символ строки</target>
        <note />
      </trans-unit>
      <trans-unit id="Illegal_whitespace_character">
        <source>Illegal whitespace character</source>
        <target state="translated">Недопустимый символ пробела</target>
        <note />
      </trans-unit>
      <trans-unit id="Illegal_x_y_with_x_less_than_y">
        <source>Illegal {x,y} with x &gt; y</source>
        <target state="translated">Неправильное использование {x,y} в x &gt; y</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{1,0}</note>
      </trans-unit>
      <trans-unit id="Implement_0_explicitly">
        <source>Implement '{0}' explicitly</source>
        <target state="translated">Реализовать "{0}" явно</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_0_implicitly">
        <source>Implement '{0}' implicitly</source>
        <target state="translated">Реализовать "{0}" неявно</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_all_interfaces_explicitly">
        <source>Implement all interfaces explicitly</source>
        <target state="translated">Реализовать все интерфейсы явно</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_all_interfaces_implicitly">
        <source>Implement all interfaces implicitly</source>
        <target state="translated">Реализовать все интерфейсы неявно</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_explicitly">
        <source>Implement explicitly</source>
        <target state="translated">Реализовать явно</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_implicitly">
        <source>Implement implicitly</source>
        <target state="translated">Реализовать неявно</target>
        <note />
      </trans-unit>
      <trans-unit id="Incomplete_character_escape">
        <source>Incomplete \p{X} character escape</source>
        <target state="translated">Незавершенная escape-последовательность \p{X}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{ Cc }</note>
      </trans-unit>
      <trans-unit id="Indent_all_arguments">
        <source>Indent all arguments</source>
        <target state="translated">Добавить отступы для всех аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_all_elements">
        <source>Indent all elements</source>
        <target state="translated">Добавить отступ для всех элементов</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_all_parameters">
        <source>Indent all parameters</source>
        <target state="translated">Добавить отступы для всех параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_wrapped_arguments">
        <source>Indent wrapped arguments</source>
        <target state="translated">Добавить отступы для свернутых аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_wrapped_parameters">
        <source>Indent wrapped parameters</source>
        <target state="translated">Создать отступы для свернутых параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="Inline_0">
        <source>Inline '{0}'</source>
        <target state="translated">Встроенный метод "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Inline_and_keep_0">
        <source>Inline and keep '{0}'</source>
        <target state="translated">Сделать "{0}" встроенным и сохранить его</target>
        <note />
      </trans-unit>
      <trans-unit id="Inline_temporary_variable">
        <source>Inline temporary variable</source>
        <target state="translated">Встроить временную переменную</target>
        <note />
      </trans-unit>
      <trans-unit id="Insufficient_hexadecimal_digits">
        <source>Insufficient hexadecimal digits</source>
        <target state="new">Insufficient hexadecimal digits</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \x</note>
      </trans-unit>
      <trans-unit id="Introduce_constant">
        <source>Introduce constant</source>
        <target state="translated">Добавить константу</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_field">
        <source>Introduce field</source>
        <target state="translated">Добавить поле</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local">
        <source>Introduce local</source>
        <target state="translated">Добавить локальный оператор</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_parameter_for_0">
        <source>Introduce parameter for '{0}'</source>
        <target state="translated">Ввести параметр для "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_parameter_for_all_occurrences_of_0">
        <source>Introduce parameter for all occurrences of '{0}'</source>
        <target state="translated">Введите параметр для всех вхождений "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_query_variable">
        <source>Introduce query variable</source>
        <target state="translated">Добавить переменную запроса</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_JSON_pattern">
        <source>Invalid JSON pattern</source>
        <target state="translated">Недопустимый шаблон JSON</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_constructor_name">
        <source>Invalid constructor name</source>
        <target state="translated">Недопустимое имя конструктора</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_escape_sequence">
        <source>Invalid escape sequence</source>
        <target state="translated">Недопустимая escape-последовательность</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_group_name_Group_names_must_begin_with_a_word_character">
        <source>Invalid group name: Group names must begin with a word character</source>
        <target state="translated">Недопустимое имя группы: имя группы должно начинаться с буквы</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;a &gt;a)</note>
      </trans-unit>
      <trans-unit id="Invalid_number">
        <source>Invalid number</source>
        <target state="translated">Недопустимое число</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_property_name">
        <source>Invalid property name</source>
        <target state="translated">Недопустимое имя свойства</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_regex_pattern">
        <source>Invalid regex pattern</source>
        <target state="translated">Недопустимый шаблон регулярного выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_selection">
        <source>Invalid selection.</source>
        <target state="translated">Недопустимое выделение.</target>
        <note />
      </trans-unit>
      <trans-unit id="JSON_issue_0">
        <source>JSON issue: {0}</source>
        <target state="translated">Проблема JSON: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Invert_conditional">
        <source>Invert conditional</source>
        <target state="translated">Инвертировать условный оператор</target>
        <note />
      </trans-unit>
      <trans-unit id="Load_from_0">
        <source>Load from: '{0}'</source>
        <target state="translated">Загрузить из: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Making_a_method_an_iterator_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
        <source>Making a method an iterator requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">Чтобы сделать метод итератором, требуется перезапустить приложение, так как это не поддерживается средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Making_a_method_asynchronous_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
        <source>Making a method asynchronous requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">Чтобы сделать метод асинхронным, требуется перезапустить приложение, так как это не поддерживается средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Malformed">
        <source>malformed</source>
        <target state="new">malformed</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0</note>
      </trans-unit>
      <trans-unit id="Malformed_character_escape">
        <source>Malformed \p{X} character escape</source>
        <target state="translated">Неправильная escape-последовательность \p{X}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p {Cc}</note>
      </trans-unit>
      <trans-unit id="Malformed_named_back_reference">
        <source>Malformed \k&lt;...&gt; named back reference</source>
        <target state="translated">Неправильная именованная обратная ссылка \k&lt;...&gt;</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k'</note>
      </trans-unit>
      <trans-unit id="Merge_with_nested_0_statement">
        <source>Merge with nested '{0}' statement</source>
        <target state="translated">Объединить с вложенным оператором "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Merge_with_next_0_statement">
        <source>Merge with next '{0}' statement</source>
        <target state="translated">Объединить со следующим оператором "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Merge_with_outer_0_statement">
        <source>Merge with outer '{0}' statement</source>
        <target state="translated">Объединить с внешним оператором "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Merge_with_previous_0_statement">
        <source>Merge with previous '{0}' statement</source>
        <target state="translated">Объединить с предыдущим оператором "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodMustReturnStreamThatSupportsReadAndSeek">
        <source>{0} must return a stream that supports read and seek operations.</source>
        <target state="translated">{0} должен возвращать поток, который поддерживает операции чтения и поиска.</target>
        <note />
      </trans-unit>
      <trans-unit id="Method_0_must_be_static_and_non_generic">
        <source>Method '{0}' must be static and non-generic</source>
        <target state="new">Method '{0}' must be static and non-generic</target>
        <note />
      </trans-unit>
      <trans-unit id="Method_0_must_have_a_single_parameter_of_type_1_and_return_2">
        <source>Method '{0}' must have a single parameter of type '{1}' and return '{2}'</source>
        <target state="new">Method '{0}' must have a single parameter of type '{1}' and return '{2}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Miscellaneous_Files">
        <source>Miscellaneous Files</source>
        <target state="translated">Прочие файлы</target>
        <note />
      </trans-unit>
      <trans-unit id="Missing_control_character">
        <source>Missing control character</source>
        <target state="translated">Отсутствует управляющий символ</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \c</note>
      </trans-unit>
      <trans-unit id="Missing_property_value">
        <source>Missing property value</source>
        <target state="translated">Отсутствует значение свойства</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_a_static_variable_requires_restarting_the_application">
        <source>Modifying {0} which contains a static variable requires restarting the application.</source>
        <target state="translated">Для изменения {0}, где содержится статическая переменная, требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_an_Aggregate_Group_By_or_Join_query_clauses_requires_restarting_the_application">
        <source>Modifying {0} which contains an Aggregate, Group By, or Join query clauses requires restarting the application.</source>
        <target state="translated">Для изменения {0}, содержащего предложения запроса Aggregate, Group By или Join, требуется перезапустить приложение.</target>
        <note>{Locked="Aggregate"}{Locked="Group By"}{Locked="Join"} are VB keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_the_stackalloc_operator_requires_restarting_the_application">
        <source>Modifying {0} which contains the stackalloc operator requires restarting the application.</source>
        <target state="translated">Для изменения {0}, содержащего оператор stackalloc, требуется перезапустить приложение.</target>
        <note>{Locked="stackalloc"} "stackalloc" is C# keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Modifying_a_catch_finally_handler_with_an_active_statement_in_the_try_block_requires_restarting_the_application">
        <source>Modifying a catch/finally handler with an active statement in the try block requires restarting the application.</source>
        <target state="translated">Для изменения обработчика catch/finally с активным оператором в блоке try требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_catch_handler_around_an_active_statement_requires_restarting_the_application">
        <source>Modifying a catch handler around an active statement requires restarting the application.</source>
        <target state="translated">Для изменения обработчика catch вокруг активной инструкции требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_generic_method_requires_restarting_the_application">
        <source>Modifying a generic method requires restarting the application.</source>
        <target state="translated">Для изменения универсального метода требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_method_inside_the_context_of_a_generic_type_requires_restarting_the_application">
        <source>Modifying a method inside the context of a generic type requires restarting the application.</source>
        <target state="translated">Для изменения метода в контексте универсального типа требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_try_catch_finally_statement_when_the_finally_block_is_active_requires_restarting_the_application">
        <source>Modifying a try/catch/finally statement when the finally block is active requires restarting the application.</source>
        <target state="translated">Для изменения оператора try/catch/finally при активном блоке finally требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_body_of_0_requires_restarting_the_application_because_the_body_has_too_many_statements">
        <source>Modifying the body of {0} requires restarting the application because the body has too many statements.</source>
        <target state="translated">Для изменения тела {0} требуется перезапустить приложение, так как в теле содержится слишком много операторов.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_body_of_0_requires_restarting_the_application_due_to_internal_error_1">
        <source>Modifying the body of {0} requires restarting the application due to internal error: {1}</source>
        <target state="translated">Для изменения тела {0} требуется перезапустить приложение из-за внутренней ошибки: {1}</target>
        <note>{1} is a multi-line exception message including a stacktrace. Place it at the end of the message and don't add any punctation after or around {1}</note>
      </trans-unit>
      <trans-unit id="Modifying_source_file_0_requires_restarting_the_application_because_the_file_is_too_big">
        <source>Modifying source file '{0}' requires restarting the application because the file is too big.</source>
        <target state="translated">Для изменения исходного файла "{0}" требуется перезапустить приложение, так как файл слишком велик.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_source_file_0_requires_restarting_the_application_due_to_internal_error_1">
        <source>Modifying source file '{0}' requires restarting the application due to internal error: {1}</source>
        <target state="translated">Для изменения исходного файла "{0}" требуется перезапустить приложение из-за внутренней ошибки: {1}</target>
        <note>{2} is a multi-line exception message including a stacktrace. Place it at the end of the message and don't add any punctation after or around {1}</note>
      </trans-unit>
      <trans-unit id="Modifying_source_with_experimental_language_features_enabled_requires_restarting_the_application">
        <source>Modifying source with experimental language features enabled requires restarting the application.</source>
        <target state="translated">Для изменения исходного кода с включенными экспериментальными функциями языка требуется перезапустить приложение..</target>
        <note />
      </trans-unit>
      <trans-unit id="Module_not_found">
        <source>Module not found!</source>
        <target state="translated">Модуль не найден.</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_contents_to_namespace">
        <source>Move contents to namespace...</source>
        <target state="translated">Переместить содержимое в пространство имен...</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_declaration_near_reference_may_change_semantics">
        <source>Move declaration near reference (may change semantics)</source>
        <target state="translated">Переместить объявление рядом со ссылкой (может изменить семантику)</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_file_to_0">
        <source>Move file to '{0}'</source>
        <target state="translated">Переместить файл в "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_file_to_project_root_folder">
        <source>Move file to project root folder</source>
        <target state="translated">Переместить файл в корневую папку проекта</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_static_members_to_another_type">
        <source>Move static members to another type...</source>
        <target state="translated">Переместить статические элементы в другой тип...</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_to_namespace">
        <source>Move to namespace...</source>
        <target state="translated">Переместить в пространство имен...</target>
        <note />
      </trans-unit>
      <trans-unit id="Moving_0_requires_restarting_the_application">
        <source>Moving {0} requires restarting the application.</source>
        <target state="translated">Для перемещения {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="NET_Code_Actions">
        <source>.NET Code Actions</source>
        <target state="translated">Действия кода .NET</target>
        <note />
      </trans-unit>
      <trans-unit id="Name_expected">
        <source>Name expected</source>
        <target state="translated">Ожидалось имя</target>
        <note />
      </trans-unit>
      <trans-unit id="Navigating_to_symbol_0_from_1">
        <source>Navigating to symbol '{0}' from '{1}'.</source>
        <target state="translated">Переход к символу "{0}" от "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Nested_properties_not_allowed">
        <source>Nested properties not allowed</source>
        <target state="translated">Вложенные свойства не разрешены</target>
        <note />
      </trans-unit>
      <trans-unit id="Nested_quantifier_0">
        <source>Nested quantifier {0}</source>
        <target state="new">Nested quantifier {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a**. In this case {0} will be '*', the extra unnecessary quantifier.</note>
      </trans-unit>
      <trans-unit id="No_common_root_node_for_extraction">
        <source>No common root node for extraction.</source>
        <target state="translated">Нет стандартного корневого узла для извлечения.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_source_document_info_found_in_PDB">
        <source>No source document info found in PDB.</source>
        <target state="translated">В PDB-файле не найдены сведения об исходном документе.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_valid_location_to_insert_method_call">
        <source>No valid location to insert method call.</source>
        <target state="translated">Отсутствует допустимое расположение для вставки вызова метода.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_valid_selection_to_perform_extraction">
        <source>No valid selection to perform extraction.</source>
        <target state="translated">Нет допустимого выделения для извлечения.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_valid_statement_range_to_extract">
        <source>No valid statement range to extract</source>
        <target state="translated">Отсутствует допустимый диапазон операторов для извлечения</target>
        <note />
      </trans-unit>
      <trans-unit id="Not_all_code_paths_return">
        <source>Not all code paths return</source>
        <target state="translated">Не все пути к коду возвращают значения</target>
        <note />
      </trans-unit>
      <trans-unit id="Not_enough_close_parens">
        <source>Not enough )'s</source>
        <target state="translated">Отсутствуют закрывающие круглые скобки</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (a</note>
      </trans-unit>
      <trans-unit id="Only_properties_allowed_in_an_object">
        <source>Only properties allowed in an object</source>
        <target state="translated">В объекте разрешены только свойства</target>
        <note />
      </trans-unit>
      <trans-unit id="Operators">
        <source>Operators</source>
        <target state="translated">Операторы</target>
        <note />
      </trans-unit>
      <trans-unit id="Please_resolve_errors_in_your_code_before_renaming_this_element">
        <source>Please resolve errors in your code before renaming this element.</source>
        <target state="translated">Устраните ошибки в коде, прежде чем переименовать этот элемент.</target>
        <note />
      </trans-unit>
      <trans-unit id="Probable_JSON_string_detected">
        <source>Probable JSON string detected</source>
        <target state="translated">Обнаружена возможная строка JSON</target>
        <note />
      </trans-unit>
      <trans-unit id="Properties_not_allowed_in_an_array">
        <source>Properties not allowed in an array</source>
        <target state="translated">Свойства не разрешены в массиве</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_name_must_be_a_string">
        <source>Property name must be a string</source>
        <target state="translated">Имя свойства должно быть строкой</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_name_must_be_followed_by_a_colon">
        <source>Property name must be followed by a ':'</source>
        <target state="translated">После имени свойства должен быть указан символ \":\"</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_reference_cannot_be_updated">
        <source>Property reference cannot be updated</source>
        <target state="translated">Не удается обновить ссылку на свойство</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_0_up_to">
        <source>Pull '{0}' up to ...</source>
        <target state="translated">Извлечь "{0}" до ...</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_members_up_to_base_type">
        <source>Pull members up to base type...</source>
        <target state="translated">Извлечь элементы до базового типа...</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_selected_members_up">
        <source>Pull selected members up</source>
        <target state="translated">Вытянуть выбранные элементы вверх</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_selected_members_up_to_0">
        <source>Pull selected members up to {0}</source>
        <target state="new">Pull selected members up to {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Quantifier_x_y_following_nothing">
        <source>Quantifier {x,y} following nothing</source>
        <target state="new">Quantifier {x,y} following nothing</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: *</note>
      </trans-unit>
      <trans-unit id="Query">
        <source>Query</source>
        <target state="new">Query</target>
        <note />
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group">
        <source>reference to undefined group</source>
        <target state="new">reference to undefined group</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(1))</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_name_0">
        <source>Reference to undefined group name {0}</source>
        <target state="new">Reference to undefined group name {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k&lt;a&gt;. Here, {0} will be the name of the undefined group ('a')</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_number_0">
        <source>Reference to undefined group number {0}</source>
        <target state="translated">Ссылка на неопределенный номер группы {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;-1&gt;). Here, {0} will be the number of the undefined group ('1')</note>
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_long">
        <source>All control characters. This includes the Cc, Cf, Cs, Co, and Cn categories.</source>
        <target state="translated">Все управляющие символы. Сюда входят категории Cc, Cf, Cs, Co и Cn.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_short">
        <source>all control characters</source>
        <target state="translated">все управляющие символы</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_long">
        <source>All diacritic marks. This includes the Mn, Mc, and Me categories.</source>
        <target state="translated">Все диакритические знаки. Сюда входят категории Mn, Mc и Me.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_short">
        <source>all diacritic marks</source>
        <target state="translated">все диакритические знаки</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_long">
        <source>All letter characters. This includes the Lu, Ll, Lt, Lm, and Lo characters.</source>
        <target state="translated">Все буквенные символы. Сюда входят символы Lu, Ll, Lt, Lm и Lo.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_short">
        <source>all letter characters</source>
        <target state="translated">все буквенные символы</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_long">
        <source>All numbers. This includes the Nd, Nl, and No categories.</source>
        <target state="translated">Все числа. Сюда входят категории Nd, Nl и No.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_short">
        <source>all numbers</source>
        <target state="translated">все числа</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_long">
        <source>All punctuation characters. This includes the Pc, Pd, Ps, Pe, Pi, Pf, and Po categories.</source>
        <target state="translated">Все знаки препинания. Сюда входят категории Pc, Pd, Ps, Pe, Pi, Pf и Po.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_short">
        <source>all punctuation characters</source>
        <target state="translated">все знаки препинания</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_long">
        <source>All separator characters. This includes the Zs, Zl, and Zp categories.</source>
        <target state="translated">Все символы-разделители. Сюда входят категории Zs, Zl и Zp.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_short">
        <source>all separator characters</source>
        <target state="translated">все символы-разделители</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_long">
        <source>All symbols. This includes the Sm, Sc, Sk, and So categories.</source>
        <target state="translated">Все символы. Сюда входят категории Sm, Sc, Sk и So.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_short">
        <source>all symbols</source>
        <target state="translated">все символы</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_long">
        <source>You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.</source>
        <target state="translated">Вы можете использовать символ вертикальной черты (|), чтобы сопоставить любую из серий шаблонов, где каждый шаблон отделяется символом |.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_short">
        <source>alternation</source>
        <target state="translated">чередование</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_long">
        <source>The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified by the 's' option, . matches any character.</source>
        <target state="translated">Символ точки (.) соответствует любому символу, кроме \n (символ новой строки, \u000A). Если шаблон регулярного выражения изменяется параметром RegexOptions.Singleline или если часть шаблона, содержащая класс символов ., изменяется параметром "s", . соответствует любому символу.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_short">
        <source>any character</source>
        <target state="translated">любой символ</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_atomic_group_long">
        <source>Atomic groups (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression) disable backtracking. The regular expression engine will match as many characters in the input string as it can. When no further match is possible, it will not backtrack to attempt alternate pattern matches. (That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)

This option is recommended if you know that backtracking will not succeed. Preventing the regular expression engine from performing unnecessary searching improves performance.</source>
        <target state="translated">Атомарные группы (которые в некоторых других модулях обработки регулярных выражений также называются частями выражения без обратного отслеживания, атомарными частями выражения или частями выражения, сопоставляемыми один раз) отключают обратное отслеживание. Обработчик регулярных выражений будет сопоставлять максимально возможное число символов во входной строке. Если дальнейшее сопоставление невозможно, он не будет выполнять обратное отслеживание, чтобы попытаться определить альтернативные совпадения шаблона. (Таким образом, часть выражения соответствует только тем строкам, которые соответствовали бы ей одной; она не пытается сопоставить строку на основе части выражения и любых следующих за ней частей выражения.)

Этот параметр рекомендуется использовать, если известно, что обратное отслеживание не даст результата. Запрет выполнять ненужный поиск для обработчика регулярных выражений улучшает производительность.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_atomic_group_short">
        <source>atomic group</source>
        <target state="translated">атомарная группа</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_long">
        <source>Matches a backspace character, \u0008</source>
        <target state="translated">Соответствует символу возврата \u0008</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_short">
        <source>backspace character</source>
        <target state="translated">символ возврата</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_long">
        <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.

'name1' is the current group (optional), 'name2' is a previously defined group, and 'subexpression' is any valid regular expression pattern. The balancing group definition deletes the definition of name2 and stores the interval between name2 and name1 in name1. If no name2 group is defined, the match backtracks. Because deleting the last definition of name2 reveals the previous definition of name2, this construct lets you use the stack of captures for group name2 as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.

The balancing group definition uses 'name2' as a stack. The beginning character of each nested construct is placed in the group and in its Group.Captures collection. When the closing character is matched, its corresponding opening character is removed from the group, and the Captures collection is decreased by one. After the opening and closing characters of all nested constructs have been matched, 'name1' is empty.</source>
        <target state="translated">Сбалансированное определение группы удаляет определение ранее определенной группы и сохраняет (в текущей группе) интервал между ранее определенной группой и текущей группой.

Значение "имя1" является текущей группой (необязательная), "имя2" является ранее определенной группой, а "часть выражения" является любым допустимым шаблоном регулярного выражения. Сбалансированное определение группы удаляет определение "имя2" и сохраняет интервал между "имя2" и "имя1" в "имя1". Если группа "имя2" не определена, соответствие определяется по обратному отслеживанию. Так как удаление последнего определения "имя2" приводит к раскрытию предыдущего определения "имя2", эта конструкция позволяет использовать стек записей для группы "имя2" в качестве счетчика для отслеживания вложенных конструкций, таких как круглые скобки или открывающие и закрывающие скобки.

Сбалансированное определение группы использует "имя2" в качестве стека. Начальный символ каждой вложенной конструкции помещается в группу и ее коллекцию Group.Captures. При появлении совпадения для закрывающего символа соответствующий ему открывающий символ удаляется из группы, а коллекция Captures уменьшается на единицу. После обнаружения совпадений для всех открывающих и закрывающих символов всех вложенных конструкций группа "имя1" остается пустой.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_short">
        <source>balancing group</source>
        <target state="translated">группа балансировки</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_base_group">
        <source>base-group</source>
        <target state="translated">базовая группа</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_long">
        <source>Matches a bell (alarm) character, \u0007</source>
        <target state="translated">Соответствует символу колокольчика (сигнала) \u0007</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_short">
        <source>bell character</source>
        <target state="translated">символ колокольчика</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_long">
        <source>Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n.</source>
        <target state="translated">Соответствует символу возврата каретки \u000D. Обратите внимание, что \r не эквивалентен символу новой строки \n.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_short">
        <source>carriage-return character</source>
        <target state="translated">символ возврата каретки</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_long">
        <source>Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.

'base_group' is a positive or negative character group or range. The 'excluded_group' component is another positive or negative character group, or another character class subtraction expression (that is, you can nest character class subtraction expressions).</source>
        <target state="translated">Вычитание класса символов дает набор символов, который является результатом исключения символов одного класса символов из другого класса символов.

base_group является положительной или отрицательной группой символов или диапазоном. Компонент excluded_group — это другая положительная или отрицательная группа символов или другое выражение вычитания класса символов (то есть вы можете вкладывать выражения вычитания класса символов).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_short">
        <source>character class subtraction</source>
        <target state="translated">вычитание класса символов</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_group">
        <source>character-group</source>
        <target state="translated">группа символов</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_comment">
        <source>comment</source>
        <target state="translated">комментарий</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.

'expression' is the initial pattern to match, 'yes' is the pattern to match if expression is matched, and 'no' is the optional pattern to match if expression is not matched.</source>
        <target state="translated">Этот элемент языка пытается соответствовать одному из двух шаблонов в зависимости от того, может ли он соответствовать исходному шаблону.

expression является исходным шаблоном для проверки соответствия, yes является шаблоном, когда выражение имеет соответствие, а no является необязательным шаблоном для проверки соответствия, если выражение не имеет соответствия.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_short">
        <source>conditional expression match</source>
        <target state="translated">условное соответствие выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.

'name' is the name (or number) of a capturing group, 'yes' is the expression to match if 'name' (or 'number') has a match, and 'no' is the optional expression to match if it does not.</source>
        <target state="translated">Этот элемент языка пытается соответствовать одному из двух шаблонов в зависимости от того, установил ли он соответствие указанной группе записи.

name является именем (или номером) группы записи, yes является выражением для проверки соответствия, если name (или number) имеет соответствие, а no является необязательным выражением для проверки соответствия в противном случае.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_short">
        <source>conditional group match</source>
        <target state="translated">условное соответствие группы</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_long">
        <source>The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.</source>
        <target state="translated">Привязка \G указывает, что соответствие должно находиться в том месте, где заканчивается предыдущее соответствие. При использовании этой привязки с методом Regex.Matches или Match.NextMatch она обеспечивает непрерывность всех соответствий.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_short">
        <source>contiguous matches</source>
        <target state="translated">непрерывные соответствия</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_long">
        <source>Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C.</source>
        <target state="translated">Соответствует управляющему символу ASCII, где X — это буква управляющего символа. Например, \cC — это CTRL-C.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_short">
        <source>control character</source>
        <target state="translated">управляющий символ</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_long">
        <source>\d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.

If ECMAScript-compliant behavior is specified, \d is equivalent to [0-9]</source>
        <target state="translated">\d соответствует любой десятичной цифре. Это эквивалент шаблона регулярного выражения \p{Nd}, который включает в себя стандартные десятичные цифры 0–9, а также десятичные цифры из ряда других наборов символов.

Если указано поведение, соответствующее ECMAScript, \d является эквивалентом [0–9].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_short">
        <source>decimal-digit character</source>
        <target state="translated">символ десятичной цифры</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_long">
        <source>A number sign (#) marks an x-mode comment, which starts at the unescaped # character at the end of the regular expression pattern and continues until the end of the line. To use this construct, you must either enable the x option (through inline options) or supply the RegexOptions.IgnorePatternWhitespace value to the option parameter when instantiating the Regex object or calling a static Regex method.</source>
        <target state="translated">Символ решетки (#) помечает комментарий x-mode, который начинается с неэкранированного символа # в конце шаблона регулярного выражения и продолжается до конца строки. Чтобы использовать эту конструкцию, нужно либо включить параметр x (посредством встроенных параметров), либо указать значение RegexOptions.IgnorePatternWhitespace для параметра option при создании экземпляра объекта Regex или вызове статического метода Regex.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_short">
        <source>end-of-line comment</source>
        <target state="translated">комментарий в конце строки</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_long">
        <source>The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, it can only match the last line of the input string.</source>
        <target state="translated">Привязка \z указывает, что соответствие должно находиться в конце входной строки. Как и элемент языка $, \z игнорирует параметр RegexOptions.Multiline. В отличие от элемента языка \Z, \z не соответствует символу \n в конце строки. Поэтому она может соответствовать только последней строке входной строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_short">
        <source>end of string only</source>
        <target state="translated">только конец строки</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_long">
        <source>The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can only match the end of the last line, or the last line before \n.

The \Z anchor matches \n but does not match \r\n (the CR/LF character combination). To match CR/LF, include \r?\Z in the regular expression pattern.</source>
        <target state="translated">Привязка \Z указывает, что соответствие должно находиться в конце входной строки или перед \n в конце входной строки. Она идентична привязке $, за исключением того, что \Z игнорирует параметр RegexOptions.Multiline. Поэтому в многострочной строке она может соответствовать только концу последней строки или последней строке перед \n.

Привязка \Z соответствует \n, но не соответствует значению \r\n (сочетание символов CR/LF). Чтобы обеспечить соответствие CR/LF, включите \r?\Z в шаблон регулярного выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_short">
        <source>end of string or before ending newline</source>
        <target state="translated">конец строки или до последнего символа новой строки</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_long">
        <source>The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string. If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line.

The $ anchor matches \n but does not match \r\n (the combination of carriage return and newline characters, or CR/LF). To match the CR/LF character combination, include \r?$ in the regular expression pattern.</source>
        <target state="translated">Привязка $ указывает, что предыдущий шаблон должен находиться в конце входной строки или перед \n в конце входной строки. Если использовать $ с параметром RegexOptions.Multiline, соответствие также может находиться в конце строки.

Привязка $ соответствует \n, но не соответствует значению \r\n (сочетанию символа возврата каретки и символа новой строки, которое также обозначается как CR/LF). Чтобы обеспечить соответствие сочетанию символов CR/LF, включите \r?$ в шаблон регулярного выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_short">
        <source>end of string or line</source>
        <target state="translated">конец строковых данных или строки</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_long">
        <source>Matches an escape character, \u001B</source>
        <target state="translated">Соответствует escape-символу \u001B</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_short">
        <source>escape character</source>
        <target state="translated">escape-символ</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_excluded_group">
        <source>excluded-group</source>
        <target state="translated">исключенная группа</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_expression">
        <source>expression</source>
        <target state="translated">выражение</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_long">
        <source>Matches a form-feed character, \u000C</source>
        <target state="translated">Соответствует символу перевода страницы \u000C</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_short">
        <source>form-feed character</source>
        <target state="translated">символ перевода страницы</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_long">
        <source>This grouping construct applies or disables the specified options within a subexpression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly
	named or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">Эта конструкция группировки включает или отключает указанные параметры в части выражения. Включаемые параметры указаны после вопросительного знака, а отключаемые параметры — после знака минус. Допустимые параметры:

    i	Использовать сопоставление без учета регистра.
    m	Использовать многострочный режим, где ^ и $ соответствуют началу и концу каждой строки
	(а не началу и концу входной строки).
    s	Использовать однострочный режим, где точка (.) соответствует каждому символу
	(а не каждому символу, кроме \n).
    n	Не записывать неименованные группы. Для записи подходят только явно именованные
	или нумерованные группы формы (?&lt;name&gt; часть выражения).
    x	Исключить неэкранированный пробел из шаблона и включить комментарии
	после символа решетки (#).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_short">
        <source>group options</source>
        <target state="translated">параметры группы</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_long">
        <source>Matches an ASCII character, where ## is a two-digit hexadecimal character code.</source>
        <target state="translated">Соответствует символу ASCII, где ## — это двузначный шестнадцатеричный код символа.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_short">
        <source>hexadecimal escape</source>
        <target state="translated">шестнадцатеричный escape-символ</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_long">
        <source>The (?# comment) construct lets you include an inline comment in a regular expression. The regular expression engine does not use any part of the comment in pattern matching, although the comment is included in the string that is returned by the Regex.ToString method. The comment ends at the first closing parenthesis.</source>
        <target state="translated">Конструкция (?# comment) позволяет включить встроенный комментарий в регулярное выражение. Обработчик регулярных выражений не использует никакие части этого комментария при сравнении шаблонов, однако комментарий включается в строку, возвращаемую методом Regex.ToString. Комментарий заканчивается на первой закрывающей скобке.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_short">
        <source>inline comment</source>
        <target state="translated">встроенный комментарий</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_long">
        <source>Enables or disables specific pattern matching options for the remainder of a regular expression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly named
	or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">Включает или отключает конкретные параметры сопоставления шаблонов для оставшейся части регулярного выражения. Включаемые параметры указаны после вопросительного знака, а отключаемые параметры — после знака минус. Допустимые параметры:

    i	Использовать сопоставление без учета регистра.
    m	Использовать многострочный режим, где ^ и $ соответствуют началу и концу каждой строки
	(вместо начала и конца входной строки).
    s	Использовать однострочный режим, где точка (.) соответствует каждому символу
	(а не каждому символу, кроме \n).
    n	Не записывать неименованные группы. Для записи подходят только явно именованные
	или нумерованные группы формы (?&lt;name&gt; часть выражения).
    x	Исключить неэкранированный пробел из шаблона и включить комментарии
	после символа решетки (#).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_short">
        <source>inline options</source>
        <target state="translated">встроенные параметры</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_issue_0">
        <source>Regex issue: {0}</source>
        <target state="translated">Проблема с регулярным выражением: {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. {0} will be the actual text of one of the above Regular Expression errors.</note>
      </trans-unit>
      <trans-unit id="Regex_letter_lowercase">
        <source>letter, lowercase</source>
        <target state="translated">буква, строчная</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_modifier">
        <source>letter, modifier</source>
        <target state="translated">буква, модификатор</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_other">
        <source>letter, other</source>
        <target state="translated">буква, другая</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_titlecase">
        <source>letter, titlecase</source>
        <target state="translated">буква, заглавная</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_uppercase">
        <source>letter, uppercase</source>
        <target state="translated">буква, прописная</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_enclosing">
        <source>mark, enclosing</source>
        <target state="translated">метка, с включением</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_nonspacing">
        <source>mark, nonspacing</source>
        <target state="translated">метка, без пробелов</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_spacing_combining">
        <source>mark, spacing combining</source>
        <target state="translated">метка, объединение интервалов</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_long">
        <source>The {n,}? quantifier matches the preceding element at least n times, where n is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,}</source>
        <target state="translated">Квантификатор {n,}? соответствует предыдущему элементу по меньшей мере n раз, где n — любое целое число, при этом данное количество должно быть минимальным. Это "ленивый" аналог "жадного" квантификатора {n,}</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">совпадение не менее "n" раз (ленивый)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_long">
        <source>The {n,} quantifier matches the preceding element at least n times, where n is any integer. {n,} is a greedy quantifier whose lazy equivalent is {n,}?</source>
        <target state="translated">Квантификатор {n,} соответствует предыдущему элементу по меньшей мере n раз, где n — любое целое число. {n,} — это "жадный" квантификатор, "ленивым" аналогом которого является {n,}?</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_short">
        <source>match at least 'n' times</source>
        <target state="translated">совпадают по меньшей мере "n" раз</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_long">
        <source>The {n,m}? quantifier matches the preceding element between n and m times, where n and m are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,m}</source>
        <target state="translated">Квантификатор {n,m}? соответствует предыдущему элементу от n до m раз, где n и m — любые целые числа, при этом данное количество должно быть минимальным. Это "ленивый" аналог "жадного" квантификатора {n,m}</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">совпадение не менее "n" раз (ленивый)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_long">
        <source>The {n,m} quantifier matches the preceding element at least n times, but no more than m times, where n and m are integers. {n,m} is a greedy quantifier whose lazy equivalent is {n,m}?</source>
        <target state="translated">Квантификатор {n,m} соответствует предыдущему элементу по меньшей мере n раз, но не более m раз, где n и m — любые целые числа. {n,m} — это "жадный" квантификатор, "ленивым" аналогом которого является {n,m}?</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_short">
        <source>match between 'm' and 'n' times</source>
        <target state="translated">совпадение от "m" до "n" раз</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_long">
        <source>The {n}? quantifier matches the preceding element exactly n times, where n is any integer. It is the lazy counterpart of the greedy quantifier {n}+</source>
        <target state="translated">Квантификатор {n}? соответствует предыдущему элементу ровно n раз, где n — любое целое число. Это "ленивый" аналог "жадного" квантификатора {n}+</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_short">
        <source>match exactly 'n' times (lazy)</source>
        <target state="translated">совпадение ровно "n" раз (ленивый)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_long">
        <source>The {n} quantifier matches the preceding element exactly n times, where n is any integer. {n} is a greedy quantifier whose lazy equivalent is {n}?</source>
        <target state="translated">Квантификатор {n} соответствует предыдущему элементу ровно n раз, где n — любое целое число. {n} — это "жадный" квантификатор, "ленивым" аналогом которого является {n}?</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_short">
        <source>match exactly 'n' times</source>
        <target state="translated">совпадение ровно "n" раз</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_long">
        <source>The +? quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier +</source>
        <target state="translated">Квантификатор +? соответствует предыдущему элементу один или несколько раз, при этом данное количество должно быть минимальным. Это "ленивый" аналог "жадного" квантификатора +</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_short">
        <source>match one or more times (lazy)</source>
        <target state="translated">совпадение один или несколько раз (ленивый)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_long">
        <source>The + quantifier matches the preceding element one or more times. It is equivalent to the {1,} quantifier. + is a greedy quantifier whose lazy equivalent is +?.</source>
        <target state="translated">Квантификатор + соответствует предыдущему элементу один или несколько раз. Это эквивалент квантификатора {1,}. + — это "жадный" квантификатор, "ленивым" аналогом которого является +?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_short">
        <source>match one or more times</source>
        <target state="translated">совпадение один или несколько раз</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_long">
        <source>The *? quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier *</source>
        <target state="translated">Квантификатор *? соответствует предыдущему элементу ни одного или несколько раз, при этом данное количество должно быть минимальным. Это "ленивый" аналог "жадного" квантификатора *</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_short">
        <source>match zero or more times (lazy)</source>
        <target state="translated">совпадение ни одного или несколько раз (ленивый)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_long">
        <source>The * quantifier matches the preceding element zero or more times. It is equivalent to the {0,} quantifier. * is a greedy quantifier whose lazy equivalent is *?.</source>
        <target state="translated">Квантификатор * соответствует предыдущему элементу ни одного или несколько раз. Это эквивалент квантификатора {0,}. * — это "жадный" квантификатор, "ленивым" аналогом которого является *?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_short">
        <source>match zero or more times</source>
        <target state="translated">совпадение ни одного или несколько раз</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_long">
        <source>The ?? quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier ?</source>
        <target state="translated">Квантификатор ?? соответствует предыдущему элементу ни одного раза или один раз, при этом данное количество должно быть минимальным. Это "ленивый" аналог "жадного" квантификатора ?</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_short">
        <source>match zero or one time (lazy)</source>
        <target state="translated">совпадение ни одного раза или один раз (ленивый)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_long">
        <source>The ? quantifier matches the preceding element zero or one time. It is equivalent to the {0,1} quantifier. ? is a greedy quantifier whose lazy equivalent is ??.</source>
        <target state="translated">Квантификатор ? соответствует предыдущему элементу ни одного раза или один раз. Это эквивалент квантификатора {0,1}. ? — это "жадный" квантификатор, "ленивым" аналогом которого является ??.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_short">
        <source>match zero or one time</source>
        <target state="translated">совпадение ни одного раза или один раз</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_long">
        <source>This grouping construct captures a matched 'subexpression', where 'subexpression' is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one. The capture that is numbered zero is the text matched by the entire regular expression pattern.</source>
        <target state="translated">Эта конструкция группировки записывает соответствующую "часть выражения", где "часть выражения" — это любой допустимый шаблон регулярного выражения. Записи, использующие круглые скобки, нумеруются автоматически слева направо в порядке открывающих скобок в регулярном выражении, начиная с первой. Запись с нулевым номером — это текст, совпадающий со всем шаблоном регулярного выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_short">
        <source>matched subexpression</source>
        <target state="translated">соответствующая часть выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name">
        <source>name</source>
        <target state="translated">имя</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name1">
        <source>name1</source>
        <target state="translated">имя1</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name2">
        <source>name2</source>
        <target state="translated">имя2</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name_or_number">
        <source>name-or-number</source>
        <target state="translated">имя-или-число</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_long">
        <source>A named or numbered backreference.

'name' is the name of a capturing group defined in the regular expression pattern.</source>
        <target state="translated">Именованная или нумерованная обратная ссылка.

Значение "имя" — это имя группы записи, определенное в шаблоне регулярного выражения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_short">
        <source>named backreference</source>
        <target state="translated">именованная обратная ссылка</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_long">
        <source>Captures a matched subexpression and lets you access it by name or by number.

'name' is a valid group name, and 'subexpression' is any valid regular expression pattern. 'name' must not contain any punctuation characters and cannot begin with a number.

If the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the only way to capture a subexpression is to explicitly name capturing groups.</source>
        <target state="translated">Записывает совпадающую часть выражения и позволяет вам обратиться к ней по имени или номеру.

Значение "имя" — это допустимое имя группы, а "часть выражения" — любой допустимый шаблон регулярного выражения. Значение "имя" не должно содержать знаков пунктуации или начинаться с числа.

Если параметр RegexOptions метода сопоставления шаблона регулярного выражения включает флаг RegexOptions.ExplicitCapture или если параметр n применяется к этой части выражения, единственным способом записи части выражения является явное именование групп записи.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_short">
        <source>named matched subexpression</source>
        <target state="translated">именованная соответствующая часть выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_long">
        <source>A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters are specified individually.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">Отрицательная группа символов указывает список символов, которые не должны присутствовать во входной строке для выполняемой проверки соответствия. Список символов настраивается в индивидуальном порядке.

Можно сцепить два или более диапазонов символов. Например, чтобы указать диапазон десятичных цифр от 0 до 9, диапазон строчных букв от a до f и диапазон прописных букв от A до F, используйте [0-9a-fA-F].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_short">
        <source>negative character group</source>
        <target state="translated">отрицательная группа символов</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_range_long">
        <source>A negative character range specifies a list of characters that must not appear in an input string for a match to occur. 'firstCharacter' is the character that begins the range, and 'lastCharacter' is the character that ends the range.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">Отрицательный диапазон символов указывает список символов, которые не должны присутствовать во входной строке для выполняемой проверки соответствия. firstCharacter — это первый символ диапазона, а lastCharacter — последний.

Можно сцепить два или более диапазонов символов. Например, чтобы указать диапазон десятичных цифр от 0 до 9, диапазон строчных букв от a до f и диапазон прописных букв от A до F, используйте [0-9a-fA-F].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_long">
        <source>The regular expression construct \P{ name } matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">Конструкция регулярного выражения \P{ name } соответствует любому символу, который не относится к общей категории Юникода или именованному блоку, где "имя" — это сокращение названия категории или имя именованного блока.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_short">
        <source>negative unicode category</source>
        <target state="translated">отрицательная категория Юникода</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_long">
        <source>Matches a new-line character, \u000A</source>
        <target state="translated">Соответствует символу новой строки \u000A</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_short">
        <source>new-line character</source>
        <target state="translated">символ новой строки</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_no">
        <source>no</source>
        <target state="translated">нет</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_long">
        <source>\D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.

If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9]</source>
        <target state="translated">\D соответствует любому символу, не являющемуся цифрой. Это эквивалент шаблона регулярного выражения \P{Nd}.

Если указано поведение, соответствующее ECMAScript, \D является эквивалентом [^0-9]</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_short">
        <source>non-digit character</source>
        <target state="translated">символ, не являющийся цифрой</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_long">
        <source>\S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.

If ECMAScript-compliant behavior is specified, \S is equivalent to [^ \f\n\r\t\v]</source>
        <target state="translated">\S соответствует любому символу, не являющемуся пробелом. Это эквивалент шаблона регулярного выражения [^\f\n\r\t\v\x85\p{Z}] либо противоположность шаблона регулярного выражения, эквивалентного \s, который сопоставляет символы пробелов.

Если указано поведение, соответствующее ECMAScript, \S является эквивалентом [^ \f\n\r\t\v]</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_short">
        <source>non-white-space character</source>
        <target state="translated">символ, не являющийся пробелом</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_long">
        <source>The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor.</source>
        <target state="translated">Привязка \B указывает, что соответствие не должно находиться на границе слов. Это противоположность привязки \b.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_short">
        <source>non-word boundary</source>
        <target state="translated">граница не по словам</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_character_long">
        <source>\W matches any non-word character. It matches any character except for those in the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \W is equivalent to [^a-zA-Z_0-9]</source>
        <target state="translated">\W соответствует любому символу, не образующему слово. Он соответствует любому символу, кроме относящихся к следующим категориям Юникода:

    Ll	буква, строчная
    Lu	буква, прописная
    Lt	буква, заглавная
    Lo	буква, другая
    Lm	буква, модификатор
    Mn	метка, без пробела
    Nd	число, десятичная цифра
    Pc	пунктуация, соединитель

Если указано поведение, соответствующее ECMAScript, \W является эквивалентом [^a-zA-Z_0-9]</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized. </note>
      </trans-unit>
      <trans-unit id="Regex_non_word_character_short">
        <source>non-word character</source>
        <target state="translated">символ, не образующий слово</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_long">
        <source>This construct does not capture the substring that is matched by a subexpression:

The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.

If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
        <target state="translated">Эта конструкция не записывает подстроку, соответствующую части выражения:

Конструкция группы без записи обычно используется, когда квантификатор применяется к группе, но подстроки, записанные группой, не представляют интереса.

Если регулярное выражение содержит вложенные конструкциb группировки, внешняя конструкция группы без записи не применяется к внутренним вложенным конструкциям группы.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_short">
        <source>noncapturing group</source>
        <target state="translated">группа без записи</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_decimal_digit">
        <source>number, decimal digit</source>
        <target state="translated">число, десятичная цифра</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_letter">
        <source>number, letter</source>
        <target state="translated">число, буква</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_other">
        <source>number, other</source>
        <target state="translated">число, другое</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_long">
        <source>A numbered backreference, where 'number' is the ordinal position of the capturing group in the regular expression. For example, \4 matches the contents of the fourth capturing group.

There is an ambiguity between octal escape codes (such as \16) and \number backreferences that use the same notation. If the ambiguity is a problem, you can use the \k&lt;name&gt; notation, which is unambiguous and cannot be confused with octal character codes. Similarly, hexadecimal codes such as \xdd are unambiguous and cannot be confused with backreferences.</source>
        <target state="translated">Нумерованная обратная ссылка, где "номер" — порядковый номер группы записи в регулярном выражении. Например, \4 соответствует содержимому четвертой группы записи.

Существует неоднозначность между восьмеричными escape-кодами (например, \16) и обратными ссылками \number, которые используют одну и ту же нотацию. Если подобная неоднозначность является проблемой, можно использовать нотацию \k&lt;name&gt;, которая не является неоднозначной и не может быть перепутана с восьмеричными кодами символов. Аналогичным образом шестнадцатеричные коды, такие как \xdd, не являются неоднозначными и не могут быть перепутаны с обратными ссылками.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_short">
        <source>numbered backreference</source>
        <target state="translated">нумерованная обратная ссылка</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_control">
        <source>other, control</source>
        <target state="translated">другое, управление</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_format">
        <source>other, format</source>
        <target state="translated">другой, формат</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_not_assigned">
        <source>other, not assigned</source>
        <target state="translated">другое, не назначено</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_private_use">
        <source>other, private use</source>
        <target state="translated">другое, частное использование</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_surrogate">
        <source>other, surrogate</source>
        <target state="translated">другое, суррогат</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_long">
        <source>A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur.</source>
        <target state="translated">Положительная группа символов задает список символов, любой из которых может выводиться во входной строке для выполняемого сопоставления.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_short">
        <source>positive character group</source>
        <target state="translated">положительная группа символов</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_long">
        <source>A positive character range specifies a range of characters, any one of which may appear in an input string for a match to occur.  'firstCharacter' is the character that begins the range and 'lastCharacter' is the character that ends the range. </source>
        <target state="translated">Положительная группа символов задает диапазон символов, любой из которых может выводиться во входной строке для выполняемого сопоставления. firstCharacter — это первый символ диапазона, а lastCharacter — последний.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_short">
        <source>positive character range</source>
        <target state="translated">положительный диапазон символов</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_close">
        <source>punctuation, close</source>
        <target state="translated">пунктуация, закрытие</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_connector">
        <source>punctuation, connector</source>
        <target state="translated">пунктуация, соединитель</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_dash">
        <source>punctuation, dash</source>
        <target state="translated">пунктуация, тире</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_final_quote">
        <source>punctuation, final quote</source>
        <target state="translated">пунктуация, конечная кавычка</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_initial_quote">
        <source>punctuation, initial quote</source>
        <target state="translated">пунктуация, начальная кавычка</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_open">
        <source>punctuation, open</source>
        <target state="translated">пунктуация, открытие</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_other">
        <source>punctuation, other</source>
        <target state="translated">пунктуация, другие</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_line">
        <source>separator, line</source>
        <target state="translated">разделитель, строка</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_paragraph">
        <source>separator, paragraph</source>
        <target state="translated">разделитель, абзац</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_space">
        <source>separator, space</source>
        <target state="translated">разделитель, пробел</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_long">
        <source>The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input string.</source>
        <target state="translated">Привязка \A указывает, что совпадение должно находиться в начале входной строки. Она идентична привязке ^, за исключением того, что \A игнорирует параметр RegexOptions.Multiline. Поэтому она может соответствовать только началу первой строки в многострочной входной строке.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_short">
        <source>start of string only</source>
        <target state="translated">только начало строки</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_long">
        <source>The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.</source>
        <target state="translated">Привязка ^ указывает, что следующий шаблон должен начинаться с позиции первого знака строки. Если вы используете ^ с параметром RegexOptions.Multiline, совпадение должно находиться в начале каждой строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_short">
        <source>start of string or line</source>
        <target state="translated">начало строковых данных или строки</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_subexpression">
        <source>subexpression</source>
        <target state="translated">часть выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_currency">
        <source>symbol, currency</source>
        <target state="translated">символ, валюта</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_math">
        <source>symbol, math</source>
        <target state="translated">символ, математика</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_modifier">
        <source>symbol, modifier</source>
        <target state="translated">символ, модификатор</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_other">
        <source>symbol, other</source>
        <target state="translated">символ, другое</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_long">
        <source>Matches a tab character, \u0009</source>
        <target state="translated">Соответствует знаку табуляции \u0009</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_short">
        <source>tab character</source>
        <target state="translated">знак табуляции</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_long">
        <source>The regular expression construct \p{ name } matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">Конструкция регулярного выражения \p{ name } соответствует любому символу, который относится к общей категории Юникода или именованному блоку, где "имя" — это сокращение названия категории или имя именованного блока.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_short">
        <source>unicode category</source>
        <target state="translated">категория Юникода</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_long">
        <source>Matches a UTF-16 code unit whose value is #### hexadecimal.</source>
        <target state="translated">Соответствует блоку кода UTF-16, шестнадцатеричное значение которого равно ####.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_short">
        <source>unicode escape</source>
        <target state="translated">escape-символ Юникода</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_general_category_0">
        <source>Unicode General Category: {0}</source>
        <target state="translated">Общая категория Юникода: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_long">
        <source>Matches a vertical-tab character, \u000B</source>
        <target state="translated">Соответствует знаку вертикальной табуляции \u000B</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_short">
        <source>vertical-tab character</source>
        <target state="translated">знак вертикальной табуляции</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_long">
        <source>\s matches any white-space character. It is equivalent to the following escape sequences and Unicode categories:

    \f	The form feed character, \u000C
    \n	The newline character, \u000A
    \r	The carriage return character, \u000D
    \t	The tab character, \u0009
    \v	The vertical tab character, \u000B
    \x85	The ellipsis or NEXT LINE (NEL) character (…), \u0085
    \p{Z}	Matches any separator character

If ECMAScript-compliant behavior is specified, \s is equivalent to [ \f\n\r\t\v]</source>
        <target state="translated">\s соответствует любому символу пробела. Она эквивалентна следующим escape-последовательностям и категориям Юникода:

    \f	символ перевода страницы, \u000C
    \n	символ новой строки, \u000A
    \r	символ возврата каретки, \u000D
    \t	знак табуляции, \u0009
    \v	знак вертикальной табуляции, \u000B
    \x85	многоточие или символ NEXT LINE (NEL)(…), \u0085
    \p{Z}	соответствует любому символу-разделителю

Если указано поведение, соответствующее ECMAScript, \s является эквивалентом [ \f\n\r\t\v]</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_short">
        <source>white-space character</source>
        <target state="translated">символ пробела</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_long">
        <source>The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore. The match may also occur on a word boundary at the beginning or end of the string.

The \b anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
        <target state="translated">Привязка \b указывает, что соответствие должно находиться между символом слова (элемент языка \w) и символом, не образующим слово, (элемент языка \W). Символы слова состоят из буквенно-цифровых символов и символов подчеркивания; не образующий слово символ — это любой символ, не являющийся буквенно-цифровым и символом подчеркивания. Соответствие также может находиться на границе слов в начале или конце строки.

Привязка \b часто используется для обеспечения того, что часть строки соответствует всему слову, а не только его началу или концу.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_short">
        <source>word boundary</source>
        <target state="translated">граница слов</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_character_long">
        <source>\w matches any word character. A word character is a member of any of the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \w is equivalent to [a-zA-Z_0-9]</source>
        <target state="translated">\w соответствует любому символу слова. Символ слова относится к любой из следующих категорий Юникода:

    Ll	буква, строчная
    Lu	буква, прописная
    Lt	буква, заглавная
    Lo	буква, другая
    Lm	буква, модификатор
    Mn	метка, без пробела
    Nd	число, десятичная цифра
    Pc	пунктуация, соединитель

Если указано поведение, соответствующее ECMAScript, \w является эквивалентом [a-zA-Z_0-9]</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized.</note>
      </trans-unit>
      <trans-unit id="Regex_word_character_short">
        <source>word character</source>
        <target state="translated">символ слова</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_yes">
        <source>yes</source>
        <target state="translated">да</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_long">
        <source>A zero-width negative lookahead assertion, where for the match to be successful, the input string must not match the regular expression pattern in subexpression. The matched string is not included in the match result.

A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression. At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched. In this case, it is often used to limit backtracking. At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
        <target state="translated">Отрицательное утверждение просмотра вперед нулевой ширины, в котором для успешного сопоставления входная строка не должна соответствовать шаблону регулярного выражения в части выражения. Соответствующая строка не включается в результат сравнения.

Отрицательное упреждающее утверждение нулевой ширины обычно используется либо в начале, либо в конце регулярного выражения. В начале выражения оно может определять определенный шаблон, который не должен совпадать, когда начало регулярного выражения определяет схожий, но более общий сравниваемый шаблон. В этом случае такое утверждение часто используется для ограничения обратного отслеживания. В конце регулярного выражения такое утверждение может определять часть выражения, которое не может находиться в конце сравнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_short">
        <source>zero-width negative lookahead assertion</source>
        <target state="translated">отрицательное утверждение просмотра вперед нулевой ширины</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_long">
        <source>A zero-width negative lookbehind assertion, where for a match to be successful, 'subexpression' must not occur at the input string to the left of the current position. Any substring that does not match 'subexpression' is not included in the match result.

Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define precludes a match in the string that follows. They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</source>
        <target state="translated">Отрицательное утверждение просмотра назад нулевой ширины, где для успешного сопоставления "часть выражения" не должна находиться во входной строке слева от текущей позиции. Любая подстрока, не соответствующая "части выражения", не включается в результат сравнения.

Отрицательные отстающие утверждения просмотра назад обычно используются в начале регулярных выражений. Шаблон, который они определяют, предотвращает совпадение в следующей строке. Они также используются для ограничения обратного отслеживания, когда один или несколько последних символов в группе записи не должны соответствовать символам шаблона регулярного выражения этой группы.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_short">
        <source>zero-width negative lookbehind assertion</source>
        <target state="translated">отрицательное утверждение просмотра назад нулевой ширины</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_long">
        <source>A zero-width positive lookahead assertion, where for a match to be successful, the input string must match the regular expression pattern in 'subexpression'. The matched substring is not included in the match result. A zero-width positive lookahead assertion does not backtrack.

Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern. It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match. It is also useful for preventing excessive backtracking. You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</source>
        <target state="translated">Положительное утверждение просмотра вперед нулевой ширины, в котором для успешного сопоставления входная строка должна соответствовать шаблону регулярного выражения в части выражения. Соответствующая подстрока не включается в результат сравнения. Положительное упреждающее утверждение нулевой ширины не выполняет обратное отслеживание.

Обычно такое утверждение находится в конце шаблона регулярного выражения. Оно определяет подстроку, которая должна быть найдена в конце строки для выполнения сравнения, но не может быть включена в него. Кроме того, это утверждение удобно использовать для предотвращения избыточного обратного отслеживания. Вы можете использовать положительное упреждающее утверждение нулевой ширины, чтобы убедиться, что определенная записанная группа начинается с текста, который соответствует подмножеству шаблона, определенного для этой записанной группы.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_short">
        <source>zero-width positive lookahead assertion</source>
        <target state="translated">положительное утверждение просмотра вперед нулевой ширины</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_long">
        <source>A zero-width positive lookbehind assertion, where for a match to be successful, 'subexpression' must occur at the input string to the left of the current position. 'subexpression' is not included in the match result. A zero-width positive lookbehind assertion does not backtrack.

Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
        <target state="translated">Положительное утверждение просмотра назад нулевой ширины, где для успешного сопоставления "часть выражения" должна находиться во входной строке, слева от текущей позиции. "Часть выражения" не включается в результат сравнения. Такое утверждение не выполняет обратное отслеживание.

Положительные отстающие утверждения просмотра назад обычно используются в начале регулярных выражений. Шаблон, который они определяют, является необходимым условием для совпадения, хотя и не входит в его результат.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_short">
        <source>zero-width positive lookbehind assertion</source>
        <target state="translated">положительное утверждение просмотра назад нулевой ширины</target>
        <note />
      </trans-unit>
      <trans-unit id="Removal_of_document_not_supported">
        <source>Removal of document not supported</source>
        <target state="translated">Удаление документа не поддерживается</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unnecessary_casts">
        <source>Remove unnecessary casts</source>
        <target state="translated">Удалить ненужные приведения</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unnecessary_imports_or_usings">
        <source>Remove unnecessary imports or usings</source>
        <target state="translated">Удалить ненужные операции импорта или использования</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unused_parameters">
        <source>Remove unused parameters</source>
        <target state="translated">Удалить неиспользуемый параметр</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unused_suppressions">
        <source>Remove unused suppressions</source>
        <target state="translated">Удалить неиспользуемые подавления</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unused_variables">
        <source>Remove unused variables</source>
        <target state="translated">Удалить неиспользуемые переменные</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_0_that_contains_an_active_statement_requires_restarting_the_application">
        <source>Removing {0} that contains an active statement requires restarting the application.</source>
        <target state="translated">Для удаления {0} с активным оператором требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Renaming_0_requires_restarting_the_application">
        <source>Renaming {0} requires restarting the application.</source>
        <target state="translated">Для переименования {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Renaming_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
        <source>Renaming {0} requires restarting the application because it is not supported by the runtime.</source>
        <target state="translated">Для переименования {0} требуется перезапустить приложение, поскольку это не поддерживается средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Renaming_a_captured_variable_from_0_to_1_requires_restarting_the_application">
        <source>Renaming a captured variable, from '{0}' to '{1}' requires restarting the application.</source>
        <target state="translated">Для переименования зафиксированной переменной из "{0}" в "{1}" требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Renaming_anonymous_type_members_is_not_yet_supported">
        <source>Renaming anonymous type members is not yet supported.</source>
        <target state="new">Renaming anonymous type members is not yet supported.</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_1">
        <source>Replace '{0}' with '{1}' </source>
        <target state="translated">Замените '{0}' на '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_conditional_expression_with_statements">
        <source>Replace conditional expression with statements</source>
        <target state="translated">Заменить условное выражение операторами</target>
        <note />
      </trans-unit>
      <trans-unit id="Required">
        <source>required</source>
        <target state="translated">требуется</target>
        <note>Used in the object initializer completion.</note>
      </trans-unit>
      <trans-unit id="Resolve_0">
        <source>Resolve: '{0}'</source>
        <target state="translated">Разрешить: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Resolve_module_0_of_1">
        <source>Resolve module: '{0}' of '{1}'</source>
        <target state="translated">Разрешить модуль: "{0}" из "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="RudeEdit">
        <source>Rude edit</source>
        <target state="translated">Грубая редакция</target>
        <note />
      </trans-unit>
      <trans-unit id="Run_All_Tests">
        <source>Run All Tests</source>
        <target state="translated">Запустить все тесты</target>
        <note />
      </trans-unit>
      <trans-unit id="Run_Test">
        <source>Run Test</source>
        <target state="translated">Запуск теста</target>
        <note />
      </trans-unit>
      <trans-unit id="Selection_does_not_contain_a_valid_token">
        <source>Selection does not contain a valid token.</source>
        <target state="translated">Выделение не содержит допустимый токен.</target>
        <note />
      </trans-unit>
      <trans-unit id="Selection_not_contained_inside_a_type">
        <source>Selection not contained inside a type.</source>
        <target state="translated">Выделенный фрагмент не входит в тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="SemanticSearch">
        <source>Semantic Search</source>
        <target state="translated">Семантический поиск</target>
        <note />
      </trans-unit>
      <trans-unit id="Semantic_search_only_supported_on_net_core">
        <source>Semantic search is only supported when code analysis runs in a separate process on the latest .NET (see Tools &gt; Options &gt; Text Editor &gt; C# &gt; Advanced).</source>
        <target state="translated">Семантический поиск поддерживается только в том случае, если анализ кода выполняется в отдельном процессе последней версии .NET (см. "Сервис" &gt; "Параметры" &gt; "Текстовый редактор" &gt; "C#" &gt; "Дополнительно").</target>
        <note />
      </trans-unit>
      <trans-unit id="Semantic_search_query_failed_to_compile">
        <source>Semantic search query failed to compile</source>
        <target state="new">Semantic search query failed to compile</target>
        <note />
      </trans-unit>
      <trans-unit id="Semantic_search_query_terminated_with_exception">
        <source>Semantic search query terminated with exception</source>
        <target state="new">Semantic search query terminated with exception</target>
        <note />
      </trans-unit>
      <trans-unit id="Silent">
        <source>Silent</source>
        <target state="translated">Тихий</target>
        <note />
      </trans-unit>
      <trans-unit id="Simplify_member_access_0">
        <source>Simplify member access '{0}'</source>
        <target state="translated">Упрощение доступа для членов "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Simplify_name_0">
        <source>Simplify name '{0}'</source>
        <target state="translated">Упрощение имени "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Sort_Imports_or_usings">
        <source>Sort Imports or usings</source>
        <target state="translated">Сортировать операторы Imports или директивы using</target>
        <note />
      </trans-unit>
      <trans-unit id="Sort_accessibility_modifiers">
        <source>Sort accessibility modifiers</source>
        <target state="translated">Сортировать модификаторы доступности</target>
        <note />
      </trans-unit>
      <trans-unit id="Source_code_language_information_was_not_found_in_PDB">
        <source>Source code language information was not found in PDB.</source>
        <target state="translated">Сведения о языке исходного кода не найдены в PDB-файле.</target>
        <note />
      </trans-unit>
      <trans-unit id="Source_is_a_reference_assembly">
        <source>Source is a reference assembly, not enough information to find PDB.</source>
        <target state="translated">Источник является базовой сборкой. Недостаточно сведений для поиска PDB-файла.</target>
        <note />
      </trans-unit>
      <trans-unit id="Split_into_consecutive_0_statements">
        <source>Split into consecutive '{0}' statements</source>
        <target state="translated">Разделить на последовательные операторы "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Split_into_nested_0_statements">
        <source>Split into nested '{0}' statements</source>
        <target state="translated">Разделить на вложенные операторы "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Strings_must_start_with_double_quote_not_single_quote">
        <source>Strings must start with " not '</source>
        <target state="translated">Строки должны начинаться с " не '</target>
        <note />
      </trans-unit>
      <trans-unit id="Suppress_0">
        <source>Suppress {0}</source>
        <target state="translated">Скрыть {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Switching_between_lambda_and_local_function_requires_restarting_the_application">
        <source>Switching between a lambda and a local function requires restarting the application.</source>
        <target state="translated">Для переключения между лямбда-выражением и локальной функцией требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbol_found_in_assembly_path_0">
        <source>Symbol found in assembly path '{0}'</source>
        <target state="translated">Найден символ в пути сборки "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbol_search">
        <source>Symbol search</source>
        <target state="translated">Поиск символов</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbols">
        <source>Symbols</source>
        <target state="translated">Символы</target>
        <note />
      </trans-unit>
      <trans-unit id="Syntax_error">
        <source>Syntax error</source>
        <target state="translated">Синтаксическая ошибка</target>
        <note />
      </trans-unit>
      <trans-unit id="Target_type_matches">
        <source>Target type matches</source>
        <target state="translated">Соответствия целевого типа</target>
        <note />
      </trans-unit>
      <trans-unit id="The_assembly_0_containing_type_1_references_NET_Framework">
        <source>The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.</source>
        <target state="translated">Сборка "{0}", содержащая тип "{1}", ссылается на платформу .NET Framework, которая не поддерживается.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_assembly_0_references_compiler_version_1_newer_than_2">
        <source>The analyzer assembly '{0}' references version '{1}' of the compiler, which is newer than the currently running version '{2}'.</source>
        <target state="new">The analyzer assembly '{0}' references version '{1}' of the compiler, which is newer than the currently running version '{2}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_query_does_not_specify_0_method_or_top_level_function">
        <source>The query does not specify '{0}' method or top-level function</source>
        <target state="new">The query does not specify '{0}' method or top-level function</target>
        <note />
      </trans-unit>
      <trans-unit id="The_selection_contains_a_local_function_call_without_its_declaration">
        <source>The selection contains a local function call without its declaration.</source>
        <target state="translated">Выделенный фрагмент содержит вызов локальной функции без ее объявления.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_symbol_has_no_base">
        <source>The symbol has no base.</source>
        <target state="translated">У этого символа нет основания.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_symbol_has_no_implementations">
        <source>The symbol has no implementations.</source>
        <target state="translated">Этот символ не имеет реализации.</target>
        <note />
      </trans-unit>
      <trans-unit id="This_0_has_1_references">
        <source>This {0} has {1} reference(s).</source>
        <target state="translated">Cсылок у {0}: {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Timeout_SourceLink">
        <source>Timed out trying to download source code from SourceLink. Subsequent requests may succeed.</source>
        <target state="translated">Истекло время ожидания при попытке скачать исходный код из SourceLink. Последующие запросы могут быть успешными.</target>
        <note />
      </trans-unit>
      <trans-unit id="Timeout_symbol_server">
        <source>Timed out trying to download PDB from symbol server. Subsequent requests may succeed.</source>
        <target state="translated">Истекло время ожидания при попытке скачать PDB-файл с сервера символов. Последующие запросы могут быть успешными.</target>
        <note />
      </trans-unit>
      <trans-unit id="Too_many_bars_in_conditional_grouping">
        <source>Too many | in (?()|)</source>
        <target state="translated">Слишком много операторов "|" в "(?()|)"</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0)a|b|)</note>
      </trans-unit>
      <trans-unit id="Too_many_close_parens">
        <source>Too many )'s</source>
        <target state="translated">Слишком много закрывающих круглых скобок</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: )</note>
      </trans-unit>
      <trans-unit id="Trailing_comma_not_allowed">
        <source>Trailing comma not allowed</source>
        <target state="translated">Завершающая запятая не разрешена</target>
        <note />
      </trans-unit>
      <trans-unit id="Types_colon">
        <source>Types:</source>
        <target state="translated">Типы:</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToReadSourceFileOrPdb">
        <source>Unable to read source file '{0}' or the PDB built for the containing project. Any changes made to this file while debugging won't be applied until its content matches the built source.</source>
        <target state="translated">Не удалось считать исходный файл "{0}" или PDB, созданный для содержащего проекта. Все изменения, внесенные в этот файл во время отладки, не будут применены, пока содержимое файла не будет соответствовать созданному источнику.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unable_to_create_0">
        <source>Unable to create '{0}'</source>
        <target state="translated">Не удается создать "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Unable_to_load_type_0_1">
        <source>Unable to load type '{0}': '{1}'</source>
        <target state="new">Unable to load type '{0}': '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_property">
        <source>Unknown property</source>
        <target state="translated">Неизвестное свойство</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{}</note>
      </trans-unit>
      <trans-unit id="Unknown_property_0">
        <source>Unknown property '{0}'</source>
        <target state="translated">Неизвестное свойство "{0}"</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{xxx}. Here, {0} will be the name of the unknown property ('xxx')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_control_character">
        <source>Unrecognized control character</source>
        <target state="translated">Не удалось распознать управляющий символ</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [\c]</note>
      </trans-unit>
      <trans-unit id="Unrecognized_escape_sequence_0">
        <source>Unrecognized escape sequence \{0}</source>
        <target state="translated">Не удалось распознать escape-последовательность \{0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \m. Here, {0} will be the unrecognized character ('m')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_grouping_construct">
        <source>Unrecognized grouping construct</source>
        <target state="translated">Не удалось распознать конструкцию группировки</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;</note>
      </trans-unit>
      <trans-unit id="Unterminated_character_class_set">
        <source>Unterminated [] set</source>
        <target state="translated">Набор [] без признака завершения</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [</note>
      </trans-unit>
      <trans-unit id="Unterminated_comment">
        <source>Unterminated comment</source>
        <target state="translated">Незавершенный комментарий</target>
        <note />
      </trans-unit>
      <trans-unit id="Unterminated_regex_comment">
        <source>Unterminated (?#...) comment</source>
        <target state="translated">Незавершенный комментарий (? #...)</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?#</note>
      </trans-unit>
      <trans-unit id="Unterminated_string">
        <source>Unterminated string</source>
        <target state="translated">Незавершенная строка</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_all_arguments">
        <source>Unwrap all arguments</source>
        <target state="translated">Развернуть все аргументы</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_all_elements">
        <source>Unwrap all elements</source>
        <target state="translated">Не переносить все элементы</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_all_parameters">
        <source>Unwrap all parameters</source>
        <target state="translated">Развернуть все параметры</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_and_indent_all_arguments">
        <source>Unwrap and indent all arguments</source>
        <target state="translated">Развернуть все аргументы и удалить отступы для них</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_and_indent_all_parameters">
        <source>Unwrap and indent all parameters</source>
        <target state="translated">Развернуть все параметры и добавить отступы для них</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_argument_list">
        <source>Unwrap argument list</source>
        <target state="translated">Развернуть список аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_call_chain">
        <source>Unwrap call chain</source>
        <target state="translated">Развернуть цепочку вызовов</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_collection">
        <source>Unwrap collection</source>
        <target state="translated">Распаковка коллекции</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_expression">
        <source>Unwrap expression</source>
        <target state="translated">Развернуть выражение</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_initializer">
        <source>Unwrap initializer</source>
        <target state="translated">Не переносить инициализатор</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_parameter_list">
        <source>Unwrap parameter list</source>
        <target state="translated">Развернуть список параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_0_requires_restarting_the_application">
        <source>Updating '{0}' requires restarting the application.</source>
        <target state="translated">Для обновления "{0}" требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_0_within_generic_type_or_method_requires_restarting_the_application_because_is_not_supported_by_the_runtime">
        <source>Updating {0} within generic type or method requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">Обновление {0} в универсальном типе или методе требует перезапуска приложения, поскольку это не поддерживается средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_a_0_around_an_active_statement_requires_restarting_the_application">
        <source>Updating a {0} around an active statement requires restarting the application.</source>
        <target state="translated">Для обновления {0} вокруг активного оператора требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_a_complex_statement_containing_an_await_expression_requires_restarting_the_application">
        <source>Updating a complex statement containing an await expression requires restarting the application.</source>
        <target state="translated">Для обновления сложного оператора, содержащего выражение await, требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_an_active_statement_requires_restarting_the_application">
        <source>Updating an active statement requires restarting the application.</source>
        <target state="translated">Для обновления активного оператора требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_async_or_iterator_modifier_around_an_active_statement_requires_restarting_the_application">
        <source>Updating async or iterator modifier around an active statement requires restarting the application.</source>
        <target state="translated">Для обновления модификатора async или iterator вокруг активного оператора требуется перезапустить приложение.</target>
        <note>{Locked="async"}{Locked="iterator"} "async" and "iterator" are C#/VB keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Updating_async_or_iterator_requires_restarting_the_application_because_is_not_supported_by_the_runtime">
        <source>Updating async or iterator requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">Обновление асинхронного режима или итератора требует перезапуска приложения, так как это не поддерживается средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_reloadable_type_marked_by_0_attribute_or_its_member_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
        <source>Updating a reloadable type (marked by {0}) or its member requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">Для обновления перезагружаемого типа (отмеченного атрибутом {0}) или его элемента требуется перезапустить приложение, так как обновление не поддерживается средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_Handles_clause_of_0_requires_restarting_the_application">
        <source>Updating the Handles clause of {0} requires restarting the application.</source>
        <target state="translated">Для обновления предложения Handles в {0} требуется перезапустить приложение.</target>
        <note>{Locked="Handles"} "Handles" is VB keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Updating_the_Implements_clause_of_a_0_requires_restarting_the_application">
        <source>Updating the Implements clause of a {0} requires restarting the application.</source>
        <target state="translated">Для обновления предложения Implements в {0} требуется перезапустить приложение.</target>
        <note>{Locked="Implements"} "Implements" is VB keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Updating_the_alias_of_Declare_statement_requires_restarting_the_application">
        <source>Updating the alias of Declare statement requires restarting the application.</source>
        <target state="translated">Для обновления псевдонима оператора Declare требуется перезапустить приложение.</target>
        <note>{Locked="Declare"} "Declare" is VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Updating_the_attributes_of_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
        <source>Updating the attributes of {0} requires restarting the application because it is not supported by the runtime.</source>
        <target state="translated">Для обновления атрибутов {0} требуется перезапустить приложение, так как обновление не поддерживается средой выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_base_class_and_or_base_interface_s_of_0_requires_restarting_the_application">
        <source>Updating the base class and/or base interface(s) of {0} requires restarting the application.</source>
        <target state="translated">Для обновления базового класса и/или базового интерфейса {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_initializer_of_0_requires_restarting_the_application">
        <source>Updating the initializer of {0} requires restarting the application.</source>
        <target state="translated">Для обновления инициализатора {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_kind_of_a_property_event_accessor_requires_restarting_the_application">
        <source>Updating the kind of a property/event accessor requires restarting the application.</source>
        <target state="translated">Для обновления метода доступа свойства/события требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_kind_of_a_type_requires_restarting_the_application">
        <source>Updating the kind of a type requires restarting the application.</source>
        <target state="translated">Для обновления вида типа требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_library_name_of_Declare_statement_requires_restarting_the_application">
        <source>Updating the library name of Declare statement requires restarting the application.</source>
        <target state="translated">Для обновления имени библиотеки оператора Declare требуется перезапустить приложение.</target>
        <note>{Locked="Declare"} "Declare" is VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Updating_the_modifiers_of_0_requires_restarting_the_application">
        <source>Updating the modifiers of {0} requires restarting the application.</source>
        <target state="translated">Для обновления модификаторов {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_size_of_a_0_requires_restarting_the_application">
        <source>Updating the size of a {0} requires restarting the application.</source>
        <target state="translated">Для обновления размера {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_type_of_0_around_an_active_statement_requires_restarting_the_application">
        <source>Updating the type of {0} (from '{1}' to '{2}') around an active statement requires restarting the application.</source>
        <target state="new">Updating the type of {0} (from '{1}' to '{2}') around an active statement requires restarting the application.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_type_of_0_requires_restarting_the_application">
        <source>Updating the type of {0} requires restarting the application.</source>
        <target state="translated">Для обновления типа {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_underlying_type_of_0_requires_restarting_the_application">
        <source>Updating the underlying type of {0} requires restarting the application.</source>
        <target state="translated">Для обновления базового типа {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_variance_of_0_requires_restarting_the_application">
        <source>Updating the variance of {0} requires restarting the application.</source>
        <target state="translated">Для обновления расхождения {0} требуется перезапустить приложение.</target>
        <note />
      </trans-unit>
      <trans-unit id="Value_colon">
        <source>Value:</source>
        <target state="translated">Значение:</target>
        <note />
      </trans-unit>
      <trans-unit id="Value_required">
        <source>Value required</source>
        <target state="translated">Требуется значение</target>
        <note />
      </trans-unit>
      <trans-unit id="WARN_Version_mismatch_Expected_0_Got_1">
        <source>WARN: Version mismatch. Expected: '{0}', Got: '{1}'</source>
        <target state="translated">Внимание! Несовпадение версий. Ожидалось: "{0}", получено: "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_changing_namespace_may_produce_invalid_code_and_change_code_meaning">
        <source>Warning: Changing namespace may produce invalid code and change code meaning.</source>
        <target state="translated">Предупреждение: изменение пространства имен может привести к появлению недопустимого кода и к изменению значения кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_semantics_may_change_when_converting_statement">
        <source>Warning: Semantics may change when converting statement.</source>
        <target state="translated">Внимание! При преобразовании инструкции семантика может измениться.</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_and_align_call_chain">
        <source>Wrap and align call chain</source>
        <target state="translated">Свернуть и выровнять цепочку вызовов</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_and_align_expression">
        <source>Wrap and align expression</source>
        <target state="translated">Перенос и выравнивание выражения</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_and_align_long_call_chain">
        <source>Wrap and align long call chain</source>
        <target state="translated">Свернуть и выровнять длинную цепочку вызовов</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_call_chain">
        <source>Wrap call chain</source>
        <target state="translated">Свернуть цепочку вызовов</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_collection">
        <source>Wrap collection</source>
        <target state="translated">Упаковка коллекции</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_every_argument">
        <source>Wrap every argument</source>
        <target state="translated">Свернуть каждый аргумент</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_every_parameter">
        <source>Wrap every parameter</source>
        <target state="translated">Свернуть каждый параметр</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_expression">
        <source>Wrap expression</source>
        <target state="translated">Свернуть выражение</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_initializer">
        <source>Wrap initializer</source>
        <target state="translated">Переносить инициализатор</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_argument_list">
        <source>Wrap long argument list</source>
        <target state="translated">Свернуть длинный список аргументов</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_call_chain">
        <source>Wrap long call chain</source>
        <target state="translated">Свернуть длинную цепочку вызовов</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_collection">
        <source>Wrap long collection</source>
        <target state="translated">Упаковка длинной коллекции</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_initializer">
        <source>Wrap long initializer</source>
        <target state="translated">Переносить длинный инициализатор</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_parameter_list">
        <source>Wrap long parameter list</source>
        <target state="translated">Свернуть длинный список параметров</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrapping">
        <source>Wrapping</source>
        <target state="translated">Перенос по словам</target>
        <note />
      </trans-unit>
      <trans-unit id="You_can_use_the_navigation_bar_to_switch_contexts">
        <source>You can use the navigation bar to switch contexts.</source>
        <target state="translated">Для переключения контекстов можно использовать панель навигации.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_cannot_rename_elements_from_previous_submissions">
        <source>You cannot rename elements from previous submissions.</source>
        <target state="translated">Нельзя переименовать элементы из предыдущих отправок.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_cannot_rename_elements_that_are_defined_in_metadata">
        <source>You cannot rename elements that are defined in metadata.</source>
        <target state="translated">Нельзя переименовать элементы, определенные в метаданных.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_cannot_rename_operators">
        <source>You cannot rename operators.</source>
        <target state="translated">Нельзя переименовать операторы.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_cannot_rename_this_element">
        <source>You cannot rename this element.</source>
        <target state="translated">Этот элемент переименовать нельзя.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_must_rename_an_identifier">
        <source>You must rename an identifier.</source>
        <target state="translated">Необходимо переименовать идентификатор.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_bases">
        <source>'{0}' bases</source>
        <target state="translated">Основания: “{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_cannot_be_null_or_empty">
        <source>'{0}' cannot be null or empty.</source>
        <target state="translated">"{0}" не может быть неопределенным или пустым.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_cannot_be_null_or_whitespace">
        <source>'{0}' cannot be null or whitespace.</source>
        <target state="translated">"{0}" не может быть пустым или содержать только пробел.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_dash_1">
        <source>{0} - {1}</source>
        <target state="translated">{0} - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_expected">
        <source>'{0}' expected</source>
        <target state="translated">Ожидалось значение {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_in_embedded_PDB">
        <source>'{0}' found in embedded PDB.</source>
        <target state="translated">Найдено "{0}" во внедренном PDB-файле.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_in_embedded_PDB_but_checksum_failed">
        <source>'{0}' found in embedded PDB but checksum was wrong, or couldn't read temp file.</source>
        <target state="translated">Найдено "{0}" во внедренном PDB-файле, но контрольная сумма неверна или не удалось прочитать временный файл.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_in_embedded_PDB_but_could_not_write_file_1">
        <source>'{0}' found in embedded PDB but could not write to temp file: '{1}'</source>
        <target state="translated">Найдено "{0}" во внедренном PDB-файле, но не удалось выполнить запись во временном файле: "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_in_embedded_PDB_cached_source_file">
        <source>'{0}' found in embedded PDB and found cached source file.</source>
        <target state="translated">Обнаружено "{0}" во внедренном PDB-файле и найден кэшированный исходный файл.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_in_original_location">
        <source>'{0}' found in original location.</source>
        <target state="translated">Найдено "{0}" в исходном расположении.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_in_original_location_but_checksum_failed">
        <source>'{0}' found in original location but checksum was wrong, or couldn't read temp file.</source>
        <target state="translated">Найдено "{0}" в исходном расположении, но контрольная сумма неверна или не удалось прочитать временный файл.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_via_SourceLink">
        <source>'{0}' found via SourceLink.</source>
        <target state="translated">Найдено "{0}" с помощью SourceLink.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_via_SourceLink_but_couldnt_read_file">
        <source>'{0}' found via SourceLink but couldn't read temp file.</source>
        <target state="translated">Найдено "{0}" с помощью SourceLink, но не удалось прочитать временный файл.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_implementations">
        <source>'{0}' implementations</source>
        <target state="translated">Реализации “{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_null_here">
        <source>'{0}' is not null here.</source>
        <target state="translated">Здесь "{0}" имеет значение, отличное от NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_items_in_cache">
        <source>'{0}' items in cache</source>
        <target state="translated">Элементов в кэше: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_literal_not_allowed">
        <source>'{0}' literal not allowed</source>
        <target state="translated">Литерал {0} не разрешен</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_may_be_null_here">
        <source>'{0}' may be null here.</source>
        <target state="translated">Здесь "{0}" может иметь значение NULL.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_reference_unquoted">
        <source>{0} reference</source>
        <target state="translated">Cсылок: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_references">
        <source>'{0}' references</source>
        <target state="translated">Ссылки “{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_references_unquoted">
        <source>{0} references</source>
        <target state="translated">Ссылок: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_unexpected">
        <source>'{0}' unexpected</source>
        <target state="translated">Непредусмотренное значение {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second">
        <source>10,000,000ths of a second</source>
        <target state="translated">10 000 000-е доли секунды</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second_description">
        <source>The "fffffff" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value.

Although it's possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Описатель пользовательского формата "fffffff" представляет семь наиболее значащих цифр дробной части секунды; то есть он представляет десятимиллионные доли секунды в значении даты и времени.

Хотя десятимиллионные доли второго компонента значения времени можно отобразить, это значение может быть неинформативным. Точность значений даты и времени зависит от разрешения системных часов. В операционных системах Windows NT 3.5 (и более поздних версий) и Windows Vista разрешение часов составляет приблизительно 10–15 мс.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second_non_zero">
        <source>10,000,000ths of a second (non-zero)</source>
        <target state="translated">10 000 000-е доли секунды (не нуль)</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second_non_zero_description">
        <source>The "FFFFFFF" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value. However, trailing zeros or seven zero digits aren't displayed.

Although it's possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Описатель пользовательского формата "FFFFFFF" представляет семь наиболее значащих цифр дробной части секунды; то есть он представляет десятимиллионные доли секунды в значении даты и времени. При этом конечные нули или семь нулевых разрядов не отображаются.

Хотя десятимиллионные доли второго компонента значения времени можно отобразить, это значение может быть неинформативным. Точность значений даты и времени зависит от разрешения системных часов. В операционных системах Windows NT 3.5 (и более поздних версий) и Windows Vista разрешение часов составляет приблизительно 10–15 мс.</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second">
        <source>1,000,000ths of a second</source>
        <target state="translated">1 000 000-е доли секунды</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second_description">
        <source>The "ffffff" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value.

Although it's possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Описатель пользовательского формата "ffffff" представляет шесть наиболее значащих цифр дробной части секунды; то есть он представляет миллионные доли секунды в значении даты и времени.

Хотя миллионные доли второго компонента значения времени можно отобразить, это значение может быть неинформативным. Точность значений даты и времени зависит от разрешения системных часов. В операционных системах Windows NT 3.5 (и более поздних версий) и Windows Vista разрешение часов составляет приблизительно 10–15 мс.</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second_non_zero">
        <source>1,000,000ths of a second (non-zero)</source>
        <target state="translated">1 000 000-е доли секунды (не нуль)</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second_non_zero_description">
        <source>The "FFFFFF" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value. However, trailing zeros or six zero digits aren't displayed.

Although it's possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Описатель пользовательского формата "FFFFFF" представляет шесть наиболее значащих цифр дробной части секунды; то есть он представляет миллионные доли секунды в значении даты и времени. При этом конечные нули или шесть нулевых разрядов не отображаются.

Хотя миллионные доли второго компонента значения времени можно отобразить, это значение может быть неинформативным. Точность значений даты и времени зависит от разрешения системных часов. В операционных системах Windows NT 3.5 (и более поздних версий) и Windows Vista разрешение часов составляет приблизительно 10–15 мс.</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second">
        <source>100,000ths of a second</source>
        <target state="translated">100 000-е доли секунды</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second_description">
        <source>The "fffff" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value.

Although it's possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Описатель пользовательского формата "fffff" представляет пять наиболее значащих цифр дробной части секунды; то есть он представляет стотысячные доли секунды в значении даты и времени.

Хотя стотысячные доли второго компонента значения времени можно отобразить, это значение может быть неинформативным. Точность значений даты и времени зависит от разрешения системных часов. В операционных системах Windows NT 3.5 (и более поздних версий) и Windows Vista разрешение часов составляет приблизительно 10–15 мс.</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second_non_zero">
        <source>100,000ths of a second (non-zero)</source>
        <target state="translated">100 000-е доли секунды (не нуль)</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second_non_zero_description">
        <source>The "FFFFF" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value. However, trailing zeros or five zero digits aren't displayed.

Although it's possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Описатель пользовательского формата "FFFFF" представляет пять наиболее значащих цифр дробной части секунды; то есть он представляет стотысячные доли секунды в значении даты и времени. При этом конечные нули или пять нулевых разрядов не отображаются.

Хотя стотысячные доли второго компонента значения времени можно отобразить, это значение может быть неинформативным. Точность значений даты и времени зависит от разрешения системных часов. В операционных системах Windows NT 3.5 (и более поздних версий) и Windows Vista разрешение часов составляет приблизительно 10–15 мс.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second">
        <source>10,000ths of a second</source>
        <target state="translated">10 000-е доли секунды</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second_description">
        <source>The "ffff" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value.

Although it's possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT version 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Описатель пользовательского формата "ffff" представляет четыре наиболее значащих цифры дробной части секунды; то есть он представляет десятитысячные доли секунды в значении даты и времени.

Хотя десятитысячные доли второго компонента значения времени можно отобразить, это значение может быть неинформативным. Точность значений даты и времени зависит от разрешения системных часов. В операционных системах Windows NT 3.5 (и более поздних версий) и Windows Vista разрешение часов составляет приблизительно 10–15 мс.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second_non_zero">
        <source>10,000ths of a second (non-zero)</source>
        <target state="translated">10 000-е доли секунды (не нуль)</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second_non_zero_description">
        <source>The "FFFF" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value. However, trailing zeros or four zero digits aren't displayed.

Although it's possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">Описатель пользовательского формата "FFFF" представляет четыре наиболее значащих цифры дробной части секунды; то есть он представляет десятитысячные доли секунды в значении даты и времени. При этом конечные нули или четыре нулевых разряда не отображаются.

Хотя десятитысячные доли второго компонента значения времени можно отобразить, это значение может быть неинформативным. Точность значений даты и времени зависит от разрешения системных часов. В операционных системах Windows NT 3.5 (и более поздних версий) и Windows Vista разрешение часов составляет приблизительно 10–15 мс.</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second">
        <source>1,000ths of a second</source>
        <target state="translated">1000-е доли секунды</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second_description">
        <source>The "fff" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value.</source>
        <target state="translated">Описатель пользовательского формата "fff" представляет три наиболее значащих цифры в дробной части секунды, то есть представляет миллисекунды в значении даты и времени.</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second_non_zero">
        <source>1,000ths of a second (non-zero)</source>
        <target state="translated">1000-е доли секунды (не нуль)</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second_non_zero_description">
        <source>The "FFF" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value. However, trailing zeros or three zero digits aren't displayed.</source>
        <target state="translated">Описатель пользовательского формата "FFF" представляет три наиболее значащих цифры в дробной части секунды, то есть представляет миллисекунды в значении даты и времени. При этом конечные нули или три нулевых разряда не отображаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second">
        <source>100ths of a second</source>
        <target state="translated">100-е доли секунды</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second_description">
        <source>The "ff" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value.</source>
        <target state="translated">Описатель пользовательского формата "ff" представляет две наиболее значащих цифры в дробной части секунды, то есть представляет сотые доли секунды в значении даты и времени.</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second_non_zero">
        <source>100ths of a second (non-zero)</source>
        <target state="translated">100-е доли секунды (не нуль)</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second_non_zero_description">
        <source>The "FF" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value. However, trailing zeros or two zero digits aren't displayed.</source>
        <target state="translated">Описатель пользовательского формата "FF" представляет две наиболее значащих цифры в дробной части секунды, то есть представляет сотые доли секунды в значении даты и времени. При этом конечные нули или два нулевых разряда не отображаются.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second">
        <source>10ths of a second</source>
        <target state="translated">10-е доли секунды</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second_description">
        <source>The "f" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value.

If the "f" format specifier is used without other format specifiers, it's interpreted as the "f" standard date and time format specifier.

When you use "f" format specifiers as part of a format string supplied to the ParseExact or TryParseExact method, the number of "f" format specifiers indicates the number of most significant digits of the seconds fraction that must be present to successfully parse the string.</source>
        <target state="translated">Описатель пользовательского формата "f" представляет наиболее значащую цифру в дробной части секунды, то есть представляет десятые доли секунды в значении даты и времени.

Если описатель формата "f" используется без других описателей формата, он интерпретируется как описатель стандартного формата даты и времени "f".

При использовании описателей формата "f" в качестве части строки формата, передаваемой методу ParseExact или TryParseExact, число описателей формата "f" указывает количество наиболее значащих цифр в дробной части секунды, которые должны присутствовать для успешного анализа строки.</target>
        <note>{Locked="ParseExact"}{Locked="TryParseExact"}{Locked=""f""}</note>
      </trans-unit>
      <trans-unit id="_10ths_of_a_second_non_zero">
        <source>10ths of a second (non-zero)</source>
        <target state="translated">10-е доли секунды (не нуль)</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second_non_zero_description">
        <source>The "F" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value. Nothing is displayed if the digit is zero.

If the "F" format specifier is used without other format specifiers, it's interpreted as the "F" standard date and time format specifier.

The number of "F" format specifiers used with the ParseExact, TryParseExact, ParseExact, or TryParseExact method indicates the maximum number of most significant digits of the seconds fraction that can be present to successfully parse the string.</source>
        <target state="translated">Описатель пользовательского формата "F" представляет наиболее значащую цифру в дробной части секунды, то есть представляет десятые доли секунды в значении даты и времени. Если разряд равен нулю, ничего не отображается.

Если описатель формата "F" используется без других описателей формата, он интерпретируется как описатель стандартного формата даты и времени "F".

Число описателей формата "F", используемых с методом ParseExact, TryParseExact, ParseExact или TryParseExact, указывает максимальное количество наиболее значащих цифр в дробной части секунды, которые должны присутствовать для успешного анализа строки.</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_1_2_digits">
        <source>12 hour clock (1-2 digits)</source>
        <target state="translated">12-часовой формат времени (1–2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_1_2_digits_description">
        <source>The "h" custom format specifier represents the hour as a number from 1 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour after midnight is indistinguishable from the same hour after noon. The hour is not rounded, and a single-digit hour is formatted without a leading zero. For example, given a time of 5:43 in the morning or afternoon, this custom format specifier displays "5".

If the "h" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">Описатель пользовательского формата "h" представляет час в виде числа от 1 до 12, то есть час представлен в 12-часовом формате, который подсчитывает целые часы, начиная с полуночи или с полудня. Определенный час после полуночи невозможно отличить от такого же часа после полудня. Значение часа не округляется, а значение часа из одной цифры форматируется без начального нуля. Например, для времени 5:43 утра или вечера этот описатель пользовательского формата выводит "5".

Если описатель формата "h" используется без других описателей пользовательского формата, он интерпретируется как описатель стандартного формата даты и времени и вызывает исключение FormatException.</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_2_digits">
        <source>12 hour clock (2 digits)</source>
        <target state="translated">12-часовой формат времени (2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_2_digits_description">
        <source>The "hh" custom format specifier (plus any number of additional "h" specifiers) represents the hour as a number from 01 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour after midnight is indistinguishable from the same hour after noon. The hour is not rounded, and a single-digit hour is formatted with a leading zero. For example, given a time of 5:43 in the morning or afternoon, this format specifier displays "05".</source>
        <target state="translated">Описатель пользовательского формата "hh" (плюс любое число дополнительных описателей "h") представляет час в виде числа от 01 до 12, то есть час представлен в 12-часовом формате, который подсчитывает целые часы, начиная с полуночи или с полудня. Определенный час после полуночи невозможно отличить от такого же часа после полудня. Значение часа не округляется, а значение часа из одной цифры форматируется с начальным нулем. Например, для времени 5:43 утра или вечера этот описатель формата выводит "05".</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_1_2_digits">
        <source>24 hour clock (1-2 digits)</source>
        <target state="translated">24-часовой формат времени (1–2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_1_2_digits_description">
        <source>The "H" custom format specifier represents the hour as a number from 0 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is formatted without a leading zero.

If the "H" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">Описатель пользовательского формата "H" представляет час в виде числа от 0 до 23, то есть час представлен в начинающемся с нуля 24-часовом формате, отсчитывающем часы с полуночи. Значение часа из одной цифры форматируется без начального нуля.

Если описатель формата "H" используется без других описателей пользовательского формата, он интерпретируется как описатель стандартного формата даты и времени и вызывает исключение FormatException.</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_2_digits">
        <source>24 hour clock (2 digits)</source>
        <target state="translated">24-часовой формат времени (2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_2_digits_description">
        <source>The "HH" custom format specifier (plus any number of additional "H" specifiers) represents the hour as a number from 00 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is formatted with a leading zero.</source>
        <target state="translated">Описатель пользовательского формата "HH" (плюс любое число дополнительных описателей "H") представляет час в виде числа от 00 до 23, то есть час представлен в начинающемся с нуля 24-часовом формате, отсчитывающем часы с полуночи. Значение часа из одной цифры форматируется с начальным нулем.</target>
        <note />
      </trans-unit>
      <trans-unit id="all_anonymous_types_in_container">
        <source>all anonymous types in container</source>
        <target state="translated">все анонимные типы в контейнере</target>
        <note />
      </trans-unit>
      <trans-unit id="and_update_call_sites_directly">
        <source>and update call sites directly</source>
        <target state="translated">и обновлять сайты вызовов напрямую</target>
        <note />
      </trans-unit>
      <trans-unit id="class_name">
        <source>&lt;class name&gt;</source>
        <target state="translated">&lt;имя класса&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="class_with_explicit_or_sequential_layout">
        <source>class with explicit or sequential layout</source>
        <target state="translated">класс с явной или последовательной компоновкой</target>
        <note />
      </trans-unit>
      <trans-unit id="code">
        <source>code</source>
        <target state="translated">код</target>
        <note />
      </trans-unit>
      <trans-unit id="console_writeline">
        <source>Console.WriteLine</source>
        <target state="translated">Console.WriteLine</target>
        <note />
      </trans-unit>
      <trans-unit id="date_separator">
        <source>date separator</source>
        <target state="translated">разделитель компонентов даты</target>
        <note />
      </trans-unit>
      <trans-unit id="date_separator_description">
        <source>The "/" custom format specifier represents the date separator, which is used to differentiate years, months, and days. The appropriate localized date separator is retrieved from the DateTimeFormatInfo.DateSeparator property of the current or specified culture.

Note: To change the date separator for a particular date and time string, specify the separator character within a literal string delimiter. For example, the custom format string mm'/'dd'/'yyyy produces a result string in which "/" is always used as the date separator. To change the date separator for all dates for a culture, either change the value of the DateTimeFormatInfo.DateSeparator property of the current culture, or instantiate a DateTimeFormatInfo object, assign the character to its DateSeparator property, and call an overload of the formatting method that includes an IFormatProvider parameter.

If the "/" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">Описатель пользовательского формата "/" представляет разделитель компонентов даты, который позволяет различать годы, месяцы и дни. Соответствующий локализованный разделитель компонентов даты извлекается из свойства DateTimeFormatInfo.DateSeparator текущих или заданных языка и региональных параметров.

Примечание. Чтобы изменить разделитель компонентов даты для определенной строки даты и времени, укажите знак разделения в разделителе литеральной строки. Например, строка пользовательского формата mm'/'dd'/'yyyy дает результирующую строку, в которой "/" всегда используется в качестве разделителя компонентов даты. Чтобы изменить разделитель компонентов даты для всех дат для языка и региональных параметров, измените значение свойства DateTimeFormatInfo.DateSeparator текущих языка и региональных параметров или создайте экземпляр объекта DateTimeFormatInfo, присвойте этот знак его свойству DateSeparator и вызовите перегрузку метода форматирования, включающую параметр IFormatProvider.

Если описатель формата "/" используется без других описателей пользовательского формата, он интерпретируется как описатель стандартного формата даты и времени и вызывает исключение FormatException.</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_1_2_digits">
        <source>day of the month (1-2 digits)</source>
        <target state="translated">день месяца (1–2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_1_2_digits_description">
        <source>The "d" custom format specifier represents the day of the month as a number from 1 through 31. A single-digit day is formatted without a leading zero.

If the "d" format specifier is used without other custom format specifiers, it's interpreted as the "d" standard date and time format specifier.</source>
        <target state="translated">Описатель пользовательского формата "d" представляет день месяца в виде числа от 1 до 31. Значение дня из одной цифры форматируется без начального нуля.

Если описатель формата "d" используется без других описателей пользовательского формата, он интерпретируется как описатель "d" стандартного формата даты и времени.</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_2_digits">
        <source>day of the month (2 digits)</source>
        <target state="translated">день месяца (2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_2_digits_description">
        <source>The "dd" custom format string represents the day of the month as a number from 01 through 31. A single-digit day is formatted with a leading zero.</source>
        <target state="translated">Описатель пользовательского формата "dd" представляет день месяца в виде числа от 01 до 31. Значение дня из одной цифры форматируется с начальным нулем.</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_abbreviated">
        <source>day of the week (abbreviated)</source>
        <target state="translated">День недели (сокращенно)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_abbreviated_description">
        <source>The "ddd" custom format specifier represents the abbreviated name of the day of the week. The localized abbreviated name of the day of the week is retrieved from the DateTimeFormatInfo.AbbreviatedDayNames property of the current or specified culture.</source>
        <target state="translated">Описатель пользовательского формата "ddd" представляет сокращенное название дня недели. Локализованное сокращенное название дня недели извлекается из свойства DateTimeFormatInfo.AbbreviatedDayNames текущих или заданных языка и региональных параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_full">
        <source>day of the week (full)</source>
        <target state="translated">День недели (полностью)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_full_description">
        <source>The "dddd" custom format specifier (plus any number of additional "d" specifiers) represents the full name of the day of the week. The localized name of the day of the week is retrieved from the DateTimeFormatInfo.DayNames property of the current or specified culture.</source>
        <target state="translated">Описатель пользовательского формата "dddd" (плюс любое число дополнительных описателей "d") представляет полное название дня недели. Локализованное название дня недели извлекается из свойства DateTimeFormatInfo.DayNames текущих или заданных языка и региональных параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="discard">
        <source>discard</source>
        <target state="translated">отменить</target>
        <note />
      </trans-unit>
      <trans-unit id="else_statement">
        <source>else statement</source>
        <target state="translated">инструкция else</target>
        <note />
      </trans-unit>
      <trans-unit id="embedded">
        <source>embedded</source>
        <target state="translated">внедренный</target>
        <note>Embedded is a technical term for "Embedded source", where souce files are embedded into the PDB</note>
      </trans-unit>
      <trans-unit id="external">
        <source>external</source>
        <target state="translated">внешний</target>
        <note>External means "external source", meaning source files that are not part of the current solution</note>
      </trans-unit>
      <trans-unit id="foreach_loop">
        <source>foreach loop</source>
        <target state="translated">Цикл ForEach</target>
        <note />
      </trans-unit>
      <trans-unit id="from_metadata">
        <source>from metadata</source>
        <target state="translated">из метаданных</target>
        <note />
      </trans-unit>
      <trans-unit id="full_long_date_time">
        <source>full long date/time</source>
        <target state="translated">полный длинный формат даты и времени</target>
        <note />
      </trans-unit>
      <trans-unit id="full_long_date_time_description">
        <source>The "F" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.FullDateTimePattern property. For example, the custom format string for the invariant culture is "dddd, dd MMMM yyyy HH:mm:ss".</source>
        <target state="translated">Описатель стандартного формата "F" представляет строку пользовательского формата даты и времени, определяемую текущим свойством DateTimeFormatInfo.FullDateTimePattern. Например, строка пользовательского формата для инвариантных языка и региональных параметров имеет вид "dddd, dd MMMM yyyy HH:mm:ss".</target>
        <note />
      </trans-unit>
      <trans-unit id="full_short_date_time">
        <source>full short date/time</source>
        <target state="translated">полный краткий формат даты и времени</target>
        <note />
      </trans-unit>
      <trans-unit id="full_short_date_time_description">
        <source>The Full Date Short Time ("f") Format Specifier

The "f" standard format specifier represents a combination of the long date ("D") and short time ("t") patterns, separated by a space.</source>
        <target state="translated">Описатель формата полной даты и краткого времени ("f")

Описатель стандартного формата "f" представляет сочетание шаблонов длинной даты ("D") и краткого времени ("t"), разделенных пробелом.</target>
        <note />
      </trans-unit>
      <trans-unit id="general_long_date_time">
        <source>general long date/time</source>
        <target state="translated">общий длинный формат даты и времени</target>
        <note />
      </trans-unit>
      <trans-unit id="general_long_date_time_description">
        <source>The "G" standard format specifier represents a combination of the short date ("d") and long time ("T") patterns, separated by a space.</source>
        <target state="translated">Описатель стандартного формата "G" представляет сочетание шаблонов краткой даты ("d") и полного времени ("T"), разделенных пробелом.</target>
        <note />
      </trans-unit>
      <trans-unit id="general_short_date_time">
        <source>general short date/time</source>
        <target state="translated">общий краткий формат даты и времени</target>
        <note />
      </trans-unit>
      <trans-unit id="general_short_date_time_description">
        <source>The "g" standard format specifier represents a combination of the short date ("d") and short time ("t") patterns, separated by a space.</source>
        <target state="translated">Описатель стандартного формата "g" представляет сочетание шаблонов краткой даты ("d") и краткого времени ("t"), разделенных пробелом.</target>
        <note />
      </trans-unit>
      <trans-unit id="generic_overload">
        <source>generic overload</source>
        <target state="translated">универсальная перегрузка</target>
        <note />
      </trans-unit>
      <trans-unit id="generic_overloads">
        <source>generic overloads</source>
        <target state="translated">универсальные перегрузки</target>
        <note />
      </trans-unit>
      <trans-unit id="get_only_property">
        <source>get-only property</source>
        <target state="translated">свойство, предназначенное только для получения</target>
        <note />
      </trans-unit>
      <trans-unit id="if_statement">
        <source>if statement</source>
        <target state="translated">оператор if</target>
        <note />
      </trans-unit>
      <trans-unit id="in_0_1_2">
        <source>in {0} ({1} - {2})</source>
        <target state="translated">в {0} ({1} — {2})</target>
        <note />
      </trans-unit>
      <trans-unit id="in_Source_attribute">
        <source>in Source (attribute)</source>
        <target state="translated">в источнике (атрибут)</target>
        <note />
      </trans-unit>
      <trans-unit id="interface_name">
        <source>&lt;interface name&gt;</source>
        <target state="translated">&lt;имя интерфейса&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="into_extracted_method_to_invoke_at_call_sites">
        <source>into extracted method to invoke at call sites</source>
        <target state="translated">в извлеченный метод для вызова на сайтах вызовов</target>
        <note />
      </trans-unit>
      <trans-unit id="into_new_overload">
        <source>into new overload</source>
        <target state="translated">в новую перегрузку</target>
        <note />
      </trans-unit>
      <trans-unit id="just_this_anonymous_type">
        <source>just this anonymous type</source>
        <target state="translated">только этот анонимный тип</target>
        <note />
      </trans-unit>
      <trans-unit id="long_date">
        <source>long date</source>
        <target state="translated">Длинный формат даты</target>
        <note />
      </trans-unit>
      <trans-unit id="long_date_description">
        <source>The "D" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.LongDatePattern property. For example, the custom format string for the invariant culture is "dddd, dd MMMM yyyy".</source>
        <target state="translated">Описатель стандартного формата "D" представляет строку пользовательского формата даты и времени, определяемую текущим свойством DateTimeFormatInfo.LongDatePattern. Например, строка пользовательского формата для инвариантных языка и региональных параметров имеет вид "dddd, dd MMMM yyyy".</target>
        <note />
      </trans-unit>
      <trans-unit id="long_time">
        <source>long time</source>
        <target state="translated">Длинный формат времени</target>
        <note />
      </trans-unit>
      <trans-unit id="long_time_description">
        <source>The "T" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.LongTimePattern property. For example, the custom format string for the invariant culture is "HH:mm:ss".</source>
        <target state="translated">Описатель стандартного формата "T" представляет строку пользовательского формата даты и времени, определяемую свойством DateTimeFormatInfo.LongTimePattern конкретных языка и региональных параметров. Например, строка пользовательского формата для инвариантных языка и региональных параметров имеет вид "HH:mm:ss".</target>
        <note />
      </trans-unit>
      <trans-unit id="member_kind_and_name">
        <source>{0} '{1}'</source>
        <target state="translated">{0} "{1}"</target>
        <note>e.g. "method 'M'"</note>
      </trans-unit>
      <trans-unit id="minute_1_2_digits">
        <source>minute (1-2 digits)</source>
        <target state="translated">минута (1–2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_1_2_digits_description">
        <source>The "m" custom format specifier represents the minute as a number from 0 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted without a leading zero.

If the "m" format specifier is used without other custom format specifiers, it's interpreted as the "m" standard date and time format specifier.</source>
        <target state="translated">Описатель пользовательского формата "m" представляет минуту в виде числа от 0 до 59. Это число представляет собой целые минуты, истекшие с момента наступления последнего часа. Значение минуты из одной цифры форматируется без начального нуля.

Если описатель формата "m" используется без других описателей пользовательского формата, он интерпретируется как описатель "m" стандартного формата даты и времени.</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_2_digits">
        <source>minute (2 digits)</source>
        <target state="translated">минута (2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_2_digits_description">
        <source>The "mm" custom format specifier (plus any number of additional "m" specifiers) represents the minute as a number from 00 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted with a leading zero.</source>
        <target state="translated">Описатель пользовательского формата "mm" (плюс любое число дополнительных описателей "m") представляет минуту в виде числа от 00 до 59. Это число представляет собой целые минуты, истекшие с момента наступления последнего часа. Значение минуты из одной цифры форматируется с начальным нулем.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_1_2_digits">
        <source>month (1-2 digits)</source>
        <target state="translated">месяц (1–2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_1_2_digits_description">
        <source>The "M" custom format specifier represents the month as a number from 1 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted without a leading zero.

If the "M" format specifier is used without other custom format specifiers, it's interpreted as the "M" standard date and time format specifier.</source>
        <target state="translated">Описатель пользовательского формата "M" представляет месяц в виде числа от 1 до 12 (или от 1 до 13 для календарей, состоящих из 13 месяцев). Значение месяца из одной цифры форматируется без начального нуля.

Если описатель формата "M" используется без других описателей пользовательского формата, он интерпретируется как описатель "M" стандартного формата даты и времени.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_2_digits">
        <source>month (2 digits)</source>
        <target state="translated">месяц (2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_2_digits_description">
        <source>The "MM" custom format specifier represents the month as a number from 01 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted with a leading zero.</source>
        <target state="translated">Описатель пользовательского формата "MM" представляет месяц в виде числа от 1 до 12 (или от 1 до 13 для календарей, состоящих из 13 месяцев). Значение месяца из одной цифры форматируется с начальным нулем.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_abbreviated">
        <source>month (abbreviated)</source>
        <target state="translated">месяц (сокращенно)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_abbreviated_description">
        <source>The "MMM" custom format specifier represents the abbreviated name of the month. The localized abbreviated name of the month is retrieved from the DateTimeFormatInfo.AbbreviatedMonthNames property of the current or specified culture.</source>
        <target state="translated">Описатель пользовательского формата "MMM" представляет сокращенное название месяца. Локализованное сокращенное название месяца извлекается из свойства DateTimeFormatInfo.AbbreviatedMonthNames текущих или заданных языка и региональных параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_day">
        <source>month day</source>
        <target state="translated">День месяца</target>
        <note />
      </trans-unit>
      <trans-unit id="month_day_description">
        <source>The "M" or "m" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.MonthDayPattern property. For example, the custom format string for the invariant culture is "MMMM dd".</source>
        <target state="translated">Описатель стандартного формата "M" или "m" представляет строку пользовательского формата даты и времени, определяемую текущим свойством DateTimeFormatInfo.MonthDayPattern. Например, строка пользовательского формата для инвариантных языка и региональных параметров имеет вид "MMMM dd".</target>
        <note />
      </trans-unit>
      <trans-unit id="month_full">
        <source>month (full)</source>
        <target state="translated">месяц (полностью)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_full_description">
        <source>The "MMMM" custom format specifier represents the full name of the month. The localized name of the month is retrieved from the DateTimeFormatInfo.MonthNames property of the current or specified culture.</source>
        <target state="translated">Описатель пользовательского формата "MMMM" представляет полное название месяца. Локализованное название месяца извлекается из свойства DateTimeFormatInfo.MonthNames текущих или заданных языка и региональных параметров.</target>
        <note />
      </trans-unit>
      <trans-unit id="namespace_name">
        <source>&lt;namespace name&gt;</source>
        <target state="translated">&lt;имя пространства имен&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="overload">
        <source>overload</source>
        <target state="translated">перегрузка</target>
        <note />
      </trans-unit>
      <trans-unit id="overloads_">
        <source>overloads</source>
        <target state="translated">перегрузки</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_Keyword">
        <source>{0} Keyword</source>
        <target state="translated">Ключевое слово: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_field_colon_0_and_use_property">
        <source>Encapsulate field: '{0}' (and use property)</source>
        <target state="translated">Инкапсулировать поле: "{0}" (и использовать свойство)</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_field_colon_0_but_still_use_field">
        <source>Encapsulate field: '{0}' (but still use field)</source>
        <target state="translated">Инкапсулировать поле: "{0}" (но продолжать использовать поле)</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_fields_and_use_property">
        <source>Encapsulate fields (and use property)</source>
        <target state="translated">Инкапсулировать поля (и использовать свойство)</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_fields_but_still_use_field">
        <source>Encapsulate fields (but still use field)</source>
        <target state="translated">Инкапсулировать поля (но продолжать использовать поле)</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_extract_interface_colon_The_selection_is_not_inside_a_class_interface_struct">
        <source>Could not extract interface: The selection is not inside a class/interface/struct.</source>
        <target state="translated">Не удалось извлечь интерфейс: выбранный элемент не находится внутри класса, интерфейса или структуры.</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_extract_interface_colon_The_type_does_not_contain_any_member_that_can_be_extracted_to_an_interface">
        <source>Could not extract interface: The type does not contain any member that can be extracted to an interface.</source>
        <target state="translated">Не удалось извлечь интерфейс: тип не содержит никаких членов, которые можно извлечь в интерфейс.</target>
        <note />
      </trans-unit>
      <trans-unit id="Parameters_type_or_return_type_cannot_be_an_anonymous_type_colon_bracket_0_bracket">
        <source>Parameters' type or return type cannot be an anonymous type : [{0}]</source>
        <target state="translated">Тип параметров или возвращаемых данных не может иметь анонимный тип: [{0}]</target>
        <note />
      </trans-unit>
      <trans-unit id="The_selection_contains_no_active_statement">
        <source>The selection contains no active statement.</source>
        <target state="translated">Выбранный элемент не содержит активный оператор.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_selection_contains_an_error_or_unknown_type">
        <source>The selection contains an error or unknown type.</source>
        <target state="translated">Выбранный элемент содержит ошибку или неизвестный тип.</target>
        <note />
      </trans-unit>
      <trans-unit id="Type_parameter_0_is_hidden_by_another_type_parameter_1">
        <source>Type parameter '{0}' is hidden by another type parameter '{1}'.</source>
        <target state="translated">Параметр типа "{0}" скрыт другим параметром типа "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="The_address_of_a_variable_is_used_inside_the_selected_code">
        <source>The address of a variable is used inside the selected code.</source>
        <target state="translated">Этот адрес переменной используется внутри выбранного кода.</target>
        <note />
      </trans-unit>
      <trans-unit id="Assigning_to_readonly_fields_must_be_done_in_a_constructor_colon_bracket_0_bracket">
        <source>Assigning to readonly fields must be done in a constructor : [{0}].</source>
        <target state="translated">Назначение значения полям, доступным только для чтения, следует выполнять в конструкторе: [{0}].</target>
        <note />
      </trans-unit>
      <trans-unit id="generated_code_is_overlapping_with_hidden_portion_of_the_code">
        <source>generated code is overlapping with hidden portion of the code</source>
        <target state="translated">созданный код накладывается на скрытую часть кода</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_optional_parameters_to_0">
        <source>Add optional parameters to '{0}'</source>
        <target state="translated">Добавить дополнительные параметры в "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_parameters_to_0">
        <source>Add parameters to '{0}'</source>
        <target state="translated">Добавить параметры в "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_delegating_constructor_0_1">
        <source>Generate delegating constructor '{0}({1})'</source>
        <target state="translated">Создать делегирующий конструктор "{0}({1})"</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_Equals_and_GetHashCode">
        <source>Generate Equals and GetHashCode</source>
        <target state="translated">Создать Equals и GetHashCode</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_Equals_object">
        <source>Generate Equals(object)</source>
        <target state="new">Generate Equals(object)</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_GetHashCode">
        <source>Generate GetHashCode()</source>
        <target state="translated">Создать "GetHashCode()"</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_0_1_in_new_file">
        <source>Generate {0} '{1}' in new file</source>
        <target state="translated">Создать {0} "{1}" в новом файле</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_nested_0_1">
        <source>Generate nested {0} '{1}'</source>
        <target state="translated">Создать вложенный {0} "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_field_for_0">
        <source>Introduce field for '{0}'</source>
        <target state="translated">Введите поле для "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_for_0">
        <source>Introduce local for '{0}'</source>
        <target state="translated">Введите локальное значение для "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_constant_for_0">
        <source>Introduce constant for '{0}'</source>
        <target state="translated">Введите константу для "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_constant_for_0">
        <source>Introduce local constant for '{0}'</source>
        <target state="translated">Введите локальную константу для "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_field_for_all_occurrences_of_0">
        <source>Introduce field for all occurrences of '{0}'</source>
        <target state="translated">Введите поле для всех вхождений "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_for_all_occurrences_of_0">
        <source>Introduce local for all occurrences of '{0}'</source>
        <target state="translated">Введите локальное значение для всех вхождений "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_constant_for_all_occurrences_of_0">
        <source>Introduce constant for all occurrences of '{0}'</source>
        <target state="translated">Введите константу для всех вхождений "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_constant_for_all_occurrences_of_0">
        <source>Introduce local constant for all occurrences of '{0}'</source>
        <target state="translated">Введите локальную константу для всех вхождений "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_query_variable_for_all_occurrences_of_0">
        <source>Introduce query variable for all occurrences of '{0}'</source>
        <target state="translated">Введите переменную запроса для всех вхождений "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_query_variable_for_0">
        <source>Introduce query variable for '{0}'</source>
        <target state="translated">Введите переменную запроса для "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="is_">
        <source>is</source>
        <target state="translated">является</target>
        <note />
      </trans-unit>
      <trans-unit id="Represents_an_object_whose_operations_will_be_resolved_at_runtime">
        <source>Represents an object whose operations will be resolved at runtime.</source>
        <target state="translated">Представляет объект, операции которого будут разрешаться во время выполнения.</target>
        <note />
      </trans-unit>
      <trans-unit id="constant">
        <source>constant</source>
        <target state="translated">константа</target>
        <note />
      </trans-unit>
      <trans-unit id="field">
        <source>field</source>
        <target state="translated">Поле</target>
        <note />
      </trans-unit>
      <trans-unit id="local_constant">
        <source>local constant</source>
        <target state="translated">локальная константа</target>
        <note />
      </trans-unit>
      <trans-unit id="local_variable">
        <source>local variable</source>
        <target state="translated">локальная переменная</target>
        <note />
      </trans-unit>
      <trans-unit id="label">
        <source>label</source>
        <target state="translated">Этикетка</target>
        <note />
      </trans-unit>
      <trans-unit id="period_era">
        <source>period/era</source>
        <target state="translated">период/эра</target>
        <note />
      </trans-unit>
      <trans-unit id="period_era_description">
        <source>The "g" or "gg" custom format specifiers (plus any number of additional "g" specifiers) represents the period or era, such as A.D. The formatting operation ignores this specifier if the date to be formatted doesn't have an associated period or era string.

If the "g" format specifier is used without other custom format specifiers, it's interpreted as the "g" standard date and time format specifier.</source>
        <target state="translated">Описатели пользовательского формата "g" или "gg" (плюс любое число дополнительных описателей "g") представляют период или эру, например "время нашей эры". Операция форматирования игнорирует этот описатель, если форматируемая дата не имеет соответствующей строки периода или эры.

Если описатель формата "g" используется без других описателей пользовательского формата, он интерпретируется как описатель "g" стандартного формата даты и времени.</target>
        <note />
      </trans-unit>
      <trans-unit id="property_accessor">
        <source>property accessor</source>
        <target state="translated">метод доступа к свойству</target>
        <note />
      </trans-unit>
      <trans-unit id="range_variable">
        <source>range variable</source>
        <target state="translated">переменная диапазона</target>
        <note />
      </trans-unit>
      <trans-unit id="parameter">
        <source>parameter</source>
        <target state="translated">параметр</target>
        <note />
      </trans-unit>
      <trans-unit id="in_">
        <source>in</source>
        <target state="translated">Входной</target>
        <note />
      </trans-unit>
      <trans-unit id="Summary_colon">
        <source>Summary:</source>
        <target state="translated">Сводка:</target>
        <note />
      </trans-unit>
      <trans-unit id="Locals_and_parameters">
        <source>Locals and parameters</source>
        <target state="translated">Локальные переменные и параметры</target>
        <note />
      </trans-unit>
      <trans-unit id="Type_parameters_colon">
        <source>Type parameters:</source>
        <target state="translated">Параметры типа:</target>
        <note />
      </trans-unit>
      <trans-unit id="Returns_colon">
        <source>Returns:</source>
        <target state="translated">Возврат:</target>
        <note />
      </trans-unit>
      <trans-unit id="Remarks_colon">
        <source>Remarks:</source>
        <target state="translated">Примечания:</target>
        <note />
      </trans-unit>
      <trans-unit id="generating_source_for_symbols_of_this_type_is_not_supported">
        <source>generating source for symbols of this type is not supported</source>
        <target state="translated">создание источника для символов такого типа не поддерживается</target>
        <note />
      </trans-unit>
      <trans-unit id="Assembly">
        <source>Assembly</source>
        <target state="translated">сборка</target>
        <note />
      </trans-unit>
      <trans-unit id="location_unknown">
        <source>location unknown</source>
        <target state="translated">расположение неизвестно</target>
        <note />
      </trans-unit>
      <trans-unit id="Unexpected_interface_member_kind_colon_0">
        <source>Unexpected interface member kind: {0}</source>
        <target state="translated">Непредвиденный тип члена интерфейса: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="The_symbol_does_not_have_an_icon">
        <source>The symbol does not have an icon.</source>
        <target state="translated">Символ не имеет значка.</target>
        <note />
      </trans-unit>
      <trans-unit id="Asynchronous_method_cannot_have_ref_out_parameters_colon_bracket_0_bracket">
        <source>Asynchronous method cannot have ref/out parameters : [{0}]</source>
        <target state="translated">Асинхронный метод не может иметь параметры ref/out: [{0}]</target>
        <note />
      </trans-unit>
      <trans-unit id="The_member_is_defined_in_metadata">
        <source>The member is defined in metadata.</source>
        <target state="translated">Член определен в метаданных.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_can_only_change_the_signature_of_a_constructor_indexer_method_or_delegate">
        <source>You can only change the signature of a constructor, indexer, method or delegate.</source>
        <target state="translated">Вы можете изменить только подпись конструктора, индексатора, метода или делегата.</target>
        <note />
      </trans-unit>
      <trans-unit id="This_symbol_has_related_definitions_or_references_in_metadata_Changing_its_signature_may_result_in_build_errors_Do_you_want_to_continue">
        <source>This symbol has related definitions or references in metadata. Changing its signature may result in build errors.

Do you want to continue?</source>
        <target state="translated">Этот символ имеет связанные с ним определения или ссылки в метаданных. Изменение его подписи может привести к ошибкам сборки.

Продолжить?</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_signature">
        <source>Change signature...</source>
        <target state="translated">Изменить подпись...</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_new_type">
        <source>Generate new type...</source>
        <target state="translated">Создать новый тип...</target>
        <note />
      </trans-unit>
      <trans-unit id="User_Diagnostic_Analyzer_Failure">
        <source>User Diagnostic Analyzer Failure.</source>
        <target state="translated">Сбой диагностического анализатора пользователей.</target>
        <note />
      </trans-unit>
      <trans-unit id="Analyzer_0_threw_an_exception_of_type_1_with_message_2">
        <source>Analyzer '{0}' threw an exception of type '{1}' with message '{2}'.</source>
        <target state="translated">Анализатор "{0}" создал исключение типа "{1}" с сообщением "{2}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Analyzer_0_threw_the_following_exception_colon_1">
        <source>Analyzer '{0}' threw the following exception:
'{1}'.</source>
        <target state="translated">Анализатор "{0}" создал следующее исключение:
"{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_qualification">
        <source>Remove qualification</source>
        <target state="translated">Удалить квалификацию</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_error_occurred">
        <source>Unknown error occurred</source>
        <target state="translated">Возникла неизвестная ошибка</target>
        <note />
      </trans-unit>
      <trans-unit id="Available">
        <source>Available</source>
        <target state="translated">Доступные</target>
        <note />
      </trans-unit>
      <trans-unit id="Not_Available">
        <source>Not Available ⚠</source>
        <target state="translated">Недоступно ⚠</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_1">
        <source>    {0} - {1}</source>
        <target state="new">    {0} - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="in_Source">
        <source>in Source</source>
        <target state="translated">в исходном</target>
        <note />
      </trans-unit>
      <trans-unit id="in_Suppression_File">
        <source>in Suppression File</source>
        <target state="translated">в файле подавляемых предупреждений</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_Suppression_0">
        <source>Remove Suppression {0}</source>
        <target state="translated">Удалить подавление {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_Suppression">
        <source>Remove Suppression</source>
        <target state="translated">Удалить подавление</target>
        <note />
      </trans-unit>
      <trans-unit id="Pending">
        <source>&lt;Pending&gt;</source>
        <target state="translated">&lt;Ожидание&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="Note_colon_Tab_twice_to_insert_the_0_snippet">
        <source>Note: Tab twice to insert the '{0}' snippet.</source>
        <target state="translated">Примечание. Два раза нажмите клавишу TAB, чтобы вставить фрагмент кода "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Computing_fix_all_occurrences_code_fix">
        <source>Computing fix all occurrences code fix...</source>
        <target state="translated">Вычисление изменения кода для исправления всех вхождений...</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_occurrences">
        <source>Fix all occurrences</source>
        <target state="translated">Исправить все случаи</target>
        <note />
      </trans-unit>
      <trans-unit id="Document">
        <source>Document</source>
        <target state="translated">Документ</target>
        <note />
      </trans-unit>
      <trans-unit id="Project">
        <source>Project</source>
        <target state="translated">Проект</target>
        <note />
      </trans-unit>
      <trans-unit id="Solution">
        <source>Solution</source>
        <target state="translated">Решение</target>
        <note />
      </trans-unit>
      <trans-unit id="Compiler2">
        <source>Compiler</source>
        <target state="translated">Компилятор</target>
        <note />
      </trans-unit>
      <trans-unit id="Live">
        <source>Live</source>
        <target state="translated">В реальном времени</target>
        <note />
      </trans-unit>
      <trans-unit id="enum_value">
        <source>enum value</source>
        <target state="translated">значение enum</target>
        <note>{Locked="enum"} "enum" is a C#/VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="const_field">
        <source>const field</source>
        <target state="translated">поле const</target>
        <note>{Locked="const"} "const" is a C#/VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="method">
        <source>method</source>
        <target state="translated">метод</target>
        <note />
      </trans-unit>
      <trans-unit id="operator_">
        <source>operator</source>
        <target state="translated">Оператор</target>
        <note />
      </trans-unit>
      <trans-unit id="constructor">
        <source>constructor</source>
        <target state="translated">конструктор</target>
        <note />
      </trans-unit>
      <trans-unit id="auto_property">
        <source>auto-property</source>
        <target state="translated">автосвойство</target>
        <note />
      </trans-unit>
      <trans-unit id="property_">
        <source>property</source>
        <target state="translated">Свойство</target>
        <note />
      </trans-unit>
      <trans-unit id="event_accessor">
        <source>event accessor</source>
        <target state="translated">метод доступа к событию</target>
        <note />
      </trans-unit>
      <trans-unit id="rfc1123_date_time">
        <source>rfc1123 date/time</source>
        <target state="translated">дата и время в формате RFC1123</target>
        <note />
      </trans-unit>
      <trans-unit id="rfc1123_date_time_description">
        <source>The "R" or "r" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.RFC1123Pattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'". When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.</source>
        <target state="translated">Описатель стандартного формата "R" или "r" представляет строку пользовательского формата даты и времени, определяемую свойством DateTimeFormatInfo.RFC1123Pattern. Шаблон отражает определенный стандарт, а само свойство доступно только для чтения. Таким образом, данное значение всегда одинаково, независимо от используемых языка и региональных параметров или от указанного поставщика формата. Строка пользовательского формата имеет вид "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'". Когда используется этот описатель стандартного формата, операция форматирования или анализа всегда использует инвариантные язык и региональные параметры.</target>
        <note />
      </trans-unit>
      <trans-unit id="round_trip_date_time">
        <source>round-trip date/time</source>
        <target state="translated">дата и время для кругового пути</target>
        <note />
      </trans-unit>
      <trans-unit id="round_trip_date_time_description">
        <source>The "O" or "o" standard format specifier represents a custom date and time format string using a pattern that preserves time zone information and emits a result string that complies with ISO 8601. For DateTime values, this format specifier is designed to preserve date and time values along with the DateTime.Kind property in text. The formatted string can be parsed back by using the DateTime.Parse(String, IFormatProvider, DateTimeStyles) or DateTime.ParseExact method if the styles parameter is set to DateTimeStyles.RoundtripKind.

The "O" or "o" standard format specifier corresponds to the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" custom format string for DateTime values and to the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffzzz" custom format string for DateTimeOffset values. In this string, the pairs of single quotation marks that delimit individual characters, such as the hyphens, the colons, and the letter "T", indicate that the individual character is a literal that cannot be changed. The apostrophes do not appear in the output string.

The "O" or "o" standard format specifier (and the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" custom format string) takes advantage of the three ways that ISO 8601 represents time zone information to preserve the Kind property of DateTime values:

    The time zone component of DateTimeKind.Local date and time values is an offset from UTC (for example, +01:00, -07:00). All DateTimeOffset values are also represented in this format.

    The time zone component of DateTimeKind.Utc date and time values uses "Z" (which stands for zero offset) to represent UTC.

    DateTimeKind.Unspecified date and time values have no time zone information.

Because the "O" or "o" standard format specifier conforms to an international standard, the formatting or parsing operation that uses the specifier always uses the invariant culture and the Gregorian calendar.

Strings that are passed to the Parse, TryParse, ParseExact, and TryParseExact methods of DateTime and DateTimeOffset can be parsed by using the "O" or "o" format specifier if they are in one of these formats. In the case of DateTime objects, the parsing overload that you call should also include a styles parameter with a value of DateTimeStyles.RoundtripKind. Note that if you call a parsing method with the custom format string that corresponds to the "O" or "o" format specifier, you won't get the same results as "O" or "o". This is because parsing methods that use a custom format string can't parse the string representation of date and time values that lack a time zone component or use "Z" to indicate UTC.</source>
        <target state="translated">Описатель стандартного формата "O" или "o" представляет строку пользовательского формата даты и времени с использованием шаблона, который сохраняет сведения о часовом поясе и дает результирующую строку, соответствующую стандарту ISO 8601. Для значений DateTime этот описатель формата предназначен для сохранения значений даты и времени вместе со свойством DateTime.Kind в тексте. Отформатированную строку можно проанализировать в обратном направлении с помощью метода DateTime.Parse(String, IFormatProvider, DateTimeStyles) или DateTime.ParseExact, если параметр styles имеет значение DateTimeStyles.RoundtripKind.

Описатель стандартного формата "O" или "o" соответствует строке пользовательского формата "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" для значений DateTime и строке пользовательского формата "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffzzz" для значений DateTimeOffset. В этой строке пары одинарных кавычек, разделяющие отдельные символы, такие как дефисы, двоеточия и буква "T", указывают, что этот отдельный знак является литералом, который не может быть изменен. Апострофы не отображаются в выходной строке.

Описатель стандартного формата "O" или "o" (и строка пользовательского формата "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK") использует преимущества трех описанных в ISO 8601 способов представления сведений о часовом поясе, для сохранения свойства Kind значений DateTime:

    Компонент часового пояса в значениях даты и времени DateTimeKind.Local является смещением от UTC (например, +01:00, -07:00). Все значения DateTimeOffset также представлены в этом формате.

    Компонент часового пояса для значений даты и времени DateTimeKind.Utc использует "Z" (что означает нулевое смещение) для представления времени в формате UTC.

    Значения даты и времени DateTimeKind.Unspecified не содержат сведения о часовом поясе.

Так как описатель стандартного формата "O" или "o" соответствует международным стандарту, операция форматирования или анализа, использующая этот описатель, всегда использует инвариантные язык и региональные параметры, а также григорианский календарь.

Строки, передаваемые в методы Parse, TryParse, ParseExact и TryParseExact для значений DateTime и DateTimeOffset, можно проанализировать с помощью описателя формата "O" или "o", если они имеют один из этих форматов. В случае объектов DateTime вызываемая перегрузка анализа должна также включать параметр styles со значением DateTimeStyles.RoundtripKind. Обратите внимание, что при вызове метода анализа со строкой пользовательского формата, соответствующей описателю формата "O" или "o", результаты будут не такими, как для "O" или "o". Это вызвано тем, что методы анализа, использующие строку пользовательского формата, не могут анализировать строковое представление значений даты и времени, в которых отсутствует компонент часового пояса или используется "Z" для обозначения времени в формате UTC.</target>
        <note />
      </trans-unit>
      <trans-unit id="second_1_2_digits">
        <source>second (1-2 digits)</source>
        <target state="translated">секунда (1–2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="second_1_2_digits_description">
        <source>The "s" custom format specifier represents the seconds as a number from 0 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted without a leading zero.

If the "s" format specifier is used without other custom format specifiers, it's interpreted as the "s" standard date and time format specifier.</source>
        <target state="translated">Описатель пользовательского формата "s" представляет секунды в виде числа от 0 до 59. Это число представляет собой целые секунды, истекшие с момента наступления последней минуты. Значение секунд из одной цифры форматируется без начального нуля.

Если описатель формата "s" используется без других описателей пользовательского формата, он интерпретируется как описатель "s" стандартного формата даты и времени.</target>
        <note />
      </trans-unit>
      <trans-unit id="second_2_digits">
        <source>second (2 digits)</source>
        <target state="translated">секунда (2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="second_2_digits_description">
        <source>The "ss" custom format specifier (plus any number of additional "s" specifiers) represents the seconds as a number from 00 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted with a leading zero.</source>
        <target state="translated">Описатель пользовательского формата "ss" (плюс любое число дополнительных описателей "s") представляет секунды в виде числа от 00 до 59. Это число представляет собой целые секунды, истекшие с момента наступления последней минуты. Значение секунд из одной цифры форматируется с начальным нулем.</target>
        <note />
      </trans-unit>
      <trans-unit id="short_date">
        <source>short date</source>
        <target state="translated">Краткий формат даты</target>
        <note />
      </trans-unit>
      <trans-unit id="short_date_description">
        <source>The "d" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.ShortDatePattern property. For example, the custom format string that is returned by the ShortDatePattern property of the invariant culture is "MM/dd/yyyy".</source>
        <target state="translated">Описатель стандартного формата "d" представляет строку пользовательского формата даты и времени, определяемую свойством DateTimeFormatInfo.ShortDatePattern конкретных языка и региональных параметров. Например, строка пользовательского формата, возвращаемая свойством ShortDatePattern для инвариантных языка и региональных параметров, имеет вид "MM/dd/yyyy".</target>
        <note />
      </trans-unit>
      <trans-unit id="short_time">
        <source>short time</source>
        <target state="translated">Краткий формат времени</target>
        <note />
      </trans-unit>
      <trans-unit id="short_time_description">
        <source>The "t" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.ShortTimePattern property. For example, the custom format string for the invariant culture is "HH:mm".</source>
        <target state="translated">Описатель стандартного формата "t" представляет строку пользовательского формата даты и времени, определяемую текущим свойством DateTimeFormatInfo.ShortTimePattern. Например, строка пользовательского формата для инвариантных языка и региональных параметров имеет вид "HH:mm".</target>
        <note />
      </trans-unit>
      <trans-unit id="sortable_date_time">
        <source>sortable date/time</source>
        <target state="translated">Формат даты-времени для сортировки</target>
        <note />
      </trans-unit>
      <trans-unit id="sortable_date_time_description">
        <source>The "s" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.SortableDateTimePattern property. The pattern reflects a defined standard (ISO 8601), and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "yyyy'-'MM'-'dd'T'HH':'mm':'ss".

The purpose of the "s" format specifier is to produce result strings that sort consistently in ascending or descending order based on date and time values. As a result, although the "s" standard format specifier represents a date and time value in a consistent format, the formatting operation does not modify the value of the date and time object that is being formatted to reflect its DateTime.Kind property or its DateTimeOffset.Offset value. For example, the result strings produced by formatting the date and time values 2014-11-15T18:32:17+00:00 and 2014-11-15T18:32:17+08:00 are identical.

When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.</source>
        <target state="translated">Описатель стандартного формата "s" представляет строку пользовательского формата даты и времени, определяемую свойством DateTimeFormatInfo.SortableDateTimePattern. Шаблон отражает определенный стандарт (ISO 8601), а само свойство доступно только для чтения. Таким образом, данное значение всегда одинаково, независимо от используемых языка и региональных параметров или от указанного поставщика формата. Строка пользовательского формата имеет вид "yyyy'-'MM'-'dd'T'HH':'mm':'ss".

Описатель формата "s" предназначен для получения результирующих строк, которые согласованным образом сортируются по возрастанию или убыванию на основе значений даты и времени. В результате, хотя описатель стандартного формата "s" представляет значение даты и времени в согласованном формате, операция форматирования не изменяет значение объекта даты и времени, которое форматируется, чтобы отразить его свойство DateTime.Kind или его значение DateTimeOffset.Offset. Например, результирующие строки, полученные при форматировании значений даты и времени 2014-11-15T18:32:17+00:00 и 2014-11-15T18:32:17+08:00, идентичны.

Когда используется этот описатель стандартного формата, операция форматирования или анализа всегда использует инвариантные язык и региональные параметры.</target>
        <note />
      </trans-unit>
      <trans-unit id="static_constructor">
        <source>static constructor</source>
        <target state="translated">статический конструктор</target>
        <note />
      </trans-unit>
      <trans-unit id="struct_">
        <source>struct</source>
        <target state="translated">структура</target>
        <note />
      </trans-unit>
      <trans-unit id="symbol_cannot_be_a_namespace">
        <source>'symbol' cannot be a namespace.</source>
        <target state="translated">'"символ" не может быть пространством имен.</target>
        <note />
      </trans-unit>
      <trans-unit id="symbol_kind_and_name_of_member_kind_and_name">
        <source>{0} '{1}' of {2} '{3}'</source>
        <target state="translated">{0} ' {1} ' из {2} ' {3} '</target>
        <note>e.g. "parameter 'T param' of method 'M'"</note>
      </trans-unit>
      <trans-unit id="time_separator">
        <source>time separator</source>
        <target state="translated">разделитель компонентов времени</target>
        <note />
      </trans-unit>
      <trans-unit id="time_separator_description">
        <source>The ":" custom format specifier represents the time separator, which is used to differentiate hours, minutes, and seconds. The appropriate localized time separator is retrieved from the DateTimeFormatInfo.TimeSeparator property of the current or specified culture.

Note: To change the time separator for a particular date and time string, specify the separator character within a literal string delimiter. For example, the custom format string hh'_'dd'_'ss produces a result string in which "_" (an underscore) is always used as the time separator. To change the time separator for all dates for a culture, either change the value of the DateTimeFormatInfo.TimeSeparator property of the current culture, or instantiate a DateTimeFormatInfo object, assign the character to its TimeSeparator property, and call an overload of the formatting method that includes an IFormatProvider parameter.

If the ":" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">Описатель пользовательского формата ":" представляет разделитель компонентов времени, который позволяет различать часы, минуты и секунды. Соответствующий локализованный разделитель компонентов времени извлекается из свойства DateTimeFormatInfo.TimeSeparator текущих или заданных языка и региональных параметров.

Примечание. Чтобы изменить разделитель компонентов времени для определенной строки даты и времени, укажите знак разделения в разделителе литеральной строки. Например, строка пользовательского формата hh'_'dd'_'ss дает результирующую строку, в которой "_" (символ подчеркивания) всегда используется в качестве разделителя компонентов времени. Чтобы изменить разделитель компонентов времени для всех дат для языка и региональных параметров, измените значение свойства DateTimeFormatInfo.TimeSeparator текущих языка и региональных параметров или создайте экземпляр объекта DateTimeFormatInfo, присвойте этот знак его свойству TimeSeparator и вызовите перегрузку метода форматирования, включающую параметр IFormatProvider.

Если описатель формата ":" используется без других описателей пользовательского формата, он интерпретируется как описатель стандартного формата даты и времени и вызывает исключение FormatException.</target>
        <note />
      </trans-unit>
      <trans-unit id="time_zone">
        <source>time zone</source>
        <target state="translated">Часовой пояс</target>
        <note />
      </trans-unit>
      <trans-unit id="time_zone_description">
        <source>The "K" custom format specifier represents the time zone information of a date and time value. When this format specifier is used with DateTime values, the result string is defined by the value of the DateTime.Kind property:

    For the local time zone (a DateTime.Kind property value of DateTimeKind.Local), this specifier is equivalent to the "zzz" specifier and produces a result string containing the local offset from Coordinated Universal Time (UTC); for example, "-07:00".

    For a UTC time (a DateTime.Kind property value of DateTimeKind.Utc), the result string includes a "Z" character to represent a UTC date.

    For a time from an unspecified time zone (a time whose DateTime.Kind property equals DateTimeKind.Unspecified), the result is equivalent to String.Empty.

For DateTimeOffset values, the "K" format specifier is equivalent to the "zzz" format specifier, and produces a result string containing the DateTimeOffset value's offset from UTC.

If the "K" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">Описатель пользовательского формата "K" представляет сведения о часовом поясе для значения даты и времени. Если этот описатель формата используется со значениями DateTime, результирующая строка определяется значением свойства DateTime.Kind:

    Для локального часового пояса (значение DateTimeKind.Local свойства DateTime.Kind) этот описатель равнозначен описателю "zzz" и дает результирующую строку, содержащую локальное смещение от UTC, например, "-07:00".

    Для времени в формате UTC (значение DateTimeKind.Utc свойства DateTime.Kind) результирующая строка включает символ "Z" для обозначения даты в формате UTC.

    Для времени из неуказанного часового пояса (значение DateTimeKind.Unspecified свойства DateTime.Kind) результат эквивалентен String.Empty.

Для значений DateTimeOffset описатель формата "K" равнозначен описателю формата "zzz" и дает результирующую строку, содержащую смещение значения DateTimeOffset от UTC.

Если описатель формата "K" используется без других описателей пользовательского формата, он интерпретируется как описатель стандартного формата даты и времени и вызывает исключение FormatException.</target>
        <note />
      </trans-unit>
      <trans-unit id="type">
        <source>type</source>
        <target state="translated">тип</target>
        <note />
      </trans-unit>
      <trans-unit id="type_constraint">
        <source>type constraint</source>
        <target state="translated">ограничение типа</target>
        <note />
      </trans-unit>
      <trans-unit id="type_parameter">
        <source>type parameter</source>
        <target state="translated">параметр типа</target>
        <note />
      </trans-unit>
      <trans-unit id="attribute">
        <source>attribute</source>
        <target state="translated">атрибут</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_and_1_with_property">
        <source>Replace '{0}' and '{1}' with property</source>
        <target state="translated">Заменить "{0}" и "{1}" свойством</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_property">
        <source>Replace '{0}' with property</source>
        <target state="translated">Заменить "{0}" свойством</target>
        <note />
      </trans-unit>
      <trans-unit id="Method_referenced_implicitly">
        <source>Method referenced implicitly</source>
        <target state="translated">Неявная ссылка на метод</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_type_0">
        <source>Generate type '{0}'</source>
        <target state="translated">Создать тип "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_0_1">
        <source>Generate {0} '{1}'</source>
        <target state="translated">Создать {0} "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_0_to_1">
        <source>Change '{0}' to '{1}'.</source>
        <target state="translated">Измените "{0}" на "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Non_invoked_method_cannot_be_replaced_with_property">
        <source>Non-invoked method cannot be replaced with property.</source>
        <target state="translated">Невызванный метод нельзя заменить свойством.</target>
        <note />
      </trans-unit>
      <trans-unit id="Only_methods_with_a_single_argument_which_is_not_an_out_variable_declaration_can_be_replaced_with_a_property">
        <source>Only methods with a single argument, which is not an out variable declaration, can be replaced with a property.</source>
        <target state="translated">Заменить на свойство можно только методы с одним аргументом, который не является объявлением внешней переменной.</target>
        <note />
      </trans-unit>
      <trans-unit id="Roslyn_HostError">
        <source>Roslyn.HostError</source>
        <target state="translated">Roslyn.HostError</target>
        <note />
      </trans-unit>
      <trans-unit id="An_instance_of_analyzer_0_cannot_be_created_from_1_colon_2">
        <source>An instance of analyzer {0} cannot be created from {1}: {2}.</source>
        <target state="translated">Экземпляр анализатора {0} невозможно создать из {1}: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_assembly_0_does_not_contain_any_analyzers">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">Сборка {0} не содержит анализаторов.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unable_to_load_Analyzer_assembly_0_colon_1">
        <source>Unable to load Analyzer assembly {0}: {1}</source>
        <target state="translated">Не удалось загрузить сборку анализатора {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="from_0">
        <source>from {0}</source>
        <target state="translated">из {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Find_and_install_latest_version">
        <source>Find and install latest version</source>
        <target state="translated">Найти и установить последнюю версию</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_local_version_0">
        <source>Use local version '{0}'</source>
        <target state="translated">Использовать локальную версию "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_locally_installed_0_version_1_This_version_used_in_colon_2">
        <source>Use locally installed '{0}' version '{1}'
This version used in: {2}</source>
        <target state="translated">Использовать локально установленное ПО "{0}" версии "{1}"
Эта версия используется в: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="Find_and_install_latest_version_of_0">
        <source>Find and install latest version of '{0}'</source>
        <target state="translated">Найти и установить последнюю версию "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_with_package_manager">
        <source>Install with package manager...</source>
        <target state="translated">Установить с помощью диспетчера пакетов...</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_0_1">
        <source>Install '{0} {1}'</source>
        <target state="translated">Установить "{0} {1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_version_0">
        <source>Install version '{0}'</source>
        <target state="translated">Установить версию "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes">
        <source>Classes</source>
        <target state="translated">Классы</target>
        <note />
      </trans-unit>
      <trans-unit id="Constants">
        <source>Constants</source>
        <target state="translated">Константы</target>
        <note />
      </trans-unit>
      <trans-unit id="Delegates">
        <source>Delegates</source>
        <target state="translated">Делегаты</target>
        <note />
      </trans-unit>
      <trans-unit id="Enums">
        <source>Enums</source>
        <target state="translated">Перечисления</target>
        <note />
      </trans-unit>
      <trans-unit id="Events">
        <source>Events</source>
        <target state="translated">События</target>
        <note />
      </trans-unit>
      <trans-unit id="Extension_methods">
        <source>Extension methods</source>
        <target state="translated">Методы расширения</target>
        <note />
      </trans-unit>
      <trans-unit id="Fields">
        <source>Fields</source>
        <target state="translated">Поля</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces">
        <source>Interfaces</source>
        <target state="translated">Интерфейсы</target>
        <note />
      </trans-unit>
      <trans-unit id="Methods">
        <source>Methods</source>
        <target state="translated">Методы</target>
        <note />
      </trans-unit>
      <trans-unit id="Modules">
        <source>Modules</source>
        <target state="translated">Модули</target>
        <note />
      </trans-unit>
      <trans-unit id="Namespaces">
        <source>Namespaces</source>
        <target state="translated">Пространства имен</target>
        <note />
      </trans-unit>
      <trans-unit id="Properties">
        <source>Properties</source>
        <target state="translated">Свойства</target>
        <note />
      </trans-unit>
      <trans-unit id="Structures">
        <source>Structures</source>
        <target state="translated">Структуры</target>
        <note />
      </trans-unit>
      <trans-unit id="Parameters_colon">
        <source>Parameters:</source>
        <target state="translated">Параметры:</target>
        <note />
      </trans-unit>
      <trans-unit id="Variadic_SignatureHelpItem_must_have_at_least_one_parameter">
        <source>Variadic SignatureHelpItem must have at least one parameter.</source>
        <target state="translated">Variadic SignatureHelpItem должен иметь хотя бы один параметр.</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_method">
        <source>Replace '{0}' with method</source>
        <target state="translated">Заменить "{0}" методом</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_methods">
        <source>Replace '{0}' with methods</source>
        <target state="translated">Заменить "{0}" методами</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_referenced_implicitly">
        <source>Property referenced implicitly</source>
        <target state="translated">На свойство имеется неявная ссылка</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_cannot_safely_be_replaced_with_a_method_call">
        <source>Property cannot safely be replaced with a method call</source>
        <target state="translated">Свойство нельзя безопасно заменить на вызов метода</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_interpolated_string">
        <source>Convert to interpolated string</source>
        <target state="translated">Преобразовать в интерполированную строку</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_type_to_0">
        <source>Move type to {0}</source>
        <target state="translated">Переместить тип в {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Rename_file_to_0">
        <source>Rename file to {0}</source>
        <target state="translated">Переименовать файл в {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Rename_type_to_0">
        <source>Rename type to {0}</source>
        <target state="translated">Переименовать тип в {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="paren_Unknown_paren">
        <source>(Unknown)</source>
        <target state="translated">(Неизвестно)</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_framework_type">
        <source>Use framework type</source>
        <target state="translated">Использовать тип платформы</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_package_0">
        <source>Install package '{0}'</source>
        <target state="translated">Установить пакет "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="project_0">
        <source>project {0}</source>
        <target state="translated">проект: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Fully_qualify_0">
        <source>Fully qualify '{0}'</source>
        <target state="translated">Определить полностью "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_reference_to_0">
        <source>Remove reference to '{0}'.</source>
        <target state="translated">Удалить ссылку на "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Keywords">
        <source>Keywords</source>
        <target state="translated">Ключевые слова</target>
        <note />
      </trans-unit>
      <trans-unit id="Snippets">
        <source>Snippets</source>
        <target state="translated">Фрагменты кода</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_document_0">
        <source>Remove document '{0}'</source>
        <target state="translated">Удалить документ "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_document_0">
        <source>Add document '{0}'</source>
        <target state="translated">Добавить документ "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_argument_name_0">
        <source>Add argument name '{0}'</source>
        <target state="translated">Добавить имя аргумента "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unused_variable">
        <source>Remove unused variable</source>
        <target state="translated">Удалить неиспользуемые переменные</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_binary">
        <source>Convert to binary</source>
        <target state="translated">Преобразовать в двоичное</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_decimal">
        <source>Convert to decimal</source>
        <target state="translated">Преобразовать в десятичное</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_hex">
        <source>Convert to hex</source>
        <target state="translated">Преобразовать в шестнадцатеричное</target>
        <note />
      </trans-unit>
      <trans-unit id="Separate_thousands">
        <source>Separate thousands</source>
        <target state="translated">Разделять тысячи</target>
        <note />
      </trans-unit>
      <trans-unit id="Separate_words">
        <source>Separate words</source>
        <target state="translated">Разделять слова</target>
        <note />
      </trans-unit>
      <trans-unit id="Separate_nibbles">
        <source>Separate nibbles</source>
        <target state="translated">Разделять полубайты</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_separators">
        <source>Remove separators</source>
        <target state="translated">Удалить разделители</target>
        <note />
      </trans-unit>
      <trans-unit id="Pick_members_to_be_used_as_constructor_parameters">
        <source>Pick members to be used as constructor parameters</source>
        <target state="translated">Выберите члены, которые будут использоваться как параметры конструктора</target>
        <note />
      </trans-unit>
      <trans-unit id="Pick_members_to_be_used_in_Equals_GetHashCode">
        <source>Pick members to be used in Equals/GetHashCode</source>
        <target state="translated">Выберите члены, которые будут использоваться в Equals/GetHashCode</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_overrides">
        <source>Generate overrides...</source>
        <target state="translated">Создать переопределения...</target>
        <note />
      </trans-unit>
      <trans-unit id="Pick_members_to_override">
        <source>Pick members to override</source>
        <target state="translated">Выберите члены для переопределения</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_null_check">
        <source>Add null check</source>
        <target state="translated">Добавить проверку значений NULL</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_string_IsNullOrEmpty_check">
        <source>Add 'string.IsNullOrEmpty' check</source>
        <target state="new">Add 'string.IsNullOrEmpty' check</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_string_IsNullOrWhiteSpace_check">
        <source>Add 'string.IsNullOrWhiteSpace' check</source>
        <target state="new">Add 'string.IsNullOrWhiteSpace' check</target>
        <note />
      </trans-unit>
      <trans-unit id="Initialize_field_0">
        <source>Initialize field '{0}'</source>
        <target state="translated">Инициализировать поле "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Initialize_property_0">
        <source>Initialize property '{0}'</source>
        <target state="translated">Инициализировать свойство "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_null_checks">
        <source>Add _null checks</source>
        <target state="translated">Добавить проверки значений _null</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_operators">
        <source>Generate operators</source>
        <target state="translated">Создать операторы</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_0">
        <source>Implement {0}</source>
        <target state="translated">Реализация {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Reported_diagnostic_0_has_a_source_location_in_file_1_which_is_not_part_of_the_compilation_being_analyzed">
        <source>Reported diagnostic '{0}' has a source location in file '{1}', which is not part of the compilation being analyzed.</source>
        <target state="translated">В отчете о диагностике "{0}" используется исходное расположение "{1}", которое не входит в анализируемую компиляцию.</target>
        <note />
      </trans-unit>
      <trans-unit id="Reported_diagnostic_0_has_a_source_location_1_in_file_2_which_is_outside_of_the_given_file">
        <source>Reported diagnostic '{0}' has a source location '{1}' in file '{2}', which is outside of the given file.</source>
        <target state="translated">В отчете о диагностике "{0}" используется исходное расположение "{1}" в файле "{2}". Это расположение находится за пределами указанного файла.</target>
        <note />
      </trans-unit>
      <trans-unit id="in_0_project_1">
        <source>in {0} (project {1})</source>
        <target state="translated">в {0} (проект {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_declaration_near_reference">
        <source>Move declaration near reference</source>
        <target state="translated">Переместить объявление рядом со ссылкой</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_full_property">
        <source>Convert to full property</source>
        <target state="translated">Преобразовать в полное свойство</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_Method_overrides_symbol_from_metadata">
        <source>Warning: Method overrides symbol from metadata</source>
        <target state="translated">Предупреждение. Метод переопределяет символ из метаданных.</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_0">
        <source>Use {0}</source>
        <target state="translated">Использовать {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_argument_name_0_including_trailing_arguments">
        <source>Add argument name '{0}' (including trailing arguments)</source>
        <target state="translated">Добавьте имя аргумента "{0}" (включая конечные аргументы)</target>
        <note />
      </trans-unit>
      <trans-unit id="local_function">
        <source>local function</source>
        <target state="translated">локальная функция</target>
        <note />
      </trans-unit>
      <trans-unit id="indexer_">
        <source>indexer</source>
        <target state="translated">индексатор</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_Collection_was_modified_during_iteration">
        <source>Warning: Collection was modified during iteration.</source>
        <target state="translated">Внимание! Коллекция изменена во время итерации.</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_Iteration_variable_crossed_function_boundary">
        <source>Warning: Iteration variable crossed function boundary.</source>
        <target state="translated">Внимание! Переменная итерации вышла за границу функции.</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_full_date_time">
        <source>universal full date/time</source>
        <target state="translated">Универсальный полный формат даты-времени</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_full_date_time_description">
        <source>The "U" standard format specifier represents a custom date and time format string that is defined by a specified culture's DateTimeFormatInfo.FullDateTimePattern property. The pattern is the same as the "F" pattern. However, the DateTime value is automatically converted to UTC before it is formatted.</source>
        <target state="translated">Описатель стандартного формата "U" представляет строку пользовательского формата даты и времени, определяемую свойством DateTimeFormatInfo.FullDateTimePattern заданных языка и региональных параметров. Этот шаблон совпадает с шаблоном "F". Однако перед форматированием значение DateTime автоматически преобразуется в формат UTC.</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_sortable_date_time">
        <source>universal sortable date/time</source>
        <target state="translated">Универсальный формат даты-времени для сортировки</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_sortable_date_time_description">
        <source>The "u" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.UniversalSortableDateTimePattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "yyyy'-'MM'-'dd HH':'mm':'ss'Z'". When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.

Although the result string should express a time as Coordinated Universal Time (UTC), no conversion of the original DateTime value is performed during the formatting operation. Therefore, you must convert a DateTime value to UTC by calling the DateTime.ToUniversalTime method before formatting it.</source>
        <target state="translated">Описатель стандартного формата "u" представляет строку пользовательского формата даты и времени, определяемую свойством DateTimeFormatInfo.UniversalSortableDateTimePattern. Шаблон отражает определенный стандарт, а само свойство доступно только для чтения. Таким образом, данное значение всегда одинаково, независимо от используемых языка и региональных параметров или указанного поставщика формата. Строка пользовательского формата имеет вид "yyyy'-'MM'-'dd HH':'mm':'ss'Z". Когда применяется этот описатель стандартного формата, операция форматирования или анализа всегда использует инвариантные язык и региональные параметры.

Хотя результирующая строка должна выражать время в формате UTC, во время операции форматирования преобразование исходного значения DateTime не выполняется. Поэтому перед форматированием необходимо преобразовать значение DateTime в формат UTC, вызвав метод DateTime.ToUniversalTime.</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_containing_member">
        <source>updating usages in containing member</source>
        <target state="translated">обновление директив usage во вложенном элементе</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_containing_project">
        <source>updating usages in containing project</source>
        <target state="translated">обновление директив usage во вложенном проекте</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_containing_type">
        <source>updating usages in containing type</source>
        <target state="translated">обновление директив usage во вложенном типе</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_dependent_projects">
        <source>updating usages in dependent projects</source>
        <target state="translated">обновление директив usage в зависимых проектах</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_and_minute_offset">
        <source>utc hour and minute offset</source>
        <target state="translated">смещение от UTC в часах и минутах</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_and_minute_offset_description">
        <source>With DateTime values, the "zzz" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours and minutes. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "zzz" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours and minutes.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted with a leading zero.</source>
        <target state="translated">При использовании значений типа DateTime описатель пользовательского формата "zzz" представляет значение смещения локального часового пояса операционной системы от UTC, имеющее знак и измеряемое в часах и минутах. Оно не отражает значение свойства DateTime.Kind экземпляра. Поэтому описатель формата "zzz" не рекомендуется использовать со значениями DateTime.

При использовании значений DateTimeOffset этот описатель формата представляет смещение значения DateTimeOffset от UTC в часах и минутах.

Смещение всегда отображается с предшествующим знаком. Знак "плюс" (+) обозначает часы опережения UTC, а знак "минус" (-) — часы отставания от UTC. Смещение из одной цифры форматируется с начальным нулем.</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_1_2_digits">
        <source>utc hour offset (1-2 digits)</source>
        <target state="translated">смещение от UTC в часах (1–2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_1_2_digits_description">
        <source>With DateTime values, the "z" custom format specifier represents the signed offset of the local operating system's time zone from Coordinated Universal Time (UTC), measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "z" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted without a leading zero.

If the "z" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">При использовании значений типа DateTime описатель пользовательского формата "z" представляет значение смещения локального часового пояса операционной системы от UTC, имеющее знак и измеряемое в часах. Оно не отражает значение свойства DateTime.Kind экземпляра. Поэтому описатель формата "z" не рекомендуется использовать со значениями DateTime.

При использовании значений DateTimeOffset этот описатель формата представляет смещение значения DateTimeOffset от UTC в часах.

Смещение всегда отображается с предшествующим знаком. Знак "плюс" (+) обозначает часы опережения UTC, а знак "минус" (-) — часы отставания от UTC. Смещение из одной цифры форматируется без начального нуля.

Если описатель формата "z" используется без других описателей пользовательского формата, он интерпретируется как описатель стандартного формата даты и времени и вызывает исключение FormatException.</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_2_digits">
        <source>utc hour offset (2 digits)</source>
        <target state="translated">смещение от UTC в часах (2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_2_digits_description">
        <source>With DateTime values, the "zz" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "zz" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted with a leading zero.</source>
        <target state="translated">При использовании значений типа DateTime описатель пользовательского формата "zz" представляет значение смещения локального часового пояса операционной системы от UTC, имеющее знак и измеряемое в часах. Оно не отражает значение свойства DateTime.Kind экземпляра. Поэтому описатель формата "zz" не рекомендуется использовать со значениями DateTime.

При использовании значений DateTimeOffset этот описатель формата представляет смещение значения DateTimeOffset от UTC в часах.

Смещение всегда отображается с предшествующим знаком. Знак "плюс" (+) обозначает часы опережения UTC, а знак "минус" (-) — часы отставания от UTC. Смещение из одной цифры форматируется с начальным нулем.</target>
        <note />
      </trans-unit>
      <trans-unit id="while_loop">
        <source>while loop</source>
        <target state="translated">Цикл while</target>
        <note />
      </trans-unit>
      <trans-unit id="x_y_range_in_reverse_order">
        <source>[x-y] range in reverse order</source>
        <target state="translated">Диапазон [x-y] в обратном порядке</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [b-a]</note>
      </trans-unit>
      <trans-unit id="year_1_2_digits">
        <source>year (1-2 digits)</source>
        <target state="translated">год (1–2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_1_2_digits_description">
        <source>The "y" custom format specifier represents the year as a one-digit or two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the first digit of a two-digit year begins with a zero (for example, 2008), the number is formatted without a leading zero.

If the "y" format specifier is used without other custom format specifiers, it's interpreted as the "y" standard date and time format specifier.</source>
        <target state="translated">Описатель пользовательского формата "y" представляет год как число из одной или двух цифр. Если в значении года больше двух цифр, в результате появятся только два младших разряда. Если первый разряд такого двузначного года является нулевым (например, 2008), число форматируется без начального нуля.

Если описатель формата "y" используется без других описателей пользовательского формата, он интерпретируется как описатель "y" стандартного формата даты и времени.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_2_digits">
        <source>year (2 digits)</source>
        <target state="translated">год (2 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_2_digits_description">
        <source>The "yy" custom format specifier represents the year as a two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the two-digit year has fewer than two significant digits, the number is padded with leading zeros to produce two digits.

In a parsing operation, a two-digit year that is parsed using the "yy" custom format specifier is interpreted based on the Calendar.TwoDigitYearMax property of the format provider's current calendar. The following example parses the string representation of a date that has a two-digit year by using the default Gregorian calendar of the en-US culture, which, in this case, is the current culture. It then changes the current culture's CultureInfo object to use a GregorianCalendar object whose TwoDigitYearMax property has been modified.</source>
        <target state="translated">Описатель пользовательского формата "yy" представляет год как число из двух цифр. Если в значении года больше двух значащих цифр, в результате появятся только два младших разряда. Если двузначное значение года содержит меньше двух значащих цифр, число дополняется начальными нулями, чтобы получить два разряда.

В операции анализа двузначное значение года, проанализированное с использованием описателя пользовательского формата "yy", интерпретируется на основе Calendar.TwoDigitYearMax текущего календаря поставщика формата. В следующем примере строковое представление даты с двузначным годом анализируется с использованием григорианского календаря для языка и региональных параметров en-US, которые в данном случае являются текущими. Затем объект CultureInfo текущих языка и региональных параметров изменяется для использования объекта GregorianCalendar, свойство TwoDigitYearMax которого было изменено.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_3_4_digits">
        <source>year (3-4 digits)</source>
        <target state="translated">год (3–4 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_3_4_digits_description">
        <source>The "yyy" custom format specifier represents the year with a minimum of three digits. If the year has more than three significant digits, they are included in the result string. If the year has fewer than three digits, the number is padded with leading zeros to produce three digits.</source>
        <target state="translated">Описатель пользовательского формата "yyy" представляет год как число из по меньшей мере трех цифр. Если в значении года больше трех значащих цифр, они включаются в результирующую строку. Если значение года содержит меньше трех цифр, число дополняется начальными нулями, чтобы получить три разряда.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_4_digits">
        <source>year (4 digits)</source>
        <target state="translated">год (4 цифры)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_4_digits_description">
        <source>The "yyyy" custom format specifier represents the year with a minimum of four digits. If the year has more than four significant digits, they are included in the result string. If the year has fewer than four digits, the number is padded with leading zeros to produce four digits.</source>
        <target state="translated">Описатель пользовательского формата "yyyy" представляет год как число из по меньшей мере четырех цифр. Если в значении года больше четырех значащих цифр, они включаются в результирующую строку. Если значение года содержит меньше четырех цифр, число дополняется начальными нулями, чтобы получить четыре разряда.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_5_digits">
        <source>year (5 digits)</source>
        <target state="translated">год (5 цифр)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_5_digits_description">
        <source>The "yyyyy" custom format specifier (plus any number of additional "y" specifiers) represents the year with a minimum of five digits. If the year has more than five significant digits, they are included in the result string. If the year has fewer than five digits, the number is padded with leading zeros to produce five digits.

If there are additional "y" specifiers, the number is padded with as many leading zeros as necessary to produce the number of "y" specifiers.</source>
        <target state="translated">Описатель пользовательского формата "yyyyy" (плюс любое число дополнительных описателей "y") представляет год как число из по меньшей мере пяти цифр. Если в значении года больше пяти значащих цифр, они включаются в результирующую строку. Если значение года содержит меньше пяти цифр, число дополняется начальными нулями, чтобы получить пять разрядов.

При наличии дополнительных описателей "y" число дополняется таким количеством начальных нулей, которое позволяет получить нужное число описателей "y".</target>
        <note />
      </trans-unit>
      <trans-unit id="year_month">
        <source>year month</source>
        <target state="translated">Месяц года</target>
        <note />
      </trans-unit>
      <trans-unit id="year_month_description">
        <source>The "Y" or "y" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.YearMonthPattern property of a specified culture. For example, the custom format string for the invariant culture is "yyyy MMMM".</source>
        <target state="translated">Описатель стандартного формата "Y" или "y" представляет строку пользовательского формата даты и времени, определяемую свойством DateTimeFormatInfo.YearMonthPattern заданных языка и региональных параметров. Например, строка пользовательского формата для инвариантных языка и региональных параметров имеет вид "yyyy MMMM".</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>