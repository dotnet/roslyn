<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../FeaturesResources.resx">
    <body>
      <trans-unit id="AM_PM_abbreviated">
        <source>AM/PM (abbreviated)</source>
        <target state="translated">AM/PM(缩写)</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_abbreviated_description">
        <source>The "t" custom format specifier represents the first character of the AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property of the current or specific culture. The AM designator is used for all times from 0:00:00 (midnight) to 11:59:59.999. The PM designator is used for all times from 12:00:00 (noon) to 23:59:59.999.

If the "t" format specifier is used without other custom format specifiers, it's interpreted as the "t" standard date and time format specifier.</source>
        <target state="translated">"T" 自定义格式说明符表示 AM/PM 指示符的第一个字符。相应的本地化指示符从当前或特定区域性的 DateTimeFormatInfo.AMDesignator 或 DateTimeFormatInfo.PMDesignator 属性中进行检索。AM 指示符用于指示从 0:00:00 (午夜)到 11:59:59.999 的所有时间。PM 指示符用于指示从 12:00:00 (中午)到 23:59:59.999 的所有时间。

如果使用 "t" 格式说明符而未使用其他自定义格式说明符，则该说明符将被解释为 "t" 标准日期和时间格式说明符。</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_full">
        <source>AM/PM (full)</source>
        <target state="translated">AM/PM(完整)</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_full_description">
        <source>The "tt" custom format specifier (plus any number of additional "t" specifiers) represents the entire AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property of the current or specific culture. The AM designator is used for all times from 0:00:00 (midnight) to 11:59:59.999. The PM designator is used for all times from 12:00:00 (noon) to 23:59:59.999.

Make sure to use the "tt" specifier for languages for which it's necessary to maintain the distinction between AM and PM. An example is Japanese, for which the AM and PM designators differ in the second character instead of the first character.</source>
        <target state="translated">"tt" 自定义格式说明符(另加任意数量的其他 "t" 说明符)表示整个 AM/PM 指示符。相应的本地化指示符从当前或特定区域性的 DateTimeFormatInfo.AMDesignator 或 DateTimeFormatInfo.PMDesignator 属性中进行检索。AM 指示符用于指示从 0:00:00(午夜)到 11:59:59.999 的所有时间。PM 指示符用于指示从 12:00:00 (中午)到 23:59:59.999 的所有时间。

请确保对需要维护 AM 和 PM 之间的差异的语言使用 "tt" 说明符。例如日语，其 AM 和 PM 指示符在第二个字符(而不是第一个字符)会不同。</target>
        <note />
      </trans-unit>
      <trans-unit id="A_subtraction_must_be_the_last_element_in_a_character_class">
        <source>A subtraction must be the last element in a character class</source>
        <target state="translated">负号必须是字符类中的最后一个元素</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-[b]-c]</note>
      </trans-unit>
      <trans-unit id="Add_DebuggerDisplay_attribute">
        <source>Add 'DebuggerDisplay' attribute</source>
        <target state="translated">添加 "DebuggerDisplay" 属性</target>
        <note>{Locked="DebuggerDisplay"} "DebuggerDisplay" is a BCL class and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Add_explicit_cast">
        <source>Add explicit cast</source>
        <target state="translated">添加显式转换</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_member_name">
        <source>Add member name</source>
        <target state="translated">添加成员名称</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_null_checks_for_all_parameters">
        <source>Add null checks for all parameters</source>
        <target state="translated">为所有参数添加 null 检查</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_optional_parameter_to_constructor">
        <source>Add optional parameter to constructor</source>
        <target state="translated">将可选参数添加到构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_parameter_to_0_and_overrides_implementations">
        <source>Add parameter to '{0}' (and overrides/implementations)</source>
        <target state="translated">将参数添加到“{0}”(和重写/实现)</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_parameter_to_constructor">
        <source>Add parameter to constructor</source>
        <target state="translated">将参数添加到构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_project_reference_to_0">
        <source>Add project reference to '{0}'.</source>
        <target state="translated">将参数引用添加到“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_reference_to_0">
        <source>Add reference to '{0}'.</source>
        <target state="translated">将引用添加到“{0}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="Actions_can_not_be_empty">
        <source>Actions can not be empty.</source>
        <target state="translated">操作不能为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_tuple_element_name_0">
        <source>Add tuple element name '{0}'</source>
        <target state="translated">添加元组元素名称 "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_an_interface_method_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' into an interface method will prevent the debug session from continuing.</source>
        <target state="translated">将 "{0}" 添加进接口方法将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_an_interface_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' into an interface will prevent the debug session from continuing.</source>
        <target state="translated">将 "{0}" 添加进接口将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_method_with_explicit_interface_specifier_will_prevernt_the_debug_session_from_continuing">
        <source>Adding a method with an explicit interface specifier will prevent the debug session from continuing.</source>
        <target state="translated">添加具有显式接口说明符的方法将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Align_wrapped_arguments">
        <source>Align wrapped arguments</source>
        <target state="translated">对齐包装的参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Align_wrapped_parameters">
        <source>Align wrapped parameters</source>
        <target state="translated">对齐包装参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Alternation_conditions_cannot_be_comments">
        <source>Alternation conditions cannot be comments</source>
        <target state="translated">替换条件不能是注释</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a|(?#b)</note>
      </trans-unit>
      <trans-unit id="Alternation_conditions_do_not_capture_and_cannot_be_named">
        <source>Alternation conditions do not capture and cannot be named</source>
        <target state="translated">替换条件不捕获且不能命名</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(?'x'))</note>
      </trans-unit>
      <trans-unit id="Awaited_task_returns_0">
        <source>Awaited task returns '{0}'</source>
        <target state="translated">等待任务返回“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Awaited_task_returns_no_value">
        <source>Awaited task returns no value</source>
        <target state="translated">等待任务没有返回任何值</target>
        <note />
      </trans-unit>
      <trans-unit id="Base_classes_contain_inaccessible_unimplemented_members">
        <source>Base classes contain inaccessible unimplemented members</source>
        <target state="translated">基类包含无法访问的未实现成员</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotApplyChangesUnexpectedError">
        <source>Cannot apply changes -- unexpected error: '{0}'</source>
        <target state="translated">无法应用更改 - 意外错误:“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_include_class_0_in_character_range">
        <source>Cannot include class \{0} in character range</source>
        <target state="translated">不能在字符范围内包含类 \{0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-\w]. {0} is the invalid class (\w here)</note>
      </trans-unit>
      <trans-unit id="Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue">
        <source>Capture group numbers must be less than or equal to Int32.MaxValue</source>
        <target state="translated">捕获组编号必须小于等于 Int32.MaxValue</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{2147483648}</note>
      </trans-unit>
      <trans-unit id="Capture_number_cannot_be_zero">
        <source>Capture number cannot be zero</source>
        <target state="translated">捕获编号不能为零</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;0&gt;a)</note>
      </trans-unit>
      <trans-unit id="ChangeSignature_NewParameterInferValue">
        <source>&lt;infer&gt;</source>
        <target state="translated">&lt;infer&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeSignature_NewParameterIntroduceTODOVariable">
        <source>TODO</source>
        <target state="translated">TODO</target>
        <note>"TODO" is an indication that there is work still to be done.</note>
      </trans-unit>
      <trans-unit id="ChangeSignature_NewParameterOmitValue">
        <source>&lt;omit&gt;</source>
        <target state="translated">&lt;省略&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_namespace_to_0">
        <source>Change namespace to '{0}'</source>
        <target state="translated">将名称空间更改为“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_to_global_namespace">
        <source>Change to global namespace</source>
        <target state="translated">更改为全局命名空间</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangesDisallowedWhileStoppedAtException">
        <source>Changes are not allowed while stopped at exception</source>
        <target state="translated">在出现异常而停止时禁止更改</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangesNotAppliedWhileRunning">
        <source>Changes made in project '{0}' will not be applied while the application is running</source>
        <target state="translated">在应用程序运行时，将不应用在项目“{0}”中所作的更改</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_0_from_asynchronous_to_synchronous_will_prevent_the_debug_session_from_continuing">
        <source>Changing '{0}' from asynchronous to synchronous will prevent the debug session from continuing.</source>
        <target state="translated">将“{0}”从异步更改为同步会阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_0_to_1_will_prevent_the_debug_session_from_continuing_because_it_changes_the_shape_of_the_state_machine">
        <source>Changing '{0}' to '{1}' will prevent the debug session from continuing because it changes the shape of the state machine.</source>
        <target state="translated">将“{0}”更改为“{1}”会阻止调试会话继续执行，因为它会更改状态机的形状。</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_0_code_style">
        <source>Configure {0} code style</source>
        <target state="translated">配置 {0} 代码样式</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_0_severity">
        <source>Configure {0} severity</source>
        <target state="translated">配置 {0} 严重性</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_severity_for_all_0_analyzers">
        <source>Configure severity for all '{0}' analyzers</source>
        <target state="translated">为所有“{0}”分析器配置严重性</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_severity_for_all_analyzers">
        <source>Configure severity for all analyzers</source>
        <target state="translated">为所有分析器配置严重性</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_linq">
        <source>Convert to LINQ</source>
        <target state="translated">转换为 LINQ</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_to_0">
        <source>Add to '{0}'</source>
        <target state="translated">添加到“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_class">
        <source>Convert to class</source>
        <target state="translated">转换为类</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_linq_call_form">
        <source>Convert to LINQ (call form)</source>
        <target state="translated">转换为 LINQ (调用表单)</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_struct">
        <source>Convert to struct</source>
        <target state="translated">转换为结构</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_type_to_0">
        <source>Convert type to '{0}'</source>
        <target state="translated">将类型转换为“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_field_0">
        <source>Create and assign field '{0}'</source>
        <target state="translated">创建并分配字段 "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_property_0">
        <source>Create and assign property '{0}'</source>
        <target state="translated">创建并分配属性 "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_remaining_as_fields">
        <source>Create and assign remaining as fields</source>
        <target state="translated">创建并分配其余字段</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_remaining_as_properties">
        <source>Create and assign remaining as properties</source>
        <target state="translated">创建并分配其余属性</target>
        <note />
      </trans-unit>
      <trans-unit id="DisposableFieldsShouldBeDisposedDescription">
        <source>A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field.</source>
        <target state="translated">实现 System.IDisposable 的类型将声明一些字段，这些字段所属的类型还实现 IDisposable。字段的 Dispose 方法不由声明类型的 Dispose 方法调用。若要修复此规则的违规行为，如果你负责分配和释放该字段持有的非托管资源，请在其所属类型实现 IDisposable 的字段上调用 Dispose。</target>
        <note />
      </trans-unit>
      <trans-unit id="Disposable_field_0_is_never_disposed">
        <source>Disposable field '{0}' is never disposed</source>
        <target state="translated">从未释放可释放字段 "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Disposable_fields_should_be_disposed">
        <source>Disposable fields should be disposed</source>
        <target state="translated">应释放可释放的字段</target>
        <note />
      </trans-unit>
      <trans-unit id="Disposable_object_created_by_0_is_never_disposed">
        <source>Disposable object created by '{0}' is never disposed</source>
        <target state="translated">从未释放由 "{0}" 创建的可释放对象</target>
        <note />
      </trans-unit>
      <trans-unit id="Dispose_objects_before_losing_scope">
        <source>Dispose objects before losing scope</source>
        <target state="translated">丢失范围之前释放对象</target>
        <note />
      </trans-unit>
      <trans-unit id="Do_not_change_this_code_Put_cleanup_code_in_0_method">
        <source>Do not change this code. Put cleanup code in '{0}' method</source>
        <target state="translated">不要更改此代码。请将清理代码放入“{0}”方法中</target>
        <note />
      </trans-unit>
      <trans-unit id="DocumentIsOutOfSyncWithDebuggee">
        <source>The current content of source file '{0}' does not match the built source. Any changes made to this file while debugging won't be applied until its content matches the built source.</source>
        <target state="translated">源文件 "{0}" 的当前内容与生成的源不匹配。在调试期间对此文件所做的任何更改都不会应用，直到其内容与生成的源匹配为止。</target>
        <note />
      </trans-unit>
      <trans-unit id="Document_must_be_contained_in_the_workspace_that_created_this_service">
        <source>Document must be contained in the workspace that created this service</source>
        <target state="translated">文件必须包含在创建此服务的工作区中</target>
        <note />
      </trans-unit>
      <trans-unit id="EditAndContinue">
        <source>Edit and Continue</source>
        <target state="translated">编辑并继续</target>
        <note />
      </trans-unit>
      <trans-unit id="EditAndContinueDisallowedByModule">
        <source>Edit and Continue disallowed by module</source>
        <target state="translated">模块已禁用“编辑并继续”</target>
        <note />
      </trans-unit>
      <trans-unit id="EditAndContinueDisallowedByProject">
        <source>Changes made in project '{0}' will prevent the debug session from continuing: {1}</source>
        <target state="translated">在项目“{0}”中所作的更改将阻止调试会话继续: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorReadingFile">
        <source>Error while reading file '{0}': {1}</source>
        <target state="translated">读取文件“{0}”时出错: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Example">
        <source>Example:</source>
        <target state="translated">示例:</target>
        <note>Singular form when we want to show an example, but only have one to show.</note>
      </trans-unit>
      <trans-unit id="Examples">
        <source>Examples:</source>
        <target state="translated">示例:</target>
        <note>Plural form when we have multiple examples to show.</note>
      </trans-unit>
      <trans-unit id="Extract_base_class">
        <source>Extract base class...</source>
        <target state="new">Extract base class...</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_interface">
        <source>Extract interface...</source>
        <target state="translated">提取接口…</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_local_function">
        <source>Extract local function</source>
        <target state="translated">提取本地函数</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_method">
        <source>Extract method</source>
        <target state="translated">提取方法</target>
        <note />
      </trans-unit>
      <trans-unit id="Failed_to_analyze_data_flow_for_0">
        <source>Failed to analyze data-flow for: {0}</source>
        <target state="translated">未能分析 {0} 的数据流</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_formatting">
        <source>Fix formatting</source>
        <target state="translated">修正格式</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_typo_0">
        <source>Fix typo '{0}'</source>
        <target state="translated">修正笔误“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Formatting_document">
        <source>Formatting document</source>
        <target state="translated">设置文档格式</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_comparison_operators">
        <source>Generate comparison operators</source>
        <target state="translated">生成比较运算符</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constructor_in_0_with_fields">
        <source>Generate constructor in '{0}' (with fields)</source>
        <target state="translated">在“{0}”中生成构造函数(包含字段)</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constructor_in_0_with_properties">
        <source>Generate constructor in '{0}' (with properties)</source>
        <target state="translated">在“{0}”中生成构造函数(包含属性)</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_for_0">
        <source>Generate for '{0}'</source>
        <target state="translated">为 "{0}" 生成</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_parameter_0">
        <source>Generate parameter '{0}'</source>
        <target state="translated">生成参数 "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_parameter_0_and_overrides_implementations">
        <source>Generate parameter '{0}' (and overrides/implementations)</source>
        <target state="translated">生成参数 {0}(和重写/实现)</target>
        <note />
      </trans-unit>
      <trans-unit id="Illegal_backslash_at_end_of_pattern">
        <source>Illegal \ at end of pattern</source>
        <target state="translated">模式末尾的 \ 非法</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \</note>
      </trans-unit>
      <trans-unit id="Illegal_x_y_with_x_less_than_y">
        <source>Illegal {x,y} with x &gt; y</source>
        <target state="translated">x &gt; y 的 {x,y} 无效</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{1,0}</note>
      </trans-unit>
      <trans-unit id="Implement_0_explicitly">
        <source>Implement '{0}' explicitly</source>
        <target state="translated">显式实现 "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_0_implicitly">
        <source>Implement '{0}' implicitly</source>
        <target state="translated">隐式实现 "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_abstract_class">
        <source>Implement abstract class</source>
        <target state="translated">实现抽象类</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_all_interfaces_explicitly">
        <source>Implement all interfaces explicitly</source>
        <target state="translated">显式实现所有接口</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_all_interfaces_implicitly">
        <source>Implement all interfaces implicitly</source>
        <target state="translated">隐式实现所有接口</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_all_members_explicitly">
        <source>Implement all members explicitly</source>
        <target state="translated">显式实现所有成员</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_explicitly">
        <source>Implement explicitly</source>
        <target state="translated">显式实现</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_implicitly">
        <source>Implement implicitly</source>
        <target state="translated">隐式实现</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_remaining_members_explicitly">
        <source>Implement remaining members explicitly</source>
        <target state="translated">显式实现剩余成员</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_through_0">
        <source>Implement through '{0}'</source>
        <target state="translated">通过“{0}”实现</target>
        <note />
      </trans-unit>
      <trans-unit id="Incomplete_character_escape">
        <source>Incomplete \p{X} character escape</source>
        <target state="translated">\p{X} 字符转义不完整</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{ Cc }</note>
      </trans-unit>
      <trans-unit id="Indent_all_arguments">
        <source>Indent all arguments</source>
        <target state="translated">缩进所有参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_all_parameters">
        <source>Indent all parameters</source>
        <target state="translated">缩进所有参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_wrapped_arguments">
        <source>Indent wrapped arguments</source>
        <target state="translated">缩进包装的参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_wrapped_parameters">
        <source>Indent wrapped parameters</source>
        <target state="translated">缩进包装参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Inline_0">
        <source>Inline '{0}'</source>
        <target state="new">Inline '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Inline_and_keep_0">
        <source>Inline and keep '{0}'</source>
        <target state="new">Inline and keep '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Insufficient_hexadecimal_digits">
        <source>Insufficient hexadecimal digits</source>
        <target state="translated">无效的十六进制数字</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \x</note>
      </trans-unit>
      <trans-unit id="Introduce_constant">
        <source>Introduce constant</source>
        <target state="translated">引入常量</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_field">
        <source>Introduce field</source>
        <target state="translated">介绍领域</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local">
        <source>Introduce local</source>
        <target state="translated">引入局部</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_query_variable">
        <source>Introduce query variable</source>
        <target state="translated">引入查询变量</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_group_name_Group_names_must_begin_with_a_word_character">
        <source>Invalid group name: Group names must begin with a word character</source>
        <target state="translated">组名无效: 组名必须以单词字符开头</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;a &gt;a)</note>
      </trans-unit>
      <trans-unit id="Make_class_abstract">
        <source>Make class 'abstract'</source>
        <target state="translated">将类设置为 "abstract"</target>
        <note />
      </trans-unit>
      <trans-unit id="Make_member_static">
        <source>Make static</source>
        <target state="translated">设为静态</target>
        <note />
      </trans-unit>
      <trans-unit id="Invert_conditional">
        <source>Invert conditional</source>
        <target state="translated">反转条件</target>
        <note />
      </trans-unit>
      <trans-unit id="Malformed">
        <source>malformed</source>
        <target state="translated">格式错误</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0</note>
      </trans-unit>
      <trans-unit id="Malformed_character_escape">
        <source>Malformed \p{X} character escape</source>
        <target state="translated">\p{X} 字符转义格式错误</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p {Cc}</note>
      </trans-unit>
      <trans-unit id="Malformed_named_back_reference">
        <source>Malformed \k&lt;...&gt; named back reference</source>
        <target state="translated">名为“向后引用”的 \k&lt;...&gt; 格式不正确</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k'</note>
      </trans-unit>
      <trans-unit id="Merge_with_nested_0_statement">
        <source>Merge with nested '{0}' statement</source>
        <target state="translated">与嵌套的 "{0}" 语句合并</target>
        <note />
      </trans-unit>
      <trans-unit id="Merge_with_next_0_statement">
        <source>Merge with next '{0}' statement</source>
        <target state="translated">与下一个 "{0}" 语句合并</target>
        <note />
      </trans-unit>
      <trans-unit id="Merge_with_outer_0_statement">
        <source>Merge with outer '{0}' statement</source>
        <target state="translated">与外部 "{0}" 语句合并</target>
        <note />
      </trans-unit>
      <trans-unit id="Merge_with_previous_0_statement">
        <source>Merge with previous '{0}' statement</source>
        <target state="translated">与以前的 "{0}" 语句合并</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodMustReturnStreamThatSupportsReadAndSeek">
        <source>{0} must return a stream that supports read and seek operations.</source>
        <target state="translated">{0} 必须返回支持读取和查找操作的流。</target>
        <note />
      </trans-unit>
      <trans-unit id="Missing_control_character">
        <source>Missing control character</source>
        <target state="translated">缺少控制字符</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \c</note>
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_a_switch_expression_will_prevent_the_debug_session_from_continuing">
        <source>Modifying '{0}' which contains a switch expression will prevent the debug session from continuing.</source>
        <target state="translated">修改包含 switch 表达式的“{0}”将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_body_of_member_will_prevent_the_debug_session_from_continuing_because_the_body_has_too_many_statements">
        <source>Modifying the body of '{0}' will prevent the debug session from continuing because the body has too many statements.</source>
        <target state="new">Modifying the body of '{0}' will prevent the debug session from continuing because the body has too many statements.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_body_of_member_will_prevent_the_debug_session_from_continuing_due_to_internal_error">
        <source>Modifying the body of '{0}' will prevent the debug session from continuing due to internal error: {1}</source>
        <target state="new">Modifying the body of '{0}' will prevent the debug session from continuing due to internal error: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_source_file_will_prevent_the_debug_session_from_continuing_because_the_file_is_too_big">
        <source>Modifying source file '{0}' will prevent the debug session from continuing because the file is too big.</source>
        <target state="new">Modifying source file '{0}' will prevent the debug session from continuing because the file is too big.</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_contents_to_namespace">
        <source>Move contents to namespace...</source>
        <target state="translated">将内容移动到命名空间...</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_file_to_0">
        <source>Move file to '{0}'</source>
        <target state="translated">将文件移至“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_file_to_project_root_folder">
        <source>Move file to project root folder</source>
        <target state="translated">将文件移动到项目根文件夹</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_to_namespace">
        <source>Move to namespace...</source>
        <target state="translated">移动到命名空间...</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_source_file_will_prevent_the_debug_session_from_continuing_due_to_internal_error">
        <source>Modifying source file '{0}' will prevent the debug session from continuing due to internal error: {1}</source>
        <target state="needs-review-translation">修改源文件 {0} 将防止调试会话因内部错误 {1} 而继续进行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Nested_quantifier_0">
        <source>Nested quantifier {0}</source>
        <target state="translated">嵌套限定符 {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a**. In this case {0} will be '*', the extra unnecessary quantifier.</note>
      </trans-unit>
      <trans-unit id="Not_enough_close_parens">
        <source>Not enough )'s</source>
        <target state="translated">")" 不足</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (a</note>
      </trans-unit>
      <trans-unit id="Property_reference_cannot_be_updated">
        <source>Property reference cannot be updated</source>
        <target state="translated">无法更新属性引用</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_0_up">
        <source>Pull '{0}' up</source>
        <target state="translated">向上拉 "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_0_up_to_1">
        <source>Pull '{0}' up to '{1}'</source>
        <target state="translated">将 "{0}" 拉到 "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_members_up_to_base_type">
        <source>Pull members up to base type...</source>
        <target state="translated">将成员拉到基本类型..。</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_members_up_to_new_base_class">
        <source>Pull member(s) up to new base class...</source>
        <target state="new">Pull member(s) up to new base class...</target>
        <note />
      </trans-unit>
      <trans-unit id="Quantifier_x_y_following_nothing">
        <source>Quantifier {x,y} following nothing</source>
        <target state="translated">限定符 {x,y} 前没有任何内容</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: *</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group">
        <source>reference to undefined group</source>
        <target state="translated">对未定义组的引用</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(1))</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_name_0">
        <source>Reference to undefined group name {0}</source>
        <target state="translated">对未定义的组名 {0} 的引用</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k&lt;a&gt;. Here, {0} will be the name of the undefined group ('a')</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_number_0">
        <source>Reference to undefined group number {0}</source>
        <target state="translated">对未定义的组编号 {0} 的引用</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;-1&gt;). Here, {0} will be the number of the undefined group ('1')</note>
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_long">
        <source>All control characters. This includes the Cc, Cf, Cs, Co, and Cn categories.</source>
        <target state="translated">所有控制字符。这包括 Cc、Cf、Cs、Co 和 Cn 类别。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_short">
        <source>all control characters</source>
        <target state="translated">所有控制字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_long">
        <source>All diacritic marks. This includes the Mn, Mc, and Me categories.</source>
        <target state="translated">所有音调符号标记。这包括 "Mn"、"Mc" 和 "Me" 类别。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_short">
        <source>all diacritic marks</source>
        <target state="translated">所有音调符号标记</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_long">
        <source>All letter characters. This includes the Lu, Ll, Lt, Lm, and Lo characters.</source>
        <target state="translated">所有字母字符。这包括 Lu、Ll、Lt、Lm 和 Lo 字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_short">
        <source>all letter characters</source>
        <target state="translated">所有字母字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_long">
        <source>All numbers. This includes the Nd, Nl, and No categories.</source>
        <target state="translated">所有数字。这包括 Nd、Nl 和 No 类别。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_short">
        <source>all numbers</source>
        <target state="translated">所有数字</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_long">
        <source>All punctuation characters. This includes the Pc, Pd, Ps, Pe, Pi, Pf, and Po categories.</source>
        <target state="translated">所有标点字符。这包括 Pc、Pd、Ps、Pe、Pi、Pf 和 Po 类别。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_short">
        <source>all punctuation characters</source>
        <target state="translated">所有标点字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_long">
        <source>All separator characters. This includes the Zs, Zl, and Zp categories.</source>
        <target state="translated">所有分隔符字符。这包括 Zs、Zl 和 Zp 类别。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_short">
        <source>all separator characters</source>
        <target state="translated">所有分隔符字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_long">
        <source>All symbols. This includes the Sm, Sc, Sk, and So categories.</source>
        <target state="translated">所有符号。这包括 Sm、Sc、Sk 和 So 类别。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_short">
        <source>all symbols</source>
        <target state="translated">所有符号</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_long">
        <source>You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.</source>
        <target state="translated">可以使用竖线(|)字符匹配一系列模式中的任何一个，其中 | 字符分隔每个模式。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_short">
        <source>alternation</source>
        <target state="translated">替换</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_long">
        <source>The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified by the 's' option, . matches any character.</source>
        <target state="translated">句点字符(.)匹配除 \n (换行符 \u000A)以外的任何字符。如果正则表达式模式已被 RegexOptions Singleline 选项修改，或者如果包含 ". " 字符类的模式部分已被 "s" 选项修改，则 ". " 可匹配任何字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_short">
        <source>any character</source>
        <target state="translated">任何字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_atomic_group_long">
        <source>Atomic groups (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression) disable backtracking. The regular expression engine will match as many characters in the input string as it can. When no further match is possible, it will not backtrack to attempt alternate pattern matches. (That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)

This option is recommended if you know that backtracking will not succeed. Preventing the regular expression engine from performing unnecessary searching improves performance.</source>
        <target state="translated">原子组(在其他一些正则表达式引擎中称为非回溯子表达式、原子子表达式或一次性子表达式)禁用回溯。正则表达式引擎将匹配输入字符串中的多个字符。当无进一步的匹配时，它将不回溯以尝试匹配备用模式。(也就是说，子表达式只匹配那些将单独由子表达式匹配的字符串；它不会尝试根据子表达式和其后的任何子表达式匹配字符串。)

如果你知道回溯不会成功，建议使用此选项。防止正则表达式引擎执行不必要的搜索可提高性能。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_atomic_group_short">
        <source>atomic group</source>
        <target state="translated">原子组</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_long">
        <source>Matches a backspace character, \u0008</source>
        <target state="translated">与退格键字符(\u0008)匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_short">
        <source>backspace character</source>
        <target state="translated">退格键字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_long">
        <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.
    
'name1' is the current group (optional), 'name2' is a previously defined group, and 'subexpression' is any valid regular expression pattern. The balancing group definition deletes the definition of name2 and stores the interval between name2 and name1 in name1. If no name2 group is defined, the match backtracks. Because deleting the last definition of name2 reveals the previous definition of name2, this construct lets you use the stack of captures for group name2 as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.

The balancing group definition uses 'name2' as a stack. The beginning character of each nested construct is placed in the group and in its Group.Captures collection. When the closing character is matched, its corresponding opening character is removed from the group, and the Captures collection is decreased by one. After the opening and closing characters of all nested constructs have been matched, 'name1' is empty.</source>
        <target state="translated">均衡组定义删除以前定义的组的定义，并在当前组中存储以前定义的组和当前组之间的时间间隔。
    
"name1" 是当前组(可选)，"name2" 是以前定义的组，而 "subexpression" 是任何有效的正则表达式模式。均衡组定义将删除 name2 的定义，并在 name1 中存储 name2 和 name1 之间的间隔。如果未定义 name2 组，则匹配回溯。由于删除 name2 的最后一个定义会发现 name2 的上一个定义，此构造使你能够使用作为计数器的组的捕获堆栈来跟踪嵌套构造(如括号)或左括号和右括号。

均衡组定义使用 "name2" 作为堆栈。每个嵌套构造的开始字符都放在该组中并位于其组中。捕获集合。匹配结束字符时，将从组中删除其相应的左符号，并减小捕获集合 1。在所有嵌套构造的开始和结束字符都匹配后，"name1" 为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_short">
        <source>balancing group</source>
        <target state="translated">均衡组</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_base_group">
        <source>base-group</source>
        <target state="translated">基本组</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_long">
        <source>Matches a bell (alarm) character, \u0007</source>
        <target state="translated">与响铃(警告)字符(\u0007)匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_short">
        <source>bell character</source>
        <target state="translated">响铃字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_long">
        <source>Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n.</source>
        <target state="translated">与回车符(\u000D)匹配。请注意，\r 与换行符(\n)不等效。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_short">
        <source>carriage-return character</source>
        <target state="translated">回车符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_long">
        <source>Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.

'base_group' is a positive or negative character group or range. The 'excluded_group' component is another positive or negative character group, or another character class subtraction expression (that is, you can nest character class subtraction expressions).</source>
        <target state="translated">字符类减法生成一组字符，这是从另一个字符类中排除一个字符类中的字符后得到的。

"base_group" 为正或为负的字符组或范围。"excluded_group" 组件是另一个为正或为负的字符组，或其他字符类减法表达式(即，可以嵌套字符类减法表达式)。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_short">
        <source>character class subtraction</source>
        <target state="translated">字符类减法</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_group">
        <source>character-group</source>
        <target state="translated">字符组</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_comment">
        <source>comment</source>
        <target state="translated">注释</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.

'expression' is the initial pattern to match, 'yes' is the pattern to match if expression is matched, and 'no' is the optional pattern to match if expression is not matched.</source>
        <target state="translated">此语言元素尝试匹配两种模式之一，具体取决于它是否可以与初始模式匹配。

"expression" 是要匹配的初始模式，如果表达式匹配，则 "yes" 是可匹配的模式；如果表达式不匹配，则 "no" 是可匹配的可选模式。。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_short">
        <source>conditional expression match</source>
        <target state="translated">条件表达式匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.

'name' is the name (or number) of a capturing group, 'yes' is the expression to match if 'name' (or 'number') has a match, and 'no' is the optional expression to match if it does not.</source>
        <target state="translated">此语言元素尝试匹配两种模式之一，具体取决于它是否与指定的捕获组匹配。

"name" 是捕获组的名称(或编号)，"yes" 是在 "name" (或 "number") 具有匹配项的情况下匹配的表达式，"no" 是没有匹配的情况下可匹配的可选表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_short">
        <source>conditional group match</source>
        <target state="translated">条件组匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_long">
        <source>The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.</source>
        <target state="translated">\G 定位点指定匹配必须出现在上一个匹配结束的点。在 Regex.Matches 或 Match.NextMatch 方法中使用此定位点可确保所有匹配项都是连续的。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_short">
        <source>contiguous matches</source>
        <target state="translated">连续匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_long">
        <source>Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C.</source>
        <target state="translated">与 ASCII 控制字符匹配，其中 X 是控制字符的字母。例如, \cC 是 CTRL-C。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_short">
        <source>control character</source>
        <target state="translated">控制字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_long">
        <source>\d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.

If ECMAScript-compliant behavior is specified, \d is equivalent to [0-9]</source>
        <target state="translated">\d 匹配任何十进制数字。它等效于 \p{Nd} 正则表达式模式，该模式包括标准十进制数字 0-9 以及许多其他字符集的小数位数。

如果指定了符合 ECMAScript 的行为，则 \d 等效于 [0-9]</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_short">
        <source>decimal-digit character</source>
        <target state="translated">十进制数字字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_long">
        <source>A number sign (#) marks an x-mode comment, which starts at the unescaped # character at the end of the regular expression pattern and continues until the end of the line. To use this construct, you must either enable the x option (through inline options) or supply the RegexOptions.IgnorePatternWhitespace value to the option parameter when instantiating the Regex object or calling a static Regex method.</source>
        <target state="translated">数字符号(#)标记 x 模式注释，该注释从正则表达式模式结尾处的非转义 # 字符开始，一直持续到行尾。若要使用此构造，必须启用 x 选项(通过内联选项)，或者在实例化 regex 对象或调用静态 regex 方法时向选项参数提供 RegexOptions 值。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_short">
        <source>end-of-line comment</source>
        <target state="translated">行尾注释</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_long">
        <source>The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, it can only match the last line of the input string.</source>
        <target state="translated">\z 定位点指定匹配必须出现在输入字符串的末尾。像 $ language 元素一样，\z 忽略了 RegexOptions 选项。与 \z 语言元素不同，\z 与字符串结尾的 \n 字符不匹配。因此，它只能匹配输入字符串的最后一行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_short">
        <source>end of string only</source>
        <target state="translated">仅字符串末尾</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_long">
        <source>The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can only match the end of the last line, or the last line before \n.

The \Z anchor matches \n but does not match \r\n (the CR/LF character combination). To match CR/LF, include \r?\Z in the regular expression pattern.</source>
        <target state="translated">\Z 定位点指定匹配必须出现在输入字符串的末尾或输入字符串的结尾处的 \n 之前。它与 $ 定位点相同，只不过 \Z 忽略了 RegexOptions 选项。因此，在多行字符串中，它只能匹配最后一行的结尾或 \n 前的最后一行。

\Z 定位点匹配 \n 但不匹配 \r\n (CR/LF 字符组合)。若要匹配 CR/LF，请在正则表达式模式中包含 \r?\Z。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_short">
        <source>end of string or before ending newline</source>
        <target state="translated">字符串末尾或结束换行符之前</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_long">
        <source>The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string. If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line.

The $ anchor matches \n but does not match \r\n (the combination of carriage return and newline characters, or CR/LF). To match the CR/LF character combination, include \r?$ in the regular expression pattern.</source>
        <target state="translated">$ 定位点指定前面的模式必须出现在输入字符串的末尾或输入字符串结尾的 \n 之前。如果将 $ 与 RegexOptions 选项一起使用，则匹配也可以出现在行尾。

$ 定位点匹配 \n，但不匹配 \r\n (回车符和换行符的组合，或 CR/LF)。若要匹配 CR/LF 字符组合, 请在正则表达式模式中包括 \r?$。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_short">
        <source>end of string or line</source>
        <target state="translated">字符串或行的结尾</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_long">
        <source>Matches an escape character, \u001B</source>
        <target state="translated">与转义字符(\u001B)匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_short">
        <source>escape character</source>
        <target state="translated">转义字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_excluded_group">
        <source>excluded-group</source>
        <target state="translated">排除的组</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_expression">
        <source>expression</source>
        <target state="new">expression</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_long">
        <source>Matches a form-feed character, \u000C</source>
        <target state="translated">与换页符(\u000C)匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_short">
        <source>form-feed character</source>
        <target state="translated">换页符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_long">
        <source>This grouping construct applies or disables the specified options within a subexpression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly
	named or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">此分组构造应用或禁用子表达式中的指定选项。在问号后指定要启用的选项，在减号后禁用的选项。允许的选项有:

    i	使用不区分大小写的匹配。
    m	使用多行模式，其中 ^ 和 $ 分别匹配每行的开头和结尾
	(而不是输入字符串的开头和结尾)。
    s	使用单行模式，其中句点(.)与每个字符
	(而不是除 \n 之外的每个字符)匹配。
    n	请勿捕获未命名的组。唯一有效的捕获已被显式
	命名为或编码为(?&lt;name&gt; subexpression)形式的组。
    x	请删除模式中的非转义空格，并
	在数字符号(#)之后使用注释。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_short">
        <source>group options</source>
        <target state="translated">组选项</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_long">
        <source>Matches an ASCII character, where ## is a two-digit hexadecimal character code.</source>
        <target state="translated">与 ASCII 字符匹配，其中 ## 是两位数的十六进制字符代码。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_short">
        <source>hexadecimal escape</source>
        <target state="translated">十六进制转义符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_long">
        <source>The (?# comment) construct lets you include an inline comment in a regular expression. The regular expression engine does not use any part of the comment in pattern matching, although the comment is included in the string that is returned by the Regex.ToString method. The comment ends at the first closing parenthesis.</source>
        <target state="translated">(?# comment)构造允许在正则表达式中包括内联注释。尽管注释包含在 Regex 方法返回的字符串中，但正则表达式引擎不使用模式匹配中注释的任何部分。注释以第一个右括号结束。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_short">
        <source>inline comment</source>
        <target state="translated">内联注释</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_long">
        <source>Enables or disables specific pattern matching options for the remainder of a regular expression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly named
	or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">为正则表达式的其余部分启用或禁用特定模式匹配选项。在问号后面指定要启用的选项，在减号后指定要禁用的选项。允许的选项有:

    i	使用不区分大小写的匹配。
    m	使用多行模式，其中 ^ 和 $ 分别匹配每行的开头和结尾
	(而不是输入字符串的开头和结尾)。
    s	使用单行模式，其中句点(.)与每个字符
	(而不是除 \n 之外的每个字符)匹配。
    n	请勿捕获未命名的组。唯一有效的捕获已被显式
	命名为或编码为(?&lt;name&gt; subexpression)形式的组。
    x	请删除模式中的非转义空格，并
	在数字符号(#)之后使用注释。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_short">
        <source>inline options</source>
        <target state="translated">内联选项</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_issue_0">
        <source>Regex issue: {0}</source>
        <target state="translated">正则表达式问题: {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. {0} will be the actual text of one of the above Regular Expression errors.</note>
      </trans-unit>
      <trans-unit id="Regex_letter_lowercase">
        <source>letter, lowercase</source>
        <target state="translated">字母，小写</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_modifier">
        <source>letter, modifier</source>
        <target state="translated">字母，修饰符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_other">
        <source>letter, other</source>
        <target state="translated">字母，其他</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_titlecase">
        <source>letter, titlecase</source>
        <target state="translated">字母，首字母大写</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_uppercase">
        <source>letter, uppercase</source>
        <target state="translated">字母，大写</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_enclosing">
        <source>mark, enclosing</source>
        <target state="translated">标记，封闭</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_nonspacing">
        <source>mark, nonspacing</source>
        <target state="translated">标记，非间距</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_spacing_combining">
        <source>mark, spacing combining</source>
        <target state="translated">标记，间距组合</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_long">
        <source>The {n,}? quantifier matches the preceding element at least n times, where n is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,}</source>
        <target state="translated">{n,}? 限定符匹配前面的元素至少 n 次，其中 n 是任何整数，但次数尽可能少。它是贪婪限定符 {n,} 的惰性副本</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">至少匹配 "n" 次(惰性)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_long">
        <source>The {n,} quantifier matches the preceding element at least n times, where n is any integer. {n,} is a greedy quantifier whose lazy equivalent is {n,}?</source>
        <target state="translated">{n,} 限定符匹配前面的元素至少 n 次，其中 n 是任何整数。{n,} 是贪婪限定符，其惰性等效值为 {n,}?</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_short">
        <source>match at least 'n' times</source>
        <target state="translated">至少匹配 "n" 次</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_long">
        <source>The {n,m}? quantifier matches the preceding element between n and m times, where n and m are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,m}</source>
        <target state="translated">{n,m}? 限定符匹配前面的元素 n 次和 m 次，其中 n 和 m 是整数，但次数尽可能少。它是贪婪限定符 {n, m} 的惰性副本</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">至少匹配 "n" 次(惰性)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_long">
        <source>The {n,m} quantifier matches the preceding element at least n times, but no more than m times, where n and m are integers. {n,m} is a greedy quantifier whose lazy equivalent is {n,m}?</source>
        <target state="translated">{n, m} 限定符匹配前面的元素至少 n 次，但不超过 m 次，其中 n 和 m 是整数。{n, m} 是贪婪限定符，其惰性等效值为 {n,m}?</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_short">
        <source>match between 'm' and 'n' times</source>
        <target state="translated">匹配次数介于 "m" 次和 "n" 次之间</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_long">
        <source>The {n}? quantifier matches the preceding element exactly n times, where n is any integer. It is the lazy counterpart of the greedy quantifier {n}+</source>
        <target state="translated">{n}? 限定符恰好匹配前面的元素 n 次，其中 n 是任何整数。它是贪婪限定符 {n}+ 的惰性副本</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_short">
        <source>match exactly 'n' times (lazy)</source>
        <target state="translated">刚好匹配 "n" 次(惰性)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_long">
        <source>The {n} quantifier matches the preceding element exactly n times, where n is any integer. {n} is a greedy quantifier whose lazy equivalent is {n}?</source>
        <target state="translated">{n} 限定符恰好匹配前面的元素 n 次，其中 n 是任何整数。{n} 是贪婪限定符，其惰性等效值为 {n}?</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_short">
        <source>match exactly 'n' times</source>
        <target state="translated">刚好匹配 "n" 次</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_long">
        <source>The +? quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier +</source>
        <target state="translated">+? 限定符匹配前面的元素一次或多次，但次数尽可能少。它是贪婪限定符 + 的惰性副本</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_short">
        <source>match one or more times (lazy)</source>
        <target state="translated">匹配一次或多次(惰性)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_long">
        <source>The + quantifier matches the preceding element one or more times. It is equivalent to the {1,} quantifier. + is a greedy quantifier whose lazy equivalent is +?.</source>
        <target state="translated">+ 限定符匹配前面的元素一次或多次。它等效于 {1,} 数量表示符。+ 是贪婪限定符，其惰性等效项为 +?。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_short">
        <source>match one or more times</source>
        <target state="translated">匹配一次或多次</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_long">
        <source>The *? quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier *</source>
        <target state="translated">*? 限定符匹配前导元素零次或多次，但次数尽可能少。它是贪婪限定符 * 的惰性副本</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_short">
        <source>match zero or more times (lazy)</source>
        <target state="translated">匹配零次或多次(惰性)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_long">
        <source>The * quantifier matches the preceding element zero or more times. It is equivalent to the {0,} quantifier. * is a greedy quantifier whose lazy equivalent is *?.</source>
        <target state="translated">* 限定符匹配前面的元素零次或多次。它等效于 {0,} 数量表示符。* 是贪婪限定符，其惰性等效项为 *?。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_short">
        <source>match zero or more times</source>
        <target state="translated">匹配零次或多次</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_long">
        <source>The ?? quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier ?</source>
        <target state="translated">?? 限定符匹配前面的元素零次或一次，但次数尽可能少。它是贪婪限定符 ? 的惰性副本</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_short">
        <source>match zero or one time (lazy)</source>
        <target state="translated">匹配零次或一次(惰性)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_long">
        <source>The ? quantifier matches the preceding element zero or one time. It is equivalent to the {0,1} quantifier. ? is a greedy quantifier whose lazy equivalent is ??.</source>
        <target state="translated">? 限定符匹配前面的元素零次或一次。它等效于 {0,1} 限定符。? 是贪婪限定符，其惰性等效项为 ??。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_short">
        <source>match zero or one time</source>
        <target state="translated">匹配零次或一次</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_long">
        <source>This grouping construct captures a matched 'subexpression', where 'subexpression' is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one. The capture that is numbered zero is the text matched by the entire regular expression pattern.</source>
        <target state="translated">此分组构造捕获匹配的 "subexpression"，其中 "subexpression" 是任何有效的正则表达式模式。使用括号的捕获将根据正则表达式中左括号的顺序从 1 开始按从左到右的顺序自动编号。被编号为零的捕获是由整个正则表达式模式匹配的文本。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_short">
        <source>matched subexpression</source>
        <target state="translated">匹配的子表达式</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name">
        <source>name</source>
        <target state="new">name</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name1">
        <source>name1</source>
        <target state="translated">name1</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name2">
        <source>name2</source>
        <target state="translated">name2</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name_or_number">
        <source>name-or-number</source>
        <target state="translated">名称或数字</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_long">
        <source>A named or numbered backreference.

'name' is the name of a capturing group defined in the regular expression pattern.</source>
        <target state="translated">已命名或已编号的向后引用。

"name" 是在正则表达式模式中定义的捕获组的名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_short">
        <source>named backreference</source>
        <target state="translated">已命名的向后引用</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_long">
        <source>Captures a matched subexpression and lets you access it by name or by number.

'name' is a valid group name, and 'subexpression' is any valid regular expression pattern. 'name' must not contain any punctuation characters and cannot begin with a number.

If the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the only way to capture a subexpression is to explicitly name capturing groups.</source>
        <target state="translated">捕获匹配的子表达式，以便按名称或按编号进行访问。

"name" 是有效的组名，而 "subexpression" 是任何有效的正则表达式模式。"name" 不得包含任何标点符号字符且不能以数字开头。

如果正则表达式模式匹配方法的 RegexOptions 参数包括 RegexOptions ExplicitCapture 标志，或者如果将 n 选项应用于此子表达式，则捕获子表达式的唯一方法是显式命名捕获组。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_short">
        <source>named matched subexpression</source>
        <target state="translated">已命名匹配的子表达式</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_long">
        <source>A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters are specified individually.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">负字符组指定不能出现在匹配项的输入字符串中的字符列表。字符列表是单独指定的。

可以连接两个或更多字符范围。例如，若要指定从 "0" 到 "9" 的十进制数字范围、从 "a" 到 "f" 的小写字母范围以及从 "A" 到 "F" 的大写字母范围，请使用 [0-9a-fA-F]。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_short">
        <source>negative character group</source>
        <target state="translated">负字符组</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_range_long">
        <source>A negative character range specifies a list of characters that must not appear in an input string for a match to occur. 'firstCharacter' is the character that begins the range, and 'lastCharacter' is the character that ends the range.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">负字符范围指定不能出现在输入字符串中的字符列表，以使匹配发生。"firstCharacter" 是该范围的开始字符，而 "lastCharacter" 是该范围的结束字符。

可以连接两个或更多字符范围。例如，若要指定从 "0" 到 "9" 的十进制数字范围、从 "a" 到 "f" 的小写字母范围以及从 "A" 到 "F" 的大写字母范围，请使用 [0-9a-fA-F]。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_range_short">
        <source>negative character range</source>
        <target state="translated">负字符范围</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_long">
        <source>The regular expression construct \P{ name } matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">正则表达式构造 \P{name} 匹配不属于 Unicode 通用类别或命名块的任何字符，其中 "name" 是类别缩写或命名块名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_short">
        <source>negative unicode category</source>
        <target state="translated">负 unicode 类别</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_long">
        <source>Matches a new-line character, \u000A</source>
        <target state="translated">与换行符(\u000A)匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_short">
        <source>new-line character</source>
        <target state="translated">换行符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_no">
        <source>no</source>
        <target state="new">no</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_long">
        <source>\D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.

If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9]</source>
        <target state="translated">\D 与任何非数字字符匹配。它等效于 \P{Nd} 正则表达式模式。

如果指定了符合 ECMAScript 的行为，则 \P 等效于 [^0-9]</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_short">
        <source>non-digit character</source>
        <target state="translated">非数字字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_long">
        <source>\S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.

If ECMAScript-compliant behavior is specified, \S is equivalent to [^ \f\n\r\t\v]</source>
        <target state="translated">\S 与任何非空格字符匹配。它等效于 [^\f\n\r\t\v\x85\p{Z}] 正则表达式模式，或与等效于 \s 的正则表达式模式(与空格字符匹配)的相反形式。

如果指定了符合 ECMAScript 的行为，则 \s 等效于 [^ \f\n\r\t\v]</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_short">
        <source>non-white-space character</source>
        <target state="translated">非空格字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_long">
        <source>The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor.</source>
        <target state="translated">\B 定位点指定匹配不得出现在字边界上。它与 \b 定位点相反。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_short">
        <source>non-word boundary</source>
        <target state="translated">非字边界</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_character_long">
        <source>\W matches any non-word character. It matches any character except for those in the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \W is equivalent to [^a-zA-Z_0-9]</source>
        <target state="translated">\w 与任何非字词字符匹配。它匹配除以下 Unicode 类别中的任何字符:

    Ll	字母，小写
    Lu 	字母，大写
    Lt	字母，首字母大写
    Lo	字母，其他
    Lm	字母，修饰符
    Mn	标记，非间距
    Nd	数字，十进制数字
    Pc	标点，连接符

如果指定了符合 ECMAScript 的行为，则 \W 等效于 [^a-zA-Z_0-9]</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized. </note>
      </trans-unit>
      <trans-unit id="Regex_non_word_character_short">
        <source>non-word character</source>
        <target state="translated">非字词字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_long">
        <source>This construct does not capture the substring that is matched by a subexpression:

The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.

If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
        <target state="translated">此构造不捕获由子表达式匹配的子字符串:

在将限定符应用于组时，通常使用非捕获组构造，但组捕获的子字符串不具有任何意义。

如果正则表达式包含嵌套的分组构造，则外部非捕获组构造不适用于内部嵌套的组构造。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_short">
        <source>noncapturing group</source>
        <target state="translated">非捕获组</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_decimal_digit">
        <source>number, decimal digit</source>
        <target state="translated">数字，十进制数字</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_letter">
        <source>number, letter</source>
        <target state="translated">数字，字母</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_other">
        <source>number, other</source>
        <target state="translated">数字，其他</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_long">
        <source>A numbered backreference, where 'number' is the ordinal position of the capturing group in the regular expression. For example, \4 matches the contents of the fourth capturing group.

There is an ambiguity between octal escape codes (such as \16) and \number backreferences that use the same notation. If the ambiguity is a problem, you can use the \k&lt;name&gt; notation, which is unambiguous and cannot be confused with octal character codes. Similarly, hexadecimal codes such as \xdd are unambiguous and cannot be confused with backreferences.</source>
        <target state="translated">一个带编号的向后引用，其中 "number" 是正则表达式中捕获组的序号位置。例如，\4 与第四个捕获组的内容匹配。

八进制转义码(例如 \16) 和使用相同表示法的 \number 向后引用之间存在二义性。如果多义性是一个问题，则可以使用 \k&lt;name&gt; 表示法，该符号是明确的，不能与八进制字符代码混淆。同样，十六进制代码(如 \xdd)是明确的，不能与向后引用混淆。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_short">
        <source>numbered backreference</source>
        <target state="translated">带编号的向后引用</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_control">
        <source>other, control</source>
        <target state="translated">其他，控件</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_format">
        <source>other, format</source>
        <target state="translated">其他，格式</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_not_assigned">
        <source>other, not assigned</source>
        <target state="translated">其他，未分配</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_private_use">
        <source>other, private use</source>
        <target state="translated">其他，专用</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_surrogate">
        <source>other, surrogate</source>
        <target state="translated">其他，代理项</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_long">
        <source>A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur.</source>
        <target state="translated">正字符组指定字符列表，其中的任何一个字符都可能出现在输入字符串中，以使匹配发生。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_short">
        <source>positive character group</source>
        <target state="translated">正字符组</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_long">
        <source>A positive character range specifies a range of characters, any one of which may appear in an input string for a match to occur.  'firstCharacter' is the character that begins the range and 'lastCharacter' is the character that ends the range. </source>
        <target state="translated">正字符范围指定一个字符范围，其中的任何一个字符都可能出现在输入字符串中，以使匹配发生。 "firstCharacter" 是该范围的起始字符，而 "lastCharacter" 是该范围的结束字符。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_short">
        <source>positive character range</source>
        <target state="translated">正字符范围</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_close">
        <source>punctuation, close</source>
        <target state="translated">标点，结束</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_connector">
        <source>punctuation, connector</source>
        <target state="translated">标点，连接符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_dash">
        <source>punctuation, dash</source>
        <target state="translated">标点，短划线</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_final_quote">
        <source>punctuation, final quote</source>
        <target state="translated">标点，右引号</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_initial_quote">
        <source>punctuation, initial quote</source>
        <target state="translated">标点，左引号</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_open">
        <source>punctuation, open</source>
        <target state="translated">标点，开始</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_other">
        <source>punctuation, other</source>
        <target state="translated">标点，其他</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_line">
        <source>separator, line</source>
        <target state="translated">分隔符，行</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_paragraph">
        <source>separator, paragraph</source>
        <target state="translated">分隔符，段落</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_space">
        <source>separator, space</source>
        <target state="translated">分隔符，空格</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_long">
        <source>The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input string.</source>
        <target state="translated">\A 定位点指定匹配必须出现在输入字符串的开头。它与 ^ 定位点相同，只不过 \A 忽略了 RegexOptions 选项。因此，它只能匹配多行输入字符串中第一行的开头。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_short">
        <source>start of string only</source>
        <target state="translated">仅字符串的开头</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_long">
        <source>The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.</source>
        <target state="translated">^ 定位点指定以下模式必须从字符串的第一个字符位置开始。如果使用 ^ 和 RegexOptions 选项，则匹配必须出现在每行的开头。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_short">
        <source>start of string or line</source>
        <target state="translated">字符串或行的开头</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_subexpression">
        <source>subexpression</source>
        <target state="translated">子表达式</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_currency">
        <source>symbol, currency</source>
        <target state="translated">符号，货币</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_math">
        <source>symbol, math</source>
        <target state="translated">符号，数学</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_modifier">
        <source>symbol, modifier</source>
        <target state="translated">符号，修饰符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_other">
        <source>symbol, other</source>
        <target state="translated">符号，其他</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_long">
        <source>Matches a tab character, \u0009</source>
        <target state="translated">与制表符(\u0009)匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_short">
        <source>tab character</source>
        <target state="translated">制表符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_long">
        <source>The regular expression construct \p{ name } matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">正则表达式构造 \p{name} 匹配属于 Unicode 通用类别或命名块的任何字符，其中 "name" 是类别缩写或命名块名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_short">
        <source>unicode category</source>
        <target state="translated">Unicode 类别</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_long">
        <source>Matches a UTF-16 code unit whose value is #### hexadecimal.</source>
        <target state="translated">与值为 ####十六进制的 utf-16 代码单元匹配。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_short">
        <source>unicode escape</source>
        <target state="translated">Unicode 转义</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_general_category_0">
        <source>Unicode General Category: {0}</source>
        <target state="translated">Unicode 通用类别: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_long">
        <source>Matches a vertical-tab character, \u000B</source>
        <target state="translated">与垂直制表符(\u000B)匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_short">
        <source>vertical-tab character</source>
        <target state="translated">垂直制表符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_long">
        <source>\s matches any white-space character. It is equivalent to the following escape sequences and Unicode categories:

    \f	The form feed character, \u000C
    \n	The newline character, \u000A
    \r	The carriage return character, \u000D
    \t	The tab character, \u0009
    \v	The vertical tab character, \u000B
    \x85	The ellipsis or NEXT LINE (NEL) character (…), \u0085
    \p{Z}	Matches any separator character

If ECMAScript-compliant behavior is specified, \s is equivalent to [ \f\n\r\t\v]</source>
        <target state="translated">\s 与任何空格字符匹配。它等效于以下转义序列和 Unicode 类别:

    \f	换页符 \u000C
    \n	换行符 \u000A
    \rr	回车符 \u000D
    \t	制表符 \u0009
    \v	垂直制表符 \u000B
    \x85	省略号或下一行(NEL)字符(…) \u0085
    \p{Z}	匹配任何分隔符字符

如果指定了符合 ECMAScript 的行为，则 \s 等效于 [ \f\n\r\t\v]</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_short">
        <source>white-space character</source>
        <target state="translated">空格字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_long">
        <source>The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore. The match may also occur on a word boundary at the beginning or end of the string.

The \b anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
        <target state="translated">\b 定位点指定匹配必须出现在字词字符(\w 语言元素)和非字词字符(\w 语言元素)之间的边界上。字词字符由字母数字字符和下划线组成；非字词字符是任何不是字母数字或下划线的字符。匹配也可能出现在字符串开头或结尾的字边界上。

\b 定位点经常用于确保子表达式匹配整个字而不只是匹配字的开头或结尾。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_short">
        <source>word boundary</source>
        <target state="translated">字边界</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_character_long">
        <source>\w matches any word character. A word character is a member of any of the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \w is equivalent to [a-zA-Z_0-9]</source>
        <target state="translated">\w 匹配任何字词字符。字词字符是以下任何 Unicode 类别中的成员之一:

    Ll	字母，小写
    Lu	字母，大写
    Lt	字母，首字母大写
    Lo	字母，其他
    Lm	字母，修饰符
    Mn	标记，非间距
    Nd	数字，十进制数字
    Pc	标点，连接符

如果指定了符合 ECMAScript 的行为，则 \w 等效于 [a-zA-Z_0-9]</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized.</note>
      </trans-unit>
      <trans-unit id="Regex_word_character_short">
        <source>word character</source>
        <target state="translated">字词字符</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_yes">
        <source>yes</source>
        <target state="new">yes</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_long">
        <source>A zero-width negative lookahead assertion, where for the match to be successful, the input string must not match the regular expression pattern in subexpression. The matched string is not included in the match result.

A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression. At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched. In this case, it is often used to limit backtracking. At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
        <target state="translated">零宽负向先行断言(即要成功匹配)，输入字符串不得与子表达式中的正则表达式模式匹配。匹配的字符串未包含在匹配结果中。

零宽负向先行断言通常在正则表达式的开头或结尾使用。在正则表达式的开头，它可以定义一个特定模式，当正则表达式的开头定义类似但更多个要匹配的常规模式时，不应匹配该模式。在这种情况下，它通常用于限制回溯。在正则表达式的末尾，它可以定义无法在匹配结束时出现的子表达式。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_short">
        <source>zero-width negative lookahead assertion</source>
        <target state="translated">零宽负向先行断言</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_long">
        <source>A zero-width negative lookbehind assertion, where for a match to be successful, 'subexpression' must not occur at the input string to the left of the current position. Any substring that does not match 'subexpression' is not included in the match result.

Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define precludes a match in the string that follows. They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</source>
        <target state="translated">零宽负向后行断言(即要成功匹配)，不得在输入字符串的当前位置左侧出现 "subexpression"。与 "subexpression" 不匹配的任何子字符串都不包含在匹配结果中。

零宽负向后行断言通常在正则表达式开头使用。它们定义的模式在后面的字符串中排除匹配。当捕获组中的最后一个字符不能是与该组的正则表达式模式匹配的一个或多个字符时，它们也用于限制回溯。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_short">
        <source>zero-width negative lookbehind assertion</source>
        <target state="translated">零宽负向后行断言</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_long">
        <source>A zero-width positive lookahead assertion, where for a match to be successful, the input string must match the regular expression pattern in 'subexpression'. The matched substring is not included in the match result. A zero-width positive lookahead assertion does not backtrack.

Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern. It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match. It is also useful for preventing excessive backtracking. You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</source>
        <target state="translated">零宽正向先行断言(即要成功匹配)，输入字符串必须与 "subexpression" 中的正则表达式模式匹配。匹配结果中不包括匹配的子字符串。零宽正向先行断言不回溯。

零宽正向先行断言通常出现在正则表达式模式的末尾。它定义一个子字符串，该字符串必须位于字符串的末尾(以便匹配发生)但不应包含在匹配中。它对于防止过度回溯也很有用。可以使用零宽正向先行断言来确保特定捕获的组以与为捕获的组定义的模式的子集匹配的文本开头。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_short">
        <source>zero-width positive lookahead assertion</source>
        <target state="translated">零宽正向先行断言</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_long">
        <source>A zero-width positive lookbehind assertion, where for a match to be successful, 'subexpression' must occur at the input string to the left of the current position. 'subexpression' is not included in the match result. A zero-width positive lookbehind assertion does not backtrack.

Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
        <target state="translated">零宽正向后行断言(即要成功匹配)，"subexpression" 必须出现在输入字符串的当前位置左侧。匹配结果中不包含 "subexpression"。零宽正向后行断言不会回溯。

零宽正向后行断言通常在正则表达式开头使用。它们定义的模式是匹配项的前提条件，尽管它不是匹配结果的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_short">
        <source>zero-width positive lookbehind assertion</source>
        <target state="translated">零宽正向后行断言</target>
        <note />
      </trans-unit>
      <trans-unit id="Related_method_signatures_found_in_metadata_will_not_be_updated">
        <source>Related method signatures found in metadata will not be updated.</source>
        <target state="translated">不更新在元数据中发现的相关方法签名。</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_async_modifier">
        <source>Remove 'async' modifier</source>
        <target state="translated">删除 "async" 修饰符</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_1">
        <source>Replace '{0}' with '{1}' </source>
        <target state="translated">将 "{0}" 替换为 "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Resolve_conflict_markers">
        <source>Resolve conflict markers</source>
        <target state="translated">解决冲突标记</target>
        <note />
      </trans-unit>
      <trans-unit id="RudeEdit">
        <source>Rude edit</source>
        <target state="translated">原始编辑</target>
        <note />
      </trans-unit>
      <trans-unit id="Split_into_consecutive_0_statements">
        <source>Split into consecutive '{0}' statements</source>
        <target state="translated">拆分为连续的 "{0}" 语句</target>
        <note />
      </trans-unit>
      <trans-unit id="Split_into_nested_0_statements">
        <source>Split into nested '{0}' statements</source>
        <target state="translated">拆分为嵌套的 "{0}" 语句</target>
        <note />
      </trans-unit>
      <trans-unit id="StreamMustSupportReadAndSeek">
        <source>Stream must support read and seek operations.</source>
        <target state="translated">流必须支持读取和搜寻操作。</target>
        <note />
      </trans-unit>
      <trans-unit id="Suppress_0">
        <source>Suppress {0}</source>
        <target state="translated">取消 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="TODO_colon_free_unmanaged_resources_unmanaged_objects_and_override_finalizer">
        <source>TODO: free unmanaged resources (unmanaged objects) and override finalizer</source>
        <target state="translated">TODO: 释放未托管的资源(未托管的对象)并替代终结器</target>
        <note />
      </trans-unit>
      <trans-unit id="TODO_colon_override_finalizer_only_if_0_has_code_to_free_unmanaged_resources">
        <source>TODO: override finalizer only if '{0}' has code to free unmanaged resources</source>
        <target state="translated">TODO: 仅当“{0}”拥有用于释放未托管资源的代码时才替代终结器</target>
        <note />
      </trans-unit>
      <trans-unit id="Target_type_matches">
        <source>Target type matches</source>
        <target state="translated">目标类型匹配</target>
        <note />
      </trans-unit>
      <trans-unit id="The_selection_contains_a_local_function_call_without_its_declaration">
        <source>The selection contains a local function call without its declaration.</source>
        <target state="translated">所选内容包含不带声明的本地函数调用。</target>
        <note />
      </trans-unit>
      <trans-unit id="Too_many_bars_in_conditional_grouping">
        <source>Too many | in (?()|)</source>
        <target state="translated">(?()|) 中的 | 太多</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0)a|b|)</note>
      </trans-unit>
      <trans-unit id="Too_many_close_parens">
        <source>Too many )'s</source>
        <target state="translated">")" 太多</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: )</note>
      </trans-unit>
      <trans-unit id="UnableToReadSourceFileOrPdb">
        <source>Unable to read source file '{0}' or the PDB built for the containing project. Any changes made to this file while debugging won't be applied until its content matches the built source.</source>
        <target state="translated">无法读取源文件 "{0}" 或为包含项目生成的 PDB。在调试期间对此文件所做的任何更改都不会应用，直到其内容与生成的源匹配为止。</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_property">
        <source>Unknown property</source>
        <target state="translated">未知属性</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{}</note>
      </trans-unit>
      <trans-unit id="Unknown_property_0">
        <source>Unknown property '{0}'</source>
        <target state="translated">未知属性“{0}”</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{xxx}. Here, {0} will be the name of the unknown property ('xxx')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_control_character">
        <source>Unrecognized control character</source>
        <target state="translated">无法识别的控制字符</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [\c]</note>
      </trans-unit>
      <trans-unit id="Unrecognized_escape_sequence_0">
        <source>Unrecognized escape sequence \{0}</source>
        <target state="translated">无法识别的转义序列 \{0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \m. Here, {0} will be the unrecognized character ('m')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_grouping_construct">
        <source>Unrecognized grouping construct</source>
        <target state="translated">无法识别的分组构造</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;</note>
      </trans-unit>
      <trans-unit id="Unterminated_character_class_set">
        <source>Unterminated [] set</source>
        <target state="translated">[] 集未关闭</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [</note>
      </trans-unit>
      <trans-unit id="Unterminated_regex_comment">
        <source>Unterminated (?#...) comment</source>
        <target state="translated">(?#...) 注释未关闭</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?#</note>
      </trans-unit>
      <trans-unit id="Unwrap_all_arguments">
        <source>Unwrap all arguments</source>
        <target state="translated">展开所有参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_all_parameters">
        <source>Unwrap all parameters</source>
        <target state="translated">展开打开所有参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_and_indent_all_arguments">
        <source>Unwrap and indent all arguments</source>
        <target state="translated">展开和缩进所有参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_and_indent_all_parameters">
        <source>Unwrap and indent all parameters</source>
        <target state="translated">展开和缩进所有参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_argument_list">
        <source>Unwrap argument list</source>
        <target state="translated">展开参数列表</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_call_chain">
        <source>Unwrap call chain</source>
        <target state="translated">展开调用链</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_expression">
        <source>Unwrap expression</source>
        <target state="translated">展开表达式</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_parameter_list">
        <source>Unwrap parameter list</source>
        <target state="translated">展开参数列表</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_a_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Updating a '{0}' around an active statement will prevent the debug session from continuing.</source>
        <target state="translated">更新活动语句周围的“{0}”将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="UseRecommendedDisposePatternDescription">
        <source>Use recommended dispose pattern to ensure that locally scoped disposable objects are disposed on all paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transferred to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'</source>
        <target state="translated">使用推荐的释放模式以确保在所有路径中释放局部可释放对象。如果可能，请将创建包装在 "using" 语句或 "using" 声明中。否则，请使用 try-finally 模式，在 try 区域之前声明一个专用的局部变量，在 "finally" 区域中对非 null 值进行无条件 Dispose 调用，比如，"x?.Dispose()"。如果对象显式释放在 try 区域内或释放所有权转让给另一个对象或方法，则在这样的操作之后立即将 "null" 分配给局部变量，以防止在 "finally" 中进行双重释放。</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_block_body_for_lambda_expressions">
        <source>Use block body for lambda expressions</source>
        <target state="translated">对 lambda 表达式使用块主体</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_expression_body_for_lambda_expressions">
        <source>Use expression body for lambda expressions</source>
        <target state="translated">对 lambda 表达式使用表达式正文</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_interpolated_verbatim_string">
        <source>Use interpolated verbatim string</source>
        <target state="translated">使用内插的逐字字符串</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_recommended_dispose_pattern">
        <source>Use recommended dispose pattern</source>
        <target state="translated">使用建议的释放模式</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_recommended_dispose_pattern_to_ensure_that_object_created_by_0_is_disposed_on_all_paths_using_statement_declaration_or_try_finally">
        <source>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all paths: using statement/declaration or try/finally</source>
        <target state="translated">使用建议的释放模式以确保在所有路径上释放由 "{0}" 创建的对象: using 语句/声明或 try/finally</target>
        <note>{Locked="using"}{Locked="try"}{Locked="finally"} "using", "try" and "finally" are C# keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Value_colon">
        <source>Value:</source>
        <target state="translated">值:</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_changing_namespace_may_produce_invalid_code_and_change_code_meaning">
        <source>Warning: Changing namespace may produce invalid code and change code meaning.</source>
        <target state="translated">警告: 更改命名空间可能会产生无效的代码并更改代码的含义。</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_semantics_may_change_when_converting_statement">
        <source>Warning: Semantics may change when converting statement.</source>
        <target state="translated">警告: 转换语句时，语义可能出现变化。</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_and_align_call_chain">
        <source>Wrap and align call chain</source>
        <target state="translated">包装并对齐调用链</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_and_align_expression">
        <source>Wrap and align expression</source>
        <target state="translated">环绕和对齐表达式</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_and_align_long_call_chain">
        <source>Wrap and align long call chain</source>
        <target state="translated">包装并对齐长调用链</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_call_chain">
        <source>Wrap call chain</source>
        <target state="translated">包装调用链</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_every_argument">
        <source>Wrap every argument</source>
        <target state="translated">包装每个参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_every_parameter">
        <source>Wrap every parameter</source>
        <target state="translated">包装每个参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_expression">
        <source>Wrap expression</source>
        <target state="translated">包装表达式</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_argument_list">
        <source>Wrap long argument list</source>
        <target state="translated">包装长参数列表</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_call_chain">
        <source>Wrap long call chain</source>
        <target state="translated">包装长调用链</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_parameter_list">
        <source>Wrap long parameter list</source>
        <target state="translated">包装长参数列表</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrapping">
        <source>Wrapping</source>
        <target state="translated">换行</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_cannot_be_null_or_empty">
        <source>'{0}' cannot be null or empty.</source>
        <target state="needs-review-translation">“{0}”不能是 Null 或为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_cannot_be_null_or_whitespace">
        <source>'{0}' cannot be null or whitespace.</source>
        <target state="needs-review-translation">“{0}”不能为 Null 或空白。</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_null_here">
        <source>'{0}' is not null here.</source>
        <target state="new">'{0}' is not null here.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_may_be_null_here">
        <source>'{0}' may be null here.</source>
        <target state="new">'{0}' may be null here.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second">
        <source>10,000,000ths of a second</source>
        <target state="translated">千万分之一秒</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second_description">
        <source>The "fffffff" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value.

Although it's possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"fffffff" 自定义格式说明符表示秒部分的七个最高有效位；即在日期和时间值中表示千万分之一秒数。

虽然时间值的秒部分可以显示到千万分之一秒，但该值可能没有意义。日期和时间值的精度取决于系统时钟的分辨率。在 Windows NT 3.5 (及更高版本)和 Windows Vista 操作系统上，时钟的分辨率大约为 10-15 毫秒。</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second_non_zero">
        <source>10,000,000ths of a second (non-zero)</source>
        <target state="translated">千万分之一秒(非零)</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second_non_zero_description">
        <source>The "FFFFFFF" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value. However, trailing zeros or seven zero digits aren't displayed.

Although it's possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"FFFFFFF" 自定义格式说明符表示秒部分的七个最高有效位；即在日期和时间值中表示千万分之一秒数。但不显示尾随零或七个零位。

虽然时间值的秒部分可以显示到千万分之一秒，但该值可能没有意义。日期和时间值的精度取决于系统时钟的分辨率。在 Windows NT 3.5 (及更高版本)和 Windows Vista 操作系统上，时钟的分辨率大约为 10-15 毫秒。</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second">
        <source>1,000,000ths of a second</source>
        <target state="translated">百万分之一秒</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second_description">
        <source>The "ffffff" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value.

Although it's possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"ffffff" 自定义格式说明符表示秒部分的六个最高有效位；即在日期和时间值中表示百万分之一秒数。

虽然时间值的秒部分可以显示到百万分之一秒，但该值可能没有意义。日期和时间值的精度取决于系统时钟的分辨率。在 Windows NT 3.5 (及更高版本)和 Windows Vista 操作系统上，时钟的分辨率大约为 10-15 毫秒。</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second_non_zero">
        <source>1,000,000ths of a second (non-zero)</source>
        <target state="translated">百万分之一秒(非零)</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second_non_zero_description">
        <source>The "FFFFFF" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value. However, trailing zeros or six zero digits aren't displayed.

Although it's possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"FFFFFF" 自定义格式说明符表示秒部分的六个最高有效位；即在日期和时间值中表示百万分之一秒数。但不显示尾随零或六个零位。

虽然时间值的秒部分可以显示到百万分之一秒，但该值可能没有意义。日期和时间值的精度取决于系统时钟的分辨率。在 Windows NT 3.5 (及更高版本)和 Windows Vista 操作系统上，时钟的分辨率大约为 10-15 毫秒。</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second">
        <source>100,000ths of a second</source>
        <target state="translated">十万分之一秒</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second_description">
        <source>The "fffff" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value.

Although it's possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"fffff" 自定义格式说明符表示秒部分的五个最高有效位；即在日期和时间值中表示十万分之一秒数。

虽然时间值的秒部分可以显示到十万分之一秒，但该值可能没有意义。日期和时间值的精度取决于系统时钟的分辨率。在 Windows NT 3.5 (及更高版本)和 Windows Vista 操作系统上，时钟的分辨率大约为 10-15 毫秒。</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second_non_zero">
        <source>100,000ths of a second (non-zero)</source>
        <target state="translated">十万分之一秒(非零)</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second_non_zero_description">
        <source>The "FFFFF" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value. However, trailing zeros or five zero digits aren't displayed.

Although it's possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"FFFFF" 自定义格式说明符表示秒部分的五个最高有效位；即在日期和时间值中表示十万分之一秒数。但是，不显示尾随零或五个零位。

虽然时间值的秒部分可以显示到十万分之一秒，但该值可能没有意义。日期和时间值的精度取决于系统时钟的分辨率。在 Windows NT 3.5 (及更高版本)和 Windows Vista 操作系统上，时钟的分辨率大约为 10-15 毫秒。</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second">
        <source>10,000ths of a second</source>
        <target state="translated">万分之一秒</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second_description">
        <source>The "ffff" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value.

Although it's possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT version 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"ffff" 自定义格式说明符表示秒部分的四个最高有效位；即在日期和时间值中表示万分之一秒数。

虽然时间值的秒部分可以显示到万分之一秒，但该值可能没有意义。日期和时间值的精度取决于系统时钟的分辨率。在 Windows NT 3.5 (及更高版本)和 Windows Vista 操作系统上，时钟的分辨率大约为 10-15 毫秒。</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second_non_zero">
        <source>10,000ths of a second (non-zero)</source>
        <target state="translated">万分之一秒(非零)</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second_non_zero_description">
        <source>The "FFFF" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value. However, trailing zeros or four zero digits aren't displayed.

Although it's possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"FFFF" 自定义格式说明符表示秒部分的四个最高有效位；即在日期和时间值中表示万分之一秒数。但是，不显示尾随零或四个零位。

虽然时间值的秒部分可以显示到万分之一秒，但该值可能没有意义。日期和时间值的精度取决于系统时钟的分辨率。在 Windows NT 3.5 (及更高版本)和 Windows Vista 操作系统上，时钟的分辨率大约为 10-15 毫秒。</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second">
        <source>1,000ths of a second</source>
        <target state="translated">千分之一秒</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second_description">
        <source>The "fff" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value.</source>
        <target state="translated">"fff" 自定义格式说明符表示秒部分的三个最高有效位；即表示日期和时间值中的毫秒。</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second_non_zero">
        <source>1,000ths of a second (non-zero)</source>
        <target state="translated">千分之一秒(非零)</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second_non_zero_description">
        <source>The "FFF" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value. However, trailing zeros or three zero digits aren't displayed.</source>
        <target state="translated">"FFF" 自定义格式说明符表示秒部分的三个最高有效位；即表示日期和时间值中的毫秒。但不显示尾随零或三个零位。</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second">
        <source>100ths of a second</source>
        <target state="translated">百分之一秒</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second_description">
        <source>The "ff" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value.</source>
        <target state="translated">"ff" 自定义格式说明符表示秒部分的两个最高有效位；即在日期和时间值中表示百分之一秒数。</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second_non_zero">
        <source>100ths of a second (non-zero)</source>
        <target state="translated">百分之一秒(非零)</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second_non_zero_description">
        <source>The "FF" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value. However, trailing zeros or two zero digits aren't displayed.</source>
        <target state="translated">"FF" 自定义格式说明符表示秒部分的两个最高有效位；即在日期和时间值中表示百分之一秒数。但不显示尾随零或两个零位。</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second">
        <source>10ths of a second</source>
        <target state="translated">十分之一秒</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second_description">
        <source>The "f" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value.

If the "f" format specifier is used without other format specifiers, it's interpreted as the "f" standard date and time format specifier.

When you use "f" format specifiers as part of a format string supplied to the ParseExact, TryParseExact, ParseExact, or TryParseExact method, the number of "f" format specifiers indicates the number of most significant digits of the seconds fraction that must be present to successfully parse the string.</source>
        <target state="translated">"f" 自定义格式说明符表示秒部分的最高有效位；即表示日期和时间值中的十分之一秒数。

如果使用 "f" 格式说明符而没有其他自定义格式说明符，该说明符将被解释为 "f" 标准日期和时间格式说明符。

将 "f" 格式说明符用作提供给 ParseExact、TryParseExact、ParseExact 或 TryParseExact 方法的格式字符串的一部分时，"f" 格式说明符的数目指示能够成功分析的字符串的秒部分的最高有效位的最大数目。</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second_non_zero">
        <source>10ths of a second (non-zero)</source>
        <target state="translated">十分之一秒(非零)</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second_non_zero_description">
        <source>The "F" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value. Nothing is displayed if the digit is zero.

If the "F" format specifier is used without other format specifiers, it's interpreted as the "F" standard date and time format specifier.

The number of "F" format specifiers used with the ParseExact, TryParseExact, ParseExact, or TryParseExact method indicates the maximum number of most significant digits of the seconds fraction that can be present to successfully parse the string.</source>
        <target state="translated">"F" 自定义格式说明符表示秒部分的最高有效位；即在日期和时间值中表示十分之一秒数。如果数字为零，则不显示任何内容。

如果使用 "F" 格式说明符而没有其他自定义格式说明符，则该说明符将被解释为 "F" 标准日期和时间格式说明符。

ParseExact、TryParseExact、ParseExact 或 TryParseExact 方法中的 "F" 格式说明符的数目指示能够成功分析的字符串的秒部分的最高有效位的最大数目。</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_1_2_digits">
        <source>12 hour clock (1-2 digits)</source>
        <target state="translated">12 小时制(1-2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_1_2_digits_description">
        <source>The "h" custom format specifier represents the hour as a number from 1 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour after midnight is indistinguishable from the same hour after noon. The hour is not rounded, and a single-digit hour is formatted without a leading zero. For example, given a time of 5:43 in the morning or afternoon, this custom format specifier displays "5".

If the "h" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">"h" 自定义格式说明符将小时表示为从 1 到 12 的数字；即通过 12 小时制表示小时，自午夜或中午开始对整小时计数。因此，午夜后经过的某特定小时数与中午过后的相同小时数无法加以区分。小时数不进行舍入，一位数字的小时数设置为不带前导零的格式。例如，给定上午或下午时间为 5:43，则此自定义格式说明符显示为 "5"。

如果使用 "h" 格式说明符而没有其他自定义格式说明符，该说明符将被解释为标准日期和时间格式说明符，并引发 FormatException。</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_2_digits">
        <source>12 hour clock (2 digits)</source>
        <target state="translated">12 小时制(2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_2_digits_description">
        <source>The "hh" custom format specifier (plus any number of additional "h" specifiers) represents the hour as a number from 01 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour after midnight is indistinguishable from the same hour after noon. The hour is not rounded, and a single-digit hour is formatted with a leading zero. For example, given a time of 5:43 in the morning or afternoon, this format specifier displays "05".</source>
        <target state="translated">"hh" 自定义格式说明符(另加任意数量的其他 "h" 说明符)将小时表示为从 01 到 12 的数字；即通过 12 小时制表示小时，因此，午夜后经过的某特定小时数与中午过后的相同小时数无法加以区分。小时数不进行舍入，一位数字的小时数设置为带前导零的格式。例如，给定上午或下午时间为 5:43，则此格式说明符显示为 "05"。</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_1_2_digits">
        <source>24 hour clock (1-2 digits)</source>
        <target state="translated">24 小时制(1-2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_1_2_digits_description">
        <source>The "H" custom format specifier represents the hour as a number from 0 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is formatted without a leading zero.

If the "H" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">"H" 自定义格式说明符将小时表示为从 0 至 23 的数字，即通过从零开始的 24 小时制表示小时，自午夜开始对小时计数。一位数字的小时数设置为不带前导零的格式。

如果使用 "H" 格式说明符而没有其他自定义格式说明符，该说明符将被解释为标准日期和时间格式说明符，并引发 FormatException。</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_2_digits">
        <source>24 hour clock (2 digits)</source>
        <target state="translated">24 小时制(2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_2_digits_description">
        <source>The "HH" custom format specifier (plus any number of additional "H" specifiers) represents the hour as a number from 00 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is formatted with a leading zero.</source>
        <target state="translated">"HH" 自定义格式说明符(另加任意数量的 "H" 说明符)将小时表示为从 00 至 23 的数字，即通过从零开始的 24 小时制表示小时，自午夜开始对小时计数。一位数字的小时数设置为带前导零的格式。</target>
        <note />
      </trans-unit>
      <trans-unit id="date_separator">
        <source>date separator</source>
        <target state="translated">日期分隔符</target>
        <note />
      </trans-unit>
      <trans-unit id="date_separator_description">
        <source>The "/" custom format specifier represents the date separator, which is used to differentiate years, months, and days. The appropriate localized date separator is retrieved from the DateTimeFormatInfo.DateSeparator property of the current or specified culture.

Note: To change the date separator for a particular date and time string, specify the separator character within a literal string delimiter. For example, the custom format string mm'/'dd'/'yyyy produces a result string in which "/" is always used as the date separator. To change the date separator for all dates for a culture, either change the value of the DateTimeFormatInfo.DateSeparator property of the current culture, or instantiate a DateTimeFormatInfo object, assign the character to its DateSeparator property, and call an overload of the formatting method that includes an IFormatProvider parameter.

If the "/" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">"/" 自定义格式说明符表示用于区分年、月和日的日期分隔符。可从当前或指定区域性的 DateTimeFormatInfo.DateSeparator 属性中检索适当的本地化日期分隔符。

注意: 若要更改特定日期和时间字符串的日期分隔符，需要在文本字符串分隔符中指定分隔符字符。例如，自定义格式字符串 mm'/'dd'/'yyyy 会生成一个结果字符串，其中 "/" 始终用作日期分隔符。若要更改某个区域性的所有日期的日期分隔符，请更改当前区域性的 DateTimeFormatInfo.DateSeparator 属性的值，或者实例化 DateTimeFormatInfo 对象，并将该字符分配给它的 DateSeparator 属性，然后调用包含 IFormatProvider 参数的格式设置方法的重载。

如果使用 "/" 格式说明符而没有其他自定义格式说明符，则该说明符将被解释为标准日期和时间格式说明符，并引发 FormatException。</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_1_2_digits">
        <source>day of the month (1-2 digits)</source>
        <target state="translated">一月中某天(1-2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_1_2_digits_description">
        <source>The "d" custom format specifier represents the day of the month as a number from 1 through 31. A single-digit day is formatted without a leading zero.

If the "d" format specifier is used without other custom format specifiers, it's interpreted as the "d" standard date and time format specifier.</source>
        <target state="translated">"d" 自定义格式说明符将一月中某天表示为从 1 至 31 的数字。一位数字的日期设置为不带前导零的格式。

如果使用 "d" 格式说明符而没有其他自定义格式说明符，则该说明符将被解释为 "d" 标准日期和时间格式说明符。</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_2_digits">
        <source>day of the month (2 digits)</source>
        <target state="translated">一月中某天(2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_2_digits_description">
        <source>The "dd" custom format string represents the day of the month as a number from 01 through 31. A single-digit day is formatted with a leading zero.</source>
        <target state="translated">"dd" 自定义格式字符串将将一月中某天表示为从 01 至 31 的数字。一位数字的日期设置为带前导零的格式。</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_abbreviated">
        <source>day of the week (abbreviated)</source>
        <target state="translated">一周中某天(缩写)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_abbreviated_description">
        <source>The "ddd" custom format specifier represents the abbreviated name of the day of the week. The localized abbreviated name of the day of the week is retrieved from the DateTimeFormatInfo.AbbreviatedDayNames property of the current or specified culture.</source>
        <target state="translated">"ddd" 自定义格式说明符表示一周中某天的缩写名称。可从当前或指定区域性的 DateTimeFormatInfo.AbbreviatedDayNames 属性中检索一周中某天的本地化缩写名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_full">
        <source>day of the week (full)</source>
        <target state="translated">一周中某天(完整)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_full_description">
        <source>The "dddd" custom format specifier (plus any number of additional "d" specifiers) represents the full name of the day of the week. The localized name of the day of the week is retrieved from the DateTimeFormatInfo.DayNames property of the current or specified culture.</source>
        <target state="translated">"dddd" 自定义格式说明符(另加任意数量的其他 "d" 说明符)表示一周中某天的完整名称。可从当前或指定区域性的 DateTimeFormatInfo.DayNames 属性中检索一周中某天的本地化名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="discard">
        <source>discard</source>
        <target state="translated">放弃</target>
        <note />
      </trans-unit>
      <trans-unit id="from_metadata">
        <source>from metadata</source>
        <target state="translated">从元数据</target>
        <note />
      </trans-unit>
      <trans-unit id="full_long_date_time">
        <source>full long date/time</source>
        <target state="translated">完整长日期/时间</target>
        <note />
      </trans-unit>
      <trans-unit id="full_long_date_time_description">
        <source>The "F" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.FullDateTimePattern property. For example, the custom format string for the invariant culture is "dddd, dd MMMM yyyy HH:mm:ss".</source>
        <target state="translated">"F" 标准格式说明符表示由当前 DateTimeFormatInfo FullDateTimePattern 属性定义的自定义日期和时间格式字符串。例如，固定区域性的自定义格式字符串为 "dddd, dd MMMM yyyy HH:mm:ss"。</target>
        <note />
      </trans-unit>
      <trans-unit id="full_short_date_time">
        <source>full short date/time</source>
        <target state="translated">完整短日期/时间</target>
        <note />
      </trans-unit>
      <trans-unit id="full_short_date_time_description">
        <source>The Full Date Short Time ("f") Format Specifier

The "f" standard format specifier represents a combination of the long date ("D") and short time ("t") patterns, separated by a space.</source>
        <target state="translated">完整日期短时间("f")格式说明符

"f" 标准格式说明符表示长日期("D")和短时间("t")模式组合，用空格分隔。</target>
        <note />
      </trans-unit>
      <trans-unit id="general_long_date_time">
        <source>general long date/time</source>
        <target state="translated">常规长日期/时间</target>
        <note />
      </trans-unit>
      <trans-unit id="general_long_date_time_description">
        <source>The "G" standard format specifier represents a combination of the short date ("d") and long time ("T") patterns, separated by a space.</source>
        <target state="translated">"G" 标准格式说明符表示短日期("d")和长时间("T")模式组合，用空格分隔。</target>
        <note />
      </trans-unit>
      <trans-unit id="general_short_date_time">
        <source>general short date/time</source>
        <target state="translated">常规短日期/时间</target>
        <note />
      </trans-unit>
      <trans-unit id="general_short_date_time_description">
        <source>The "g" standard format specifier represents a combination of the short date ("d") and short time ("t") patterns, separated by a space.</source>
        <target state="translated">"g" 标准格式说明符表示短日期("d")和短时间("t")模式组合，用空格分隔。</target>
        <note />
      </trans-unit>
      <trans-unit id="generic_overload">
        <source>generic overload</source>
        <target state="translated">泛型重载</target>
        <note />
      </trans-unit>
      <trans-unit id="generic_overloads">
        <source>generic overloads</source>
        <target state="translated">多个泛型重载</target>
        <note />
      </trans-unit>
      <trans-unit id="in_Source_attribute">
        <source>in Source (attribute)</source>
        <target state="translated">在源(属性)中</target>
        <note />
      </trans-unit>
      <trans-unit id="long_date">
        <source>long date</source>
        <target state="translated">长日期</target>
        <note />
      </trans-unit>
      <trans-unit id="long_date_description">
        <source>The "D" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.LongDatePattern property. For example, the custom format string for the invariant culture is "dddd, dd MMMM yyyy".</source>
        <target state="translated">"D" 标准格式说明符表示由当前 DateTimeFormatInfo LongDatePattern 属性定义的自定义日期和时间格式字符串。例如，固定区域性的自定义格式字符串为 "dddd, dd MMMM yyyy"。</target>
        <note />
      </trans-unit>
      <trans-unit id="long_time">
        <source>long time</source>
        <target state="translated">长时间</target>
        <note />
      </trans-unit>
      <trans-unit id="long_time_description">
        <source>The "T" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.LongTimePattern property. For example, the custom format string for the invariant culture is "HH:mm:ss".</source>
        <target state="translated">"T" 标准格式说明符表示由特定区域性的 DateTimeFormatInfo.LongTimePattern 属性定义的自定义日期和时间格式字符串。例如，固定区域性的自定义格式字符串为 "HH:mm:ss"。</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_1_2_digits">
        <source>minute (1-2 digits)</source>
        <target state="translated">分钟(1-2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_1_2_digits_description">
        <source>The "m" custom format specifier represents the minute as a number from 0 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted without a leading zero.

If the "m" format specifier is used without other custom format specifiers, it's interpreted as the "m" standard date and time format specifier.</source>
        <target state="translated">"m" 自定义格式说明符将分钟表示为从 0 到 59 的数字。分钟表示自前一小时后经过的整分钟数。一位数字的分钟数设置为不带前导零的格式。

如果使用 "m" 格式说明符而没有其他自定义格式说明符，则该说明符将被解释为 "m" 标准日期和时间格式说明符。</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_2_digits">
        <source>minute (2 digits)</source>
        <target state="translated">分钟(2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_2_digits_description">
        <source>The "mm" custom format specifier (plus any number of additional "m" specifiers) represents the minute as a number from 00 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted with a leading zero.</source>
        <target state="translated">"mm" 自定义格式说明符(另加任意数量的其他 "m" 说明符)将分钟表示为从 00 至 59 的数字。分钟表示自前一小时后经过的整分钟数。一位数字的分钟数设置为带前导零的格式。</target>
        <note />
      </trans-unit>
      <trans-unit id="month_1_2_digits">
        <source>month (1-2 digits)</source>
        <target state="translated">月(1-2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_1_2_digits_description">
        <source>The "M" custom format specifier represents the month as a number from 1 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted without a leading zero.

If the "M" format specifier is used without other custom format specifiers, it's interpreted as the "M" standard date and time format specifier.</source>
        <target state="translated">"M" 自定义格式说明符将月份表示为从 1 至 12 (如果日历包含 13 个月，则为从 1 到 13)的数字。一位数字的月份设置为不带前导零的格式。

如果使用 "M" 格式说明符而没有其他自定义格式说明符，则该说明符将被解释为 "M" 标准日期和时间格式说明符。</target>
        <note />
      </trans-unit>
      <trans-unit id="month_2_digits">
        <source>month (2 digits)</source>
        <target state="translated">月(2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_2_digits_description">
        <source>The "MM" custom format specifier represents the month as a number from 01 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted with a leading zero.</source>
        <target state="translated">"MM" 自定义格式说明符将月份表示为从 01 至 12 (如果日历包含 13 个月，则为从 1 到 13)的数字。一位数字的月份设置为带前导零的格式。</target>
        <note />
      </trans-unit>
      <trans-unit id="month_abbreviated">
        <source>month (abbreviated)</source>
        <target state="translated">月(缩写)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_abbreviated_description">
        <source>The "MMM" custom format specifier represents the abbreviated name of the month. The localized abbreviated name of the month is retrieved from the DateTimeFormatInfo.AbbreviatedMonthNames property of the current or specified culture.</source>
        <target state="translated">"MMM" 自定义格式说明符表示月份的缩写名称。可从当前或指定区域性的 DateTimeFormatInfo.AbbreviatedMonthNames 属性中检索月份的本地化缩写名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="month_day">
        <source>month day</source>
        <target state="translated">月日</target>
        <note />
      </trans-unit>
      <trans-unit id="month_day_description">
        <source>The "M" or "m" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.MonthDayPattern property. For example, the custom format string for the invariant culture is "MMMM dd".</source>
        <target state="translated">"M" 或 "m" 标准格式说明符表示由当前 DateTimeFormatInfo.MonthDayPattern 属性定义的自定义日期和时间格式字符串。例如，固定区域性的自定义格式字符串为 "MMMM dd"。</target>
        <note />
      </trans-unit>
      <trans-unit id="month_full">
        <source>month (full)</source>
        <target state="translated">月(完整)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_full_description">
        <source>The "MMMM" custom format specifier represents the full name of the month. The localized name of the month is retrieved from the DateTimeFormatInfo.MonthNames property of the current or specified culture.</source>
        <target state="translated">"MMMM" 自定义格式说明符表示月份的完整名称。可从当前或指定区域性的 DateTimeFormatInfo.MonthNames 属性中检索月份的本地化名称。</target>
        <note />
      </trans-unit>
      <trans-unit id="overload">
        <source>overload</source>
        <target state="translated">重载</target>
        <note />
      </trans-unit>
      <trans-unit id="overloads_">
        <source>overloads</source>
        <target state="translated">多个重载</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_Keyword">
        <source>{0} Keyword</source>
        <target state="translated">{0} 关键字</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_field_colon_0_and_use_property">
        <source>Encapsulate field: '{0}' (and use property)</source>
        <target state="translated">封装字段:“{0}”(并使用属性)</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_field_colon_0_but_still_use_field">
        <source>Encapsulate field: '{0}' (but still use field)</source>
        <target state="translated">封装字段:“{0}”(但仍使用字段)</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_fields_and_use_property">
        <source>Encapsulate fields (and use property)</source>
        <target state="translated">封装字段 (并使用属性)</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_fields_but_still_use_field">
        <source>Encapsulate fields (but still use field)</source>
        <target state="translated">封装字段 (但仍使用字段)</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_extract_interface_colon_The_selection_is_not_inside_a_class_interface_struct">
        <source>Could not extract interface: The selection is not inside a class/interface/struct.</source>
        <target state="translated">无法提取接口:所选内容不在类/接口/结构中。</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_extract_interface_colon_The_type_does_not_contain_any_member_that_can_be_extracted_to_an_interface">
        <source>Could not extract interface: The type does not contain any member that can be extracted to an interface.</source>
        <target state="translated">无法提取接口:此类型不含任何可以提取到接口的成员。</target>
        <note />
      </trans-unit>
      <trans-unit id="can_t_not_construct_final_tree">
        <source>can't not construct final tree</source>
        <target state="translated">不能构造最终树</target>
        <note />
      </trans-unit>
      <trans-unit id="Parameters_type_or_return_type_cannot_be_an_anonymous_type_colon_bracket_0_bracket">
        <source>Parameters' type or return type cannot be an anonymous type : [{0}]</source>
        <target state="translated">参数的类型或返回类型不能为匿名类型:[{0}]</target>
        <note />
      </trans-unit>
      <trans-unit id="The_selection_contains_no_active_statement">
        <source>The selection contains no active statement.</source>
        <target state="translated">所选内容不含活动语句。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_selection_contains_an_error_or_unknown_type">
        <source>The selection contains an error or unknown type.</source>
        <target state="translated">所选内容含错误或未知类型。</target>
        <note />
      </trans-unit>
      <trans-unit id="Type_parameter_0_is_hidden_by_another_type_parameter_1">
        <source>Type parameter '{0}' is hidden by another type parameter '{1}'.</source>
        <target state="translated">类型参数“{0}”被另一类型参数“{1}”隐藏。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_address_of_a_variable_is_used_inside_the_selected_code">
        <source>The address of a variable is used inside the selected code.</source>
        <target state="translated">变量的地址在选定代码内使用。</target>
        <note />
      </trans-unit>
      <trans-unit id="Assigning_to_readonly_fields_must_be_done_in_a_constructor_colon_bracket_0_bracket">
        <source>Assigning to readonly fields must be done in a constructor : [{0}].</source>
        <target state="translated">分配到只读字段必须在构造函数: [{0}] 中完成。</target>
        <note />
      </trans-unit>
      <trans-unit id="generated_code_is_overlapping_with_hidden_portion_of_the_code">
        <source>generated code is overlapping with hidden portion of the code</source>
        <target state="translated">生成的代码与代码隐藏部分重叠</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_optional_parameters_to_0">
        <source>Add optional parameters to '{0}'</source>
        <target state="translated">将可选参数添加到“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_parameters_to_0">
        <source>Add parameters to '{0}'</source>
        <target state="translated">将参数添加到“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_delegating_constructor_0_1">
        <source>Generate delegating constructor '{0}({1})'</source>
        <target state="translated">生成委托构造函数“{0}({1})”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constructor_0_1">
        <source>Generate constructor '{0}({1})'</source>
        <target state="translated">生成构造函数 “{0}({1})”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_field_assigning_constructor_0_1">
        <source>Generate field assigning constructor '{0}({1})'</source>
        <target state="translated">生成字段分配构造函数“{0}({1})”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_Equals_and_GetHashCode">
        <source>Generate Equals and GetHashCode</source>
        <target state="translated">生成 Equals 和 GetHashCode</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_Equals_object">
        <source>Generate Equals(object)</source>
        <target state="translated">生成 Equals(object)</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_GetHashCode">
        <source>Generate GetHashCode()</source>
        <target state="translated">生成 GetHashCode()</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constructor_in_0">
        <source>Generate constructor in '{0}'</source>
        <target state="translated">在“{0}”中生成构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_all">
        <source>Generate all</source>
        <target state="translated">生成所有</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_enum_member_1_0">
        <source>Generate enum member '{1}.{0}'</source>
        <target state="translated">生成枚举成员“{1}.{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constant_1_0">
        <source>Generate constant '{1}.{0}'</source>
        <target state="translated">生成常数“{1}.{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_read_only_property_1_0">
        <source>Generate read-only property '{1}.{0}'</source>
        <target state="translated">生成只读属性“{1}.{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_property_1_0">
        <source>Generate property '{1}.{0}'</source>
        <target state="translated">生成属性“{1}.{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_read_only_field_1_0">
        <source>Generate read-only field '{1}.{0}'</source>
        <target state="translated">生成只读字段“{1}.{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_field_1_0">
        <source>Generate field '{1}.{0}'</source>
        <target state="translated">生成字段“{1}.{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_local_0">
        <source>Generate local '{0}'</source>
        <target state="translated">生成本地“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_0_1_in_new_file">
        <source>Generate {0} '{1}' in new file</source>
        <target state="translated">在新文件中生成 {0}“{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_nested_0_1">
        <source>Generate nested {0} '{1}'</source>
        <target state="translated">生成嵌套的 {0}“{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Global_Namespace">
        <source>Global Namespace</source>
        <target state="translated">全局命名空间</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_interface_abstractly">
        <source>Implement interface abstractly</source>
        <target state="translated">以抽象方式实现接口</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_interface_through_0">
        <source>Implement interface through '{0}'</source>
        <target state="translated">通过“{0}”实现接口</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_interface">
        <source>Implement interface</source>
        <target state="translated">实现接口</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_field_for_0">
        <source>Introduce field for '{0}'</source>
        <target state="translated">为“{0}”引入字段</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_for_0">
        <source>Introduce local for '{0}'</source>
        <target state="translated">为“{0}”引入本地</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_constant_for_0">
        <source>Introduce constant for '{0}'</source>
        <target state="translated">为“{0}”引入常量</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_constant_for_0">
        <source>Introduce local constant for '{0}'</source>
        <target state="translated">为“{0}”引入局部常量</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_field_for_all_occurrences_of_0">
        <source>Introduce field for all occurrences of '{0}'</source>
        <target state="translated">为出现的所有“{0}”引入字段</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_for_all_occurrences_of_0">
        <source>Introduce local for all occurrences of '{0}'</source>
        <target state="translated">为出现的所有“{0}”引入本地</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_constant_for_all_occurrences_of_0">
        <source>Introduce constant for all occurrences of '{0}'</source>
        <target state="translated">为出现的所有“{0}”引入常量</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_constant_for_all_occurrences_of_0">
        <source>Introduce local constant for all occurrences of '{0}'</source>
        <target state="translated">为出现的所有“{0}”引入局部常量</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_query_variable_for_all_occurrences_of_0">
        <source>Introduce query variable for all occurrences of '{0}'</source>
        <target state="translated">为出现的所有“{0}”引入查询变量</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_query_variable_for_0">
        <source>Introduce query variable for '{0}'</source>
        <target state="translated">为“{0}”引入查询变量</target>
        <note />
      </trans-unit>
      <trans-unit id="Anonymous_Types_colon">
        <source>Anonymous Types:</source>
        <target state="translated">匿名类型:</target>
        <note />
      </trans-unit>
      <trans-unit id="is_">
        <source>is</source>
        <target state="translated">是</target>
        <note />
      </trans-unit>
      <trans-unit id="Represents_an_object_whose_operations_will_be_resolved_at_runtime">
        <source>Represents an object whose operations will be resolved at runtime.</source>
        <target state="translated">表示将在运行时解析其操作的对象</target>
        <note />
      </trans-unit>
      <trans-unit id="constant">
        <source>constant</source>
        <target state="translated">常量</target>
        <note />
      </trans-unit>
      <trans-unit id="field">
        <source>field</source>
        <target state="translated">字段</target>
        <note />
      </trans-unit>
      <trans-unit id="local_constant">
        <source>local constant</source>
        <target state="translated">局部常量</target>
        <note />
      </trans-unit>
      <trans-unit id="local_variable">
        <source>local variable</source>
        <target state="translated">局部变量</target>
        <note />
      </trans-unit>
      <trans-unit id="label">
        <source>label</source>
        <target state="translated">标签</target>
        <note />
      </trans-unit>
      <trans-unit id="period_era">
        <source>period/era</source>
        <target state="translated">期间/周期</target>
        <note />
      </trans-unit>
      <trans-unit id="period_era_description">
        <source>The "g" or "gg" custom format specifiers (plus any number of additional "g" specifiers) represents the period or era, such as A.D. The formatting operation ignores this specifier if the date to be formatted doesn't have an associated period or era string.

If the "g" format specifier is used without other custom format specifiers, it's interpreted as the "g" standard date and time format specifier.</source>
        <target state="translated">"g" 或 "gg" 自定义格式说明符(另加任意数量的其他 "g" 说明符)表示期间或纪元，如果要设置格式的日期不具有关联的时期或纪元字符串，则格式操作将忽略该说明符。

如果使用 "g" 格式说明符而没有其他自定义格式说明符，则该说明符将被解释为 "g" 标准日期和时间格式说明符。</target>
        <note />
      </trans-unit>
      <trans-unit id="range_variable">
        <source>range variable</source>
        <target state="translated">范围变量</target>
        <note />
      </trans-unit>
      <trans-unit id="parameter">
        <source>parameter</source>
        <target state="translated">参数</target>
        <note />
      </trans-unit>
      <trans-unit id="in_">
        <source>in</source>
        <target state="translated">隶属</target>
        <note />
      </trans-unit>
      <trans-unit id="Summary_colon">
        <source>Summary:</source>
        <target state="translated">摘要:</target>
        <note />
      </trans-unit>
      <trans-unit id="Locals_and_parameters">
        <source>Locals and parameters</source>
        <target state="translated">局部变量和参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Type_parameters_colon">
        <source>Type parameters:</source>
        <target state="translated">类型参数:</target>
        <note />
      </trans-unit>
      <trans-unit id="Returns_colon">
        <source>Returns:</source>
        <target state="translated">返回结果:</target>
        <note />
      </trans-unit>
      <trans-unit id="Exceptions_colon">
        <source>Exceptions:</source>
        <target state="translated">异常:</target>
        <note />
      </trans-unit>
      <trans-unit id="Remarks_colon">
        <source>Remarks:</source>
        <target state="translated">言论：</target>
        <note />
      </trans-unit>
      <trans-unit id="generating_source_for_symbols_of_this_type_is_not_supported">
        <source>generating source for symbols of this type is not supported</source>
        <target state="translated">不支持为此类型符号生成源。</target>
        <note />
      </trans-unit>
      <trans-unit id="Assembly">
        <source>Assembly</source>
        <target state="translated">程序集</target>
        <note />
      </trans-unit>
      <trans-unit id="location_unknown">
        <source>location unknown</source>
        <target state="translated">未知的位置</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更新“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_a_complex_statement_containing_an_await_expression_will_prevent_the_debug_session_from_continuing">
        <source>Updating a complex statement containing an await expression will prevent the debug session from continuing.</source>
        <target state="translated">更新包含 Await 表达式的复杂语句将中止调试会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_visibility_of_a_constructor_will_prevent_the_debug_session_from_continuing">
        <source>Changing visibility of a constructor will prevent the debug session from continuing.</source>
        <target state="translated">更改构造函数的可见性将会中止调试会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="Capturing_variable_0_that_hasn_t_been_captured_before_will_prevent_the_debug_session_from_continuing">
        <source>Capturing variable '{0}' that hasn't been captured before will prevent the debug session from continuing.</source>
        <target state="translated">捕获之前尚未捕获过的变量“{0}”将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Ceasing_to_capture_variable_0_will_prevent_the_debug_session_from_continuing">
        <source>Ceasing to capture variable '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">中止捕获变量“{0}”将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_captured_variable_0_will_prevent_the_debug_session_from_continuing">
        <source>Deleting captured variable '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">删除捕获的变量“{0}”将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_type_of_a_captured_variable_0_previously_of_type_1_will_prevent_the_debug_session_from_continuing">
        <source>Changing the type of a captured variable '{0}' previously of type '{1}' will prevent the debug session from continuing.</source>
        <target state="translated">更改之前类型为“{1}”的捕获的变量“{0}”的类型将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_parameters_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Changing the parameters of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更改“{0}”的参数将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_return_type_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Changing the return type of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更改“{0}”的返回类型将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_type_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Changing the type of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更改“{0}”的类型将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_declaration_scope_of_a_captured_variable_0_will_prevent_the_debug_session_from_continuing">
        <source>Changing the declaration scope of a captured variable '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更改捕获的变量“{0}”的声明范围将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Accessing_captured_variable_0_that_hasn_t_been_accessed_before_in_1_will_prevent_the_debug_session_from_continuing">
        <source>Accessing captured variable '{0}' that hasn't been accessed before in {1} will prevent the debug session from continuing.</source>
        <target state="translated">访问 {1} 中之前尚未访问过的捕获的变量“{0}”将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Ceasing_to_access_captured_variable_0_in_1_will_prevent_the_debug_session_from_continuing">
        <source>Ceasing to access captured variable '{0}' in {1} will prevent the debug session from continuing.</source>
        <target state="translated">中止访问 {1} 中的捕获的变量“{0}”将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_that_accesses_captured_variables_1_and_2_declared_in_different_scopes_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' that accesses captured variables '{1}' and '{2}' declared in different scopes will prevent the debug session from continuing.</source>
        <target state="translated">添加访问捕获的变量“{1}”和“{2}”(在不同范围中声明)的“{0}”将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_0_that_accessed_captured_variables_1_and_2_declared_in_different_scopes_will_prevent_the_debug_session_from_continuing">
        <source>Removing '{0}' that accessed captured variables '{1}' and '{2}' declared in different scopes will prevent the debug session from continuing.</source>
        <target state="translated">删除访问捕获的变量“{1}”和“{2}”(在不同范围中声明)的“{0}”将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_a_1_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' into a '{1}' will prevent the debug session from continuing.</source>
        <target state="translated">将“{0}”添加进“{1}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_a_class_with_explicit_or_sequential_layout_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' into a class with explicit or sequential layout will prevent the debug session from continuing.</source>
        <target state="translated">将“{0}”添加到具有显式或有序布局的类将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_modifiers_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the modifiers of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更新“{0}”的修饰符将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_Handles_clause_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the Handles clause of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更新“{0}”的 Handles 子句将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_with_the_Handles_clause_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' with the Handles clause will prevent the debug session from continuing.</source>
        <target state="translated">向“{0}”添加 Handles 子句将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_Implements_clause_of_a_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the Implements clause of a '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更新“{0}”的 Implements 子句将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_constraint_from_0_to_1_will_prevent_the_debug_session_from_continuing">
        <source>Changing the constraint from '{0}' to '{1}' will prevent the debug session from continuing.</source>
        <target state="translated">将约束从“{0}”更改为“{1}” 将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_variance_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the variance of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更新“{0}”的变型将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_type_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the type of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更新“{0}”的类型将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_initializer_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the initializer of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更新“{0}”的初始值设定项将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_size_of_a_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the size of a '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更新“{0}”的大小将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_underlying_type_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the underlying type of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更新“{0}”的基础类型将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_base_class_and_or_base_interface_s_of_0_will_prevent_the_debug_session_from_continuing">
        <source>Updating the base class and/or base interface(s) of '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">更新“{0}”的基类和/或基接口将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_a_field_to_an_event_or_vice_versa_will_prevent_the_debug_session_from_continuing">
        <source>Updating a field to an event or vice versa will prevent the debug session from continuing.</source>
        <target state="translated">更新事件的字段或更新字段的事件都将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_kind_of_a_type_will_prevent_the_debug_session_from_continuing">
        <source>Updating the kind of a type will prevent the debug session from continuing.</source>
        <target state="translated">更新类型的种类将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_kind_of_an_property_event_accessor_will_prevent_the_debug_session_from_continuing">
        <source>Updating the kind of an property/event accessor will prevent the debug session from continuing.</source>
        <target state="translated">更新一个属性/事件访问器的种类将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_kind_of_a_method_Sub_Function_will_prevent_the_debug_session_from_continuing">
        <source>Updating the kind of a method (Sub/Function) will prevent the debug session from continuing.</source>
        <target state="translated">更新方法 (Sub/Function) 的种类将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_library_name_of_Declare_Statement_will_prevent_the_debug_session_from_continuing">
        <source>Updating the library name of Declare Statement will prevent the debug session from continuing.</source>
        <target state="translated">更新 Declare 语句的库名将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_alias_of_Declare_Statement_will_prevent_the_debug_session_from_continuing">
        <source>Updating the alias of Declare Statement will prevent the debug session from continuing.</source>
        <target state="translated">更新“Declare 语句”的别名将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Renaming_0_will_prevent_the_debug_session_from_continuing">
        <source>Renaming '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">重命名“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">添加“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_an_abstract_0_or_overriding_an_inherited_0_will_prevent_the_debug_session_from_continuing">
        <source>Adding an abstract '{0}' or overriding an inherited '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">添加摘要“{0}”或替代继承的“{0}”将会中止调试会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_MustOverride_0_or_overriding_an_inherited_0_will_prevent_the_debug_session_from_continuing">
        <source>Adding a MustOverride '{0}' or overriding an inherited '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">添加 MustOverride“{0}”或替代继承的“{0}”将会中止调试会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_an_extern_0_will_prevent_the_debug_session_from_continuing">
        <source>Adding an extern '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">添加外部“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_an_imported_method_will_prevent_the_debug_session_from_continuing">
        <source>Adding an imported method will prevent the debug session from continuing.</source>
        <target state="translated">添加导入的方法将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_user_defined_0_will_prevent_the_debug_session_from_continuing">
        <source>Adding a user defined '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">添加用户定义的“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_generic_0_will_prevent_the_debug_session_from_continuing">
        <source>Adding a generic '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">添加泛型“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Adding '{0}' around an active statement will prevent the debug session from continuing.</source>
        <target state="translated">在活动语句周围添加“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Moving_0_will_prevent_the_debug_session_from_continuing">
        <source>Moving '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">移动“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_0_will_prevent_the_debug_session_from_continuing">
        <source>Deleting '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">删除“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Deleting '{0}' around an active statement will prevent the debug session from continuing.</source>
        <target state="translated">删除活动语句周围的“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_method_body_will_prevent_the_debug_session_from_continuing">
        <source>Adding a method body will prevent the debug session from continuing.</source>
        <target state="translated">添加方法主体将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_a_method_body_will_prevent_the_debug_session_from_continuing">
        <source>Deleting a method body will prevent the debug session from continuing.</source>
        <target state="translated">删除方法主体将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="An_active_statement_has_been_removed_from_its_original_method_You_must_revert_your_changes_to_continue_or_restart_the_debugging_session">
        <source>An active statement has been removed from its original method. You must revert your changes to continue or restart the debugging session.</source>
        <target state="translated">活动语句已从其初始方法中删除。必须还原更改才能继续或重新启动调试会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_async_or_iterator_modifier_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Updating async or iterator modifier around an active statement will prevent the debug session from continuing.</source>
        <target state="translated">更新当前语句的 async 或 iterator 修饰符可以阻止调试会话继续。</target>
        <note>{Locked="async"}{Locked="iterator"} "async" and "iterator" are C#/VB keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Modifying_a_generic_method_will_prevent_the_debug_session_from_continuing">
        <source>Modifying a generic method will prevent the debug session from continuing.</source>
        <target state="translated">修改泛型方法将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_whitespace_or_comments_in_a_generic_0_will_prevent_the_debug_session_from_continuing">
        <source>Modifying whitespace or comments in a generic '{0}' will prevent the debug session from continuing.</source>
        <target state="translated">修改泛型“{0}”中的空白或注释将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_method_inside_the_context_of_a_generic_type_will_prevent_the_debug_session_from_continuing">
        <source>Modifying a method inside the context of a generic type will prevent the debug session from continuing.</source>
        <target state="translated">修改某个泛型类型上下文内的方法将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_whitespace_or_comments_in_0_inside_the_context_of_a_generic_type_will_prevent_the_debug_session_from_continuing">
        <source>Modifying whitespace or comments in '{0}' inside the context of a generic type will prevent the debug session from continuing.</source>
        <target state="translated">修改泛型类型上下文内“{0}”的空白或注释将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_the_initializer_of_0_in_a_generic_type_will_prevent_the_debug_session_from_continuing">
        <source>Modifying the initializer of '{0}' in a generic type will prevent the debug session from continuing.</source>
        <target state="translated">修改泛型类型中的“{0}”的初始值设定项将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_the_initializer_of_0_in_a_partial_type_will_prevent_the_debug_session_from_continuing">
        <source>Modifying the initializer of '{0}' in a partial type will prevent the debug session from continuing.</source>
        <target state="translated">修改分部类型中“{0}”的初始值设定项将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_constructor_to_a_type_with_a_field_or_property_initializer_that_contains_an_anonymous_function_will_prevent_the_debug_session_from_continuing">
        <source>Adding a constructor to a type with a field or property initializer that contains an anonymous function will prevent the debug session from continuing.</source>
        <target state="translated">使用包含匿名类型的字段或属性初始值设定项向类型添加构造函数将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Renaming_a_captured_variable_from_0_to_1_will_prevent_the_debug_session_from_continuing">
        <source>Renaming a captured variable, from '{0}' to '{1}' will prevent the debug session from continuing.</source>
        <target state="translated">如果将捕获的变量从“{0}”重命名为“{1}”，调试会话将不能继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_catch_finally_handler_with_an_active_statement_in_the_try_block_will_prevent_the_debug_session_from_continuing">
        <source>Modifying a catch/finally handler with an active statement in the try block will prevent the debug session from continuing.</source>
        <target state="translated">修改带有 try 块中的活动语句的 catch/finally 处理程序将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_try_catch_finally_statement_when_the_finally_block_is_active_will_prevent_the_debug_session_from_continuing">
        <source>Modifying a try/catch/finally statement when the finally block is active will prevent the debug session from continuing.</source>
        <target state="translated">在 finally 块处于活动状态时修改 try/catch/finally 语句将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_catch_handler_around_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Modifying a catch handler around an active statement will prevent the debug session from continuing.</source>
        <target state="translated">修改活动语句周围的 catch 处理程序将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_the_stackalloc_operator_will_prevent_the_debug_session_from_continuing">
        <source>Modifying '{0}' which contains the 'stackalloc' operator will prevent the debug session from continuing.</source>
        <target state="translated">修改含“stackalloc”运算符的“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_an_active_0_which_contains_On_Error_or_Resume_statements_will_prevent_the_debug_session_from_continuing">
        <source>Modifying an active '{0}' which contains 'On Error' or 'Resume' statements will prevent the debug session from continuing.</source>
        <target state="translated">修改含“On Error”或“Resume”语句的活动“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_an_Aggregate_Group_By_or_Join_query_clauses_will_prevent_the_debug_session_from_continuing">
        <source>Modifying '{0}' which contains an Aggregate, Group By, or Join query clauses will prevent the debug session from continuing.</source>
        <target state="translated">修改包含 Aggregate、Group By 或 Join 查询子句的“{0}”将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_source_with_experimental_language_features_enabled_will_prevent_the_debug_session_from_continuing">
        <source>Modifying source with experimental language features enabled will prevent the debug session from continuing.</source>
        <target state="translated">修改已启用实验性语言功能的源将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Updating an active statement will prevent the debug session from continuing.</source>
        <target state="translated">更新活动语句将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_0_that_contains_an_active_statement_will_prevent_the_debug_session_from_continuing">
        <source>Removing '{0}' that contains an active statement will prevent the debug session from continuing.</source>
        <target state="translated">删除含活动语句的“{0}”将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_new_file_will_prevent_the_debug_session_from_continuing">
        <source>Adding a new file will prevent the debug session from continuing.</source>
        <target state="translated">添加一个新文件将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Attribute_0_is_missing_Updating_an_async_method_or_an_iterator_will_prevent_the_debug_session_from_continuing">
        <source>Attribute '{0}' is missing. Updating an async method or an iterator will prevent the debug session from continuing.</source>
        <target state="translated">特性“{0}”缺失。更新异步方法或迭代器将阻止调试会话继续。</target>
        <note />
      </trans-unit>
      <trans-unit id="Unexpected_interface_member_kind_colon_0">
        <source>Unexpected interface member kind: {0}</source>
        <target state="translated">意外的接口成员种类:{0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_symbol_kind">
        <source>Unknown symbol kind</source>
        <target state="translated">未知符号种类</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_abstract_property_1_0">
        <source>Generate abstract property '{1}.{0}'</source>
        <target state="translated">生成抽象属性“{1}.{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_abstract_method_1_0">
        <source>Generate abstract method '{1}.{0}'</source>
        <target state="translated">生成抽象方法“{1}.{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_method_1_0">
        <source>Generate method '{1}.{0}'</source>
        <target state="translated">生成方法“{1}.{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Requested_assembly_already_loaded_from_0">
        <source>Requested assembly already loaded from '{0}'.</source>
        <target state="translated">已从“{0}”中加载请求的程序集。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_symbol_does_not_have_an_icon">
        <source>The symbol does not have an icon.</source>
        <target state="translated">此符号无图标。</target>
        <note />
      </trans-unit>
      <trans-unit id="Asynchronous_method_cannot_have_ref_out_parameters_colon_bracket_0_bracket">
        <source>Asynchronous method cannot have ref/out parameters : [{0}]</source>
        <target state="translated">异步方法不能包含 ref/out 参数:[{0}]</target>
        <note />
      </trans-unit>
      <trans-unit id="The_member_is_defined_in_metadata">
        <source>The member is defined in metadata.</source>
        <target state="translated">此成员是在元数据中定义的。</target>
        <note />
      </trans-unit>
      <trans-unit id="You_can_only_change_the_signature_of_a_constructor_indexer_method_or_delegate">
        <source>You can only change the signature of a constructor, indexer, method or delegate.</source>
        <target state="translated">只能更改构造函数、索引器、方法或委托的签名。</target>
        <note />
      </trans-unit>
      <trans-unit id="This_symbol_has_related_definitions_or_references_in_metadata_Changing_its_signature_may_result_in_build_errors_Do_you_want_to_continue">
        <source>This symbol has related definitions or references in metadata. Changing its signature may result in build errors.

Do you want to continue?</source>
        <target state="translated">此符号在元数据中有相关定义或引用。更它的签名可能会造成生成错误。

想要继续吗?</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_signature">
        <source>Change signature...</source>
        <target state="translated">更改签名...</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_new_type">
        <source>Generate new type...</source>
        <target state="translated">生成新类型...</target>
        <note />
      </trans-unit>
      <trans-unit id="User_Diagnostic_Analyzer_Failure">
        <source>User Diagnostic Analyzer Failure.</source>
        <target state="translated">用户诊断分析器失败。</target>
        <note />
      </trans-unit>
      <trans-unit id="Analyzer_0_threw_an_exception_of_type_1_with_message_2">
        <source>Analyzer '{0}' threw an exception of type '{1}' with message '{2}'.</source>
        <target state="translated">分析器“{0}”抛出类型为“{1}”的异常，并显示消息“{2}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="Analyzer_0_threw_the_following_exception_colon_1">
        <source>Analyzer '{0}' threw the following exception:
'{1}'.</source>
        <target state="translated">分析器“{0}”引发了以下异常:
“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="Simplify_Names">
        <source>Simplify Names</source>
        <target state="translated">简化名称</target>
        <note />
      </trans-unit>
      <trans-unit id="Simplify_Member_Access">
        <source>Simplify Member Access</source>
        <target state="translated">简化成员访问</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_qualification">
        <source>Remove qualification</source>
        <target state="translated">删除限定</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_error_occurred">
        <source>Unknown error occurred</source>
        <target state="translated">发生未知错误</target>
        <note />
      </trans-unit>
      <trans-unit id="Available">
        <source>Available</source>
        <target state="translated">可用</target>
        <note />
      </trans-unit>
      <trans-unit id="Not_Available">
        <source>Not Available</source>
        <target state="translated">不可用</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_1">
        <source>    {0} - {1}</source>
        <target state="translated">    {0} - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="You_can_use_the_navigation_bar_to_switch_context">
        <source>You can use the navigation bar to switch context.</source>
        <target state="translated">你可以使用导航栏切换上下文。</target>
        <note />
      </trans-unit>
      <trans-unit id="in_Source">
        <source>in Source</source>
        <target state="translated">在源中</target>
        <note />
      </trans-unit>
      <trans-unit id="in_Suppression_File">
        <source>in Suppression File</source>
        <target state="translated">在禁止显示文件中</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_Suppression_0">
        <source>Remove Suppression {0}</source>
        <target state="translated">删除禁止显示 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_Suppression">
        <source>Remove Suppression</source>
        <target state="translated">删除禁止显示</target>
        <note />
      </trans-unit>
      <trans-unit id="Pending">
        <source>&lt;Pending&gt;</source>
        <target state="translated">&lt;挂起&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="Note_colon_Tab_twice_to_insert_the_0_snippet">
        <source>Note: Tab twice to insert the '{0}' snippet.</source>
        <target state="translated">注意: 两次 Tab 插入“{0}”片段。</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_interface_explicitly_with_Dispose_pattern">
        <source>Implement interface explicitly with Dispose pattern</source>
        <target state="translated">通过释放模式显式实现接口</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_interface_with_Dispose_pattern">
        <source>Implement interface with Dispose pattern</source>
        <target state="translated">通过释放模式实现接口</target>
        <note />
      </trans-unit>
      <trans-unit id="Re_triage_0_currently_1">
        <source>Re-triage {0}(currently '{1}')</source>
        <target state="translated">对 {0}(当前为“{1}”) 进行重新分类</target>
        <note />
      </trans-unit>
      <trans-unit id="Argument_cannot_have_a_null_element">
        <source>Argument cannot have a null element.</source>
        <target state="translated">参数不能具有 null 元素。</target>
        <note />
      </trans-unit>
      <trans-unit id="Argument_cannot_be_empty">
        <source>Argument cannot be empty.</source>
        <target state="translated">参数不能为空。</target>
        <note />
      </trans-unit>
      <trans-unit id="Reported_diagnostic_with_ID_0_is_not_supported_by_the_analyzer">
        <source>Reported diagnostic with ID '{0}' is not supported by the analyzer.</source>
        <target state="translated">分析器不支持 ID 为“{0}”的报告的诊断。</target>
        <note />
      </trans-unit>
      <trans-unit id="Computing_fix_all_occurrences_code_fix">
        <source>Computing fix all occurrences code fix...</source>
        <target state="translated">正在计算“修复所有出现的地方”代码修复...</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_occurrences">
        <source>Fix all occurrences</source>
        <target state="translated">修复所有出现的地方</target>
        <note />
      </trans-unit>
      <trans-unit id="Document">
        <source>Document</source>
        <target state="translated">文档</target>
        <note />
      </trans-unit>
      <trans-unit id="Project">
        <source>Project</source>
        <target state="translated">项目</target>
        <note />
      </trans-unit>
      <trans-unit id="Solution">
        <source>Solution</source>
        <target state="translated">解决方案</target>
        <note />
      </trans-unit>
      <trans-unit id="TODO_colon_dispose_managed_state_managed_objects">
        <source>TODO: dispose managed state (managed objects)</source>
        <target state="translated">TODO: 释放托管状态(托管对象)</target>
        <note />
      </trans-unit>
      <trans-unit id="TODO_colon_set_large_fields_to_null">
        <source>TODO: set large fields to null</source>
        <target state="translated">TODO: 将大型字段设置为 null</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_a_static_variable_will_prevent_the_debug_session_from_continuing">
        <source>Modifying '{0}' which contains a static variable will prevent the debug session from continuing.</source>
        <target state="translated">修改包含静态变量的“{0}”将阻止调试会话继续执行。</target>
        <note />
      </trans-unit>
      <trans-unit id="Compiler2">
        <source>Compiler</source>
        <target state="translated">编译器</target>
        <note />
      </trans-unit>
      <trans-unit id="Live">
        <source>Live</source>
        <target state="translated">活动</target>
        <note />
      </trans-unit>
      <trans-unit id="enum_value">
        <source>enum value</source>
        <target state="translated">enum 值</target>
        <note>{Locked="enum"} "enum" is a C#/VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="const_field">
        <source>const field</source>
        <target state="translated">const 字段</target>
        <note>{Locked="const"} "const" is a C#/VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="method">
        <source>method</source>
        <target state="translated">方法</target>
        <note />
      </trans-unit>
      <trans-unit id="operator_">
        <source>operator</source>
        <target state="translated">运算符</target>
        <note />
      </trans-unit>
      <trans-unit id="constructor">
        <source>constructor</source>
        <target state="translated">构造函数</target>
        <note />
      </trans-unit>
      <trans-unit id="auto_property">
        <source>auto-property</source>
        <target state="translated">自动属性</target>
        <note />
      </trans-unit>
      <trans-unit id="property_">
        <source>property</source>
        <target state="translated">属性</target>
        <note />
      </trans-unit>
      <trans-unit id="event_accessor">
        <source>event accessor</source>
        <target state="translated">事件访问器</target>
        <note />
      </trans-unit>
      <trans-unit id="rfc1123_date_time">
        <source>rfc1123 date/time</source>
        <target state="translated">rfc1123 日期/时间</target>
        <note />
      </trans-unit>
      <trans-unit id="rfc1123_date_time_description">
        <source>The "R" or "r" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.RFC1123Pattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'". When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.</source>
        <target state="translated">"R" 或 "r" 标准格式说明符表示由 DateTimeFormatInfo.RFC1123Pattern 属性定义的自定义日期和时间格式字符串。模式反映已定义的标准，并且属性是只读的。因此，无论使用何种区域性或提供格式提供程序，它始终是相同的。自定义格式字符串为 "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'"。使用此标准格式说明符时，格式设置或分析操作始终使用固定区域性。</target>
        <note />
      </trans-unit>
      <trans-unit id="round_trip_date_time">
        <source>round-trip date/time</source>
        <target state="translated">往返日期/时间</target>
        <note />
      </trans-unit>
      <trans-unit id="round_trip_date_time_description">
        <source>The "O" or "o" standard format specifier represents a custom date and time format string using a pattern that preserves time zone information and emits a result string that complies with ISO 8601. For DateTime values, this format specifier is designed to preserve date and time values along with the DateTime.Kind property in text. The formatted string can be parsed back by using the DateTime.Parse(String, IFormatProvider, DateTimeStyles) or DateTime.ParseExact method if the styles parameter is set to DateTimeStyles.RoundtripKind.

The "O" or "o" standard format specifier corresponds to the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" custom format string for DateTime values and to the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffzzz" custom format string for DateTimeOffset values. In this string, the pairs of single quotation marks that delimit individual characters, such as the hyphens, the colons, and the letter "T", indicate that the individual character is a literal that cannot be changed. The apostrophes do not appear in the output string.

The "O" or "o" standard format specifier (and the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" custom format string) takes advantage of the three ways that ISO 8601 represents time zone information to preserve the Kind property of DateTime values:

    The time zone component of DateTimeKind.Local date and time values is an offset from UTC (for example, +01:00, -07:00). All DateTimeOffset values are also represented in this format.

    The time zone component of DateTimeKind.Utc date and time values uses "Z" (which stands for zero offset) to represent UTC.

    DateTimeKind.Unspecified date and time values have no time zone information.

Because the "O" or "o" standard format specifier conforms to an international standard, the formatting or parsing operation that uses the specifier always uses the invariant culture and the Gregorian calendar.

Strings that are passed to the Parse, TryParse, ParseExact, and TryParseExact methods of DateTime and DateTimeOffset can be parsed by using the "O" or "o" format specifier if they are in one of these formats. In the case of DateTime objects, the parsing overload that you call should also include a styles parameter with a value of DateTimeStyles.RoundtripKind. Note that if you call a parsing method with the custom format string that corresponds to the "O" or "o" format specifier, you won't get the same results as "O" or "o". This is because parsing methods that use a custom format string can't parse the string representation of date and time values that lack a time zone component or use "Z" to indicate UTC.</source>
        <target state="translated">"O" 或 "o" 标准格式说明符表示使用以下模式的自定义日期和时间格式字符串: 该模式保留时区信息并发出符合 ISO 8601 的结果字符串。对于 DateTime 值，此格式说明符旨在保留日期和时间值以及文本中的 DateTime.Kind 属性。如果将样式参数设置为 DateTimeStyles.RoundtripKind，则可使用 DateTime.Parse(String, IFormatProvider, DateTimeStyles)或 DateTime.ParseExact 方法对格式化字符串进行重新分析。

"O" 或 "o" 标准格式说明符对应于 DateTime 值的 "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" 自定义格式字符串和 DateTimeOffset 值的 "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffzzz" 自定义格式字符串。在此字符串中，分隔单个字符的单引号标记对(如连字符、冒号和字母 "T")指示单个字符是不能更改的文本。撇号不会出现在输出字符串中。

"O" 或 "o" 标准格式说明符(以及 "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" 自定义格式字符串)利用 ISO 8601 表示时区信息的三种方式保留日期时间值的 Kind 属性: 

DateTimeKind 日期和时间值的时区部分是相对于 UTC 的偏移量(例如 +01:00, -07:00)。所有 DateTimeOffset 值也以这种格式表示。

DateTimeKind 日期和时间值的时区部分使用 "Z" (代表零偏移量)表示 UTC。

DateTimeKind.Unspecified  日期和时间值不具有时区信息。

由于 "O" 或 "o" 标准格式说明符符合国际标准，因此使用该说明符的格式设置或分析操作始终使用固定区域性和公历。

可使用  "O" 或 "o" 格式说明符分析传递给 DateTime 和 DateTimeOffset 的 Parse、TryParse、ParseExact 和 TryParseExact 方法的字符串，如果字符串采用了这些格式的其中一种格式。对于 DateTime 对象，调用的分析重载还应包含值为 DateTimeStyles RoundtripKind 的样式参数。请注意，如果使用与 "O" 或 "o" 格式说明符对应的自定义格式字符串调用分析方法，则不会获得与 "O" 或 "o" 相同的结果。这是因为使用自定义格式字符串的分析方法无法分析缺少时区部分或使用 "Z" 指示 UTC 的日期和时间值的字符串表示形式。</target>
        <note />
      </trans-unit>
      <trans-unit id="second_1_2_digits">
        <source>second (1-2 digits)</source>
        <target state="translated">秒(1-2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="second_1_2_digits_description">
        <source>The "s" custom format specifier represents the seconds as a number from 0 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted without a leading zero.

If the "s" format specifier is used without other custom format specifiers, it's interpreted as the "s" standard date and time format specifier.</source>
        <target state="translated">"S" 自定义格式说明符将秒表示为从 0 到 59 的数字。结果表示自前一分钟后经过的整秒数。一位数字的秒数设置为不带前导零的格式。

如果使用 "s" 格式说明符而没有其他自定义格式说明符，则该说明符将被解释为 "s" 标准日期和时间格式说明符。</target>
        <note />
      </trans-unit>
      <trans-unit id="second_2_digits">
        <source>second (2 digits)</source>
        <target state="translated">秒(2 位数</target>
        <note />
      </trans-unit>
      <trans-unit id="second_2_digits_description">
        <source>The "ss" custom format specifier (plus any number of additional "s" specifiers) represents the seconds as a number from 00 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted with a leading zero.</source>
        <target state="translated">"ss" 自定义格式说明符(另加任意数量的其他 "s" 说明符)将秒表示为从 00 到 59 的数字。结果表示自前一分钟后经过的整秒数。一位数字的秒数设置为带前导零的格式。</target>
        <note />
      </trans-unit>
      <trans-unit id="short_date">
        <source>short date</source>
        <target state="translated">短日期</target>
        <note />
      </trans-unit>
      <trans-unit id="short_date_description">
        <source>The "d" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.ShortDatePattern property. For example, the custom format string that is returned by the ShortDatePattern property of the invariant culture is "MM/dd/yyyy".</source>
        <target state="translated">"D" 标准格式说明符表示由特定区域性的 DateTimeFormatInfo.ShortDatePattern 属性定义的自定义日期和时间格式字符串。例如，固定区域性的 ShortDatePattern 属性返回的自定义格式字符串为 "MM/dd/yyyy"。</target>
        <note />
      </trans-unit>
      <trans-unit id="short_time">
        <source>short time</source>
        <target state="translated">短时间</target>
        <note />
      </trans-unit>
      <trans-unit id="short_time_description">
        <source>The "t" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.ShortTimePattern property. For example, the custom format string for the invariant culture is "HH:mm".</source>
        <target state="translated">"t" 标准格式说明符表示由当前 DateTimeFormatInfo.ShortTimePattern 属性定义的自定义日期和时间格式字符串。例如，固定区域性的自定义格式字符串为 "HH:mm"。</target>
        <note />
      </trans-unit>
      <trans-unit id="sortable_date_time">
        <source>sortable date/time</source>
        <target state="translated">可排序日期/时间</target>
        <note />
      </trans-unit>
      <trans-unit id="sortable_date_time_description">
        <source>The "s" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.SortableDateTimePattern property. The pattern reflects a defined standard (ISO 8601), and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "yyyy'-'MM'-'dd'T'HH':'mm':'ss".

The purpose of the "s" format specifier is to produce result strings that sort consistently in ascending or descending order based on date and time values. As a result, although the "s" standard format specifier represents a date and time value in a consistent format, the formatting operation does not modify the value of the date and time object that is being formatted to reflect its DateTime.Kind property or its DateTimeOffset.Offset value. For example, the result strings produced by formatting the date and time values 2014-11-15T18:32:17+00:00 and 2014-11-15T18:32:17+08:00 are identical.

When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.</source>
        <target state="translated">"s" 标准格式说明符表示由 DateTimeFormatInfo.SortableDateTimePattern 属性定义的自定义日期和时间格式字符串。该模式反映已定义的标准(ISO 8601)，并且该属性是只读的。因此，无论使用何种区域性或提供格式提供程序，它始终是相同的。自定义格式字符串为 "yyyy'-'MM'-'dd'T'HH':'mm':'ss"。

"s" 格式说明符的用途是生成结果字符串，该字符串根据日期和时间值以升序或降序顺序进行排序。因此，尽管 "s" 标准格式说明符以一致的格式表示日期和时间值，但该格式设置操作不会修改设置为反映其 DateTime.Kind 属性或其 DateTimeOffset.Offset 值的 date 和 time 对象的值。例如，通过设置日期和时间值(2014-11-15T18:32:17+00:00 和 2014-11-15T18:32:17+08:00)的格式生成的结果字符串是相同的。

使用此标准格式说明符时，格式设置或分析操作始终使用固定区域性。</target>
        <note />
      </trans-unit>
      <trans-unit id="symbol_cannot_be_a_namespace">
        <source>'symbol' cannot be a namespace.</source>
        <target state="translated">'“symbol” 不能为命名空间。</target>
        <note />
      </trans-unit>
      <trans-unit id="time_separator">
        <source>time separator</source>
        <target state="translated">时间分隔符</target>
        <note />
      </trans-unit>
      <trans-unit id="time_separator_description">
        <source>The ":" custom format specifier represents the time separator, which is used to differentiate hours, minutes, and seconds. The appropriate localized time separator is retrieved from the DateTimeFormatInfo.TimeSeparator property of the current or specified culture.

Note: To change the time separator for a particular date and time string, specify the separator character within a literal string delimiter. For example, the custom format string hh'_'dd'_'ss produces a result string in which "_" (an underscore) is always used as the time separator. To change the time separator for all dates for a culture, either change the value of the DateTimeFormatInfo.TimeSeparator property of the current culture, or instantiate a DateTimeFormatInfo object, assign the character to its TimeSeparator property, and call an overload of the formatting method that includes an IFormatProvider parameter.

If the ":" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">":" 自定义格式说明符表示用于区分小时、分钟和秒的时间分隔符。可从当前或指定区域性的 DateTimeFormatInfo.TimeSeparator 属性中检索适当的本地化时间分隔符。

注意: 若要更改特定日期和时间字符串的时间分隔符，请在文本字符串分隔符中指定分隔符字符。例如，自定义格式字符串 hh'_'dd'_'ss 生成一个结果字符串，其中 "_" (下划线)始终用作时间分隔符。若要更改某个区域性的所有日期的时间分隔符，请更改当前区域性的 DateTimeFormatInfo.TimeSeparator 属性的值，或者实例化 DateTimeFormatInfo 对象，并将该字符分配给它的 TimeSeparator 属性，然后调用包含 IFormatProvider 参数的格式设置方法的重载。

如果使用 ":" 格式说明符而没有其他自定义格式说明符，则该说明符将被解释为标准日期和时间格式说明符，并引发 FormatException。</target>
        <note />
      </trans-unit>
      <trans-unit id="time_zone">
        <source>time zone</source>
        <target state="translated">时区</target>
        <note />
      </trans-unit>
      <trans-unit id="time_zone_description">
        <source>The "K" custom format specifier represents the time zone information of a date and time value. When this format specifier is used with DateTime values, the result string is defined by the value of the DateTime.Kind property:

    For the local time zone (a DateTime.Kind property value of DateTimeKind.Local), this specifier is equivalent to the "zzz" specifier and produces a result string containing the local offset from Coordinated Universal Time (UTC); for example, "-07:00".

    For a UTC time (a DateTime.Kind property value of DateTimeKind.Utc), the result string includes a "Z" character to represent a UTC date.

    For a time from an unspecified time zone (a time whose DateTime.Kind property equals DateTimeKind.Unspecified), the result is equivalent to String.Empty.

For DateTimeOffset values, the "K" format specifier is equivalent to the "zzz" format specifier, and produces a result string containing the DateTimeOffset value's offset from UTC.

If the "K" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">"K" 自定义格式说明符表示日期和时间值的时区信息。将此格式说明符与 DateTime 值一起使用时，结果字符串由 DateTime.Kind 属性的值定义: 

对于本地时区(DateTimeKind.Local 的 DateTime.Kind 属性值)，此说明符等效于 "zzz" 说明符，并生成包含协调世界时(UTC)的本地偏移量的结果字符串；例如 "-07:00"。

对于 UTC 时间(DateTimeKind.Utc 的 DateTime.Kind 属性值)，结果字符串包含表示 UTC 日期的 "Z" 字符。

对于未指定时区的时间(其 DateTime.Kind 属性等于 DateTimeKind.Unspecified 的时间)，其结果等效于 String.Empty。

对于 DateTimeOffset 值，"K" 格式说明符等效于 "zzz" 格式说明符，并生成一个包含来自 UTC 的 DateTimeOffset 值偏移量的结果字符串。

如果使用 "K" 格式说明符而没有其他自定义格式说明符，则该说明符将被解释为标准日期和时间格式说明符，并引发 FormatException。</target>
        <note />
      </trans-unit>
      <trans-unit id="type_constraint">
        <source>type constraint</source>
        <target state="translated">类型约束</target>
        <note />
      </trans-unit>
      <trans-unit id="type_parameter">
        <source>type parameter</source>
        <target state="translated">类型形参</target>
        <note />
      </trans-unit>
      <trans-unit id="attribute">
        <source>attribute</source>
        <target state="translated">属性</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_and_1_with_property">
        <source>Replace '{0}' and '{1}' with property</source>
        <target state="translated">使用属性替代“{0}”和“{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_property">
        <source>Replace '{0}' with property</source>
        <target state="translated">使用属性替代“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Method_referenced_implicitly">
        <source>Method referenced implicitly</source>
        <target state="translated">隐式引用的方法</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_type_0">
        <source>Generate type '{0}'</source>
        <target state="translated">生成类型“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_0_1">
        <source>Generate {0} '{1}'</source>
        <target state="translated">生成 {0}“{1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_0_to_1">
        <source>Change '{0}' to '{1}'.</source>
        <target state="translated">将“{0}”更改为“{1}”。</target>
        <note />
      </trans-unit>
      <trans-unit id="Non_invoked_method_cannot_be_replaced_with_property">
        <source>Non-invoked method cannot be replaced with property.</source>
        <target state="translated">无法使用属性替代非被调用方法。</target>
        <note />
      </trans-unit>
      <trans-unit id="Only_methods_with_a_single_argument_which_is_not_an_out_variable_declaration_can_be_replaced_with_a_property">
        <source>Only methods with a single argument, which is not an out variable declaration, can be replaced with a property.</source>
        <target state="translated">只有带一个参数，不是化出变量声明的方法可以使用属性进行替换。</target>
        <note />
      </trans-unit>
      <trans-unit id="Roslyn_HostError">
        <source>Roslyn.HostError</source>
        <target state="translated">Roslyn.HostError</target>
        <note />
      </trans-unit>
      <trans-unit id="An_instance_of_analyzer_0_cannot_be_created_from_1_colon_2">
        <source>An instance of analyzer {0} cannot be created from {1}: {2}.</source>
        <target state="translated">无法从 {1}: {2} 创建分析器实例 {0}。</target>
        <note />
      </trans-unit>
      <trans-unit id="The_assembly_0_does_not_contain_any_analyzers">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">程序集 {0} 不包含任何分析器。</target>
        <note />
      </trans-unit>
      <trans-unit id="Unable_to_load_Analyzer_assembly_0_colon_1">
        <source>Unable to load Analyzer assembly {0}: {1}</source>
        <target state="translated">无法加载分析器程序集 {0}: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Make_method_synchronous">
        <source>Make method synchronous</source>
        <target state="translated">使方法同步</target>
        <note />
      </trans-unit>
      <trans-unit id="from_0">
        <source>from {0}</source>
        <target state="translated">自 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Find_and_install_latest_version">
        <source>Find and install latest version</source>
        <target state="translated">查找并安装最新版本</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_local_version_0">
        <source>Use local version '{0}'</source>
        <target state="translated">使用本地版本“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_locally_installed_0_version_1_This_version_used_in_colon_2">
        <source>Use locally installed '{0}' version '{1}'
This version used in: {2}</source>
        <target state="translated">使用本地安装的“{0}”版本“{1}”
此版本用于: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="Find_and_install_latest_version_of_0">
        <source>Find and install latest version of '{0}'</source>
        <target state="translated">查找并安装最新版本的“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_with_package_manager">
        <source>Install with package manager...</source>
        <target state="translated">使用包管理器安装...</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_0_1">
        <source>Install '{0} {1}'</source>
        <target state="translated">安装“{0} {1}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_version_0">
        <source>Install version '{0}'</source>
        <target state="translated">安装版本“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_variable_0">
        <source>Generate variable '{0}'</source>
        <target state="translated">生成变量 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes">
        <source>Classes</source>
        <target state="translated">类</target>
        <note />
      </trans-unit>
      <trans-unit id="Constants">
        <source>Constants</source>
        <target state="translated">常量</target>
        <note />
      </trans-unit>
      <trans-unit id="Delegates">
        <source>Delegates</source>
        <target state="translated">委托</target>
        <note />
      </trans-unit>
      <trans-unit id="Enums">
        <source>Enums</source>
        <target state="translated">枚举</target>
        <note />
      </trans-unit>
      <trans-unit id="Events">
        <source>Events</source>
        <target state="translated">事件</target>
        <note />
      </trans-unit>
      <trans-unit id="Extension_methods">
        <source>Extension methods</source>
        <target state="translated">扩展方法</target>
        <note />
      </trans-unit>
      <trans-unit id="Fields">
        <source>Fields</source>
        <target state="translated">字段</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces">
        <source>Interfaces</source>
        <target state="translated">接口</target>
        <note />
      </trans-unit>
      <trans-unit id="Locals">
        <source>Locals</source>
        <target state="translated">局部变量</target>
        <note />
      </trans-unit>
      <trans-unit id="Methods">
        <source>Methods</source>
        <target state="translated">方法</target>
        <note />
      </trans-unit>
      <trans-unit id="Modules">
        <source>Modules</source>
        <target state="translated">模块</target>
        <note />
      </trans-unit>
      <trans-unit id="Namespaces">
        <source>Namespaces</source>
        <target state="translated">命名空间</target>
        <note />
      </trans-unit>
      <trans-unit id="Properties">
        <source>Properties</source>
        <target state="translated">属性</target>
        <note />
      </trans-unit>
      <trans-unit id="Structures">
        <source>Structures</source>
        <target state="translated">结构</target>
        <note />
      </trans-unit>
      <trans-unit id="Parameters_colon">
        <source>Parameters:</source>
        <target state="translated">参数:</target>
        <note />
      </trans-unit>
      <trans-unit id="Variadic_SignatureHelpItem_must_have_at_least_one_parameter">
        <source>Variadic SignatureHelpItem must have at least one parameter.</source>
        <target state="translated">可变参数 SignatureHelpItem 必须有至少一个参数。</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_method">
        <source>Replace '{0}' with method</source>
        <target state="translated">将“{0}”替换为方法</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_methods">
        <source>Replace '{0}' with methods</source>
        <target state="translated">将“{0}”替换为方法</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_referenced_implicitly">
        <source>Property referenced implicitly</source>
        <target state="translated">隐式引用的属性</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_cannot_safely_be_replaced_with_a_method_call">
        <source>Property cannot safely be replaced with a method call</source>
        <target state="translated">不能将属性安全地替换为方法调用</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_interpolated_string">
        <source>Convert to interpolated string</source>
        <target state="translated">转换为插补字符串</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_type_to_0">
        <source>Move type to {0}</source>
        <target state="translated">将类型移动到 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Rename_file_to_0">
        <source>Rename file to {0}</source>
        <target state="translated">将文件重命名为 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Rename_type_to_0">
        <source>Rename type to {0}</source>
        <target state="translated">将类型重命名为 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_tag">
        <source>Remove tag</source>
        <target state="translated">删除标记</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_missing_param_nodes">
        <source>Add missing param nodes</source>
        <target state="translated">添加缺少的参数节点</target>
        <note />
      </trans-unit>
      <trans-unit id="Make_containing_scope_async">
        <source>Make containing scope async</source>
        <target state="translated">将包含范围改为 Async</target>
        <note />
      </trans-unit>
      <trans-unit id="Make_containing_scope_async_return_Task">
        <source>Make containing scope async (return Task)</source>
        <target state="translated">将包含范围改为 Async (返回“任务”)</target>
        <note />
      </trans-unit>
      <trans-unit id="paren_Unknown_paren">
        <source>(Unknown)</source>
        <target state="translated">(未知)</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_framework_type">
        <source>Use framework type</source>
        <target state="translated">使用框架类型</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_package_0">
        <source>Install package '{0}'</source>
        <target state="translated">安装包“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="project_0">
        <source>project {0}</source>
        <target state="translated">项目 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Fully_qualify_0">
        <source>Fully qualify '{0}'</source>
        <target state="translated">完全限定“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_reference_to_0">
        <source>Remove reference to '{0}'.</source>
        <target state="translated">删除对“{0}”的引用。</target>
        <note />
      </trans-unit>
      <trans-unit id="Keywords">
        <source>Keywords</source>
        <target state="translated">关键字</target>
        <note />
      </trans-unit>
      <trans-unit id="Snippets">
        <source>Snippets</source>
        <target state="translated">片段</target>
        <note />
      </trans-unit>
      <trans-unit id="All_lowercase">
        <source>All lowercase</source>
        <target state="translated">全部小写</target>
        <note />
      </trans-unit>
      <trans-unit id="All_uppercase">
        <source>All uppercase</source>
        <target state="translated">全部大写</target>
        <note />
      </trans-unit>
      <trans-unit id="First_word_capitalized">
        <source>First word capitalized</source>
        <target state="translated">第一个单词首字母大写</target>
        <note />
      </trans-unit>
      <trans-unit id="Pascal_Case">
        <source>Pascal Case</source>
        <target state="translated">帕斯卡拼写法</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_document_0">
        <source>Remove document '{0}'</source>
        <target state="translated">删除文档“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_document_0">
        <source>Add document '{0}'</source>
        <target state="translated">添加文档“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_argument_name_0">
        <source>Add argument name '{0}'</source>
        <target state="translated">添加参数名“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Take_0">
        <source>Take '{0}'</source>
        <target state="translated">采用“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Take_both">
        <source>Take both</source>
        <target state="translated">二者均采用</target>
        <note />
      </trans-unit>
      <trans-unit id="Take_bottom">
        <source>Take bottom</source>
        <target state="translated">采用底值</target>
        <note />
      </trans-unit>
      <trans-unit id="Take_top">
        <source>Take top</source>
        <target state="translated">采用顶值</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unused_variable">
        <source>Remove unused variable</source>
        <target state="translated">删除未使用的变量</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_binary">
        <source>Convert to binary</source>
        <target state="translated">转换为二进制</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_decimal">
        <source>Convert to decimal</source>
        <target state="translated">转换为十进制</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_hex">
        <source>Convert to hex</source>
        <target state="translated">转换为十六进制</target>
        <note />
      </trans-unit>
      <trans-unit id="Separate_thousands">
        <source>Separate thousands</source>
        <target state="translated">分隔千分位</target>
        <note />
      </trans-unit>
      <trans-unit id="Separate_words">
        <source>Separate words</source>
        <target state="translated">分隔单词</target>
        <note />
      </trans-unit>
      <trans-unit id="Separate_nibbles">
        <source>Separate nibbles</source>
        <target state="translated">分隔半字节</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_separators">
        <source>Remove separators</source>
        <target state="translated">删除分隔符</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_parameter_to_0">
        <source>Add parameter to '{0}'</source>
        <target state="translated">将参数添加到“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constructor">
        <source>Generate constructor...</source>
        <target state="translated">生成构造函数...</target>
        <note />
      </trans-unit>
      <trans-unit id="Pick_members_to_be_used_as_constructor_parameters">
        <source>Pick members to be used as constructor parameters</source>
        <target state="translated">选择成员用作构造函数参数</target>
        <note />
      </trans-unit>
      <trans-unit id="Pick_members_to_be_used_in_Equals_GetHashCode">
        <source>Pick members to be used in Equals/GetHashCode</source>
        <target state="translated">选择成员用于 Equals/GetHashCode</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_overrides">
        <source>Generate overrides...</source>
        <target state="translated">生成重写...</target>
        <note />
      </trans-unit>
      <trans-unit id="Pick_members_to_override">
        <source>Pick members to override</source>
        <target state="translated">选择成员进行重写</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_null_check">
        <source>Add null check</source>
        <target state="translated">添加 null 检查</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_string_IsNullOrEmpty_check">
        <source>Add 'string.IsNullOrEmpty' check</source>
        <target state="translated">添加 "string.IsNullOrEmpty" 检查</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_string_IsNullOrWhiteSpace_check">
        <source>Add 'string.IsNullOrWhiteSpace' check</source>
        <target state="translated">添加 "string.IsNullOrWhiteSpace" 检查</target>
        <note />
      </trans-unit>
      <trans-unit id="Initialize_field_0">
        <source>Initialize field '{0}'</source>
        <target state="translated">初始化字段“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Initialize_property_0">
        <source>Initialize property '{0}'</source>
        <target state="translated">初始化属性“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_null_checks">
        <source>Add null checks</source>
        <target state="translated">添加 null 检查</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_operators">
        <source>Generate operators</source>
        <target state="translated">生成运算符</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_0">
        <source>Implement {0}</source>
        <target state="translated">实现 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Reported_diagnostic_0_has_a_source_location_in_file_1_which_is_not_part_of_the_compilation_being_analyzed">
        <source>Reported diagnostic '{0}' has a source location in file '{1}', which is not part of the compilation being analyzed.</source>
        <target state="translated">报告的诊断“{0}”的源位置位于文件“{1}”中，后者不是要分析的编译的一部分。</target>
        <note />
      </trans-unit>
      <trans-unit id="Reported_diagnostic_0_has_a_source_location_1_in_file_2_which_is_outside_of_the_given_file">
        <source>Reported diagnostic '{0}' has a source location '{1}' in file '{2}', which is outside of the given file.</source>
        <target state="translated">报告的诊断“{0}”的源位置“{1}”位于文件“{2}”中，后者不是给定文件。</target>
        <note />
      </trans-unit>
      <trans-unit id="in_0_project_1">
        <source>in {0} (project {1})</source>
        <target state="translated">在 {0} (项目 {1})中</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_accessibility_modifiers">
        <source>Add accessibility modifiers</source>
        <target state="translated">添加可访问性修饰符</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_declaration_near_reference">
        <source>Move declaration near reference</source>
        <target state="translated">将声明移动至引用附近</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_full_property">
        <source>Convert to full property</source>
        <target state="translated">转换为完整属性</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_Method_overrides_symbol_from_metadata">
        <source>Warning: Method overrides symbol from metadata</source>
        <target state="translated">警告: 方法将替代元数据中的符号</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_0">
        <source>Use {0}</source>
        <target state="translated">使用 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Switching_between_lambda_and_local_function_will_prevent_the_debug_session_from_continuing">
        <source>Switching between a lambda and a local function will prevent the debug session from continuing.</source>
        <target state="translated">在 lambda 与本地函数之间切换可能会导致无法继续调试会话。</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_argument_name_0_including_trailing_arguments">
        <source>Add argument name '{0}' (including trailing arguments)</source>
        <target state="translated">添加参数名“{0}”(包括尾随参数)</target>
        <note />
      </trans-unit>
      <trans-unit id="local_function">
        <source>local function</source>
        <target state="translated">本地函数</target>
        <note />
      </trans-unit>
      <trans-unit id="indexer_">
        <source>indexer</source>
        <target state="translated">索引器</target>
        <note />
      </trans-unit>
      <trans-unit id="Alias_ambiguous_type_0">
        <source>Alias ambiguous type '{0}'</source>
        <target state="translated">别名多义类型“{0}”</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_Collection_was_modified_during_iteration">
        <source>Warning: Collection was modified during iteration.</source>
        <target state="translated">警告: 迭代期间已修改集合。</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_Iteration_variable_crossed_function_boundary">
        <source>Warning: Iteration variable crossed function boundary.</source>
        <target state="translated">警告: 迭代变量跨函数边界。</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_Collection_may_be_modified_during_iteration">
        <source>Warning: Collection may be modified during iteration.</source>
        <target state="translated">警告: 迭代期间可能修改集合。</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_full_date_time">
        <source>universal full date/time</source>
        <target state="translated">通用完整日期/时间</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_full_date_time_description">
        <source>The "U" standard format specifier represents a custom date and time format string that is defined by a specified culture's DateTimeFormatInfo.FullDateTimePattern property. The pattern is the same as the "F" pattern. However, the DateTime value is automatically converted to UTC before it is formatted.</source>
        <target state="translated">"U" 标准格式说明符表示由指定区域性的 DateTimeFormatInfo.FullDateTimePattern 属性定义的自定义日期和时间格式字符串。模式与 "F" 模式相同。但在 DateTime 值进行格式设置之前，该值将自动转换为 UTC。</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_sortable_date_time">
        <source>universal sortable date/time</source>
        <target state="translated">通用可排序日期/时间</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_sortable_date_time_description">
        <source>The "u" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.UniversalSortableDateTimePattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "yyyy'-'MM'-'dd HH':'mm':'ss'Z'". When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.

Although the result string should express a time as Coordinated Universal Time (UTC), no conversion of the original DateTime value is performed during the formatting operation. Therefore, you must convert a DateTime value to UTC by calling the DateTime.ToUniversalTime method before formatting it.</source>
        <target state="translated">"U" 标准格式说明符表示由 DateTimeFormatInfo.UniversalSortableDateTimePattern 属性定义的自定义日期和时间格式字符串。模式反映已定义的标准，并且属性是只读的。因此，无论使用何种区域性或提供格式提供程序，它始终是相同的。自定义格式字符串为 "yyyy'-'MM'-'dd HH':'mm':'ss'Z'"。使用此标准格式说明符时，格式设置或分析操作始终使用固定区域性。

虽然结果字符串应将时间表示为协调世界时(UTC)，但在格式设置操作期间不执行原始日期时间值的转换。因此，在设置 DateTime 格式之前，必须通过调用 DateTime.ToUniversalTime 方法将 DateTime 值转换为 UTC。</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_containing_member">
        <source>updating usages in containing member</source>
        <target state="translated">更新包含成员的用法</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_containing_project">
        <source>updating usages in containing project</source>
        <target state="translated">更新包含项目中的用法</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_containing_type">
        <source>updating usages in containing type</source>
        <target state="translated">更新包含类型中的用法</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_dependent_projects">
        <source>updating usages in dependent projects</source>
        <target state="translated">更新相关项目中的用法</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_and_minute_offset">
        <source>utc hour and minute offset</source>
        <target state="translated">utc 小时和分钟偏移量</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_and_minute_offset_description">
        <source>With DateTime values, the "zzz" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours and minutes. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "zzz" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours and minutes.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted with a leading zero.</source>
        <target state="translated">对于 DateTime 值，"zzz" 自定义格式说明符表示本地操作系统的时区与 UTC 的有符号偏移量，以小时和分钟度量。它不反映实例的 DateTime.Kind 属性的值。因此，不建议将 "zzz" 格式说明符用于 DateTime 值。

对于 DateTimeOffset 值，此格式说明符表示 DateTimeOffset 值与 UTC 的偏移量(以小时和分钟为单位)。

偏移量始终显示为带有前导符号。加号(+)表示小时数早于 UTC，减号(-)指示小时数迟于 UTC。一位数字的偏移量设置为带前导零的格式。</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_1_2_digits">
        <source>utc hour offset (1-2 digits)</source>
        <target state="translated">utc 小时偏移量(1-2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_1_2_digits_description">
        <source>With DateTime values, the "z" custom format specifier represents the signed offset of the local operating system's time zone from Coordinated Universal Time (UTC), measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "z" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted without a leading zero.

If the "z" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">对于 DateTime 值，"z" 自定义格式说明符表示本地操作系统的时区与协调世界时(UTC)的有符号偏移量(以小时为单位)。它不反映实例的 DateTime.Kind 属性的值。因此，不建议将 "z" 格式说明符用于 DateTime 值。

对于 DateTimeOffset 值，此格式说明符表示 DateTimeOffset 值与 UTC 的偏移量(以小时为单位)。

偏移量始终显示为带有前导符号。加号(+)表示小时数早于 UTC，减号(-)表示小时数迟于 UTC。一位数字的偏移量设置为不带前导零的格式。

如果使用 "z" 格式说明符而没有其他自定义格式说明符，则该说明符将被解释为标准日期和时间格式说明符，并引发 FormatException。</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_2_digits">
        <source>utc hour offset (2 digits)</source>
        <target state="translated">utc 小时偏移量(2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_2_digits_description">
        <source>With DateTime values, the "zz" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "zz" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted with a leading zero.</source>
        <target state="translated">对于 DateTime 值，"zz" 自定义格式说明符表示本地操作系统的时区与 UTC 之间的有符号偏移量(以小时为单位)。它不反映实例的 DateTime.Kind 属性的值。因此，建议不要将 "zz" 格式说明符与 DateTime 值一起使用。

对于 DateTimeOffset 值，此格式说明符表示 DateTimeOffset 值与 UTC 的偏移量(以小时为单位)。

偏移量始终显示为带前导的符号。加号(+)表示小时数早于 UTC，减号(-)表示小时数迟于 UTC。一位数字的偏移量设置为带前导零的格式。</target>
        <note />
      </trans-unit>
      <trans-unit id="x_y_range_in_reverse_order">
        <source>[x-y] range in reverse order</source>
        <target state="translated">按相反顺序排列的 [x-y] 范围</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [b-a]</note>
      </trans-unit>
      <trans-unit id="year_1_2_digits">
        <source>year (1-2 digits)</source>
        <target state="translated">年(1-2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_1_2_digits_description">
        <source>The "y" custom format specifier represents the year as a one-digit or two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the first digit of a two-digit year begins with a zero (for example, 2008), the number is formatted without a leading zero.

If the "y" format specifier is used without other custom format specifiers, it's interpreted as the "y" standard date and time format specifier.</source>
        <target state="translated">"Y" 自定义格式说明符将年份表示为一位数字或两位数的数字。如果年份具有两个以上的数字，则结果中仅显示两个低序位数字。如果两位数年份的第一个数字以零开头(例如 2008)，则该数字的格式没有前导零。

如果使用 "y" 格式说明符而没有其他自定义格式说明符，则该说明符将被解释为 "y" 标准日期和时间格式说明符。</target>
        <note />
      </trans-unit>
      <trans-unit id="year_2_digits">
        <source>year (2 digits)</source>
        <target state="translated">年(2 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_2_digits_description">
        <source>The "yy" custom format specifier represents the year as a two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the two-digit year has fewer than two significant digits, the number is padded with leading zeros to produce two digits.

In a parsing operation, a two-digit year that is parsed using the "yy" custom format specifier is interpreted based on the Calendar.TwoDigitYearMax property of the format provider's current calendar. The following example parses the string representation of a date that has a two-digit year by using the default Gregorian calendar of the en-US culture, which, in this case, is the current culture. It then changes the current culture's CultureInfo object to use a GregorianCalendar object whose TwoDigitYearMax property has been modified.</source>
        <target state="translated">"yy" 自定义格式说明符将年份表示为两位数字。如果年份具有两个以上的数字，则结果中仅显示两个低序位数字。如果两位数的年份的有效数字少于两个，则用前导零填充该数字以生成两个数字。

在分析操作中，使用 "yy" 自定义格式说明符分析的两位数年份根据格式提供程序当前日历的 Calendar.TwoDigitYearMax 属性进行解释。下面的示例使用 en-US 区域性的默认公历日历(在本例中为当前区域性)分析具有两位数年份的日期的字符串表示形式。然后更改当前区域性的 CultureInfo 对象，以使用其 TwoDigitYearMax 属性已被修改的 GregorianCalendar 对象。</target>
        <note />
      </trans-unit>
      <trans-unit id="year_3_4_digits">
        <source>year (3-4 digits)</source>
        <target state="translated">年(3-4 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_3_4_digits_description">
        <source>The "yyy" custom format specifier represents the year with a minimum of three digits. If the year has more than three significant digits, they are included in the result string. If the year has fewer than three digits, the number is padded with leading zeros to produce three digits.</source>
        <target state="translated">"yyy" 自定义格式说明符表示最少为三位的年份。如果年份有三个以上的有效数字，则结果字符串中会显示所有数字。如果年份少于三位数，则用前导零填充该数字以生成三位数。</target>
        <note />
      </trans-unit>
      <trans-unit id="year_4_digits">
        <source>year (4 digits)</source>
        <target state="translated">年(4 位数字)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_4_digits_description">
        <source>The "yyyy" custom format specifier represents the year with a minimum of four digits. If the year has more than four significant digits, they are included in the result string. If the year has fewer than four digits, the number is padded with leading zeros to produce four digits.</source>
        <target state="translated">"yyyy" 自定义格式说明符表示最少为四位的年份。如果年份有四个以上的有效数字，则结果字符串中会显示所有数字。如果年份少于四位数，则用前导零填充该数字以生成四位数。</target>
        <note />
      </trans-unit>
      <trans-unit id="year_5_digits">
        <source>year (5 digits)</source>
        <target state="translated">年(5 位数)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_5_digits_description">
        <source>The "yyyyy" custom format specifier (plus any number of additional "y" specifiers) represents the year with a minimum of five digits. If the year has more than five significant digits, they are included in the result string. If the year has fewer than five digits, the number is padded with leading zeros to produce five digits.

If there are additional "y" specifiers, the number is padded with as many leading zeros as necessary to produce the number of "y" specifiers.</source>
        <target state="translated">"yyyyy" 自定义格式说明符(另加任意数量的其他 "y" 说明符)表示最少为五位年份。如果年份具有五个以上的有效数字，则结果字符串中会显示所有数字。如果年份少于五位，则用前导零填充该数字以生成五个数字。

如果有其他 "y" 说明符，则用所需数量的前导零填充该数字，以生成 "y" 说明符。</target>
        <note />
      </trans-unit>
      <trans-unit id="year_month">
        <source>year month</source>
        <target state="translated">年月</target>
        <note />
      </trans-unit>
      <trans-unit id="year_month_description">
        <source>The "Y" or "y" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.YearMonthPattern property of a specified culture. For example, the custom format string for the invariant culture is "yyyy MMMM".</source>
        <target state="translated">"Y" 或 "y" 标准格式说明符表示由指定区域性的 DateTimeFormatInfo.YearMonthPattern 属性定义的自定义日期和时间格式字符串。例如，固定区域性的自定义格式字符串为 "yyyy MMMM"。</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>