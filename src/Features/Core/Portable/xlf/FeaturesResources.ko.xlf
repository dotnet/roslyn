<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../FeaturesResources.resx">
    <body>
      <trans-unit id="0_directive">
        <source>#{0} directive</source>
        <target state="translated">#{0} 지시문</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_abbreviated">
        <source>AM/PM (abbreviated)</source>
        <target state="translated">AM/PM(약식)</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_abbreviated_description">
        <source>The "t" custom format specifier represents the first character of the AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property of the current or specific culture. The AM designator is used for all times from 0:00:00 (midnight) to 11:59:59.999. The PM designator is used for all times from 12:00:00 (noon) to 23:59:59.999.

If the "t" format specifier is used without other custom format specifiers, it's interpreted as the "t" standard date and time format specifier.</source>
        <target state="translated">"t" 사용자 지정 형식 지정자는 AM/PM 지정자의 첫 번째 문자를 나타냅니다. 지역화된 적절한 지정자는 현재 문화권 또는 특정 문화권의 DateTimeFormatInfo.AMDesignator 또는 DateTimeFormatInfo.PMDesignator 속성에서 검색됩니다. AM 지정자는 0:00:00(자정)부터 11:59:59.999까지의 모든 시간에 사용됩니다. PM 지정자는 12:00:00(정오)부터 23:59:59.999까지의 모든 시간에 사용됩니다.

다른 사용자 지정 형식 지정자 없이 "t" 형식 지정자를 사용하면 "t" 표준 날짜 및 시간 형식 지정자로 해석됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_full">
        <source>AM/PM (full)</source>
        <target state="translated">AM/PM(전체)</target>
        <note />
      </trans-unit>
      <trans-unit id="AM_PM_full_description">
        <source>The "tt" custom format specifier (plus any number of additional "t" specifiers) represents the entire AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property of the current or specific culture. The AM designator is used for all times from 0:00:00 (midnight) to 11:59:59.999. The PM designator is used for all times from 12:00:00 (noon) to 23:59:59.999.

Make sure to use the "tt" specifier for languages for which it's necessary to maintain the distinction between AM and PM. An example is Japanese, for which the AM and PM designators differ in the second character instead of the first character.</source>
        <target state="translated">"tt" 사용자 지정 형식 지정자(및 임의 개수의 추가 "t" 지정자)는 전체 AM/PM 지정자를 나타냅니다. 지역화된 적절한 지정자는 현재 문화권 또는 특정 문화권의 DateTimeFormatInfo.AMDesignator 또는 DateTimeFormatInfo.PMDesignator 속성에서 검색됩니다. AM 지정자는 0:00:00(자정)부터 11:59:59.999까지의 모든 시간에 사용됩니다. PM 지정자는 12:00:00(정오)부터 23:59:59.999까지의 모든 시간에 사용됩니다.

"tt" 지정자는 AM과 PM 사이의 구분을 유지해야 하는 언어에 사용해야 합니다. 그 예로 일본어를 들 수 있는데, 일본어에서는 AM 지정자와 PM 지정자가 첫 번째 문자가 아닌 두 번째 문자에서 구분됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="A_subtraction_must_be_the_last_element_in_a_character_class">
        <source>A subtraction must be the last element in a character class</source>
        <target state="translated">빼기는 문자 클래스의 마지막 요소여야 합니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-[b]-c]</note>
      </trans-unit>
      <trans-unit id="Add_0_check">
        <source>Add '{0}' check</source>
        <target state="new">Add '{0}' check</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_DebuggerDisplay_attribute">
        <source>Add 'DebuggerDisplay' attribute</source>
        <target state="translated">'DebuggerDisplay' 특성을 추가합니다.</target>
        <note>{Locked="DebuggerDisplay"} "DebuggerDisplay" is a BCL class and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Add_negative_value_check">
        <source>Add negative value check</source>
        <target state="new">Add negative value check</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_negative_value_or_zero_check">
        <source>Add negative value or zero check</source>
        <target state="new">Add negative value or zero check</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_null_checks_for_all_parameters">
        <source>Add null checks for all parameters</source>
        <target state="translated">모든 매개 변수에 대한 null 검사 추가</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_optional_parameter_to_constructor">
        <source>Add optional parameter to constructor</source>
        <target state="translated">생성자에 선택적 매개 변수 추가</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_parameter_to_constructor">
        <source>Add parameter to constructor</source>
        <target state="translated">생성자에 매개 변수 추가</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_project_reference_to_0">
        <source>Add project reference to '{0}'.</source>
        <target state="translated">프로젝트 참조를 '{0}'에 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_reference_to_0">
        <source>Add reference to '{0}'.</source>
        <target state="translated">참조를 '{0}'에 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Actions_can_not_be_empty">
        <source>Actions can not be empty.</source>
        <target state="translated">작업은 비워 둘 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_tuple_element_name_0">
        <source>Add tuple element name '{0}'</source>
        <target state="translated">튜플 요소 이름 '{0}' 추가</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_around_an_active_statement_requires_restarting_the_application">
        <source>Adding {0} around an active statement requires restarting the application.</source>
        <target state="translated">활성 문 주위에 {0}을(를) 추가하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_an_interface_method_requires_restarting_the_application">
        <source>Adding {0} into an interface method requires restarting the application.</source>
        <target state="translated">인터페이스 메소드에 {0}을(를) 추가하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_into_an_interface_requires_restarting_the_application">
        <source>Adding {0} into an interface requires restarting the application.</source>
        <target state="translated">인터페이스에 {0}을(를) 추가하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_requires_restarting_the_application">
        <source>Adding {0} requires restarting the application.</source>
        <target state="translated">{0}을(를) 추가하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_0_with_the_Handles_clause_requires_restarting_the_application">
        <source>Adding {0} with the Handles clause requires restarting the application.</source>
        <target state="translated">Handles 절과 함께 {0}을(를) 추가하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note>{Locked="Handles"} "Handles" is VB keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Adding_a_MustOverride_0_or_overriding_an_inherited_0_requires_restarting_the_application">
        <source>Adding a MustOverride {0} or overriding an inherited {0} requires restarting the application.</source>
        <target state="translated">MustOverride {0}를 추가하거나 상속된 {0}를 재정의하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note>{Locked="MustOverride"} "MustOverride" is VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Adding_a_constructor_to_a_type_with_a_field_or_property_initializer_that_contains_an_anonymous_function_requires_restarting_the_application">
        <source>Adding a constructor to a type with a field or property initializer that contains an anonymous function requires restarting the application.</source>
        <target state="translated">익명 함수가 포함된 필드 또는 속성 이니셜라이저가 있는 형식에 생성자를 추가하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_method_with_an_explicit_interface_specifier_requires_restarting_the_application">
        <source>Adding a method with an explicit interface specifier requires restarting the application.</source>
        <target state="translated">명시적 인터페이스 지정자를 사용하여 메서드를 추가하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_new_file_requires_restarting_the_application">
        <source>Adding a new file requires restarting the application.</source>
        <target state="translated">새 파일을 추가하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_a_user_defined_0_requires_restarting_the_application">
        <source>Adding a user defined {0} requires restarting the application.</source>
        <target state="translated">사용자 정의 {0}을(를) 추가하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_an_abstract_0_or_overriding_an_inherited_0_requires_restarting_the_application">
        <source>Adding an abstract {0} or overriding an inherited {0} requires restarting the application.</source>
        <target state="translated">추상 {0}을(를) 추가하거나 상속된 {0}을(를) 재정의하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_an_extern_0_requires_restarting_the_application">
        <source>Adding an extern {0} requires restarting the application.</source>
        <target state="translated">extern {0}을(를) 추가하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note>{Locked="extern"} "extern" is C# keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Adding_an_imported_method_requires_restarting_the_application">
        <source>Adding an imported method requires restarting the application.</source>
        <target state="translated">가져온 메서드를 추가하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_or_moving_0_of_1_requires_restarting_the_application">
        <source>Adding or moving {0} of {1} requires restarting the application.</source>
        <target state="translated">{1} {0} 추가하거나 이동하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_or_moving_0_of_1_with_explicit_or_sequential_layout_requires_restarting_the_application">
        <source>Adding or moving {0} of {1} with explicit or sequential layout requires restarting the application.</source>
        <target state="translated">명시적 또는 순차적 레이아웃으로 {1}개 중 {0}개를 추가하거나 이동하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_or_moving_0_of_a_COM_interface_requires_restarting_the_application">
        <source>Adding or moving {0} of a COM interface requires restarting the application.</source>
        <target state="translated">COM 인터페이스의 {0} 추가하거나 이동하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Align_wrapped_arguments">
        <source>Align wrapped arguments</source>
        <target state="translated">래핑된 인수 맞춤</target>
        <note />
      </trans-unit>
      <trans-unit id="Align_wrapped_parameters">
        <source>Align wrapped parameters</source>
        <target state="translated">래핑된 매개 변수 맞춤</target>
        <note />
      </trans-unit>
      <trans-unit id="Alternation_conditions_cannot_be_comments">
        <source>Alternation conditions cannot be comments</source>
        <target state="translated">교체 조건은 주석이 될 수 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a|(?#b)</note>
      </trans-unit>
      <trans-unit id="Alternation_conditions_do_not_capture_and_cannot_be_named">
        <source>Alternation conditions do not capture and cannot be named</source>
        <target state="translated">교체 조건은 캡처하지 않고 이름을 지정할 수 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(?'x'))</note>
      </trans-unit>
      <trans-unit id="An_update_that_causes_the_return_type_of_implicit_main_to_change_requires_restarting_the_application">
        <source>An update that causes the return type of the implicit Main method to change requires restarting the application.</source>
        <target state="translated">암시적 Main 메서드의 반환 유형이 변경되도록 하는 업데이트는 응용 프로그램을 다시 시작해야 합니다.</target>
        <note>{Locked="Main"} is C# keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Apply_auto_property_preferences">
        <source>Apply auto property preferences</source>
        <target state="translated">자동 속성 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_blank_line_preferences_experimental">
        <source>Apply blank line preferences (experimental)</source>
        <target state="translated">빈 줄 적용 기본 설정(실험적)</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_coalesce_expression_preferences">
        <source>Apply coalesce expression preferences</source>
        <target state="translated">병합 식 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_compound_assignment_preferences">
        <source>Apply compound assignment preferences</source>
        <target state="translated">복합 할당 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_conditional_expression_preferences">
        <source>Apply conditional expression preferences</source>
        <target state="translated">조건식 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_file_header_preferences">
        <source>Apply file header preferences</source>
        <target state="translated">파일 헤더 기본 설정 적용</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_inferred_anonymous_type_member_names_preferences">
        <source>Apply inferred anonymous type member names preferences</source>
        <target state="translated">유추된 무명 형식 멤버 이름 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_language_framework_type_preferences">
        <source>Apply language/framework type preferences</source>
        <target state="translated">언어/프레임워크 형식 기본 설정 적용</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_namespace_matches_folder_preferences">
        <source>Apply namespace matches folder preferences</source>
        <target state="translated">네임스페이스와 폴더 일치 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_null_checking_preferences">
        <source>Apply null checking preferences</source>
        <target state="translated">Null 검사 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_null_propagation_preferences">
        <source>Apply null propagation preferences</source>
        <target state="translated">Null 전파 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_object_collection_initialization_preferences">
        <source>Apply object/collection initialization preferences</source>
        <target state="translated">개체/컬렉션 초기화 기본 설정 적용</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_object_initializer_preferences">
        <source>Apply object initializer preferences</source>
        <target state="translated">개체 이니셜라이저 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_parentheses_preferences">
        <source>Apply parentheses preferences</source>
        <target state="translated">괄호 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_simplify_boolean_expression_preferences">
        <source>Apply simplify boolean expression preferences</source>
        <target state="translated">부울 식 간소화 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_statement_after_block_preferences_experimental">
        <source>Apply statement after block preferences (experimental)</source>
        <target state="translated">블록 뒤에 문 적용 기본 설정(실험적)</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_string_interpolation_preferences">
        <source>Apply string interpolation preferences</source>
        <target state="translated">문자열 보간 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_tuple_name_preferences">
        <source>Apply tuple name preferences</source>
        <target state="translated">튜플 이름 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_unused_value_preferences">
        <source>Apply unused value preferences</source>
        <target state="translated">사용하지 않는 값 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Apply_using_directive_placement_preferences">
        <source>Apply using directive placement preferences</source>
        <target state="translated">Using 지시문 배치 적용 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Applying_source_changes_while_the_application_is_running_is_not_supported_by_the_runtime">
        <source>Applying source changes while the application is running is not supported by the runtime.</source>
        <target state="translated">애플리케이션이 실행되는 동안 원본 변경 사항을 적용하는 것은 런타임에서 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Attribute_0_is_missing_Updating_an_async_method_or_an_iterator_requires_restarting_the_application">
        <source>Attribute '{0}' is missing. Updating an async method or an iterator requires restarting the application.</source>
        <target state="translated">특성 '{0}'이(가) 없습니다. 비동기 메서드 또는 반복기를 업데이트하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Asynchronously_waits_for_the_task_to_finish">
        <source>Asynchronously waits for the task to finish.</source>
        <target state="translated">작업이 완료될 때까지 비동기적으로 기다립니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Await_the_preceding_expression">
        <source>Await the preceding expression</source>
        <target state="translated">이전 식을 기다립니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Await_the_preceding_expression_and_add_ConfigureAwait_0">
        <source>Await the preceding expression and add ConfigureAwait({0}).</source>
        <target state="translated">이전 식을 기다리고 ConfigureAwait({0})를 추가합니다.</target>
        <note>{Locked="ConfigureAwait"} "ConfigureAwait" is an api name and should not be localized. {0} is a placeholder for the language specific keyword 'false'.</note>
      </trans-unit>
      <trans-unit id="Awaited_task_returns_0">
        <source>Awaited task returns {0}</source>
        <target state="translated">대기된 작업에서 {0}이(가) 반환됨</target>
        <note />
      </trans-unit>
      <trans-unit id="Awaited_task_returns_no_value">
        <source>Awaited task returns no value</source>
        <target state="translated">대기된 작업에서 값이 반환되지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="CSharp_VisualBasic_References">
        <source>C# and Visual Basic References</source>
        <target state="translated">C# 및 Visual Basic 참조</target>
        <note />
      </trans-unit>
      <trans-unit id="CannotApplyChangesUnexpectedError">
        <source>Cannot apply changes -- unexpected error: '{0}'</source>
        <target state="translated">변경 내용을 적용할 수 없음 -- 예기치 않은 오류: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_determine_valid_range_of_statements_to_extract">
        <source>Cannot determine valid range of statements to extract</source>
        <target state="translated">추출할 문의 유효한 범위를 결정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_include_class_0_in_character_range">
        <source>Cannot include class \{0} in character range</source>
        <target state="translated">문자 범위에 \{0} 클래스를 포함할 수 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-\w]. {0} is the invalid class (\w here)</note>
      </trans-unit>
      <trans-unit id="Cannot_navigate_to_the_symbol_under_the_caret">
        <source>Cannot navigate to the symbol under the caret.</source>
        <target state="translated">캐럿에서 기호를 탐색할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Capture_number_cannot_be_zero">
        <source>Capture number cannot be zero</source>
        <target state="translated">캡처 번호는 0일 수 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;0&gt;a)</note>
      </trans-unit>
      <trans-unit id="Capturing_primary_constructor_parameter_0_that_hasn_t_been_captured_before_requires_restarting_the_application">
        <source>Capturing primary constructor parameter '{0}' that hasn't been capture before requires restarting the application.</source>
        <target state="translated">캡처되지 않은 '{0}' 기본 생성자 매개 변수를 캡처하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Ceasing_to_capture_primary_constructor_parameter_0_of_1_requires_restarting_the_application">
        <source>Ceasing to capture primary constructor parameter '{0}' of '{1}' requires restarting the application.</source>
        <target state="translated">'{0}'/‘{1}’ 기본 생성자 매개 변수를 캡처를 중지하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeSignature_NewParameterInferValue">
        <source>&lt;infer&gt;</source>
        <target state="translated">&lt;유추&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangeSignature_NewParameterIntroduceTODOVariable">
        <source>TODO</source>
        <target state="translated">TODO</target>
        <note>"TODO" is an indication that there is work still to be done.</note>
      </trans-unit>
      <trans-unit id="ChangeSignature_NewParameterOmitValue">
        <source>&lt;omit&gt;</source>
        <target state="translated">&lt;생략&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_namespace_to_0">
        <source>Change namespace to '{0}'</source>
        <target state="translated">네임스페이스를 '{0}'(으)로 변경</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_to_global_namespace">
        <source>Change to global namespace</source>
        <target state="translated">전역 네임스페이스로 변경</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangesDisallowedWhileStoppedAtException">
        <source>Changes are not allowed while stopped at exception</source>
        <target state="translated">예외에서 중지된 동안에는 변경할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="ChangesRequiredSynthesizedType">
        <source>One or more changes result in a new type being created by the compiler, which requires restarting the application because it is not supported by the runtime</source>
        <target state="translated">하나 이상의 변경으로 인해 컴파일러에서 새 유형이 생성되며 런타임에서 지원하지 않기 때문에 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_0_from_asynchronous_to_synchronous_requires_restarting_the_application">
        <source>Changing {0} from asynchronous to synchronous requires restarting the application.</source>
        <target state="translated">비동기에서 동기로 {0}을(를) 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_0_might_not_have_any_effect_until_the_application_is_restarted">
        <source>Changing '{0}' might not have any effect until the application is restarted.</source>
        <target state="translated">애플리케이션을 다시 시작할 때까지는 '{0}'을(를) 변경해도 아무것도 적용되지 않을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_0_to_1_requires_restarting_the_application_because_it_changes_the_shape_of_the_state_machine">
        <source>Changing '{0}' to '{1}' requires restarting the application because it changes the shape of the state machine.</source>
        <target state="translated">'{0}'을(를) '{1}'(으)로 변경하려면 상태 시스템의 모양을 변경하므로 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_a_field_to_an_event_or_vice_versa_requires_restarting_the_application">
        <source>Changing a field to an event or vice versa requires restarting the application.</source>
        <target state="translated">필드를 이벤트로 변경하거나 그 반대로 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_attribute_0_requires_restarting_the_application">
        <source>Changing attribute '{0}' requires restarting the application.</source>
        <target state="translated">'{0}' 특성을 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_constraints_of_0_requires_restarting_the_application">
        <source>Changing constraints of {0} requires restarting the application.</source>
        <target state="translated">{0} 제약 조건을 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_name_or_signature_of_0_that_contains_an_active_statement_requires_restarting_the_application">
        <source>Changing attribute '{0}' requires restarting the application.</source>
        <target state="translated">'{0}' 특성을 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_parameter_types_of_0_requires_restarting_the_application">
        <source>Changing parameter types of {0} requires restarting the application.</source>
        <target state="translated">{0}의 매개 변수 유형을 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_project_or_package_reference_caused_the_identity_of_referenced_assembly_to_change_from_0_to_1_which_requires_restarting_the_application">
        <source>Changing project or package reference caused the identity of referenced assembly to change from '{0}' to '{1}', which requires restarting the application.</source>
        <target state="new">Changing project or package reference caused the identity of referenced assembly to change from '{0}' to '{1}', which requires restarting the application.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_project_setting_0_from_1_to_2_requires_restarting_the_application">
        <source>Changing project setting '{0}' from '{1}' to '{2}' requires restarting the application.</source>
        <target state="new">Changing project setting '{0}' from '{1}' to '{2}' requires restarting the application.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_pseudo_custom_attribute_0_of_1_requires_restarting_th_application">
        <source>Changing pseudo-custom attribute '{0}' of {1} requires restarting the application</source>
        <target state="translated">{1}의 허위 사용자 지정 특성 '{0}'을(를) 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_source_file_0_in_a_stale_project_has_no_effect_until_the_project_is_rebuit">
        <source>Changing source file '{0}' in a stale project has no effect until the project is rebuit.</source>
        <target state="new">Changing source file '{0}' in a stale project has no effect until the project is rebuit.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_containing_namespace_of_0_from_1_to_2_requires_restarting_th_application">
        <source>Changing the containing namespace of '{0}' from '{1}' to '{2}' requires restarting the application</source>
        <target state="translated">'{0}'의 포함 네임스페이스를 '{1}'에서 '{2}'(으)로 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_declaration_scope_of_a_captured_variable_0_requires_restarting_the_application">
        <source>Changing the declaration scope of a captured variable '{0}' requires restarting the application.</source>
        <target state="translated">캡처된 변수 '{0}'의 선언 범위를 변경하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_parameters_of_0_requires_restarting_the_application">
        <source>Changing the parameters of {0} requires restarting the application.</source>
        <target state="translated">{0}의 매개 변수를 변경하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_return_type_of_0_requires_restarting_the_application">
        <source>Changing the return type of {0} requires restarting the application.</source>
        <target state="translated">{0}의 반환 형식을 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_signature_of_0_requires_restarting_the_application">
        <source>Changing the signature of {0} requires restarting the application.</source>
        <target state="translated">{0} 서명을 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_signature_of_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
        <source>Changing the signature of {0} requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">런타임에서 지원하지 않기 때문에 {0} 서명을 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_the_type_of_a_captured_variable_0_previously_of_type_1_requires_restarting_the_application">
        <source>Changing the type of a captured variable '{0}' previously of type '{1}' requires restarting the application.</source>
        <target state="translated">이전에 '{1}' 형식의 캡처된 변수 '{0}' 형식을 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_type_parameters_of_0_requires_restarting_the_application">
        <source>Changing type parameters of {0} requires restarting the application.</source>
        <target state="translated">{0}의 유형 매개 변수를 변경하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_visibility_of_0_requires_restarting_the_application">
        <source>Changing visibility of {0} requires restarting the application.</source>
        <target state="translated">{0} 표시 유형을 변경하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Chosen_version_0">
        <source>Chosen version: '{0}'</source>
        <target state="translated">선택한 버전: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Code_snippet_for_0">
        <source>Code snippet for '{0}'</source>
        <target state="translated">'{0}'의 코드 조각</target>
        <note />
      </trans-unit>
      <trans-unit id="Comments_not_allowed">
        <source>Comments not allowed</source>
        <target state="translated">주석이 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Conditional_alternation_is_missing_a_closing_parenthesis_after_the_group_number_0">
        <source>Conditional alternation is missing a closing parenthesis after the group number {0}</source>
        <target state="new">Conditional alternation is missing a closing parenthesis after the group number {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0</note>
      </trans-unit>
      <trans-unit id="Conditional_alternation_refers_to_an_undefined_group_number_0">
        <source>Conditional alternation refers to an undefined group number {0}</source>
        <target state="new">Conditional alternation refers to an undefined group number {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(1)\1))</note>
      </trans-unit>
      <trans-unit id="Configure_0_code_style">
        <source>Configure {0} code style</source>
        <target state="translated">{0} 코드 스타일 구성</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_0_severity">
        <source>Configure {0} severity</source>
        <target state="translated">{0} 심각도 구성</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_severity_for_all_0_analyzers">
        <source>Configure severity for all '{0}' analyzers</source>
        <target state="translated">모든 '{0}' 분석기에 대해 심각도 구성</target>
        <note />
      </trans-unit>
      <trans-unit id="Configure_severity_for_all_analyzers">
        <source>Configure severity for all analyzers</source>
        <target state="translated">모든 분석기에 대해 심각도 구성</target>
        <note />
      </trans-unit>
      <trans-unit id="Conflict_s_detected">
        <source>Conflict(s) detected.</source>
        <target state="translated">충돌이 감지되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Constructors_not_allowed">
        <source>Constructors not allowed</source>
        <target state="translated">생성자를 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Containing_Member">
        <source>Containing Member</source>
        <target state="translated">포함하는 멤버</target>
        <note />
      </trans-unit>
      <trans-unit id="Containing_Type">
        <source>Containing Type</source>
        <target state="translated">포함하는 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_number">
        <source>Convert number</source>
        <target state="translated">숫자 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_field_property">
        <source>Convert to 'field' property</source>
        <target state="new">Convert to 'field' property</target>
        <note>{Locked="field"} "field" is C# keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Convert_to_linq">
        <source>Convert to LINQ</source>
        <target state="translated">LINQ로 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_class">
        <source>Convert to class</source>
        <target state="translated">클래스로 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_linq_call_form">
        <source>Convert to LINQ (call form)</source>
        <target state="translated">LINQ로 변환(통화 양식)</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_record">
        <source>Convert to record</source>
        <target state="translated">레코드로 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_record_struct">
        <source>Convert to record struct</source>
        <target state="translated">레코드 구조체로 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_struct">
        <source>Convert to struct</source>
        <target state="translated">구조체로 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_tuple">
        <source>Convert to tuple</source>
        <target state="translated">튜플로 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_find_PDB_on_disk_or_embedded">
        <source>Could not find portable PDB on disk or embedded.</source>
        <target state="translated">디스크 또는 포함에서 이식 가능한 PDB를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_find_PDB_on_disk_or_embedded_or_server">
        <source>Could not find PDB on disk, or embedded, or on a symbol server.</source>
        <target state="translated">디스크에서 PDB를 찾거나 포함된 PDB 또는 기호 서버에서 PDB를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_find_by_name_0">
        <source>Could not find by name: '{0}'</source>
        <target state="translated">'{0}' 이름으로 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_find_implementation_of_symbol_0">
        <source>Could not find implementation of symbol '{0}'</source>
        <target state="translated">'{0}' 기호의 구현을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_field_0">
        <source>Create and assign field '{0}'</source>
        <target state="translated">'{0}' 필드 만들기 및 할당</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_property_0">
        <source>Create and assign property '{0}'</source>
        <target state="translated">'{0}' 속성 만들기 및 할당</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_remaining_as_fields">
        <source>Create and assign remaining as fields</source>
        <target state="translated">나머지를 만들고 필드로 할당합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Create_and_assign_remaining_as_properties">
        <source>Create and assign remaining as properties</source>
        <target state="translated">나머지를 만들고 속성으로 할당합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Debug_All_Tests">
        <source>Debug All Tests</source>
        <target state="translated">모든 테스트 디버그</target>
        <note />
      </trans-unit>
      <trans-unit id="Debug_Test">
        <source>Debug Test</source>
        <target state="translated">테스트 디버그</target>
        <note />
      </trans-unit>
      <trans-unit id="Decompilation_log">
        <source>Decompilation log</source>
        <target state="translated">디컴파일 로그</target>
        <note />
      </trans-unit>
      <trans-unit id="Decompiled">
        <source>decompiled</source>
        <target state="translated">디컴파일됨</target>
        <note />
      </trans-unit>
      <trans-unit id="Deconstruct_locals_for_0">
        <source>Deconstruct locals for '{0}'</source>
        <target state="translated">'{0}'에 대한 로컬 분해</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_0_around_an_active_statement_requires_restarting_the_application">
        <source>Deleting {0} around an active statement requires restarting the application.</source>
        <target state="translated">활성 문 주변의 {0}을(를) 삭제하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_0_requires_restarting_the_application">
        <source>Deleting {0} requires restarting the application.</source>
        <target state="translated">{0}을(를) 삭제하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Deleting_0_requires_restarting_the_application_because_is_not_supported_by_the_runtime">
        <source>Deleting {0} requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">런타임에서 지원하지 않기 때문에 {0}을(를) 삭제하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Directives_from_0">
        <source>Directives from '{0}'</source>
        <target state="translated">'{0}'의 지시문</target>
        <note />
      </trans-unit>
      <trans-unit id="Dismiss">
        <source>Dismiss</source>
        <target state="translated">해제</target>
        <note />
      </trans-unit>
      <trans-unit id="DocumentIsOutOfSyncWithDebuggee">
        <source>The current content of source file '{0}' does not match the built source. Any changes made to this file while debugging won't be applied until its content matches the built source.</source>
        <target state="translated">소스 파일 '{0}'의 현재 콘텐츠가 빌드된 소스와 일치하지 않습니다. 디버그하는 동안 이 파일의 변경된 모든 내용은 해당 콘텐츠가 빌드된 소스와 일치할 때까지 적용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Document_must_be_contained_in_the_workspace_that_created_this_service">
        <source>Document must be contained in the workspace that created this service</source>
        <target state="translated">문서가 이 서비스를 만든 작업 영역에 포함되어 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="EditAndContinue">
        <source>Edit and Continue</source>
        <target state="translated">편집하며 계속하기</target>
        <note />
      </trans-unit>
      <trans-unit id="EditAndContinueDisallowedByProject">
        <source>Changes made in project '{0}' require restarting the application: {1}</source>
        <target state="translated">' {0}' 프로젝트에서 변경한 내용을 적용하려면 응용 프로그램 ‘{1}’을(를) 다시 시작 해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Enable_all_JSON_editor_features">
        <source>Enable all JSON editor features</source>
        <target state="translated">모든 JSON 편집기 기능 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="Enum_members">
        <source>Enum members</source>
        <target state="translated">멤버 열거</target>
        <note />
      </trans-unit>
      <trans-unit id="ErrorReadingFile">
        <source>Error while reading file '{0}': {1}</source>
        <target state="translated">'{0}' 파일을 읽는 동안 오류가 발생했습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Error_creating_instance_of_CodeFixProvider">
        <source>Error creating instance of CodeFixProvider</source>
        <target state="translated">CodeFixProvider 인스턴스를 만드는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Error_creating_instance_of_CodeFixProvider_0">
        <source>Error creating instance of CodeFixProvider '{0}'</source>
        <target state="translated">CodeFixProvider '{0}' 인스턴스를 만드는 동안 오류가 발생했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Error_parsing_comment">
        <source>Error parsing comment</source>
        <target state="translated">주석 구문 분석 오류</target>
        <note />
      </trans-unit>
      <trans-unit id="Error_reading_PDB_0">
        <source>Error reading PDB: '{0}'</source>
        <target state="translated">PDB를 읽는 동안 오류 발생: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Example">
        <source>Example:</source>
        <target state="translated">예:</target>
        <note>Singular form when we want to show an example, but only have one to show.</note>
      </trans-unit>
      <trans-unit id="Examples">
        <source>Examples:</source>
        <target state="translated">예:</target>
        <note>Plural form when we have multiple examples to show.</note>
      </trans-unit>
      <trans-unit id="Extension_0_is_already_registered">
        <source>Extension '{0}' is already registered.</source>
        <target state="new">Extension '{0}' is already registered.</target>
        <note />
      </trans-unit>
      <trans-unit id="Extension_0_was_not_registered">
        <source>Extension '{0}' was not registered.</source>
        <target state="new">Extension '{0}' was not registered.</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_base_class">
        <source>Extract base class...</source>
        <target state="translated">기본 클래스 추출...</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_base_record">
        <source>Extract base record...</source>
        <target state="translated">기본 record 추출...</target>
        <note>{Locked="record"} "record" is a language construct for C# and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Extract_interface">
        <source>Extract interface...</source>
        <target state="translated">인터페이스 추출...</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_local_function">
        <source>Extract local function</source>
        <target state="translated">로컬 함수 추출</target>
        <note />
      </trans-unit>
      <trans-unit id="Extract_method">
        <source>Extract method</source>
        <target state="translated">메서드 추출</target>
        <note />
      </trans-unit>
      <trans-unit id="Failed_to_analyze_data_flow_for_0">
        <source>Failed to analyze data-flow for: {0}</source>
        <target state="translated">{0}의 데이터 흐름 분석 실패</target>
        <note />
      </trans-unit>
      <trans-unit id="Find_All_References_not_invoked_on_applicable_symbol">
        <source>'Find All References' not invoked on applicable symbol</source>
        <target state="translated">해당 기호에서 '모든 참조 찾기'가 호출되지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_All_0">
        <source>Fix All: {0}</source>
        <target state="translated">모두 수정: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_typo_0">
        <source>Fix typo '{0}'</source>
        <target state="translated">오타 '{0}' 수정</target>
        <note />
      </trans-unit>
      <trans-unit id="Fixing_0">
        <source>Fixing '{0}'</source>
        <target state="translated">'{0}' 수정 중</target>
        <note />
      </trans-unit>
      <trans-unit id="Formatting_document">
        <source>Formatting document</source>
        <target state="translated">문서 서식을 지정하는 중</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_0_assemblies_for_1">
        <source>Found '{0}' assemblies for '{1}':</source>
        <target state="translated">'{1}'의 어셈블리를 '{0}'개 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_PDB_file_at_0">
        <source>Found PDB file at '{0}'</source>
        <target state="translated">'{0}'에서 PDB 파일을 찾음</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_PDB_on_symbol_server">
        <source>Found PDB on symbol server.</source>
        <target state="translated">기호 서버에서 PDB를 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_PDB_on_symbol_server_but_could_not_read_file">
        <source>Found PDB on symbol server but could not read file.</source>
        <target state="translated">기호 서버에서 PDB를 찾았지만 파일을 읽을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_embedded_PDB_file">
        <source>Found embedded PDB file.</source>
        <target state="translated">포함된 PDB 파일을 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_exact_match_0">
        <source>Found exact match: '{0}'</source>
        <target state="translated">정확하게 일치하는 항목을 찾았습니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_higher_version_match_0">
        <source>Found higher version match: '{0}'</source>
        <target state="translated">일치하는 상위 버전을 찾았습니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Found_single_assembly_0">
        <source>Found single assembly: '{0}'</source>
        <target state="translated">단일 어셈블리를 찾았습니다. '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_Equals">
        <source>Generate Equals(...)</source>
        <target state="translated">Equals(...) 생성</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_comparison_operators">
        <source>Generate comparison operators</source>
        <target state="translated">비교 연산자 생성</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_constructor_from_members">
        <source>Generate constructor from members...</source>
        <target state="translated">멤버에서 생성자 생성...</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_for_0">
        <source>Generate for '{0}'</source>
        <target state="translated">'{0}'에 대해 생성</target>
        <note />
      </trans-unit>
      <trans-unit id="Illegal_backslash_at_end_of_pattern">
        <source>Illegal \ at end of pattern</source>
        <target state="translated">패턴 끝에 \를 사용할 수 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \</note>
      </trans-unit>
      <trans-unit id="Illegal_string_character">
        <source>Illegal string character</source>
        <target state="translated">문자열 문자가 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Illegal_whitespace_character">
        <source>Illegal whitespace character</source>
        <target state="translated">잘못된 공백 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Illegal_x_y_with_x_less_than_y">
        <source>Illegal {x,y} with x &gt; y</source>
        <target state="translated">x &gt; y인 잘못된 {x,y}입니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{1,0}</note>
      </trans-unit>
      <trans-unit id="Implement_0_explicitly">
        <source>Implement '{0}' explicitly</source>
        <target state="translated">'{0}'을(를) 명시적으로 구현</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_0_implicitly">
        <source>Implement '{0}' implicitly</source>
        <target state="translated">'{0}'을(를) 암시적으로 구현</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_all_interfaces_explicitly">
        <source>Implement all interfaces explicitly</source>
        <target state="translated">모든 인터페이스를 명시적으로 구현</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_all_interfaces_implicitly">
        <source>Implement all interfaces implicitly</source>
        <target state="translated">모든 인터페이스를 암시적으로 구현</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_explicitly">
        <source>Implement explicitly</source>
        <target state="translated">명시적으로 구현</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_implicitly">
        <source>Implement implicitly</source>
        <target state="translated">암시적으로 구현</target>
        <note />
      </trans-unit>
      <trans-unit id="Incomplete_character_escape">
        <source>Incomplete \p{X} character escape</source>
        <target state="translated">불완전한 \p{X} 문자 이스케이프</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{ Cc }</note>
      </trans-unit>
      <trans-unit id="Indent_all_arguments">
        <source>Indent all arguments</source>
        <target state="translated">모든 인수 들여쓰기</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_all_elements">
        <source>Indent all elements</source>
        <target state="translated">모든 요소 한 수준 내리기</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_all_parameters">
        <source>Indent all parameters</source>
        <target state="translated">모든 매개 변수 들여쓰기</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_wrapped_arguments">
        <source>Indent wrapped arguments</source>
        <target state="translated">래핑된 인수 들여쓰기</target>
        <note />
      </trans-unit>
      <trans-unit id="Indent_wrapped_parameters">
        <source>Indent wrapped parameters</source>
        <target state="translated">래핑된 매개 변수 들여쓰기</target>
        <note />
      </trans-unit>
      <trans-unit id="Inline_0">
        <source>Inline '{0}'</source>
        <target state="translated">'{0}'을(를) 인라인으로 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Inline_and_keep_0">
        <source>Inline and keep '{0}'</source>
        <target state="translated">'{0}'을(를) 인라인으로 지정 및 유지</target>
        <note />
      </trans-unit>
      <trans-unit id="Inline_temporary_variable">
        <source>Inline temporary variable</source>
        <target state="translated">인라인 임시 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="Insufficient_or_invalid_hexadecimal_digits">
        <source>Insufficient or invalid hexadecimal digits</source>
        <target state="new">Insufficient or invalid hexadecimal digits</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \x</note>
      </trans-unit>
      <trans-unit id="Introduce_constant">
        <source>Introduce constant</source>
        <target state="translated">상수 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_field">
        <source>Introduce field</source>
        <target state="translated">필드 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local">
        <source>Introduce local</source>
        <target state="translated">로컬 소개</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_parameter_for_0">
        <source>Introduce parameter for '{0}'</source>
        <target state="translated">'{0}'에 대한 매개 변수 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_parameter_for_all_occurrences_of_0">
        <source>Introduce parameter for all occurrences of '{0}'</source>
        <target state="translated">'{0}'의 모든 항목에 대한 매개 변수를 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_query_variable">
        <source>Introduce query variable</source>
        <target state="translated">쿼리 변수 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_JSON_pattern">
        <source>Invalid JSON pattern</source>
        <target state="translated">잘못된 JSON 패턴</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_constructor_name">
        <source>Invalid constructor name</source>
        <target state="translated">잘못된 생성자 이름</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_escape_sequence">
        <source>Invalid escape sequence</source>
        <target state="translated">잘못된 이스케이프 시퀀스</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_group_name_Group_names_must_begin_with_a_word_character">
        <source>Invalid group name: Group names must begin with a word character</source>
        <target state="translated">잘못된 그룹 이름: 그룹 이름은 단어 문자로 시작해야 합니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;a &gt;a)</note>
      </trans-unit>
      <trans-unit id="Invalid_number">
        <source>Invalid number</source>
        <target state="translated">잘못된 숫자</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_property_name">
        <source>Invalid property name</source>
        <target state="translated">잘못된 속성 이름</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_regex_pattern">
        <source>Invalid regex pattern</source>
        <target state="translated">잘못된 regex 패턴</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_selection">
        <source>Invalid selection.</source>
        <target state="translated">잘못된 선택 항목입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="JSON_issue_0">
        <source>JSON issue: {0}</source>
        <target state="translated">JSON 문제: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Invert_conditional">
        <source>Invert conditional</source>
        <target state="translated">조건 반전</target>
        <note />
      </trans-unit>
      <trans-unit id="Load_from_0">
        <source>Load from: '{0}'</source>
        <target state="translated">로드 위치: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Making_a_method_an_iterator_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
        <source>Making a method an iterator requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">런타임에서 지원하지 않기 때문에 메서드를 반복기로 만들려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Making_a_method_asynchronous_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
        <source>Making a method asynchronous requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">런타임에서 지원하지 않기 때문에 메서드를 비동기화하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Malformed_character_escape">
        <source>Malformed \p{X} character escape</source>
        <target state="translated">형식이 잘못된 \p{X} 문자 이스케이프</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p {Cc}</note>
      </trans-unit>
      <trans-unit id="Malformed_named_back_reference">
        <source>Malformed \k&lt;...&gt; named back reference</source>
        <target state="translated">\k&lt;...&gt; 역참조 형식이 잘못되었습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k'</note>
      </trans-unit>
      <trans-unit id="Merge_with_nested_0_statement">
        <source>Merge with nested '{0}' statement</source>
        <target state="translated">중첩 '{0}' 문과 병합</target>
        <note />
      </trans-unit>
      <trans-unit id="Merge_with_next_0_statement">
        <source>Merge with next '{0}' statement</source>
        <target state="translated">다음 '{0}' 문과 병합</target>
        <note />
      </trans-unit>
      <trans-unit id="Merge_with_outer_0_statement">
        <source>Merge with outer '{0}' statement</source>
        <target state="translated">외부 '{0}' 문과 병합</target>
        <note />
      </trans-unit>
      <trans-unit id="Merge_with_previous_0_statement">
        <source>Merge with previous '{0}' statement</source>
        <target state="translated">이전 '{0}' 문과 병합</target>
        <note />
      </trans-unit>
      <trans-unit id="MethodMustReturnStreamThatSupportsReadAndSeek">
        <source>{0} must return a stream that supports read and seek operations.</source>
        <target state="translated">{0}은(는) 읽기 및 검색 작업을 지원하는 스트림을 반환해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Miscellaneous_Files">
        <source>Miscellaneous Files</source>
        <target state="translated">기타 파일</target>
        <note />
      </trans-unit>
      <trans-unit id="Missing_control_character">
        <source>Missing control character</source>
        <target state="translated">제어 문자가 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \c</note>
      </trans-unit>
      <trans-unit id="Missing_property_value">
        <source>Missing property value</source>
        <target state="translated">속성 값이 누락되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_a_static_variable_requires_restarting_the_application">
        <source>Modifying {0} which contains a static variable requires restarting the application.</source>
        <target state="translated">정적 변수를 포함하는 {0}을(를) 수정하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_an_Aggregate_Group_By_or_Join_query_clauses_requires_restarting_the_application">
        <source>Modifying {0} which contains an Aggregate, Group By, or Join query clauses requires restarting the application.</source>
        <target state="translated">Aggregate, Group By 또는 Join 쿼리 절이 포함된 {0}을(를) 수정하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note>{Locked="Aggregate"}{Locked="Group By"}{Locked="Join"} are VB keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Modifying_0_which_contains_the_stackalloc_operator_requires_restarting_the_application">
        <source>Modifying {0} which contains the stackalloc operator requires restarting the application.</source>
        <target state="translated">stackalloc 연산자를 포함하는 {0}을(를) 수정하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note>{Locked="stackalloc"} "stackalloc" is C# keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Modifying_a_catch_finally_handler_with_an_active_statement_in_the_try_block_requires_restarting_the_application">
        <source>Modifying a catch/finally handler with an active statement in the try block requires restarting the application.</source>
        <target state="translated">try 블록에서 활성 문으로 catch/finally 처리기를 수정하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_catch_handler_around_an_active_statement_requires_restarting_the_application">
        <source>Modifying a catch handler around an active statement requires restarting the application.</source>
        <target state="translated">활성 문 주위에 catch 처리기를 수정하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_generic_method_requires_restarting_the_application">
        <source>Modifying a generic method requires restarting the application.</source>
        <target state="translated">일반 메서드를 수정하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_method_inside_the_context_of_a_generic_type_requires_restarting_the_application">
        <source>Modifying a method inside the context of a generic type requires restarting the application.</source>
        <target state="translated">제네릭 형식의 컨텍스트 내에서 메서드를 수정하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_a_try_catch_finally_statement_when_the_finally_block_is_active_requires_restarting_the_application">
        <source>Modifying a try/catch/finally statement when the finally block is active requires restarting the application.</source>
        <target state="translated">finally 블록이 활성 상태일 때 try/catch/finally 문을 수정하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_body_of_0_requires_restarting_the_application_because_the_body_has_too_many_statements">
        <source>Modifying the body of {0} requires restarting the application because the body has too many statements.</source>
        <target state="translated">본문에 문이 너무 많기 때문에 {0}의 본문을 수정하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_body_of_0_requires_restarting_the_application_due_to_internal_error_1">
        <source>Modifying the body of {0} requires restarting the application due to internal error: {1}</source>
        <target state="translated">{0}의 본문을 수정하려면 내부 오류로 인해 애플리케이션을 다시 시작해야 합니다. {1}</target>
        <note>{1} is a multi-line exception message including a stacktrace. Place it at the end of the message and don't add any punctation after or around {1}</note>
      </trans-unit>
      <trans-unit id="Modifying_source_file_0_requires_restarting_the_application_because_the_file_is_too_big">
        <source>Modifying source file '{0}' requires restarting the application because the file is too big.</source>
        <target state="translated">원본 파일 '{0}'을(를) 수정하려면 파일이 너무 크므로 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifying_source_file_0_requires_restarting_the_application_due_to_internal_error_1">
        <source>Modifying source file '{0}' requires restarting the application due to internal error: {1}</source>
        <target state="translated">원본 파일 '{0}'을(를) 수정하려면 내부 오류로 인해 응용 프로그램을 다시 시작해야 합니다. {1}</target>
        <note>{2} is a multi-line exception message including a stacktrace. Place it at the end of the message and don't add any punctation after or around {1}</note>
      </trans-unit>
      <trans-unit id="Modifying_source_with_experimental_language_features_enabled_requires_restarting_the_application">
        <source>Modifying source with experimental language features enabled requires restarting the application.</source>
        <target state="translated">실험 언어 기능이 활성화된 원본를 수정하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Module_not_found">
        <source>Module not found!</source>
        <target state="translated">모듈을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_contents_to_namespace">
        <source>Move contents to namespace...</source>
        <target state="translated">네임스페이스로 콘텐츠 이동...</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_declaration_near_reference_may_change_semantics">
        <source>Move declaration near reference (may change semantics)</source>
        <target state="translated">선언을 참조 근처로 이동(의미 체계가 변경될 수 있음)</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_file_to_0">
        <source>Move file to '{0}'</source>
        <target state="translated">파일을 '{0}'(으)로 이동</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_file_to_project_root_folder">
        <source>Move file to project root folder</source>
        <target state="translated">파일을 프로젝트 루트 폴더로 이동</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_static_members_to_another_type">
        <source>Move static members to another type...</source>
        <target state="translated">정적 멤버를 다른 형식으로 이동...</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_to_namespace">
        <source>Move to namespace...</source>
        <target state="translated">네임스페이스로 이동...</target>
        <note />
      </trans-unit>
      <trans-unit id="Moving_0_requires_restarting_the_application">
        <source>Moving {0} requires restarting the application.</source>
        <target state="translated">{0}을(를) 이동하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Multiple_handlers_found_for_message_0">
        <source>Multiple handlers found for message {0}.</source>
        <target state="new">Multiple handlers found for message {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="NET_Code_Actions">
        <source>.NET Code Actions</source>
        <target state="translated">.NET 코드 작업</target>
        <note />
      </trans-unit>
      <trans-unit id="Name_expected">
        <source>Name expected</source>
        <target state="translated">이름이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Navigating_to_symbol_0_from_1">
        <source>Navigating to symbol '{0}' from '{1}'.</source>
        <target state="translated">'{1}'에서 기호 '{0}'(으)로 이동하는 중입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Nested_properties_not_allowed">
        <source>Nested properties not allowed</source>
        <target state="translated">중첩 속성은 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Nested_quantifier_0">
        <source>Nested quantifier '{0}'</source>
        <target state="needs-review-translation">중첩 수량자 {0}입니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a**. In this case {0} will be '*', the extra unnecessary quantifier.</note>
      </trans-unit>
      <trans-unit id="No_common_root_node_for_extraction">
        <source>No common root node for extraction.</source>
        <target state="translated">추출에 필요한 일반 루트 노드가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_extension_registered_as_0">
        <source>No extension registered as '{0}'.</source>
        <target state="new">No extension registered as '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_extensions_registered_at_0">
        <source>No extensions registered at '{0}'.</source>
        <target state="new">No extensions registered at '{0}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_handler_found_for_message_0">
        <source>No handler found for message {0}.</source>
        <target state="new">No handler found for message {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_source_document_info_found_in_PDB">
        <source>No source document info found in PDB.</source>
        <target state="translated">PDB에서 원본 문서 정보를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_valid_location_to_insert_method_call">
        <source>No valid location to insert method call.</source>
        <target state="translated">메서드 호출을 삽입할 유효한 위치가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_valid_selection_to_perform_extraction">
        <source>No valid selection to perform extraction.</source>
        <target state="translated">추출을 수행할 선택 항목이 잘못되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_valid_statement_range_to_extract">
        <source>No valid statement range to extract</source>
        <target state="translated">추출하는 데 유효한 문 범위가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Not_all_code_paths_return">
        <source>Not all code paths return</source>
        <target state="translated">일부 코드 경로가 반환됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Not_enough_close_parens">
        <source>Not enough )'s</source>
        <target state="translated">부족 )'s</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (a</note>
      </trans-unit>
      <trans-unit id="Only_properties_allowed_in_an_object">
        <source>Only properties allowed in an object</source>
        <target state="translated">개체에는 속성만 사용할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Operators">
        <source>Operators</source>
        <target state="translated">연산자</target>
        <note />
      </trans-unit>
      <trans-unit id="Please_resolve_errors_in_your_code_before_renaming_this_element">
        <source>Please resolve errors in your code before renaming this element.</source>
        <target state="translated">이 요소의 이름을 바꾸기 전에 코드 오류를 해결하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="Probable_JSON_string_detected">
        <source>Probable JSON string detected</source>
        <target state="translated">가능한 JSON 문자열이 탐지됨</target>
        <note />
      </trans-unit>
      <trans-unit id="Project_references_mutliple_assemblies_of_the_same_simple_name_0_1_Changing_a_reference_to_such_an_assembly_requires_restarting_the_application">
        <source>Project references mutliple assemblies of the same simple name '{0}': {1}. Changing a reference to such an assembly requires restarting the application.</source>
        <target state="new">Project references mutliple assemblies of the same simple name '{0}': {1}. Changing a reference to such an assembly requires restarting the application.</target>
        <note />
      </trans-unit>
      <trans-unit id="Properties_not_allowed_in_an_array">
        <source>Properties not allowed in an array</source>
        <target state="translated">배열에는 속성을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_name_must_be_a_string">
        <source>Property name must be a string</source>
        <target state="translated">속성 이름은 문자열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_name_must_be_followed_by_a_colon">
        <source>Property name must be followed by a ':'</source>
        <target state="translated">속성 이름 뒤에는 ':'이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_reference_cannot_be_updated">
        <source>Property reference cannot be updated</source>
        <target state="translated">속성 참조를 업데이트할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_0_up_to">
        <source>Pull '{0}' up to ...</source>
        <target state="translated">'{0}'을(를) 다음으로 끌어오기...</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_members_up_to_base_type">
        <source>Pull members up to base type...</source>
        <target state="translated">기본 형식까지 멤버를 풀...</target>
        <note />
      </trans-unit>
      <trans-unit id="Pull_selected_members_up">
        <source>Pull selected members up</source>
        <target state="translated">선택한 멤버를 위로 당깁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Quantifier_0_following_nothing">
        <source>Quantifier '{0}' following nothing</source>
        <target state="new">Quantifier '{0}' following nothing</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: *</note>
      </trans-unit>
      <trans-unit id="Quantifier_and_capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue">
        <source>Quantifier and capture group numbers must be less than or equal to Int32.MaxValue</source>
        <target state="new">Quantifier and capture group numbers must be less than or equal to Int32.MaxValue</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{2147483648}</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_name_0">
        <source>Reference to undefined group name '{0}'</source>
        <target state="needs-review-translation">정의되지 않은 그룹 이름 {0}에 대한 참조입니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k&lt;a&gt;. Here, {0} will be the name of the undefined group ('a')</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_number_0">
        <source>Reference to undefined group number {0}</source>
        <target state="new">Reference to undefined group number {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;-1&gt;). Here, {0} will be the number of the undefined group ('1')</note>
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_long">
        <source>All control characters. This includes the Cc, Cf, Cs, Co, and Cn categories.</source>
        <target state="translated">모든 제어 문자입니다. Cc, Cf, Cs, Co 및 Cn 범주가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_short">
        <source>all control characters</source>
        <target state="translated">모든 제어 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_long">
        <source>All diacritic marks. This includes the Mn, Mc, and Me categories.</source>
        <target state="translated">모든 분음 부호입니다. Mn, Mc 및 Me 범주가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_short">
        <source>all diacritic marks</source>
        <target state="translated">모든 분음 부호</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_long">
        <source>All letter characters. This includes the Lu, Ll, Lt, Lm, and Lo characters.</source>
        <target state="translated">모든 문자입니다. Lu, Ll, Lt, Lm 및 Lo 문자가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_short">
        <source>all letter characters</source>
        <target state="translated">모든 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_long">
        <source>All numbers. This includes the Nd, Nl, and No categories.</source>
        <target state="translated">모든 숫자입니다. Nd, Nl 및 No 범주가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_short">
        <source>all numbers</source>
        <target state="translated">모든 숫자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_long">
        <source>All punctuation characters. This includes the Pc, Pd, Ps, Pe, Pi, Pf, and Po categories.</source>
        <target state="translated">모든 문장 부호 문자입니다. Pc, Pd, Ps, Pe, Pi, Pf 및 Po 범주가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_short">
        <source>all punctuation characters</source>
        <target state="translated">모든 문장 부호 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_long">
        <source>All separator characters. This includes the Zs, Zl, and Zp categories.</source>
        <target state="translated">모든 구분 문자입니다. Zs, Zl 및 Zp 범주가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_short">
        <source>all separator characters</source>
        <target state="translated">모든 구분 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_long">
        <source>All symbols. This includes the Sm, Sc, Sk, and So categories.</source>
        <target state="translated">모든 기호입니다. Sm, Sc, Sk 및 So 범주가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_short">
        <source>all symbols</source>
        <target state="translated">모든 기호</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_long">
        <source>You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.</source>
        <target state="translated">세로 막대(|) 문자를 사용하여 일련의 패턴 중 하나를 일치시킬 수 있습니다. 여기서 | 문자는 각 패턴을 구분합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_short">
        <source>alternation</source>
        <target state="translated">대체</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_long">
        <source>The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified by the 's' option, . matches any character.</source>
        <target state="translated">마침표(.) 문자는 \n(줄 바꿈 문자, \u000A)을 제외한 모든 문자와 일치시킵니다. 정규식 패턴이 RegexOptions.Singleline 옵션으로 수정되거나 . 문자 클래스가 포함된 패턴의 일부가 's' 옵션으로 수정된 경우 .는 모든 문자와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_short">
        <source>any character</source>
        <target state="translated">모든 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_atomic_group_long">
        <source>Atomic groups (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression) disable backtracking. The regular expression engine will match as many characters in the input string as it can. When no further match is possible, it will not backtrack to attempt alternate pattern matches. (That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)

This option is recommended if you know that backtracking will not succeed. Preventing the regular expression engine from performing unnecessary searching improves performance.</source>
        <target state="translated">원자성 그룹(다른 정규식 엔진에서 역추적하지 않는 하위 식, 원자성 하위 식 또는 한 번만 하위 식이라고 함)은 역추적을 사용하지 않도록 설정합니다. 정규식 엔진은 입력 문자열에서 가능한 한 많은 문자와 일치시킵니다. 더 이상 일치 항목을 찾을 수 없으면 대체 패턴 일치 항목 찾기를 시도하도록 역추적하지 않습니다. 즉, 하위 식은 해당 하위 식 단독으로 일치되는 문자열만 일치시킵니다. 해당 하위 식과 그 뒤에 오는 하위 식을 기반으로 문자열을 일치시키지 않습니다.

이 옵션은 역추적이 성공하지 못할 것을 알고 있는 경우에 사용하는 것이 좋습니다. 정규식 엔진이 불필요한 검색을 수행하지 않도록 하면 성능이 향상됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_atomic_group_short">
        <source>atomic group</source>
        <target state="translated">원자성 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_long">
        <source>Matches a backspace character, \u0008</source>
        <target state="translated">백스페이스 문자 \u0008과 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_short">
        <source>backspace character</source>
        <target state="translated">백스페이스 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_long">
        <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.

'name1' is the current group (optional), 'name2' is a previously defined group, and 'subexpression' is any valid regular expression pattern. The balancing group definition deletes the definition of name2 and stores the interval between name2 and name1 in name1. If no name2 group is defined, the match backtracks. Because deleting the last definition of name2 reveals the previous definition of name2, this construct lets you use the stack of captures for group name2 as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.

The balancing group definition uses 'name2' as a stack. The beginning character of each nested construct is placed in the group and in its Group.Captures collection. When the closing character is matched, its corresponding opening character is removed from the group, and the Captures collection is decreased by one. After the opening and closing characters of all nested constructs have been matched, 'name1' is empty.</source>
        <target state="translated">균형 조정 그룹 정의는 이전에 정의된 그룹의 정의를 삭제하고, 이전에 정의된 그룹과 현재 그룹 사이의 간격을 현재 그룹에 저장합니다.

'name1'은 현재 그룹이고(선택 사항), 'name2'는 이전에 정의된 그룹이며, 'subexpression'은 유효한 정규식 패턴입니다. 균형 조정 그룹 정의는 name2의 정의를 삭제하고 name2와 name1 사이의 간격을 name1에 저장합니다. name2 그룹이 정의되어 있지 않으면 일치에서 역추적합니다. name2의 마지막 정의를 삭제하면 name2의 이전 정의가 표시되므로 이 구문을 통해 name2 그룹에 대한 캡처 스택을 괄호 또는 여는 대괄호 및 닫는 대괄호와 같은 중첩 구문을 추적하기 위한 카운터로 사용할 수 있습니다.

균형 조정 그룹 정의에서는 'name2'를 스택으로 사용합니다. 각 중첩 구문의 시작 문자는 그룹 및 해당 Group.Captures 컬렉션에 배치됩니다. 닫는 문자가 일치되면 해당하는 여는 문자가 그룹에서 제거되고 Captures 컬렉션이 하나 감소합니다. 모든 중첩 구문의 여는 문자와 닫는 문자가 일치되고 나면 'name1'은 비어 있는 상태가 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_short">
        <source>balancing group</source>
        <target state="translated">균형 조정 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_base_group">
        <source>base-group</source>
        <target state="translated">기본 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_long">
        <source>Matches a bell (alarm) character, \u0007</source>
        <target state="translated">벨(경보) 문자 \u0007과 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_short">
        <source>bell character</source>
        <target state="translated">벨 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_long">
        <source>Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n.</source>
        <target state="translated">캐리지 리턴 문자 \u000D와 일치시킵니다. \r은 줄 바꿈 문자 \n과 같지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_short">
        <source>carriage-return character</source>
        <target state="translated">캐리지 리턴 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_long">
        <source>Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.

'base_group' is a positive or negative character group or range. The 'excluded_group' component is another positive or negative character group, or another character class subtraction expression (that is, you can nest character class subtraction expressions).</source>
        <target state="translated">문자 클래스 빼기를 사용하면 한 문자 클래스의 문자를 다른 문자 클래스에서 제외한 결과인 문자 집합을 얻게 됩니다.

'base_group'은 긍정 또는 부정 문자 그룹이거나 문자 범위입니다. 'excluded_group' 구성 요소는 다른 긍정 또는 부정 문자 그룹이거나 다른 문자 클래스 빼기 식입니다(즉, 문자 클래스 빼기 식을 중첩할 수 있음).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_short">
        <source>character class subtraction</source>
        <target state="translated">문자 클래스 빼기</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_group">
        <source>character-group</source>
        <target state="translated">문자 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_comment">
        <source>comment</source>
        <target state="translated">주석</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.

'expression' is the initial pattern to match, 'yes' is the pattern to match if expression is matched, and 'no' is the optional pattern to match if expression is not matched.</source>
        <target state="translated">이 언어 요소는 초기 패턴과 일치시킬 수 있는지 여부에 따라 두 패턴 중 하나와 일치시키려고 시도합니다.

'expression'은 일치시킬 초기 패턴이며 'yes'는 식이 일치하는 경우 일치시킬 패턴이고 'no'는 식이 일치하지 않는 경우 일치시킬 선택적 패턴입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_short">
        <source>conditional expression match</source>
        <target state="translated">조건식 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.

'name' is the name (or number) of a capturing group, 'yes' is the expression to match if 'name' (or 'number') has a match, and 'no' is the optional expression to match if it does not.</source>
        <target state="translated">이 언어 요소는 지정한 캡처링 그룹과 일치시켰는지 여부에 따라 두 패턴 중 하나와 일치시키려고 시도합니다.

'name'은 캡처링 그룹의 이름(또는 번호)이며 'yes'는 'name'(또는 'number')에 일치 항목이 있는 경우 일치시킬 식이고 'no'는 일치 항목이 없는 경우 일치시킬 선택적 식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_short">
        <source>conditional group match</source>
        <target state="translated">조건 그룹 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_long">
        <source>The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.</source>
        <target state="translated">\G 앵커는 이전 일치 항목 찾기가 끝난 지점에서 일치 항목을 찾도록 지정합니다. 이 앵커를 Regex.Matches 또는 Match.NextMatch 메서드와 함께 사용하면 모든 일치 항목이 연속되도록 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_short">
        <source>contiguous matches</source>
        <target state="translated">연속 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_long">
        <source>Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C.</source>
        <target state="translated">ASCII 제어 문자와 일치시킵니다. 여기서, X는 제어 문자의 문자입니다. 예를 들어 \cC는 CTRL-C입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_short">
        <source>control character</source>
        <target state="translated">제어 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_long">
        <source>\d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.

If ECMAScript-compliant behavior is specified, \d is equivalent to [0-9]</source>
        <target state="translated">\d는 10진수와 일치시킵니다. 표준 10진수 0-9와 여러 다른 문자 집합의 10진수를 포함한 \p{Nd} 정규식 패턴과 같습니다.

ECMAScript 규격 동작을 지정한 경우 \d는 [0-9]와 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_short">
        <source>decimal-digit character</source>
        <target state="translated">10진수 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_long">
        <source>A number sign (#) marks an x-mode comment, which starts at the unescaped # character at the end of the regular expression pattern and continues until the end of the line. To use this construct, you must either enable the x option (through inline options) or supply the RegexOptions.IgnorePatternWhitespace value to the option parameter when instantiating the Regex object or calling a static Regex method.</source>
        <target state="translated">숫자 기호(#)는 정규식 패턴의 끝에 있는 이스케이프되지 않은 # 문자에서 시작하고 줄의 끝까지 계속되는 x-모드 주석을 표시합니다. 이 구문을 사용하려면 인라인 옵션을 통해 x 옵션을 사용해야 합니다. 또는 Regex 개체를 인스턴스화하거나 정적 Regex 메서드를 호출할 때 RegexOptions.IgnorePatternWhitespace 값을 옵션 매개 변수에 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_short">
        <source>end-of-line comment</source>
        <target state="translated">줄의 끝 주석</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_long">
        <source>The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, it can only match the last line of the input string.</source>
        <target state="translated">\z 앵커는 입력 문자열의 끝부분에서 일치 항목을 찾도록 지정합니다. $ 언어 요소와 마찬가지로, \z는 RegexOptions.Multiline 옵션을 무시합니다. 하지만 \Z 언어 요소와 달리 \z는 문자열의 끝에 있는 \n 문자와 일치시키지 않습니다. 따라서 입력 문자열의 마지막 줄만 일치시킬 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_short">
        <source>end of string only</source>
        <target state="translated">문자열의 끝만</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_long">
        <source>The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can only match the end of the last line, or the last line before \n.

The \Z anchor matches \n but does not match \r\n (the CR/LF character combination). To match CR/LF, include \r?\Z in the regular expression pattern.</source>
        <target state="translated">\Z 앵커는 입력 문자열의 끝부분이나 입력 문자열의 끝부분에 있는 \n 앞에서 일치 항목을 찾도록 지정합니다. \Z는 RegexOptions.Multiline 옵션을 무시한다는 점을 제외하고는 $ 앵커와 동일합니다. 따라서 여러 줄 문자열에서는 마지막 줄의 끝이나 \n 앞의 마지막 줄만 일치시킬 수 있습니다.

\Z 앵커는 \n은 일치시키지만 \r\n(CR/LF 문자 조합)은 일치시키지 않습니다. CR/LF와 일치시키려면 정규식 패턴에 \r?\Z를 포함하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_short">
        <source>end of string or before ending newline</source>
        <target state="translated">문자열의 끝 또는 줄 바꿈 종료 전</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_long">
        <source>The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string. If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line.

The $ anchor matches \n but does not match \r\n (the combination of carriage return and newline characters, or CR/LF). To match the CR/LF character combination, include \r?$ in the regular expression pattern.</source>
        <target state="translated">$ 앵커는 입력 문자열의 끝부분이나 입력 문자열의 끝부분에 있는 \n 앞에 이전 패턴이 오도록 지정합니다. RegexOptions.Multiline 옵션과 함께 $를 사용하면 줄의 끝부분에서도 일치 항목을 찾을 수 있습니다.

$ 앵커는 \n은 일치시키지만 \r\n(캐리지 리턴 및 줄 바꿈 문자 조합 또는 CR/LF)은 일치시키지 않습니다. CR/LF 문자 조합과 일치시키려면 정규식 패턴에 \r?$를 포함하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_short">
        <source>end of string or line</source>
        <target state="translated">문자열 또는 줄의 끝</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_long">
        <source>Matches an escape character, \u001B</source>
        <target state="translated">이스케이프 문자 \u001B와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_short">
        <source>escape character</source>
        <target state="translated">이스케이프 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_excluded_group">
        <source>excluded-group</source>
        <target state="translated">제외된 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_expression">
        <source>expression</source>
        <target state="translated">식</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_long">
        <source>Matches a form-feed character, \u000C</source>
        <target state="translated">용지 공급 문자 \u000C와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_short">
        <source>form-feed character</source>
        <target state="translated">용지 공급 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_long">
        <source>This grouping construct applies or disables the specified options within a subexpression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly
	named or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">이 그룹화 생성자는 하위 식 내에서 지정된 옵션을 적용하거나 사용하지 않도록 설정합니다. 사용하도록 설정하는 옵션은 물음표 뒤에 지정되며 사용하지 않도록 설정하는 옵션은 빼기 기호 뒤에 지정됩니다. 허용되는 옵션은 다음과 같습니다.

    i	대/소문자를 구분하지 않는 일치를 사용합니다.
    m	여러 줄 모드를 사용합니다. 여기서, ^ 및 $는 각 줄의 시작 및 끝과 일치시킵니다(입력
	문자열의 시작 및 끝이 아님).
    s	한 줄 모드를 사용합니다. 여기서, 마침표(.)는 모든 문자(\n을 제외한
	모든 문자가 아님)와 일치시킵니다.
    n	명명되지 않은 그룹을 캡처하지 않습니다. 양식(?&lt;이름&gt; 하위 식)의 명시적으로 명명된 그룹
	또는 번호가 매겨진 그룹만 유효한 캡처입니다.
    x	이스케이프되지 않은 공백은 패턴에서 제외하고 주석은 숫자 기호(#) 다음에
	사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_short">
        <source>group options</source>
        <target state="translated">그룹 옵션</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_long">
        <source>Matches an ASCII character, where ## is a two-digit hexadecimal character code.</source>
        <target state="translated">ASCII 문자와 일치시킵니다. 여기서, ##은 두 자리 16진수 문자 코드입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_short">
        <source>hexadecimal escape</source>
        <target state="translated">16진수 이스케이프</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_long">
        <source>The (?# comment) construct lets you include an inline comment in a regular expression. The regular expression engine does not use any part of the comment in pattern matching, although the comment is included in the string that is returned by the Regex.ToString method. The comment ends at the first closing parenthesis.</source>
        <target state="translated">(?# comment) 구문에서는 정규식에 인라인 주석을 포함할 수 있습니다. Regex.ToString 메서드에서 반환된 문자열에 주석이 포함되어 있어도 정규식 엔진은 패턴 일치에 주석의 어떤 부분도 사용하지 않습니다. 주석은 첫 번째 닫는 괄호에서 종료됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_short">
        <source>inline comment</source>
        <target state="translated">인라인 주석</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_long">
        <source>Enables or disables specific pattern matching options for the remainder of a regular expression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly named
	or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">정규식의 나머지 부분에 대해 특정 패턴 일치 옵션을 사용하거나 사용하지 않도록 설정합니다. 사용하도록 설정하는 옵션은 물음표 뒤에 지정되며 사용하지 않도록 설정하는 옵션은 빼기 기호 뒤에 지정됩니다. 허용되는 옵션은 다음과 같습니다.

    i	대/소문자를 구분하지 않는 일치를 사용합니다.
    m	여러 줄 모드를 사용합니다. 여기서, ^ 및 $는 각 줄의 시작 및 끝과 일치시킵니다(입력
	문자열의 시작 및 끝이 아님).
    s	한 줄 모드를 사용합니다. 여기서, 마침표(.)는 모든 문자(\n을 제외한
	모든 문자가 아님)와 일치시킵니다.
    n	명명되지 않은 그룹을 캡처하지 않습니다. 양식(?&lt;이름&gt; 하위 식)의 명시적으로 명명된 그룹
	또는 번호가 매겨진 그룹만 유효한 캡처입니다.
    x	이스케이프되지 않은 공백은 패턴에서 제외하고 주석은 숫자 기호(#) 다음에
	사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_short">
        <source>inline options</source>
        <target state="translated">인라인 옵션</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_issue_0">
        <source>Regex issue: {0}</source>
        <target state="translated">Regex 문제: {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. {0} will be the actual text of one of the above Regular Expression errors.</note>
      </trans-unit>
      <trans-unit id="Regex_letter_lowercase">
        <source>letter, lowercase</source>
        <target state="translated">문자, 소문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_modifier">
        <source>letter, modifier</source>
        <target state="translated">문자, 한정자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_other">
        <source>letter, other</source>
        <target state="translated">문자, 기타</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_titlecase">
        <source>letter, titlecase</source>
        <target state="translated">문자, 첫 글자만 대문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_uppercase">
        <source>letter, uppercase</source>
        <target state="translated">문자, 대문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_enclosing">
        <source>mark, enclosing</source>
        <target state="translated">표시, 묶음</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_nonspacing">
        <source>mark, nonspacing</source>
        <target state="translated">표시, 공간을 차지하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_spacing_combining">
        <source>mark, spacing combining</source>
        <target state="translated">표시, 간격 결합</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_long">
        <source>The {n,}? quantifier matches the preceding element at least n times, where n is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,}</source>
        <target state="translated">{n,}? 수량자는 n번 이상 이전 요소와 일치시키지만 가능한 한 적은 횟수로 일치시킵니다. 여기서, n은 정수입니다. 탐욕적 수량자 {n,}에 대응되는 게으른 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">'n'번 이상 일치(지연)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_long">
        <source>The {n,} quantifier matches the preceding element at least n times, where n is any integer. {n,} is a greedy quantifier whose lazy equivalent is {n,}?</source>
        <target state="translated">{n,} 수량자는 n번 이상 이전 요소와 일치시킵니다. 여기서, n은 정수입니다. {n,}는 해당 게으른 수량자가 {n,}?인 탐욕적 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_short">
        <source>match at least 'n' times</source>
        <target state="translated">'n'번 이상 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_long">
        <source>The {n,m}? quantifier matches the preceding element between n and m times, where n and m are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,m}</source>
        <target state="translated">{n,m}? 수량자는 n 및 m번 사이로 이전 요소와 일치시키지만 가능한 한 적은 횟수로 일치시킵니다. 여기서, n 및 m은 정수입니다. 탐욕적 수량자 {n,m}에 대응되는 게으른 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">'n'번 이상 일치(지연)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_long">
        <source>The {n,m} quantifier matches the preceding element at least n times, but no more than m times, where n and m are integers. {n,m} is a greedy quantifier whose lazy equivalent is {n,m}?</source>
        <target state="translated">{n,m} 수량자는 n번 이상 m번 이하로 이전 요소와 일치시킵니다. 여기서, n 및 m은 정수입니다. {n,m}는 해당 게으른 수량자가 {n,m}?인 탐욕적 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_short">
        <source>match between 'm' and 'n' times</source>
        <target state="translated">'m'에서 'n'번 사이 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_long">
        <source>The {n}? quantifier matches the preceding element exactly n times, where n is any integer. It is the lazy counterpart of the greedy quantifier {n}+</source>
        <target state="translated">{n}? 수량자는 정확히 n번을 이전 요소와 일치시킵니다. 여기서, n은 정수입니다. 탐욕적 수량자 {n}+에 대응되는 게으른 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_short">
        <source>match exactly 'n' times (lazy)</source>
        <target state="translated">정확하게 'n'번 일치(지연)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_long">
        <source>The {n} quantifier matches the preceding element exactly n times, where n is any integer. {n} is a greedy quantifier whose lazy equivalent is {n}?</source>
        <target state="translated">{n} 수량자는 정확히 n번을 이전 요소와 일치시킵니다. 여기서, n은 정수입니다. {n}는 해당 게으른 수량자가 {n}?인 탐욕적 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_short">
        <source>match exactly 'n' times</source>
        <target state="translated">정확하게 'n'번 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_long">
        <source>The +? quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier +</source>
        <target state="translated">+? 수량자는 1번 이상 이전 요소와 일치시키지만 가능한 한 적은 횟수로 일치시킵니다. 탐욕적 수량자 +에 대응되는 게으른 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_short">
        <source>match one or more times (lazy)</source>
        <target state="translated">1번 이상 일치(지연)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_long">
        <source>The + quantifier matches the preceding element one or more times. It is equivalent to the {1,} quantifier. + is a greedy quantifier whose lazy equivalent is +?.</source>
        <target state="translated">+ 수량자는 1번 이상 이전 요소와 일치시킵니다. {1,} 수량자와 같습니다. +는 해당 게으른 수량자가 +?인 탐욕적 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_short">
        <source>match one or more times</source>
        <target state="translated">1번 이상 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_long">
        <source>The *? quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier *</source>
        <target state="translated">*? 수량자는 0번 이상 이전 요소와 일치시키지만 가능한 한 적은 횟수로 일치시킵니다. 탐욕적 수량자 *에 대응되는 게으른 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_short">
        <source>match zero or more times (lazy)</source>
        <target state="translated">0번 이상 일치(지연)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_long">
        <source>The * quantifier matches the preceding element zero or more times. It is equivalent to the {0,} quantifier. * is a greedy quantifier whose lazy equivalent is *?.</source>
        <target state="translated">* 수량자는 0번 이상 이전 요소와 일치시킵니다. {0,} 수량자와 같습니다. *는 해당 게으른 수량자가 *?인 탐욕적 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_short">
        <source>match zero or more times</source>
        <target state="translated">0번 이상 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_long">
        <source>The ?? quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier ?</source>
        <target state="translated">?? 수량자는 0번 이상 이전 요소와 일치시키지만 가능한 한 적은 횟수로 일치시킵니다. 탐욕적 수량자 ?에 대응되는 게으른 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_short">
        <source>match zero or one time (lazy)</source>
        <target state="translated">0 또는 1번 일치(지연)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_long">
        <source>The ? quantifier matches the preceding element zero or one time. It is equivalent to the {0,1} quantifier. ? is a greedy quantifier whose lazy equivalent is ??.</source>
        <target state="translated">? 수량자는 0번 이상 이전 요소와 일치시킵니다. {0,1} 수량자와 같습니다. ?는 해당 게으른 수량자가 ??인 탐욕적 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_short">
        <source>match zero or one time</source>
        <target state="translated">0 또는 1번 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_long">
        <source>This grouping construct captures a matched 'subexpression', where 'subexpression' is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one. The capture that is numbered zero is the text matched by the entire regular expression pattern.</source>
        <target state="translated">이 그룹화 생성자는 일치하는 'subexpression'을 캡처합니다. 여기서, 'subexpression'은 임의의 유효한 정규식 패턴입니다. 괄호를 사용하는 캡처는 정규식의 여는 괄호 순서를 기준으로 왼쪽에서 오른쪽으로 1부터 자동으로 번호가 매겨집니다. 0으로 번호가 매겨진 캡처는 전체 정규식 패턴과 일치하는 텍스트입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_short">
        <source>matched subexpression</source>
        <target state="translated">일치하는 하위 식</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name">
        <source>name</source>
        <target state="translated">이름</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name1">
        <source>name1</source>
        <target state="translated">name1</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name2">
        <source>name2</source>
        <target state="translated">name2</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name_or_number">
        <source>name-or-number</source>
        <target state="translated">이름 또는 번호</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_long">
        <source>A named or numbered backreference.

'name' is the name of a capturing group defined in the regular expression pattern.</source>
        <target state="translated">명명되거나 번호가 매겨진 역참조입니다.

'name'은 정규식 패턴에 정의된 캡처링 그룹의 이름입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_short">
        <source>named backreference</source>
        <target state="translated">명명된 역참조</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_long">
        <source>Captures a matched subexpression and lets you access it by name or by number.

'name' is a valid group name, and 'subexpression' is any valid regular expression pattern. 'name' must not contain any punctuation characters and cannot begin with a number.

If the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the only way to capture a subexpression is to explicitly name capturing groups.</source>
        <target state="translated">일치하는 하위 식을 캡처하고 이름 또는 번호를 통해 해당 하위 식에 액세스할 수 있도록 허용합니다.

'name'은 유효한 그룹 이름이고 'subexpression'은 유효한 정규식 패턴입니다. 'name'은 문장 부호 문자를 사용하지 않아야 하며 숫자로 시작할 수 없습니다.

정규식 패턴 일치 메서드의 RegexOptions 매개 변수에 RegexOptions.ExplicitCapture 플래그가 포함되어 있거나 이 하위 식에 n 옵션이 적용되는 경우 하위 식을 캡처하는 유일한 방법은 명시적으로 캡처링 그룹 이름을 지정하는 것입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_short">
        <source>named matched subexpression</source>
        <target state="translated">명명된 일치하는 하위 식</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_long">
        <source>A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters are specified individually.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">부정 문자 그룹은 일치 항목을 찾을 입력 문자열에 표시되지 않아야 하는 문자 목록을 지정합니다. 문자 목록은 개별적으로 지정됩니다.

둘 이상의 문자 범위를 연결할 수 있습니다. 예를 들어 "0"에서 "9"까지의 10진수 범위, "a"에서 "f"까지의 소문자 범위 및 "A"에서 "F"까지의 대문자 범위를 지정하려면 [0-9a-fA-F]를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_short">
        <source>negative character group</source>
        <target state="translated">부정 문자 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_range_long">
        <source>A negative character range specifies a list of characters that must not appear in an input string for a match to occur. 'firstCharacter' is the character that begins the range, and 'lastCharacter' is the character that ends the range.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">부정 문자 범위는 일치 항목을 찾을 입력 문자열에 표시되지 않아야 하는 문자 목록을 지정합니다. 'firstCharacter'는 범위를 시작하는 문자이고 'lastCharacter'는 범위를 끝내는 문자입니다.

둘 이상의 문자 범위를 연결할 수 있습니다. 예를 들어 "0"에서 "9"까지의 10진수 범위, "a"에서 "f"까지의 소문자 범위 및 "A"에서 "F"까지의 대문자 범위를 지정하려면 [0-9a-fA-F]를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_long">
        <source>The regular expression construct \P{ name } matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">정규식 구문 \P{ name }는 유니코드 일반 범주 또는 명명된 블록에 속하지 않는 모든 문자와 일치시킵니다. 여기서, name은 범주 약어 또는 명명된 블록 이름입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_short">
        <source>negative unicode category</source>
        <target state="translated">부정 유니코드 범주</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_long">
        <source>Matches a new-line character, \u000A</source>
        <target state="translated">줄 바꿈 문자 \u000A와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_short">
        <source>new-line character</source>
        <target state="translated">줄 바꿈 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_no">
        <source>no</source>
        <target state="translated">아니요</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_long">
        <source>\D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.

If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9]</source>
        <target state="translated">\D는 숫자가 아닌 문자와 일치시킵니다. \P{Nd} 정규식 패턴과 같습니다.

ECMAScript 규격 동작을 지정한 경우 \D는 [^0-9]와 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_short">
        <source>non-digit character</source>
        <target state="translated">숫자가 아닌 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_long">
        <source>\S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.

If ECMAScript-compliant behavior is specified, \S is equivalent to [^ \f\n\r\t\v]</source>
        <target state="translated">\S는 공백이 아닌 문자와 일치시킵니다. [^\f\n\r\t\v\x85\p{Z}] 정규식 패턴과 같거나, 공백 문자와 일치시키는 \s와 같은 정규식 패턴과 반대됩니다.

ECMAScript 규격 동작을 지정한 경우 \S는 [^ \f\n\r\t\v]와 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_short">
        <source>non-white-space character</source>
        <target state="translated">공백이 아닌 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_long">
        <source>The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor.</source>
        <target state="translated">\B 앵커는 단어 경계에서 일치 항목을 찾도록 지정합니다. \b 앵커와 반대입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_short">
        <source>non-word boundary</source>
        <target state="translated">단어가 아닌 경계</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_character_long">
        <source>\W matches any non-word character. It matches any character except for those in the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \W is equivalent to [^a-zA-Z_0-9]</source>
        <target state="translated">\W는 단어가 아닌 문자와 일치시킵니다. 다음 유니코드 범주의 문자를 제외한 모든 문자와 일치시킵니다.

    Ll	문자, 소문자
    Lu	문자, 대문자
    Lt	문자, 첫 글자만 대문자
    Lo	문자, 기타
    Lm	문자, 한정자
    Mn	표시, 공간을 차지하지 않는 문자
    Nd	숫자, 10진수
    Pc	문장 부호, 연결선

ECMAScript 규격 동작을 지정한 경우 \W는 [^a-zA-Z_0-9]와 같습니다.</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized. </note>
      </trans-unit>
      <trans-unit id="Regex_non_word_character_short">
        <source>non-word character</source>
        <target state="translated">단어가 아닌 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_long">
        <source>This construct does not capture the substring that is matched by a subexpression:

The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.

If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
        <target state="translated">이 구문은 하위 식으로 일치되는 하위 문자열을 캡처하지 않습니다.

한정사가 그룹에 적용되는 경우 일반적으로 비캡처링 그룹 구문이 사용되지만 그룹에서 캡처된 하위 문자열과는 관련이 없습니다.

정규식에 중첩 그룹화 생성자가 포함되는 경우 외부 비캡처링 그룹 구문은 내부 중첩 그룹 구문에 적용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_short">
        <source>noncapturing group</source>
        <target state="translated">비캡처링 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_decimal_digit">
        <source>number, decimal digit</source>
        <target state="translated">숫자, 10진수</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_letter">
        <source>number, letter</source>
        <target state="translated">숫자, 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_other">
        <source>number, other</source>
        <target state="translated">숫자, 기타</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_long">
        <source>A numbered backreference, where 'number' is the ordinal position of the capturing group in the regular expression. For example, \4 matches the contents of the fourth capturing group.

There is an ambiguity between octal escape codes (such as \16) and \number backreferences that use the same notation. If the ambiguity is a problem, you can use the \k&lt;name&gt; notation, which is unambiguous and cannot be confused with octal character codes. Similarly, hexadecimal codes such as \xdd are unambiguous and cannot be confused with backreferences.</source>
        <target state="translated">번호가 매겨진 역참조입니다. 여기서 'number'는 정규식에 있는 캡처링 그룹의 서수 위치입니다. 예를 들어 \4는 네 번째 캡처링 그룹의 콘텐츠와 일치시킵니다.

8진수 이스케이프 코드(예: \16) 및 동일한 표기법을 사용하는 \number 역참조 사이에는 모호성이 있습니다. 모호성 문제가 발생하는 경우 명확하며 8진수 문자 코드와 혼동되지 않는 \k&lt;이름&gt; 표기법을 사용할 수 있습니다. 마찬가지로, \xdd와 같은 16진수 코드는 명확하며 역참조와 혼동되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_short">
        <source>numbered backreference</source>
        <target state="translated">번호가 매겨진 역참조</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_control">
        <source>other, control</source>
        <target state="translated">기타, 제어</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_format">
        <source>other, format</source>
        <target state="translated">기타, 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_not_assigned">
        <source>other, not assigned</source>
        <target state="translated">기타, 할당되지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_private_use">
        <source>other, private use</source>
        <target state="translated">기타, 프라이빗 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_surrogate">
        <source>other, surrogate</source>
        <target state="translated">기타, 서로게이트</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_long">
        <source>A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur.</source>
        <target state="translated">긍정 문자 그룹은 일치 항목을 찾을 입력 문자열에 표시될 수 있는 문자 목록을 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_short">
        <source>positive character group</source>
        <target state="translated">긍정 문자 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_long">
        <source>A positive character range specifies a range of characters, any one of which may appear in an input string for a match to occur.  'firstCharacter' is the character that begins the range and 'lastCharacter' is the character that ends the range. </source>
        <target state="translated">긍정 문자 범위는 일치 항목을 찾을 입력 문자열에 표시될 수 있는 문자 범위를 지정합니다. 'firstCharacter'는 범위를 시작하는 문자이고 'lastCharacter'는 범위를 끝내는 문자입니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_short">
        <source>positive character range</source>
        <target state="translated">긍정 문자 범위</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_close">
        <source>punctuation, close</source>
        <target state="translated">문장 부호, 닫기</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_connector">
        <source>punctuation, connector</source>
        <target state="translated">문장 부호, 연결선</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_dash">
        <source>punctuation, dash</source>
        <target state="translated">문장 부호, 대시</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_final_quote">
        <source>punctuation, final quote</source>
        <target state="translated">문장 부호, 마지막 따옴표</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_initial_quote">
        <source>punctuation, initial quote</source>
        <target state="translated">문장 부호, 처음 따옴표</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_open">
        <source>punctuation, open</source>
        <target state="translated">문장 부호, 열기</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_other">
        <source>punctuation, other</source>
        <target state="translated">문장 부호, 기타</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_line">
        <source>separator, line</source>
        <target state="translated">구분 기호, 줄</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_paragraph">
        <source>separator, paragraph</source>
        <target state="translated">구분 기호, 단락</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_space">
        <source>separator, space</source>
        <target state="translated">구분 기호, 공백</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_long">
        <source>The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input string.</source>
        <target state="translated">\A 앵커는 입력 문자열의 시작 부분에서 일치 항목을 찾도록 지정합니다. \A가 RegexOptions.Multiline 옵션을 무시한다는 점을 제외하고는 ^ 앵커와 동일합니다. 따라서 여러 줄 입력 문자열에서 첫 번째 줄의 시작 부분만 찾을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_short">
        <source>start of string only</source>
        <target state="translated">문자열의 시작만</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_long">
        <source>The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.</source>
        <target state="translated">^ 앵커는 다음 패턴이 문자열의 첫 번째 문자 위치에서 시작하도록 지정합니다. ^ 기호를 RegexOptions.Multiline 옵션과 함께 사용하는 경우 각 줄의 시작 부분에 일치 항목이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_short">
        <source>start of string or line</source>
        <target state="translated">문자열 또는 줄의 시작</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_subexpression">
        <source>subexpression</source>
        <target state="translated">하위 식</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_currency">
        <source>symbol, currency</source>
        <target state="translated">기호, 통화</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_math">
        <source>symbol, math</source>
        <target state="translated">기호, 수학</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_modifier">
        <source>symbol, modifier</source>
        <target state="translated">기호, 한정자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_other">
        <source>symbol, other</source>
        <target state="translated">기호, 기타</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_long">
        <source>Matches a tab character, \u0009</source>
        <target state="translated">탭 문자 \u0009와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_short">
        <source>tab character</source>
        <target state="translated">탭 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_long">
        <source>The regular expression construct \p{ name } matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">정규식 구문 \p{ name }는 유니코드 일반 범주 또는 명명된 블록에 속하는 모든 문자와 일치시킵니다. 여기서, name은 범주 약어 또는 명명된 블록 이름입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_short">
        <source>unicode category</source>
        <target state="translated">유니코드 범주</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_long">
        <source>Matches a UTF-16 code unit whose value is #### hexadecimal.</source>
        <target state="translated">값이 #### 16진수인 UTF-16 코드 단위와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_short">
        <source>unicode escape</source>
        <target state="translated">유니코드 이스케이프</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_general_category_0">
        <source>Unicode General Category: {0}</source>
        <target state="translated">유니코드 일반 범주: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_long">
        <source>Matches a vertical-tab character, \u000B</source>
        <target state="translated">세로 탭 문자 \u000B와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_short">
        <source>vertical-tab character</source>
        <target state="translated">세로 탭 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_long">
        <source>\s matches any white-space character. It is equivalent to the following escape sequences and Unicode categories:

    \f	The form feed character, \u000C
    \n	The newline character, \u000A
    \r	The carriage return character, \u000D
    \t	The tab character, \u0009
    \v	The vertical tab character, \u000B
    \x85	The ellipsis or NEXT LINE (NEL) character (…), \u0085
    \p{Z}	Matches any separator character

If ECMAScript-compliant behavior is specified, \s is equivalent to [ \f\n\r\t\v]</source>
        <target state="translated">\s는 공백 문자와 일치시킵니다. 다음 이스케이프 시퀀스 및 유니코드 범주와 같습니다.

    \f	용지 공급 문자, \u000C
    \n	줄 바꿈 문자, \u000A
    \r	캐리지 리턴 문자, \u000D
    \t	탭 문자, \u0009
    \v	세로 탭 문자, \u000B
    \x85	줄임표 또는 NEXT LINE(NEL) 문자(…), \u0085
    \p{Z}	구분 문자와 일치시킵니다.

ECMAScript와 호환되는 동작을 지정한 경우 \s는 [ \f\n\r\t\v]와 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_short">
        <source>white-space character</source>
        <target state="translated">공백 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_long">
        <source>The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore. The match may also occur on a word boundary at the beginning or end of the string.

The \b anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
        <target state="translated">\b 앵커는 단어 문자(\w 언어 요소)와 단어가 아닌 문자(\W 언어 요소) 사이의 경계에서 일치 항목을 찾도록 지정합니다. 단어 문자는 영숫자 문자 및 밑줄로 구성되고, 단어가 아닌 문자는 영숫자나 밑줄이 아닌 모든 문자입니다. 문자열의 시작 또는 끝부분 단어 경계에서 일치 항목을 찾을 수도 있습니다.

\b 앵커는 하위 식이 단어의 시작 또는 끝부분이 아닌 전체 단어를 일치시키도록 하는 데 자주 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_short">
        <source>word boundary</source>
        <target state="translated">단어 경계</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_character_long">
        <source>\w matches any word character. A word character is a member of any of the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \w is equivalent to [a-zA-Z_0-9]</source>
        <target state="translated">\w는 단어 문자와 일치시킵니다. 단어 문자는 다음 유니코드 범주의 멤버입니다.

    Ll	문자, 소문자
    Lu	문자, 대문자
    Lt	문자, 첫 글자만 대문자
    Lo	문자, 기타
    Lm	문자, 한정자
    Mn	표시, 공간을 차지하지 않는 문자
    Nd	숫자, 10진수
    Pc	문장 부호, 연결선

ECMAScript 규격 동작을 지정한 경우 \w는 [a-zA-Z_0-9]와 같습니다.</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized.</note>
      </trans-unit>
      <trans-unit id="Regex_word_character_short">
        <source>word character</source>
        <target state="translated">단어 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_yes">
        <source>yes</source>
        <target state="translated">예</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_long">
        <source>A zero-width negative lookahead assertion, where for the match to be successful, the input string must not match the regular expression pattern in subexpression. The matched string is not included in the match result.

A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression. At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched. In this case, it is often used to limit backtracking. At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
        <target state="translated">너비가 0인 부정 lookahead 어설션입니다. 여기서, 일치 항목을 찾으려면 입력 문자열이 하위 식의 정규식 패턴과 일치하면 안 됩니다. 일치하는 문자열은 일치 결과에 포함되지 않습니다.

너비가 0인 부정 lookahead 어설션은 일반적으로 정규식의 시작 부분이나 끝부분에 사용됩니다. 정규식의 시작 부분에서는 일치시켜야 하는 유사하지만 보다 일반적인 패턴을 정의할 때 일치시키면 안 되는 특정 패턴을 정의할 수 있습니다. 이 경우 보통 역추적을 제한하는 데 사용됩니다. 정규식의 끝부분에서는 일치 항목의 끝부분에 있으면 안 되는 하위 식을 정의할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_short">
        <source>zero-width negative lookahead assertion</source>
        <target state="translated">너비가 0인 부정 lookahead 어설션</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_long">
        <source>A zero-width negative lookbehind assertion, where for a match to be successful, 'subexpression' must not occur at the input string to the left of the current position. Any substring that does not match 'subexpression' is not included in the match result.

Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define precludes a match in the string that follows. They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</source>
        <target state="translated">너비가 0인 부정 lookbehind 어설션입니다. 여기서, 일치 항목을 찾으려면 입력 문자열에서 현재 위치 왼쪽에 'subexpression'이 없어야 합니다. 'subexpression'과 일치하지 않는 하위 문자열은 일치 결과에 포함되지 않습니다.

너비가 0인 부정 lookbehind 어설션은 일반적으로 정규식의 시작 부분에 사용됩니다. 어설션이 정의하는 패턴은 뒤에 오는 문자열에 일치 항목이 없도록 합니다. 캡처된 그룹에 있는 마지막 문자가 해당 그룹의 정규식 패턴과 일치하는 하나 이상의 문자가 아니어야 하는 경우 역추적을 제한하는 데도 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_short">
        <source>zero-width negative lookbehind assertion</source>
        <target state="translated">너비가 0인 부정 lookbehind 어설션</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_long">
        <source>A zero-width positive lookahead assertion, where for a match to be successful, the input string must match the regular expression pattern in 'subexpression'. The matched substring is not included in the match result. A zero-width positive lookahead assertion does not backtrack.

Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern. It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match. It is also useful for preventing excessive backtracking. You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</source>
        <target state="translated">너비가 0인 긍정 lookahead 어설션입니다. 여기서, 일치 항목을 찾으려면 입력 문자열이 'subexpression'의 정규식 패턴과 일치해야 합니다. 일치된 하위 문자열은 일치 결과에 포함되지 않습니다. 너비가 0인 긍정 lookahead 어설션은 역추적하지 않습니다.

일반적으로 너비가 0인 긍정 lookahead 어설션은 정규식 패턴 끝에 있습니다. 이 어설션은 일치 항목을 찾을 문자열 끝에 있어야 하지만 일치에 포함되면 안 되는 하위 문자열을 정의합니다. 또한, 과도한 역추적을 방지하는 데에도 유용합니다. 너비가 0인 긍정 lookahead 어설션을 사용하면 캡처된 특정 그룹이 이 캡처된 그룹에 정의된 패턴의 하위 집합과 일치하는 텍스트로 시작하도록 할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_short">
        <source>zero-width positive lookahead assertion</source>
        <target state="translated">너비가 0인 긍정 lookahead 어설션</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_long">
        <source>A zero-width positive lookbehind assertion, where for a match to be successful, 'subexpression' must occur at the input string to the left of the current position. 'subexpression' is not included in the match result. A zero-width positive lookbehind assertion does not backtrack.

Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
        <target state="translated">너비가 0인 긍정 lookbehind 어설션입니다. 여기서, 일치 항목을 찾으려면 입력 문자열에서 현재 위치 왼쪽에 'subexpression'이 있어야 합니다. 'subexpression'은 일치 결과에 포함되지 않습니다. 너비가 0인 긍정 lookbehind 어설션은 역추적하지 않습니다.

너비가 0인 긍정 lookbehind 어설션은 일반적으로 정규식의 시작 부분에 사용됩니다. 어설션이 정의하는 패턴은 일치 항목의 사전 조건이지만 일치 결과에 포함되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_short">
        <source>zero-width positive lookbehind assertion</source>
        <target state="translated">너비가 0인 긍정 lookbehind 어설션</target>
        <note />
      </trans-unit>
      <trans-unit id="Removal_of_document_not_supported">
        <source>Removal of document not supported</source>
        <target state="translated">지원되지 않는 문서 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unnecessary_casts">
        <source>Remove unnecessary casts</source>
        <target state="translated">불필요한 캐스트 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unnecessary_imports_or_usings">
        <source>Remove unnecessary imports or usings</source>
        <target state="translated">불필요한 가져오기 또는 사용 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unused_parameters">
        <source>Remove unused parameters</source>
        <target state="translated">사용하지 않는 매개 변수 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unused_suppressions">
        <source>Remove unused suppressions</source>
        <target state="translated">사용하지 않는 제거 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unused_variables">
        <source>Remove unused variables</source>
        <target state="translated">사용하지 않는 변수 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_0_that_contains_an_active_statement_requires_restarting_the_application">
        <source>Removing {0} that contains an active statement requires restarting the application.</source>
        <target state="translated">활성 문이 포함된 {0}을(를) 제거하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Renaming_0_requires_restarting_the_application">
        <source>Renaming {0} requires restarting the application.</source>
        <target state="translated">{0} 이름을 바꾸려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Renaming_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
        <source>Renaming {0} requires restarting the application because it is not supported by the runtime.</source>
        <target state="translated">런타임에서 지원하지 않기 때문에 {0}의 이름을 바꾸려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Renaming_a_captured_variable_from_0_to_1_requires_restarting_the_application">
        <source>Renaming a captured variable, from '{0}' to '{1}' requires restarting the application.</source>
        <target state="translated">캡처된 변수의 이름을 '{0}'에서 '{1}'(으)로 바꾸려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_1">
        <source>Replace '{0}' with '{1}' </source>
        <target state="translated">'{0}'을(를) '{1}'(으)로 바꾸기</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_conditional_expression_with_statements">
        <source>Replace conditional expression with statements</source>
        <target state="translated">조건식을 명령문으로 바꾸기</target>
        <note />
      </trans-unit>
      <trans-unit id="Required">
        <source>required</source>
        <target state="translated">필수 사항</target>
        <note>Used in the object initializer completion.</note>
      </trans-unit>
      <trans-unit id="Resolve_0">
        <source>Resolve: '{0}'</source>
        <target state="translated">확인: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Resolve_module_0_of_1">
        <source>Resolve module: '{0}' of '{1}'</source>
        <target state="translated">모듈 확인: '{0}'/'{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="RudeEdit">
        <source>Rude edit</source>
        <target state="translated">편집 다시 실행</target>
        <note />
      </trans-unit>
      <trans-unit id="Run_All_Tests">
        <source>Run All Tests</source>
        <target state="translated">모든 테스트 실행</target>
        <note />
      </trans-unit>
      <trans-unit id="Run_Test">
        <source>Run Test</source>
        <target state="translated">테스트 실행</target>
        <note />
      </trans-unit>
      <trans-unit id="Selection_does_not_contain_a_valid_token">
        <source>Selection does not contain a valid token.</source>
        <target state="translated">선택 항목에 유효한 토큰이 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Selection_not_contained_inside_a_type">
        <source>Selection not contained inside a type.</source>
        <target state="translated">선택 항목이 형식 내에 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="SemanticSearch">
        <source>Semantic Search</source>
        <target state="new">Semantic Search</target>
        <note />
      </trans-unit>
      <trans-unit id="Semantic_search_only_supported_on_net_core">
        <source>Semantic search is only supported when code analysis runs in a separate process on the latest .NET (see Tools &gt; Options &gt; Text Editor &gt; C# &gt; Advanced).</source>
        <target state="new">Semantic search is only supported when code analysis runs in a separate process on the latest .NET (see Tools &gt; Options &gt; Text Editor &gt; C# &gt; Advanced).</target>
        <note />
      </trans-unit>
      <trans-unit id="Silent">
        <source>Silent</source>
        <target state="translated">침묵</target>
        <note />
      </trans-unit>
      <trans-unit id="Simplify_member_access_0">
        <source>Simplify member access '{0}'</source>
        <target state="translated">멤버 액세스 '{0}' 단순화</target>
        <note />
      </trans-unit>
      <trans-unit id="Simplify_name_0">
        <source>Simplify name '{0}'</source>
        <target state="translated">'{0}' 이름 단순화</target>
        <note />
      </trans-unit>
      <trans-unit id="Sort_Imports_or_usings">
        <source>Sort Imports or usings</source>
        <target state="translated">Import 또는 Using 정렬</target>
        <note />
      </trans-unit>
      <trans-unit id="Sort_accessibility_modifiers">
        <source>Sort accessibility modifiers</source>
        <target state="translated">접근성 한정자 정렬</target>
        <note />
      </trans-unit>
      <trans-unit id="Source_code_language_information_was_not_found_in_PDB">
        <source>Source code language information was not found in PDB.</source>
        <target state="translated">PDB에서 원본 코드 언어 정보를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Source_is_a_reference_assembly">
        <source>Source is a reference assembly, not enough information to find PDB.</source>
        <target state="translated">원본은 참조 어셈블리이며 PDB를 찾을 수 있는 정보가 부족합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Split_into_consecutive_0_statements">
        <source>Split into consecutive '{0}' statements</source>
        <target state="translated">연속 '{0}' 문으로 분할</target>
        <note />
      </trans-unit>
      <trans-unit id="Split_into_nested_0_statements">
        <source>Split into nested '{0}' statements</source>
        <target state="translated">중첩 '{0}' 문으로 분할</target>
        <note />
      </trans-unit>
      <trans-unit id="Strings_must_start_with_double_quote_not_single_quote">
        <source>Strings must start with " not '</source>
        <target state="translated">문자열은 " not '으로 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Suppress_0">
        <source>Suppress {0}</source>
        <target state="translated">{0}을(를) 표시하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="Switching_between_lambda_and_local_function_requires_restarting_the_application">
        <source>Switching between a lambda and a local function requires restarting the application.</source>
        <target state="translated">람다 함수와 로컬 함수 간에 전환하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbol_found_in_assembly_path_0">
        <source>Symbol found in assembly path '{0}'</source>
        <target state="translated">어셈블리 경로 '{0}'에서 기호를 찾음</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbol_search">
        <source>Symbol search</source>
        <target state="translated">기호 검색</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbols">
        <source>Symbols</source>
        <target state="translated">기호</target>
        <note />
      </trans-unit>
      <trans-unit id="Syntax_error">
        <source>Syntax error</source>
        <target state="translated">구문 오류</target>
        <note />
      </trans-unit>
      <trans-unit id="Target_type_matches">
        <source>Target type matches</source>
        <target state="translated">대상 유형 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="The_assembly_0_containing_type_1_references_NET_Framework">
        <source>The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.</source>
        <target state="translated">'{1}' 형식을 포함하는 '{0}' 어셈블리가 지원되지 않는 .NET Framework를 참조합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_assembly_0_references_compiler_version_1_newer_than_2">
        <source>Analyzer assembly '{0}' cannot be used because it references version '{1}' of the compiler, which is newer than the currently running version '{2}'.</source>
        <target state="needs-review-translation">분석기 어셈블리 '{0}'은(는) 컴파일러의 '{1}' 버전을 참조하며, 이 버전은 현재 실행 중인 버전 '{2}'보다 최신 버전입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_selection_contains_a_local_function_call_without_its_declaration">
        <source>The selection contains a local function call without its declaration.</source>
        <target state="translated">선언이 없는 로컬 함수 호출이 선택 영역에 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_symbol_has_no_base">
        <source>The symbol has no base.</source>
        <target state="translated">기호에 베이스가 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_symbol_has_no_implementations">
        <source>The symbol has no implementations.</source>
        <target state="translated">기호에 구현이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="This_0_has_1_references">
        <source>This {0} has {1} reference(s).</source>
        <target state="translated">이 {0}에는 {1}개의 참조가 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Timeout_SourceLink">
        <source>Timed out trying to download source code from SourceLink. Subsequent requests may succeed.</source>
        <target state="translated">SourceLink에서 원본 코드를 다운로드하는 동안 시간이 초과되었습니다. 후속 요청이 성공할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Timeout_symbol_server">
        <source>Timed out trying to download PDB from symbol server. Subsequent requests may succeed.</source>
        <target state="translated">기호 서버에서 PDB를 다운로드하는 동안 시간이 초과되었습니다. 후속 요청이 성공할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Too_many_bars_in_conditional_grouping">
        <source>Too many | in (?()|)</source>
        <target state="translated">(?()|)에 |가 너무 많습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0)a|b|)</note>
      </trans-unit>
      <trans-unit id="Too_many_close_parens">
        <source>Too many )'s</source>
        <target state="translated">)가 너무 많습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: )</note>
      </trans-unit>
      <trans-unit id="Trailing_comma_not_allowed">
        <source>Trailing comma not allowed</source>
        <target state="translated">후행 쉼표는 허용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Types_colon">
        <source>Types:</source>
        <target state="translated">형식:</target>
        <note />
      </trans-unit>
      <trans-unit id="UnableToReadSourceFileOrPdb">
        <source>Unable to read source file '{0}' or the PDB built for the containing project. Any changes made to this file while debugging won't be applied until its content matches the built source.</source>
        <target state="translated">소스 파일 '{0}' 또는 포함하는 프로젝트에 대해 빌드된 PDB를 읽을 수 없습니다. 디버그하는 동안 이 파일의 변경된 모든 내용은 해당 콘텐츠가 빌드된 소스와 일치할 때까지 적용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unable_to_create_0">
        <source>Unable to create '{0}'</source>
        <target state="translated">{0}(을)를 만들 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="Unable_to_get_the_directory_name_for_0">
        <source>Unable to get the directory name for {0}.</source>
        <target state="new">Unable to get the directory name for {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_property">
        <source>Unknown property</source>
        <target state="translated">알 수 없는 속성</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{}</note>
      </trans-unit>
      <trans-unit id="Unknown_property_0">
        <source>Unknown property '{0}'</source>
        <target state="translated">알 수 없는 속성 '{0}'</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{xxx}. Here, {0} will be the name of the unknown property ('xxx')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_control_character">
        <source>Unrecognized control character</source>
        <target state="translated">인식할 수 없는 제어 문자입니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [\c]</note>
      </trans-unit>
      <trans-unit id="Unrecognized_escape_sequence_0">
        <source>Unrecognized escape sequence \{0}</source>
        <target state="translated">인식할 수 없는 이스케이프 시퀀스 \{0}입니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \m. Here, {0} will be the unrecognized character ('m')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_grouping_construct">
        <source>Unrecognized grouping construct</source>
        <target state="translated">인식할 수 없는 그룹화 생성자입니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;</note>
      </trans-unit>
      <trans-unit id="Unterminated_character_class_set">
        <source>Unterminated [] set</source>
        <target state="translated">종결되지 않은 [] 집합</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [</note>
      </trans-unit>
      <trans-unit id="Unterminated_comment">
        <source>Unterminated comment</source>
        <target state="translated">종결되지 않은 주석</target>
        <note />
      </trans-unit>
      <trans-unit id="Unterminated_regex_comment">
        <source>Unterminated (?#...) comment</source>
        <target state="translated">종격되지 않은 (?#...) 주석</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?#</note>
      </trans-unit>
      <trans-unit id="Unterminated_string">
        <source>Unterminated string</source>
        <target state="translated">종결되지 않은 문자열</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_all_arguments">
        <source>Unwrap all arguments</source>
        <target state="translated">모든 인수 래핑 해제</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_all_elements">
        <source>Unwrap all elements</source>
        <target state="translated">모든 요소 래핑 해제</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_all_parameters">
        <source>Unwrap all parameters</source>
        <target state="translated">모든 매개 변수 래핑 해제</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_and_indent_all_arguments">
        <source>Unwrap and indent all arguments</source>
        <target state="translated">모든 인수 래핑 해제 및 들여쓰기</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_and_indent_all_parameters">
        <source>Unwrap and indent all parameters</source>
        <target state="translated">모든 매개 변수 래핑 해제 및 들여쓰기</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_argument_list">
        <source>Unwrap argument list</source>
        <target state="translated">인수 목록 래핑 해제</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_call_chain">
        <source>Unwrap call chain</source>
        <target state="translated">호출 체인 래핑 해제</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_collection">
        <source>Unwrap collection</source>
        <target state="translated">컬렉션 래핑 해제</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_expression">
        <source>Unwrap expression</source>
        <target state="translated">식 래핑 해제</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_initializer">
        <source>Unwrap initializer</source>
        <target state="translated">이니셜라이저 래핑 해제</target>
        <note />
      </trans-unit>
      <trans-unit id="Unwrap_parameter_list">
        <source>Unwrap parameter list</source>
        <target state="translated">매개 변수 목록 래핑 해제</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_0_requires_restarting_the_application">
        <source>Updating '{0}' requires restarting the application.</source>
        <target state="translated">'{0}'을(를) 업데이트하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_0_within_generic_type_or_method_requires_restarting_the_application_because_is_not_supported_by_the_runtime">
        <source>Updating {0} within generic type or method requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">런타임에서 지원하지 않기 때문에 제네릭 형식 또는 메서드 내에서 {0}을(를) 업데이트하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_a_0_around_an_active_statement_requires_restarting_the_application">
        <source>Updating a {0} around an active statement requires restarting the application.</source>
        <target state="translated">활성 문 주변의 {0}을(를) 업데이트하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_a_complex_statement_containing_an_await_expression_requires_restarting_the_application">
        <source>Updating a complex statement containing an await expression requires restarting the application.</source>
        <target state="translated">await 식을 포함하는 복잡한 문을 업데이트하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_an_active_statement_requires_restarting_the_application">
        <source>Updating an active statement requires restarting the application.</source>
        <target state="translated">활성 명령문을 업데이트하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_async_or_iterator_modifier_around_an_active_statement_requires_restarting_the_application">
        <source>Updating async or iterator modifier around an active statement requires restarting the application.</source>
        <target state="translated">활성 문 주변의 async 또는 iterator 수정자를 업데이트하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note>{Locked="async"}{Locked="iterator"} "async" and "iterator" are C#/VB keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Updating_async_or_iterator_requires_restarting_the_application_because_is_not_supported_by_the_runtime">
        <source>Updating async or iterator requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">런타임에서 지원하지 않기 때문에 비동기 또는 반복기를 업데이트하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_reloadable_type_marked_by_0_attribute_or_its_member_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
        <source>Updating a reloadable type (marked by {0}) or its member requires restarting the application because is not supported by the runtime.</source>
        <target state="translated">런타임에서 지원되지 않으므로 다시 로드할 수 있는 형식({0}(으)로 표시) 또는 해당 멤버를 업데이트하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_Handles_clause_of_0_requires_restarting_the_application">
        <source>Updating the Handles clause of {0} requires restarting the application.</source>
        <target state="translated">{0}의 Handles 절을 업데이트하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note>{Locked="Handles"} "Handles" is VB keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Updating_the_Implements_clause_of_a_0_requires_restarting_the_application">
        <source>Updating the Implements clause of a {0} requires restarting the application.</source>
        <target state="translated">{0}의 Implements 절을 업데이트하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note>{Locked="Implements"} "Implements" is VB keywords and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Updating_the_alias_of_Declare_statement_requires_restarting_the_application">
        <source>Updating the alias of Declare statement requires restarting the application.</source>
        <target state="translated">Declare 문의 별칭을 업데이트하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note>{Locked="Declare"} "Declare" is VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Updating_the_attributes_of_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime">
        <source>Updating the attributes of {0} requires restarting the application because it is not supported by the runtime.</source>
        <target state="translated">{0}의 특성을 업데이트하려면 런타임에서 지원되지 않으므로 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_base_class_and_or_base_interface_s_of_0_requires_restarting_the_application">
        <source>Updating the base class and/or base interface(s) of {0} requires restarting the application.</source>
        <target state="translated">{0}의 기본 클래스 및/또는 기본 인터페이스를 업데이트하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_initializer_of_0_requires_restarting_the_application">
        <source>Updating the initializer of {0} requires restarting the application.</source>
        <target state="translated">{0}의 이니셜라이저를 업데이트하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_kind_of_a_property_event_accessor_requires_restarting_the_application">
        <source>Updating the kind of a property/event accessor requires restarting the application.</source>
        <target state="translated">속성/이벤트 접근자의 종류를 업데이트하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_kind_of_a_type_requires_restarting_the_application">
        <source>Updating the kind of a type requires restarting the application.</source>
        <target state="translated">형식 종류를 업데이트하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_library_name_of_Declare_statement_requires_restarting_the_application">
        <source>Updating the library name of Declare statement requires restarting the application.</source>
        <target state="translated">Declare 문의 라이브러리 이름을 업데이트하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note>{Locked="Declare"} "Declare" is VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="Updating_the_modifiers_of_0_requires_restarting_the_application">
        <source>Updating the modifiers of {0} requires restarting the application.</source>
        <target state="translated">{0}의 한정자를 업데이트하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_size_of_a_0_requires_restarting_the_application">
        <source>Updating the size of a {0} requires restarting the application.</source>
        <target state="translated">{0}의 크기를 업데이트하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_type_of_0_requires_restarting_the_application">
        <source>Updating the type of {0} requires restarting the application.</source>
        <target state="translated">{0} 유형을 업데이트하려면 애플리케이션을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_underlying_type_of_0_requires_restarting_the_application">
        <source>Updating the underlying type of {0} requires restarting the application.</source>
        <target state="translated">{0}의 기본 유형을 업데이트하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Updating_the_variance_of_0_requires_restarting_the_application">
        <source>Updating the variance of {0} requires restarting the application.</source>
        <target state="translated">{0}의 분산을 업데이트하려면 응용 프로그램을 다시 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Value_colon">
        <source>Value:</source>
        <target state="translated">값:</target>
        <note />
      </trans-unit>
      <trans-unit id="Value_required">
        <source>Value required</source>
        <target state="translated">값이 필요함</target>
        <note />
      </trans-unit>
      <trans-unit id="WARN_Version_mismatch_Expected_0_Got_1">
        <source>WARN: Version mismatch. Expected: '{0}', Got: '{1}'</source>
        <target state="translated">WARN: 버전이 일치하지 않습니다. 예상: '{0}', 실제: '{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_changing_namespace_may_produce_invalid_code_and_change_code_meaning">
        <source>Warning: Changing namespace may produce invalid code and change code meaning.</source>
        <target state="translated">경고: 네임스페이스를 변경하면 잘못된 코드가 발생하고 코드 의미가 변경될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_semantics_may_change_when_converting_statement">
        <source>Warning: Semantics may change when converting statement.</source>
        <target state="translated">경고: 문을 변환할 때 의미 체계가 변경될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_and_align_call_chain">
        <source>Wrap and align call chain</source>
        <target state="translated">호출 체인 래핑 및 맞춤</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_and_align_expression">
        <source>Wrap and align expression</source>
        <target state="translated">식 래핑 및 맞추기</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_and_align_long_call_chain">
        <source>Wrap and align long call chain</source>
        <target state="translated">긴 호출 체인 래핑 및 맞춤</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_call_chain">
        <source>Wrap call chain</source>
        <target state="translated">호출 체인 래핑</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_collection">
        <source>Wrap collection</source>
        <target state="translated">컬렉션 래핑</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_every_argument">
        <source>Wrap every argument</source>
        <target state="translated">모든 인수 래핑</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_every_parameter">
        <source>Wrap every parameter</source>
        <target state="translated">모든 매개 변수 래핑</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_expression">
        <source>Wrap expression</source>
        <target state="translated">식 래핑</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_initializer">
        <source>Wrap initializer</source>
        <target state="translated">이니셜라이저 래핑</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_argument_list">
        <source>Wrap long argument list</source>
        <target state="translated">긴 인수 목록 래핑</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_call_chain">
        <source>Wrap long call chain</source>
        <target state="translated">긴 호출 체인 래핑</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_collection">
        <source>Wrap long collection</source>
        <target state="translated">긴 컬렉션 래핑</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_initializer">
        <source>Wrap long initializer</source>
        <target state="translated">긴 이니셜라이저 래핑</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrap_long_parameter_list">
        <source>Wrap long parameter list</source>
        <target state="translated">긴 매개 변수 목록 래핑</target>
        <note />
      </trans-unit>
      <trans-unit id="Wrapping">
        <source>Wrapping</source>
        <target state="translated">래핑</target>
        <note />
      </trans-unit>
      <trans-unit id="You_can_use_the_navigation_bar_to_switch_contexts">
        <source>You can use the navigation bar to switch contexts.</source>
        <target state="translated">탐색 모음을 사용하여 컨텍스트를 전환할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_cannot_rename_elements_from_previous_submissions">
        <source>You cannot rename elements from previous submissions.</source>
        <target state="translated">이전 전송 요소의 이름을 바꿀 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_cannot_rename_elements_that_are_defined_in_metadata">
        <source>You cannot rename elements that are defined in metadata.</source>
        <target state="translated">메타데이터에서 정의된 요소의 이름을 바꿀 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_cannot_rename_operators">
        <source>You cannot rename operators.</source>
        <target state="translated">연산자의 이름을 바꿀 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_cannot_rename_this_element">
        <source>You cannot rename this element.</source>
        <target state="translated">이 요소의 이름을 바꿀 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_must_rename_an_identifier">
        <source>You must rename an identifier.</source>
        <target state="translated">식별자의 이름을 바꿔야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_bases">
        <source>'{0}' bases</source>
        <target state="translated">'{0}' 기본</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_cannot_be_negative">
        <source>'{0}' cannot be negative</source>
        <target state="new">'{0}' cannot be negative</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_cannot_be_negative_or_zero">
        <source>'{0}' cannot be negative or zero</source>
        <target state="new">'{0}' cannot be negative or zero</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_cannot_be_null_or_empty">
        <source>'{0}' cannot be null or empty.</source>
        <target state="translated">'{0}'은(는) Null이거나 비워 둘 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_cannot_be_null_or_whitespace">
        <source>'{0}' cannot be null or whitespace.</source>
        <target state="translated">'{0}'은(는) null이거나 공백일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_dash_1">
        <source>{0} - {1}</source>
        <target state="translated">{0} - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_expected">
        <source>'{0}' expected</source>
        <target state="translated">'{0}'이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_in_embedded_PDB">
        <source>'{0}' found in embedded PDB.</source>
        <target state="translated">포함된 PDB에서 '{0}'을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_in_embedded_PDB_but_checksum_failed">
        <source>'{0}' found in embedded PDB but checksum was wrong, or couldn't read temp file.</source>
        <target state="translated">포함된 PDB에서 '{0}'을(를) 찾았지만 체크섬이 잘못되었거나 임시 파일을 읽을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_in_embedded_PDB_but_could_not_write_file_1">
        <source>'{0}' found in embedded PDB but could not write to temp file: '{1}'</source>
        <target state="translated">포함된 PDB에서 '{0}'을 찾았지만 임시 파일 '{1}'에 쓸 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_in_embedded_PDB_cached_source_file">
        <source>'{0}' found in embedded PDB and found cached source file.</source>
        <target state="translated">포함된 PDB에서 '{0}'을(를) 찾았으며 캐시된 원본 파일을 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_in_original_location">
        <source>'{0}' found in original location.</source>
        <target state="translated">원래 위치에 '{0}'이(가) 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_in_original_location_but_checksum_failed">
        <source>'{0}' found in original location but checksum was wrong, or couldn't read temp file.</source>
        <target state="translated">'{0}'이(가) 원래 위치에서 발견되었지만 체크섬이 잘못되었거나 임시 파일을 읽을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_via_SourceLink">
        <source>'{0}' found via SourceLink.</source>
        <target state="translated">SourceLink를 통해 '{0}'을(를) 찾았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_found_via_SourceLink_but_couldnt_read_file">
        <source>'{0}' found via SourceLink but couldn't read temp file.</source>
        <target state="translated">SourceLink를 통해 '{0}'을(를) 찾았지만 임시 파일을 읽을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_implementations">
        <source>'{0}' implementations</source>
        <target state="translated">'{0}' 구현</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_null_here">
        <source>'{0}' is not null here.</source>
        <target state="translated">'{0}'은(는) 여기에서 null이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_nullable_aware">
        <source>'{0}' is not nullable aware.</source>
        <target state="new">'{0}' is not nullable aware.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_items_in_cache">
        <source>'{0}' items in cache</source>
        <target state="translated">캐시의 '{0}'개 항목</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_literal_not_allowed">
        <source>'{0}' literal not allowed</source>
        <target state="translated">'{0}' 리터럴을 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_may_be_null_here">
        <source>'{0}' may be null here.</source>
        <target state="translated">'{0}'은(는) 여기에서 null일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_reference_unquoted">
        <source>{0} reference</source>
        <target state="translated">참조 {0}개</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_references">
        <source>'{0}' references</source>
        <target state="translated">'{0}' 참조</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_references_unquoted">
        <source>{0} references</source>
        <target state="translated">참조 {0}개</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_unexpected">
        <source>'{0}' unexpected</source>
        <target state="translated">예기치 않은 ‘{0}’</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second">
        <source>10,000,000ths of a second</source>
        <target state="translated">10,000,000분의 1초</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second_description">
        <source>The "fffffff" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value.

Although it's possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"fffffff" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자 7개를 나타냅니다. 즉, 날짜 및 시간 값에서 10,000,000분의 1초를 나타냅니다.

시간 값의 초 부분의 10,000,000분의 1초를 표시하는 것이 가능하긴 하나, 이 값은 의미가 없을 수 있습니다. 날짜 및 시간 값의 정밀도는 시스템 시계의 해상도에 따라 달라집니다. Windows NT 3.5(및 이후 버전) 및 Windows Vista 운영 체제의 시계 해상도는 약 10~15밀리초입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second_non_zero">
        <source>10,000,000ths of a second (non-zero)</source>
        <target state="translated">10,000,000분의 1초(0이 아님)</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000000ths_of_a_second_non_zero_description">
        <source>The "FFFFFFF" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value. However, trailing zeros or seven zero digits aren't displayed.

Although it's possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"FFFFFFF" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자 7개를 나타냅니다. 즉, 날짜 및 시간 값에서 10,000,000분의 1초를 나타냅니다. 그러나 후행 0 또는 7개의 0은 표시되지 않습니다.

시간 값의 초 부분의 10,000,000분의 1초를 표시하는 것이 가능하긴 하나, 이 값은 의미가 없을 수 있습니다. 날짜 및 시간 값의 정밀도는 시스템 시계의 해상도에 따라 달라집니다. Windows NT 3.5(및 이후 버전) 및 Windows Vista 운영 체제의 시계 해상도는 약 10~15밀리초입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second">
        <source>1,000,000ths of a second</source>
        <target state="translated">1,000,000분의 1초</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second_description">
        <source>The "ffffff" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value.

Although it's possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"ffffff" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자 6개를 나타냅니다. 즉, 날짜 및 시간 값에서 1,000,000분의 1초를 나타냅니다.

시간 값의 초 부분의 1,000,000분의 1초를 표시하는 것이 가능하긴 하나, 이 값은 의미가 없을 수 있습니다. 날짜 및 시간 값의 정밀도는 시스템 시계의 해상도에 따라 달라집니다. Windows NT 3.5(및 이후 버전) 및 Windows Vista 운영 체제의 시계 해상도는 약 10~15밀리초입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second_non_zero">
        <source>1,000,000ths of a second (non-zero)</source>
        <target state="translated">1,000,000분의 1초(0이 아님)</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000000ths_of_a_second_non_zero_description">
        <source>The "FFFFFF" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value. However, trailing zeros or six zero digits aren't displayed.

Although it's possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"FFFFFF" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자 6개를 나타냅니다. 즉, 날짜 및 시간 값에서 1,000,000분의 1초를 나타냅니다. 그러나 후행 0 또는 6개의 0은 표시되지 않습니다.

시간 값의 초 부분의 1,000,000분의 1초를 표시하는 것이 가능하긴 하나, 이 값은 의미가 없을 수 있습니다. 날짜 및 시간 값의 정밀도는 시스템 시계의 해상도에 따라 달라집니다. Windows NT 3.5(및 이후 버전) 및 Windows Vista 운영 체제의 시계 해상도는 약 10~15밀리초입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second">
        <source>100,000ths of a second</source>
        <target state="translated">100,000분의 1초</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second_description">
        <source>The "fffff" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value.

Although it's possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"fffff" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자 5개를 나타냅니다. 즉, 날짜 및 시간 값에서 100,000분의 1초를 나타냅니다.

시간 값의 초 부분의 100,000분의 1초를 표시하는 것이 가능하긴 하나, 이 값은 의미가 없을 수 있습니다. 날짜 및 시간 값의 정밀도는 시스템 시계의 해상도에 따라 달라집니다. Windows NT 3.5(및 이후 버전) 및 Windows Vista 운영 체제의 시계 해상도는 약 10~15밀리초입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second_non_zero">
        <source>100,000ths of a second (non-zero)</source>
        <target state="translated">100,000분의 1초(0이 아님)</target>
        <note />
      </trans-unit>
      <trans-unit id="_100000ths_of_a_second_non_zero_description">
        <source>The "FFFFF" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value. However, trailing zeros or five zero digits aren't displayed.

Although it's possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"FFFFF" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자 5개를 나타냅니다. 즉, 날짜 및 시간 값에서 100,000분의 1초를 나타냅니다. 그러나 후행 0 또는 5개의 0은 표시되지 않습니다.

시간 값의 초 부분의 100,000분의 1초를 표시하는 것이 가능하긴 하나, 이 값은 의미가 없을 수 있습니다. 날짜 및 시간 값의 정밀도는 시스템 시계의 해상도에 따라 달라집니다. Windows NT 3.5(및 이후 버전) 및 Windows Vista 운영 체제의 시계 해상도는 약 10~15밀리초입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second">
        <source>10,000ths of a second</source>
        <target state="translated">10,000분의 1초</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second_description">
        <source>The "ffff" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value.

Although it's possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT version 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"ffff" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자 4개를 나타냅니다. 즉, 날짜 및 시간 값에서 10,000분의 1초를 나타냅니다.

시간 값의 초 부분의 10,000분의 1초를 표시하는 것이 가능하긴 하나, 이 값은 의미가 없을 수 있습니다. 날짜 및 시간 값의 정밀도는 시스템 시계의 해상도에 따라 달라집니다. Windows NT 버전 3.5(및 이후 버전) 및 Windows Vista 운영 체제의 시계 해상도는 약 10~15밀리초입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second_non_zero">
        <source>10,000ths of a second (non-zero)</source>
        <target state="translated">10,000분의 1초(0이 아님)</target>
        <note />
      </trans-unit>
      <trans-unit id="_10000ths_of_a_second_non_zero_description">
        <source>The "FFFF" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value. However, trailing zeros or four zero digits aren't displayed.

Although it's possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</source>
        <target state="translated">"FFFF" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자 4개를 나타냅니다. 즉, 날짜 및 시간 값에서 10,000분의 1초를 나타냅니다. 그러나 후행 0 또는 4개의 0은 표시되지 않습니다.

시간 값의 초 부분의 10,000분의 1초를 표시하는 것이 가능하긴 하나, 이 값은 의미가 없을 수 있습니다. 날짜 및 시간 값의 정밀도는 시스템 시계의 해상도에 따라 달라집니다. Windows NT 3.5(및 이후 버전) 및 Windows Vista 운영 체제에서의 시계 해상도는 약 10~15밀리초입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second">
        <source>1,000ths of a second</source>
        <target state="translated">1,000분의 1초</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second_description">
        <source>The "fff" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value.</source>
        <target state="translated">"fff" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자 3개를 나타냅니다. 즉, 날짜 및 시간 값에서 1,000분의 1초를 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second_non_zero">
        <source>1,000ths of a second (non-zero)</source>
        <target state="translated">1,000분의 1초(0이 아님)</target>
        <note />
      </trans-unit>
      <trans-unit id="_1000ths_of_a_second_non_zero_description">
        <source>The "FFF" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value. However, trailing zeros or three zero digits aren't displayed.</source>
        <target state="translated">"FFF" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자 3개를 나타냅니다. 즉, 날짜 및 시간 값에서 1,000분의 1초를 나타냅니다. 그러나 후행 0 또는 3개의 0은 표시되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second">
        <source>100ths of a second</source>
        <target state="translated">100분의 1초</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second_description">
        <source>The "ff" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value.</source>
        <target state="translated">"ff" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자 2개를 나타냅니다. 즉, 날짜 및 시간 값에서 100분의 1초를 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second_non_zero">
        <source>100ths of a second (non-zero)</source>
        <target state="translated">100분의 1초(0이 아님)</target>
        <note />
      </trans-unit>
      <trans-unit id="_100ths_of_a_second_non_zero_description">
        <source>The "FF" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value. However, trailing zeros or two zero digits aren't displayed.</source>
        <target state="translated">"FF" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자 2개를 나타냅니다. 즉, 날짜 및 시간 값에서 100분의 1초를 나타냅니다. 그러나 후행 0 또는 2개의 0은 표시되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second">
        <source>10ths of a second</source>
        <target state="translated">10분의 1초</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second_description">
        <source>The "f" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value.

If the "f" format specifier is used without other format specifiers, it's interpreted as the "f" standard date and time format specifier.

When you use "f" format specifiers as part of a format string supplied to the ParseExact or TryParseExact method, the number of "f" format specifiers indicates the number of most significant digits of the seconds fraction that must be present to successfully parse the string.</source>
        <target state="translated">"f" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자를 나타냅니다. 즉, 날짜 및 시간 값에서 10분의 1초를 나타냅니다.

다른 형식 지정자 없이 "f" 형식 지정자를 사용하면 "f" 표준 날짜 및 시간 형식 지정자로 해석됩니다.

ParseExact 또는 TryParseExact 메서드로 제공되는 형식 문자열의 일부로 "f" 형식 지정자를 사용할 경우 "f" 형식 지정자의 개수는 초 부분에서 문자열을 성공적으로 구문 분석하려면 존재해야 하는 가장 유효한 숫자의 개수를 나타냅니다.</target>
        <note>{Locked="ParseExact"}{Locked="TryParseExact"}{Locked=""f""}</note>
      </trans-unit>
      <trans-unit id="_10ths_of_a_second_non_zero">
        <source>10ths of a second (non-zero)</source>
        <target state="translated">10분의 1초(0이 아님)</target>
        <note />
      </trans-unit>
      <trans-unit id="_10ths_of_a_second_non_zero_description">
        <source>The "F" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value. Nothing is displayed if the digit is zero.

If the "F" format specifier is used without other format specifiers, it's interpreted as the "F" standard date and time format specifier.

The number of "F" format specifiers used with the ParseExact, TryParseExact, ParseExact, or TryParseExact method indicates the maximum number of most significant digits of the seconds fraction that can be present to successfully parse the string.</source>
        <target state="translated">"F" 사용자 지정 형식 지정자는 초 부분의 가장 유효한 숫자를 나타냅니다. 즉, 날짜 및 시간 값에서 10분의 1초를 나타냅니다. 이 숫자가 0이면 아무것도 표시되지 않습니다.

다른 형식 지정자 없이 "F" 형식 지정자를 사용하면 "F" 표준 날짜 및 시간 형식 지정자로 해석됩니다.

ParseExact, TryParseExact, ParseExact 또는 TryParseExact 메서드에서 사용되는 "F" 형식 지정자의 개수는 초 부분에서 문자열을 성공적으로 구문 분석하기 위해 존재할 수 있는 가장 유효한 숫자의 최대 개수를 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_1_2_digits">
        <source>12 hour clock (1-2 digits)</source>
        <target state="translated">12시간제(1~2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_1_2_digits_description">
        <source>The "h" custom format specifier represents the hour as a number from 1 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour after midnight is indistinguishable from the same hour after noon. The hour is not rounded, and a single-digit hour is formatted without a leading zero. For example, given a time of 5:43 in the morning or afternoon, this custom format specifier displays "5".

If the "h" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">"h" 사용자 지정 형식 지정자는 시간을 1부터 12까지의 숫자로 나타냅니다. 즉, 시간은 자정 또는 정오부터 경과한 정수 시간을 계산하는 12시간제로 표현됩니다. 자정 이후의 특정 시간은 정오 이후의 동일한 시간과 구분되지 않습니다. 시간은 반올림되지 않으며, 한 자릿수 시간은 앞에 0이 없는 형식으로 지정됩니다. 예를 들어, 오전 또는 오후 5:43이라는 시간이 지정되면 이 사용자 지정 형식 지정자는 "5"를 표시합니다.

다른 사용자 지정 형식 지정자 없이 "h" 형식 지정자를 사용하면 표준 날짜 및 시간 형식 지정자로 해석되어 FormatException을 throw합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_2_digits">
        <source>12 hour clock (2 digits)</source>
        <target state="translated">12시간제(2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="_12_hour_clock_2_digits_description">
        <source>The "hh" custom format specifier (plus any number of additional "h" specifiers) represents the hour as a number from 01 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour after midnight is indistinguishable from the same hour after noon. The hour is not rounded, and a single-digit hour is formatted with a leading zero. For example, given a time of 5:43 in the morning or afternoon, this format specifier displays "05".</source>
        <target state="translated">"hh" 사용자 지정 형식 지정자(및 임의 개수의 추가 "h" 지정자)는 시간을 01부터 12까지의 숫자로 나타냅니다. 즉, 시간은 자정 또는 정오부터 경과한 정수 시간을 계산하는 12시간제로 표현됩니다. 자정 이후의 특정 시간은 정오 이후의 동일한 시간과 구분되지 않습니다. 시간은 반올림되지 않으며, 한 자릿수 시간은 앞에 0이 있는 형식으로 지정됩니다. 예를 들어, 오전 또는 오후 5:43이라는 시간이 지정되면 이 형식 지정자는 "05"를 표시합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_1_2_digits">
        <source>24 hour clock (1-2 digits)</source>
        <target state="translated">24시간제(1~2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_1_2_digits_description">
        <source>The "H" custom format specifier represents the hour as a number from 0 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is formatted without a leading zero.

If the "H" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">"H" 사용자 지정 형식 지정자는 시간을 0부터 23까지의 숫자로 나타냅니다. 즉, 시간은 자정부터 경과한 시간을 계산하는 0 기반 24시간제로 표현됩니다. 한 자릿수 시간은 앞에 0이 없는 형식으로 지정됩니다.

다른 사용자 지정 형식 지정자 없이 "H" 형식 지정자를 사용하면 표준 날짜 및 시간 형식 지정자로 해석되어 FormatException을 throw합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_2_digits">
        <source>24 hour clock (2 digits)</source>
        <target state="translated">24시간제(2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="_24_hour_clock_2_digits_description">
        <source>The "HH" custom format specifier (plus any number of additional "H" specifiers) represents the hour as a number from 00 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is formatted with a leading zero.</source>
        <target state="translated">"HH" 사용자 지정 형식 지정자(및 임의 개수의 추가 "H" 지정자)는 시간을 00부터 23까지의 숫자로 나타냅니다. 즉, 시간은 자정부터 경과한 시간을 계산하는 0 기반 24시간제로 표현됩니다. 한 자릿수 시간은 앞에 0이 있는 형식으로 지정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="all_anonymous_types_in_container">
        <source>all anonymous types in container</source>
        <target state="translated">컨테이너의 모든 익명 유형</target>
        <note />
      </trans-unit>
      <trans-unit id="and_update_call_sites_directly">
        <source>and update call sites directly</source>
        <target state="translated">통화 사이트를 직접 업데이트하고</target>
        <note />
      </trans-unit>
      <trans-unit id="class_name">
        <source>&lt;class name&gt;</source>
        <target state="translated">&lt;class name&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="class_with_explicit_or_sequential_layout">
        <source>class with explicit or sequential layout</source>
        <target state="translated">명시적 또는 순차적 레이아웃이 있는 클래스</target>
        <note />
      </trans-unit>
      <trans-unit id="code">
        <source>code</source>
        <target state="translated">코드</target>
        <note />
      </trans-unit>
      <trans-unit id="console_writeline">
        <source>Console.WriteLine</source>
        <target state="translated">Console.WriteLine</target>
        <note />
      </trans-unit>
      <trans-unit id="date_separator">
        <source>date separator</source>
        <target state="translated">날짜 구분 기호</target>
        <note />
      </trans-unit>
      <trans-unit id="date_separator_description">
        <source>The "/" custom format specifier represents the date separator, which is used to differentiate years, months, and days. The appropriate localized date separator is retrieved from the DateTimeFormatInfo.DateSeparator property of the current or specified culture.

Note: To change the date separator for a particular date and time string, specify the separator character within a literal string delimiter. For example, the custom format string mm'/'dd'/'yyyy produces a result string in which "/" is always used as the date separator. To change the date separator for all dates for a culture, either change the value of the DateTimeFormatInfo.DateSeparator property of the current culture, or instantiate a DateTimeFormatInfo object, assign the character to its DateSeparator property, and call an overload of the formatting method that includes an IFormatProvider parameter.

If the "/" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">"/" 사용자 지정 형식 지정자는 년, 월, 일을 구분하는 데 사용되는 날짜 구분 기호를 나타냅니다. 지역화된 적절한 날짜 구분 기호가 현재 문화권 또는 지정된 문화권의 DateTimeFormatInfo.DateSeparator 속성에서 검색됩니다.

참고: 특정 날짜 및 시간 문자열의 날짜 구분 기호를 변경하려면 리터럴 문자열 구분 기호 내에서 구분 기호 문자를 지정하세요. 예를 들어, 사용자 지정 형식 문자열 mm'/'dd'/'yyyy는 "/"가 항상 날짜 구분 기호로 사용되는 결과 문자열을 생성합니다. 문화권의 모든 날짜에 대해 날짜 구분 기호를 변경하려면 현재 문화권의 DateTimeFormatInfo.DateSeparator 속성 값을 변경하거나 DateTimeFormatInfo 개체를 인스턴스화한 후 해당 DateSeparator 속성에 문자를 할당하고 IFormatProvider 매개 변수를 포함하는 형식 지정 메서드의 오버로드를 호출하세요.

다른 사용자 지정 형식 지정자 없이 "/" 형식 지정자를 사용하면 표준 날짜 및 시간 형식 지정자로 해석되어 FormatException을 throw합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_1_2_digits">
        <source>day of the month (1-2 digits)</source>
        <target state="translated">일(1~2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_1_2_digits_description">
        <source>The "d" custom format specifier represents the day of the month as a number from 1 through 31. A single-digit day is formatted without a leading zero.

If the "d" format specifier is used without other custom format specifiers, it's interpreted as the "d" standard date and time format specifier.</source>
        <target state="translated">"d" 사용자 지정 형식 지정자는 일을 1부터 31까지의 숫자로 나타냅니다. 한 자릿수 일은 앞에 0이 없는 형식으로 지정됩니다.

다른 사용자 지정 형식 지정자 없이 "d" 형식 지정자를 사용하면 "d" 표준 날짜 및 시간 형식 지정자로 해석됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_2_digits">
        <source>day of the month (2 digits)</source>
        <target state="translated">일(2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_month_2_digits_description">
        <source>The "dd" custom format string represents the day of the month as a number from 01 through 31. A single-digit day is formatted with a leading zero.</source>
        <target state="translated">"dd" 사용자 지정 형식 문자열은 일을 01부터 31까지의 숫자로 나타냅니다. 한 자릿수 일은 앞에 0이 있는 형식으로 지정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_abbreviated">
        <source>day of the week (abbreviated)</source>
        <target state="translated">요일(약식)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_abbreviated_description">
        <source>The "ddd" custom format specifier represents the abbreviated name of the day of the week. The localized abbreviated name of the day of the week is retrieved from the DateTimeFormatInfo.AbbreviatedDayNames property of the current or specified culture.</source>
        <target state="translated">"ddd" 사용자 지정 형식 지정자는 요일의 약식 이름을 나타냅니다. 요일의 지역화된 약식 이름은 현재 문화권 지정된 문화권의 DateTimeFormatInfo.AbbreviatedDayNames 속성에서 검색됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_full">
        <source>day of the week (full)</source>
        <target state="translated">요일(전체)</target>
        <note />
      </trans-unit>
      <trans-unit id="day_of_the_week_full_description">
        <source>The "dddd" custom format specifier (plus any number of additional "d" specifiers) represents the full name of the day of the week. The localized name of the day of the week is retrieved from the DateTimeFormatInfo.DayNames property of the current or specified culture.</source>
        <target state="translated">"dddd" 사용자 지정 형식 지정자(및 임의 개수의 추가 "d" 지정자)는 요일의 전체 이름을 나타냅니다. 요일의 지역화된 이름은 현재 문화권 또는 지정된 문화권의 DateTimeFormatInfo.DayNames 속성에서 검색됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="default">
        <source>default&gt;</source>
        <target state="new">default&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="discard">
        <source>discard</source>
        <target state="translated">무시 항목</target>
        <note />
      </trans-unit>
      <trans-unit id="else_statement">
        <source>else statement</source>
        <target state="translated">else 문</target>
        <note />
      </trans-unit>
      <trans-unit id="embedded">
        <source>embedded</source>
        <target state="translated">포함됨</target>
        <note>Embedded is a technical term for "Embedded source", where souce files are embedded into the PDB</note>
      </trans-unit>
      <trans-unit id="extension_block">
        <source>extension block</source>
        <target state="new">extension block</target>
        <note />
      </trans-unit>
      <trans-unit id="external">
        <source>external</source>
        <target state="translated">외부</target>
        <note>External means "external source", meaning source files that are not part of the current solution</note>
      </trans-unit>
      <trans-unit id="foreach_loop">
        <source>foreach loop</source>
        <target state="translated">foreach 루프</target>
        <note />
      </trans-unit>
      <trans-unit id="from_metadata">
        <source>from metadata</source>
        <target state="translated">메타데이터에서</target>
        <note />
      </trans-unit>
      <trans-unit id="full_long_date_time">
        <source>full long date/time</source>
        <target state="translated">자세한 전체 날짜/시간</target>
        <note />
      </trans-unit>
      <trans-unit id="full_long_date_time_description">
        <source>The "F" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.FullDateTimePattern property. For example, the custom format string for the invariant culture is "dddd, dd MMMM yyyy HH:mm:ss".</source>
        <target state="translated">"F" 표준 형식 지정자는 현재 DateTimeFormatInfo.FullDateTimePattern 속성으로 정의되는 사용자 지정 날짜 및 시간 형식 문자열을 나타냅니다. 예를 들어, 고정 문화권의 사용자 지정 형식 문자열은 "dddd, dd MMMM yyyy HH:mm:ss"입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="full_short_date_time">
        <source>full short date/time</source>
        <target state="translated">간단한 전체 날짜/시간</target>
        <note />
      </trans-unit>
      <trans-unit id="full_short_date_time_description">
        <source>The Full Date Short Time ("f") Format Specifier

The "f" standard format specifier represents a combination of the long date ("D") and short time ("t") patterns, separated by a space.</source>
        <target state="translated">전체 날짜 간단한 시간("f") 형식 지정자

"f" 표준 형식 지정자는 공백으로 구분된 자세한 날짜("D") 패턴과 간단한 시간("t") 패턴의 조합을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="general_long_date_time">
        <source>general long date/time</source>
        <target state="translated">자세한 일반 날짜/시간</target>
        <note />
      </trans-unit>
      <trans-unit id="general_long_date_time_description">
        <source>The "G" standard format specifier represents a combination of the short date ("d") and long time ("T") patterns, separated by a space.</source>
        <target state="translated">"G" 표준 형식 지정자는 공백으로 구분된 간단한 날짜("d") 패턴과 자세한 시간("T") 패턴의 조합을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="general_short_date_time">
        <source>general short date/time</source>
        <target state="translated">간단한 일반 날짜/시간</target>
        <note />
      </trans-unit>
      <trans-unit id="general_short_date_time_description">
        <source>The "g" standard format specifier represents a combination of the short date ("d") and short time ("t") patterns, separated by a space.</source>
        <target state="translated">"g" 표준 형식 지정자는 공백으로 구분된 간단한 날짜("d") 패턴과 간단한 시간("t") 패턴의 조합을 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="generic_overload">
        <source>generic overload</source>
        <target state="translated">제네릭 오버로드</target>
        <note />
      </trans-unit>
      <trans-unit id="generic_overloads">
        <source>generic overloads</source>
        <target state="translated">제네릭 오버로드</target>
        <note />
      </trans-unit>
      <trans-unit id="get_only_property">
        <source>get-only property</source>
        <target state="translated">get 전용 속성</target>
        <note />
      </trans-unit>
      <trans-unit id="if_statement">
        <source>if statement</source>
        <target state="translated">If 문</target>
        <note />
      </trans-unit>
      <trans-unit id="in_0_1_2">
        <source>in {0} ({1} - {2})</source>
        <target state="translated">{0}({1} - {2})에서</target>
        <note />
      </trans-unit>
      <trans-unit id="in_Source_attribute">
        <source>in Source (attribute)</source>
        <target state="translated">소스(특성)</target>
        <note />
      </trans-unit>
      <trans-unit id="interface_name">
        <source>&lt;interface name&gt;</source>
        <target state="translated">&lt;interface name&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="into_extracted_method_to_invoke_at_call_sites">
        <source>into extracted method to invoke at call sites</source>
        <target state="translated">호출 사이트에서 호출하기 위해 추출된 메서드로</target>
        <note />
      </trans-unit>
      <trans-unit id="into_new_overload">
        <source>into new overload</source>
        <target state="translated">새 오버로드로</target>
        <note />
      </trans-unit>
      <trans-unit id="just_this_anonymous_type">
        <source>just this anonymous type</source>
        <target state="translated">이 익명 형식만</target>
        <note />
      </trans-unit>
      <trans-unit id="long_date">
        <source>long date</source>
        <target state="translated">자세한 날짜</target>
        <note />
      </trans-unit>
      <trans-unit id="long_date_description">
        <source>The "D" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.LongDatePattern property. For example, the custom format string for the invariant culture is "dddd, dd MMMM yyyy".</source>
        <target state="translated">"D" 표준 형식 지정자는 현재 DateTimeFormatInfo.LongDatePattern 속성으로 정의되는 사용자 지정 날짜 및 시간 형식 문자열을 나타냅니다. 예를 들어, 고정 문화권의 사용자 지정 형식 문자열은 "dddd, dd MMMM yyyy"입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="long_time">
        <source>long time</source>
        <target state="translated">자세한 시간</target>
        <note />
      </trans-unit>
      <trans-unit id="long_time_description">
        <source>The "T" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.LongTimePattern property. For example, the custom format string for the invariant culture is "HH:mm:ss".</source>
        <target state="translated">"T" 표준 형식 지정자는 특정 문화권의 DateTimeFormatInfo.LongTimePattern 속성으로 정의되는 사용자 지정 날짜 및 시간 형식 문자열을 나타냅니다. 예를 들어, 고정 문화권의 사용자 지정 형식 문자열은 "HH:mm:ss"입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="member_kind_and_name">
        <source>{0} '{1}'</source>
        <target state="translated">{0} '{1}'</target>
        <note>e.g. "method 'M'"</note>
      </trans-unit>
      <trans-unit id="minute_1_2_digits">
        <source>minute (1-2 digits)</source>
        <target state="translated">분(1~2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_1_2_digits_description">
        <source>The "m" custom format specifier represents the minute as a number from 0 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted without a leading zero.

If the "m" format specifier is used without other custom format specifiers, it's interpreted as the "m" standard date and time format specifier.</source>
        <target state="translated">"m" 사용자 지정 형식 지정자는 분을 0부터 59까지의 숫자로 나타냅니다. 분은 마지막 정각으로부터 경과한 정수 분을 나타냅니다. 한 자릿수 분은 앞에 0이 없는 형식으로 지정됩니다.

다른 사용자 지정 형식 지정자 없이 "m" 형식 지정자를 사용하면 "m" 표준 날짜 및 시간 형식 지정자로 해석됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_2_digits">
        <source>minute (2 digits)</source>
        <target state="translated">분(2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="minute_2_digits_description">
        <source>The "mm" custom format specifier (plus any number of additional "m" specifiers) represents the minute as a number from 00 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted with a leading zero.</source>
        <target state="translated">"mm" 사용자 지정 형식 지정자(및 임의 개수의 추가 "m" 지정자)는 분을 00부터 59까지의 숫자로 나타냅니다. 분은 마지막 정각으로부터 경과한 정수 분을 나타냅니다. 한 자릿수 분은 앞에 0이 있는 형식으로 지정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_1_2_digits">
        <source>month (1-2 digits)</source>
        <target state="translated">월(1~2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_1_2_digits_description">
        <source>The "M" custom format specifier represents the month as a number from 1 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted without a leading zero.

If the "M" format specifier is used without other custom format specifiers, it's interpreted as the "M" standard date and time format specifier.</source>
        <target state="translated">"M" 사용자 지정 형식 지정자는 월을 1부터 12까지의 숫자(13개월이 있는 달력에서는 1부터 13까지의 숫자)로 나타냅니다. 한 자릿수 월은 앞에 0이 없는 형식으로 지정됩니다.

다른 사용자 지정 형식 지정자 없이 "M" 형식 지정자를 사용하면 "M" 표준 날짜 및 시간 형식 지정자로 해석됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_2_digits">
        <source>month (2 digits)</source>
        <target state="translated">월(2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_2_digits_description">
        <source>The "MM" custom format specifier represents the month as a number from 01 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted with a leading zero.</source>
        <target state="translated">"MM" 사용자 지정 형식 지정자는 월을 01부터 12까지의 숫자(13개월이 있는 달력에서는 1부터 13까지의 숫자)로 나타냅니다. 한 자릿수 월은 앞에 0이 있는 형식으로 지정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_abbreviated">
        <source>month (abbreviated)</source>
        <target state="translated">월(약식)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_abbreviated_description">
        <source>The "MMM" custom format specifier represents the abbreviated name of the month. The localized abbreviated name of the month is retrieved from the DateTimeFormatInfo.AbbreviatedMonthNames property of the current or specified culture.</source>
        <target state="translated">"MMM" 사용자 지정 형식 지정자는 월의 약식 이름을 나타냅니다. 월의 지역화된 약식 이름은 현재 문화권 또는 지정된 문화권의 DateTimeFormatInfo.AbbreviatedMonthNames 속성에서 검색됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_day">
        <source>month day</source>
        <target state="translated">월 일</target>
        <note />
      </trans-unit>
      <trans-unit id="month_day_description">
        <source>The "M" or "m" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.MonthDayPattern property. For example, the custom format string for the invariant culture is "MMMM dd".</source>
        <target state="translated">"M" 또는 "m" 표준 형식 지정자는 현재 DateTimeFormatInfo.MonthDayPattern 속성으로 정의되는 사용자 지정 날짜 및 시간 형식 문자열을 나타냅니다. 예를 들어, 고정 문화권의 사용자 지정 형식 문자열은 "MMMM dd"입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="month_full">
        <source>month (full)</source>
        <target state="translated">월(전체)</target>
        <note />
      </trans-unit>
      <trans-unit id="month_full_description">
        <source>The "MMMM" custom format specifier represents the full name of the month. The localized name of the month is retrieved from the DateTimeFormatInfo.MonthNames property of the current or specified culture.</source>
        <target state="translated">"MMMM" 사용자 지정 형식 지정자는 월의 전체 이름을 나타냅니다. 월의 지역화된 이름은 현재 문화권 또는 지정된 문화권의 DateTimeFormatInfo.MonthNames 속성에서 검색됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="namespace_name">
        <source>&lt;namespace name&gt;</source>
        <target state="translated">&lt;namespace name&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="overload">
        <source>overload</source>
        <target state="translated">오버로드</target>
        <note />
      </trans-unit>
      <trans-unit id="overloads_">
        <source>overloads</source>
        <target state="translated">오버로드</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_Keyword">
        <source>{0} Keyword</source>
        <target state="translated">{0} 키워드</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_field_colon_0_and_use_property">
        <source>Encapsulate field: '{0}' (and use property)</source>
        <target state="translated">필드 캡슐화: '{0}'(그리고 속성을 사용함)</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_field_colon_0_but_still_use_field">
        <source>Encapsulate field: '{0}' (but still use field)</source>
        <target state="translated">필드 캡슐화: '{0}'(그러나 여전히 필드를 사용함)</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_fields_and_use_property">
        <source>Encapsulate fields (and use property)</source>
        <target state="translated">필드 캡슐화(그리고 속성을 사용함)</target>
        <note />
      </trans-unit>
      <trans-unit id="Encapsulate_fields_but_still_use_field">
        <source>Encapsulate fields (but still use field)</source>
        <target state="translated">필드 캡슐화(그러나 여전히 필드를 사용함)</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_extract_interface_colon_The_selection_is_not_inside_a_class_interface_struct">
        <source>Could not extract interface: The selection is not inside a class/interface/struct.</source>
        <target state="translated">인터페이스를 추출할 수 없습니다. 선택 영역이 class/interface/struct 내부에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_extract_interface_colon_The_type_does_not_contain_any_member_that_can_be_extracted_to_an_interface">
        <source>Could not extract interface: The type does not contain any member that can be extracted to an interface.</source>
        <target state="translated">인터페이스를 추출할 수 없습니다. 형식에 인터페이스로 추출할 수 있는 멤버가 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Parameters_type_or_return_type_cannot_be_an_anonymous_type_colon_bracket_0_bracket">
        <source>Parameters' type or return type cannot be an anonymous type : [{0}]</source>
        <target state="translated">매개 변수 형식 또는 반환 형식은 익명 형식 [{0}]일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_selection_contains_no_active_statement">
        <source>The selection contains no active statement.</source>
        <target state="translated">선택 영역에 활성 문이 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_selection_contains_an_error_or_unknown_type">
        <source>The selection contains an error or unknown type.</source>
        <target state="translated">이 섹션에는 오류 또는 알 수 없는 형식이 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Type_parameter_0_is_hidden_by_another_type_parameter_1">
        <source>Type parameter '{0}' is hidden by another type parameter '{1}'.</source>
        <target state="translated">'{0}' 형식 매개 변수가 다른 '{1}' 형식 매개 변수에 의해 숨겨집니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_address_of_a_variable_is_used_inside_the_selected_code">
        <source>The address of a variable is used inside the selected code.</source>
        <target state="translated">변수 주소는 선택한 코드 내부에서 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Assigning_to_readonly_fields_must_be_done_in_a_constructor_colon_bracket_0_bracket">
        <source>Assigning to readonly fields must be done in a constructor : [{0}].</source>
        <target state="translated">생성자 [{0}]에서 읽기 전용 필드에 대한 할당 작업을 수행해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="generated_code_is_overlapping_with_hidden_portion_of_the_code">
        <source>generated code is overlapping with hidden portion of the code</source>
        <target state="translated">생성된 코드가 숨겨진 코드 부분과 겹쳐져 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_optional_parameters_to_0">
        <source>Add optional parameters to '{0}'</source>
        <target state="translated">'{0}'에 선택적 매개 변수 추가</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_parameters_to_0">
        <source>Add parameters to '{0}'</source>
        <target state="translated">'{0}'에 매개 변수 추가</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_delegating_constructor_0_1">
        <source>Generate delegating constructor '{0}({1})'</source>
        <target state="translated">위임하는 생성자 '{0}({1})' 생성</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_Equals_and_GetHashCode">
        <source>Generate Equals and GetHashCode</source>
        <target state="translated">Equals 및 GetHashCode 생성</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_GetHashCode">
        <source>Generate GetHashCode()</source>
        <target state="translated">GetHashCode() 생성</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_0_1_in_new_file">
        <source>Generate {0} '{1}' in new file</source>
        <target state="translated">새 파일에서 {0} '{1}' 생성</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_nested_0_1">
        <source>Generate nested {0} '{1}'</source>
        <target state="translated">중첩된 {0} '{1}' 생성</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_field_for_0">
        <source>Introduce field for '{0}'</source>
        <target state="translated">'{0}'에 대한 필드 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_for_0">
        <source>Introduce local for '{0}'</source>
        <target state="translated">'{0}'에 대한 로컬 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_constant_for_0">
        <source>Introduce constant for '{0}'</source>
        <target state="translated">'{0}'에 대한 상수 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_constant_for_0">
        <source>Introduce local constant for '{0}'</source>
        <target state="translated">'{0}'에 대한 지역 상수 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_field_for_all_occurrences_of_0">
        <source>Introduce field for all occurrences of '{0}'</source>
        <target state="translated">'{0}'의 모든 항목에 대한 필드 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_for_all_occurrences_of_0">
        <source>Introduce local for all occurrences of '{0}'</source>
        <target state="translated">'{0}'의 모든 항목에 대한 로컬 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_constant_for_all_occurrences_of_0">
        <source>Introduce constant for all occurrences of '{0}'</source>
        <target state="translated">'{0}'의 모든 항목에 대한 상수 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_local_constant_for_all_occurrences_of_0">
        <source>Introduce local constant for all occurrences of '{0}'</source>
        <target state="translated">'{0}'의 모든 항목에 대한 지역 상수 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_query_variable_for_all_occurrences_of_0">
        <source>Introduce query variable for all occurrences of '{0}'</source>
        <target state="translated">'{0}'의 모든 항목에 대한 쿼리 변수 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="Introduce_query_variable_for_0">
        <source>Introduce query variable for '{0}'</source>
        <target state="translated">'{0}'에 대한 쿼리 변수 지정</target>
        <note />
      </trans-unit>
      <trans-unit id="is_">
        <source>is</source>
        <target state="translated">은(는)</target>
        <note />
      </trans-unit>
      <trans-unit id="Represents_an_object_whose_operations_will_be_resolved_at_runtime">
        <source>Represents an object whose operations will be resolved at runtime.</source>
        <target state="translated">런타임에 확인될 작업이 포함된 개체를 나타냅니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="constant">
        <source>constant</source>
        <target state="translated">상수</target>
        <note />
      </trans-unit>
      <trans-unit id="field">
        <source>field</source>
        <target state="translated">필드</target>
        <note />
      </trans-unit>
      <trans-unit id="local_constant">
        <source>local constant</source>
        <target state="translated">지역 상수</target>
        <note />
      </trans-unit>
      <trans-unit id="local_variable">
        <source>local variable</source>
        <target state="translated">지역 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="label">
        <source>label</source>
        <target state="translated">레이블</target>
        <note />
      </trans-unit>
      <trans-unit id="period_era">
        <source>period/era</source>
        <target state="translated">기간/시대</target>
        <note />
      </trans-unit>
      <trans-unit id="period_era_description">
        <source>The "g" or "gg" custom format specifiers (plus any number of additional "g" specifiers) represents the period or era, such as A.D. The formatting operation ignores this specifier if the date to be formatted doesn't have an associated period or era string.

If the "g" format specifier is used without other custom format specifiers, it's interpreted as the "g" standard date and time format specifier.</source>
        <target state="translated">"g" 또는 "gg" 사용자 지정 형식 지정자(및 임의 개수의 추가 "g" 지정자)는 기간 또는 시대(예: A.D.)를 나타냅니다. 형식 지정 연산은 형식을 지정할 날짜에 연결된 기간 또는 시대 문자열이 없으면 이 지정자를 무시합니다.

다른 사용자 지정 형식 지정자 없이 "g" 형식 지정자를 사용하면 "g" 표준 날짜 및 시간 형식 지정자로 해석됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="property_accessor">
        <source>property accessor</source>
        <target state="translated">속성 접근자</target>
        <note />
      </trans-unit>
      <trans-unit id="range_variable">
        <source>range variable</source>
        <target state="translated">범위 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="parameter">
        <source>parameter</source>
        <target state="translated">매개 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="in_">
        <source>in</source>
        <target state="translated">In</target>
        <note />
      </trans-unit>
      <trans-unit id="Summary_colon">
        <source>Summary:</source>
        <target state="translated">요약:</target>
        <note />
      </trans-unit>
      <trans-unit id="Locals_and_parameters">
        <source>Locals and parameters</source>
        <target state="translated">로컬 항목 및 매개 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="Type_parameters_colon">
        <source>Type parameters:</source>
        <target state="translated">형식 매개 변수:</target>
        <note />
      </trans-unit>
      <trans-unit id="Returns_colon">
        <source>Returns:</source>
        <target state="translated">반환 값:</target>
        <note />
      </trans-unit>
      <trans-unit id="Remarks_colon">
        <source>Remarks:</source>
        <target state="translated">설명:</target>
        <note />
      </trans-unit>
      <trans-unit id="generating_source_for_symbols_of_this_type_is_not_supported">
        <source>generating source for symbols of this type is not supported</source>
        <target state="translated">이 형식의 기호에 대한 소스는 생성할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Assembly">
        <source>Assembly</source>
        <target state="translated">어셈블리</target>
        <note />
      </trans-unit>
      <trans-unit id="location_unknown">
        <source>location unknown</source>
        <target state="translated">위치를 알 수 없음</target>
        <note />
      </trans-unit>
      <trans-unit id="Unexpected_interface_member_kind_colon_0">
        <source>Unexpected interface member kind: {0}</source>
        <target state="translated">예기치 않은 인터페이스 멤버 종류: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="The_symbol_does_not_have_an_icon">
        <source>The symbol does not have an icon.</source>
        <target state="translated">기호에 아이콘이 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Asynchronous_method_cannot_have_ref_out_parameters_colon_bracket_0_bracket">
        <source>Asynchronous method cannot have ref/out parameters : [{0}]</source>
        <target state="translated">비동기 메서드에는 ref/out 매개 변수 [{0}]을(를) 포함할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_member_is_defined_in_metadata">
        <source>The member is defined in metadata.</source>
        <target state="translated">멤버가 메타데이터에 정의되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="You_can_only_change_the_signature_of_a_constructor_indexer_method_or_delegate">
        <source>You can only change the signature of a constructor, indexer, method or delegate.</source>
        <target state="translated">생성자, 인덱서, 메서드 또는 대리자의 서명만 변경할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="This_symbol_has_related_definitions_or_references_in_metadata_Changing_its_signature_may_result_in_build_errors_Do_you_want_to_continue">
        <source>This symbol has related definitions or references in metadata. Changing its signature may result in build errors.

Do you want to continue?</source>
        <target state="translated">이 기호에는 메타데이터에 관련된 정의 또는 참조가 있습니다. 시그니처를 변경하면 빌드 오류가 발생할 수 있습니다.

계속하시겠습니까?</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_signature">
        <source>Change signature...</source>
        <target state="needs-review-translation">시그니처 변경...</target>
        <note>Here 'signature' refers to a programming signature (e.g., a method signature), not a legal signature</note>
      </trans-unit>
      <trans-unit id="Generate_new_type">
        <source>Generate new type...</source>
        <target state="translated">새 형식 생성...</target>
        <note />
      </trans-unit>
      <trans-unit id="User_Diagnostic_Analyzer_Failure">
        <source>User Diagnostic Analyzer Failure.</source>
        <target state="translated">사용자 진단 분석기 오류입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Analyzer_0_threw_an_exception_of_type_1_with_message_2">
        <source>Analyzer '{0}' threw an exception of type '{1}' with message '{2}'.</source>
        <target state="translated">분석기 '{0}'에서 '{2}' 메시지와 함께 '{1}' 형식의 예외를 throw했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Analyzer_0_threw_the_following_exception_colon_1">
        <source>Analyzer '{0}' threw the following exception:
'{1}'.</source>
        <target state="translated">'{0}' 분석기에서 다음 예외를 throw했습니다.
'{1}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_qualification">
        <source>Remove qualification</source>
        <target state="translated">한정자 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_error_occurred">
        <source>Unknown error occurred</source>
        <target state="translated">알 수 없는 오류 발생</target>
        <note />
      </trans-unit>
      <trans-unit id="Available">
        <source>Available</source>
        <target state="translated">사용할 수 있는</target>
        <note />
      </trans-unit>
      <trans-unit id="Not_Available">
        <source>Not Available ⚠</source>
        <target state="translated">사용할 수 없음 ⚠</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_1">
        <source>{0} - {1}</source>
        <target state="needs-review-translation">    {0} - {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="in_Source">
        <source>in Source</source>
        <target state="translated">소스</target>
        <note />
      </trans-unit>
      <trans-unit id="in_Suppression_File">
        <source>in Suppression File</source>
        <target state="translated">비표시 오류(Suppression) 파일</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_Suppression_0">
        <source>Remove Suppression {0}</source>
        <target state="translated">비표시 오류(Suppression) {0} 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_Suppression">
        <source>Remove Suppression</source>
        <target state="translated">비표시 오류(Suppression) 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="Pending">
        <source>&lt;Pending&gt;</source>
        <target state="translated">&lt;보류 중&gt;</target>
        <note />
      </trans-unit>
      <trans-unit id="Note_colon_Tab_twice_to_insert_the_0_snippet">
        <source>Note: Tab twice to insert the '{0}' snippet.</source>
        <target state="translated">참고: '{0}' 코드 조각을 삽입하려면 두 번 탭하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="Computing_fix_all_occurrences_code_fix">
        <source>Computing fix all occurrences code fix...</source>
        <target state="translated">모든 항목 코드 수정 사항을 계산하는 중...</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_occurrences">
        <source>Fix all occurrences</source>
        <target state="translated">모든 발생 수정</target>
        <note />
      </trans-unit>
      <trans-unit id="Document">
        <source>Document</source>
        <target state="translated">문서</target>
        <note />
      </trans-unit>
      <trans-unit id="Project">
        <source>Project</source>
        <target state="translated">프로젝트</target>
        <note />
      </trans-unit>
      <trans-unit id="Solution">
        <source>Solution</source>
        <target state="translated">솔루션</target>
        <note />
      </trans-unit>
      <trans-unit id="Compiler2">
        <source>Compiler</source>
        <target state="translated">컴파일러</target>
        <note />
      </trans-unit>
      <trans-unit id="Live">
        <source>Live</source>
        <target state="translated">라이브</target>
        <note />
      </trans-unit>
      <trans-unit id="enum_value">
        <source>enum value</source>
        <target state="translated">enum 값</target>
        <note>{Locked="enum"} "enum" is a C#/VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="const_field">
        <source>const field</source>
        <target state="translated">const 필드</target>
        <note>{Locked="const"} "const" is a C#/VB keyword and should not be localized.</note>
      </trans-unit>
      <trans-unit id="method">
        <source>method</source>
        <target state="translated">메서드</target>
        <note />
      </trans-unit>
      <trans-unit id="operator_">
        <source>operator</source>
        <target state="translated">운영자</target>
        <note />
      </trans-unit>
      <trans-unit id="constructor">
        <source>constructor</source>
        <target state="translated">생성자</target>
        <note />
      </trans-unit>
      <trans-unit id="auto_property">
        <source>auto-property</source>
        <target state="translated">Auto 속성</target>
        <note />
      </trans-unit>
      <trans-unit id="property_">
        <source>property</source>
        <target state="translated">속성</target>
        <note />
      </trans-unit>
      <trans-unit id="event_accessor">
        <source>event accessor</source>
        <target state="translated">이벤트 접근자</target>
        <note />
      </trans-unit>
      <trans-unit id="rfc1123_date_time">
        <source>rfc1123 date/time</source>
        <target state="translated">rfc1123 날짜/시간</target>
        <note />
      </trans-unit>
      <trans-unit id="rfc1123_date_time_description">
        <source>The "R" or "r" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.RFC1123Pattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'". When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.</source>
        <target state="translated">"R" 또는 "r" 표준 형식 지정자는 DateTimeFormatInfo.RFC1123Pattern 속성으로 정의되는 사용자 지정 날짜 및 시간 형식 문자열을 나타냅니다. 패턴은 정의된 표준을 반영하며, 속성은 읽기 전용입니다. 따라서 사용된 문화권이나 지정된 형식 공급자와 관계없이 항상 동일합니다. 사용자 지정 형식 문자열은 "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'"입니다. 이 표준 형식 지정자를 사용하면 형식 지정 또는 구문 분석 연산에서 항상 고정 문화권이 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="round_trip_date_time">
        <source>round-trip date/time</source>
        <target state="translated">왕복 날짜/시간</target>
        <note />
      </trans-unit>
      <trans-unit id="round_trip_date_time_description">
        <source>The "O" or "o" standard format specifier represents a custom date and time format string using a pattern that preserves time zone information and emits a result string that complies with ISO 8601. For DateTime values, this format specifier is designed to preserve date and time values along with the DateTime.Kind property in text. The formatted string can be parsed back by using the DateTime.Parse(String, IFormatProvider, DateTimeStyles) or DateTime.ParseExact method if the styles parameter is set to DateTimeStyles.RoundtripKind.

The "O" or "o" standard format specifier corresponds to the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" custom format string for DateTime values and to the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffzzz" custom format string for DateTimeOffset values. In this string, the pairs of single quotation marks that delimit individual characters, such as the hyphens, the colons, and the letter "T", indicate that the individual character is a literal that cannot be changed. The apostrophes do not appear in the output string.

The "O" or "o" standard format specifier (and the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" custom format string) takes advantage of the three ways that ISO 8601 represents time zone information to preserve the Kind property of DateTime values:

    The time zone component of DateTimeKind.Local date and time values is an offset from UTC (for example, +01:00, -07:00). All DateTimeOffset values are also represented in this format.

    The time zone component of DateTimeKind.Utc date and time values uses "Z" (which stands for zero offset) to represent UTC.

    DateTimeKind.Unspecified date and time values have no time zone information.

Because the "O" or "o" standard format specifier conforms to an international standard, the formatting or parsing operation that uses the specifier always uses the invariant culture and the Gregorian calendar.

Strings that are passed to the Parse, TryParse, ParseExact, and TryParseExact methods of DateTime and DateTimeOffset can be parsed by using the "O" or "o" format specifier if they are in one of these formats. In the case of DateTime objects, the parsing overload that you call should also include a styles parameter with a value of DateTimeStyles.RoundtripKind. Note that if you call a parsing method with the custom format string that corresponds to the "O" or "o" format specifier, you won't get the same results as "O" or "o". This is because parsing methods that use a custom format string can't parse the string representation of date and time values that lack a time zone component or use "Z" to indicate UTC.</source>
        <target state="translated">"O" 또는 "o" 표준 형식 지정자는 표준 시간대 정보를 보존하고 ISO 8601을 준수하는 결과 문자열을 출력하는 패턴을 사용하여 사용자 지정 날짜 및 시간 형식 문자열을 나타냅니다. DateTime 값의 경우, 이 형식 지정자는 텍스트의 DateTime.Kind 속성과 함께 날짜 및 시간 값을 보존하도록 설계되어 있습니다. 형식이 지정된 문자열은 styles 매개 변수가 DateTimeStyles.RoundtripKind로 설정된 경우 DateTime.Parse(String, IFormatProvider, DateTimeStyles) 또는 DateTime.ParseExact 메서드를 사용하여 다시 구문 분석할 수 있습니다.

"O" 또는 "o" 표준 형식 지정자는 DateTime 값의 "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" 사용자 지정 형식 문자열 및 DateTimeOffset 값의 "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffzzz" 사용자 지정 형식 문자열에 대응됩니다. 이 문자열에서 하이픈, 콜론 및 문자 "T"와 같은 개별 문자를 구분하는 작은따옴표 쌍은 해당 개별 문자가 변경될 수 없는 리터럴임을 나타냅니다. 출력 문자열에는 아포스트로피가 표시되지 않습니다.

"O" 또는 "o" 표준 형식 지정자(및 "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" 사용자 지정 형식 문자열)는 ISO 8601이 표준 시간대 정보를 나타내는 세 가지 방법을 사용하여 DateTime 값의 Kind 속성을 보존합니다.

    DateTimeKind.Local 날짜 및 시간 값의 표준 시간대 부분은 UTC에서 가져온 오프셋(예: +01:00, -07:00)입니다. 모든 DateTimeOffset 값도 이 형식으로 표현됩니다.

    DateTimeKind.Utc 날짜 및 시간 값의 표준 시간대 부분은 "Z"(제로 오프셋을 나타냄)를 사용하여 UTC를 표현합니다.

    DateTimeKind.Unspecified 날짜 및 시간 값에는 표준 시간대 정보가 없습니다.

"O" 또는 "o" 표준 형식 지정자는 국제 표준을 준수하므로 이 지정자를 사용하는 형식 지정 또는 구문 분석 연산은 항상 고정 문화권과 양력을 사용합니다.

DateTime 및 DateTimeOffset의 Parse, TryParse, ParseExact 및 TryParseExact 메서드로 전달되는 문자열은 "O" 또는 "o"형식 중 하나인 경우 "O" 또는 "o" 형식 지정자를 사용하여 구문 분석될 수 있습니다. DateTime 개체의 경우, 호출하는 구문 분석 오버로드는 값이 DateTimeStyles.RoundtripKind인 styles 매개 변수도 포함해야 합니다. "O" 또는 "o" 형식 지정자에 대응되는 사용자 지정 형식 문자열을 사용하여 구문 분석 메서드를 호출해도 "O" 또는 "o"와 동일한 결과를 얻을 수 없습니다. 사용자 지정 형식 문자열을 사용하는 구문 분석 메서드는 표준 시간대 부분이 없거나 "Z"를 사용하여 UTC를 나타내는 날짜 및 시간 값의 문자열 표현을 구문 분석할 수 없기 때문입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="second_1_2_digits">
        <source>second (1-2 digits)</source>
        <target state="translated">초(1~2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="second_1_2_digits_description">
        <source>The "s" custom format specifier represents the seconds as a number from 0 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted without a leading zero.

If the "s" format specifier is used without other custom format specifiers, it's interpreted as the "s" standard date and time format specifier.</source>
        <target state="translated">"s" 사용자 지정 형식 지정자는 초를 0부터 59까지의 숫자로 나타냅니다. 결과는 마지막 분으로부터 경과한 정수 초를 나타냅니다. 한 자릿수 초는 앞에 0이 없는 형식으로 지정됩니다.

다른 사용자 지정 형식 지정자 없이 "s" 형식 지정자를 사용하면 "s" 표준 날짜 및 시간 형식 지정자로 해석됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="second_2_digits">
        <source>second (2 digits)</source>
        <target state="translated">초(2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="second_2_digits_description">
        <source>The "ss" custom format specifier (plus any number of additional "s" specifiers) represents the seconds as a number from 00 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted with a leading zero.</source>
        <target state="translated">"ss" 사용자 지정 형식 지정자(및 임의 개수의 추가 "s" 지정자)는 초를 00부터 59까지의 숫자로 나타냅니다. 결과는 마지막 분으로부터 경과한 정수 초를 나타냅니다. 한 자릿수 초는 앞에 0이 있는 형식으로 지정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="short_date">
        <source>short date</source>
        <target state="translated">간단한 날짜</target>
        <note />
      </trans-unit>
      <trans-unit id="short_date_description">
        <source>The "d" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.ShortDatePattern property. For example, the custom format string that is returned by the ShortDatePattern property of the invariant culture is "MM/dd/yyyy".</source>
        <target state="translated">"d" 표준 형식 지정자는 특정 문화권의 DateTimeFormatInfo.ShortDatePattern 속성으로 정의되는 사용자 지정 날짜 및 시간 형식 문자열을 나타냅니다. 예를 들어, 고정 문화권의 ShortDatePattern 속성이 반환하는 사용자 지정 형식 문자열은 "MM/dd/yyyy"입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="short_time">
        <source>short time</source>
        <target state="translated">간단한 시간</target>
        <note />
      </trans-unit>
      <trans-unit id="short_time_description">
        <source>The "t" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.ShortTimePattern property. For example, the custom format string for the invariant culture is "HH:mm".</source>
        <target state="translated">"t" 표준 형식 지정자는 현재 DateTimeFormatInfo.ShortTimePattern 속성으로 정의되는 사용자 지정 날짜 및 시간 형식 문자열을 나타냅니다. 예를 들어, 고정 문화권의 사용자 지정 형식 문자열은 "HH:mm"입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="sortable_date_time">
        <source>sortable date/time</source>
        <target state="translated">정렬 가능한 날짜/시간</target>
        <note />
      </trans-unit>
      <trans-unit id="sortable_date_time_description">
        <source>The "s" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.SortableDateTimePattern property. The pattern reflects a defined standard (ISO 8601), and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "yyyy'-'MM'-'dd'T'HH':'mm':'ss".

The purpose of the "s" format specifier is to produce result strings that sort consistently in ascending or descending order based on date and time values. As a result, although the "s" standard format specifier represents a date and time value in a consistent format, the formatting operation does not modify the value of the date and time object that is being formatted to reflect its DateTime.Kind property or its DateTimeOffset.Offset value. For example, the result strings produced by formatting the date and time values 2014-11-15T18:32:17+00:00 and 2014-11-15T18:32:17+08:00 are identical.

When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.</source>
        <target state="translated">"s" 표준 형식 지정자는 DateTimeFormatInfo.SortableDateTimePattern 속성으로 정의되는 사용자 지정 날짜 및 시간 형식 문자열을 나타냅니다. 패턴은 정의된 표준(ISO 8601)을 반영하며, 속성은 읽기 전용입니다. 따라서 사용된 문화권이나 지정된 형식 공급자와 관계없이 항상 동일합니다. 사용자 지정 형식 문자열은 "yyyy'-'MM'-'dd'T'HH':'mm':'ss"입니다.

"s" 형식 지정자의 목표는 날짜 및 시간 값을 기준으로 일관성 있게 오름차순 또는 내림차순으로 정렬되는 결과 문자열을 생성하는 것입니다. 그 결과 "s" 표준 형식 지정자는 일관성 있는 형식으로 날짜 및 시간 값을 나타내긴 하지만 형식 지정 연산은 형식 지정 대상인 날짜 및 시간 개체가 그 DateTime.Kind 속성 또는 DateTimeOffset.Offset 값을 반영하도록 수정하지 않습니다. 예를 들어, 날짜 및 시간 값 2014-11-15T18:32:17+00:00과 2014-11-15T18:32:17+08:00의 형식을 지정하여 생성되는 결과 문자열은 동일합니다.

이 표준 형식 지정자를 사용하면 형식 지정 또는 구문 분석 연산에서 항상 고정 문화권이 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="static_constructor">
        <source>static constructor</source>
        <target state="translated">정적 생성자</target>
        <note />
      </trans-unit>
      <trans-unit id="struct_">
        <source>struct</source>
        <target state="translated">구조체</target>
        <note />
      </trans-unit>
      <trans-unit id="symbol_cannot_be_a_namespace">
        <source>'symbol' cannot be a namespace.</source>
        <target state="translated">'기호'는 네임스페이스일 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="symbol_kind_and_name_of_member_kind_and_name">
        <source>{0} '{1}' of {2} '{3}'</source>
        <target state="translated">{2} '{3}' 중 {0} '{1}'</target>
        <note>e.g. "parameter 'T param' of method 'M'"</note>
      </trans-unit>
      <trans-unit id="time_separator">
        <source>time separator</source>
        <target state="translated">시간 구분 기호</target>
        <note />
      </trans-unit>
      <trans-unit id="time_separator_description">
        <source>The ":" custom format specifier represents the time separator, which is used to differentiate hours, minutes, and seconds. The appropriate localized time separator is retrieved from the DateTimeFormatInfo.TimeSeparator property of the current or specified culture.

Note: To change the time separator for a particular date and time string, specify the separator character within a literal string delimiter. For example, the custom format string hh'_'dd'_'ss produces a result string in which "_" (an underscore) is always used as the time separator. To change the time separator for all dates for a culture, either change the value of the DateTimeFormatInfo.TimeSeparator property of the current culture, or instantiate a DateTimeFormatInfo object, assign the character to its TimeSeparator property, and call an overload of the formatting method that includes an IFormatProvider parameter.

If the ":" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">":" 사용자 지정 형식 지정자는 시간, 분, 초를 구분하는 데 사용되는 시간 구분 기호를 나타냅니다. 지역화된 적절한 시간 구분 기호가 현재 문화권 또는 지정된 문화권의 DateTimeFormatInfo.TimeSeparator 속성에서 검색됩니다.

참고: 특정 날짜 및 시간 문자열의 시간 구분 기호를 변경하려면 리터럴 문자열 구분 기호 내에서 구분 기호 문자를 지정하세요. 예를 들어, 사용자 지정 형식 문자열 hh'_'dd'_'ss는 "_"(밑줄)이 항상 시간 구분 기호로 사용되는 결과 문자열을 생성합니다. 문화권의 모든 날짜에 대해 시간 구분 기호를 변경하려면 현재 문화권의 DateTimeFormatInfo.TimeSeparator 속성 값을 변경하거나 DateTimeFormatInfo 개체를 인스턴스화한 후 해당 TimeSeparator 속성에 문자를 할당하고 IFormatProvider 매개 변수를 포함하는 형식 지정 메서드의 오버로드를 호출하세요.

다른 사용자 지정 형식 지정자 없이 ":" 형식 지정자를 사용하면 표준 날짜 및 시간 형식 지정자로 해석되어 FormatException을 throw합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="time_zone">
        <source>time zone</source>
        <target state="translated">표준 시간대</target>
        <note />
      </trans-unit>
      <trans-unit id="time_zone_description">
        <source>The "K" custom format specifier represents the time zone information of a date and time value. When this format specifier is used with DateTime values, the result string is defined by the value of the DateTime.Kind property:

    For the local time zone (a DateTime.Kind property value of DateTimeKind.Local), this specifier is equivalent to the "zzz" specifier and produces a result string containing the local offset from Coordinated Universal Time (UTC); for example, "-07:00".

    For a UTC time (a DateTime.Kind property value of DateTimeKind.Utc), the result string includes a "Z" character to represent a UTC date.

    For a time from an unspecified time zone (a time whose DateTime.Kind property equals DateTimeKind.Unspecified), the result is equivalent to String.Empty.

For DateTimeOffset values, the "K" format specifier is equivalent to the "zzz" format specifier, and produces a result string containing the DateTimeOffset value's offset from UTC.

If the "K" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">"K" 사용자 지정 형식 지정자는 날짜 및 시간 값의 표준 시간대 정보를 나타냅니다. 이 형식 지정자를 DateTime 값과 함께 사용하면 결과 문자열은 DateTime.Kind 속성의 값으로 정의됩니다.

    현지 표준 시간대(DateTimeKind.Local의 DateTime.Kind 속성 값)의 경우, 이 지정자는 "zzz" 지정자와 동일하며 UTC(협정 세계시)에서 가져온 로컬 오프셋을 포함하는 결과 문자열을 생성합니다. 예를 들면 "-07:00"과 같습니다.

    UTC 시간(DateTimeKind.Utc의 DateTime.Kind 속성 값)의 경우, 결과 문자열은 UTC 날짜를 나타내는 "Z" 문자를 포함합니다.

    지정되지 않은 표준 시간대의 시간(DateTime.Kind 속성 값이 DateTimeKind.Unspecified와 같은 시간)의 경우, 결과는 String.Empty와 동일합니다.

DateTimeOffset 값의 경우, "K" 형식 지정자는 "zzz" 형식 지정자와 동일하며 UTC에서 가져온 DateTimeOffset 값의 오프셋을 포함하는 결과 문자열을 생성합니다.

다른 사용자 지정 형식 지정자 없이 "K" 형식 지정자를 사용하면 표준 날짜 및 시간 형식 지정자로 해석되어 FormatException을 throw합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="type">
        <source>type</source>
        <target state="translated">유형</target>
        <note />
      </trans-unit>
      <trans-unit id="type_constraint">
        <source>type constraint</source>
        <target state="translated">형식 제약 조건</target>
        <note />
      </trans-unit>
      <trans-unit id="type_parameter">
        <source>type parameter</source>
        <target state="translated">형식 매개 변수</target>
        <note />
      </trans-unit>
      <trans-unit id="attribute">
        <source>attribute</source>
        <target state="translated">특성</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_and_1_with_property">
        <source>Replace '{0}' and '{1}' with property</source>
        <target state="translated">속성으로 '{0}' 및 '{1}' 바꾸기</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_property">
        <source>Replace '{0}' with property</source>
        <target state="translated">속성으로 '{0}' 바꾸기</target>
        <note />
      </trans-unit>
      <trans-unit id="Method_referenced_implicitly">
        <source>Method referenced implicitly</source>
        <target state="translated">메서드가 암시적으로 참조됨</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_type_0">
        <source>Generate type '{0}'</source>
        <target state="translated">'{0}' 형식 생성</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_0_1">
        <source>Generate {0} '{1}'</source>
        <target state="translated">{0} '{1}' 생성</target>
        <note />
      </trans-unit>
      <trans-unit id="Change_0_to_1">
        <source>Change '{0}' to '{1}'.</source>
        <target state="translated">'{0}'을(를) '{1}'(으)로 변경합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Non_invoked_method_cannot_be_replaced_with_property">
        <source>Non-invoked method cannot be replaced with property.</source>
        <target state="translated">호출되지 않은 메서드는 속성으로 대체될 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Only_methods_with_a_single_argument_which_is_not_an_out_variable_declaration_can_be_replaced_with_a_property">
        <source>Only methods with a single argument, which is not an out variable declaration, can be replaced with a property.</source>
        <target state="translated">출력 변수 선언이 아닌, 단일 인수를 사용하는 메서드만 속성으로 대체될 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Roslyn_HostError">
        <source>Roslyn.HostError</source>
        <target state="translated">Roslyn.HostError</target>
        <note />
      </trans-unit>
      <trans-unit id="An_instance_of_analyzer_0_cannot_be_created_from_1_colon_2">
        <source>An instance of analyzer {0} cannot be created from {1}: {2}.</source>
        <target state="translated">{0} 분석기 인스턴스는 {1}에서 만들 수 없습니다. {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="The_assembly_0_does_not_contain_any_analyzers">
        <source>The assembly {0} does not contain any analyzers.</source>
        <target state="translated">{0} 어셈블리에는 분석기가 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unable_to_load_Analyzer_assembly_0_colon_1">
        <source>Unable to load Analyzer assembly {0}: {1}</source>
        <target state="translated">{0} 분석기 어셈블리를 로드할 수 없습니다. {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="from_0">
        <source>from {0}</source>
        <target state="translated">소스: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Find_and_install_latest_version">
        <source>Find and install latest version</source>
        <target state="translated">최신 버전 찾기 및 설치</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_local_version_0">
        <source>Use local version '{0}'</source>
        <target state="translated">로컬 버전 '{0}' 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_locally_installed_0_version_1_This_version_used_in_colon_2">
        <source>Use locally installed '{0}' version '{1}'
This version used in: {2}</source>
        <target state="translated">로컬에 설치된 '{0}' 버전 '{1}' 사용
이 버전 사용 대상: {2}</target>
        <note />
      </trans-unit>
      <trans-unit id="Find_and_install_latest_version_of_0">
        <source>Find and install latest version of '{0}'</source>
        <target state="translated">'{0}'의 최신 버전 찾기 및 설치</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_with_package_manager">
        <source>Install with package manager...</source>
        <target state="translated">패키지 관리자를 사용하여 설치...</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_0_1">
        <source>Install '{0} {1}'</source>
        <target state="translated">{0} {1}' 설치</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_version_0">
        <source>Install version '{0}'</source>
        <target state="translated">'{0}' 버전 설치</target>
        <note />
      </trans-unit>
      <trans-unit id="Classes">
        <source>Classes</source>
        <target state="translated">클래스</target>
        <note />
      </trans-unit>
      <trans-unit id="Constants">
        <source>Constants</source>
        <target state="translated">상수</target>
        <note />
      </trans-unit>
      <trans-unit id="Delegates">
        <source>Delegates</source>
        <target state="translated">대리자</target>
        <note />
      </trans-unit>
      <trans-unit id="Enums">
        <source>Enums</source>
        <target state="translated">열거형</target>
        <note />
      </trans-unit>
      <trans-unit id="Events">
        <source>Events</source>
        <target state="translated">이벤트</target>
        <note />
      </trans-unit>
      <trans-unit id="Extension_methods">
        <source>Extension methods</source>
        <target state="translated">확장 메서드</target>
        <note />
      </trans-unit>
      <trans-unit id="Fields">
        <source>Fields</source>
        <target state="translated">필드</target>
        <note />
      </trans-unit>
      <trans-unit id="Interfaces">
        <source>Interfaces</source>
        <target state="translated">인터페이스</target>
        <note />
      </trans-unit>
      <trans-unit id="Methods">
        <source>Methods</source>
        <target state="translated">메서드</target>
        <note />
      </trans-unit>
      <trans-unit id="Modules">
        <source>Modules</source>
        <target state="translated">모듈</target>
        <note />
      </trans-unit>
      <trans-unit id="Namespaces">
        <source>Namespaces</source>
        <target state="translated">네임스페이스</target>
        <note />
      </trans-unit>
      <trans-unit id="Properties">
        <source>Properties</source>
        <target state="translated">속성</target>
        <note />
      </trans-unit>
      <trans-unit id="Structures">
        <source>Structures</source>
        <target state="translated">구조</target>
        <note />
      </trans-unit>
      <trans-unit id="Parameters_colon">
        <source>Parameters:</source>
        <target state="translated">매개 변수:</target>
        <note />
      </trans-unit>
      <trans-unit id="Variadic_SignatureHelpItem_must_have_at_least_one_parameter">
        <source>Variadic SignatureHelpItem must have at least one parameter.</source>
        <target state="translated">Variadic SignatureHelpItem에는 매개 변수가 하나 이상 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_method">
        <source>Replace '{0}' with method</source>
        <target state="translated">'{0}'을(를) 메서드로 대체</target>
        <note />
      </trans-unit>
      <trans-unit id="Replace_0_with_methods">
        <source>Replace '{0}' with methods</source>
        <target state="translated">'{0}'을(를) 메서드로 대체</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_referenced_implicitly">
        <source>Property referenced implicitly</source>
        <target state="translated">속성이 암시적으로 참조됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Property_cannot_safely_be_replaced_with_a_method_call">
        <source>Property cannot safely be replaced with a method call</source>
        <target state="translated">속성을 메서드 호출로 안전하게 대체할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_interpolated_string">
        <source>Convert to interpolated string</source>
        <target state="translated">보간된 문자열로 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_type_to_0">
        <source>Move type to {0}</source>
        <target state="translated">{0}(으)로 형식 이동</target>
        <note />
      </trans-unit>
      <trans-unit id="Rename_file_to_0">
        <source>Rename file to {0}</source>
        <target state="translated">{0}(으)로 파일 이름 바꾸기</target>
        <note />
      </trans-unit>
      <trans-unit id="Rename_type_to_0">
        <source>Rename type to {0}</source>
        <target state="translated">{0}(으)로 형식 이름 바꾸기</target>
        <note />
      </trans-unit>
      <trans-unit id="paren_Unknown_paren">
        <source>(Unknown)</source>
        <target state="translated">(알 수 없음)</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_framework_type">
        <source>Use framework type</source>
        <target state="translated">Framework 형식 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="Install_package_0">
        <source>Install package '{0}'</source>
        <target state="translated">'{0}' 패키지 설치</target>
        <note />
      </trans-unit>
      <trans-unit id="project_0">
        <source>project {0}</source>
        <target state="translated">프로젝트 {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Fully_qualify_0">
        <source>Fully qualify '{0}'</source>
        <target state="translated">'{0}' 정규화</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_reference_to_0">
        <source>Remove reference to '{0}'.</source>
        <target state="translated">'{0}'에 대한 참조를 제거합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Keywords">
        <source>Keywords</source>
        <target state="translated">키워드</target>
        <note />
      </trans-unit>
      <trans-unit id="Snippets">
        <source>Snippets</source>
        <target state="translated">코드 조각</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_document_0">
        <source>Remove document '{0}'</source>
        <target state="translated">문서 '{0}' 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_document_0">
        <source>Add document '{0}'</source>
        <target state="translated">문서 '{0}' 추가</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_argument_name_0">
        <source>Add argument name '{0}'</source>
        <target state="translated">인수 이름 '{0}' 추가</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_unused_variable">
        <source>Remove unused variable</source>
        <target state="translated">사용하지 않는 변수 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_binary">
        <source>Convert to binary</source>
        <target state="translated">이진으로 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_decimal">
        <source>Convert to decimal</source>
        <target state="translated">10진수로 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_hex">
        <source>Convert to hex</source>
        <target state="translated">16진수로 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="Separate_thousands">
        <source>Separate thousands</source>
        <target state="translated">천 단위 구분</target>
        <note />
      </trans-unit>
      <trans-unit id="Separate_words">
        <source>Separate words</source>
        <target state="translated">단어 구분</target>
        <note />
      </trans-unit>
      <trans-unit id="Separate_nibbles">
        <source>Separate nibbles</source>
        <target state="translated">니블 구분</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_separators">
        <source>Remove separators</source>
        <target state="translated">구분 기호 제거</target>
        <note />
      </trans-unit>
      <trans-unit id="Pick_members_to_be_used_as_constructor_parameters">
        <source>Pick members to be used as constructor parameters</source>
        <target state="translated">생성자 매개 변수로 사용할 멤버 선택</target>
        <note />
      </trans-unit>
      <trans-unit id="Pick_members_to_be_used_in_Equals_GetHashCode">
        <source>Pick members to be used in Equals/GetHashCode</source>
        <target state="translated">Equals/GetHashCode에 사용할 멤버 선택</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_overrides">
        <source>Generate overrides...</source>
        <target state="translated">재정의 생성...</target>
        <note />
      </trans-unit>
      <trans-unit id="Pick_members_to_override">
        <source>Pick members to override</source>
        <target state="translated">재정의할 멤버 선택</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_null_check">
        <source>Add null check</source>
        <target state="translated">null 검사 추가</target>
        <note />
      </trans-unit>
      <trans-unit id="Initialize_field_0">
        <source>Initialize field '{0}'</source>
        <target state="translated">'{0}' 필드 초기화</target>
        <note />
      </trans-unit>
      <trans-unit id="Initialize_property_0">
        <source>Initialize property '{0}'</source>
        <target state="translated">'{0}' 속성 초기화</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_null_checks">
        <source>Add _null checks</source>
        <target state="translated">_null 검사 추가</target>
        <note />
      </trans-unit>
      <trans-unit id="Generate_operators">
        <source>Generate operators</source>
        <target state="translated">연산자 생성</target>
        <note />
      </trans-unit>
      <trans-unit id="Implement_0">
        <source>Implement {0}</source>
        <target state="translated">{0} 구현</target>
        <note />
      </trans-unit>
      <trans-unit id="Reported_diagnostic_0_has_a_source_location_in_file_1_which_is_not_part_of_the_compilation_being_analyzed">
        <source>Reported diagnostic '{0}' has a source location in file '{1}', which is not part of the compilation being analyzed.</source>
        <target state="translated">보고된 진단 '{0}'의 소스 위치가 분석되는 컴파일의 일부가 아닌 '{1}' 파일에 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Reported_diagnostic_0_has_a_source_location_1_in_file_2_which_is_outside_of_the_given_file">
        <source>Reported diagnostic '{0}' has a source location '{1}' in file '{2}', which is outside of the given file.</source>
        <target state="translated">보고된 진단 '{0}'의 소스 위치 '{1}'이(가) 지정된 파일의 범위 밖인 파일 '{2}'에 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="in_0_project_1">
        <source>in {0} (project {1})</source>
        <target state="translated">{0}(프로젝트 {1})</target>
        <note />
      </trans-unit>
      <trans-unit id="Move_declaration_near_reference">
        <source>Move declaration near reference</source>
        <target state="translated">참조 근처로 선언 이동</target>
        <note />
      </trans-unit>
      <trans-unit id="Convert_to_full_property">
        <source>Convert to full property</source>
        <target state="translated">전체 속성으로 변환</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_Method_overrides_symbol_from_metadata">
        <source>Warning: Method overrides symbol from metadata</source>
        <target state="translated">경고: 메서드가 메타데이터의 기호를 재정의합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Use_0">
        <source>Use {0}</source>
        <target state="translated">{0} 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_argument_name_0_including_trailing_arguments">
        <source>Add argument name '{0}' (including trailing arguments)</source>
        <target state="translated">인수 이름 '{0}' 추가(후행 인수 포함)</target>
        <note />
      </trans-unit>
      <trans-unit id="local_function">
        <source>local function</source>
        <target state="translated">로컬 함수</target>
        <note />
      </trans-unit>
      <trans-unit id="indexer_">
        <source>indexer</source>
        <target state="translated">인덱서</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_Collection_was_modified_during_iteration">
        <source>Warning: Collection was modified during iteration.</source>
        <target state="translated">경고: 반복 중 컬렉션이 수정되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_colon_Iteration_variable_crossed_function_boundary">
        <source>Warning: Iteration variable crossed function boundary.</source>
        <target state="translated">경고: 반복 변수가 함수 경계를 벗어났습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_full_date_time">
        <source>universal full date/time</source>
        <target state="translated">범용 전체 날짜/시간</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_full_date_time_description">
        <source>The "U" standard format specifier represents a custom date and time format string that is defined by a specified culture's DateTimeFormatInfo.FullDateTimePattern property. The pattern is the same as the "F" pattern. However, the DateTime value is automatically converted to UTC before it is formatted.</source>
        <target state="translated">"U" 표준 형식 지정자는 지정된 문화권의 DateTimeFormatInfo.FullDateTimePattern 속성으로 정의되는 사용자 지정 날짜 및 시간 형식 문자열을 나타냅니다. 패턴은 "F" 패턴과 동일합니다. 그러나 DateTime 값은 형식이 지정되기 전에 자동으로 UTC로 변환됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_sortable_date_time">
        <source>universal sortable date/time</source>
        <target state="translated">범용 정렬 가능한 날짜/시간</target>
        <note />
      </trans-unit>
      <trans-unit id="universal_sortable_date_time_description">
        <source>The "u" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.UniversalSortableDateTimePattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "yyyy'-'MM'-'dd HH':'mm':'ss'Z'". When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.

Although the result string should express a time as Coordinated Universal Time (UTC), no conversion of the original DateTime value is performed during the formatting operation. Therefore, you must convert a DateTime value to UTC by calling the DateTime.ToUniversalTime method before formatting it.</source>
        <target state="translated">"u" 표준 형식 지정자는 DateTimeFormatInfo.UniversalSortableDateTimePattern 속성으로 정의되는 사용자 지정 날짜 및 시간 형식 문자열을 나타냅니다. 패턴은 정의된 표준을 반영하며, 속성은 읽기 전용입니다. 따라서 사용된 문화권이나 지정된 형식 공급자와 관계없이 항상 동일합니다. 사용자 지정 형식 문자열은 "yyyy'-'MM'-'dd HH':'mm':'ss'Z'"입니다. 이 표준 형식 지정자를 사용하면 형식 지정 또는 구문 분석 연산에서 항상 고정 문화권이 사용됩니다..

결과 문자열은 시간을 UTC(협정 세계시)로 표현해야 하지만, 형식 지정 연산 중에 원래 DateTime 값의 변환이 수행되지 않습니다. 따라서 형식을 지정하기 전에 먼저 DateTime.ToUniversalTime 메서드를 호출하여 DateTime 값을 UTC로 변환해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_containing_member">
        <source>updating usages in containing member</source>
        <target state="translated">포함하는 멤버에서 사용을 업데이트하는 중</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_containing_project">
        <source>updating usages in containing project</source>
        <target state="translated">포함하는 프로젝트에서 사용을 업데이트하는 중</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_containing_type">
        <source>updating usages in containing type</source>
        <target state="translated">포함하는 형식에서 사용을 업데이트하는 중</target>
        <note />
      </trans-unit>
      <trans-unit id="updating_usages_in_dependent_projects">
        <source>updating usages in dependent projects</source>
        <target state="translated">종속 프로젝트에서 사용을 업데이트하는 중</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_and_minute_offset">
        <source>utc hour and minute offset</source>
        <target state="translated">UTC 시간 및 분 오프셋</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_and_minute_offset_description">
        <source>With DateTime values, the "zzz" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours and minutes. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "zzz" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours and minutes.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted with a leading zero.</source>
        <target state="translated">DateTime 값의 경우, "zzz" 사용자 지정 형식 지정자는 UTC에서 가져온 로컬 운영 체제의 표준 시간대의 부호 있는 오프셋을 나타내며(단위: 시간과 분), 인스턴스의 DateTime.Kind 속성의 값을 반영하지 않습니다. 따라서 DateTime 값과 함께 "zzz" 형식 지정자를 사용하는 것은 권장되지 않습니다.

DateTimeOffset 값의 경우, 이 형식 지정자는 UTC에서 가져온 DateTimeOffset 값의 오프셋을 나타냅니다(단위: 시간과 분).

오프셋은 항상 앞에 있는 부호와 함께 표시됩니다. 더하기 부호(+)는 UTC보다 앞선 시간을, 빼기 부호(-)는 UTC보다 늦은 시간을 나타냅니다. 한 자릿수 오프셋은 앞에 0이 있는 형식으로 지정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_1_2_digits">
        <source>utc hour offset (1-2 digits)</source>
        <target state="translated">UTC 시간 오프셋(1~2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_1_2_digits_description">
        <source>With DateTime values, the "z" custom format specifier represents the signed offset of the local operating system's time zone from Coordinated Universal Time (UTC), measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "z" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted without a leading zero.

If the "z" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</source>
        <target state="translated">DateTime 값의 경우, "z" 사용자 지정 형식 지정자는 UTC(협정 세계시)에서 가져온 로컬 운영 체제의 표준 시간대의 부호 있는 오프셋을 나타내며(단위: 시간), 인스턴스의 DateTime.Kind 속성의 값을 반영하지 않습니다. 따라서 DateTime 값과 함께 "z" 형식 지정자를 사용하는 것은 권장되지 않습니다.

DateTimeOffset 값의 경우, 이 형식 지정자는 UTC에서 가져온 DateTimeOffset 값의 오프셋을 나타냅니다(단위: 시간).

오프셋은 항상 앞에 있는 부호와 함께 표시됩니다. 더하기 부호(+)는 UTC보다 앞선 시간을, 빼기 부호(-)는 UTC보다 늦은 시간을 나타냅니다. 한 자릿수 오프셋은 앞에 0이 없는 형식으로 지정됩니다.

다른 사용자 지정 형식 지정자 없이 "z" 형식 지정자를 사용하면 표준 날짜 및 시간 형식으로 해석되어 FormatException을 throw합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_2_digits">
        <source>utc hour offset (2 digits)</source>
        <target state="translated">UTC 시간 오프셋(2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="utc_hour_offset_2_digits_description">
        <source>With DateTime values, the "zz" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "zz" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted with a leading zero.</source>
        <target state="translated">DateTime 값의 경우, "zz" 사용자 지정 형식 지정자는 UTC에서 가져온 로컬 운영 체제의 표준 시간대의 부호 있는 오프셋을 나타내며(단위: 시간), 인스턴스의 DateTime.Kind 속성의 값을 반영하지 않습니다. 따라서 DateTime 값과 함께 "zz" 형식 지정자를 사용하는 것은 권장되지 않습니다.

DateTimeOffset 값의 경우, 이 형식 지정자는 UTC에서 가져온 DateTimeOffset 값의 오프셋을 나타냅니다(단위: 시간).

오프셋은 항상 앞에 있는 부호와 함께 표시됩니다. 더하기 부호(+)는 UTC보다 앞선 시간을, 빼기 부호(-)는 UTC보다 늦은 시간을 나타냅니다. 한 자릿수 오프셋은 앞에 0이 있는 형식으로 지정됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="while_loop">
        <source>while loop</source>
        <target state="translated">while 루프</target>
        <note />
      </trans-unit>
      <trans-unit id="x_y_range_in_reverse_order">
        <source>[x-y] range in reverse order</source>
        <target state="translated">[x-y] 범위가 역순으로 되어 있습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [b-a]</note>
      </trans-unit>
      <trans-unit id="year_1_2_digits">
        <source>year (1-2 digits)</source>
        <target state="translated">년(1~2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_1_2_digits_description">
        <source>The "y" custom format specifier represents the year as a one-digit or two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the first digit of a two-digit year begins with a zero (for example, 2008), the number is formatted without a leading zero.

If the "y" format specifier is used without other custom format specifiers, it's interpreted as the "y" standard date and time format specifier.</source>
        <target state="translated">"y" 사용자 지정 형식 지정자는 연도를 한 자릿수 또는 두 자릿수 숫자로 나타냅니다. 연도에 세 자릿수 이상이 있는 경우 결과에는 최하위 숫자 2개만 표시됩니다. 두 자릿수 연도의 첫 번째 숫자가 0으로 시작하면(예: 2008) 숫자는 앞에 0이 없는 형식으로 지정됩니다.

다른 사용자 지정 형식 지정자 없이 "y" 형식 지정자를 사용하면 "y" 표준 날짜 및 시간 형식 지정자로 해석됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_2_digits">
        <source>year (2 digits)</source>
        <target state="translated">년(2자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_2_digits_description">
        <source>The "yy" custom format specifier represents the year as a two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the two-digit year has fewer than two significant digits, the number is padded with leading zeros to produce two digits.

In a parsing operation, a two-digit year that is parsed using the "yy" custom format specifier is interpreted based on the Calendar.TwoDigitYearMax property of the format provider's current calendar. The following example parses the string representation of a date that has a two-digit year by using the default Gregorian calendar of the en-US culture, which, in this case, is the current culture. It then changes the current culture's CultureInfo object to use a GregorianCalendar object whose TwoDigitYearMax property has been modified.</source>
        <target state="translated">"yy" 사용자 지정 형식 지정자는 연도를 두 자릿수 숫자로 나타냅니다. 연도에 세 자릿수 이상이 있는 경우 결과에 최하위 숫자 2개만 표시됩니다. 두 자릿수 연도에 3개 미만의 유효숫자가 있는 경우 앞을 0으로 채워 두 자릿수를 생성합니다.

구문 분석 연산에서, "yy" 사용자 지정 형식 지정자를 사용하여 구문 분석되는 두 자릿수 연도는 형식 공급자의 현재 달력의 Calendar.TwoDigitYearMax 속성을 기준으로 해석됩니다. 다음 예제에서는 두 자릿수 연도를 갖는 날짜의 문자열 표현을 이 예제의 현재 문화권인 en-US 문화권의 기본 양력을 사용하여 구문 분석합니다. 그런 다음 TwoDigitYearMax 속성이 수정된 GregorianCalendar 개체를 사용하도록 현재 문화권의 CultureInfo 개체를 변경합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_3_4_digits">
        <source>year (3-4 digits)</source>
        <target state="translated">년(3~4자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_3_4_digits_description">
        <source>The "yyy" custom format specifier represents the year with a minimum of three digits. If the year has more than three significant digits, they are included in the result string. If the year has fewer than three digits, the number is padded with leading zeros to produce three digits.</source>
        <target state="translated">"yyy" 사용자 지정 형식 지정자는 세 자릿수 이상으로 연도를 나타냅니다. 연도에 4개 이상의 유효 숫자가 있는 경우 결과 문자열에 포함됩니다. 연도에 3개 미만의 유효 숫자가 있는 경우 앞을 0으로 채워 세 자릿수를 생성합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_4_digits">
        <source>year (4 digits)</source>
        <target state="translated">년(4자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_4_digits_description">
        <source>The "yyyy" custom format specifier represents the year with a minimum of four digits. If the year has more than four significant digits, they are included in the result string. If the year has fewer than four digits, the number is padded with leading zeros to produce four digits.</source>
        <target state="translated">"yyyy" 사용자 지정 형식 지정자는 네 자릿수 이상으로 연도를 나타냅니다. 연도에 5개 이상의 유효 숫자가 있는 경우 결과 문자열에 포함됩니다. 연도에 4개 미만의 유효 숫자가 있는 경우 앞을 0으로 채워 네 자릿수를 생성합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_5_digits">
        <source>year (5 digits)</source>
        <target state="translated">년(5자리)</target>
        <note />
      </trans-unit>
      <trans-unit id="year_5_digits_description">
        <source>The "yyyyy" custom format specifier (plus any number of additional "y" specifiers) represents the year with a minimum of five digits. If the year has more than five significant digits, they are included in the result string. If the year has fewer than five digits, the number is padded with leading zeros to produce five digits.

If there are additional "y" specifiers, the number is padded with as many leading zeros as necessary to produce the number of "y" specifiers.</source>
        <target state="translated">"yyyyy" 사용자 지정 형식 지정자(및 임의 개수의 추가 "y" 지정자)는 다섯 자릿수 이상으로 연도를 나타냅니다. 연도에 6개 이상의 유효 숫자가 있는 경우 결과 문자열에 포함됩니다. 연도에 5개 미만의 유효 숫자가 있는 경우 앞을 0으로 채워 다섯 자릿수를 생성합니다.

추가 "y" 지정자가 있는 경우 "y" 지정자의 개수를 생성하는 데 필요한 만큼 숫자가 0으로 채워집니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="year_month">
        <source>year month</source>
        <target state="translated">년 월</target>
        <note />
      </trans-unit>
      <trans-unit id="year_month_description">
        <source>The "Y" or "y" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.YearMonthPattern property of a specified culture. For example, the custom format string for the invariant culture is "yyyy MMMM".</source>
        <target state="translated">"Y" 또는 "y" 표준 형식 지정자는 지정된 문화권의 DateTimeFormatInfo.YearMonthPattern 속성으로 정의되는 사용자 지정 날짜 및 시간 형식 문자열을 나타냅니다. 예를 들어, 고정 문화권의 사용자 지정 형식 문자열은 "yyyy MMMM"입니다.</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>