<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="Add_project_reference_to_0" xml:space="preserve">
    <value>Add project reference to '{0}'.</value>
  </data>
  <data name="Add_reference_to_0" xml:space="preserve">
    <value>Add reference to '{0}'.</value>
  </data>
  <data name="Actions_can_not_be_empty" xml:space="preserve">
    <value>Actions can not be empty.</value>
  </data>
  <data name="generic_overload" xml:space="preserve">
    <value>generic overload</value>
  </data>
  <data name="generic_overloads" xml:space="preserve">
    <value>generic overloads</value>
  </data>
  <data name="overload" xml:space="preserve">
    <value>overload</value>
  </data>
  <data name="overloads_" xml:space="preserve">
    <value>overloads</value>
  </data>
  <data name="_0_Keyword" xml:space="preserve">
    <value>{0} Keyword</value>
  </data>
  <data name="Encapsulate_field_colon_0_and_use_property" xml:space="preserve">
    <value>Encapsulate field: '{0}' (and use property)</value>
  </data>
  <data name="Encapsulate_field_colon_0_but_still_use_field" xml:space="preserve">
    <value>Encapsulate field: '{0}' (but still use field)</value>
  </data>
  <data name="Encapsulate_fields_and_use_property" xml:space="preserve">
    <value>Encapsulate fields (and use property)</value>
  </data>
  <data name="Encapsulate_fields_but_still_use_field" xml:space="preserve">
    <value>Encapsulate fields (but still use field)</value>
  </data>
  <data name="Could_not_extract_interface_colon_The_selection_is_not_inside_a_class_interface_struct" xml:space="preserve">
    <value>Could not extract interface: The selection is not inside a class/interface/struct.</value>
  </data>
  <data name="Could_not_extract_interface_colon_The_type_does_not_contain_any_member_that_can_be_extracted_to_an_interface" xml:space="preserve">
    <value>Could not extract interface: The type does not contain any member that can be extracted to an interface.</value>
  </data>
  <data name="can_t_not_construct_final_tree" xml:space="preserve">
    <value>can't not construct final tree</value>
  </data>
  <data name="Parameters_type_or_return_type_cannot_be_an_anonymous_type_colon_bracket_0_bracket" xml:space="preserve">
    <value>Parameters' type or return type cannot be an anonymous type : [{0}]</value>
  </data>
  <data name="The_selection_contains_no_active_statement" xml:space="preserve">
    <value>The selection contains no active statement.</value>
  </data>
  <data name="The_selection_contains_an_error_or_unknown_type" xml:space="preserve">
    <value>The selection contains an error or unknown type.</value>
  </data>
  <data name="Type_parameter_0_is_hidden_by_another_type_parameter_1" xml:space="preserve">
    <value>Type parameter '{0}' is hidden by another type parameter '{1}'.</value>
  </data>
  <data name="The_address_of_a_variable_is_used_inside_the_selected_code" xml:space="preserve">
    <value>The address of a variable is used inside the selected code.</value>
  </data>
  <data name="Assigning_to_readonly_fields_must_be_done_in_a_constructor_colon_bracket_0_bracket" xml:space="preserve">
    <value>Assigning to readonly fields must be done in a constructor : [{0}].</value>
  </data>
  <data name="generated_code_is_overlapping_with_hidden_portion_of_the_code" xml:space="preserve">
    <value>generated code is overlapping with hidden portion of the code</value>
  </data>
  <data name="Add_optional_parameters_to_0" xml:space="preserve">
    <value>Add optional parameters to '{0}'</value>
  </data>
  <data name="Add_parameters_to_0" xml:space="preserve">
    <value>Add parameters to '{0}'</value>
  </data>
  <data name="Generate_delegating_constructor_0_1" xml:space="preserve">
    <value>Generate delegating constructor '{0}({1})'</value>
  </data>
  <data name="Generate_constructor_0_1" xml:space="preserve">
    <value>Generate constructor '{0}({1})'</value>
  </data>
  <data name="Generate_field_assigning_constructor_0_1" xml:space="preserve">
    <value>Generate field assigning constructor '{0}({1})'</value>
  </data>
  <data name="Generate_Equals_and_GetHashCode" xml:space="preserve">
    <value>Generate Equals and GetHashCode</value>
  </data>
  <data name="Generate_Equals_object" xml:space="preserve">
    <value>Generate Equals(object)</value>
  </data>
  <data name="Generate_GetHashCode" xml:space="preserve">
    <value>Generate GetHashCode()</value>
  </data>
  <data name="Generate_constructor_in_0" xml:space="preserve">
    <value>Generate constructor in '{0}'</value>
  </data>
  <data name="Generate_all" xml:space="preserve">
    <value>Generate all</value>
  </data>
  <data name="Generate_enum_member_1_0" xml:space="preserve">
    <value>Generate enum member '{1}.{0}'</value>
  </data>
  <data name="Generate_constant_1_0" xml:space="preserve">
    <value>Generate constant '{1}.{0}'</value>
  </data>
  <data name="Generate_read_only_property_1_0" xml:space="preserve">
    <value>Generate read-only property '{1}.{0}'</value>
  </data>
  <data name="Generate_property_1_0" xml:space="preserve">
    <value>Generate property '{1}.{0}'</value>
  </data>
  <data name="Generate_read_only_field_1_0" xml:space="preserve">
    <value>Generate read-only field '{1}.{0}'</value>
  </data>
  <data name="Generate_field_1_0" xml:space="preserve">
    <value>Generate field '{1}.{0}'</value>
  </data>
  <data name="Generate_local_0" xml:space="preserve">
    <value>Generate local '{0}'</value>
  </data>
  <data name="Generate_0_1_in_new_file" xml:space="preserve">
    <value>Generate {0} '{1}' in new file</value>
  </data>
  <data name="Generate_nested_0_1" xml:space="preserve">
    <value>Generate nested {0} '{1}'</value>
  </data>
  <data name="Global_Namespace" xml:space="preserve">
    <value>Global Namespace</value>
  </data>
  <data name="Implement_interface_explicitly" xml:space="preserve">
    <value>Implement interface explicitly</value>
  </data>
  <data name="Implement_interface_abstractly" xml:space="preserve">
    <value>Implement interface abstractly</value>
  </data>
  <data name="Implement_interface_through_0" xml:space="preserve">
    <value>Implement interface through '{0}'</value>
  </data>
  <data name="Implement_interface" xml:space="preserve">
    <value>Implement interface</value>
  </data>
  <data name="Introduce_field_for_0" xml:space="preserve">
    <value>Introduce field for '{0}'</value>
  </data>
  <data name="Introduce_local_for_0" xml:space="preserve">
    <value>Introduce local for '{0}'</value>
  </data>
  <data name="Introduce_constant_for_0" xml:space="preserve">
    <value>Introduce constant for '{0}'</value>
  </data>
  <data name="Introduce_local_constant_for_0" xml:space="preserve">
    <value>Introduce local constant for '{0}'</value>
  </data>
  <data name="Introduce_field_for_all_occurrences_of_0" xml:space="preserve">
    <value>Introduce field for all occurrences of '{0}'</value>
  </data>
  <data name="Introduce_local_for_all_occurrences_of_0" xml:space="preserve">
    <value>Introduce local for all occurrences of '{0}'</value>
  </data>
  <data name="Introduce_constant_for_all_occurrences_of_0" xml:space="preserve">
    <value>Introduce constant for all occurrences of '{0}'</value>
  </data>
  <data name="Introduce_local_constant_for_all_occurrences_of_0" xml:space="preserve">
    <value>Introduce local constant for all occurrences of '{0}'</value>
  </data>
  <data name="Introduce_query_variable_for_all_occurrences_of_0" xml:space="preserve">
    <value>Introduce query variable for all occurrences of '{0}'</value>
  </data>
  <data name="Introduce_query_variable_for_0" xml:space="preserve">
    <value>Introduce query variable for '{0}'</value>
  </data>
  <data name="Anonymous_Types_colon" xml:space="preserve">
    <value>Anonymous Types:</value>
  </data>
  <data name="is_" xml:space="preserve">
    <value>is</value>
  </data>
  <data name="Represents_an_object_whose_operations_will_be_resolved_at_runtime" xml:space="preserve">
    <value>Represents an object whose operations will be resolved at runtime.</value>
  </data>
  <data name="constant" xml:space="preserve">
    <value>constant</value>
  </data>
  <data name="field" xml:space="preserve">
    <value>field</value>
  </data>
  <data name="local_constant" xml:space="preserve">
    <value>local constant</value>
  </data>
  <data name="local_variable" xml:space="preserve">
    <value>local variable</value>
  </data>
  <data name="label" xml:space="preserve">
    <value>label</value>
  </data>
  <data name="range_variable" xml:space="preserve">
    <value>range variable</value>
  </data>
  <data name="parameter" xml:space="preserve">
    <value>parameter</value>
  </data>
  <data name="in_" xml:space="preserve">
    <value>in</value>
  </data>
  <data name="Summary_colon" xml:space="preserve">
    <value>Summary:</value>
  </data>
  <data name="Locals_and_parameters" xml:space="preserve">
    <value>Locals and parameters</value>
  </data>
  <data name="Type_parameters_colon" xml:space="preserve">
    <value>Type parameters:</value>
  </data>
  <data name="Returns_colon" xml:space="preserve">
    <value>Returns:</value>
  </data>
  <data name="Exceptions_colon" xml:space="preserve">
    <value>Exceptions:</value>
  </data>
  <data name="Remarks_colon" xml:space="preserve">
    <value>Remarks:</value>
  </data>
  <data name="generating_source_for_symbols_of_this_type_is_not_supported" xml:space="preserve">
    <value>generating source for symbols of this type is not supported</value>
  </data>
  <data name="Assembly" xml:space="preserve">
    <value>Assembly</value>
  </data>
  <data name="location_unknown" xml:space="preserve">
    <value>location unknown</value>
  </data>
  <data name="Extract_Interface" xml:space="preserve">
    <value>Extract Interface...</value>
  </data>
  <data name="Updating_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_a_complex_statement_containing_an_await_expression_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating a complex statement containing an await expression will prevent the debug session from continuing.</value>
  </data>
  <data name="Changing_visibility_of_a_constructor_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Changing visibility of a constructor will prevent the debug session from continuing.</value>
  </data>
  <data name="Capturing_variable_0_that_hasn_t_been_captured_before_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Capturing variable '{0}' that hasn't been captured before will prevent the debug session from continuing.</value>
  </data>
  <data name="Ceasing_to_capture_variable_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Ceasing to capture variable '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Deleting_captured_variable_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Deleting captured variable '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Changing_the_type_of_a_captured_variable_0_previously_of_type_1_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Changing the type of a captured variable '{0}' previously of type '{1}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Changing_the_parameters_of_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Changing the parameters of '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Changing_the_return_type_of_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Changing the return type of '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Changing_the_type_of_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Changing the type of '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Changing_the_declaration_scope_of_a_captured_variable_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Changing the declaration scope of a captured variable '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Accessing_captured_variable_0_that_hasn_t_been_accessed_before_in_1_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Accessing captured variable '{0}' that hasn't been accessed before in {1} will prevent the debug session from continuing.</value>
  </data>
  <data name="Ceasing_to_access_captured_variable_0_in_1_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Ceasing to access captured variable '{0}' in {1} will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_0_that_accesses_captured_variables_1_and_2_declared_in_different_scopes_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding '{0}' that accesses captured variables '{1}' and '{2}' declared in different scopes will prevent the debug session from continuing.</value>
  </data>
  <data name="Removing_0_that_accessed_captured_variables_1_and_2_declared_in_different_scopes_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Removing '{0}' that accessed captured variables '{1}' and '{2}' declared in different scopes will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_0_into_a_1_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding '{0}' into a '{1}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_0_into_a_class_with_explicit_or_sequential_layout_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding '{0}' into a class with explicit or sequential layout will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_modifiers_of_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the modifiers of '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_Handles_clause_of_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the Handles clause of '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_0_with_the_Handles_clause_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding '{0}' with the Handles clause will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_Implements_clause_of_a_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the Implements clause of a '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Changing_the_constraint_from_0_to_1_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Changing the constraint from '{0}' to '{1}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_variance_of_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the variance of '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_type_of_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the type of '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_initializer_of_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the initializer of '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_size_of_a_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the size of a '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_underlying_type_of_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the underlying type of '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_base_class_and_or_base_interface_s_of_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the base class and/or base interface(s) of '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_a_field_to_an_event_or_vice_versa_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating a field to an event or vice versa will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_kind_of_a_type_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the kind of a type will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_kind_of_an_property_event_accessor_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the kind of an property/event accessor will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_kind_of_a_method_Sub_Function_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the kind of a method (Sub/Function) will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_library_name_of_Declare_Statement_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the library name of Declare Statement will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_the_alias_of_Declare_Statement_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating the alias of Declare Statement will prevent the debug session from continuing.</value>
  </data>
  <data name="Renaming_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Renaming '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_an_abstract_0_or_overriding_an_inherited_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding an abstract '{0}' or overriding an inherited '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_a_MustOverride_0_or_overriding_an_inherited_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding a MustOverride '{0}' or overriding an inherited '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_an_extern_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding an extern '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_an_imported_method_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding an imported method will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_a_user_defined_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding a user defined '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_a_generic_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding a generic '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding '{0}' around an active statement will prevent the debug session from continuing.</value>
  </data>
  <data name="Moving_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Moving '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Deleting_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Deleting '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Deleting_0_around_an_active_statement_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Deleting '{0}' around an active statement will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_a_method_body_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding a method body will prevent the debug session from continuing.</value>
  </data>
  <data name="Deleting_a_method_body_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Deleting a method body will prevent the debug session from continuing.</value>
  </data>
  <data name="An_active_statement_has_been_removed_from_its_original_method_You_must_revert_your_changes_to_continue_or_restart_the_debugging_session" xml:space="preserve">
    <value>An active statement has been removed from its original method. You must revert your changes to continue or restart the debugging session.</value>
  </data>
  <data name="Updating_a_0_statement_around_an_active_statement_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating a '{0}' statement around an active statement will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_async_or_iterator_modifier_around_an_active_statement_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating async or iterator modifier around an active statement will prevent the debug session from continuing.</value>
    <comment>{Locked="async"}{Locked="iterator"} "async" and "iterator" are C#/VB keywords and should not be localized.</comment>
  </data>
  <data name="Modifying_a_generic_method_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying a generic method will prevent the debug session from continuing.</value>
  </data>
  <data name="Modifying_whitespace_or_comments_in_a_generic_0_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying whitespace or comments in a generic '{0}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Modifying_a_method_inside_the_context_of_a_generic_type_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying a method inside the context of a generic type will prevent the debug session from continuing.</value>
  </data>
  <data name="Modifying_whitespace_or_comments_in_0_inside_the_context_of_a_generic_type_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying whitespace or comments in '{0}' inside the context of a generic type will prevent the debug session from continuing.</value>
  </data>
  <data name="Modifying_the_initializer_of_0_in_a_generic_type_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying the initializer of '{0}' in a generic type will prevent the debug session from continuing.</value>
  </data>
  <data name="Modifying_the_initializer_of_0_in_a_partial_type_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying the initializer of '{0}' in a partial type will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_a_constructor_to_a_type_with_a_field_or_property_initializer_that_contains_an_anonymous_function_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding a constructor to a type with a field or property initializer that contains an anonymous function will prevent the debug session from continuing.</value>
  </data>
  <data name="Renaming_a_captured_variable_from_0_to_1_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Renaming a captured variable, from '{0}' to '{1}' will prevent the debug session from continuing.</value>
  </data>
  <data name="Modifying_a_catch_finally_handler_with_an_active_statement_in_the_try_block_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying a catch/finally handler with an active statement in the try block will prevent the debug session from continuing.</value>
  </data>
  <data name="Modifying_a_try_catch_finally_statement_when_the_finally_block_is_active_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying a try/catch/finally statement when the finally block is active will prevent the debug session from continuing.</value>
  </data>
  <data name="Modifying_a_catch_handler_around_an_active_statement_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying a catch handler around an active statement will prevent the debug session from continuing.</value>
  </data>
  <data name="Modifying_0_which_contains_the_stackalloc_operator_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying '{0}' which contains the 'stackalloc' operator will prevent the debug session from continuing.</value>
  </data>
  <data name="Modifying_an_active_0_which_contains_On_Error_or_Resume_statements_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying an active '{0}' which contains 'On Error' or 'Resume' statements will prevent the debug session from continuing.</value>
  </data>
  <data name="Modifying_0_which_contains_an_Aggregate_Group_By_or_Join_query_clauses_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying '{0}' which contains an Aggregate, Group By, or Join query clauses will prevent the debug session from continuing.</value>
  </data>
  <data name="Modifying_source_with_experimental_language_features_enabled_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying source with experimental language features enabled will prevent the debug session from continuing.</value>
  </data>
  <data name="Updating_an_active_statement_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Updating an active statement will prevent the debug session from continuing.</value>
  </data>
  <data name="Removing_0_that_contains_an_active_statement_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Removing '{0}' that contains an active statement will prevent the debug session from continuing.</value>
  </data>
  <data name="Adding_a_new_file_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding a new file will prevent the debug session from continuing.</value>
  </data>
  <data name="Attribute_0_is_missing_Updating_an_async_method_or_an_iterator_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Attribute '{0}' is missing. Updating an async method or an iterator will prevent the debug session from continuing.</value>
  </data>
  <data name="Unexpected_interface_member_kind_colon_0" xml:space="preserve">
    <value>Unexpected interface member kind: {0}</value>
  </data>
  <data name="Unknown_symbol_kind" xml:space="preserve">
    <value>Unknown symbol kind</value>
  </data>
  <data name="Generate_abstract_property_1_0" xml:space="preserve">
    <value>Generate abstract property '{1}.{0}'</value>
  </data>
  <data name="Generate_abstract_method_1_0" xml:space="preserve">
    <value>Generate abstract method '{1}.{0}'</value>
  </data>
  <data name="Generate_method_1_0" xml:space="preserve">
    <value>Generate method '{1}.{0}'</value>
  </data>
  <data name="Requested_assembly_already_loaded_from_0" xml:space="preserve">
    <value>Requested assembly already loaded from '{0}'.</value>
  </data>
  <data name="The_symbol_does_not_have_an_icon" xml:space="preserve">
    <value>The symbol does not have an icon.</value>
  </data>
  <data name="Unknown" xml:space="preserve">
    <value>Unknown</value>
  </data>
  <data name="Extract_Method" xml:space="preserve">
    <value>Extract Method</value>
  </data>
  <data name="Extract_Method_plus_Local" xml:space="preserve">
    <value>Extract Method + Local</value>
  </data>
  <data name="Asynchronous_method_cannot_have_ref_out_parameters_colon_bracket_0_bracket" xml:space="preserve">
    <value>Asynchronous method cannot have ref/out parameters : [{0}]</value>
  </data>
  <data name="The_member_is_defined_in_metadata" xml:space="preserve">
    <value>The member is defined in metadata.</value>
  </data>
  <data name="You_can_only_change_the_signature_of_a_constructor_indexer_method_or_delegate" xml:space="preserve">
    <value>You can only change the signature of a constructor, indexer, method or delegate.</value>
  </data>
  <data name="This_symbol_has_related_definitions_or_references_in_metadata_Changing_its_signature_may_result_in_build_errors_Do_you_want_to_continue" xml:space="preserve">
    <value>This symbol has related definitions or references in metadata. Changing its signature may result in build errors.

Do you want to continue?</value>
  </data>
  <data name="Change_signature" xml:space="preserve">
    <value>Change signature...</value>
  </data>
  <data name="Generate_new_type" xml:space="preserve">
    <value>Generate new type...</value>
  </data>
  <data name="User_Diagnostic_Analyzer_Failure" xml:space="preserve">
    <value>User Diagnostic Analyzer Failure.</value>
  </data>
  <data name="Analyzer_0_threw_an_exception_of_type_1_with_message_2" xml:space="preserve">
    <value>Analyzer '{0}' threw an exception of type '{1}' with message '{2}'.</value>
  </data>
  <data name="Analyzer_0_threw_the_following_exception_colon_1" xml:space="preserve">
    <value>Analyzer '{0}' threw the following exception:
'{1}'.</value>
  </data>
  <data name="Remove_Unnecessary_Cast" xml:space="preserve">
    <value>Remove Unnecessary Cast</value>
  </data>
  <data name="Simplify_Names" xml:space="preserve">
    <value>Simplify Names</value>
  </data>
  <data name="Simplify_Member_Access" xml:space="preserve">
    <value>Simplify Member Access</value>
  </data>
  <data name="Remove_qualification" xml:space="preserve">
    <value>Remove qualification</value>
  </data>
  <data name="Edit_and_Continue1" xml:space="preserve">
    <value>Edit and Continue</value>
  </data>
  <data name="This_signature_does_not_contain_parameters_that_can_be_changed" xml:space="preserve">
    <value>This signature does not contain parameters that can be changed.</value>
  </data>
  <data name="Unknown_error_occurred" xml:space="preserve">
    <value>Unknown error occurred</value>
  </data>
  <data name="Available" xml:space="preserve">
    <value>Available</value>
  </data>
  <data name="Not_Available" xml:space="preserve">
    <value>Not Available</value>
  </data>
  <data name="_0_1" xml:space="preserve">
    <value>    {0} - {1}</value>
  </data>
  <data name="You_can_use_the_navigation_bar_to_switch_context" xml:space="preserve">
    <value>You can use the navigation bar to switch context.</value>
  </data>
  <data name="in_Source" xml:space="preserve">
    <value>in Source</value>
  </data>
  <data name="in_Suppression_File" xml:space="preserve">
    <value>in Suppression File</value>
  </data>
  <data name="Remove_Suppression_0" xml:space="preserve">
    <value>Remove Suppression {0}</value>
  </data>
  <data name="Remove_Suppression" xml:space="preserve">
    <value>Remove Suppression</value>
  </data>
  <data name="Pending" xml:space="preserve">
    <value>&lt;Pending&gt;</value>
  </data>
  <data name="Awaited_task_returns" xml:space="preserve">
    <value>Awaited task returns</value>
  </data>
  <data name="no_value" xml:space="preserve">
    <value>no value.</value>
  </data>
  <data name="Note_colon_Tab_twice_to_insert_the_0_snippet" xml:space="preserve">
    <value>Note: Tab twice to insert the '{0}' snippet.</value>
  </data>
  <data name="Implement_interface_explicitly_with_Dispose_pattern" xml:space="preserve">
    <value>Implement interface explicitly with Dispose pattern</value>
  </data>
  <data name="Implement_interface_with_Dispose_pattern" xml:space="preserve">
    <value>Implement interface with Dispose pattern</value>
  </data>
  <data name="Compiler1" xml:space="preserve">
    <value>Compiler</value>
  </data>
  <data name="Edit_and_Continue2" xml:space="preserve">
    <value>Edit and Continue</value>
  </data>
  <data name="Style" xml:space="preserve">
    <value>Style</value>
  </data>
  <data name="Suppress_0" xml:space="preserve">
    <value>Suppress {0}</value>
  </data>
  <data name="Re_triage_0_currently_1" xml:space="preserve">
    <value>Re-triage {0}(currently '{1}')</value>
  </data>
  <data name="Argument_cannot_have_a_null_element" xml:space="preserve">
    <value>Argument cannot have a null element.</value>
  </data>
  <data name="Argument_cannot_be_empty" xml:space="preserve">
    <value>Argument cannot be empty.</value>
  </data>
  <data name="Reported_diagnostic_with_ID_0_is_not_supported_by_the_analyzer" xml:space="preserve">
    <value>Reported diagnostic with ID '{0}' is not supported by the analyzer.</value>
  </data>
  <data name="Computing_fix_all_occurrences_code_fix" xml:space="preserve">
    <value>Computing fix all occurrences code fix...</value>
  </data>
  <data name="Fix_all_occurrences" xml:space="preserve">
    <value>Fix all occurrences</value>
  </data>
  <data name="Document" xml:space="preserve">
    <value>Document</value>
  </data>
  <data name="Project" xml:space="preserve">
    <value>Project</value>
  </data>
  <data name="Solution" xml:space="preserve">
    <value>Solution</value>
  </data>
  <data name="TODO_colon_dispose_managed_state_managed_objects" xml:space="preserve">
    <value>TODO: dispose managed state (managed objects).</value>
  </data>
  <data name="TODO_colon_set_large_fields_to_null" xml:space="preserve">
    <value>TODO: set large fields to null.</value>
  </data>
  <data name="To_detect_redundant_calls" xml:space="preserve">
    <value>To detect redundant calls</value>
  </data>
  <data name="Modifying_0_which_contains_a_static_variable_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Modifying '{0}' which contains a static variable will prevent the debug session from continuing.</value>
  </data>
  <data name="Compiler2" xml:space="preserve">
    <value>Compiler</value>
  </data>
  <data name="Edit_And_Continue" xml:space="preserve">
    <value>Edit And Continue</value>
  </data>
  <data name="Live" xml:space="preserve">
    <value>Live</value>
  </data>
  <data name="namespace_" xml:space="preserve">
    <value>namespace</value>
    <comment>{Locked}</comment>
  </data>
  <data name="class_" xml:space="preserve">
    <value>class</value>
    <comment>{Locked}</comment>
  </data>
  <data name="interface_" xml:space="preserve">
    <value>interface</value>
    <comment>{Locked}</comment>
  </data>
  <data name="enum_" xml:space="preserve">
    <value>enum</value>
    <comment>{Locked}</comment>
  </data>
  <data name="enum_value" xml:space="preserve">
    <value>enum value</value>
    <comment>{Locked="enum"} "enum" is a C#/VB keyword and should not be localized.</comment>
  </data>
  <data name="delegate_" xml:space="preserve">
    <value>delegate</value>
    <comment>{Locked}</comment>
  </data>
  <data name="const_field" xml:space="preserve">
    <value>const field</value>
    <comment>{Locked="const"} "const" is a C#/VB keyword and should not be localized.</comment>
  </data>
  <data name="method" xml:space="preserve">
    <value>method</value>
  </data>
  <data name="operator_" xml:space="preserve">
    <value>operator</value>
  </data>
  <data name="constructor" xml:space="preserve">
    <value>constructor</value>
  </data>
  <data name="auto_property" xml:space="preserve">
    <value>auto-property</value>
  </data>
  <data name="property_" xml:space="preserve">
    <value>property</value>
  </data>
  <data name="event_" xml:space="preserve">
    <value>event</value>
    <comment>{Locked}</comment>
  </data>
  <data name="event_accessor" xml:space="preserve">
    <value>event accessor</value>
  </data>
  <data name="type_constraint" xml:space="preserve">
    <value>type constraint</value>
  </data>
  <data name="type_parameter" xml:space="preserve">
    <value>type parameter</value>
  </data>
  <data name="attribute" xml:space="preserve">
    <value>attribute</value>
  </data>
  <data name="Use_auto_property" xml:space="preserve">
    <value>Use auto property</value>
  </data>
  <data name="Replace_0_and_1_with_property" xml:space="preserve">
    <value>Replace '{0}' and '{1}' with property</value>
  </data>
  <data name="Replace_0_with_property" xml:space="preserve">
    <value>Replace '{0}' with property</value>
  </data>
  <data name="Method_referenced_implicitly" xml:space="preserve">
    <value>Method referenced implicitly</value>
  </data>
  <data name="Generate_type_0" xml:space="preserve">
    <value>Generate type '{0}'</value>
  </data>
  <data name="Generate_0_1" xml:space="preserve">
    <value>Generate {0} '{1}'</value>
  </data>
  <data name="Change_0_to_1" xml:space="preserve">
    <value>Change '{0}' to '{1}'.</value>
  </data>
  <data name="Non_invoked_method_cannot_be_replaced_with_property" xml:space="preserve">
    <value>Non-invoked method cannot be replaced with property.</value>
  </data>
  <data name="Only_methods_with_a_single_argument_which_is_not_an_out_variable_declaration_can_be_replaced_with_a_property" xml:space="preserve">
    <value>Only methods with a single argument, which is not an out variable declaration, can be replaced with a property.</value>
  </data>
  <data name="Roslyn_HostError" xml:space="preserve">
    <value>Roslyn.HostError</value>
  </data>
  <data name="An_instance_of_analyzer_0_cannot_be_created_from_1_colon_2" xml:space="preserve">
    <value>An instance of analyzer {0} cannot be created from {1}: {2}.</value>
  </data>
  <data name="The_assembly_0_does_not_contain_any_analyzers" xml:space="preserve">
    <value>The assembly {0} does not contain any analyzers.</value>
  </data>
  <data name="Unable_to_load_Analyzer_assembly_0_colon_1" xml:space="preserve">
    <value>Unable to load Analyzer assembly {0}: {1}</value>
  </data>
  <data name="Make_method_synchronous" xml:space="preserve">
    <value>Make method synchronous</value>
  </data>
  <data name="Add_this_or_Me_qualification" xml:space="preserve">
    <value>Add 'this' or 'Me' qualification.</value>
  </data>
  <data name="Fix_Name_Violation_colon_0" xml:space="preserve">
    <value>Fix Name Violation: {0}</value>
  </data>
  <data name="Naming_rule_violation_0" xml:space="preserve">
    <value>Naming rule violation: {0}</value>
    <comment>{0} is the rule title, {1} is the way in which the rule was violated</comment>
  </data>
  <data name="Naming_Styles" xml:space="preserve">
    <value>Naming Styles</value>
  </data>
  <data name="from_0" xml:space="preserve">
    <value>from {0}</value>
  </data>
  <data name="Find_and_install_latest_version" xml:space="preserve">
    <value>Find and install latest version</value>
  </data>
  <data name="Use_local_version_0" xml:space="preserve">
    <value>Use local version '{0}'</value>
  </data>
  <data name="Use_locally_installed_0_version_1_This_version_used_in_colon_2" xml:space="preserve">
    <value>Use locally installed '{0}' version '{1}'
This version used in: {2}</value>
  </data>
  <data name="Find_and_install_latest_version_of_0" xml:space="preserve">
    <value>Find and install latest version of '{0}'</value>
  </data>
  <data name="Install_with_package_manager" xml:space="preserve">
    <value>Install with package manager...</value>
  </data>
  <data name="Install_0_1" xml:space="preserve">
    <value>Install '{0} {1}'</value>
  </data>
  <data name="Install_version_0" xml:space="preserve">
    <value>Install version '{0}'</value>
  </data>
  <data name="Generate_variable_0" xml:space="preserve">
    <value>Generate variable '{0}'</value>
  </data>
  <data name="Classes" xml:space="preserve">
    <value>Classes</value>
  </data>
  <data name="Constants" xml:space="preserve">
    <value>Constants</value>
  </data>
  <data name="Delegates" xml:space="preserve">
    <value>Delegates</value>
  </data>
  <data name="Enums" xml:space="preserve">
    <value>Enums</value>
  </data>
  <data name="Events" xml:space="preserve">
    <value>Events</value>
  </data>
  <data name="Extension_methods" xml:space="preserve">
    <value>Extension methods</value>
  </data>
  <data name="Fields" xml:space="preserve">
    <value>Fields</value>
  </data>
  <data name="Interfaces" xml:space="preserve">
    <value>Interfaces</value>
  </data>
  <data name="Locals" xml:space="preserve">
    <value>Locals</value>
  </data>
  <data name="Methods" xml:space="preserve">
    <value>Methods</value>
  </data>
  <data name="Modules" xml:space="preserve">
    <value>Modules</value>
  </data>
  <data name="Namespaces" xml:space="preserve">
    <value>Namespaces</value>
  </data>
  <data name="Properties" xml:space="preserve">
    <value>Properties</value>
  </data>
  <data name="Structures" xml:space="preserve">
    <value>Structures</value>
  </data>
  <data name="Parameters_colon" xml:space="preserve">
    <value>Parameters:</value>
  </data>
  <data name="Add_missing_cases" xml:space="preserve">
    <value>Add missing cases</value>
  </data>
  <data name="Add_both" xml:space="preserve">
    <value>Add both</value>
  </data>
  <data name="Add_default_case" xml:space="preserve">
    <value>Add default case</value>
  </data>
  <data name="Variadic_SignatureHelpItem_must_have_at_least_one_parameter" xml:space="preserve">
    <value>Variadic SignatureHelpItem must have at least one parameter.</value>
  </data>
  <data name="Add_braces" xml:space="preserve">
    <value>Add braces</value>
  </data>
  <data name="Replace_0_with_method" xml:space="preserve">
    <value>Replace '{0}' with method</value>
  </data>
  <data name="Replace_0_with_methods" xml:space="preserve">
    <value>Replace '{0}' with methods</value>
  </data>
  <data name="Property_referenced_implicitly" xml:space="preserve">
    <value>Property referenced implicitly</value>
  </data>
  <data name="Property_cannot_safely_be_replaced_with_a_method_call" xml:space="preserve">
    <value>Property cannot safely be replaced with a method call</value>
  </data>
  <data name="Convert_to_interpolated_string" xml:space="preserve">
    <value>Convert to interpolated string</value>
  </data>
  <data name="Move_type_to_0" xml:space="preserve">
    <value>Move type to {0}</value>
  </data>
  <data name="Rename_file_to_0" xml:space="preserve">
    <value>Rename file to {0}</value>
  </data>
  <data name="Rename_type_to_0" xml:space="preserve">
    <value>Rename type to {0}</value>
  </data>
  <data name="Remove_tag" xml:space="preserve">
    <value>Remove tag</value>
  </data>
  <data name="Add_missing_param_nodes" xml:space="preserve">
    <value>Add missing param nodes</value>
  </data>
  <data name="Make_containing_scope_async" xml:space="preserve">
    <value>Make containing scope async</value>
  </data>
  <data name="Make_containing_scope_async_return_Task" xml:space="preserve">
    <value>Make containing scope async (return Task)</value>
  </data>
  <data name="paren_Unknown_paren" xml:space="preserve">
    <value>(Unknown)</value>
  </data>
  <data name="Implement_Abstract_Class" xml:space="preserve">
    <value>Implement Abstract Class</value>
  </data>
  <data name="Use_framework_type" xml:space="preserve">
    <value>Use framework type</value>
  </data>
  <data name="Install_package_0" xml:space="preserve">
    <value>Install package '{0}'</value>
  </data>
  <data name="Object_initialization_can_be_simplified" xml:space="preserve">
    <value>Object initialization can be simplified</value>
  </data>
  <data name="Use_throw_expression" xml:space="preserve">
    <value>Use 'throw' expression</value>
  </data>
  <data name="project_0" xml:space="preserve">
    <value>project {0}</value>
  </data>
  <data name="Inline_variable_declaration" xml:space="preserve">
    <value>Inline variable declaration</value>
  </data>
  <data name="Use_pattern_matching" xml:space="preserve">
    <value>Use pattern matching</value>
  </data>
  <data name="Use_interpolated_verbatim_string" xml:space="preserve">
    <value>Use interpolated verbatim string</value>
  </data>
  <data name="Use_expression_body_for_methods" xml:space="preserve">
    <value>Use expression body for methods</value>
  </data>
  <data name="Use_block_body_for_methods" xml:space="preserve">
    <value>Use block body for methods</value>
  </data>
  <data name="Use_block_body_for_accessors" xml:space="preserve">
    <value>Use block body for accessors</value>
  </data>
  <data name="Use_block_body_for_constructors" xml:space="preserve">
    <value>Use block body for constructors</value>
  </data>
  <data name="Use_block_body_for_indexers" xml:space="preserve">
    <value>Use block body for indexers</value>
  </data>
  <data name="Use_block_body_for_operators" xml:space="preserve">
    <value>Use block body for operators</value>
  </data>
  <data name="Use_block_body_for_properties" xml:space="preserve">
    <value>Use block body for properties</value>
  </data>
  <data name="Use_expression_body_for_accessors" xml:space="preserve">
    <value>Use expression body for accessors</value>
  </data>
  <data name="Use_expression_body_for_constructors" xml:space="preserve">
    <value>Use expression body for constructors</value>
  </data>
  <data name="Use_expression_body_for_indexers" xml:space="preserve">
    <value>Use expression body for indexers</value>
  </data>
  <data name="Use_expression_body_for_operators" xml:space="preserve">
    <value>Use expression body for operators</value>
  </data>
  <data name="Use_expression_body_for_properties" xml:space="preserve">
    <value>Use expression body for properties</value>
  </data>
  <data name="Fix_typo_0" xml:space="preserve">
    <value>Fix typo '{0}'</value>
  </data>
  <data name="Fully_qualify_0" xml:space="preserve">
    <value>Fully qualify '{0}'</value>
  </data>
  <data name="Remove_reference_to_0" xml:space="preserve">
    <value>Remove reference to '{0}'.</value>
  </data>
  <data name="Keywords" xml:space="preserve">
    <value>Keywords</value>
  </data>
  <data name="Snippets" xml:space="preserve">
    <value>Snippets</value>
  </data>
  <data name="All_lowercase" xml:space="preserve">
    <value>All lowercase</value>
  </data>
  <data name="All_uppercase" xml:space="preserve">
    <value>All uppercase</value>
  </data>
  <data name="First_word_capitalized" xml:space="preserve">
    <value>First word capitalized</value>
  </data>
  <data name="Pascal_Case" xml:space="preserve">
    <value>Pascal Case</value>
  </data>
  <data name="Collection_initialization_can_be_simplified" xml:space="preserve">
    <value>Collection initialization can be simplified</value>
  </data>
  <data name="Use_coalesce_expression" xml:space="preserve">
    <value>Use coalesce expression</value>
  </data>
  <data name="Use_null_propagation" xml:space="preserve">
    <value>Use null propagation</value>
  </data>
  <data name="Variable_declaration_can_be_inlined" xml:space="preserve">
    <value>Variable declaration can be inlined</value>
  </data>
  <data name="Null_check_can_be_simplified" xml:space="preserve">
    <value>Null check can be simplified</value>
  </data>
  <data name="Simplify_collection_initialization" xml:space="preserve">
    <value>Simplify collection initialization</value>
  </data>
  <data name="Simplify_object_initialization" xml:space="preserve">
    <value>Simplify object initialization</value>
  </data>
  <data name="Prefer_explicitly_provided_tuple_element_name" xml:space="preserve">
    <value>Prefer explicitly provided tuple element name</value>
  </data>
  <data name="Use_explicitly_provided_tuple_name" xml:space="preserve">
    <value>Use explicitly provided tuple name</value>
  </data>
  <data name="Remove_document_0" xml:space="preserve">
    <value>Remove document '{0}'</value>
  </data>
  <data name="Add_document_0" xml:space="preserve">
    <value>Add document '{0}'</value>
  </data>
  <data name="Add_argument_name_0" xml:space="preserve">
    <value>Add argument name '{0}'</value>
  </data>
  <data name="Add_tuple_element_name_0" xml:space="preserve">
    <value>Add tuple element name '{0}'</value>
  </data>
  <data name="Take_0" xml:space="preserve">
    <value>Take '{0}'</value>
  </data>
  <data name="Take_both" xml:space="preserve">
    <value>Take both</value>
  </data>
  <data name="Take_bottom" xml:space="preserve">
    <value>Take bottom</value>
  </data>
  <data name="Take_top" xml:space="preserve">
    <value>Take top</value>
  </data>
  <data name="Remove_unused_variable" xml:space="preserve">
    <value>Remove unused variable</value>
  </data>
  <data name="Convert_to_binary" xml:space="preserve">
    <value>Convert to binary</value>
  </data>
  <data name="Convert_to_decimal" xml:space="preserve">
    <value>Convert to decimal</value>
  </data>
  <data name="Convert_to_hex" xml:space="preserve">
    <value>Convert to hex</value>
  </data>
  <data name="Separate_thousands" xml:space="preserve">
    <value>Separate thousands</value>
  </data>
  <data name="Separate_words" xml:space="preserve">
    <value>Separate words</value>
  </data>
  <data name="Separate_nibbles" xml:space="preserve">
    <value>Separate nibbles</value>
  </data>
  <data name="Remove_separators" xml:space="preserve">
    <value>Remove separators</value>
  </data>
  <data name="Add_parameter_to_0" xml:space="preserve">
    <value>Add parameter to '{0}'</value>
  </data>
  <data name="Add_parameter_to_0_and_overrides_implementations" xml:space="preserve">
    <value>Add parameter to '{0}' (and overrides/implementations)</value>
  </data>
  <data name="Add_to_0" xml:space="preserve">
    <value>Add to '{0}'</value>
  </data>
  <data name="Related_method_signatures_found_in_metadata_will_not_be_updated" xml:space="preserve">
    <value>Related method signatures found in metadata will not be updated.</value>
  </data>
  <data name="Generate_constructor" xml:space="preserve">
    <value>Generate constructor...</value>
  </data>
  <data name="Pick_members_to_be_used_as_constructor_parameters" xml:space="preserve">
    <value>Pick members to be used as constructor parameters</value>
  </data>
  <data name="Pick_members_to_be_used_in_Equals_GetHashCode" xml:space="preserve">
    <value>Pick members to be used in Equals/GetHashCode</value>
  </data>
  <data name="Changes_to_expression_trees_may_result_in_behavior_changes_at_runtime" xml:space="preserve">
    <value>Changes to expression trees may result in behavior changes at runtime</value>
  </data>
  <data name="Generate_overrides" xml:space="preserve">
    <value>Generate overrides...</value>
  </data>
  <data name="Pick_members_to_override" xml:space="preserve">
    <value>Pick members to override</value>
  </data>
  <data name="Add_null_check" xml:space="preserve">
    <value>Add null check</value>
  </data>
  <data name="Add_string_IsNullOrEmpty_check" xml:space="preserve">
    <value>Add 'string.IsNullOrEmpty' check</value>
  </data>
  <data name="Add_string_IsNullOrWhiteSpace_check" xml:space="preserve">
    <value>Add 'string.IsNullOrWhiteSpace' check</value>
  </data>
  <data name="Create_and_initialize_field_0" xml:space="preserve">
    <value>Create and initialize field '{0}'</value>
  </data>
  <data name="Create_and_initialize_property_0" xml:space="preserve">
    <value>Create and initialize property '{0}'</value>
  </data>
  <data name="Initialize_field_0" xml:space="preserve">
    <value>Initialize field '{0}'</value>
  </data>
  <data name="Initialize_property_0" xml:space="preserve">
    <value>Initialize property '{0}'</value>
  </data>
  <data name="Add_null_checks" xml:space="preserve">
    <value>Add null checks</value>
  </data>
  <data name="Generate_operators" xml:space="preserve">
    <value>Generate operators</value>
  </data>
  <data name="Implement_0" xml:space="preserve">
    <value>Implement {0}</value>
  </data>
  <data name="Simplify_default_expression" xml:space="preserve">
    <value>Simplify 'default' expression</value>
  </data>
  <data name="default_expression_can_be_simplified" xml:space="preserve">
    <value>'default' expression can be simplified</value>
  </data>
  <data name="Format_string_contains_invalid_placeholder" xml:space="preserve">
    <value>Format string contains invalid placeholder</value>
  </data>
  <data name="Invalid_format_string" xml:space="preserve">
    <value>Invalid format string</value>
  </data>
  <data name="Use_inferred_member_name" xml:space="preserve">
    <value>Use inferred member name</value>
  </data>
  <data name="Member_name_can_be_simplified" xml:space="preserve">
    <value>Member name can be simplified</value>
  </data>
  <data name="Reported_diagnostic_0_has_a_source_location_in_file_1_which_is_not_part_of_the_compilation_being_analyzed" xml:space="preserve">
    <value>Reported diagnostic '{0}' has a source location in file '{1}', which is not part of the compilation being analyzed.</value>
  </data>
  <data name="Reported_diagnostic_0_has_a_source_location_1_in_file_2_which_is_outside_of_the_given_file" xml:space="preserve">
    <value>Reported diagnostic '{0}' has a source location '{1}' in file '{2}', which is outside of the given file.</value>
  </data>
  <data name="Unreachable_code_detected" xml:space="preserve">
    <value>Unreachable code detected</value>
  </data>
  <data name="Remove_unreachable_code" xml:space="preserve">
    <value>Remove unreachable code</value>
  </data>
  <data name="Modifiers_are_not_ordered" xml:space="preserve">
    <value>Modifiers are not ordered</value>
  </data>
  <data name="Order_modifiers" xml:space="preserve">
    <value>Order modifiers</value>
  </data>
  <data name="in_0_project_1" xml:space="preserve">
    <value>in {0} (project {1})</value>
  </data>
  <data name="Accessibility_modifiers_required" xml:space="preserve">
    <value>Accessibility modifiers required</value>
  </data>
  <data name="Add_accessibility_modifiers" xml:space="preserve">
    <value>Add accessibility modifiers</value>
  </data>
  <data name="Use_local_function" xml:space="preserve">
    <value>Use local function</value>
  </data>
  <data name="Warning_colon_Declaration_changes_scope_and_may_change_meaning" xml:space="preserve">
    <value>Warning: Declaration changes scope and may change meaning.</value>
  </data>
  <data name="Move_declaration_near_reference" xml:space="preserve">
    <value>Move declaration near reference</value>
  </data>
  <data name="Convert_to_full_property" xml:space="preserve">
    <value>Convert to full property</value>
  </data>
  <data name="Generate_constructor_in_0_without_fields" xml:space="preserve">
    <value>Generate constructor in '{0}' (without fields)</value>
  </data>
  <data name="Parentheses_can_be_removed" xml:space="preserve">
    <value>Parentheses can be removed</value>
  </data>
  <data name="Remove_unnecessary_parentheses" xml:space="preserve">
    <value>Remove unnecessary parentheses</value>
  </data>
  <data name="Add_file_banner" xml:space="preserve">
    <value>Add file banner</value>
  </data>
  <data name="Warning_Method_overrides_symbol_from_metadata" xml:space="preserve">
    <value>Warning: Method overrides symbol from metadata</value>
  </data>
  <data name="Add_parentheses_for_clarity" xml:space="preserve">
    <value>Add parentheses for clarity</value>
  </data>
  <data name="Parentheses_should_be_added_for_clarity" xml:space="preserve">
    <value>Parentheses should be added for clarity</value>
  </data>
  <data name="Use_0" xml:space="preserve">
    <value>Use {0}</value>
  </data>
  <data name="Switching_between_lambda_and_local_function_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Switching between a lambda and a local function will prevent the debug session from continuing.</value>
  </data>
  <data name="Deconstruct_variable_declaration" xml:space="preserve">
    <value>Deconstruct variable declaration</value>
  </data>
  <data name="Variable_declaration_can_be_deconstructed" xml:space="preserve">
    <value>Variable declaration can be deconstructed</value>
  </data>
  <data name="Add_argument_name_0_including_trailing_arguments" xml:space="preserve">
    <value>Add argument name '{0}' (including trailing arguments)</value>
  </data>
  <data name="Using_readonly_structs_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Using readonly structs will prevent the debug session from continuing.</value>
  </data>
  <data name="Using_ref_structs_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Using ref structs will prevent the debug session from continuing.</value>
  </data>
  <data name="Using_readonly_references_will_prevent_the_debug_session_from_continuing" xml:space="preserve">
    <value>Using readonly references will prevent the debug session from continuing.</value>
  </data>
  <data name="local_function" xml:space="preserve">
    <value>local function</value>
  </data>
  <data name="indexer_" xml:space="preserve">
    <value>indexer</value>
  </data>
  <data name="Alias_ambiguous_type_0" xml:space="preserve">
    <value>Alias ambiguous type '{0}'</value>
  </data>
  <data name="Warning_colon_Collection_was_modified_during_iteration" xml:space="preserve">
    <value>Warning: Collection was modified during iteration.</value>
  </data>
  <data name="Warning_colon_Iteration_variable_crossed_function_boundary" xml:space="preserve">
    <value>Warning: Iteration variable crossed function boundary.</value>
  </data>
  <data name="Warning_colon_Collection_may_be_modified_during_iteration" xml:space="preserve">
    <value>Warning: Collection may be modified during iteration.</value>
  </data>
  <data name="Add_readonly_modifier" xml:space="preserve">
    <value>Add readonly modifier</value>
  </data>
  <data name="Make_field_readonly" xml:space="preserve">
    <value>Make field readonly</value>
  </data>
  <data name="Convert_to_conditional_expression" xml:space="preserve">
    <value>Convert to conditional expression</value>
  </data>
  <data name="Convert_to_linq" xml:space="preserve">
    <value>Convert to LINQ</value>
  </data>
  <data name="Convert_to_tuple" xml:space="preserve">
    <value>Convert to tuple</value>
  </data>
  <data name="Convert_to_class" xml:space="preserve">
    <value>Convert to class</value>
  </data>
  <data name="Convert_to_struct" xml:space="preserve">
    <value>Convert to struct</value>
  </data>
  <data name="updating_usages_in_containing_member" xml:space="preserve">
    <value>updating usages in containing member</value>
  </data>
  <data name="updating_usages_in_containing_project" xml:space="preserve">
    <value>updating usages in containing project</value>
  </data>
  <data name="updating_usages_in_containing_type" xml:space="preserve">
    <value>updating usages in containing type</value>
  </data>
  <data name="updating_usages_in_dependent_projects" xml:space="preserve">
    <value>updating usages in dependent projects</value>
  </data>
  <data name="Formatting_document" xml:space="preserve">
    <value>Formatting document</value>
  </data>
  <data name="Add_member_name" xml:space="preserve">
    <value>Add member name</value>
  </data>
  <data name="Use_block_body_for_lambda_expressions" xml:space="preserve">
    <value>Use block body for lambda expressions</value>
  </data>
  <data name="Use_expression_body_for_lambda_expressions" xml:space="preserve">
    <value>Use expression body for lambda expressions</value>
  </data>
  <data name="Convert_to_linq_call_form" xml:space="preserve">
    <value>Convert to LINQ (call form)</value>
  </data>
  <data name="Adding_method_with_explicit_interface_specifier_will_prevernt_the_debug_session_from_continuing" xml:space="preserve">
    <value>Adding a method with an explicit interface specifier will prevent the debug session from continuing.</value>
  </data>
  <data name="Remove_unused_member" xml:space="preserve">
    <value>Remove unused member</value>
  </data>
  <data name="Private_member_0_is_unused" xml:space="preserve">
    <value>Private member '{0}' is unused.</value>
  </data>
  <data name="Remove_unused_private_members" xml:space="preserve">
    <value>Remove unused private members</value>
  </data>
  <data name="Remove_unread_private_members" xml:space="preserve">
    <value>Remove unread private members</value>
  </data>
  <data name="Private_member_0_can_be_removed_as_the_value_assigned_to_it_is_never_read" xml:space="preserve">
    <value>Private member '{0}' can be removed as the value assigned to it is never read.</value>
  </data>
  <data name="Private_method_0_can_be_removed_as_it_is_never_invoked" xml:space="preserve">
    <value>Private method '{0}' can be removed as it is never invoked.</value>
  </data>
  <data name="Private_property_0_can_be_converted_to_a_method_as_its_get_accessor_is_never_invoked" xml:space="preserve">
    <value>Private property '{0}' can be converted to a method as its get accessor is never invoked.</value>
  </data>
  <data name="Code_Quality" xml:space="preserve">
    <value>Code Quality</value>
  </data>
  <data name="Modifying_source_file_will_prevent_the_debug_session_from_continuing_due_to_internal_error" xml:space="preserve">
    <value>Modifying source file {0} will prevent the debug session from continuing due to internal error: {1}.</value>
  </data>
  <data name="Change_namespace_to_0" xml:space="preserve">
    <value>Change namespace to '{0}'</value>
  </data>
  <data name="Move_file_to_0" xml:space="preserve">
    <value>Move file to '{0}'</value>
  </data>
  <data name="Move_file_to_project_root_folder" xml:space="preserve">
    <value>Move file to project root folder</value>
  </data>
  <data name="Move_to_namespace" xml:space="preserve">
    <value>Move to namespace...</value>
  </data>
  <data name="Change_to_global_namespace" xml:space="preserve">
    <value>Change to global namespace</value>
  </data>
  <data name="Warning_colon_changing_namespace_may_produce_invalid_code_and_change_code_meaning" xml:space="preserve">
    <value>Warning: Changing namespace may produce invalid code and change code meaning.</value>
  </data>
  <data name="Use_compound_assignment" xml:space="preserve">
    <value>Use compound assignment</value>
  </data>
  <data name="Invert_conditional" xml:space="preserve">
    <value>Invert conditional</value>
  </data>
  <data name="Replace_0_with_1" xml:space="preserve">
    <value>Replace '{0}' with '{1}' </value>
  </data>
  <data name="Align_wrapped_parameters" xml:space="preserve">
    <value>Align wrapped parameters</value>
  </data>
  <data name="Indent_all_parameters" xml:space="preserve">
    <value>Indent all parameters</value>
  </data>
  <data name="Indent_wrapped_parameters" xml:space="preserve">
    <value>Indent wrapped parameters</value>
  </data>
  <data name="Unwrap_all_parameters" xml:space="preserve">
    <value>Unwrap all parameters</value>
  </data>
  <data name="Unwrap_and_indent_all_parameters" xml:space="preserve">
    <value>Unwrap and indent all parameters</value>
  </data>
  <data name="Wrap_every_parameter" xml:space="preserve">
    <value>Wrap every parameter</value>
  </data>
  <data name="Wrap_long_parameter_list" xml:space="preserve">
    <value>Wrap long parameter list</value>
  </data>
  <data name="Unwrap_parameter_list" xml:space="preserve">
    <value>Unwrap parameter list</value>
  </data>
  <data name="Align_wrapped_arguments" xml:space="preserve">
    <value>Align wrapped arguments</value>
  </data>
  <data name="Indent_all_arguments" xml:space="preserve">
    <value>Indent all arguments</value>
  </data>
  <data name="Indent_wrapped_arguments" xml:space="preserve">
    <value>Indent wrapped arguments</value>
  </data>
  <data name="Unwrap_all_arguments" xml:space="preserve">
    <value>Unwrap all arguments</value>
  </data>
  <data name="Unwrap_and_indent_all_arguments" xml:space="preserve">
    <value>Unwrap and indent all arguments</value>
  </data>
  <data name="Wrap_every_argument" xml:space="preserve">
    <value>Wrap every argument</value>
  </data>
  <data name="Wrap_long_argument_list" xml:space="preserve">
    <value>Wrap long argument list</value>
  </data>
  <data name="Unwrap_argument_list" xml:space="preserve">
    <value>Unwrap argument list</value>
  </data>
  <data name="Introduce_constant" xml:space="preserve">
    <value>Introduce constant</value>
  </data>
  <data name="Introduce_field" xml:space="preserve">
    <value>Introduce field</value>
  </data>
  <data name="Introduce_local" xml:space="preserve">
    <value>Introduce local</value>
  </data>
  <data name="Introduce_query_variable" xml:space="preserve">
    <value>Introduce query variable</value>
  </data>
  <data name="Failed_to_analyze_data_flow_for_0" xml:space="preserve">
    <value>Failed to analyze data-flow for: {0}</value>
  </data>
  <data name="Expression_value_is_never_used" xml:space="preserve">
    <value>Expression value is never used</value>
  </data>
  <data name="Unnecessary_assignment_of_a_value_to_0" xml:space="preserve">
    <value>Unnecessary assignment of a value to '{0}'</value>
  </data>
  <data name="Unnecessary_assignment_of_a_value" xml:space="preserve">
    <value>Unnecessary assignment of a value</value>
  </data>
  <data name="Avoid_unnecessary_value_assignments_in_your_code_as_these_likely_indicate_redundant_value_computations_If_the_value_computation_is_not_redundant_and_you_intend_to_retain_the_assignmentcomma_then_change_the_assignment_target_to_a_local_variable_whose_name_starts_with_an_underscore_and_is_optionally_followed_by_an_integercomma_such_as___comma__1_comma__2_comma_etc_These_are_treated_as_special_discard_symbol_names" xml:space="preserve">
    <value>Avoid unnecessary value assignments in your code, as these likely indicate redundant value computations. If the value computation is not redundant and you intend to retain the assignment, then change the assignment target to a local variable whose name starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names.</value>
  </data>
  <data name="Use_discarded_local" xml:space="preserve">
    <value>Use discarded local</value>
  </data>
  <data name="Use_discard_underscore" xml:space="preserve">
    <value>Use discard '_'</value>
  </data>
  <data name="Remove_redundant_assignment" xml:space="preserve">
    <value>Remove redundant assignment</value>
  </data>
  <data name="Remove_unused_parameter" xml:space="preserve">
    <value>Remove unused parameter</value>
  </data>
  <data name="Remove_unused_parameter_0" xml:space="preserve">
    <value>Remove unused parameter '{0}'</value>
  </data>
  <data name="Avoid_unused_paramereters_in_your_code_If_the_parameter_cannot_be_removed_then_change_its_name_so_it_starts_with_an_underscore_and_is_optionally_followed_by_an_integer_such_as__comma__1_comma__2_etc_These_are_treated_as_special_discard_symbol_names" xml:space="preserve">
    <value>Avoid unused paramereters in your code. If the parameter cannot be removed, then change its name so it starts with an underscore and is optionally followed by an integer, such as '_', '_1', '_2', etc. These are treated as special discard symbol names.</value>
  </data>
  <data name="Fix_formatting" xml:space="preserve">
    <value>Fix formatting</value>
  </data>
  <data name="Split_into_nested_0_statements" xml:space="preserve">
    <value>Split into nested '{0}' statements</value>
  </data>
  <data name="Merge_with_outer_0_statement" xml:space="preserve">
    <value>Merge with outer '{0}' statement</value>
  </data>
  <data name="Split_into_consecutive_0_statements" xml:space="preserve">
    <value>Split into consecutive '{0}' statements</value>
  </data>
  <data name="Merge_with_previous_0_statement" xml:space="preserve">
    <value>Merge with previous '{0}' statement</value>
  </data>
  <data name="Indexing_can_be_simplified" xml:space="preserve">
    <value>Indexing can be simplified</value>
  </data>
  <data name="Use_index_operator" xml:space="preserve">
    <value>Use index operator</value>
  </data>
  <data name="Use_range_operator" xml:space="preserve">
    <value>Use range operator</value>
  </data>
  <data name="_0_can_be_simplified" xml:space="preserve">
    <value>{0} can be simplified</value>
  </data>
  <data name="Unwrap_expression" xml:space="preserve">
    <value>Unwrap expression</value>
  </data>
  <data name="Wrap_expression" xml:space="preserve">
    <value>Wrap expression</value>
  </data>
  <data name="Wrapping" xml:space="preserve">
    <value>Wrapping</value>
  </data>
  <data name="Remove_unused_parameter_0_if_it_is_not_part_of_a_shipped_public_API" xml:space="preserve">
    <value>Remove unused parameter '{0}' if it is not part of a shipped public API</value>
  </data>
  <data name="Remove_unused_parameter_0_if_it_is_not_part_of_a_shipped_public_API_its_initial_value_is_never_used" xml:space="preserve">
    <value>Remove unused parameter '{0}' if it is not part of a shipped public API, its initial value is never used</value>
  </data>
  <data name="Remove_unused_parameter_0_its_initial_value_is_never_used" xml:space="preserve">
    <value>Remove unused parameter '{0}', its initial value is never used</value>
  </data>
  <data name="Merge_with_nested_0_statement" xml:space="preserve">
    <value>Merge with nested '{0}' statement</value>
  </data>
  <data name="Merge_with_next_0_statement" xml:space="preserve">
    <value>Merge with next '{0}' statement</value>
  </data>
  <data name="Pull_0_up" xml:space="preserve">
    <value>Pull '{0}' up</value>
  </data>
  <data name="Pull_members_up_to_base_type" xml:space="preserve">
    <value>Pull members up to base type...</value>
  </data>
  <data name="Use_block_body_for_local_functions" xml:space="preserve">
    <value>Use block body for local functions</value>
  </data>
  <data name="Use_expression_body_for_local_functions" xml:space="preserve">
    <value>Use expression body for local functions</value>
  </data>
  <data name="Pull_0_up_to_1" xml:space="preserve">
    <value>Pull '{0}' up to '{1}'</value>
  </data>
  <data name="Wrap_and_align_expression" xml:space="preserve">
    <value>Wrap and align expression</value>
  </data>
  <data name="Local_function_can_be_made_static" xml:space="preserve">
    <value>Local function can be made static</value>
  </data>
  <data name="Make_local_function_static" xml:space="preserve">
    <value>Make local function 'static'</value>
  </data>
  <data name="Use_simple_using_statement" xml:space="preserve">
    <value>Use simple 'using' statement</value>
  </data>
  <data name="using_statement_can_be_simplified" xml:space="preserve">
    <value>'using' statement can be simplified</value>
  </data>
  <data name="Make_readonly_fields_writable" xml:space="preserve">
    <value>Make readonly fields writable</value>
    <comment>{Locked="readonly"} "readonly" is C# keyword and should not be localized.</comment>
  </data>
  <data name="Move_contents_to_namespace" xml:space="preserve">
    <value>Move contents to namespace...</value>
  </data>
  <data name="Add_optional_parameter_to_constructor" xml:space="preserve">
    <value>Add optional parameter to constructor</value>
  </data>
  <data name="Add_parameter_to_constructor" xml:space="preserve">
    <value>Add parameter to constructor</value>
  </data>
  <data name="Target_type_matches" xml:space="preserve">
    <value>Target type matches</value>
  </data>
  <data name="Generate_parameter_0" xml:space="preserve">
    <value>Generate parameter '{0}'</value>
  </data>
  <data name="Generate_parameter_0_and_overrides_implementations" xml:space="preserve">
    <value>Generate parameter '{0}' (and overrides/implementations)</value>
  </data>
  <data name="in_Source_attribute" xml:space="preserve">
    <value>in Source (attribute)</value>
  </data>
  <data name="StreamMustSupportReadAndSeek" xml:space="preserve">
    <value>Stream must support read and seek operations.</value>
  </data>
  <data name="MethodMustReturnStreamThatSupportsReadAndSeek" xml:space="preserve">
    <value>{0} must return a stream that supports read and seek operations.</value>
  </data>
  <data name="Dispose_objects_before_losing_scope" xml:space="preserve">
    <value>Dispose objects before losing scope</value>
  </data>
  <data name="Disposable_object_created_by_0_is_never_disposed" xml:space="preserve">
    <value>Disposable object created by '{0}' is never disposed</value>
  </data>
  <data name="Use_recommended_dispose_pattern" xml:space="preserve">
    <value>Use recommended dispose pattern</value>
  </data>
  <data name="Use_recommended_dispose_pattern_to_ensure_that_object_created_by_0_is_disposed_on_all_paths_using_statement_declaration_or_try_finally" xml:space="preserve">
    <value>Use recommended dispose pattern to ensure that object created by '{0}' is disposed on all paths: using statement/declaration or try/finally</value>
    <comment>{Locked="using"}{Locked="try"}{Locked="finally"} "using", "try" and "finally" are C# keywords and should not be localized.</comment>
  </data>
  <data name="UseRecommendedDisposePatternDescription" xml:space="preserve">
    <value>Use recommended dispose pattern to ensure that locally scoped disposable objects are disposed on all paths. If possible, wrap the creation within a 'using' statement or a 'using' declaration. Otherwise, use a try-finally pattern, with a dedicated local variable declared before the try region and an unconditional Dispose invocation on non-null value in the 'finally' region, say 'x?.Dispose()'. If the object is explicitly disposed within the try region or the dispose ownership is transfered to another object or method, assign 'null' to the local variable just after such an operation to prevent double dispose in 'finally'</value>
  </data>
  <data name="Disposable_fields_should_be_disposed" xml:space="preserve">
    <value>Disposable fields should be disposed</value>
  </data>
  <data name="Disposable_field_0_is_never_disposed" xml:space="preserve">
    <value>Disposable field '{0}' is never disposed</value>
  </data>
  <data name="DisposableFieldsShouldBeDisposedDescription" xml:space="preserve">
    <value>A type that implements System.IDisposable declares fields that are of types that also implement IDisposable. The Dispose method of the field is not called by the Dispose method of the declaring type. To fix a violation of this rule, call Dispose on fields that are of types that implement IDisposable if you are responsible for allocating and releasing the unmanaged resources held by the field.</value>
  </data>
  <data name="Alternation_conditions_cannot_be_comments" xml:space="preserve">
    <value>Alternation conditions cannot be comments</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: a|(?#b)</comment>
  </data>
  <data name="Alternation_conditions_do_not_capture_and_cannot_be_named" xml:space="preserve">
    <value>Alternation conditions do not capture and cannot be named</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(?'x'))</comment>
  </data>
  <data name="A_subtraction_must_be_the_last_element_in_a_character_class" xml:space="preserve">
    <value>A subtraction must be the last element in a character class</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-[b]-c]</comment>
  </data>
  <data name="Cannot_include_class_0_in_character_range" xml:space="preserve">
    <value>Cannot include class \{0} in character range</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-\w]. {0} is the invalid class (\w here)</comment>
  </data>
  <data name="Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue" xml:space="preserve">
    <value>Capture group numbers must be less than or equal to Int32.MaxValue</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{2147483648}</comment>
  </data>
  <data name="Capture_number_cannot_be_zero" xml:space="preserve">
    <value>Capture number cannot be zero</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;0&gt;a)</comment>
  </data>
  <data name="Illegal_backslash_at_end_of_pattern" xml:space="preserve">
    <value>Illegal \ at end of pattern</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \</comment>
  </data>
  <data name="Illegal_x_y_with_x_less_than_y" xml:space="preserve">
    <value>Illegal {x,y} with x &gt; y</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{1,0}</comment>
  </data>
  <data name="Incomplete_character_escape" xml:space="preserve">
    <value>Incomplete \p{X} character escape</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{ Cc }</comment>
  </data>
  <data name="Insufficient_hexadecimal_digits" xml:space="preserve">
    <value>Insufficient hexadecimal digits</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \x</comment>
  </data>
  <data name="Invalid_group_name_Group_names_must_begin_with_a_word_character" xml:space="preserve">
    <value>Invalid group name: Group names must begin with a word character</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;a &gt;a)</comment>
  </data>
  <data name="Malformed" xml:space="preserve">
    <value>malformed</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0</comment>
  </data>
  <data name="Malformed_character_escape" xml:space="preserve">
    <value>Malformed \p{X} character escape</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p {Cc}</comment>
  </data>
  <data name="Malformed_named_back_reference" xml:space="preserve">
    <value>Malformed \k&lt;...&gt; named back reference</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k'</comment>
  </data>
  <data name="Missing_control_character" xml:space="preserve">
    <value>Missing control character</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \c</comment>
  </data>
  <data name="Nested_quantifier_0" xml:space="preserve">
    <value>Nested quantifier {0}</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: a**. In this case {0} will be '*', the extra unnecessary quantifier.</comment>
  </data>
  <data name="Not_enough_close_parens" xml:space="preserve">
    <value>Not enough )'s</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (a</comment>
  </data>
  <data name="Quantifier_x_y_following_nothing" xml:space="preserve">
    <value>Quantifier {x,y} following nothing</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: *</comment>
  </data>
  <data name="Reference_to_undefined_group" xml:space="preserve">
    <value>reference to undefined group</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(1))</comment>
  </data>
  <data name="Reference_to_undefined_group_name_0" xml:space="preserve">
    <value>Reference to undefined group name {0}</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k&lt;a&gt;. Here, {0} will be the name of the undefined group ('a')</comment>
  </data>
  <data name="Reference_to_undefined_group_number_0" xml:space="preserve">
    <value>Reference to undefined group number {0}</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;-1&gt;). Here, {0} will be the number of the undefined group ('1')</comment>
  </data>
  <data name="Too_many_bars_in_conditional_grouping" xml:space="preserve">
    <value>Too many | in (?()|)</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0)a|b|)</comment>
  </data>
  <data name="Too_many_close_parens" xml:space="preserve">
    <value>Too many )'s</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: )</comment>
  </data>
  <data name="Unknown_property" xml:space="preserve">
    <value>Unknown property</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{}</comment>
  </data>
  <data name="Unknown_property_0" xml:space="preserve">
    <value>Unknown property '{0}'</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{xxx}. Here, {0} will be the name of the unknown property ('xxx')</comment>
  </data>
  <data name="Unrecognized_control_character" xml:space="preserve">
    <value>Unrecognized control character</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: [\c]</comment>
  </data>
  <data name="Unrecognized_escape_sequence_0" xml:space="preserve">
    <value>Unrecognized escape sequence \{0}</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \m. Here, {0} will be the unrecognized character ('m')</comment>
  </data>
  <data name="Unrecognized_grouping_construct" xml:space="preserve">
    <value>Unrecognized grouping construct</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;</comment>
  </data>
  <data name="Unterminated_character_class_set" xml:space="preserve">
    <value>Unterminated [] set</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: [</comment>
  </data>
  <data name="Unterminated_regex_comment" xml:space="preserve">
    <value>Unterminated (?#...) comment</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?#</comment>
  </data>
  <data name="x_y_range_in_reverse_order" xml:space="preserve">
    <value>[x-y] range in reverse order</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: [b-a]</comment>
  </data>
  <data name="Regex_issue_0" xml:space="preserve">
    <value>Regex issue: {0}</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. {0} will be the actual text of one of the above Regular Expression errors.</comment>
  </data>
  <data name="Regex_number_decimal_digit" xml:space="preserve">
    <value>number, decimal digit</value>
  </data>
  <data name="Regex_number_letter" xml:space="preserve">
    <value>number, letter</value>
  </data>
  <data name="Regex_number_other" xml:space="preserve">
    <value>number, other</value>
  </data>
  <data name="Regex_other_control" xml:space="preserve">
    <value>other, control</value>
  </data>
  <data name="Regex_other_format" xml:space="preserve">
    <value>other, format</value>
  </data>
  <data name="Regex_other_not_assigned" xml:space="preserve">
    <value>other, not assigned</value>
  </data>
  <data name="Regex_other_private_use" xml:space="preserve">
    <value>other, private use</value>
  </data>
  <data name="Regex_other_surrogate" xml:space="preserve">
    <value>other, surrogate</value>
  </data>
  <data name="Regex_punctuation_close" xml:space="preserve">
    <value>punctuation, close</value>
  </data>
  <data name="Regex_punctuation_connector" xml:space="preserve">
    <value>punctuation, connector</value>
  </data>
  <data name="Regex_punctuation_dash" xml:space="preserve">
    <value>punctuation, dash</value>
  </data>
  <data name="Regex_punctuation_final_quote" xml:space="preserve">
    <value>punctuation, final quote</value>
  </data>
  <data name="Regex_punctuation_initial_quote" xml:space="preserve">
    <value>punctuation, initial quote</value>
  </data>
  <data name="Regex_punctuation_open" xml:space="preserve">
    <value>punctuation, open</value>
  </data>
  <data name="Regex_punctuation_other" xml:space="preserve">
    <value>punctuation, other</value>
  </data>
  <data name="Regex_separator_line" xml:space="preserve">
    <value>separator, line</value>
  </data>
  <data name="Regex_separator_paragraph" xml:space="preserve">
    <value>separator, paragraph</value>
  </data>
  <data name="Regex_separator_space" xml:space="preserve">
    <value>separator, space</value>
  </data>
  <data name="Regex_symbol_currency" xml:space="preserve">
    <value>symbol, currency</value>
  </data>
  <data name="Regex_symbol_math" xml:space="preserve">
    <value>symbol, math</value>
  </data>
  <data name="Regex_symbol_modifier" xml:space="preserve">
    <value>symbol, modifier</value>
  </data>
  <data name="Regex_symbol_other" xml:space="preserve">
    <value>symbol, other</value>
  </data>
  <data name="Regex_letter_lowercase" xml:space="preserve">
    <value>letter, lowercase</value>
  </data>
  <data name="Regex_letter_modifier" xml:space="preserve">
    <value>letter, modifier</value>
  </data>
  <data name="Regex_letter_other" xml:space="preserve">
    <value>letter, other</value>
  </data>
  <data name="Regex_letter_titlecase" xml:space="preserve">
    <value>letter, titlecase</value>
  </data>
  <data name="Regex_mark_enclosing" xml:space="preserve">
    <value>mark, enclosing</value>
  </data>
  <data name="Regex_mark_nonspacing" xml:space="preserve">
    <value>mark, nonspacing</value>
  </data>
  <data name="Regex_mark_spacing_combining" xml:space="preserve">
    <value>mark, spacing combining</value>
  </data>
  <data name="Regex_contiguous_matches_long" xml:space="preserve">
    <value>The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.</value>
  </data>
  <data name="Regex_contiguous_matches_short" xml:space="preserve">
    <value>contiguous matches</value>
  </data>
  <data name="Regex_end_of_string_only_long" xml:space="preserve">
    <value>The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, it can only match the last line of the input string.</value>
  </data>
  <data name="Regex_end_of_string_only_short" xml:space="preserve">
    <value>end of string only</value>
  </data>
  <data name="Regex_end_of_string_or_before_ending_newline_long" xml:space="preserve">
    <value>The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can only match the end of the last line, or the last line before \n.

The \Z anchor matches \n but does not match \r\n (the CR/LF character combination). To match CR/LF, include \r?\Z in the regular expression pattern.</value>
  </data>
  <data name="Regex_end_of_string_or_before_ending_newline_short" xml:space="preserve">
    <value>end of string or before ending newline</value>
  </data>
  <data name="Regex_non_word_boundary_long" xml:space="preserve">
    <value>The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor.</value>
  </data>
  <data name="Regex_non_word_boundary_short" xml:space="preserve">
    <value>non-word boundary</value>
  </data>
  <data name="Regex_start_of_string_only_long" xml:space="preserve">
    <value>The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input string.</value>
  </data>
  <data name="Regex_start_of_string_only_short" xml:space="preserve">
    <value>start of string only</value>
  </data>
  <data name="Regex_word_boundary_long" xml:space="preserve">
    <value>The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore. The match may also occur on a word boundary at the beginning or end of the string.

The \b anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</value>
  </data>
  <data name="Regex_word_boundary_short" xml:space="preserve">
    <value>word boundary</value>
  </data>
  <data name="Regex_start_of_string_or_line_long" xml:space="preserve">
    <value>The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.</value>
  </data>
  <data name="Regex_start_of_string_or_line_short" xml:space="preserve">
    <value>start of string or line</value>
  </data>
  <data name="Regex_end_of_string_or_line_long" xml:space="preserve">
    <value>The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string. If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line.

The $ anchor matches \n but does not match \r\n (the combination of carriage return and newline characters, or CR/LF). To match the CR/LF character combination, include \r?$ in the regular expression pattern.</value>
  </data>
  <data name="Regex_end_of_string_or_line_short" xml:space="preserve">
    <value>end of string or line</value>
  </data>
  <data name="Regex_any_character_group_long" xml:space="preserve">
    <value>The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified by the 's' option, . matches any character.</value>
  </data>
  <data name="Regex_any_character_group_short" xml:space="preserve">
    <value>any character</value>
  </data>
  <data name="Regex_backspace_character_long" xml:space="preserve">
    <value>Matches a backspace character, \u0008</value>
  </data>
  <data name="Regex_backspace_character_short" xml:space="preserve">
    <value>backspace character</value>
  </data>
  <data name="Regex_bell_character_long" xml:space="preserve">
    <value>Matches a bell (alarm) character, \u0007</value>
  </data>
  <data name="Regex_bell_character_short" xml:space="preserve">
    <value>bell character</value>
  </data>
  <data name="Regex_carriage_return_character_long" xml:space="preserve">
    <value>Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n.</value>
  </data>
  <data name="Regex_carriage_return_character_short" xml:space="preserve">
    <value>carriage-return character</value>
  </data>
  <data name="Regex_control_character_long" xml:space="preserve">
    <value>Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C.</value>
  </data>
  <data name="Regex_control_character_short" xml:space="preserve">
    <value>control character</value>
  </data>
  <data name="Regex_decimal_digit_character_long" xml:space="preserve">
    <value>\d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.

If ECMAScript-compliant behavior is specified, \d is equivalent to [0-9]</value>
  </data>
  <data name="Regex_decimal_digit_character_short" xml:space="preserve">
    <value>decimal-digit character</value>
  </data>
  <data name="Regex_escape_character_long" xml:space="preserve">
    <value>Matches an escape character, \u001B</value>
  </data>
  <data name="Regex_escape_character_short" xml:space="preserve">
    <value>escape character</value>
  </data>
  <data name="Regex_form_feed_character_long" xml:space="preserve">
    <value>Matches a form-feed character, \u000C</value>
  </data>
  <data name="Regex_form_feed_character_short" xml:space="preserve">
    <value>form-feed character</value>
  </data>
  <data name="Regex_hexadecimal_escape_long" xml:space="preserve">
    <value>Matches an ASCII character, where ## is a two-digit hexadecimal character code.</value>
  </data>
  <data name="Regex_hexadecimal_escape_short" xml:space="preserve">
    <value>hexidecimal escape</value>
  </data>
  <data name="Regex_letter_uppercase" xml:space="preserve">
    <value>letter, uppercase</value>
  </data>
  <data name="Regex_matched_subexpression_long" xml:space="preserve">
    <value>This grouping construct captures a matched 'subexpression', where 'subexpression' is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one. The capture that is numbered zero is the text matched by the entire regular expression pattern.</value>
  </data>
  <data name="Regex_matched_subexpression_short" xml:space="preserve">
    <value>matched subexpression</value>
  </data>
  <data name="Regex_negative_character_group_long" xml:space="preserve">
    <value>A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters are specified individually.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</value>
  </data>
  <data name="Regex_negative_character_group_short" xml:space="preserve">
    <value>negative character group</value>
  </data>
  <data name="Regex_negative_character_range_long" xml:space="preserve">
    <value>A negative character range specifies a list of characters that must not appear in an input string for a match to occur. 'firstCharacter' is the character that begins the range, and 'lastCharacter' is the character that ends the range.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</value>
  </data>
  <data name="Regex_negative_character_range_short" xml:space="preserve">
    <value>negative character range</value>
  </data>
  <data name="Regex_negative_unicode_category_long" xml:space="preserve">
    <value>The regular expression construct \P{ name } matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.</value>
  </data>
  <data name="Regex_negative_unicode_category_short" xml:space="preserve">
    <value>negative unicode category</value>
  </data>
  <data name="Regex_new_line_character_long" xml:space="preserve">
    <value>Matches a new-line character, \u000A</value>
  </data>
  <data name="Regex_new_line_character_short" xml:space="preserve">
    <value>new-line character</value>
  </data>
  <data name="Regex_non_digit_character_long" xml:space="preserve">
    <value>\D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.

If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9]</value>
  </data>
  <data name="Regex_non_digit_character_short" xml:space="preserve">
    <value>non-digit character</value>
  </data>
  <data name="Regex_non_white_space_character_long" xml:space="preserve">
    <value>\S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.

If ECMAScript-compliant behavior is specified, \S is equivalent to [^ \f\n\r\t\v]</value>
  </data>
  <data name="Regex_non_white_space_character_short" xml:space="preserve">
    <value>non-white-space character</value>
  </data>
  <data name="Regex_non_word_character_long" xml:space="preserve">
    <value>\W matches any non-word character. It matches any character except for those in the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \W is equivalent to [^a-zA-Z_0-9]</value>
    <comment>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized. </comment>
  </data>
  <data name="Regex_non_word_character_short" xml:space="preserve">
    <value>non-word character</value>
  </data>
  <data name="Regex_positive_character_group_long" xml:space="preserve">
    <value>A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur.</value>
  </data>
  <data name="Regex_positive_character_group_short" xml:space="preserve">
    <value>positive character group</value>
  </data>
  <data name="Regex_positive_character_range_long" xml:space="preserve">
    <value>A positive character range specifies a range of characters, any one of which may appear in an input string for a match to occur.  'firstCharacter' is the character that begins the range and 'lastCharacter' is the character that ends the range. </value>
  </data>
  <data name="Regex_positive_character_range_short" xml:space="preserve">
    <value>positive character range</value>
  </data>
  <data name="Regex_subexpression" xml:space="preserve">
    <value>subexpression</value>
  </data>
  <data name="Regex_tab_character_long" xml:space="preserve">
    <value>Matches a tab character, \u0009</value>
  </data>
  <data name="Regex_tab_character_short" xml:space="preserve">
    <value>tab character</value>
  </data>
  <data name="Regex_unicode_category_long" xml:space="preserve">
    <value>The regular expression construct \p{ name } matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.</value>
  </data>
  <data name="Regex_unicode_category_short" xml:space="preserve">
    <value>unicode category</value>
  </data>
  <data name="Regex_unicode_escape_long" xml:space="preserve">
    <value>Matches a UTF-16 code unit whose value is #### hexadecimal.</value>
  </data>
  <data name="Regex_unicode_escape_short" xml:space="preserve">
    <value>unicode escape</value>
  </data>
  <data name="Regex_vertical_tab_character_long" xml:space="preserve">
    <value>Matches a vertical-tab character, \u000B</value>
  </data>
  <data name="Regex_vertical_tab_character_short" xml:space="preserve">
    <value>vertical-tab character</value>
  </data>
  <data name="Regex_white_space_character_long" xml:space="preserve">
    <value>\s matches any white-space character. It is equivalent to the following escape sequences and Unicode categories:

    \f	The form feed character, \u000C
    \n	The newline character, \u000A
    \r	The carriage return character, \u000D
    \t	The tab character, \u0009
    \v	The vertical tab character, \u000B
    \x85	The ellipsis or NEXT LINE (NEL) character (), \u0085
    \p{Z}	Matches any separator character

If ECMAScript-compliant behavior is specified, \s is equivalent to [ \f\n\r\t\v]</value>
  </data>
  <data name="Regex_white_space_character_short" xml:space="preserve">
    <value>white-space character</value>
  </data>
  <data name="Regex_word_character_long" xml:space="preserve">
    <value>\w matches any word character. A word character is a member of any of the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \w is equivalent to [a-zA-Z_0-9]</value>
    <comment>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized.</comment>
  </data>
  <data name="Regex_word_character_short" xml:space="preserve">
    <value>word character</value>
  </data>
  <data name="Regex_alternation_long" xml:space="preserve">
    <value>You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.</value>
  </data>
  <data name="Regex_alternation_short" xml:space="preserve">
    <value>alternation</value>
  </data>
  <data name="Regex_balancing_group_long" xml:space="preserve">
    <value>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.
    
'name1' is the current group (optional), 'name2' is a previously defined group, and 'subexpression' is any valid regular expression pattern. The balancing group definition deletes the definition of name2 and stores the interval between name2 and name1 in name1. If no name2 group is defined, the match backtracks. Because deleting the last definition of name2 reveals the previous definition of name2, this construct lets you use the stack of captures for group name2 as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.

The balancing group definition uses 'name2' as a stack. The beginning character of each nested construct is placed in the group and in its Group.Captures collection. When the closing character is matched, its corresponding opening character is removed from the group, and the Captures collection is decreased by one. After the opening and closing characters of all nested constructs have been matched, 'name1' is empty.</value>
  </data>
  <data name="Regex_balancing_group_short" xml:space="preserve">
    <value>balancing group</value>
  </data>
  <data name="Regex_comment" xml:space="preserve">
    <value>comment</value>
  </data>
  <data name="Regex_conditional_expression_match_long" xml:space="preserve">
    <value>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.

'expression' is the initial pattern to match, 'yes' is the pattern to match if expression is matched, and 'no' is the optional pattern to match if expression is not matched.</value>
  </data>
  <data name="Regex_conditional_expression_match_short" xml:space="preserve">
    <value>conditional expression match</value>
  </data>
  <data name="Regex_conditional_group_match_long" xml:space="preserve">
    <value>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.

'name' is the name (or number) of a capturing group, 'yes' is the expression to match if 'name' (or 'number') has a match, and 'no' is the optional expression to match if it does not.</value>
  </data>
  <data name="Regex_conditional_group_match_short" xml:space="preserve">
    <value>conditional group match</value>
  </data>
  <data name="Regex_end_of_line_comment_long" xml:space="preserve">
    <value>A number sign (#) marks an x-mode comment, which starts at the unescaped # character at the end of the regular expression pattern and continues until the end of the line. To use this construct, you must either enable the x option (through inline options) or supply the RegexOptions.IgnorePatternWhitespace value to the option parameter when instantiating the Regex object or calling a static Regex method.</value>
  </data>
  <data name="Regex_end_of_line_comment_short" xml:space="preserve">
    <value>end-of-line comment</value>
  </data>
  <data name="Regex_expression" xml:space="preserve">
    <value>expression</value>
  </data>
  <data name="Regex_group_options_long" xml:space="preserve">
    <value>This grouping construct applies or disables the specified options within a subexpression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly
	named or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</value>
  </data>
  <data name="Regex_group_options_short" xml:space="preserve">
    <value>group options</value>
  </data>
  <data name="Regex_inline_comment_long" xml:space="preserve">
    <value>The (?# comment) construct lets you include an inline comment in a regular expression. The regular expression engine does not use any part of the comment in pattern matching, although the comment is included in the string that is returned by the Regex.ToString method. The comment ends at the first closing parenthesis.</value>
  </data>
  <data name="Regex_inline_comment_short" xml:space="preserve">
    <value>inline comment</value>
  </data>
  <data name="Regex_name" xml:space="preserve">
    <value>name</value>
  </data>
  <data name="Regex_name1" xml:space="preserve">
    <value>name1</value>
  </data>
  <data name="Regex_name2" xml:space="preserve">
    <value>name2</value>
  </data>
  <data name="Regex_named_backreference_long" xml:space="preserve">
    <value>A named or numbered backreference.

'name' is the name of a capturing group defined in the regular expression pattern.</value>
  </data>
  <data name="Regex_named_backreference_short" xml:space="preserve">
    <value>named backreference</value>
  </data>
  <data name="Regex_named_matched_subexpression_long" xml:space="preserve">
    <value>Captures a matched subexpression and lets you access it by name or by number.

'name' is a valid group name, and 'subexpression' is any valid regular expression pattern. 'name' must not contain any punctuation characters and cannot begin with a number.

If the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the only way to capture a subexpression is to explicitly name capturing groups.</value>
  </data>
  <data name="Regex_named_matched_subexpression_short" xml:space="preserve">
    <value>named matched subexpression</value>
  </data>
  <data name="Regex_name_or_number" xml:space="preserve">
    <value>name-or-number</value>
  </data>
  <data name="Regex_no" xml:space="preserve">
    <value>no</value>
  </data>
  <data name="Regex_nonbacktracking_subexpression_long" xml:space="preserve">
    <value>This construct disables backtracking. The regular expression engine will match as many characters in the input string as it can. When no further match is possible, it will not backtrack to attempt alternate pattern matches. (That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)

This option is recommended if you know that backtracking will not succeed. Preventing the regular expression engine from performing unnecessary searching improves performance.</value>
  </data>
  <data name="Regex_nonbacktracking_subexpression_short" xml:space="preserve">
    <value>nonbacktracking subexpression</value>
  </data>
  <data name="Regex_noncapturing_group_long" xml:space="preserve">
    <value>This construct does not capture the substring that is matched by a subexpression:

The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.

If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</value>
  </data>
  <data name="Regex_noncapturing_group_short" xml:space="preserve">
    <value>noncapturing group</value>
  </data>
  <data name="Regex_numbered_backreference_long" xml:space="preserve">
    <value>A numbered backreference, where 'number' is the ordinal position of the capturing group in the regular expression. For example, \4 matches the contents of the fourth capturing group.

There is an ambiguity between octal escape codes (such as \16) and \number backreferences that use the same notation. If the ambiguity is a problem, you can use the \k&lt;name&gt; notation, which is unambiguous and cannot be confused with octal character codes. Similarly, hexadecimal codes such as \xdd are unambiguous and cannot be confused with backreferences.</value>
  </data>
  <data name="Regex_numbered_backreference_short" xml:space="preserve">
    <value>numbered backreference</value>
  </data>
  <data name="Regex_yes" xml:space="preserve">
    <value>yes</value>
  </data>
  <data name="Regex_zero_width_negative_lookahead_assertion_long" xml:space="preserve">
    <value>A zero-width negative lookahead assertion, where for the match to be successful, the input string must not match the regular expression pattern in subexpression. The matched string is not included in the match result.

A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression. At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched. In this case, it is often used to limit backtracking. At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</value>
  </data>
  <data name="Regex_zero_width_negative_lookahead_assertion_short" xml:space="preserve">
    <value>zero-width negative lookahead assertion</value>
  </data>
  <data name="Regex_zero_width_negative_lookbehind_assertion_long" xml:space="preserve">
    <value>A zero-width negative lookbehind assertion, where for a match to be successful, 'subexpression' must not occur at the input string to the left of the current position. Any substring that does not match 'subexpression' is not included in the match result.

Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define precludes a match in the string that follows. They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</value>
  </data>
  <data name="Regex_zero_width_negative_lookbehind_assertion_short" xml:space="preserve">
    <value>zero-width negative lookbehind assertion</value>
  </data>
  <data name="Regex_zero_width_positive_lookahead_assertion_long" xml:space="preserve">
    <value>A zero-width positive lookahead assertion, where for a match to be successful, the input string must match the regular expression pattern in 'subexpression'. The matched substring is not included in the match result. A zero-width positive lookahead assertion does not backtrack.

Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern. It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match. It is also useful for preventing excessive backtracking. You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</value>
  </data>
  <data name="Regex_zero_width_positive_lookahead_assertion_short" xml:space="preserve">
    <value>zero-width positive lookahead assertion</value>
  </data>
  <data name="Regex_zero_width_positive_lookbehind_assertion_long" xml:space="preserve">
    <value>A zero-width positive lookbehind assertion, where for a match to be successful, 'subexpression' must occur at the input string to the left of the current position. 'subexpression' is not included in the match result. A zero-width positive lookbehind assertion does not backtrack.

Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define is a precondition for a match, although it is not a part of the match result.</value>
  </data>
  <data name="Regex_zero_width_positive_lookbehind_assertion_short" xml:space="preserve">
    <value>zero-width positive lookbehind assertion</value>
  </data>
  <data name="Regex_all_control_characters_long" xml:space="preserve">
    <value>All control characters. This includes the Cc, Cf, Cs, Co, and Cn categories.</value>
  </data>
  <data name="Regex_all_control_characters_short" xml:space="preserve">
    <value>all control characters</value>
  </data>
  <data name="Regex_all_diacritic_marks_long" xml:space="preserve">
    <value>All diacritic marks. This includes the Mn, Mc, and Me categories.</value>
  </data>
  <data name="Regex_all_diacritic_marks_short" xml:space="preserve">
    <value>all diacritic marks</value>
  </data>
  <data name="Regex_all_letter_characters_long" xml:space="preserve">
    <value>All letter characters. This includes the Lu, Ll, Lt, Lm, and Lo characters.</value>
  </data>
  <data name="Regex_all_letter_characters_short" xml:space="preserve">
    <value>all letter characters</value>
  </data>
  <data name="Regex_all_numbers_long" xml:space="preserve">
    <value>All numbers. This includes the Nd, Nl, and No categories.</value>
  </data>
  <data name="Regex_all_numbers_short" xml:space="preserve">
    <value>all numbers</value>
  </data>
  <data name="Regex_all_punctuation_characters_long" xml:space="preserve">
    <value>All punctuation characters. This includes the Pc, Pd, Ps, Pe, Pi, Pf, and Po categories.</value>
  </data>
  <data name="Regex_all_punctuation_characters_short" xml:space="preserve">
    <value>all punctuation characters</value>
  </data>
  <data name="Regex_all_separator_characters_long" xml:space="preserve">
    <value>All separator characters. This includes the Zs, Zl, and Zp categories.</value>
  </data>
  <data name="Regex_all_separator_characters_short" xml:space="preserve">
    <value>all separator characters</value>
  </data>
  <data name="Regex_all_symbols_long" xml:space="preserve">
    <value>All symbols. This includes the Sm, Sc, Sk, and So categories.</value>
  </data>
  <data name="Regex_all_symbols_short" xml:space="preserve">
    <value>all symbols</value>
  </data>
  <data name="Regex_base_group" xml:space="preserve">
    <value>base-group</value>
  </data>
  <data name="Regex_character_class_subtraction_long" xml:space="preserve">
    <value>Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.

'base_group' is a positive or negative character group or range. The 'excluded_group' component is another positive or negative character group, or another character class subtraction expression (that is, you can nest character class subtraction expressions).</value>
  </data>
  <data name="Regex_character_class_subtraction_short" xml:space="preserve">
    <value>character class subtraction</value>
  </data>
  <data name="Regex_character_group" xml:space="preserve">
    <value>character-group</value>
  </data>
  <data name="Regex_excluded_group" xml:space="preserve">
    <value>excluded-group</value>
  </data>
  <data name="Regex_match_at_least_n_times_lazy_long" xml:space="preserve">
    <value>The {n,}? quantifier matches the preceding element at least n times, where n is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,}</value>
  </data>
  <data name="Regex_match_at_least_n_times_lazy_short" xml:space="preserve">
    <value>match at least 'n' times (lazy)</value>
  </data>
  <data name="Regex_match_at_least_n_times_long" xml:space="preserve">
    <value>The {n,} quantifier matches the preceding element at least n times, where n is any integer. {n,} is a greedy quantifier whose lazy equivalent is {n,}?</value>
  </data>
  <data name="Regex_match_at_least_n_times_short" xml:space="preserve">
    <value>match at least 'n' times</value>
  </data>
  <data name="Regex_match_between_m_and_n_times_lazy_long" xml:space="preserve">
    <value>The {n,m}? quantifier matches the preceding element between n and m times, where n and m are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,m}</value>
  </data>
  <data name="Regex_match_between_m_and_n_times_lazy_short" xml:space="preserve">
    <value>match at least 'n' times (lazy)</value>
  </data>
  <data name="Regex_match_between_m_and_n_times_long" xml:space="preserve">
    <value>The {n,m} quantifier matches the preceding element at least n times, but no more than m times, where n and m are integers. {n,m} is a greedy quantifier whose lazy equivalent is {n,m}?</value>
  </data>
  <data name="Regex_match_between_m_and_n_times_short" xml:space="preserve">
    <value>match between 'm' and 'n' times</value>
  </data>
  <data name="Regex_match_exactly_n_times_lazy_long" xml:space="preserve">
    <value>The {n}? quantifier matches the preceding element exactly n times, where n is any integer. It is the lazy counterpart of the greedy quantifier {n}+</value>
  </data>
  <data name="Regex_match_exactly_n_times_lazy_short" xml:space="preserve">
    <value>match exactly 'n' times (lazy)</value>
  </data>
  <data name="Regex_match_exactly_n_times_long" xml:space="preserve">
    <value>The {n} quantifier matches the preceding element exactly n times, where n is any integer. {n} is a greedy quantifier whose lazy equivalent is {n}?</value>
  </data>
  <data name="Regex_match_exactly_n_times_short" xml:space="preserve">
    <value>match exactly 'n' times</value>
  </data>
  <data name="Regex_match_one_or_more_times_lazy_long" xml:space="preserve">
    <value>The +? quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier +</value>
  </data>
  <data name="Regex_match_one_or_more_times_lazy_short" xml:space="preserve">
    <value>match one or more times (lazy)</value>
  </data>
  <data name="Regex_match_one_or_more_times_long" xml:space="preserve">
    <value>The + quantifier matches the preceding element one or more times. It is equivalent to the {1,} quantifier. + is a greedy quantifier whose lazy equivalent is +?.</value>
  </data>
  <data name="Regex_match_one_or_more_times_short" xml:space="preserve">
    <value>match one or more times</value>
  </data>
  <data name="Regex_match_zero_or_more_times_lazy_long" xml:space="preserve">
    <value>The *? quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier *</value>
  </data>
  <data name="Regex_match_zero_or_more_times_lazy_short" xml:space="preserve">
    <value>match zero or more times (lazy)</value>
  </data>
  <data name="Regex_match_zero_or_more_times_long" xml:space="preserve">
    <value>The * quantifier matches the preceding element zero or more times. It is equivalent to the {0,} quantifier. * is a greedy quantifier whose lazy equivalent is *?.</value>
  </data>
  <data name="Regex_match_zero_or_more_times_short" xml:space="preserve">
    <value>match zero or more times</value>
  </data>
  <data name="Regex_match_zero_or_one_time_lazy_long" xml:space="preserve">
    <value>The ?? quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier ?</value>
  </data>
  <data name="Regex_match_zero_or_one_time_lazy_short" xml:space="preserve">
    <value>match zero or one time (lazy)</value>
  </data>
  <data name="Regex_match_zero_or_one_time_long" xml:space="preserve">
    <value>The ? quantifier matches the preceding element zero or one time. It is equivalent to the {0,1} quantifier. ? is a greedy quantifier whose lazy equivalent is ??.</value>
  </data>
  <data name="Regex_match_zero_or_one_time_short" xml:space="preserve">
    <value>match zero or one time</value>
  </data>
  <data name="Regex_unicode_general_category_0" xml:space="preserve">
    <value>Unicode General Category: {0}</value>
  </data>
  <data name="Regex_inline_options_long" xml:space="preserve">
    <value>Enables or disables specific pattern matching options for the remainder of a regular expression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly named
	or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</value>
  </data>
  <data name="Regex_inline_options_short" xml:space="preserve">
    <value>inline options</value>
  </data>
</root>