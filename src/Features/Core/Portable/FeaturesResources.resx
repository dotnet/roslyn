<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="0_directive" xml:space="preserve">
    <value>#{0} directive</value>
  </data>
  <data name="Add_project_reference_to_0" xml:space="preserve">
    <value>Add project reference to '{0}'.</value>
  </data>
  <data name="Add_reference_to_0" xml:space="preserve">
    <value>Add reference to '{0}'.</value>
  </data>
  <data name="Actions_can_not_be_empty" xml:space="preserve">
    <value>Actions can not be empty.</value>
  </data>
  <data name="generic_overload" xml:space="preserve">
    <value>generic overload</value>
  </data>
  <data name="generic_overloads" xml:space="preserve">
    <value>generic overloads</value>
  </data>
  <data name="overload" xml:space="preserve">
    <value>overload</value>
  </data>
  <data name="overloads_" xml:space="preserve">
    <value>overloads</value>
  </data>
  <data name="type" xml:space="preserve">
    <value>type</value>
  </data>
  <data name="property_accessor" xml:space="preserve">
    <value>property accessor</value>
  </data>
  <data name="_0_Keyword" xml:space="preserve">
    <value>{0} Keyword</value>
  </data>
  <data name="Encapsulate_field_colon_0_and_use_property" xml:space="preserve">
    <value>Encapsulate field: '{0}' (and use property)</value>
  </data>
  <data name="Encapsulate_field_colon_0_but_still_use_field" xml:space="preserve">
    <value>Encapsulate field: '{0}' (but still use field)</value>
  </data>
  <data name="Encapsulate_fields_and_use_property" xml:space="preserve">
    <value>Encapsulate fields (and use property)</value>
  </data>
  <data name="Encapsulate_fields_but_still_use_field" xml:space="preserve">
    <value>Encapsulate fields (but still use field)</value>
  </data>
  <data name="Could_not_extract_interface_colon_The_selection_is_not_inside_a_class_interface_struct" xml:space="preserve">
    <value>Could not extract interface: The selection is not inside a class/interface/struct.</value>
  </data>
  <data name="Could_not_extract_interface_colon_The_type_does_not_contain_any_member_that_can_be_extracted_to_an_interface" xml:space="preserve">
    <value>Could not extract interface: The type does not contain any member that can be extracted to an interface.</value>
  </data>
  <data name="can_t_not_construct_final_tree" xml:space="preserve">
    <value>can't not construct final tree</value>
  </data>
  <data name="Parameters_type_or_return_type_cannot_be_an_anonymous_type_colon_bracket_0_bracket" xml:space="preserve">
    <value>Parameters' type or return type cannot be an anonymous type : [{0}]</value>
  </data>
  <data name="The_selection_contains_no_active_statement" xml:space="preserve">
    <value>The selection contains no active statement.</value>
  </data>
  <data name="The_selection_contains_a_local_function_call_without_its_declaration" xml:space="preserve">
    <value>The selection contains a local function call without its declaration.</value>
  </data>
  <data name="The_selection_contains_an_error_or_unknown_type" xml:space="preserve">
    <value>The selection contains an error or unknown type.</value>
  </data>
  <data name="Type_parameter_0_is_hidden_by_another_type_parameter_1" xml:space="preserve">
    <value>Type parameter '{0}' is hidden by another type parameter '{1}'.</value>
  </data>
  <data name="The_address_of_a_variable_is_used_inside_the_selected_code" xml:space="preserve">
    <value>The address of a variable is used inside the selected code.</value>
  </data>
  <data name="Assigning_to_readonly_fields_must_be_done_in_a_constructor_colon_bracket_0_bracket" xml:space="preserve">
    <value>Assigning to readonly fields must be done in a constructor : [{0}].</value>
  </data>
  <data name="generated_code_is_overlapping_with_hidden_portion_of_the_code" xml:space="preserve">
    <value>generated code is overlapping with hidden portion of the code</value>
  </data>
  <data name="Add_optional_parameters_to_0" xml:space="preserve">
    <value>Add optional parameters to '{0}'</value>
  </data>
  <data name="Add_parameters_to_0" xml:space="preserve">
    <value>Add parameters to '{0}'</value>
  </data>
  <data name="Generate_delegating_constructor_0_1" xml:space="preserve">
    <value>Generate delegating constructor '{0}({1})'</value>
  </data>
  <data name="Generate_constructor_0_1" xml:space="preserve">
    <value>Generate constructor '{0}({1})'</value>
  </data>
  <data name="Generate_field_assigning_constructor_0_1" xml:space="preserve">
    <value>Generate field assigning constructor '{0}({1})'</value>
  </data>
  <data name="Generate_Equals_and_GetHashCode" xml:space="preserve">
    <value>Generate Equals and GetHashCode</value>
  </data>
  <data name="Generate_Equals_object" xml:space="preserve">
    <value>Generate Equals(object)</value>
  </data>
  <data name="Generate_GetHashCode" xml:space="preserve">
    <value>Generate GetHashCode()</value>
  </data>
  <data name="Generate_constructor_in_0" xml:space="preserve">
    <value>Generate constructor in '{0}'</value>
  </data>
  <data name="Generate_all" xml:space="preserve">
    <value>Generate all</value>
  </data>
  <data name="Generate_enum_member_0" xml:space="preserve">
    <value>Generate enum member '{0}'</value>
  </data>
  <data name="Generate_constant_0" xml:space="preserve">
    <value>Generate constant '{0}'</value>
  </data>
  <data name="Generate_read_only_property_0" xml:space="preserve">
    <value>Generate read-only property '{0}'</value>
  </data>
  <data name="Generate_property_0" xml:space="preserve">
    <value>Generate property '{0}'</value>
  </data>
  <data name="Generate_read_only_field_0" xml:space="preserve">
    <value>Generate read-only field '{0}'</value>
  </data>
  <data name="Generate_field_0" xml:space="preserve">
    <value>Generate field '{0}'</value>
  </data>
  <data name="Generate_local_0" xml:space="preserve">
    <value>Generate local '{0}'</value>
  </data>
  <data name="Generate_0_1_in_new_file" xml:space="preserve">
    <value>Generate {0} '{1}' in new file</value>
  </data>
  <data name="Generate_nested_0_1" xml:space="preserve">
    <value>Generate nested {0} '{1}'</value>
  </data>
  <data name="Implement_all_members_explicitly" xml:space="preserve">
    <value>Implement all members explicitly</value>
  </data>
  <data name="Implement_interface_abstractly" xml:space="preserve">
    <value>Implement interface abstractly</value>
  </data>
  <data name="Implement_interface_through_0" xml:space="preserve">
    <value>Implement interface through '{0}'</value>
  </data>
  <data name="Implement_interface" xml:space="preserve">
    <value>Implement interface</value>
  </data>
  <data name="Introduce_field_for_0" xml:space="preserve">
    <value>Introduce field for '{0}'</value>
  </data>
  <data name="Introduce_local_for_0" xml:space="preserve">
    <value>Introduce local for '{0}'</value>
  </data>
  <data name="Introduce_constant_for_0" xml:space="preserve">
    <value>Introduce constant for '{0}'</value>
  </data>
  <data name="Introduce_local_constant_for_0" xml:space="preserve">
    <value>Introduce local constant for '{0}'</value>
  </data>
  <data name="Introduce_field_for_all_occurrences_of_0" xml:space="preserve">
    <value>Introduce field for all occurrences of '{0}'</value>
  </data>
  <data name="Introduce_local_for_all_occurrences_of_0" xml:space="preserve">
    <value>Introduce local for all occurrences of '{0}'</value>
  </data>
  <data name="Introduce_constant_for_all_occurrences_of_0" xml:space="preserve">
    <value>Introduce constant for all occurrences of '{0}'</value>
  </data>
  <data name="Introduce_local_constant_for_all_occurrences_of_0" xml:space="preserve">
    <value>Introduce local constant for all occurrences of '{0}'</value>
  </data>
  <data name="Introduce_query_variable_for_all_occurrences_of_0" xml:space="preserve">
    <value>Introduce query variable for all occurrences of '{0}'</value>
  </data>
  <data name="Introduce_query_variable_for_0" xml:space="preserve">
    <value>Introduce query variable for '{0}'</value>
  </data>
  <data name="Types_colon" xml:space="preserve">
    <value>Types:</value>
  </data>
  <data name="is_" xml:space="preserve">
    <value>is</value>
  </data>
  <data name="Represents_an_object_whose_operations_will_be_resolved_at_runtime" xml:space="preserve">
    <value>Represents an object whose operations will be resolved at runtime.</value>
  </data>
  <data name="constant" xml:space="preserve">
    <value>constant</value>
  </data>
  <data name="field" xml:space="preserve">
    <value>field</value>
  </data>
  <data name="local_constant" xml:space="preserve">
    <value>local constant</value>
  </data>
  <data name="local_variable" xml:space="preserve">
    <value>local variable</value>
  </data>
  <data name="label" xml:space="preserve">
    <value>label</value>
  </data>
  <data name="range_variable" xml:space="preserve">
    <value>range variable</value>
  </data>
  <data name="parameter" xml:space="preserve">
    <value>parameter</value>
  </data>
  <data name="discard" xml:space="preserve">
    <value>discard</value>
  </data>
  <data name="in_" xml:space="preserve">
    <value>in</value>
  </data>
  <data name="Summary_colon" xml:space="preserve">
    <value>Summary:</value>
  </data>
  <data name="Locals_and_parameters" xml:space="preserve">
    <value>Locals and parameters</value>
  </data>
  <data name="Type_parameters_colon" xml:space="preserve">
    <value>Type parameters:</value>
  </data>
  <data name="Returns_colon" xml:space="preserve">
    <value>Returns:</value>
  </data>
  <data name="Exceptions_colon" xml:space="preserve">
    <value>Exceptions:</value>
  </data>
  <data name="Remarks_colon" xml:space="preserve">
    <value>Remarks:</value>
  </data>
  <data name="generating_source_for_symbols_of_this_type_is_not_supported" xml:space="preserve">
    <value>generating source for symbols of this type is not supported</value>
  </data>
  <data name="Assembly" xml:space="preserve">
    <value>Assembly</value>
  </data>
  <data name="location_unknown" xml:space="preserve">
    <value>location unknown</value>
  </data>
  <data name="Extract_interface" xml:space="preserve">
    <value>Extract interface...</value>
  </data>
  <data name="Updating_0_requires_restarting_the_application" xml:space="preserve">
    <value>Updating '{0}' requires restarting the application.</value>
  </data>
  <data name="Changing_0_to_1_requires_restarting_the_application_because_it_changes_the_shape_of_the_state_machine" xml:space="preserve">
    <value>Changing '{0}' to '{1}' requires restarting the application because it changes the shape of the state machine.</value>
  </data>
  <data name="Updating_a_complex_statement_containing_an_await_expression_requires_restarting_the_application" xml:space="preserve">
    <value>Updating a complex statement containing an await expression requires restarting the application.</value>
  </data>
  <data name="Changing_visibility_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Changing visibility of {0} requires restarting the application.</value>
  </data>
  <data name="Capturing_variable_0_that_hasn_t_been_captured_before_requires_restarting_the_application" xml:space="preserve">
    <value>Capturing variable '{0}' that hasn't been captured before requires restarting the application.</value>
  </data>
  <data name="Ceasing_to_capture_variable_0_requires_restarting_the_application" xml:space="preserve">
    <value>Ceasing to capture variable '{0}' requires restarting the application.</value>
  </data>
  <data name="Ceasing_to_capture_primary_constructor_parameter_0_of_1_requires_restarting_the_application" xml:space="preserve">
    <value>Ceasing to capture primary constructor parameter '{0}' of '{1}' requires restarting the application.</value>
  </data>
  <data name="Changing_attribute_0_requires_restarting_the_application" xml:space="preserve">
    <value>Changing attribute '{0}' requires restarting the application.</value>
  </data>
  <data name="Changing_name_or_signature_of_0_that_contains_an_active_statement_requires_restarting_the_application" xml:space="preserve">
    <value>Changing attribute '{0}' requires restarting the application.</value>
  </data>
  <data name="Capturing_primary_constructor_parameter_0_that_hasn_t_been_captured_before_requires_restarting_the_application" xml:space="preserve">
    <value>Capturing primary constructor parameter '{0}' that hasn't been capture before requires restarting the application.</value>
  </data>
  <data name="Deleting_captured_variable_0_requires_restarting_the_application" xml:space="preserve">
    <value>Deleting captured variable '{0}' requires restarting the application.</value>
  </data>
  <data name="Changing_the_type_of_a_captured_variable_0_previously_of_type_1_requires_restarting_the_application" xml:space="preserve">
    <value>Changing the type of a captured variable '{0}' previously of type '{1}' requires restarting the application.</value>
  </data>
  <data name="Changing_the_parameters_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Changing the parameters of {0} requires restarting the application.</value>
  </data>
  <data name="Changing_the_return_type_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Changing the return type of {0} requires restarting the application.</value>
  </data>
  <data name="Changing_the_signature_of_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime" xml:space="preserve">
    <value>Changing the signature of {0} requires restarting the application because is not supported by the runtime.</value>
  </data>
  <data name="Changing_the_declaration_scope_of_a_captured_variable_0_requires_restarting_the_application" xml:space="preserve">
    <value>Changing the declaration scope of a captured variable '{0}' requires restarting the application.</value>
  </data>
  <data name="Accessing_captured_variable_0_that_hasn_t_been_accessed_before_in_1_requires_restarting_the_application" xml:space="preserve">
    <value>Accessing captured variable '{0}' that hasn't been accessed before in {1} requires restarting the application.</value>
  </data>
  <data name="Ceasing_to_access_captured_variable_0_in_1_requires_restarting_the_application" xml:space="preserve">
    <value>Ceasing to access captured variable '{0}' in {1} requires restarting the application.</value>
  </data>
  <data name="Adding_0_that_accesses_captured_variables_1_and_2_declared_in_different_scopes_requires_restarting_the_application" xml:space="preserve">
    <value>Adding {0} that accesses captured variables '{1}' and '{2}' declared in different scopes requires restarting the application.</value>
  </data>
  <data name="Removing_0_that_accessed_captured_variables_1_and_2_declared_in_different_scopes_requires_restarting_the_application" xml:space="preserve">
    <value>Removing {0} that accessed captured variables '{1}' and '{2}' declared in different scopes requires restarting the application.</value>
  </data>
  <data name="Adding_0_into_a_1_requires_restarting_the_application" xml:space="preserve">
    <value>Adding {0} into a {1} requires restarting the application.</value>
  </data>
  <data name="Adding_0_into_an_interface_requires_restarting_the_application" xml:space="preserve">
    <value>Adding {0} into an interface requires restarting the application.</value>
  </data>
  <data name="Adding_0_into_an_interface_method_requires_restarting_the_application" xml:space="preserve">
    <value>Adding {0} into an interface method requires restarting the application.</value>
  </data>
  <data name="Adding_0_into_a_class_with_explicit_or_sequential_layout_requires_restarting_the_application" xml:space="preserve">
    <value>Adding {0} into a class with explicit or sequential layout requires restarting the application.</value>
  </data>
  <data name="Updating_the_modifiers_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the modifiers of {0} requires restarting the application.</value>
  </data>
  <data name="Updating_the_Handles_clause_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the Handles clause of {0} requires restarting the application.</value>
    <comment>{Locked="Handles"} "Handles" is VB keywords and should not be localized.</comment>
  </data>
  <data name="Adding_0_with_the_Handles_clause_requires_restarting_the_application" xml:space="preserve">
    <value>Adding {0} with the Handles clause requires restarting the application.</value>
    <comment>{Locked="Handles"} "Handles" is VB keywords and should not be localized.</comment>
  </data>
  <data name="Updating_the_Implements_clause_of_a_0_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the Implements clause of a {0} requires restarting the application.</value>
    <comment>{Locked="Implements"} "Implements" is VB keywords and should not be localized.</comment>
  </data>
  <data name="Updating_the_variance_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the variance of {0} requires restarting the application.</value>
  </data>
  <data name="Updating_the_type_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the type of {0} requires restarting the application.</value>
  </data>
  <data name="Updating_the_initializer_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the initializer of {0} requires restarting the application.</value>
  </data>
  <data name="Updating_the_size_of_a_0_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the size of a {0} requires restarting the application.</value>
  </data>
  <data name="Updating_the_underlying_type_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the underlying type of {0} requires restarting the application.</value>
  </data>
  <data name="Updating_the_base_class_and_or_base_interface_s_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the base class and/or base interface(s) of {0} requires restarting the application.</value>
  </data>
  <data name="Changing_a_field_to_an_event_or_vice_versa_requires_restarting_the_application" xml:space="preserve">
    <value>Changing a field to an event or vice versa requires restarting the application.</value>
  </data>
  <data name="Updating_the_kind_of_a_type_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the kind of a type requires restarting the application.</value>
  </data>
  <data name="Updating_the_kind_of_a_property_event_accessor_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the kind of a property/event accessor requires restarting the application.</value>
  </data>
  <data name="Updating_the_library_name_of_Declare_statement_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the library name of Declare statement requires restarting the application.</value>
    <comment>{Locked="Declare"} "Declare" is VB keyword and should not be localized.</comment>
  </data>
  <data name="Updating_the_alias_of_Declare_statement_requires_restarting_the_application" xml:space="preserve">
    <value>Updating the alias of Declare statement requires restarting the application.</value>
    <comment>{Locked="Declare"} "Declare" is VB keyword and should not be localized.</comment>
  </data>
  <data name="Renaming_0_requires_restarting_the_application" xml:space="preserve">
    <value>Renaming {0} requires restarting the application.</value>
  </data>
  <data name="Adding_0_requires_restarting_the_application" xml:space="preserve">
    <value>Adding {0} requires restarting the application.</value>
  </data>
  <data name="Adding_an_abstract_0_or_overriding_an_inherited_0_requires_restarting_the_application" xml:space="preserve">
    <value>Adding an abstract {0} or overriding an inherited {0} requires restarting the application.</value>
  </data>
  <data name="Adding_a_MustOverride_0_or_overriding_an_inherited_0_requires_restarting_the_application" xml:space="preserve">
    <value>Adding a MustOverride {0} or overriding an inherited {0} requires restarting the application.</value>
    <comment>{Locked="MustOverride"} "MustOverride" is VB keyword and should not be localized.</comment>
  </data>
  <data name="Adding_an_extern_0_requires_restarting_the_application" xml:space="preserve">
    <value>Adding an extern {0} requires restarting the application.</value>
    <comment>{Locked="extern"} "extern" is C# keyword and should not be localized.</comment>
  </data>
  <data name="Adding_an_imported_method_requires_restarting_the_application" xml:space="preserve">
    <value>Adding an imported method requires restarting the application.</value>
  </data>
  <data name="Adding_a_user_defined_0_requires_restarting_the_application" xml:space="preserve">
    <value>Adding a user defined {0} requires restarting the application.</value>
  </data>
  <data name="Adding_0_around_an_active_statement_requires_restarting_the_application" xml:space="preserve">
    <value>Adding {0} around an active statement requires restarting the application.</value>
  </data>
  <data name="Moving_0_requires_restarting_the_application" xml:space="preserve">
    <value>Moving {0} requires restarting the application.</value>
  </data>
  <data name="Deleting_0_requires_restarting_the_application" xml:space="preserve">
    <value>Deleting {0} requires restarting the application.</value>
  </data>
  <data name="Deleting_0_around_an_active_statement_requires_restarting_the_application" xml:space="preserve">
    <value>Deleting {0} around an active statement requires restarting the application.</value>
  </data>
  <data name="Updating_a_0_around_an_active_statement_requires_restarting_the_application" xml:space="preserve">
    <value>Updating a {0} around an active statement requires restarting the application.</value>
  </data>
  <data name="Updating_async_or_iterator_modifier_around_an_active_statement_requires_restarting_the_application" xml:space="preserve">
    <value>Updating async or iterator modifier around an active statement requires restarting the application.</value>
    <comment>{Locked="async"}{Locked="iterator"} "async" and "iterator" are C#/VB keywords and should not be localized.</comment>
  </data>
  <data name="Changing_0_from_asynchronous_to_synchronous_requires_restarting_the_application" xml:space="preserve">
    <value>Changing {0} from asynchronous to synchronous requires restarting the application.</value>
  </data>
  <data name="Modifying_a_generic_method_requires_restarting_the_application" xml:space="preserve">
    <value>Modifying a generic method requires restarting the application.</value>
  </data>
  <data name="Modifying_a_method_inside_the_context_of_a_generic_type_requires_restarting_the_application" xml:space="preserve">
    <value>Modifying a method inside the context of a generic type requires restarting the application.</value>
  </data>
  <data name="Adding_a_constructor_to_a_type_with_a_field_or_property_initializer_that_contains_an_anonymous_function_requires_restarting_the_application" xml:space="preserve">
    <value>Adding a constructor to a type with a field or property initializer that contains an anonymous function requires restarting the application.</value>
  </data>
  <data name="Renaming_a_captured_variable_from_0_to_1_requires_restarting_the_application" xml:space="preserve">
    <value>Renaming a captured variable, from '{0}' to '{1}' requires restarting the application.</value>
  </data>
  <data name="Modifying_a_catch_finally_handler_with_an_active_statement_in_the_try_block_requires_restarting_the_application" xml:space="preserve">
    <value>Modifying a catch/finally handler with an active statement in the try block requires restarting the application.</value>
  </data>
  <data name="Modifying_a_try_catch_finally_statement_when_the_finally_block_is_active_requires_restarting_the_application" xml:space="preserve">
    <value>Modifying a try/catch/finally statement when the finally block is active requires restarting the application.</value>
  </data>
  <data name="Modifying_a_catch_handler_around_an_active_statement_requires_restarting_the_application" xml:space="preserve">
    <value>Modifying a catch handler around an active statement requires restarting the application.</value>
  </data>
  <data name="Modifying_0_which_contains_the_stackalloc_operator_requires_restarting_the_application" xml:space="preserve">
    <value>Modifying {0} which contains the stackalloc operator requires restarting the application.</value>
    <comment>{Locked="stackalloc"} "stackalloc" is C# keyword and should not be localized.</comment>
  </data>
  <data name="Modifying_0_which_contains_an_Aggregate_Group_By_or_Join_query_clauses_requires_restarting_the_application" xml:space="preserve">
    <value>Modifying {0} which contains an Aggregate, Group By, or Join query clauses requires restarting the application.</value>
    <comment>{Locked="Aggregate"}{Locked="Group By"}{Locked="Join"} are VB keywords and should not be localized.</comment>
  </data>
  <data name="Modifying_source_with_experimental_language_features_enabled_requires_restarting_the_application" xml:space="preserve">
    <value>Modifying source with experimental language features enabled requires restarting the application.</value>
  </data>
  <data name="Updating_an_active_statement_requires_restarting_the_application" xml:space="preserve">
    <value>Updating an active statement requires restarting the application.</value>
  </data>
  <data name="Removing_0_that_contains_an_active_statement_requires_restarting_the_application" xml:space="preserve">
    <value>Removing {0} that contains an active statement requires restarting the application.</value>
  </data>
  <data name="Adding_a_new_file_requires_restarting_the_application" xml:space="preserve">
    <value>Adding a new file requires restarting the application.</value>
  </data>
  <data name="Attribute_0_is_missing_Updating_an_async_method_or_an_iterator_requires_restarting_the_application" xml:space="preserve">
    <value>Attribute '{0}' is missing. Updating an async method or an iterator requires restarting the application.</value>
  </data>
  <data name="Unexpected_interface_member_kind_colon_0" xml:space="preserve">
    <value>Unexpected interface member kind: {0}</value>
  </data>
  <data name="Generate_abstract_property_0" xml:space="preserve">
    <value>Generate abstract property '{0}'</value>
  </data>
  <data name="Generate_abstract_method_0" xml:space="preserve">
    <value>Generate abstract method '{0}'</value>
  </data>
  <data name="Generate_method_0" xml:space="preserve">
    <value>Generate method '{0}'</value>
  </data>
  <data name="The_symbol_does_not_have_an_icon" xml:space="preserve">
    <value>The symbol does not have an icon.</value>
  </data>
  <data name="Extract_local_function" xml:space="preserve">
    <value>Extract local function</value>
  </data>
  <data name="Extract_method" xml:space="preserve">
    <value>Extract method</value>
  </data>
  <data name="Asynchronous_method_cannot_have_ref_out_parameters_colon_bracket_0_bracket" xml:space="preserve">
    <value>Asynchronous method cannot have ref/out parameters : [{0}]</value>
  </data>
  <data name="The_member_is_defined_in_metadata" xml:space="preserve">
    <value>The member is defined in metadata.</value>
  </data>
  <data name="You_can_only_change_the_signature_of_a_constructor_indexer_method_or_delegate" xml:space="preserve">
    <value>You can only change the signature of a constructor, indexer, method or delegate.</value>
  </data>
  <data name="This_symbol_has_related_definitions_or_references_in_metadata_Changing_its_signature_may_result_in_build_errors_Do_you_want_to_continue" xml:space="preserve">
    <value>This symbol has related definitions or references in metadata. Changing its signature may result in build errors.

Do you want to continue?</value>
  </data>
  <data name="Change_signature" xml:space="preserve">
    <value>Change signature...</value>
  </data>
  <data name="Generate_new_type" xml:space="preserve">
    <value>Generate new type...</value>
  </data>
  <data name="User_Diagnostic_Analyzer_Failure" xml:space="preserve">
    <value>User Diagnostic Analyzer Failure.</value>
  </data>
  <data name="Analyzer_0_threw_an_exception_of_type_1_with_message_2" xml:space="preserve">
    <value>Analyzer '{0}' threw an exception of type '{1}' with message '{2}'.</value>
  </data>
  <data name="Analyzer_0_threw_the_following_exception_colon_1" xml:space="preserve">
    <value>Analyzer '{0}' threw the following exception:
'{1}'.</value>
  </data>
  <data name="Remove_qualification" xml:space="preserve">
    <value>Remove qualification</value>
  </data>
  <data name="Unknown_error_occurred" xml:space="preserve">
    <value>Unknown error occurred</value>
  </data>
  <data name="No_valid_location_to_insert_method_call" xml:space="preserve">
    <value>No valid location to insert method call.</value>
  </data>
  <data name="Available" xml:space="preserve">
    <value>Available</value>
  </data>
  <data name="Not_Available" xml:space="preserve">
    <value>Not Available âš </value>
  </data>
  <data name="_0_1" xml:space="preserve">
    <value>    {0} - {1}</value>
  </data>
  <data name="You_can_use_the_navigation_bar_to_switch_contexts" xml:space="preserve">
    <value>You can use the navigation bar to switch contexts.</value>
  </data>
  <data name="in_Source" xml:space="preserve">
    <value>in Source</value>
  </data>
  <data name="in_Suppression_File" xml:space="preserve">
    <value>in Suppression File</value>
  </data>
  <data name="Remove_Suppression_0" xml:space="preserve">
    <value>Remove Suppression {0}</value>
  </data>
  <data name="Remove_Suppression" xml:space="preserve">
    <value>Remove Suppression</value>
  </data>
  <data name="Configure_0_severity" xml:space="preserve">
    <value>Configure {0} severity</value>
  </data>
  <data name="Configure_0_code_style" xml:space="preserve">
    <value>Configure {0} code style</value>
  </data>
  <data name="Configure_severity_for_all_0_analyzers" xml:space="preserve">
    <value>Configure severity for all '{0}' analyzers</value>
  </data>
  <data name="Configure_severity_for_all_analyzers" xml:space="preserve">
    <value>Configure severity for all analyzers</value>
  </data>
  <data name="Pending" xml:space="preserve">
    <value>&lt;Pending&gt;</value>
  </data>
  <data name="Awaited_task_returns_0" xml:space="preserve">
    <value>Awaited task returns '{0}'</value>
  </data>
  <data name="Awaited_task_returns_no_value" xml:space="preserve">
    <value>Awaited task returns no value</value>
  </data>
  <data name="Note_colon_Tab_twice_to_insert_the_0_snippet" xml:space="preserve">
    <value>Note: Tab twice to insert the '{0}' snippet.</value>
  </data>
  <data name="Implement_interface_explicitly_with_Dispose_pattern" xml:space="preserve">
    <value>Implement interface explicitly with Dispose pattern</value>
  </data>
  <data name="Implement_interface_with_Dispose_pattern" xml:space="preserve">
    <value>Implement interface with Dispose pattern</value>
  </data>
  <data name="Suppress_0" xml:space="preserve">
    <value>Suppress {0}</value>
  </data>
  <data name="Computing_fix_all_occurrences_code_fix" xml:space="preserve">
    <value>Computing fix all occurrences code fix...</value>
  </data>
  <data name="Fix_all_occurrences" xml:space="preserve">
    <value>Fix all occurrences</value>
  </data>
  <data name="Document" xml:space="preserve">
    <value>Document</value>
  </data>
  <data name="Project" xml:space="preserve">
    <value>Project</value>
  </data>
  <data name="Solution" xml:space="preserve">
    <value>Solution</value>
  </data>
  <data name="Containing_Member" xml:space="preserve">
    <value>Containing Member</value>
  </data>
  <data name="Containing_Type" xml:space="preserve">
    <value>Containing Type</value>
  </data>
  <data name="TODO_colon_dispose_managed_state_managed_objects" xml:space="preserve">
    <value>TODO: dispose managed state (managed objects)</value>
  </data>
  <data name="TODO_colon_set_large_fields_to_null" xml:space="preserve">
    <value>TODO: set large fields to null</value>
  </data>
  <data name="Modifying_0_which_contains_a_static_variable_requires_restarting_the_application" xml:space="preserve">
    <value>Modifying {0} which contains a static variable requires restarting the application.</value>
  </data>
  <data name="Compiler2" xml:space="preserve">
    <value>Compiler</value>
  </data>
  <data name="EditAndContinue" xml:space="preserve">
    <value>Edit and Continue</value>
  </data>
  <data name="Live" xml:space="preserve">
    <value>Live</value>
  </data>
  <data name="namespace_" xml:space="preserve">
    <value>namespace</value>
    <comment>{Locked}</comment>
  </data>
  <data name="class_" xml:space="preserve">
    <value>class</value>
    <comment>{Locked}</comment>
  </data>
  <data name="interface_" xml:space="preserve">
    <value>interface</value>
    <comment>{Locked}</comment>
  </data>
  <data name="enum_" xml:space="preserve">
    <value>enum</value>
    <comment>{Locked}</comment>
  </data>
  <data name="enum_value" xml:space="preserve">
    <value>enum value</value>
    <comment>{Locked="enum"} "enum" is a C#/VB keyword and should not be localized.</comment>
  </data>
  <data name="delegate_" xml:space="preserve">
    <value>delegate</value>
    <comment>{Locked}</comment>
  </data>
  <data name="const_field" xml:space="preserve">
    <value>const field</value>
    <comment>{Locked="const"} "const" is a C#/VB keyword and should not be localized.</comment>
  </data>
  <data name="method" xml:space="preserve">
    <value>method</value>
  </data>
  <data name="operator_" xml:space="preserve">
    <value>operator</value>
  </data>
  <data name="constructor" xml:space="preserve">
    <value>constructor</value>
  </data>
  <data name="static_constructor" xml:space="preserve">
    <value>static constructor</value>
  </data>
  <data name="auto_property" xml:space="preserve">
    <value>auto-property</value>
  </data>
  <data name="property_" xml:space="preserve">
    <value>property</value>
  </data>
  <data name="event_" xml:space="preserve">
    <value>event</value>
    <comment>{Locked}</comment>
  </data>
  <data name="event_accessor" xml:space="preserve">
    <value>event accessor</value>
  </data>
  <data name="type_constraint" xml:space="preserve">
    <value>type constraint</value>
  </data>
  <data name="type_parameter" xml:space="preserve">
    <value>type parameter</value>
  </data>
  <data name="attribute" xml:space="preserve">
    <value>attribute</value>
  </data>
  <data name="Replace_0_and_1_with_property" xml:space="preserve">
    <value>Replace '{0}' and '{1}' with property</value>
  </data>
  <data name="Replace_0_with_property" xml:space="preserve">
    <value>Replace '{0}' with property</value>
  </data>
  <data name="Method_referenced_implicitly" xml:space="preserve">
    <value>Method referenced implicitly</value>
  </data>
  <data name="Generate_type_0" xml:space="preserve">
    <value>Generate type '{0}'</value>
  </data>
  <data name="Generate_0_1" xml:space="preserve">
    <value>Generate {0} '{1}'</value>
  </data>
  <data name="Change_0_to_1" xml:space="preserve">
    <value>Change '{0}' to '{1}'.</value>
  </data>
  <data name="Non_invoked_method_cannot_be_replaced_with_property" xml:space="preserve">
    <value>Non-invoked method cannot be replaced with property.</value>
  </data>
  <data name="Only_methods_with_a_single_argument_which_is_not_an_out_variable_declaration_can_be_replaced_with_a_property" xml:space="preserve">
    <value>Only methods with a single argument, which is not an out variable declaration, can be replaced with a property.</value>
  </data>
  <data name="Roslyn_HostError" xml:space="preserve">
    <value>Roslyn.HostError</value>
  </data>
  <data name="An_instance_of_analyzer_0_cannot_be_created_from_1_colon_2" xml:space="preserve">
    <value>An instance of analyzer {0} cannot be created from {1}: {2}.</value>
  </data>
  <data name="The_assembly_0_does_not_contain_any_analyzers" xml:space="preserve">
    <value>The assembly {0} does not contain any analyzers.</value>
  </data>
  <data name="Unable_to_load_Analyzer_assembly_0_colon_1" xml:space="preserve">
    <value>Unable to load Analyzer assembly {0}: {1}</value>
  </data>
  <data name="from_0" xml:space="preserve">
    <value>from {0}</value>
  </data>
  <data name="Find_and_install_latest_version" xml:space="preserve">
    <value>Find and install latest version</value>
  </data>
  <data name="Use_local_version_0" xml:space="preserve">
    <value>Use local version '{0}'</value>
  </data>
  <data name="Use_locally_installed_0_version_1_This_version_used_in_colon_2" xml:space="preserve">
    <value>Use locally installed '{0}' version '{1}'
This version used in: {2}</value>
  </data>
  <data name="Find_and_install_latest_version_of_0" xml:space="preserve">
    <value>Find and install latest version of '{0}'</value>
  </data>
  <data name="Install_with_package_manager" xml:space="preserve">
    <value>Install with package manager...</value>
  </data>
  <data name="Install_0_1" xml:space="preserve">
    <value>Install '{0} {1}'</value>
  </data>
  <data name="Install_version_0" xml:space="preserve">
    <value>Install version '{0}'</value>
  </data>
  <data name="Generate_variable_0" xml:space="preserve">
    <value>Generate variable '{0}'</value>
  </data>
  <data name="Classes" xml:space="preserve">
    <value>Classes</value>
  </data>
  <data name="Constants" xml:space="preserve">
    <value>Constants</value>
  </data>
  <data name="Delegates" xml:space="preserve">
    <value>Delegates</value>
  </data>
  <data name="Enums" xml:space="preserve">
    <value>Enums</value>
  </data>
  <data name="Events" xml:space="preserve">
    <value>Events</value>
  </data>
  <data name="Extension_methods" xml:space="preserve">
    <value>Extension methods</value>
  </data>
  <data name="Fields" xml:space="preserve">
    <value>Fields</value>
  </data>
  <data name="Interfaces" xml:space="preserve">
    <value>Interfaces</value>
  </data>
  <data name="Methods" xml:space="preserve">
    <value>Methods</value>
  </data>
  <data name="Modules" xml:space="preserve">
    <value>Modules</value>
  </data>
  <data name="Namespaces" xml:space="preserve">
    <value>Namespaces</value>
  </data>
  <data name="Properties" xml:space="preserve">
    <value>Properties</value>
  </data>
  <data name="Structures" xml:space="preserve">
    <value>Structures</value>
  </data>
  <data name="Parameters_colon" xml:space="preserve">
    <value>Parameters:</value>
  </data>
  <data name="Variadic_SignatureHelpItem_must_have_at_least_one_parameter" xml:space="preserve">
    <value>Variadic SignatureHelpItem must have at least one parameter.</value>
  </data>
  <data name="Replace_0_with_method" xml:space="preserve">
    <value>Replace '{0}' with method</value>
  </data>
  <data name="Replace_0_with_methods" xml:space="preserve">
    <value>Replace '{0}' with methods</value>
  </data>
  <data name="Property_referenced_implicitly" xml:space="preserve">
    <value>Property referenced implicitly</value>
  </data>
  <data name="Property_cannot_safely_be_replaced_with_a_method_call" xml:space="preserve">
    <value>Property cannot safely be replaced with a method call</value>
  </data>
  <data name="Convert_to_interpolated_string" xml:space="preserve">
    <value>Convert to interpolated string</value>
  </data>
  <data name="Move_type_to_0" xml:space="preserve">
    <value>Move type to {0}</value>
  </data>
  <data name="Rename_file_to_0" xml:space="preserve">
    <value>Rename file to {0}</value>
  </data>
  <data name="Rename_type_to_0" xml:space="preserve">
    <value>Rename type to {0}</value>
  </data>
  <data name="Asynchronously_waits_for_the_task_to_finish" xml:space="preserve">
    <value>Asynchronously waits for the task to finish.</value>
  </data>
  <data name="Await_the_preceding_expression" xml:space="preserve">
    <value>Await the preceding expression</value>
  </data>
  <data name="Await_the_preceding_expression_and_add_ConfigureAwait_0" xml:space="preserve">
    <value>Await the preceding expression and add ConfigureAwait({0}).</value>
    <comment>{Locked="ConfigureAwait"} "ConfigureAwait" is an api name and should not be localized. {0} is a placeholder for the language specific keyword 'false'.</comment>
  </data>
  <data name="paren_Unknown_paren" xml:space="preserve">
    <value>(Unknown)</value>
  </data>
  <data name="Implement_abstract_class" xml:space="preserve">
    <value>Implement abstract class</value>
  </data>
  <data name="Use_framework_type" xml:space="preserve">
    <value>Use framework type</value>
  </data>
  <data name="Install_package_0" xml:space="preserve">
    <value>Install package '{0}'</value>
  </data>
  <data name="project_0" xml:space="preserve">
    <value>project {0}</value>
  </data>
  <data name="Fix_typo_0" xml:space="preserve">
    <value>Fix typo '{0}'</value>
  </data>
  <data name="Fully_qualify_0" xml:space="preserve">
    <value>Fully qualify '{0}'</value>
  </data>
  <data name="Remove_reference_to_0" xml:space="preserve">
    <value>Remove reference to '{0}'.</value>
  </data>
  <data name="Keywords" xml:space="preserve">
    <value>Keywords</value>
  </data>
  <data name="Snippets" xml:space="preserve">
    <value>Snippets</value>
  </data>
  <data name="Remove_document_0" xml:space="preserve">
    <value>Remove document '{0}'</value>
  </data>
  <data name="Add_document_0" xml:space="preserve">
    <value>Add document '{0}'</value>
  </data>
  <data name="Add_argument_name_0" xml:space="preserve">
    <value>Add argument name '{0}'</value>
  </data>
  <data name="Add_tuple_element_name_0" xml:space="preserve">
    <value>Add tuple element name '{0}'</value>
  </data>
  <data name="Remove_unused_variable" xml:space="preserve">
    <value>Remove unused variable</value>
  </data>
  <data name="Convert_to_binary" xml:space="preserve">
    <value>Convert to binary</value>
  </data>
  <data name="Convert_to_decimal" xml:space="preserve">
    <value>Convert to decimal</value>
  </data>
  <data name="Convert_to_hex" xml:space="preserve">
    <value>Convert to hex</value>
  </data>
  <data name="Separate_thousands" xml:space="preserve">
    <value>Separate thousands</value>
  </data>
  <data name="Separate_words" xml:space="preserve">
    <value>Separate words</value>
  </data>
  <data name="Separate_nibbles" xml:space="preserve">
    <value>Separate nibbles</value>
  </data>
  <data name="Remove_separators" xml:space="preserve">
    <value>Remove separators</value>
  </data>
  <data name="Generate_constructor" xml:space="preserve">
    <value>Generate constructor...</value>
  </data>
  <data name="Pick_members_to_be_used_as_constructor_parameters" xml:space="preserve">
    <value>Pick members to be used as constructor parameters</value>
  </data>
  <data name="Pick_members_to_be_used_in_Equals_GetHashCode" xml:space="preserve">
    <value>Pick members to be used in Equals/GetHashCode</value>
  </data>
  <data name="Generate_overrides" xml:space="preserve">
    <value>Generate overrides...</value>
  </data>
  <data name="Pick_members_to_override" xml:space="preserve">
    <value>Pick members to override</value>
  </data>
  <data name="Add_null_check" xml:space="preserve">
    <value>Add null check</value>
  </data>
  <data name="Add_string_IsNullOrEmpty_check" xml:space="preserve">
    <value>Add 'string.IsNullOrEmpty' check</value>
  </data>
  <data name="Add_string_IsNullOrWhiteSpace_check" xml:space="preserve">
    <value>Add 'string.IsNullOrWhiteSpace' check</value>
  </data>
  <data name="Create_and_assign_field_0" xml:space="preserve">
    <value>Create and assign field '{0}'</value>
  </data>
  <data name="Create_and_assign_property_0" xml:space="preserve">
    <value>Create and assign property '{0}'</value>
  </data>
  <data name="Initialize_field_0" xml:space="preserve">
    <value>Initialize field '{0}'</value>
  </data>
  <data name="Initialize_property_0" xml:space="preserve">
    <value>Initialize property '{0}'</value>
  </data>
  <data name="Add_null_checks" xml:space="preserve">
    <value>Add null checks</value>
  </data>
  <data name="Generate_operators" xml:space="preserve">
    <value>Generate operators</value>
  </data>
  <data name="Implement_0" xml:space="preserve">
    <value>Implement {0}</value>
  </data>
  <data name="Reported_diagnostic_0_has_a_source_location_in_file_1_which_is_not_part_of_the_compilation_being_analyzed" xml:space="preserve">
    <value>Reported diagnostic '{0}' has a source location in file '{1}', which is not part of the compilation being analyzed.</value>
  </data>
  <data name="Reported_diagnostic_0_has_a_source_location_1_in_file_2_which_is_outside_of_the_given_file" xml:space="preserve">
    <value>Reported diagnostic '{0}' has a source location '{1}' in file '{2}', which is outside of the given file.</value>
  </data>
  <data name="in_0_project_1" xml:space="preserve">
    <value>in {0} (project {1})</value>
  </data>
  <data name="Move_declaration_near_reference" xml:space="preserve">
    <value>Move declaration near reference</value>
  </data>
  <data name="Convert_to_full_property" xml:space="preserve">
    <value>Convert to full property</value>
  </data>
  <data name="Warning_Method_overrides_symbol_from_metadata" xml:space="preserve">
    <value>Warning: Method overrides symbol from metadata</value>
  </data>
  <data name="Use_0" xml:space="preserve">
    <value>Use {0}</value>
  </data>
  <data name="Switching_between_lambda_and_local_function_requires_restarting_the_application" xml:space="preserve">
    <value>Switching between a lambda and a local function requires restarting the application.</value>
  </data>
  <data name="Add_argument_name_0_including_trailing_arguments" xml:space="preserve">
    <value>Add argument name '{0}' (including trailing arguments)</value>
  </data>
  <data name="local_function" xml:space="preserve">
    <value>local function</value>
  </data>
  <data name="indexer_" xml:space="preserve">
    <value>indexer</value>
  </data>
  <data name="Warning_colon_Collection_was_modified_during_iteration" xml:space="preserve">
    <value>Warning: Collection was modified during iteration.</value>
  </data>
  <data name="Warning_colon_Iteration_variable_crossed_function_boundary" xml:space="preserve">
    <value>Warning: Iteration variable crossed function boundary.</value>
  </data>
  <data name="Convert_to_linq" xml:space="preserve">
    <value>Convert to LINQ</value>
  </data>
  <data name="Convert_to_class" xml:space="preserve">
    <value>Convert to class</value>
  </data>
  <data name="Convert_to_struct" xml:space="preserve">
    <value>Convert to struct</value>
  </data>
  <data name="updating_usages_in_containing_member" xml:space="preserve">
    <value>updating usages in containing member</value>
  </data>
  <data name="updating_usages_in_containing_project" xml:space="preserve">
    <value>updating usages in containing project</value>
  </data>
  <data name="updating_usages_in_containing_type" xml:space="preserve">
    <value>updating usages in containing type</value>
  </data>
  <data name="updating_usages_in_dependent_projects" xml:space="preserve">
    <value>updating usages in dependent projects</value>
  </data>
  <data name="Formatting_document" xml:space="preserve">
    <value>Formatting document</value>
  </data>
  <data name="Convert_to_linq_call_form" xml:space="preserve">
    <value>Convert to LINQ (call form)</value>
  </data>
  <data name="Adding_a_method_with_an_explicit_interface_specifier_requires_restarting_the_application" xml:space="preserve">
    <value>Adding a method with an explicit interface specifier requires restarting the application.</value>
  </data>
  <data name="Modifying_source_file_0_requires_restarting_the_application_due_to_internal_error_1" xml:space="preserve">
    <value>Modifying source file '{0}' requires restarting the application due to internal error: {1}</value>
    <comment>{2} is a multi-line exception message including a stacktrace. Place it at the end of the message and don't add any punctation after or around {1}</comment>
  </data>
  <data name="Modifying_source_file_0_requires_restarting_the_application_because_the_file_is_too_big" xml:space="preserve">
    <value>Modifying source file '{0}' requires restarting the application because the file is too big.</value>
  </data>
  <data name="Modifying_body_of_0_requires_restarting_the_application_due_to_internal_error_1" xml:space="preserve">
    <value>Modifying the body of {0} requires restarting the application due to internal error: {1}</value>
    <comment>{1} is a multi-line exception message including a stacktrace. Place it at the end of the message and don't add any punctation after or around {1}</comment>
  </data>
  <data name="Modifying_body_of_0_requires_restarting_the_application_because_the_body_has_too_many_statements" xml:space="preserve">
    <value>Modifying the body of {0} requires restarting the application because the body has too many statements.</value>
  </data>
  <data name="Change_namespace_to_0" xml:space="preserve">
    <value>Change namespace to '{0}'</value>
  </data>
  <data name="Move_file_to_0" xml:space="preserve">
    <value>Move file to '{0}'</value>
  </data>
  <data name="Move_file_to_project_root_folder" xml:space="preserve">
    <value>Move file to project root folder</value>
  </data>
  <data name="Move_to_namespace" xml:space="preserve">
    <value>Move to namespace...</value>
  </data>
  <data name="Change_to_global_namespace" xml:space="preserve">
    <value>Change to global namespace</value>
  </data>
  <data name="Warning_colon_changing_namespace_may_produce_invalid_code_and_change_code_meaning" xml:space="preserve">
    <value>Warning: Changing namespace may produce invalid code and change code meaning.</value>
  </data>
  <data name="Invert_conditional" xml:space="preserve">
    <value>Invert conditional</value>
  </data>
  <data name="Replace_0_with_1" xml:space="preserve">
    <value>Replace '{0}' with '{1}' </value>
  </data>
  <data name="Align_wrapped_parameters" xml:space="preserve">
    <value>Align wrapped parameters</value>
  </data>
  <data name="Indent_all_parameters" xml:space="preserve">
    <value>Indent all parameters</value>
  </data>
  <data name="Indent_wrapped_parameters" xml:space="preserve">
    <value>Indent wrapped parameters</value>
  </data>
  <data name="Unwrap_all_parameters" xml:space="preserve">
    <value>Unwrap all parameters</value>
  </data>
  <data name="Unwrap_and_indent_all_parameters" xml:space="preserve">
    <value>Unwrap and indent all parameters</value>
  </data>
  <data name="Wrap_every_parameter" xml:space="preserve">
    <value>Wrap every parameter</value>
  </data>
  <data name="Wrap_long_parameter_list" xml:space="preserve">
    <value>Wrap long parameter list</value>
  </data>
  <data name="Unwrap_parameter_list" xml:space="preserve">
    <value>Unwrap parameter list</value>
  </data>
  <data name="Align_wrapped_arguments" xml:space="preserve">
    <value>Align wrapped arguments</value>
  </data>
  <data name="Indent_all_arguments" xml:space="preserve">
    <value>Indent all arguments</value>
  </data>
  <data name="Indent_wrapped_arguments" xml:space="preserve">
    <value>Indent wrapped arguments</value>
  </data>
  <data name="Unwrap_all_arguments" xml:space="preserve">
    <value>Unwrap all arguments</value>
  </data>
  <data name="Unwrap_and_indent_all_arguments" xml:space="preserve">
    <value>Unwrap and indent all arguments</value>
  </data>
  <data name="Wrap_every_argument" xml:space="preserve">
    <value>Wrap every argument</value>
  </data>
  <data name="Wrap_long_argument_list" xml:space="preserve">
    <value>Wrap long argument list</value>
  </data>
  <data name="Unwrap_argument_list" xml:space="preserve">
    <value>Unwrap argument list</value>
  </data>
  <data name="Introduce_constant" xml:space="preserve">
    <value>Introduce constant</value>
  </data>
  <data name="Introduce_field" xml:space="preserve">
    <value>Introduce field</value>
  </data>
  <data name="Introduce_local" xml:space="preserve">
    <value>Introduce local</value>
  </data>
  <data name="Introduce_query_variable" xml:space="preserve">
    <value>Introduce query variable</value>
  </data>
  <data name="Failed_to_analyze_data_flow_for_0" xml:space="preserve">
    <value>Failed to analyze data-flow for: {0}</value>
  </data>
  <data name="Split_into_nested_0_statements" xml:space="preserve">
    <value>Split into nested '{0}' statements</value>
  </data>
  <data name="Merge_with_outer_0_statement" xml:space="preserve">
    <value>Merge with outer '{0}' statement</value>
  </data>
  <data name="Split_into_consecutive_0_statements" xml:space="preserve">
    <value>Split into consecutive '{0}' statements</value>
  </data>
  <data name="Merge_with_previous_0_statement" xml:space="preserve">
    <value>Merge with previous '{0}' statement</value>
  </data>
  <data name="Unwrap_expression" xml:space="preserve">
    <value>Unwrap expression</value>
  </data>
  <data name="Wrap_expression" xml:space="preserve">
    <value>Wrap expression</value>
  </data>
  <data name="Wrapping" xml:space="preserve">
    <value>Wrapping</value>
  </data>
  <data name="Merge_with_nested_0_statement" xml:space="preserve">
    <value>Merge with nested '{0}' statement</value>
  </data>
  <data name="Merge_with_next_0_statement" xml:space="preserve">
    <value>Merge with next '{0}' statement</value>
  </data>
  <data name="Pull_0_up" xml:space="preserve">
    <value>Pull '{0}' up</value>
  </data>
  <data name="Pull_members_up_to_base_type" xml:space="preserve">
    <value>Pull members up to base type...</value>
  </data>
  <data name="Unwrap_call_chain" xml:space="preserve">
    <value>Unwrap call chain</value>
  </data>
  <data name="Wrap_call_chain" xml:space="preserve">
    <value>Wrap call chain</value>
  </data>
  <data name="Wrap_long_call_chain" xml:space="preserve">
    <value>Wrap long call chain</value>
  </data>
  <data name="Pull_0_up_to_1" xml:space="preserve">
    <value>Pull '{0}' up to '{1}'</value>
  </data>
  <data name="Wrap_and_align_expression" xml:space="preserve">
    <value>Wrap and align expression</value>
  </data>
  <data name="Move_contents_to_namespace" xml:space="preserve">
    <value>Move contents to namespace...</value>
  </data>
  <data name="Add_optional_parameter_to_constructor" xml:space="preserve">
    <value>Add optional parameter to constructor</value>
  </data>
  <data name="Add_parameter_to_constructor" xml:space="preserve">
    <value>Add parameter to constructor</value>
  </data>
  <data name="Target_type_matches" xml:space="preserve">
    <value>Target type matches</value>
  </data>
  <data name="Generate_parameter_0" xml:space="preserve">
    <value>Generate parameter '{0}'</value>
  </data>
  <data name="Generate_parameter_0_and_overrides_implementations" xml:space="preserve">
    <value>Generate parameter '{0}' (and overrides/implementations)</value>
  </data>
  <data name="in_Source_attribute" xml:space="preserve">
    <value>in Source (attribute)</value>
  </data>
  <data name="StreamMustSupportReadAndSeek" xml:space="preserve">
    <value>Stream must support read and seek operations.</value>
  </data>
  <data name="MethodMustReturnStreamThatSupportsReadAndSeek" xml:space="preserve">
    <value>{0} must return a stream that supports read and seek operations.</value>
  </data>
  <data name="RudeEdit" xml:space="preserve">
    <value>Rude edit</value>
  </data>
  <data name="CannotApplyChangesUnexpectedError" xml:space="preserve">
    <value>Cannot apply changes -- unexpected error: '{0}'</value>
  </data>
  <data name="ErrorReadingFile" xml:space="preserve">
    <value>Error while reading file '{0}': {1}</value>
  </data>
  <data name="EditAndContinueDisallowedByProject" xml:space="preserve">
    <value>Changes made in project '{0}' require restarting the application: {1}</value>
  </data>
  <data name="DocumentIsOutOfSyncWithDebuggee" xml:space="preserve">
    <value>The current content of source file '{0}' does not match the built source. Any changes made to this file while debugging won't be applied until its content matches the built source.</value>
  </data>
  <data name="UnableToReadSourceFileOrPdb" xml:space="preserve">
    <value>Unable to read source file '{0}' or the PDB built for the containing project. Any changes made to this file while debugging won't be applied until its content matches the built source.</value>
  </data>
  <data name="ChangesDisallowedWhileStoppedAtException" xml:space="preserve">
    <value>Changes are not allowed while stopped at exception</value>
  </data>
  <data name="Wrap_and_align_call_chain" xml:space="preserve">
    <value>Wrap and align call chain</value>
  </data>
  <data name="Wrap_and_align_long_call_chain" xml:space="preserve">
    <value>Wrap and align long call chain</value>
  </data>
  <data name="Warning_colon_semantics_may_change_when_converting_statement" xml:space="preserve">
    <value>Warning: Semantics may change when converting statement.</value>
  </data>
  <data name="Add_null_checks_for_all_parameters" xml:space="preserve">
    <value>Add null checks for all parameters</value>
  </data>
  <data name="Implement_0_implicitly" xml:space="preserve">
    <value>Implement '{0}' implicitly</value>
  </data>
  <data name="Implement_all_interfaces_implicitly" xml:space="preserve">
    <value>Implement all interfaces implicitly</value>
  </data>
  <data name="Implement_implicitly" xml:space="preserve">
    <value>Implement implicitly</value>
  </data>
  <data name="Implement_0_explicitly" xml:space="preserve">
    <value>Implement '{0}' explicitly</value>
  </data>
  <data name="ChangeSignature_NewParameterIntroduceTODOVariable" xml:space="preserve">
    <value>TODO</value>
    <comment>"TODO" is an indication that there is work still to be done.</comment>
  </data>
  <data name="ChangeSignature_NewParameterOmitValue" xml:space="preserve">
    <value>&lt;omit&gt;</value>
  </data>
  <data name="Value_colon" xml:space="preserve">
    <value>Value:</value>
  </data>
  <data name="Implement_through_0" xml:space="preserve">
    <value>Implement through '{0}'</value>
  </data>
  <data name="Implement_all_interfaces_explicitly" xml:space="preserve">
    <value>Implement all interfaces explicitly</value>
  </data>
  <data name="Implement_explicitly" xml:space="preserve">
    <value>Implement explicitly</value>
  </data>
  <data name="Resolve_conflict_markers" xml:space="preserve">
    <value>Resolve conflict markers</value>
  </data>
  <data name="Base_classes_contain_inaccessible_unimplemented_members" xml:space="preserve">
    <value>Base classes contain inaccessible unimplemented members</value>
  </data>
  <data name="Add_DebuggerDisplay_attribute" xml:space="preserve">
    <value>Add 'DebuggerDisplay' attribute</value>
    <comment>{Locked="DebuggerDisplay"} "DebuggerDisplay" is a BCL class and should not be localized.</comment>
  </data>
  <data name="Do_not_change_this_code_Put_cleanup_code_in_0_method" xml:space="preserve">
    <value>Do not change this code. Put cleanup code in '{0}' method</value>
  </data>
  <data name="TODO_colon_free_unmanaged_resources_unmanaged_objects_and_override_finalizer" xml:space="preserve">
    <value>TODO: free unmanaged resources (unmanaged objects) and override finalizer</value>
  </data>
  <data name="TODO_colon_override_finalizer_only_if_0_has_code_to_free_unmanaged_resources" xml:space="preserve">
    <value>TODO: override finalizer only if '{0}' has code to free unmanaged resources</value>
  </data>
  <data name="AM_PM_abbreviated" xml:space="preserve">
    <value>AM/PM (abbreviated)</value>
  </data>
  <data name="AM_PM_abbreviated_description" xml:space="preserve">
    <value>The "t" custom format specifier represents the first character of the AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property of the current or specific culture. The AM designator is used for all times from 0:00:00 (midnight) to 11:59:59.999. The PM designator is used for all times from 12:00:00 (noon) to 23:59:59.999.

If the "t" format specifier is used without other custom format specifiers, it's interpreted as the "t" standard date and time format specifier.</value>
  </data>
  <data name="AM_PM_full" xml:space="preserve">
    <value>AM/PM (full)</value>
  </data>
  <data name="AM_PM_full_description" xml:space="preserve">
    <value>The "tt" custom format specifier (plus any number of additional "t" specifiers) represents the entire AM/PM designator. The appropriate localized designator is retrieved from the DateTimeFormatInfo.AMDesignator or DateTimeFormatInfo.PMDesignator property of the current or specific culture. The AM designator is used for all times from 0:00:00 (midnight) to 11:59:59.999. The PM designator is used for all times from 12:00:00 (noon) to 23:59:59.999.

Make sure to use the "tt" specifier for languages for which it's necessary to maintain the distinction between AM and PM. An example is Japanese, for which the AM and PM designators differ in the second character instead of the first character.</value>
  </data>
  <data name="date_separator" xml:space="preserve">
    <value>date separator</value>
  </data>
  <data name="date_separator_description" xml:space="preserve">
    <value>The "/" custom format specifier represents the date separator, which is used to differentiate years, months, and days. The appropriate localized date separator is retrieved from the DateTimeFormatInfo.DateSeparator property of the current or specified culture.

Note: To change the date separator for a particular date and time string, specify the separator character within a literal string delimiter. For example, the custom format string mm'/'dd'/'yyyy produces a result string in which "/" is always used as the date separator. To change the date separator for all dates for a culture, either change the value of the DateTimeFormatInfo.DateSeparator property of the current culture, or instantiate a DateTimeFormatInfo object, assign the character to its DateSeparator property, and call an overload of the formatting method that includes an IFormatProvider parameter.

If the "/" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</value>
  </data>
  <data name="day_of_the_month_1_2_digits" xml:space="preserve">
    <value>day of the month (1-2 digits)</value>
  </data>
  <data name="day_of_the_month_1_2_digits_description" xml:space="preserve">
    <value>The "d" custom format specifier represents the day of the month as a number from 1 through 31. A single-digit day is formatted without a leading zero.

If the "d" format specifier is used without other custom format specifiers, it's interpreted as the "d" standard date and time format specifier.</value>
  </data>
  <data name="day_of_the_month_2_digits" xml:space="preserve">
    <value>day of the month (2 digits)</value>
  </data>
  <data name="day_of_the_month_2_digits_description" xml:space="preserve">
    <value>The "dd" custom format string represents the day of the month as a number from 01 through 31. A single-digit day is formatted with a leading zero.</value>
  </data>
  <data name="day_of_the_week_abbreviated" xml:space="preserve">
    <value>day of the week (abbreviated)</value>
  </data>
  <data name="day_of_the_week_abbreviated_description" xml:space="preserve">
    <value>The "ddd" custom format specifier represents the abbreviated name of the day of the week. The localized abbreviated name of the day of the week is retrieved from the DateTimeFormatInfo.AbbreviatedDayNames property of the current or specified culture.</value>
  </data>
  <data name="day_of_the_week_full" xml:space="preserve">
    <value>day of the week (full)</value>
  </data>
  <data name="day_of_the_week_full_description" xml:space="preserve">
    <value>The "dddd" custom format specifier (plus any number of additional "d" specifiers) represents the full name of the day of the week. The localized name of the day of the week is retrieved from the DateTimeFormatInfo.DayNames property of the current or specified culture.</value>
  </data>
  <data name="full_long_date_time" xml:space="preserve">
    <value>full long date/time</value>
  </data>
  <data name="full_long_date_time_description" xml:space="preserve">
    <value>The "F" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.FullDateTimePattern property. For example, the custom format string for the invariant culture is "dddd, dd MMMM yyyy HH:mm:ss".</value>
  </data>
  <data name="full_short_date_time" xml:space="preserve">
    <value>full short date/time</value>
  </data>
  <data name="full_short_date_time_description" xml:space="preserve">
    <value>The Full Date Short Time ("f") Format Specifier

The "f" standard format specifier represents a combination of the long date ("D") and short time ("t") patterns, separated by a space.</value>
  </data>
  <data name="general_long_date_time" xml:space="preserve">
    <value>general long date/time</value>
  </data>
  <data name="general_long_date_time_description" xml:space="preserve">
    <value>The "G" standard format specifier represents a combination of the short date ("d") and long time ("T") patterns, separated by a space.</value>
  </data>
  <data name="general_short_date_time" xml:space="preserve">
    <value>general short date/time</value>
  </data>
  <data name="general_short_date_time_description" xml:space="preserve">
    <value>The "g" standard format specifier represents a combination of the short date ("d") and short time ("t") patterns, separated by a space.</value>
  </data>
  <data name="long_date" xml:space="preserve">
    <value>long date</value>
  </data>
  <data name="long_date_description" xml:space="preserve">
    <value>The "D" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.LongDatePattern property. For example, the custom format string for the invariant culture is "dddd, dd MMMM yyyy".</value>
  </data>
  <data name="long_time" xml:space="preserve">
    <value>long time</value>
  </data>
  <data name="long_time_description" xml:space="preserve">
    <value>The "T" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.LongTimePattern property. For example, the custom format string for the invariant culture is "HH:mm:ss".</value>
  </data>
  <data name="minute_1_2_digits" xml:space="preserve">
    <value>minute (1-2 digits)</value>
  </data>
  <data name="minute_1_2_digits_description" xml:space="preserve">
    <value>The "m" custom format specifier represents the minute as a number from 0 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted without a leading zero.

If the "m" format specifier is used without other custom format specifiers, it's interpreted as the "m" standard date and time format specifier.</value>
  </data>
  <data name="minute_2_digits" xml:space="preserve">
    <value>minute (2 digits)</value>
  </data>
  <data name="minute_2_digits_description" xml:space="preserve">
    <value>The "mm" custom format specifier (plus any number of additional "m" specifiers) represents the minute as a number from 00 through 59. The minute represents whole minutes that have passed since the last hour. A single-digit minute is formatted with a leading zero.</value>
  </data>
  <data name="month_1_2_digits" xml:space="preserve">
    <value>month (1-2 digits)</value>
  </data>
  <data name="month_1_2_digits_description" xml:space="preserve">
    <value>The "M" custom format specifier represents the month as a number from 1 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted without a leading zero.

If the "M" format specifier is used without other custom format specifiers, it's interpreted as the "M" standard date and time format specifier.</value>
  </data>
  <data name="month_2_digits" xml:space="preserve">
    <value>month (2 digits)</value>
  </data>
  <data name="month_2_digits_description" xml:space="preserve">
    <value>The "MM" custom format specifier represents the month as a number from 01 through 12 (or from 1 through 13 for calendars that have 13 months). A single-digit month is formatted with a leading zero.</value>
  </data>
  <data name="month_abbreviated" xml:space="preserve">
    <value>month (abbreviated)</value>
  </data>
  <data name="month_abbreviated_description" xml:space="preserve">
    <value>The "MMM" custom format specifier represents the abbreviated name of the month. The localized abbreviated name of the month is retrieved from the DateTimeFormatInfo.AbbreviatedMonthNames property of the current or specified culture.</value>
  </data>
  <data name="month_day" xml:space="preserve">
    <value>month day</value>
  </data>
  <data name="month_day_description" xml:space="preserve">
    <value>The "M" or "m" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.MonthDayPattern property. For example, the custom format string for the invariant culture is "MMMM dd".</value>
  </data>
  <data name="month_full" xml:space="preserve">
    <value>month (full)</value>
  </data>
  <data name="month_full_description" xml:space="preserve">
    <value>The "MMMM" custom format specifier represents the full name of the month. The localized name of the month is retrieved from the DateTimeFormatInfo.MonthNames property of the current or specified culture.</value>
  </data>
  <data name="period_era" xml:space="preserve">
    <value>period/era</value>
  </data>
  <data name="period_era_description" xml:space="preserve">
    <value>The "g" or "gg" custom format specifiers (plus any number of additional "g" specifiers) represents the period or era, such as A.D. The formatting operation ignores this specifier if the date to be formatted doesn't have an associated period or era string.

If the "g" format specifier is used without other custom format specifiers, it's interpreted as the "g" standard date and time format specifier.</value>
  </data>
  <data name="rfc1123_date_time" xml:space="preserve">
    <value>rfc1123 date/time</value>
  </data>
  <data name="rfc1123_date_time_description" xml:space="preserve">
    <value>The "R" or "r" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.RFC1123Pattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "ddd, dd MMM yyyy HH':'mm':'ss 'GMT'". When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.</value>
  </data>
  <data name="round_trip_date_time" xml:space="preserve">
    <value>round-trip date/time</value>
  </data>
  <data name="round_trip_date_time_description" xml:space="preserve">
    <value>The "O" or "o" standard format specifier represents a custom date and time format string using a pattern that preserves time zone information and emits a result string that complies with ISO 8601. For DateTime values, this format specifier is designed to preserve date and time values along with the DateTime.Kind property in text. The formatted string can be parsed back by using the DateTime.Parse(String, IFormatProvider, DateTimeStyles) or DateTime.ParseExact method if the styles parameter is set to DateTimeStyles.RoundtripKind.

The "O" or "o" standard format specifier corresponds to the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" custom format string for DateTime values and to the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffzzz" custom format string for DateTimeOffset values. In this string, the pairs of single quotation marks that delimit individual characters, such as the hyphens, the colons, and the letter "T", indicate that the individual character is a literal that cannot be changed. The apostrophes do not appear in the output string.

The "O" or "o" standard format specifier (and the "yyyy'-'MM'-'dd'T'HH':'mm':'ss'.'fffffffK" custom format string) takes advantage of the three ways that ISO 8601 represents time zone information to preserve the Kind property of DateTime values:

    The time zone component of DateTimeKind.Local date and time values is an offset from UTC (for example, +01:00, -07:00). All DateTimeOffset values are also represented in this format.

    The time zone component of DateTimeKind.Utc date and time values uses "Z" (which stands for zero offset) to represent UTC.

    DateTimeKind.Unspecified date and time values have no time zone information.

Because the "O" or "o" standard format specifier conforms to an international standard, the formatting or parsing operation that uses the specifier always uses the invariant culture and the Gregorian calendar.

Strings that are passed to the Parse, TryParse, ParseExact, and TryParseExact methods of DateTime and DateTimeOffset can be parsed by using the "O" or "o" format specifier if they are in one of these formats. In the case of DateTime objects, the parsing overload that you call should also include a styles parameter with a value of DateTimeStyles.RoundtripKind. Note that if you call a parsing method with the custom format string that corresponds to the "O" or "o" format specifier, you won't get the same results as "O" or "o". This is because parsing methods that use a custom format string can't parse the string representation of date and time values that lack a time zone component or use "Z" to indicate UTC.</value>
  </data>
  <data name="second_1_2_digits" xml:space="preserve">
    <value>second (1-2 digits)</value>
  </data>
  <data name="second_1_2_digits_description" xml:space="preserve">
    <value>The "s" custom format specifier represents the seconds as a number from 0 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted without a leading zero.

If the "s" format specifier is used without other custom format specifiers, it's interpreted as the "s" standard date and time format specifier.</value>
  </data>
  <data name="second_2_digits" xml:space="preserve">
    <value>second (2 digits)</value>
  </data>
  <data name="second_2_digits_description" xml:space="preserve">
    <value>The "ss" custom format specifier (plus any number of additional "s" specifiers) represents the seconds as a number from 00 through 59. The result represents whole seconds that have passed since the last minute. A single-digit second is formatted with a leading zero.</value>
  </data>
  <data name="short_date" xml:space="preserve">
    <value>short date</value>
  </data>
  <data name="short_date_description" xml:space="preserve">
    <value>The "d" standard format specifier represents a custom date and time format string that is defined by a specific culture's DateTimeFormatInfo.ShortDatePattern property. For example, the custom format string that is returned by the ShortDatePattern property of the invariant culture is "MM/dd/yyyy".</value>
  </data>
  <data name="short_time" xml:space="preserve">
    <value>short time</value>
  </data>
  <data name="short_time_description" xml:space="preserve">
    <value>The "t" standard format specifier represents a custom date and time format string that is defined by the current DateTimeFormatInfo.ShortTimePattern property. For example, the custom format string for the invariant culture is "HH:mm".</value>
  </data>
  <data name="sortable_date_time" xml:space="preserve">
    <value>sortable date/time</value>
  </data>
  <data name="sortable_date_time_description" xml:space="preserve">
    <value>The "s" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.SortableDateTimePattern property. The pattern reflects a defined standard (ISO 8601), and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "yyyy'-'MM'-'dd'T'HH':'mm':'ss".

The purpose of the "s" format specifier is to produce result strings that sort consistently in ascending or descending order based on date and time values. As a result, although the "s" standard format specifier represents a date and time value in a consistent format, the formatting operation does not modify the value of the date and time object that is being formatted to reflect its DateTime.Kind property or its DateTimeOffset.Offset value. For example, the result strings produced by formatting the date and time values 2014-11-15T18:32:17+00:00 and 2014-11-15T18:32:17+08:00 are identical.

When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.</value>
  </data>
  <data name="time_separator" xml:space="preserve">
    <value>time separator</value>
  </data>
  <data name="time_separator_description" xml:space="preserve">
    <value>The ":" custom format specifier represents the time separator, which is used to differentiate hours, minutes, and seconds. The appropriate localized time separator is retrieved from the DateTimeFormatInfo.TimeSeparator property of the current or specified culture.

Note: To change the time separator for a particular date and time string, specify the separator character within a literal string delimiter. For example, the custom format string hh'_'dd'_'ss produces a result string in which "_" (an underscore) is always used as the time separator. To change the time separator for all dates for a culture, either change the value of the DateTimeFormatInfo.TimeSeparator property of the current culture, or instantiate a DateTimeFormatInfo object, assign the character to its TimeSeparator property, and call an overload of the formatting method that includes an IFormatProvider parameter.

If the ":" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</value>
  </data>
  <data name="time_zone" xml:space="preserve">
    <value>time zone</value>
  </data>
  <data name="time_zone_description" xml:space="preserve">
    <value>The "K" custom format specifier represents the time zone information of a date and time value. When this format specifier is used with DateTime values, the result string is defined by the value of the DateTime.Kind property:

    For the local time zone (a DateTime.Kind property value of DateTimeKind.Local), this specifier is equivalent to the "zzz" specifier and produces a result string containing the local offset from Coordinated Universal Time (UTC); for example, "-07:00".

    For a UTC time (a DateTime.Kind property value of DateTimeKind.Utc), the result string includes a "Z" character to represent a UTC date.

    For a time from an unspecified time zone (a time whose DateTime.Kind property equals DateTimeKind.Unspecified), the result is equivalent to String.Empty.

For DateTimeOffset values, the "K" format specifier is equivalent to the "zzz" format specifier, and produces a result string containing the DateTimeOffset value's offset from UTC.

If the "K" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</value>
  </data>
  <data name="universal_full_date_time" xml:space="preserve">
    <value>universal full date/time</value>
  </data>
  <data name="universal_full_date_time_description" xml:space="preserve">
    <value>The "U" standard format specifier represents a custom date and time format string that is defined by a specified culture's DateTimeFormatInfo.FullDateTimePattern property. The pattern is the same as the "F" pattern. However, the DateTime value is automatically converted to UTC before it is formatted.</value>
  </data>
  <data name="universal_sortable_date_time" xml:space="preserve">
    <value>universal sortable date/time</value>
  </data>
  <data name="universal_sortable_date_time_description" xml:space="preserve">
    <value>The "u" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.UniversalSortableDateTimePattern property. The pattern reflects a defined standard, and the property is read-only. Therefore, it is always the same, regardless of the culture used or the format provider supplied. The custom format string is "yyyy'-'MM'-'dd HH':'mm':'ss'Z'". When this standard format specifier is used, the formatting or parsing operation always uses the invariant culture.

Although the result string should express a time as Coordinated Universal Time (UTC), no conversion of the original DateTime value is performed during the formatting operation. Therefore, you must convert a DateTime value to UTC by calling the DateTime.ToUniversalTime method before formatting it.</value>
  </data>
  <data name="utc_hour_and_minute_offset" xml:space="preserve">
    <value>utc hour and minute offset</value>
  </data>
  <data name="utc_hour_and_minute_offset_description" xml:space="preserve">
    <value>With DateTime values, the "zzz" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours and minutes. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "zzz" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours and minutes.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted with a leading zero.</value>
  </data>
  <data name="utc_hour_offset_1_2_digits" xml:space="preserve">
    <value>utc hour offset (1-2 digits)</value>
  </data>
  <data name="utc_hour_offset_1_2_digits_description" xml:space="preserve">
    <value>With DateTime values, the "z" custom format specifier represents the signed offset of the local operating system's time zone from Coordinated Universal Time (UTC), measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "z" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted without a leading zero.

If the "z" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</value>
  </data>
  <data name="utc_hour_offset_2_digits" xml:space="preserve">
    <value>utc hour offset (2 digits)</value>
  </data>
  <data name="utc_hour_offset_2_digits_description" xml:space="preserve">
    <value>With DateTime values, the "zz" custom format specifier represents the signed offset of the local operating system's time zone from UTC, measured in hours. It doesn't reflect the value of an instance's DateTime.Kind property. For this reason, the "zz" format specifier is not recommended for use with DateTime values.

With DateTimeOffset values, this format specifier represents the DateTimeOffset value's offset from UTC in hours.

The offset is always displayed with a leading sign. A plus sign (+) indicates hours ahead of UTC, and a minus sign (-) indicates hours behind UTC. A single-digit offset is formatted with a leading zero.</value>
  </data>
  <data name="year_1_2_digits" xml:space="preserve">
    <value>year (1-2 digits)</value>
  </data>
  <data name="year_1_2_digits_description" xml:space="preserve">
    <value>The "y" custom format specifier represents the year as a one-digit or two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the first digit of a two-digit year begins with a zero (for example, 2008), the number is formatted without a leading zero.

If the "y" format specifier is used without other custom format specifiers, it's interpreted as the "y" standard date and time format specifier.</value>
  </data>
  <data name="year_2_digits" xml:space="preserve">
    <value>year (2 digits)</value>
  </data>
  <data name="year_2_digits_description" xml:space="preserve">
    <value>The "yy" custom format specifier represents the year as a two-digit number. If the year has more than two digits, only the two low-order digits appear in the result. If the two-digit year has fewer than two significant digits, the number is padded with leading zeros to produce two digits.

In a parsing operation, a two-digit year that is parsed using the "yy" custom format specifier is interpreted based on the Calendar.TwoDigitYearMax property of the format provider's current calendar. The following example parses the string representation of a date that has a two-digit year by using the default Gregorian calendar of the en-US culture, which, in this case, is the current culture. It then changes the current culture's CultureInfo object to use a GregorianCalendar object whose TwoDigitYearMax property has been modified.</value>
  </data>
  <data name="year_3_4_digits" xml:space="preserve">
    <value>year (3-4 digits)</value>
  </data>
  <data name="year_3_4_digits_description" xml:space="preserve">
    <value>The "yyy" custom format specifier represents the year with a minimum of three digits. If the year has more than three significant digits, they are included in the result string. If the year has fewer than three digits, the number is padded with leading zeros to produce three digits.</value>
  </data>
  <data name="year_4_digits" xml:space="preserve">
    <value>year (4 digits)</value>
  </data>
  <data name="year_4_digits_description" xml:space="preserve">
    <value>The "yyyy" custom format specifier represents the year with a minimum of four digits. If the year has more than four significant digits, they are included in the result string. If the year has fewer than four digits, the number is padded with leading zeros to produce four digits.</value>
  </data>
  <data name="year_5_digits" xml:space="preserve">
    <value>year (5 digits)</value>
  </data>
  <data name="year_5_digits_description" xml:space="preserve">
    <value>The "yyyyy" custom format specifier (plus any number of additional "y" specifiers) represents the year with a minimum of five digits. If the year has more than five significant digits, they are included in the result string. If the year has fewer than five digits, the number is padded with leading zeros to produce five digits.

If there are additional "y" specifiers, the number is padded with as many leading zeros as necessary to produce the number of "y" specifiers.</value>
  </data>
  <data name="year_month" xml:space="preserve">
    <value>year month</value>
  </data>
  <data name="year_month_description" xml:space="preserve">
    <value>The "Y" or "y" standard format specifier represents a custom date and time format string that is defined by the DateTimeFormatInfo.YearMonthPattern property of a specified culture. For example, the custom format string for the invariant culture is "yyyy MMMM".</value>
  </data>
  <data name="_10000000ths_of_a_second" xml:space="preserve">
    <value>10,000,000ths of a second</value>
  </data>
  <data name="_10000000ths_of_a_second_description" xml:space="preserve">
    <value>The "fffffff" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value.

Although it's possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</value>
  </data>
  <data name="_10000000ths_of_a_second_non_zero" xml:space="preserve">
    <value>10,000,000ths of a second (non-zero)</value>
  </data>
  <data name="_10000000ths_of_a_second_non_zero_description" xml:space="preserve">
    <value>The "FFFFFFF" custom format specifier represents the seven most significant digits of the seconds fraction; that is, it represents the ten millionths of a second in a date and time value. However, trailing zeros or seven zero digits aren't displayed.

Although it's possible to display the ten millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</value>
  </data>
  <data name="_1000000ths_of_a_second" xml:space="preserve">
    <value>1,000,000ths of a second</value>
  </data>
  <data name="_1000000ths_of_a_second_description" xml:space="preserve">
    <value>The "ffffff" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value.

Although it's possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</value>
  </data>
  <data name="_1000000ths_of_a_second_non_zero" xml:space="preserve">
    <value>1,000,000ths of a second (non-zero)</value>
  </data>
  <data name="_1000000ths_of_a_second_non_zero_description" xml:space="preserve">
    <value>The "FFFFFF" custom format specifier represents the six most significant digits of the seconds fraction; that is, it represents the millionths of a second in a date and time value. However, trailing zeros or six zero digits aren't displayed.

Although it's possible to display the millionths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</value>
  </data>
  <data name="_100000ths_of_a_second" xml:space="preserve">
    <value>100,000ths of a second</value>
  </data>
  <data name="_100000ths_of_a_second_description" xml:space="preserve">
    <value>The "fffff" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value.

Although it's possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</value>
  </data>
  <data name="_100000ths_of_a_second_non_zero" xml:space="preserve">
    <value>100,000ths of a second (non-zero)</value>
  </data>
  <data name="_100000ths_of_a_second_non_zero_description" xml:space="preserve">
    <value>The "FFFFF" custom format specifier represents the five most significant digits of the seconds fraction; that is, it represents the hundred thousandths of a second in a date and time value. However, trailing zeros or five zero digits aren't displayed.

Although it's possible to display the hundred thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</value>
  </data>
  <data name="_10000ths_of_a_second" xml:space="preserve">
    <value>10,000ths of a second</value>
  </data>
  <data name="_10000ths_of_a_second_description" xml:space="preserve">
    <value>The "ffff" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value.

Although it's possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT version 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</value>
  </data>
  <data name="_10000ths_of_a_second_non_zero" xml:space="preserve">
    <value>10,000ths of a second (non-zero)</value>
  </data>
  <data name="_10000ths_of_a_second_non_zero_description" xml:space="preserve">
    <value>The "FFFF" custom format specifier represents the four most significant digits of the seconds fraction; that is, it represents the ten thousandths of a second in a date and time value. However, trailing zeros or four zero digits aren't displayed.

Although it's possible to display the ten thousandths of a second component of a time value, that value may not be meaningful. The precision of date and time values depends on the resolution of the system clock. On the Windows NT 3.5 (and later) and Windows Vista operating systems, the clock's resolution is approximately 10-15 milliseconds.</value>
  </data>
  <data name="_1000ths_of_a_second" xml:space="preserve">
    <value>1,000ths of a second</value>
  </data>
  <data name="_1000ths_of_a_second_description" xml:space="preserve">
    <value>The "fff" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value.</value>
  </data>
  <data name="_1000ths_of_a_second_non_zero" xml:space="preserve">
    <value>1,000ths of a second (non-zero)</value>
  </data>
  <data name="_1000ths_of_a_second_non_zero_description" xml:space="preserve">
    <value>The "FFF" custom format specifier represents the three most significant digits of the seconds fraction; that is, it represents the milliseconds in a date and time value. However, trailing zeros or three zero digits aren't displayed.</value>
  </data>
  <data name="_100ths_of_a_second" xml:space="preserve">
    <value>100ths of a second</value>
  </data>
  <data name="_100ths_of_a_second_description" xml:space="preserve">
    <value>The "ff" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value.</value>
  </data>
  <data name="_100ths_of_a_second_non_zero" xml:space="preserve">
    <value>100ths of a second (non-zero)</value>
  </data>
  <data name="_100ths_of_a_second_non_zero_description" xml:space="preserve">
    <value>The "FF" custom format specifier represents the two most significant digits of the seconds fraction; that is, it represents the hundredths of a second in a date and time value. However, trailing zeros or two zero digits aren't displayed.</value>
  </data>
  <data name="_10ths_of_a_second" xml:space="preserve">
    <value>10ths of a second</value>
  </data>
  <data name="_10ths_of_a_second_description" xml:space="preserve">
    <value>The "f" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value.

If the "f" format specifier is used without other format specifiers, it's interpreted as the "f" standard date and time format specifier.

When you use "f" format specifiers as part of a format string supplied to the ParseExact or TryParseExact method, the number of "f" format specifiers indicates the number of most significant digits of the seconds fraction that must be present to successfully parse the string.</value>
    <comment>{Locked="ParseExact"}{Locked="TryParseExact"}{Locked=""f""}</comment>
  </data>
  <data name="_10ths_of_a_second_non_zero" xml:space="preserve">
    <value>10ths of a second (non-zero)</value>
  </data>
  <data name="_10ths_of_a_second_non_zero_description" xml:space="preserve">
    <value>The "F" custom format specifier represents the most significant digit of the seconds fraction; that is, it represents the tenths of a second in a date and time value. Nothing is displayed if the digit is zero.

If the "F" format specifier is used without other format specifiers, it's interpreted as the "F" standard date and time format specifier.

The number of "F" format specifiers used with the ParseExact, TryParseExact, ParseExact, or TryParseExact method indicates the maximum number of most significant digits of the seconds fraction that can be present to successfully parse the string.</value>
  </data>
  <data name="_12_hour_clock_1_2_digits" xml:space="preserve">
    <value>12 hour clock (1-2 digits)</value>
  </data>
  <data name="_12_hour_clock_1_2_digits_description" xml:space="preserve">
    <value>The "h" custom format specifier represents the hour as a number from 1 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour after midnight is indistinguishable from the same hour after noon. The hour is not rounded, and a single-digit hour is formatted without a leading zero. For example, given a time of 5:43 in the morning or afternoon, this custom format specifier displays "5".

If the "h" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</value>
  </data>
  <data name="_12_hour_clock_2_digits" xml:space="preserve">
    <value>12 hour clock (2 digits)</value>
  </data>
  <data name="_12_hour_clock_2_digits_description" xml:space="preserve">
    <value>The "hh" custom format specifier (plus any number of additional "h" specifiers) represents the hour as a number from 01 through 12; that is, the hour is represented by a 12-hour clock that counts the whole hours since midnight or noon. A particular hour after midnight is indistinguishable from the same hour after noon. The hour is not rounded, and a single-digit hour is formatted with a leading zero. For example, given a time of 5:43 in the morning or afternoon, this format specifier displays "05".</value>
  </data>
  <data name="_24_hour_clock_1_2_digits" xml:space="preserve">
    <value>24 hour clock (1-2 digits)</value>
  </data>
  <data name="_24_hour_clock_1_2_digits_description" xml:space="preserve">
    <value>The "H" custom format specifier represents the hour as a number from 0 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is formatted without a leading zero.

If the "H" format specifier is used without other custom format specifiers, it's interpreted as a standard date and time format specifier and throws a FormatException.</value>
  </data>
  <data name="_24_hour_clock_2_digits" xml:space="preserve">
    <value>24 hour clock (2 digits)</value>
  </data>
  <data name="_24_hour_clock_2_digits_description" xml:space="preserve">
    <value>The "HH" custom format specifier (plus any number of additional "H" specifiers) represents the hour as a number from 00 through 23; that is, the hour is represented by a zero-based 24-hour clock that counts the hours since midnight. A single-digit hour is formatted with a leading zero.</value>
  </data>
  <data name="Implement_remaining_members_explicitly" xml:space="preserve">
    <value>Implement remaining members explicitly</value>
  </data>
  <data name="Generate_for_0" xml:space="preserve">
    <value>Generate for '{0}'</value>
  </data>
  <data name="Generate_comparison_operators" xml:space="preserve">
    <value>Generate comparison operators</value>
  </data>
  <data name="Create_and_assign_remaining_as_fields" xml:space="preserve">
    <value>Create and assign remaining as fields</value>
  </data>
  <data name="Create_and_assign_remaining_as_properties" xml:space="preserve">
    <value>Create and assign remaining as properties</value>
  </data>
  <data name="Example" xml:space="preserve">
    <value>Example:</value>
    <comment>Singular form when we want to show an example, but only have one to show.</comment>
  </data>
  <data name="Examples" xml:space="preserve">
    <value>Examples:</value>
    <comment>Plural form when we have multiple examples to show.</comment>
  </data>
  <data name="Alternation_conditions_cannot_be_comments" xml:space="preserve">
    <value>Alternation conditions cannot be comments</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: a|(?#b)</comment>
  </data>
  <data name="Alternation_conditions_do_not_capture_and_cannot_be_named" xml:space="preserve">
    <value>Alternation conditions do not capture and cannot be named</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(?'x'))</comment>
  </data>
  <data name="A_subtraction_must_be_the_last_element_in_a_character_class" xml:space="preserve">
    <value>A subtraction must be the last element in a character class</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-[b]-c]</comment>
  </data>
  <data name="Cannot_include_class_0_in_character_range" xml:space="preserve">
    <value>Cannot include class \{0} in character range</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-\w]. {0} is the invalid class (\w here)</comment>
  </data>
  <data name="Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue" xml:space="preserve">
    <value>Capture group numbers must be less than or equal to Int32.MaxValue</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{2147483648}</comment>
  </data>
  <data name="Capture_number_cannot_be_zero" xml:space="preserve">
    <value>Capture number cannot be zero</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;0&gt;a)</comment>
  </data>
  <data name="Illegal_backslash_at_end_of_pattern" xml:space="preserve">
    <value>Illegal \ at end of pattern</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \</comment>
  </data>
  <data name="Illegal_x_y_with_x_less_than_y" xml:space="preserve">
    <value>Illegal {x,y} with x &gt; y</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{1,0}</comment>
  </data>
  <data name="Incomplete_character_escape" xml:space="preserve">
    <value>Incomplete \p{X} character escape</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{ Cc }</comment>
  </data>
  <data name="Insufficient_hexadecimal_digits" xml:space="preserve">
    <value>Insufficient hexadecimal digits</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \x</comment>
  </data>
  <data name="Invalid_group_name_Group_names_must_begin_with_a_word_character" xml:space="preserve">
    <value>Invalid group name: Group names must begin with a word character</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;a &gt;a)</comment>
  </data>
  <data name="Malformed" xml:space="preserve">
    <value>malformed</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0</comment>
  </data>
  <data name="Malformed_character_escape" xml:space="preserve">
    <value>Malformed \p{X} character escape</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p {Cc}</comment>
  </data>
  <data name="Malformed_named_back_reference" xml:space="preserve">
    <value>Malformed \k&lt;...&gt; named back reference</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k'</comment>
  </data>
  <data name="Missing_control_character" xml:space="preserve">
    <value>Missing control character</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \c</comment>
  </data>
  <data name="Nested_quantifier_0" xml:space="preserve">
    <value>Nested quantifier {0}</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: a**. In this case {0} will be '*', the extra unnecessary quantifier.</comment>
  </data>
  <data name="Not_enough_close_parens" xml:space="preserve">
    <value>Not enough )'s</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (a</comment>
  </data>
  <data name="Quantifier_x_y_following_nothing" xml:space="preserve">
    <value>Quantifier {x,y} following nothing</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: *</comment>
  </data>
  <data name="Reference_to_undefined_group" xml:space="preserve">
    <value>reference to undefined group</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(1))</comment>
  </data>
  <data name="Reference_to_undefined_group_name_0" xml:space="preserve">
    <value>Reference to undefined group name {0}</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k&lt;a&gt;. Here, {0} will be the name of the undefined group ('a')</comment>
  </data>
  <data name="Reference_to_undefined_group_number_0" xml:space="preserve">
    <value>Reference to undefined group number {0}</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;-1&gt;). Here, {0} will be the number of the undefined group ('1')</comment>
  </data>
  <data name="Too_many_bars_in_conditional_grouping" xml:space="preserve">
    <value>Too many | in (?()|)</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0)a|b|)</comment>
  </data>
  <data name="Too_many_close_parens" xml:space="preserve">
    <value>Too many )'s</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: )</comment>
  </data>
  <data name="Unknown_property" xml:space="preserve">
    <value>Unknown property</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{}</comment>
  </data>
  <data name="Unknown_property_0" xml:space="preserve">
    <value>Unknown property '{0}'</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{xxx}. Here, {0} will be the name of the unknown property ('xxx')</comment>
  </data>
  <data name="Unrecognized_control_character" xml:space="preserve">
    <value>Unrecognized control character</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: [\c]</comment>
  </data>
  <data name="Unrecognized_escape_sequence_0" xml:space="preserve">
    <value>Unrecognized escape sequence \{0}</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: \m. Here, {0} will be the unrecognized character ('m')</comment>
  </data>
  <data name="Unrecognized_grouping_construct" xml:space="preserve">
    <value>Unrecognized grouping construct</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;</comment>
  </data>
  <data name="Unterminated_character_class_set" xml:space="preserve">
    <value>Unterminated [] set</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: [</comment>
  </data>
  <data name="Unterminated_regex_comment" xml:space="preserve">
    <value>Unterminated (?#...) comment</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?#</comment>
  </data>
  <data name="x_y_range_in_reverse_order" xml:space="preserve">
    <value>[x-y] range in reverse order</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. Example: [b-a]</comment>
  </data>
  <data name="Regex_issue_0" xml:space="preserve">
    <value>Regex issue: {0}</value>
    <comment>This is an error message shown to the user when they write an invalid Regular Expression. {0} will be the actual text of one of the above Regular Expression errors.</comment>
  </data>
  <data name="Regex_number_decimal_digit" xml:space="preserve">
    <value>number, decimal digit</value>
  </data>
  <data name="Regex_number_letter" xml:space="preserve">
    <value>number, letter</value>
  </data>
  <data name="Regex_number_other" xml:space="preserve">
    <value>number, other</value>
  </data>
  <data name="Regex_other_control" xml:space="preserve">
    <value>other, control</value>
  </data>
  <data name="Regex_other_format" xml:space="preserve">
    <value>other, format</value>
  </data>
  <data name="Regex_other_not_assigned" xml:space="preserve">
    <value>other, not assigned</value>
  </data>
  <data name="Regex_other_private_use" xml:space="preserve">
    <value>other, private use</value>
  </data>
  <data name="Regex_other_surrogate" xml:space="preserve">
    <value>other, surrogate</value>
  </data>
  <data name="Regex_punctuation_close" xml:space="preserve">
    <value>punctuation, close</value>
  </data>
  <data name="Regex_punctuation_connector" xml:space="preserve">
    <value>punctuation, connector</value>
  </data>
  <data name="Regex_punctuation_dash" xml:space="preserve">
    <value>punctuation, dash</value>
  </data>
  <data name="Regex_punctuation_final_quote" xml:space="preserve">
    <value>punctuation, final quote</value>
  </data>
  <data name="Regex_punctuation_initial_quote" xml:space="preserve">
    <value>punctuation, initial quote</value>
  </data>
  <data name="Regex_punctuation_open" xml:space="preserve">
    <value>punctuation, open</value>
  </data>
  <data name="Regex_punctuation_other" xml:space="preserve">
    <value>punctuation, other</value>
  </data>
  <data name="Regex_separator_line" xml:space="preserve">
    <value>separator, line</value>
  </data>
  <data name="Regex_separator_paragraph" xml:space="preserve">
    <value>separator, paragraph</value>
  </data>
  <data name="Regex_separator_space" xml:space="preserve">
    <value>separator, space</value>
  </data>
  <data name="Regex_symbol_currency" xml:space="preserve">
    <value>symbol, currency</value>
  </data>
  <data name="Regex_symbol_math" xml:space="preserve">
    <value>symbol, math</value>
  </data>
  <data name="Regex_symbol_modifier" xml:space="preserve">
    <value>symbol, modifier</value>
  </data>
  <data name="Regex_symbol_other" xml:space="preserve">
    <value>symbol, other</value>
  </data>
  <data name="Regex_letter_lowercase" xml:space="preserve">
    <value>letter, lowercase</value>
  </data>
  <data name="Regex_letter_modifier" xml:space="preserve">
    <value>letter, modifier</value>
  </data>
  <data name="Regex_letter_other" xml:space="preserve">
    <value>letter, other</value>
  </data>
  <data name="Regex_letter_titlecase" xml:space="preserve">
    <value>letter, titlecase</value>
  </data>
  <data name="Regex_mark_enclosing" xml:space="preserve">
    <value>mark, enclosing</value>
  </data>
  <data name="Regex_mark_nonspacing" xml:space="preserve">
    <value>mark, nonspacing</value>
  </data>
  <data name="Regex_mark_spacing_combining" xml:space="preserve">
    <value>mark, spacing combining</value>
  </data>
  <data name="Regex_contiguous_matches_long" xml:space="preserve">
    <value>The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.</value>
  </data>
  <data name="Regex_contiguous_matches_short" xml:space="preserve">
    <value>contiguous matches</value>
  </data>
  <data name="Regex_end_of_string_only_long" xml:space="preserve">
    <value>The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, it can only match the last line of the input string.</value>
  </data>
  <data name="Regex_end_of_string_only_short" xml:space="preserve">
    <value>end of string only</value>
  </data>
  <data name="Regex_end_of_string_or_before_ending_newline_long" xml:space="preserve">
    <value>The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can only match the end of the last line, or the last line before \n.

The \Z anchor matches \n but does not match \r\n (the CR/LF character combination). To match CR/LF, include \r?\Z in the regular expression pattern.</value>
  </data>
  <data name="Regex_end_of_string_or_before_ending_newline_short" xml:space="preserve">
    <value>end of string or before ending newline</value>
  </data>
  <data name="Regex_non_word_boundary_long" xml:space="preserve">
    <value>The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor.</value>
  </data>
  <data name="Regex_non_word_boundary_short" xml:space="preserve">
    <value>non-word boundary</value>
  </data>
  <data name="Regex_start_of_string_only_long" xml:space="preserve">
    <value>The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input string.</value>
  </data>
  <data name="Regex_start_of_string_only_short" xml:space="preserve">
    <value>start of string only</value>
  </data>
  <data name="Regex_word_boundary_long" xml:space="preserve">
    <value>The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore. The match may also occur on a word boundary at the beginning or end of the string.

The \b anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</value>
  </data>
  <data name="Regex_word_boundary_short" xml:space="preserve">
    <value>word boundary</value>
  </data>
  <data name="Regex_start_of_string_or_line_long" xml:space="preserve">
    <value>The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.</value>
  </data>
  <data name="Regex_start_of_string_or_line_short" xml:space="preserve">
    <value>start of string or line</value>
  </data>
  <data name="Regex_end_of_string_or_line_long" xml:space="preserve">
    <value>The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string. If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line.

The $ anchor matches \n but does not match \r\n (the combination of carriage return and newline characters, or CR/LF). To match the CR/LF character combination, include \r?$ in the regular expression pattern.</value>
  </data>
  <data name="Regex_end_of_string_or_line_short" xml:space="preserve">
    <value>end of string or line</value>
  </data>
  <data name="Regex_any_character_group_long" xml:space="preserve">
    <value>The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified by the 's' option, . matches any character.</value>
  </data>
  <data name="Regex_any_character_group_short" xml:space="preserve">
    <value>any character</value>
  </data>
  <data name="Regex_backspace_character_long" xml:space="preserve">
    <value>Matches a backspace character, \u0008</value>
  </data>
  <data name="Regex_backspace_character_short" xml:space="preserve">
    <value>backspace character</value>
  </data>
  <data name="Regex_bell_character_long" xml:space="preserve">
    <value>Matches a bell (alarm) character, \u0007</value>
  </data>
  <data name="Regex_bell_character_short" xml:space="preserve">
    <value>bell character</value>
  </data>
  <data name="Regex_carriage_return_character_long" xml:space="preserve">
    <value>Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n.</value>
  </data>
  <data name="Regex_carriage_return_character_short" xml:space="preserve">
    <value>carriage-return character</value>
  </data>
  <data name="Regex_control_character_long" xml:space="preserve">
    <value>Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C.</value>
  </data>
  <data name="Regex_control_character_short" xml:space="preserve">
    <value>control character</value>
  </data>
  <data name="Regex_decimal_digit_character_long" xml:space="preserve">
    <value>\d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.

If ECMAScript-compliant behavior is specified, \d is equivalent to [0-9]</value>
  </data>
  <data name="Regex_decimal_digit_character_short" xml:space="preserve">
    <value>decimal-digit character</value>
  </data>
  <data name="Regex_escape_character_long" xml:space="preserve">
    <value>Matches an escape character, \u001B</value>
  </data>
  <data name="Regex_escape_character_short" xml:space="preserve">
    <value>escape character</value>
  </data>
  <data name="Regex_form_feed_character_long" xml:space="preserve">
    <value>Matches a form-feed character, \u000C</value>
  </data>
  <data name="Regex_form_feed_character_short" xml:space="preserve">
    <value>form-feed character</value>
  </data>
  <data name="Regex_hexadecimal_escape_long" xml:space="preserve">
    <value>Matches an ASCII character, where ## is a two-digit hexadecimal character code.</value>
  </data>
  <data name="Regex_hexadecimal_escape_short" xml:space="preserve">
    <value>hexadecimal escape</value>
  </data>
  <data name="Regex_letter_uppercase" xml:space="preserve">
    <value>letter, uppercase</value>
  </data>
  <data name="Regex_matched_subexpression_long" xml:space="preserve">
    <value>This grouping construct captures a matched 'subexpression', where 'subexpression' is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one. The capture that is numbered zero is the text matched by the entire regular expression pattern.</value>
  </data>
  <data name="Regex_matched_subexpression_short" xml:space="preserve">
    <value>matched subexpression</value>
  </data>
  <data name="Regex_negative_character_group_long" xml:space="preserve">
    <value>A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters are specified individually.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</value>
  </data>
  <data name="Regex_negative_character_group_short" xml:space="preserve">
    <value>negative character group</value>
  </data>
  <data name="Regex_negative_character_range_long" xml:space="preserve">
    <value>A negative character range specifies a list of characters that must not appear in an input string for a match to occur. 'firstCharacter' is the character that begins the range, and 'lastCharacter' is the character that ends the range.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</value>
  </data>
  <data name="Regex_negative_unicode_category_long" xml:space="preserve">
    <value>The regular expression construct \P{ name } matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.</value>
  </data>
  <data name="Regex_negative_unicode_category_short" xml:space="preserve">
    <value>negative unicode category</value>
  </data>
  <data name="Regex_new_line_character_long" xml:space="preserve">
    <value>Matches a new-line character, \u000A</value>
  </data>
  <data name="Regex_new_line_character_short" xml:space="preserve">
    <value>new-line character</value>
  </data>
  <data name="Regex_non_digit_character_long" xml:space="preserve">
    <value>\D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.

If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9]</value>
  </data>
  <data name="Regex_non_digit_character_short" xml:space="preserve">
    <value>non-digit character</value>
  </data>
  <data name="Regex_non_white_space_character_long" xml:space="preserve">
    <value>\S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.

If ECMAScript-compliant behavior is specified, \S is equivalent to [^ \f\n\r\t\v]</value>
  </data>
  <data name="Regex_non_white_space_character_short" xml:space="preserve">
    <value>non-white-space character</value>
  </data>
  <data name="Regex_non_word_character_long" xml:space="preserve">
    <value>\W matches any non-word character. It matches any character except for those in the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \W is equivalent to [^a-zA-Z_0-9]</value>
    <comment>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized. </comment>
  </data>
  <data name="Regex_non_word_character_short" xml:space="preserve">
    <value>non-word character</value>
  </data>
  <data name="Regex_positive_character_group_long" xml:space="preserve">
    <value>A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur.</value>
  </data>
  <data name="Regex_positive_character_group_short" xml:space="preserve">
    <value>positive character group</value>
  </data>
  <data name="Regex_positive_character_range_long" xml:space="preserve">
    <value>A positive character range specifies a range of characters, any one of which may appear in an input string for a match to occur.  'firstCharacter' is the character that begins the range and 'lastCharacter' is the character that ends the range. </value>
  </data>
  <data name="Regex_positive_character_range_short" xml:space="preserve">
    <value>positive character range</value>
  </data>
  <data name="Regex_subexpression" xml:space="preserve">
    <value>subexpression</value>
  </data>
  <data name="Regex_tab_character_long" xml:space="preserve">
    <value>Matches a tab character, \u0009</value>
  </data>
  <data name="Regex_tab_character_short" xml:space="preserve">
    <value>tab character</value>
  </data>
  <data name="Regex_unicode_category_long" xml:space="preserve">
    <value>The regular expression construct \p{ name } matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.</value>
  </data>
  <data name="Regex_unicode_category_short" xml:space="preserve">
    <value>unicode category</value>
  </data>
  <data name="Regex_unicode_escape_long" xml:space="preserve">
    <value>Matches a UTF-16 code unit whose value is #### hexadecimal.</value>
  </data>
  <data name="Regex_unicode_escape_short" xml:space="preserve">
    <value>unicode escape</value>
  </data>
  <data name="Regex_vertical_tab_character_long" xml:space="preserve">
    <value>Matches a vertical-tab character, \u000B</value>
  </data>
  <data name="Regex_vertical_tab_character_short" xml:space="preserve">
    <value>vertical-tab character</value>
  </data>
  <data name="Regex_white_space_character_long" xml:space="preserve">
    <value>\s matches any white-space character. It is equivalent to the following escape sequences and Unicode categories:

    \f	The form feed character, \u000C
    \n	The newline character, \u000A
    \r	The carriage return character, \u000D
    \t	The tab character, \u0009
    \v	The vertical tab character, \u000B
    \x85	The ellipsis or NEXT LINE (NEL) character (â€¦), \u0085
    \p{Z}	Matches any separator character

If ECMAScript-compliant behavior is specified, \s is equivalent to [ \f\n\r\t\v]</value>
  </data>
  <data name="Regex_white_space_character_short" xml:space="preserve">
    <value>white-space character</value>
  </data>
  <data name="Regex_word_character_long" xml:space="preserve">
    <value>\w matches any word character. A word character is a member of any of the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \w is equivalent to [a-zA-Z_0-9]</value>
    <comment>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized.</comment>
  </data>
  <data name="Regex_word_character_short" xml:space="preserve">
    <value>word character</value>
  </data>
  <data name="Regex_alternation_long" xml:space="preserve">
    <value>You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.</value>
  </data>
  <data name="Regex_alternation_short" xml:space="preserve">
    <value>alternation</value>
  </data>
  <data name="Regex_balancing_group_long" xml:space="preserve">
    <value>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.

'name1' is the current group (optional), 'name2' is a previously defined group, and 'subexpression' is any valid regular expression pattern. The balancing group definition deletes the definition of name2 and stores the interval between name2 and name1 in name1. If no name2 group is defined, the match backtracks. Because deleting the last definition of name2 reveals the previous definition of name2, this construct lets you use the stack of captures for group name2 as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.

The balancing group definition uses 'name2' as a stack. The beginning character of each nested construct is placed in the group and in its Group.Captures collection. When the closing character is matched, its corresponding opening character is removed from the group, and the Captures collection is decreased by one. After the opening and closing characters of all nested constructs have been matched, 'name1' is empty.</value>
  </data>
  <data name="Regex_balancing_group_short" xml:space="preserve">
    <value>balancing group</value>
  </data>
  <data name="Regex_comment" xml:space="preserve">
    <value>comment</value>
  </data>
  <data name="Regex_conditional_expression_match_long" xml:space="preserve">
    <value>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.

'expression' is the initial pattern to match, 'yes' is the pattern to match if expression is matched, and 'no' is the optional pattern to match if expression is not matched.</value>
  </data>
  <data name="Regex_conditional_expression_match_short" xml:space="preserve">
    <value>conditional expression match</value>
  </data>
  <data name="Regex_conditional_group_match_long" xml:space="preserve">
    <value>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.

'name' is the name (or number) of a capturing group, 'yes' is the expression to match if 'name' (or 'number') has a match, and 'no' is the optional expression to match if it does not.</value>
  </data>
  <data name="Regex_conditional_group_match_short" xml:space="preserve">
    <value>conditional group match</value>
  </data>
  <data name="Regex_end_of_line_comment_long" xml:space="preserve">
    <value>A number sign (#) marks an x-mode comment, which starts at the unescaped # character at the end of the regular expression pattern and continues until the end of the line. To use this construct, you must either enable the x option (through inline options) or supply the RegexOptions.IgnorePatternWhitespace value to the option parameter when instantiating the Regex object or calling a static Regex method.</value>
  </data>
  <data name="Regex_end_of_line_comment_short" xml:space="preserve">
    <value>end-of-line comment</value>
  </data>
  <data name="Regex_expression" xml:space="preserve">
    <value>expression</value>
  </data>
  <data name="Regex_group_options_long" xml:space="preserve">
    <value>This grouping construct applies or disables the specified options within a subexpression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly
	named or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</value>
  </data>
  <data name="Regex_group_options_short" xml:space="preserve">
    <value>group options</value>
  </data>
  <data name="Regex_inline_comment_long" xml:space="preserve">
    <value>The (?# comment) construct lets you include an inline comment in a regular expression. The regular expression engine does not use any part of the comment in pattern matching, although the comment is included in the string that is returned by the Regex.ToString method. The comment ends at the first closing parenthesis.</value>
  </data>
  <data name="Regex_inline_comment_short" xml:space="preserve">
    <value>inline comment</value>
  </data>
  <data name="Regex_name" xml:space="preserve">
    <value>name</value>
  </data>
  <data name="Regex_name1" xml:space="preserve">
    <value>name1</value>
  </data>
  <data name="Regex_name2" xml:space="preserve">
    <value>name2</value>
  </data>
  <data name="Regex_named_backreference_long" xml:space="preserve">
    <value>A named or numbered backreference.

'name' is the name of a capturing group defined in the regular expression pattern.</value>
  </data>
  <data name="Regex_named_backreference_short" xml:space="preserve">
    <value>named backreference</value>
  </data>
  <data name="Regex_named_matched_subexpression_long" xml:space="preserve">
    <value>Captures a matched subexpression and lets you access it by name or by number.

'name' is a valid group name, and 'subexpression' is any valid regular expression pattern. 'name' must not contain any punctuation characters and cannot begin with a number.

If the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the only way to capture a subexpression is to explicitly name capturing groups.</value>
  </data>
  <data name="Regex_named_matched_subexpression_short" xml:space="preserve">
    <value>named matched subexpression</value>
  </data>
  <data name="Regex_name_or_number" xml:space="preserve">
    <value>name-or-number</value>
  </data>
  <data name="Regex_no" xml:space="preserve">
    <value>no</value>
  </data>
  <data name="Regex_atomic_group_long" xml:space="preserve">
    <value>Atomic groups (known in some other regular expression engines as a nonbacktracking subexpression, an atomic subexpression, or a once-only subexpression) disable backtracking. The regular expression engine will match as many characters in the input string as it can. When no further match is possible, it will not backtrack to attempt alternate pattern matches. (That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)

This option is recommended if you know that backtracking will not succeed. Preventing the regular expression engine from performing unnecessary searching improves performance.</value>
  </data>
  <data name="Regex_atomic_group_short" xml:space="preserve">
    <value>atomic group</value>
  </data>
  <data name="Regex_noncapturing_group_long" xml:space="preserve">
    <value>This construct does not capture the substring that is matched by a subexpression:

The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.

If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</value>
  </data>
  <data name="Regex_noncapturing_group_short" xml:space="preserve">
    <value>noncapturing group</value>
  </data>
  <data name="Regex_numbered_backreference_long" xml:space="preserve">
    <value>A numbered backreference, where 'number' is the ordinal position of the capturing group in the regular expression. For example, \4 matches the contents of the fourth capturing group.

There is an ambiguity between octal escape codes (such as \16) and \number backreferences that use the same notation. If the ambiguity is a problem, you can use the \k&lt;name&gt; notation, which is unambiguous and cannot be confused with octal character codes. Similarly, hexadecimal codes such as \xdd are unambiguous and cannot be confused with backreferences.</value>
  </data>
  <data name="Regex_numbered_backreference_short" xml:space="preserve">
    <value>numbered backreference</value>
  </data>
  <data name="Regex_yes" xml:space="preserve">
    <value>yes</value>
  </data>
  <data name="Regex_zero_width_negative_lookahead_assertion_long" xml:space="preserve">
    <value>A zero-width negative lookahead assertion, where for the match to be successful, the input string must not match the regular expression pattern in subexpression. The matched string is not included in the match result.

A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression. At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched. In this case, it is often used to limit backtracking. At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</value>
  </data>
  <data name="Regex_zero_width_negative_lookahead_assertion_short" xml:space="preserve">
    <value>zero-width negative lookahead assertion</value>
  </data>
  <data name="Regex_zero_width_negative_lookbehind_assertion_long" xml:space="preserve">
    <value>A zero-width negative lookbehind assertion, where for a match to be successful, 'subexpression' must not occur at the input string to the left of the current position. Any substring that does not match 'subexpression' is not included in the match result.

Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define precludes a match in the string that follows. They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</value>
  </data>
  <data name="Regex_zero_width_negative_lookbehind_assertion_short" xml:space="preserve">
    <value>zero-width negative lookbehind assertion</value>
  </data>
  <data name="Regex_zero_width_positive_lookahead_assertion_long" xml:space="preserve">
    <value>A zero-width positive lookahead assertion, where for a match to be successful, the input string must match the regular expression pattern in 'subexpression'. The matched substring is not included in the match result. A zero-width positive lookahead assertion does not backtrack.

Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern. It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match. It is also useful for preventing excessive backtracking. You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</value>
  </data>
  <data name="Regex_zero_width_positive_lookahead_assertion_short" xml:space="preserve">
    <value>zero-width positive lookahead assertion</value>
  </data>
  <data name="Regex_zero_width_positive_lookbehind_assertion_long" xml:space="preserve">
    <value>A zero-width positive lookbehind assertion, where for a match to be successful, 'subexpression' must occur at the input string to the left of the current position. 'subexpression' is not included in the match result. A zero-width positive lookbehind assertion does not backtrack.

Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define is a precondition for a match, although it is not a part of the match result.</value>
  </data>
  <data name="Regex_zero_width_positive_lookbehind_assertion_short" xml:space="preserve">
    <value>zero-width positive lookbehind assertion</value>
  </data>
  <data name="Regex_all_control_characters_long" xml:space="preserve">
    <value>All control characters. This includes the Cc, Cf, Cs, Co, and Cn categories.</value>
  </data>
  <data name="Regex_all_control_characters_short" xml:space="preserve">
    <value>all control characters</value>
  </data>
  <data name="Regex_all_diacritic_marks_long" xml:space="preserve">
    <value>All diacritic marks. This includes the Mn, Mc, and Me categories.</value>
  </data>
  <data name="Regex_all_diacritic_marks_short" xml:space="preserve">
    <value>all diacritic marks</value>
  </data>
  <data name="Regex_all_letter_characters_long" xml:space="preserve">
    <value>All letter characters. This includes the Lu, Ll, Lt, Lm, and Lo characters.</value>
  </data>
  <data name="Regex_all_letter_characters_short" xml:space="preserve">
    <value>all letter characters</value>
  </data>
  <data name="Regex_all_numbers_long" xml:space="preserve">
    <value>All numbers. This includes the Nd, Nl, and No categories.</value>
  </data>
  <data name="Regex_all_numbers_short" xml:space="preserve">
    <value>all numbers</value>
  </data>
  <data name="Regex_all_punctuation_characters_long" xml:space="preserve">
    <value>All punctuation characters. This includes the Pc, Pd, Ps, Pe, Pi, Pf, and Po categories.</value>
  </data>
  <data name="Regex_all_punctuation_characters_short" xml:space="preserve">
    <value>all punctuation characters</value>
  </data>
  <data name="Regex_all_separator_characters_long" xml:space="preserve">
    <value>All separator characters. This includes the Zs, Zl, and Zp categories.</value>
  </data>
  <data name="Regex_all_separator_characters_short" xml:space="preserve">
    <value>all separator characters</value>
  </data>
  <data name="Regex_all_symbols_long" xml:space="preserve">
    <value>All symbols. This includes the Sm, Sc, Sk, and So categories.</value>
  </data>
  <data name="Regex_all_symbols_short" xml:space="preserve">
    <value>all symbols</value>
  </data>
  <data name="Regex_base_group" xml:space="preserve">
    <value>base-group</value>
  </data>
  <data name="Regex_character_class_subtraction_long" xml:space="preserve">
    <value>Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.

'base_group' is a positive or negative character group or range. The 'excluded_group' component is another positive or negative character group, or another character class subtraction expression (that is, you can nest character class subtraction expressions).</value>
  </data>
  <data name="Regex_character_class_subtraction_short" xml:space="preserve">
    <value>character class subtraction</value>
  </data>
  <data name="Regex_character_group" xml:space="preserve">
    <value>character-group</value>
  </data>
  <data name="Regex_excluded_group" xml:space="preserve">
    <value>excluded-group</value>
  </data>
  <data name="Regex_match_at_least_n_times_lazy_long" xml:space="preserve">
    <value>The {n,}? quantifier matches the preceding element at least n times, where n is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,}</value>
  </data>
  <data name="Regex_match_at_least_n_times_lazy_short" xml:space="preserve">
    <value>match at least 'n' times (lazy)</value>
  </data>
  <data name="Regex_match_at_least_n_times_long" xml:space="preserve">
    <value>The {n,} quantifier matches the preceding element at least n times, where n is any integer. {n,} is a greedy quantifier whose lazy equivalent is {n,}?</value>
  </data>
  <data name="Regex_match_at_least_n_times_short" xml:space="preserve">
    <value>match at least 'n' times</value>
  </data>
  <data name="Regex_match_between_m_and_n_times_lazy_long" xml:space="preserve">
    <value>The {n,m}? quantifier matches the preceding element between n and m times, where n and m are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,m}</value>
  </data>
  <data name="Regex_match_between_m_and_n_times_lazy_short" xml:space="preserve">
    <value>match at least 'n' times (lazy)</value>
  </data>
  <data name="Regex_match_between_m_and_n_times_long" xml:space="preserve">
    <value>The {n,m} quantifier matches the preceding element at least n times, but no more than m times, where n and m are integers. {n,m} is a greedy quantifier whose lazy equivalent is {n,m}?</value>
  </data>
  <data name="Regex_match_between_m_and_n_times_short" xml:space="preserve">
    <value>match between 'm' and 'n' times</value>
  </data>
  <data name="Regex_match_exactly_n_times_lazy_long" xml:space="preserve">
    <value>The {n}? quantifier matches the preceding element exactly n times, where n is any integer. It is the lazy counterpart of the greedy quantifier {n}+</value>
  </data>
  <data name="Regex_match_exactly_n_times_lazy_short" xml:space="preserve">
    <value>match exactly 'n' times (lazy)</value>
  </data>
  <data name="Regex_match_exactly_n_times_long" xml:space="preserve">
    <value>The {n} quantifier matches the preceding element exactly n times, where n is any integer. {n} is a greedy quantifier whose lazy equivalent is {n}?</value>
  </data>
  <data name="Regex_match_exactly_n_times_short" xml:space="preserve">
    <value>match exactly 'n' times</value>
  </data>
  <data name="Regex_match_one_or_more_times_lazy_long" xml:space="preserve">
    <value>The +? quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier +</value>
  </data>
  <data name="Regex_match_one_or_more_times_lazy_short" xml:space="preserve">
    <value>match one or more times (lazy)</value>
  </data>
  <data name="Regex_match_one_or_more_times_long" xml:space="preserve">
    <value>The + quantifier matches the preceding element one or more times. It is equivalent to the {1,} quantifier. + is a greedy quantifier whose lazy equivalent is +?.</value>
  </data>
  <data name="Regex_match_one_or_more_times_short" xml:space="preserve">
    <value>match one or more times</value>
  </data>
  <data name="Regex_match_zero_or_more_times_lazy_long" xml:space="preserve">
    <value>The *? quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier *</value>
  </data>
  <data name="Regex_match_zero_or_more_times_lazy_short" xml:space="preserve">
    <value>match zero or more times (lazy)</value>
  </data>
  <data name="Regex_match_zero_or_more_times_long" xml:space="preserve">
    <value>The * quantifier matches the preceding element zero or more times. It is equivalent to the {0,} quantifier. * is a greedy quantifier whose lazy equivalent is *?.</value>
  </data>
  <data name="Regex_match_zero_or_more_times_short" xml:space="preserve">
    <value>match zero or more times</value>
  </data>
  <data name="Regex_match_zero_or_one_time_lazy_long" xml:space="preserve">
    <value>The ?? quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier ?</value>
  </data>
  <data name="Regex_match_zero_or_one_time_lazy_short" xml:space="preserve">
    <value>match zero or one time (lazy)</value>
  </data>
  <data name="Regex_match_zero_or_one_time_long" xml:space="preserve">
    <value>The ? quantifier matches the preceding element zero or one time. It is equivalent to the {0,1} quantifier. ? is a greedy quantifier whose lazy equivalent is ??.</value>
  </data>
  <data name="Regex_match_zero_or_one_time_short" xml:space="preserve">
    <value>match zero or one time</value>
  </data>
  <data name="Regex_unicode_general_category_0" xml:space="preserve">
    <value>Unicode General Category: {0}</value>
  </data>
  <data name="Regex_inline_options_long" xml:space="preserve">
    <value>Enables or disables specific pattern matching options for the remainder of a regular expression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly named
	or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</value>
  </data>
  <data name="Regex_inline_options_short" xml:space="preserve">
    <value>inline options</value>
  </data>
  <data name="_0_cannot_be_null_or_empty" xml:space="preserve">
    <value>'{0}' cannot be null or empty.</value>
  </data>
  <data name="_0_cannot_be_null_or_whitespace" xml:space="preserve">
    <value>'{0}' cannot be null or whitespace.</value>
  </data>
  <data name="_0_is_not_null_here" xml:space="preserve">
    <value>'{0}' is not null here.</value>
  </data>
  <data name="_0_may_be_null_here" xml:space="preserve">
    <value>'{0}' may be null here.</value>
  </data>
  <data name="ChangeSignature_NewParameterInferValue" xml:space="preserve">
    <value>&lt;infer&gt;</value>
  </data>
  <data name="from_metadata" xml:space="preserve">
    <value>from metadata</value>
  </data>
  <data name="symbol_cannot_be_a_namespace" xml:space="preserve">
    <value>'symbol' cannot be a namespace.</value>
  </data>
  <data name="Document_must_be_contained_in_the_workspace_that_created_this_service" xml:space="preserve">
    <value>Document must be contained in the workspace that created this service</value>
  </data>
  <data name="Generate_constructor_in_0_with_fields" xml:space="preserve">
    <value>Generate constructor in '{0}' (with fields)</value>
  </data>
  <data name="Generate_constructor_in_0_with_properties" xml:space="preserve">
    <value>Generate constructor in '{0}' (with properties)</value>
  </data>
  <data name="Property_reference_cannot_be_updated" xml:space="preserve">
    <value>Property reference cannot be updated</value>
  </data>
  <data name="Inline_0" xml:space="preserve">
    <value>Inline '{0}'</value>
  </data>
  <data name="Extract_base_class" xml:space="preserve">
    <value>Extract base class...</value>
  </data>
  <data name="Inline_and_keep_0" xml:space="preserve">
    <value>Inline and keep '{0}'</value>
  </data>
  <data name="Operators" xml:space="preserve">
    <value>Operators</value>
  </data>
  <data name="The_assembly_0_containing_type_1_references_NET_Framework" xml:space="preserve">
    <value>The assembly '{0}' containing type '{1}' references .NET Framework, which is not supported.</value>
  </data>
  <data name="The_assembly_0_references_compiler_version_1_newer_than_2" xml:space="preserve">
    <value>The analyzer assembly '{0}' references version '{1}' of the compiler, which is newer than the currently running version '{2}'.</value>
  </data>
  <data name="Apply_file_header_preferences" xml:space="preserve">
    <value>Apply file header preferences</value>
  </data>
  <data name="Apply_object_collection_initialization_preferences" xml:space="preserve">
    <value>Apply object/collection initialization preferences</value>
  </data>
  <data name="Remove_unnecessary_casts" xml:space="preserve">
    <value>Remove unnecessary casts</value>
  </data>
  <data name="Remove_unused_variables" xml:space="preserve">
    <value>Remove unused variables</value>
  </data>
  <data name="Sort_accessibility_modifiers" xml:space="preserve">
    <value>Sort accessibility modifiers</value>
  </data>
  <data name="Error_creating_instance_of_CodeFixProvider" xml:space="preserve">
    <value>Error creating instance of CodeFixProvider</value>
  </data>
  <data name="Error_creating_instance_of_CodeFixProvider_0" xml:space="preserve">
    <value>Error creating instance of CodeFixProvider '{0}'</value>
  </data>
  <data name="Removal_of_document_not_supported" xml:space="preserve">
    <value>Removal of document not supported</value>
  </data>
  <data name="in_0_1_2" xml:space="preserve">
    <value>in {0} ({1} - {2})</value>
  </data>
  <data name="_0_dash_1" xml:space="preserve">
    <value>{0} - {1}</value>
  </data>
  <data name="all_anonymous_types_in_container" xml:space="preserve">
    <value>all anonymous types in container</value>
  </data>
  <data name="Convert_to_tuple" xml:space="preserve">
    <value>Convert to tuple</value>
  </data>
  <data name="just_this_anonymous_type" xml:space="preserve">
    <value>just this anonymous type</value>
  </data>
  <data name="member_kind_and_name" xml:space="preserve">
    <value>{0} '{1}'</value>
    <comment>e.g. "method 'M'"</comment>
  </data>
  <data name="symbol_kind_and_name_of_member_kind_and_name" xml:space="preserve">
    <value>{0} '{1}' of {2} '{3}'</value>
    <comment>e.g. "parameter 'T param' of method 'M'"</comment>
  </data>
  <data name="code" xml:space="preserve">
    <value>code</value>
  </data>
  <data name="Convert_to_record" xml:space="preserve">
    <value>Convert to record</value>
  </data>
  <data name="Introduce_parameter_for_0" xml:space="preserve">
    <value>Introduce parameter for '{0}'</value>
  </data>
  <data name="Introduce_parameter_for_all_occurrences_of_0" xml:space="preserve">
    <value>Introduce parameter for all occurrences of '{0}'</value>
  </data>
  <data name="into_new_overload" xml:space="preserve">
    <value>into new overload</value>
  </data>
  <data name="into_extracted_method_to_invoke_at_call_sites" xml:space="preserve">
    <value>into extracted method to invoke at call sites</value>
  </data>
  <data name="and_update_call_sites_directly" xml:space="preserve">
    <value>and update call sites directly</value>
  </data>
  <data name="Convert_to_record_struct" xml:space="preserve">
    <value>Convert to record struct</value>
  </data>
  <data name="Applying_source_changes_while_the_application_is_running_is_not_supported_by_the_runtime" xml:space="preserve">
    <value>Applying source changes while the application is running is not supported by the runtime.</value>
  </data>
  <data name="Updating_reloadable_type_marked_by_0_attribute_or_its_member_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime" xml:space="preserve">
    <value>Updating a reloadable type (marked by {0}) or its member requires restarting the application because is not supported by the runtime.</value>
  </data>
  <data name="Making_a_method_an_iterator_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime" xml:space="preserve">
    <value>Making a method an iterator requires restarting the application because is not supported by the runtime.</value>
  </data>
  <data name="Making_a_method_asynchronous_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime" xml:space="preserve">
    <value>Making a method asynchronous requires restarting the application because is not supported by the runtime.</value>
  </data>
  <data name="Updating_the_attributes_of_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime" xml:space="preserve">
    <value>Updating the attributes of {0} requires restarting the application because it is not supported by the runtime.</value>
  </data>
  <data name="An_update_that_causes_the_return_type_of_implicit_main_to_change_requires_restarting_the_application" xml:space="preserve">
    <value>An update that causes the return type of the implicit Main method to change requires restarting the application.</value>
    <comment>{Locked="Main"} is C# keywords and should not be localized.</comment>
  </data>
  <data name="Changing_parameter_types_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Changing parameter types of {0} requires restarting the application.</value>
  </data>
  <data name="Changing_type_parameters_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Changing type parameters of {0} requires restarting the application.</value>
  </data>
  <data name="Changing_constraints_of_0_requires_restarting_the_application" xml:space="preserve">
    <value>Changing constraints of {0} requires restarting the application.</value>
  </data>
  <data name="No_common_root_node_for_extraction" xml:space="preserve">
    <value>No common root node for extraction.</value>
  </data>
  <data name="No_valid_selection_to_perform_extraction" xml:space="preserve">
    <value>No valid selection to perform extraction.</value>
  </data>
  <data name="Selection_does_not_contain_a_valid_token" xml:space="preserve">
    <value>Selection does not contain a valid token.</value>
  </data>
  <data name="Selection_not_contained_inside_a_type" xml:space="preserve">
    <value>Selection not contained inside a type.</value>
  </data>
  <data name="Invalid_selection" xml:space="preserve">
    <value>Invalid selection.</value>
  </data>
  <data name="Renaming_0_requires_restarting_the_application_because_it_is_not_supported_by_the_runtime" xml:space="preserve">
    <value>Renaming {0} requires restarting the application because it is not supported by the runtime.</value>
  </data>
  <data name="Move_static_members_to_another_type" xml:space="preserve">
    <value>Move static members to another type...</value>
  </data>
  <data name="Changing_pseudo_custom_attribute_0_of_1_requires_restarting_th_application" xml:space="preserve">
    <value>Changing pseudo-custom attribute '{0}' of {1} requires restarting the application</value>
  </data>
  <data name="Changing_the_containing_namespace_of_0_from_1_to_2_requires_restarting_th_application" xml:space="preserve">
    <value>Changing the containing namespace of '{0}' from '{1}' to '{2}' requires restarting the application</value>
  </data>
  <data name="ChangesRequiredSynthesizedType" xml:space="preserve">
    <value>One or more changes result in a new type being created by the compiler, which requires restarting the application because it is not supported by the runtime</value>
  </data>
  <data name="Miscellaneous_Files" xml:space="preserve">
    <value>Miscellaneous Files</value>
  </data>
  <data name="Silent" xml:space="preserve">
    <value>Silent</value>
  </data>
  <data name="console_writeline" xml:space="preserve">
    <value>Console.WriteLine</value>
  </data>
  <data name="embedded" xml:space="preserve">
    <value>embedded</value>
    <comment>Embedded is a technical term for "Embedded source", where souce files are embedded into the PDB</comment>
  </data>
  <data name="external" xml:space="preserve">
    <value>external</value>
    <comment>External means "external source", meaning source files that are not part of the current solution</comment>
  </data>
  <data name="Could_not_find_PDB_on_disk_or_embedded" xml:space="preserve">
    <value>Could not find portable PDB on disk or embedded.</value>
  </data>
  <data name="Error_reading_PDB_0" xml:space="preserve">
    <value>Error reading PDB: '{0}'</value>
  </data>
  <data name="Found_embedded_PDB_file" xml:space="preserve">
    <value>Found embedded PDB file.</value>
  </data>
  <data name="Found_PDB_file_at_0" xml:space="preserve">
    <value>Found PDB file at '{0}'</value>
  </data>
  <data name="Found_PDB_on_symbol_server" xml:space="preserve">
    <value>Found PDB on symbol server.</value>
  </data>
  <data name="Found_PDB_on_symbol_server_but_could_not_read_file" xml:space="preserve">
    <value>Found PDB on symbol server but could not read file.</value>
  </data>
  <data name="Navigating_to_symbol_0_from_1" xml:space="preserve">
    <value>Navigating to symbol '{0}' from '{1}'.</value>
  </data>
  <data name="No_source_document_info_found_in_PDB" xml:space="preserve">
    <value>No source document info found in PDB.</value>
  </data>
  <data name="Source_code_language_information_was_not_found_in_PDB" xml:space="preserve">
    <value>Source code language information was not found in PDB.</value>
  </data>
  <data name="Source_is_a_reference_assembly" xml:space="preserve">
    <value>Source is a reference assembly, not enough information to find PDB.</value>
  </data>
  <data name="_0_found_in_embedded_PDB" xml:space="preserve">
    <value>'{0}' found in embedded PDB.</value>
  </data>
  <data name="_0_found_in_embedded_PDB_but_checksum_failed" xml:space="preserve">
    <value>'{0}' found in embedded PDB but checksum was wrong, or couldn't read temp file.</value>
  </data>
  <data name="_0_found_in_embedded_PDB_but_could_not_write_file_1" xml:space="preserve">
    <value>'{0}' found in embedded PDB but could not write to temp file: '{1}'</value>
  </data>
  <data name="_0_found_in_embedded_PDB_cached_source_file" xml:space="preserve">
    <value>'{0}' found in embedded PDB and found cached source file.</value>
  </data>
  <data name="_0_found_via_SourceLink" xml:space="preserve">
    <value>'{0}' found via SourceLink.</value>
  </data>
  <data name="_0_found_via_SourceLink_but_couldnt_read_file" xml:space="preserve">
    <value>'{0}' found via SourceLink but couldn't read temp file.</value>
  </data>
  <data name="_0_found_in_original_location" xml:space="preserve">
    <value>'{0}' found in original location.</value>
  </data>
  <data name="_0_found_in_original_location_but_checksum_failed" xml:space="preserve">
    <value>'{0}' found in original location but checksum was wrong, or couldn't read temp file.</value>
  </data>
  <data name="Could_not_find_PDB_on_disk_or_embedded_or_server" xml:space="preserve">
    <value>Could not find PDB on disk, or embedded, or on a symbol server.</value>
  </data>
  <data name="Timeout_SourceLink" xml:space="preserve">
    <value>Timed out trying to download source code from SourceLink. Subsequent requests may succeed.</value>
  </data>
  <data name="Timeout_symbol_server" xml:space="preserve">
    <value>Timed out trying to download PDB from symbol server. Subsequent requests may succeed.</value>
  </data>
  <data name="Symbol_found_in_assembly_path_0" xml:space="preserve">
    <value>Symbol found in assembly path '{0}'</value>
  </data>
  <data name="Invalid_number" xml:space="preserve">
    <value>Invalid number</value>
  </data>
  <data name="Unterminated_comment" xml:space="preserve">
    <value>Unterminated comment</value>
  </data>
  <data name="Unterminated_string" xml:space="preserve">
    <value>Unterminated string</value>
  </data>
  <data name="_0_expected" xml:space="preserve">
    <value>'{0}' expected</value>
  </data>
  <data name="_0_unexpected" xml:space="preserve">
    <value>'{0}' unexpected</value>
  </data>
  <data name="Invalid_escape_sequence" xml:space="preserve">
    <value>Invalid escape sequence</value>
  </data>
  <data name="Error_parsing_comment" xml:space="preserve">
    <value>Error parsing comment</value>
  </data>
  <data name="Syntax_error" xml:space="preserve">
    <value>Syntax error</value>
  </data>
  <data name="Invalid_property_name" xml:space="preserve">
    <value>Invalid property name</value>
  </data>
  <data name="Missing_property_value" xml:space="preserve">
    <value>Missing property value</value>
  </data>
  <data name="Nested_properties_not_allowed" xml:space="preserve">
    <value>Nested properties not allowed</value>
  </data>
  <data name="Name_expected" xml:space="preserve">
    <value>Name expected</value>
  </data>
  <data name="Invalid_constructor_name" xml:space="preserve">
    <value>Invalid constructor name</value>
  </data>
  <data name="Comments_not_allowed" xml:space="preserve">
    <value>Comments not allowed</value>
  </data>
  <data name="Constructors_not_allowed" xml:space="preserve">
    <value>Constructors not allowed</value>
  </data>
  <data name="Illegal_string_character" xml:space="preserve">
    <value>Illegal string character</value>
  </data>
  <data name="Illegal_whitespace_character" xml:space="preserve">
    <value>Illegal whitespace character</value>
  </data>
  <data name="Only_properties_allowed_in_an_object" xml:space="preserve">
    <value>Only properties allowed in an object</value>
  </data>
  <data name="Properties_not_allowed_in_an_array" xml:space="preserve">
    <value>Properties not allowed in an array</value>
  </data>
  <data name="Property_name_must_be_a_string" xml:space="preserve">
    <value>Property name must be a string</value>
  </data>
  <data name="Property_name_must_be_followed_by_a_colon" xml:space="preserve">
    <value>Property name must be followed by a ':'</value>
  </data>
  <data name="Strings_must_start_with_double_quote_not_single_quote" xml:space="preserve">
    <value>Strings must start with " not '</value>
  </data>
  <data name="Trailing_comma_not_allowed" xml:space="preserve">
    <value>Trailing comma not allowed</value>
  </data>
  <data name="Value_required" xml:space="preserve">
    <value>Value required</value>
  </data>
  <data name="_0_literal_not_allowed" xml:space="preserve">
    <value>'{0}' literal not allowed</value>
  </data>
  <data name="JSON_issue_0" xml:space="preserve">
    <value>JSON issue: {0}</value>
  </data>
  <data name="Probable_JSON_string_detected" xml:space="preserve">
    <value>Probable JSON string detected</value>
  </data>
  <data name="Enable_all_JSON_editor_features" xml:space="preserve">
    <value>Enable all JSON editor features</value>
  </data>
  <data name="Invalid_regex_pattern" xml:space="preserve">
    <value>Invalid regex pattern</value>
  </data>
  <data name="Invalid_JSON_pattern" xml:space="preserve">
    <value>Invalid JSON pattern</value>
  </data>
  <data name="Unwrap_initializer" xml:space="preserve">
    <value>Unwrap initializer</value>
  </data>
  <data name="Wrap_initializer" xml:space="preserve">
    <value>Wrap initializer</value>
  </data>
  <data name="Wrap_long_initializer" xml:space="preserve">
    <value>Wrap long initializer</value>
  </data>
  <data name="Indent_all_elements" xml:space="preserve">
    <value>Indent all elements</value>
  </data>
  <data name="Unwrap_all_elements" xml:space="preserve">
    <value>Unwrap all elements</value>
  </data>
  <data name="Cannot_navigate_to_the_symbol_under_the_caret" xml:space="preserve">
    <value>Cannot navigate to the symbol under the caret.</value>
  </data>
  <data name="_0_bases" xml:space="preserve">
    <value>'{0}' bases</value>
  </data>
  <data name="_0_implementations" xml:space="preserve">
    <value>'{0}' implementations</value>
  </data>
  <data name="_0_references" xml:space="preserve">
    <value>'{0}' references</value>
  </data>
  <data name="The_symbol_has_no_base" xml:space="preserve">
    <value>The symbol has no base.</value>
  </data>
  <data name="The_symbol_has_no_implementations" xml:space="preserve">
    <value>The symbol has no implementations.</value>
  </data>
  <data name="Apply_auto_property_preferences" xml:space="preserve">
    <value>Apply auto property preferences</value>
  </data>
  <data name="Apply_blank_line_preferences_experimental" xml:space="preserve">
    <value>Apply blank line preferences (experimental)</value>
  </data>
  <data name="Apply_coalesce_expression_preferences" xml:space="preserve">
    <value>Apply coalesce expression preferences</value>
  </data>
  <data name="Apply_compound_assignment_preferences" xml:space="preserve">
    <value>Apply compound assignment preferences</value>
  </data>
  <data name="Apply_inferred_anonymous_type_member_names_preferences" xml:space="preserve">
    <value>Apply inferred anonymous type member names preferences</value>
  </data>
  <data name="Apply_language_framework_type_preferences" xml:space="preserve">
    <value>Apply language/framework type preferences</value>
  </data>
  <data name="Apply_namespace_matches_folder_preferences" xml:space="preserve">
    <value>Apply namespace matches folder preferences</value>
  </data>
  <data name="Apply_null_checking_preferences" xml:space="preserve">
    <value>Apply null checking preferences</value>
  </data>
  <data name="Apply_null_propagation_preferences" xml:space="preserve">
    <value>Apply null propagation preferences</value>
  </data>
  <data name="Apply_object_initializer_preferences" xml:space="preserve">
    <value>Apply object initializer preferences</value>
  </data>
  <data name="Apply_simplify_boolean_expression_preferences" xml:space="preserve">
    <value>Apply simplify boolean expression preferences</value>
  </data>
  <data name="Apply_string_interpolation_preferences" xml:space="preserve">
    <value>Apply string interpolation preferences</value>
  </data>
  <data name="Apply_tuple_name_preferences" xml:space="preserve">
    <value>Apply tuple name preferences</value>
  </data>
  <data name="Remove_unused_suppressions" xml:space="preserve">
    <value>Remove unused suppressions</value>
  </data>
  <data name="Apply_parentheses_preferences" xml:space="preserve">
    <value>Apply parentheses preferences</value>
  </data>
  <data name="Apply_statement_after_block_preferences_experimental" xml:space="preserve">
    <value>Apply statement after block preferences (experimental)</value>
  </data>
  <data name="Apply_unused_value_preferences" xml:space="preserve">
    <value>Apply unused value preferences</value>
  </data>
  <data name="Remove_unused_parameters" xml:space="preserve">
    <value>Remove unused parameters</value>
  </data>
  <data name="Apply_conditional_expression_preferences" xml:space="preserve">
    <value>Apply conditional expression preferences</value>
  </data>
  <data name="Apply_using_directive_placement_preferences" xml:space="preserve">
    <value>Apply using directive placement preferences</value>
  </data>
  <data name="Remove_unnecessary_Imports_or_usings" xml:space="preserve">
    <value>Remove unnecessary Imports or usings</value>
  </data>
  <data name="Sort_Imports_or_usings" xml:space="preserve">
    <value>Sort Imports or usings</value>
  </data>
  <data name="if_statement" xml:space="preserve">
    <value>if statement</value>
  </data>
  <data name="Directives_from_0" xml:space="preserve">
    <value>Directives from '{0}'</value>
  </data>
  <data name="Decompiled" xml:space="preserve">
    <value>decompiled</value>
  </data>
  <data name="Could_not_find_implementation_of_symbol_0" xml:space="preserve">
    <value>Could not find implementation of symbol '{0}'</value>
  </data>
  <data name="Replace_conditional_expression_with_statements" xml:space="preserve">
    <value>Replace conditional expression with statements</value>
  </data>
  <data name="Fixing_0" xml:space="preserve">
    <value>Fixing '{0}'</value>
  </data>
  <data name="Pull_selected_members_up_to_0" xml:space="preserve">
    <value>Pull selected members up to {0}</value>
  </data>
  <data name="Pull_selected_members_up" xml:space="preserve">
    <value>Pull selected members up</value>
  </data>
  <data name="Required" xml:space="preserve">
    <value>required</value>
    <comment>Used in the object initializer completion.</comment>
  </data>
  <data name="foreach_loop" xml:space="preserve">
    <value>foreach loop</value>
  </data>
  <data name="Deleting_0_requires_restarting_the_application_because_is_not_supported_by_the_runtime" xml:space="preserve">
    <value>Deleting {0} requires restarting the application because is not supported by the runtime.</value>
  </data>
  <data name="Updating_0_within_generic_type_or_method_requires_restarting_the_application_because_is_not_supported_by_the_runtime" xml:space="preserve">
    <value>Updating {0} within generic type or method requires restarting the application because is not supported by the runtime.</value>
  </data>
  <data name="Updating_async_or_iterator_requires_restarting_the_application_because_is_not_supported_by_the_runtime" xml:space="preserve">
    <value>Updating async or iterator requires restarting the application because is not supported by the runtime.</value>
  </data>
  <data name="Extract_base_record" xml:space="preserve">
    <value>Extract base record...</value>
    <comment>{Locked="record"} "record" is a language construct for C# and should not be localized.</comment>
  </data>
  <data name="Enum_members" xml:space="preserve">
    <value>Enum members</value>
  </data>
  <data name="struct_" xml:space="preserve">
    <value>struct</value>
  </data>
  <data name="class_with_explicit_or_sequential_layout" xml:space="preserve">
    <value>class with explicit or sequential layout</value>
  </data>
  <data name="Inline_temporary_variable" xml:space="preserve">
    <value>Inline temporary variable</value>
  </data>
  <data name="while_loop" xml:space="preserve">
    <value>while loop</value>
  </data>
  <data name="else_statement" xml:space="preserve">
    <value>else statement</value>
  </data>
  <data name="Code_snippet_for_0" xml:space="preserve">
    <value>Code snippet for '{0}'</value>
  </data>
  <data name="Please_resolve_errors_in_your_code_before_renaming_this_element" xml:space="preserve">
    <value>Please resolve errors in your code before renaming this element.</value>
  </data>
  <data name="Renaming_anonymous_type_members_is_not_yet_supported" xml:space="preserve">
    <value>Renaming anonymous type members is not yet supported.</value>
  </data>
  <data name="You_cannot_rename_elements_from_previous_submissions" xml:space="preserve">
    <value>You cannot rename elements from previous submissions.</value>
  </data>
  <data name="You_cannot_rename_elements_that_are_defined_in_metadata" xml:space="preserve">
    <value>You cannot rename elements that are defined in metadata.</value>
  </data>
  <data name="You_cannot_rename_operators" xml:space="preserve">
    <value>You cannot rename operators.</value>
  </data>
  <data name="You_cannot_rename_this_element" xml:space="preserve">
    <value>You cannot rename this element.</value>
  </data>
  <data name="You_must_rename_an_identifier" xml:space="preserve">
    <value>You must rename an identifier.</value>
  </data>
  <data name="get_only_property" xml:space="preserve">
    <value>get-only property</value>
  </data>
  <data name="This_0_has_1_references" xml:space="preserve">
    <value>This {0} has {1} reference(s).</value>
  </data>
  <data name="_0_reference_unquoted" xml:space="preserve">
    <value>{0} reference</value>
  </data>
  <data name="CSharp_VisualBasic_References" xml:space="preserve">
    <value>C# and Visual Basic References</value>
  </data>
  <data name="_0_references_unquoted" xml:space="preserve">
    <value>{0} references</value>
  </data>
  <data name="Find_All_References_not_invoked_on_applicable_symbol" xml:space="preserve">
    <value>'Find All References' not invoked on applicable symbol</value>
  </data>
  <data name="Deconstruct_locals_for_0" xml:space="preserve">
    <value>Deconstruct locals for '{0}'</value>
  </data>
  <data name="Run_All_Tests" xml:space="preserve">
    <value>Run All Tests</value>
  </data>
  <data name="Run_Test" xml:space="preserve">
    <value>Run Test</value>
  </data>
  <data name="Debug_All_Tests" xml:space="preserve">
    <value>Debug All Tests</value>
  </data>
  <data name="Debug_Test" xml:space="preserve">
    <value>Debug Test</value>
  </data>
  <data name="Chosen_version_0" xml:space="preserve">
    <value>Chosen version: '{0}'</value>
  </data>
  <data name="Could_not_find_by_name_0" xml:space="preserve">
    <value>Could not find by name: '{0}'</value>
  </data>
  <data name="Decompilation_log" xml:space="preserve">
    <value>Decompilation log</value>
  </data>
  <data name="Found_0_assemblies_for_1" xml:space="preserve">
    <value>Found '{0}' assemblies for '{1}':</value>
  </data>
  <data name="Found_exact_match_0" xml:space="preserve">
    <value>Found exact match: '{0}'</value>
  </data>
  <data name="Found_higher_version_match_0" xml:space="preserve">
    <value>Found higher version match: '{0}'</value>
  </data>
  <data name="Found_single_assembly_0" xml:space="preserve">
    <value>Found single assembly: '{0}'</value>
  </data>
  <data name="Load_from_0" xml:space="preserve">
    <value>Load from: '{0}'</value>
  </data>
  <data name="Module_not_found" xml:space="preserve">
    <value>Module not found!</value>
  </data>
  <data name="Resolve_0" xml:space="preserve">
    <value>Resolve: '{0}'</value>
  </data>
  <data name="Resolve_module_0_of_1" xml:space="preserve">
    <value>Resolve module: '{0}' of '{1}'</value>
  </data>
  <data name="WARN_Version_mismatch_Expected_0_Got_1" xml:space="preserve">
    <value>WARN: Version mismatch. Expected: '{0}', Got: '{1}'</value>
  </data>
  <data name="_0_items_in_cache" xml:space="preserve">
    <value>'{0}' items in cache</value>
  </data>
  <data name="Convert_number" xml:space="preserve">
    <value>Convert number</value>
  </data>
</root>