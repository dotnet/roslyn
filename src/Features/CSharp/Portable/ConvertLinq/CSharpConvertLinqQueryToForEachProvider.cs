// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis.ConvertLinq;
using Microsoft.CodeAnalysis.CSharp.Extensions;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Simplification;

namespace Microsoft.CodeAnalysis.CSharp.ConvertLinq
{
    internal sealed class CSharpConvertLinqQueryToLinqMethodProvider : AbstractConvertLinqProvider
    {
        private static readonly TypeSyntax VarNameIdentifier = SyntaxFactory.IdentifierName("var");

        protected override IAnalyzer CreateAnalyzer(SemanticModel semanticModel, CancellationToken cancellationToken)
            => new CSharpAnalyzer(semanticModel, cancellationToken);

        private sealed class CSharpAnalyzer : AnalyzerBase<QueryExpressionSyntax, SyntaxNode, SyntaxNode>
        {
            public CSharpAnalyzer(SemanticModel semanticModel, CancellationToken cancellationToken)
                : base(semanticModel, cancellationToken)
            {
            }

            protected override string Title => CSharpFeaturesResources.Convert_linq_query_to_foreach;

            protected override bool TryConvert(QueryExpressionSyntax source, out DocumentUpdate documentUpdate)
            {
                if (_semanticModel.GetDiagnostics(source.Span, _cancellationToken).Any())
                {
                    documentUpdate = default;
                    return false;
                }

                if (source.DescendantTrivia().Any(trivia => trivia.MatchesKind(
                    SyntaxKind.SingleLineCommentTrivia,
                    SyntaxKind.MultiLineCommentTrivia,
                    SyntaxKind.MultiLineDocumentationCommentTrivia) ||
                    source.ContainsDirectives))
                {
                    documentUpdate = default;
                    return false;
                }

                // TODO add a semantic check
                // validate that all clauses are translated into methods with signatures corresponding to code generated by the refactoring.

                switch (source.Parent.Kind())
                {
                    case SyntaxKind.ReturnStatement:
                        return TryConvertInReturnStatement(source, out documentUpdate);
                    case SyntaxKind.ForEachStatement:
                        return TryConvertInForEach(source, out documentUpdate);
                    case SyntaxKind.EqualsValueClause:
                    case SyntaxKind.SimpleAssignmentExpression:
                    case SyntaxKind.MultiplyAssignmentExpression:
                        return TryReplaceWithLocalFunction(source, out documentUpdate);
                    case SyntaxKind.ParenthesizedExpression:
                        return TryConvertInParenthesizedExpression(source, out documentUpdate);
                    default:
                        documentUpdate = default;
                        return false;
                }
            }

            private bool TryConvertInParenthesizedExpression(QueryExpressionSyntax source, out DocumentUpdate documentUpdate)
            {
                // TODO any other cases?
                var parenthesizedExpression = (ParenthesizedExpressionSyntax)source.Parent;
                if (parenthesizedExpression.Parent.Kind() == SyntaxKind.SimpleMemberAccessExpression)
                {
                    var memberAccessExpression = (MemberAccessExpressionSyntax)parenthesizedExpression.Parent;

                    Func<ExpressionSyntax, ExpressionSyntax, ExpressionSyntax> insideLoopExpression;
                    ExpressionSyntax initializer;
                    string variableNamePrefix;
                    switch (memberAccessExpression.Name.Identifier.ValueText)
                    {
                        case nameof(Enumerable.ToList):
                            if (TryGetTypeSyntax(source, out var typeSyntax))
                            {
                                if (typeSyntax.Kind() == SyntaxKind.QualifiedName)
                                {
                                    typeSyntax = ((QualifiedNameSyntax)typeSyntax).Right;
                                }

                                insideLoopExpression = (ExpressionSyntax listIdentifier, ExpressionSyntax expression) =>
                                            SyntaxFactory.InvocationExpression(
                                                SyntaxFactory.MemberAccessExpression(
                                                    SyntaxKind.SimpleMemberAccessExpression,
                                                    listIdentifier,
                                                    SyntaxFactory.IdentifierName("Add")), // TODO get "Add" from nameof something
                                                SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(expression)))
                                                );
                                initializer = SyntaxFactory.ObjectCreationExpression(
                                    SyntaxFactory.GenericName(
                                        SyntaxFactory.Identifier("List"),
                                        ((GenericNameSyntax)typeSyntax).TypeArgumentList).WithAdditionalAnnotations(Simplifier.Annotation), // / TODO "List"?
                                    SyntaxFactory.ArgumentList(), null);
                                variableNamePrefix = "list";
                            }
                            else
                            {
                                documentUpdate = default;
                                return false; // TODO refactor
                            }

                            break;
                        case nameof(Enumerable.Count):
                            // TODO extend this validation to each clause and each extension method
                            var operation = _semanticModel.GetOperation(memberAccessExpression.Parent, _cancellationToken);
                            if (operation is IInvocationOperation invocation &&
                                invocation.Arguments.Length == 1 &&
                                invocation.Type.MetadataName == "Int32") // TODO better check?
                            {
                                variableNamePrefix = "count";
                                insideLoopExpression = (ExpressionSyntax variableIdentifier, ExpressionSyntax expression) =>
                                        SyntaxFactory.PostfixUnaryExpression(SyntaxKind.PostIncrementExpression, variableIdentifier);
                                initializer = SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(0));
                            }
                            else
                            {
                                documentUpdate = default;
                                return false; // TODO refactor
                            }

                            break;
                        default:
                            return TryReplaceWithLocalFunction(source, out documentUpdate);
                    }

                    return TryConvertInInvocation(
                              source,
                             (ExpressionSyntax variableIdentifier, ExpressionSyntax expression) => SyntaxFactory.ExpressionStatement(insideLoopExpression(variableIdentifier, expression)),
                              initializer,
                              variableNamePrefix,
                              out documentUpdate);
                }

                documentUpdate = default;
                return false;
            }

            private bool TryConvertInInvocation(
                QueryExpressionSyntax source,
                Func<ExpressionSyntax, ExpressionSyntax, StatementSyntax> leafExpressionCreationMethod,
                ExpressionSyntax initializer,
                string variableName,
                out DocumentUpdate documentUpdate)
            {
                var parenthesizedExpression = (ParenthesizedExpressionSyntax)source.Parent;
                if (parenthesizedExpression.Parent.Parent.Kind() == SyntaxKind.InvocationExpression)
                {
                    switch (parenthesizedExpression.Parent.Parent.Parent.Kind())
                    {
                        case SyntaxKind.EqualsValueClause:
                        case SyntaxKind.MultiplyAssignmentExpression:
                        case SyntaxKind.SimpleAssignmentExpression:
                            if (TryGetVariableName(parenthesizedExpression.Parent.Parent.Parent, out var identifierExpression))
                            {
                                if (TryConvertQueryExpression(source, (ExpressionSyntax expression) => leafExpressionCreationMethod(identifierExpression, expression), out var qe1))
                                {
                                    if (TryFindParentAssignment(source, out var parentStatement))
                                    {
                                        var updatedParentExpressionStatement = parentStatement.ReplaceNode(
                                            source.Parent.Parent.Parent,
                                            initializer);

                                        documentUpdate = new DocumentUpdate(parentStatement, new[] { updatedParentExpressionStatement, qe1 });
                                        return true;
                                    }
                                }
                            }

                            break;
                        case SyntaxKind.ReturnStatement:
                            string freeVariableName = GetFreeSymbolName(variableName, source.GetLocation().SourceSpan.Start);
                            var identifierName = SyntaxFactory.IdentifierName(freeVariableName);
                            if (TryConvertQueryExpression(source, (ExpressionSyntax expression) => leafExpressionCreationMethod(identifierName, expression), out var qe2))
                            {
                                if (TryFindParentAssignment(source, out var parentStatement))
                                {
                                    var variableDeclaration =
                                        SyntaxFactory.LocalDeclarationStatement(
                                            SyntaxFactory.VariableDeclaration(
                                                VarNameIdentifier,
                                                SyntaxFactory.SingletonSeparatedList(
                                                    SyntaxFactory.VariableDeclarator(
                                                        identifierName.Identifier,
                                                        null,
                                                        SyntaxFactory.EqualsValueClause(initializer)))));
                                    var returnList = SyntaxFactory.ReturnStatement(identifierName);
                                    documentUpdate = new DocumentUpdate(parentStatement, new[] { variableDeclaration, qe2, returnList });
                                    return true;
                                }
                            }

                            break;
                        case SyntaxKind.ArrowExpressionClause:
                            // Not supported
                            break;
                        default:
                            throw new NotImplementedException(parenthesizedExpression.Parent.Parent.Parent.Kind().ToString());
                    }
                    documentUpdate = default;
                    return false;
                }

                throw new NotImplementedException(parenthesizedExpression.Parent.Parent.Kind().ToString());
            }

            private bool TryGetVariableName(SyntaxNode node, out ExpressionSyntax identifier)
            {
                switch (node.Kind())
                {
                    case SyntaxKind.EqualsValueClause:
                        identifier = SyntaxFactory.IdentifierName(((VariableDeclaratorSyntax)node.Parent).Identifier);
                        return true;
                    case SyntaxKind.MultiplyAssignmentExpression:
                    case SyntaxKind.SimpleAssignmentExpression:
                        identifier = ((AssignmentExpressionSyntax)node).Left;
                        return true;
                }

                identifier = null;
                return false;
            }

            private bool TryReplaceWithLocalFunction(QueryExpressionSyntax source, out DocumentUpdate documentUpdate)
            {
                if (TryFindParentAssignment(source, out var parentStatement))
                {
                    string localFunctionName = GetFreeSymbolName("localFunction", source.GetLocation().SourceSpan.Start);
                    StatementSyntax internalNodeMethod(ExpressionSyntax expression) => SyntaxFactory.YieldStatement(SyntaxKind.YieldReturnStatement, expression);
                    if (TryConvertQueryExpression(source, internalNodeMethod, out var qe))
                    {
                        if (TryGetTypeSyntax(source, out var typeSyntax))
                        {
                            var localFunctionDeclaration = SyntaxFactory.LocalFunctionStatement(
                                modifiers: default,
                                returnType: typeSyntax.WithAdditionalAnnotations(Simplifier.SpecialTypeAnnotation),
                                identifier: SyntaxFactory.Identifier(localFunctionName),
                                typeParameterList: null,
                                parameterList: SyntaxFactory.ParameterList(),
                                constraintClauses: default,
                                body: SyntaxFactory.Block(
                                    SyntaxFactory.Token(
                                        SyntaxFactory.TriviaList(),
                                        SyntaxKind.OpenBraceToken,
                                        SyntaxFactory.TriviaList(SyntaxFactory.EndOfLine(Environment.NewLine))),
                                    SyntaxFactory.SingletonList(qe),
                                    SyntaxFactory.Token(SyntaxKind.CloseBraceToken)),
                                expressionBody: null);

                            var localFunctionInvocation = SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName(localFunctionName));
                            SyntaxNode newParentExpressionStatement = parentStatement.ReplaceNode(source, localFunctionInvocation);
                            documentUpdate = new DocumentUpdate(parentStatement, new[] { localFunctionDeclaration, newParentExpressionStatement });
                            return true;
                        }
                    }
                }

                documentUpdate = default;
                return false;
            }

            private bool TryGetTypeSyntax(ExpressionSyntax expression, out TypeSyntax typeSyntax)
            {
                var typeSymbol = _semanticModel.GetTypeInfo(expression, _cancellationToken).Type;
                if (!ValidateTypeSymbol(typeSymbol))
                {
                    typeSyntax = default;
                    return false;
                }

                typeSyntax = typeSymbol.GenerateTypeSyntax();
                return true;
            }

            private static bool ValidateTypeSymbol(ITypeSymbol typeSymbol)
            {
                if (typeSymbol.IsAnonymousType || typeSymbol.TypeKind == TypeKind.Error)
                {
                    return false;
                }

                if (typeSymbol is INamedTypeSymbol namedTypeSymbol)
                {
                    foreach (var typeArgument in namedTypeSymbol.TypeArguments)
                    {
                        if (!ValidateTypeSymbol(typeArgument))
                        {
                            return false;
                        }
                    }
                }

                return true;
            }

            private static bool TryGetTypeSyntax(ITypeSymbol typeSymbol, out TypeSyntax typeSyntax)
            {
                if (!ValidateTypeSymbol(typeSymbol))
                {
                    typeSyntax = default;
                    return false;
                }

                typeSyntax = typeSymbol.GenerateTypeSyntax();
                return true;
            }

            private static bool TryFindParentAssignment(SyntaxNode node, out SyntaxNode result)
            {
                while (node != null)
                {
                    if (node is StatementSyntax)
                    {
                        result = node;
                        return true;
                    }

                    node = node.Parent;
                }

                result = default;
                return false;
            }

            private string GetFreeSymbolName(string prefix, int position)
            {
                var symbols = _semanticModel.LookupSymbols(position);
                if (!symbols.Any(s => s.Name == prefix))
                {
                    return prefix;
                }

                int counter = 1;
                do
                {
                    string candidate = $"{prefix}{counter}";
                    if (!symbols.Any(s => s.Name == candidate))
                    {
                        return candidate;
                    }
                    counter++;
                } while (true);
            }

            private bool TryConvertInForEach(QueryExpressionSyntax source, out DocumentUpdate documentUpdate)
            {
                ForEachStatementSyntax commonForEachStatement = (ForEachStatementSyntax)source.Parent;
                StatementSyntax statement = commonForEachStatement.Statement;

                StatementSyntax internalNodeMethod(ExpressionSyntax expression)
                {
                    if (expression.Kind() == SyntaxKind.IdentifierName && ((IdentifierNameSyntax)expression).Identifier.ValueText == commonForEachStatement.Identifier.ValueText)
                    {
                        return statement;
                    }
                    else
                    {
                        var declaration = SyntaxFactory.LocalDeclarationStatement(
                            SyntaxFactory.VariableDeclaration(
                                VarNameIdentifier,
                                SyntaxFactory.SingletonSeparatedList(
                                    SyntaxFactory.VariableDeclarator(commonForEachStatement.Identifier, null, SyntaxFactory.EqualsValueClause(expression)))));
                        return AddToBlockTop(declaration, statement);
                    }
                }

                if (TryConvertQueryExpression(source, internalNodeMethod, out StatementSyntax newNode))
                {
                    documentUpdate = new DocumentUpdate(commonForEachStatement, newNode);
                    return true;
                }

                documentUpdate = default;
                return false;
            }

            private bool TryConvertInReturnStatement(QueryExpressionSyntax source, out DocumentUpdate documentUpdate)
            {
                SyntaxNode nodeToReplace = source.Parent;
                StatementSyntax internalNodeMethod(ExpressionSyntax expression) => SyntaxFactory.YieldStatement(SyntaxKind.YieldReturnStatement, expression);
                if (TryConvertQueryExpression(source, internalNodeMethod, out var newNode))
                {
                    documentUpdate = new DocumentUpdate(nodeToReplace, newNode);
                    return true;
                }

                documentUpdate = default;
                return false;
            }

            private bool TryConvertQueryExpression(QueryExpressionSyntax source, Func<ExpressionSyntax, StatementSyntax> leafExpressionCreationMethod, out StatementSyntax statement)
            {
                FromClauseSyntax fromClause = source.FromClause;
                ProcessingState processingState = new ProcessingState(
                    fromClause.Identifier.ValueText,
                    s => SyntaxFactory.ForEachStatement(
                        fromClause.Type ?? VarNameIdentifier, 
                        fromClause.Identifier, 
                        fromClause.Expression.WithoutTrivia(), 
                        s));

                // Tries to create a stack of syntax building methods within the processing state: from top to bottom of the tree.
                if (TryProcessQueryBody(leafExpressionCreationMethod, source.Body, processingState))
                {
                    // Executes syntax building methods from bottom to the top of the tree.
                    statement = processingState.ExecuteMethods();
                    return true;
                }

                statement = default;
                return false;
            }

            private bool TryProcessQueryBody(Func<ExpressionSyntax, StatementSyntax> leafExpressionCreationMethod, QueryBodySyntax queryBody, ProcessingState processingState)
            {
                foreach (QueryClauseSyntax queryClause in queryBody.Clauses)
                {
                    switch (queryClause.Kind())
                    {
                        case SyntaxKind.WhereClause:
                            WhereClauseSyntax whereClause = (WhereClauseSyntax)queryClause;
                            processingState.AddStatementProcessingMethod(s =>
                            {
                                return SyntaxFactory.Block(SyntaxFactory.IfStatement(ProcessCondition(whereClause.Condition), s));
                            });

                            break;
                        case SyntaxKind.LetClause:
                            LetClauseSyntax letClause = (LetClauseSyntax)queryClause;
                            processingState.AddVariableName(letClause.Identifier.ValueText);
                            processingState.AddStatementProcessingMethod(
                                s =>
                                {
                                    LocalDeclarationStatementSyntax localDeclarationStatement =
                                       SyntaxFactory.LocalDeclarationStatement(
                                           SyntaxFactory.VariableDeclaration(
                                               VarNameIdentifier,
                                               SyntaxFactory.SingletonSeparatedList(
                                                   SyntaxFactory.VariableDeclarator(
                                                       letClause.Identifier,
                                                       null,
                                                       SyntaxFactory.EqualsValueClause(letClause.Expression)))));
                                    // TODO unit test with Let / Let / Let
                                    return AddToBlockTop(localDeclarationStatement, s);
                                });
                            break;
                        case SyntaxKind.FromClause:
                            FromClauseSyntax fromClause = (FromClauseSyntax)queryClause;
                            processingState.AddVariableName(fromClause.Identifier.ValueText);
                            processingState.AddStatementProcessingMethod(
                                s =>
                                {
                                    return SyntaxFactory.Block(
                                        SyntaxFactory.ForEachStatement(
                                            fromClause.Type ?? VarNameIdentifier,
                                            fromClause.Identifier,
                                            fromClause.Expression.WithoutTrivia(), s));
                                });
                            break;
                        case SyntaxKind.JoinClause:
                            JoinClauseSyntax joinClause = (JoinClauseSyntax)queryClause;
                            if (joinClause.Into != null)
                            {
                                processingState.AddVariableName(joinClause.Identifier.ValueText);
                                processingState.AddStatementProcessingMethod(
                                    s =>
                                    {
                                        var intoDeclaration =
                                        SyntaxFactory.LocalDeclarationStatement(
                                            SyntaxFactory.VariableDeclaration(
                                                VarNameIdentifier,
                                                SyntaxFactory.SingletonSeparatedList(
                                                    SyntaxFactory.VariableDeclarator(
                                                        joinClause.Into.Identifier,
                                                        null,
                                                        SyntaxFactory.EqualsValueClause(
                                                            SyntaxFactory.AnonymousObjectCreationExpression(
                                                                SyntaxFactory.SeparatedList(
                                                                   processingState.VariableNames.Select(vn => CreateAnonymousObjectMemberDeclarator(vn)))))))));
                                        return CreateJoinStatement(joinClause, AddToBlockTop(intoDeclaration, s));
                                    });
                            }
                            else
                            {
                                processingState.AddVariableName(joinClause.Identifier.ValueText);
                                processingState.AddStatementProcessingMethod(s => CreateJoinStatement(joinClause, s));
                            }

                            break;
                        case SyntaxKind.OrderByClause:// OrderBy is not supported by foreach.
                        default:
                            return false;
                    }
                }

                var selectOrGroupClause = queryBody.SelectOrGroup;
                switch (selectOrGroupClause.Kind())
                {
                    case SyntaxKind.SelectClause:
                        // TODO add a unit test with multiple selects
                        var selectClause = (SelectClauseSyntax)selectOrGroupClause;

                        // End of the queue
                        if (queryBody.Continuation == null)
                        {
                            processingState.AddStatementProcessingMethod(s => WrapWithBlock(leafExpressionCreationMethod(((SelectClauseSyntax)selectOrGroupClause).Expression)));
                        }
                        else
                        {
                            processingState.AddVariableName(queryBody.Continuation.Identifier.ValueText);
                            processingState.AddStatementProcessingMethod(
                                s => AddToBlockTop(
                                     SyntaxFactory.LocalDeclarationStatement(
                                        SyntaxFactory.VariableDeclaration(
                                            VarNameIdentifier,
                                            SyntaxFactory.SingletonSeparatedList(
                                                SyntaxFactory.VariableDeclarator(
                                                    queryBody.Continuation.Identifier,
                                                    null,
                                                    SyntaxFactory.EqualsValueClause(selectClause.Expression))))), s));

                            TryProcessQueryBody(leafExpressionCreationMethod, queryBody.Continuation.Body, processingState);
                        }
                        break;
                    case SyntaxKind.GroupClause:
                        // Groupclause is not supported by the conversion
                        return false;
                    default:
                        throw new ArgumentException(selectOrGroupClause.Kind().ToString());
                }

                return true;
            }

            private static BlockSyntax AddToBlockTop(StatementSyntax newStatement, StatementSyntax statement)
            {
                if (statement.Kind() == SyntaxKind.Block)
                {
                    var list = new List<StatementSyntax>();
                    list.Add(newStatement);
                    list.AddRange(((BlockSyntax)statement).Statements); // TODO refactor
                    return SyntaxFactory.Block(list);
                }
                else
                {
                    return SyntaxFactory.Block(newStatement, statement);
                }
            }

            private static BlockSyntax WrapWithBlock(StatementSyntax statement)
            {
                if (statement.Kind() == SyntaxKind.Block)
                {
                    return (BlockSyntax)statement;
                }
                else
                {
                    return SyntaxFactory.Block(statement);
                }
            }

            private static ExpressionSyntax ProcessCondition(ExpressionSyntax expression)
            {
                if (expression.Kind() == SyntaxKind.ParenthesizedExpression)
                {
                    expression = ((ParenthesizedExpressionSyntax)expression).Expression;
                }

                return expression.WithoutTrivia();
            }

            private static AnonymousObjectMemberDeclaratorSyntax CreateAnonymousObjectMemberDeclarator(string name)
            {
                return SyntaxFactory.AnonymousObjectMemberDeclarator(SyntaxFactory.NameEquals(SyntaxFactory.IdentifierName(name)), SyntaxFactory.IdentifierName(name));
            }

            private static StatementSyntax CreateJoinStatement(JoinClauseSyntax joinClause, StatementSyntax statement)
            {
                return SyntaxFactory.Block(
                                SyntaxFactory.ForEachStatement(
                                    joinClause.Type ?? VarNameIdentifier,
                                    joinClause.Identifier,
                                    joinClause.InExpression,
                                    SyntaxFactory.Block(
                                        SyntaxFactory.IfStatement(
                                            SyntaxFactory.InvocationExpression(
                                                SyntaxFactory.MemberAccessExpression(
                                                    SyntaxKind.SimpleMemberAccessExpression,
                                                    SyntaxFactory.ParenthesizedExpression(joinClause.LeftExpression),
                                                    SyntaxFactory.IdentifierName("Equals")), // TODO get name from nameof
                                                SyntaxFactory.ArgumentList(SyntaxFactory.SingletonSeparatedList(SyntaxFactory.Argument(joinClause.RightExpression.WithoutTrailingTrivia())))),
                                            statement))));
            }


            // TODO consider making immutable
            // TODO consider returning the leaf expression to the processing state.
            private class ProcessingState
            {
                public ImmutableArray<string> VariableNames { get; private set; }

                // Each clause generates a method converting StatementSyntax into StatementSyntax.
                public Stack<Func<StatementSyntax, StatementSyntax>> StatementProcessingMethods { get; }

                public ProcessingState(string variableName, Func<StatementSyntax, StatementSyntax> statementProcessingMethod)
                {
                    VariableNames = ImmutableArray.Create(variableName);
                    StatementProcessingMethods = new Stack<Func<StatementSyntax, StatementSyntax>>();
                    this.AddStatementProcessingMethod(statementProcessingMethod);
                }

                public void AddVariableName(string variableName)
                {
                    VariableNames = VariableNames.Concat(variableName);
                }

                public void AddStatementProcessingMethod(Func<StatementSyntax, StatementSyntax> method)
                {
                    StatementProcessingMethods.Push(method);
                }

                public StatementSyntax ExecuteMethods()
                {
                    StatementSyntax statement = default;
                    while (StatementProcessingMethods.Any())
                    {
                         statement = StatementProcessingMethods.Pop()(statement);
                    }

                    return statement;
                }
            }
        }
    }
}
