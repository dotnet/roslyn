//// Licensed to the .NET Foundation under one or more agreements.
//// The .NET Foundation licenses this file to you under the MIT license.
//// See the LICENSE file in the project root for more information.

//using System.Collections.Immutable;
//using System.Linq;
//using Microsoft.CodeAnalysis;
//using Microsoft.CodeAnalysis.CSharp;
//using Microsoft.CodeAnalysis.CSharp.Syntax;
//using Microsoft.CodeAnalysis.Diagnostics;

//namespace Microsoft.CodeAnalysis.CSharp.MoveToResx
//{
//    [DiagnosticAnalyzer(LanguageNames.CSharp)]
//    internal class CSharpRenameResourceKeyAnalyzer : DiagnosticAnalyzer
//    {
//        public const string DiagnosticId = "RenameResx";

//        private static readonly LocalizableString Title = new LocalizableResourceString(nameof(CSharpFeaturesResources.Rename_Resx_Name), CSharpFeaturesResources.ResourceManager, typeof(CSharpFeaturesResources));
//        private static readonly LocalizableString MessageFormat = new LocalizableResourceString(nameof(CSharpFeaturesResources.Rename_resource_and_update_Resx), CSharpFeaturesResources.ResourceManager, typeof(CSharpFeaturesResources));
//        private const string Category = "Globalization";

//        private static readonly DiagnosticDescriptor s_renameResxRule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, isEnabledByDefault: true);


//        public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics => ImmutableArray.Create(s_renameResxRule);

//        public override void Initialize(AnalysisContext context)
//        {
//            context.ConfigureGeneratedCodeAnalysis(GeneratedCodeAnalysisFlags.None);
//            context.EnableConcurrentExecution();
//            context.RegisterSyntaxNodeAction(AnalyzeMemberAccess, SyntaxKind.SimpleMemberAccessExpression);
//        }

//        private static void AnalyzeMemberAccess(SyntaxNodeAnalysisContext context)
//        {
//            var memberAccess = (MemberAccessExpressionSyntax)context.Node;

//            // Check for pattern: Namespace.ResourceClass.ResourceKey
//            // e.g., MyNamespace.Resources.autoGeneratedKey
//            // You may want to refine this logic to match your actual resource access pattern

//            var resourceKey = memberAccess.Name.Identifier.Text;
//            if (!IsAutoGeneratedResourceKey(resourceKey))
//                return;

//            // Optionally, check that the left side is a resource class (e.g., Resources)
//            // and that the full access is in the expected format

//            // Report diagnostic on the resource key identifier
//            var diagnostic = Diagnostic.Create(s_renameResxRule, memberAccess.Name.GetLocation(), resourceKey);
//            context.ReportDiagnostic(diagnostic);
//        }

//        // This should match your deterministic key generation logic
//        private static bool IsAutoGeneratedResourceKey(string key)
//        {
//            // Example: match lowerCamelCase, or use a marker/prefix if you have one
//            // Here, we assume keys like "emptyString", "someText", etc. are auto-generated
//            // You may want to refine this to match your actual key generation
//            return key == "emptyString" || char.IsLower(key.FirstOrDefault());
//        }
//    }
//}
