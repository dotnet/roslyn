// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Composition;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeMapper;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Host.Mef;
using Microsoft.CodeAnalysis.PooledObjects;
using Microsoft.CodeAnalysis.Text;
using Roslyn.Utilities;

namespace Microsoft.CodeAnalysis.CSharp.CodeMapper;

/// <summary>
/// A mapper used for Mapping C# Code from a suggestion onto existing code in the codebase.
/// This is the backbone of previews, as this allows us to know where we should place the preview.
/// </summary>
[ExportLanguageService(typeof(ICodeMapper), language: LanguageNames.CSharp), Shared]
internal sealed partial class CSharpCodeMapper : ICodeMapper
{

    private readonly InsertionHelper _insertHelper;
    private readonly ReplaceHelper _replaceHelper;

    [ImportingConstructor]
    [Obsolete(MefConstruction.ImportingConstructorMessage, error: true)]
    public CSharpCodeMapper()
    {
        _insertHelper = new InsertionHelper();
        _replaceHelper = new ReplaceHelper();
    }

    private static MappingTarget? GetMappingTarget(Document document, ImmutableArray<DocumentSpan> focusLocations)
    {
        foreach (var focusLocation in focusLocations)
        {
            if (document.Id == focusLocation.Document.Id)
                return new MappingTarget(focusLocation);
        }

        return null;
    }

    public async Task<ImmutableArray<TextChange>> MapCodeAsync(Document document, ImmutableArray<string> contents, ImmutableArray<DocumentSpan> focusLocations, CancellationToken cancellationToken)
    {
        var target = GetMappingTarget(document, focusLocations);
        if (target is null)
            return ImmutableArray<TextChange>.Empty;

        var options = (await document.GetSyntaxTreeAsync(cancellationToken).ConfigureAwait(false))?.Options as CSharpParseOptions;
        if (options is null)
            return ImmutableArray<TextChange>.Empty;

        using var _ = ArrayBuilder<TextChange>.GetInstance(out var result);
        foreach (var code in contents)
        {
            var syntaxTree = CSharpSyntaxTree.ParseText(SourceText.From(code), options, cancellationToken: cancellationToken);
            var rootNode = await syntaxTree.GetRootAsync(cancellationToken).ConfigureAwait(false);

            var sourceNodes = CSharpSourceNode.ExtractSourceNodes(rootNode);
            if (!sourceNodes.IsEmpty)
            {

                Debug.Assert(sourceNodes.Any(sn => sn.Scope is Scope.None) && sourceNodes.Any(sn => sn.Scope is not Scope.None));

                var edits = await MapInternalAsync(target, sourceNodes, cancellationToken).ConfigureAwait(false);
                result.AddRange(edits);
            }
        }

        return result.ToImmutable();
    }


    private IMappingHelper? GetMapperHelper(ImmutableArray<CSharpSourceNode> sourceNodes, SyntaxNode documentRoot)
    {

        IMappingHelper mapperHelper = sourceNodes.Any(static (sourceNode, syntaxRoot) => sourceNode.ExistsOnTarget(syntaxRoot, out _), arg: documentRoot)
            ? _replaceHelper
            : _insertHelper;
        
        // Replace does not support more than one node.
        if (mapperHelper is ReplaceHelper && sourceNodes.Length > 1)
            return null;

        return mapperHelper;
    }

    /// <summary>
    /// Maps a given syntax node from code generated by the AI,
    /// to a given or existing snapshot.
    /// </summary>
    /// <param name="target">The mapping target.</param>
    /// <param name="sourceNodes">The source nodes to map.</param>
    /// <param name="cancellationToken">A cancellation token.</param>
    /// <returns>Returns a Mapped Edit, or null when there wasn't any successful mapping.</returns>
    private async Task<ImmutableArray<TextChange>> MapInternalAsync(MappingTarget target, ImmutableArray<CSharpSourceNode> sourceNodes, CancellationToken cancellationToken)
    {
        var document = target.FocusArea.Document;
        var documentRoot = await document.GetSyntaxRootAsync(cancellationToken).ConfigureAwait(false);
        Contract.ThrowIfNull(documentRoot, nameof(documentRoot));

        var mapperHelper = GetMapperHelper(sourceNodes, documentRoot);

        // If no insertion found is valid, return empty list.
        if (mapperHelper?.TryGetValidInsertions(documentRoot, sourceNodes, out var validInsertionNodes, out var invalidInsertions) is not true)
            return ImmutableArray<TextChange>.Empty;


        using var  _ = ArrayBuilder<TextChange>.GetInstance(out var mappedEdits);
        foreach (var sourceNode in sourceNodes)
        {
            // by default we assume the insertion will be the full syntax node.
            var insertion = sourceNode.ToFullString();

            // When calculating the insert span, the insert text might suffer adjustments.
            // These adjustments will be visible in the adjustedInsertion, if it's not null that means
            // there were adjustments to the text when calculating the insert spans.

            var insertionSpan = mapperHelper.GetInsertSpan(documentRoot, sourceNode, target, out var adjustedInsertion);
            if (adjustedInsertion is not null)
            {
                insertion = adjustedInsertion;
            }

            if (insertionSpan is not null)
            {
                var snapshotSpan = GetSnapshotSpan(snapshot, insertionSpan.Value);
                var edit = new TextEdit(insertion, snapshotSpan);
                var mappedEdit = new MappedEdit(edit, uri);
                mappedEdits.Add(mappedEdit);
            }
        }

        // Merge edits when mapping has determined an insert.
        // This is a hotfix for now, because we don't have a way to handle multiple insertion nodes yet.
        // So this should help mitigate the issue we were seeing when we tried to insert more than one source node.
        if (mapperHelper is InsertionHelper && mappedEdits.Count > 1)
        {
            mappedEdits = new List<MappedEdit> { MappedEdit.MergeEdits(mappedEdits.ToArray()) };
        }

        return mappedEdits.ToArray();
    }

    private static SnapshotSpan GetSnapshotSpan(ITextSnapshot snapshot, FileLinePositionSpan position)
    {
        // find the position where the method is located in the document now that we have the node.
        var start = snapshot.GetLineFromLineNumber(position.StartLinePosition.Line).Start;
        var end = snapshot.GetLineFromLineNumber(position.EndLinePosition.Line).Start.Add(position.EndLinePosition.Character);
        // Return the snapshot span for the syntax node
        var span = new SnapshotSpan(start, end - start);
        return span;
    }

    private interface IMappingHelper
    {
        bool TryGetValidInsertions(SyntaxNode target, ImmutableArray<CSharpSourceNode> sourceNodes, out CSharpSourceNode[] validInsertions, out InvalidInsertion[] invalidInsertions);

        TextSpan? GetInsertSpan(SyntaxNode documentSyntax, CSharpSourceNode insertion, MappingTarget? target, out string? adjustedInsertion);
    }

    private record MappingTarget(DocumentSpan FocusArea)
    {
    }
}
