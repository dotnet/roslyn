// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

using System;
using System.Collections.Generic;
using System.Composition;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CodeMapper;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Host.Mef;
using Microsoft.CodeAnalysis.Text;

namespace Microsoft.CodeAnalysis.CSharp.CodeMapper;

/// <summary>
/// A mapper used for Mapping C# Code from a suggestion onto existing code in the codebase.
/// This is the backbone of previews, as this allows us to know where we should place the preview.
/// </summary>
[ExportLanguageService(typeof(ICodeMapper), language: LanguageNames.CSharp), Shared]
internal sealed partial class CSharpCodeMapper : ICodeMapper
{
    private interface ICodeMapperHelper
    {
        bool TryGetValidInsertions(
           SyntaxNode target,
           CSharpSourceNode[] sourceNodes,
           out CSharpSourceNode[] validInsertions,
           out InvalidInsertion[] invalidInsertions);

        FileLinePositionSpan? GetInsertSpan(SyntaxNode documentSyntax, CSharpSourceNode insertion, MappingTarget? target, out string? adjustedInsertion);
    }

    private readonly InsertMapperHelper _insertHelper;
    private readonly ReplaceMapperHelper _replaceHelper;

    [ImportingConstructor]
    public CSharpCodeMapper()
    {
        this._insertHelper = new InsertMapperHelper();
        this._replaceHelper = new ReplaceMapperHelper();
    }

    private ICodeMapperHelper GetMapperHelper(CSharpSourceNode[] insertions, SyntaxNode target)
    {
        foreach (var ins in insertions)
        {
            if (ins is not CSharpSourceNode csharpInsertion)
            {
                throw new InvalidOperationException("Insertion is not a C# Source Node.");
            }

            if (csharpInsertion.ExistsOnTarget(target, out _))
            {
                return this._replaceHelper;
            }
        }

        return this._insertHelper;
    }

    /// <summary>
    /// Maps a given syntax node from code generated by the AI,
    /// to a given or existing snapshot.
    /// </summary>
    /// <param name="target">The target that we need ot map the code to.</param>
    /// <param name="codeBlocks">The new code generated by the AI.</param>
    /// <param name="cancellation">A cancellation token.</param>
    /// <returns>Returns a Mapped Edit, or null when there wasn't any successful mapping.</returns>
    public async Task<MappedEdit[]> MapAsync(MappingTarget target, IReadOnlyList<string> codeBlocks, CancellationToken cancellation)
    {
        var result = new List<MappedEdit>();
        foreach (var code in codeBlocks)
        {
            var syntaxTree = CSharpSyntaxTree.ParseText(code, cancellationToken: cancellation);
            if (syntaxTree is null)
            {
                continue;
            }

            var syntaxNode = await syntaxTree.GetRootAsync(cancellation);
            if (syntaxNode is null)
            {
                continue;
            }

            var sourceNodes = NodeHelper.ExtractSourceNodes(syntaxNode);
            if (!sourceNodes.Any())
            {
                continue;
            }

            // Mixed scoped types nodes are unsupported
            if (sourceNodes.Any(sn => sn is CSharpSimpleNode) && sourceNodes.Any(sn => sn is CSharpScopedNode))
            {
                continue;
            }

            var edits = await this.MapInternalAsync(target, sourceNodes.ToArray(), cancellation);
            result.AddRange(edits);
        }

        return result.ToArray();
    }

    /// <summary>
    /// Maps a given syntax node from code generated by the AI,
    /// to a given or existing snapshot.
    /// </summary>
    /// <param name="target">The mapping target.</param>
    /// <param name="sourceNodes">The source nodes to map.</param>
    /// <param name="cancellation">A cancellation token.</param>
    /// <returns>Returns a Mapped Edit, or null when there wasn't any successful mapping.</returns>
    private async Task<MappedEdit[]> MapInternalAsync(MappingTarget target, CSharpSourceNode[] sourceNodes, CancellationToken cancellation)
    {
        if (!sourceNodes.Any())
        {
            return Array.Empty<MappedEdit>();
        }

        var snapshot = target.FocusArea.Snapshot;
        var document = snapshot.GetOpenDocumentInCurrentContextWithChanges();
        if (document is null)
        {
            // Sometimes the GetOpenDocumentInCurrentContextWithChanges will return null.
            // Still not sure what causes this, but for now we should skip silently to avoid throwing exceptions
            // user might not need to have.
            return Array.Empty<MappedEdit>();
        }

        if (!document.TryGetSyntaxRoot(out var documentRoot))
        {
            documentRoot = await document.GetSyntaxRootAsync();
        }

        if (documentRoot is null)
        {
            return Array.Empty<MappedEdit>();
        }

        var mapperHelper = this.GetMapperHelper(sourceNodes.ToArray(), documentRoot);

        // If no insertion found is valid, return empty list.
        if (!mapperHelper.TryGetValidInsertions(documentRoot, sourceNodes.OfType<CSharpSourceNode>().ToArray(), out var validInsertionNodes, out var invalidInsertions))
        {
            return Array.Empty<MappedEdit>();
        }

        // Replace does not support more than one node.
        if (mapperHelper is ReplaceMapperHelper && sourceNodes.Length > 1)
        {
            return Array.Empty<MappedEdit>();
        }

        DocumentUtils.TryGetDocumentUri(document, out var uri);

        var mappedEdits = new List<MappedEdit>();
        foreach (var sourceNode in sourceNodes)
        {
            if (sourceNode is not CSharpSourceNode validInsertion)
            {
                Debug.Fail("Expect sourceNode to be CSharpSourceNode type.");
                continue;
            }

            // by default we assume the insertion will be the full syntax node.
            var insertion = validInsertion.ToFullString();

            // When calculating the insert span, the insert text might suffer adjustments.
            // These adjustments will be visible in the adjustedInsertion, if it's not null that means
            // there were adjustments to the text when calculating the insert spans.

            var insertionSpan = mapperHelper.GetInsertSpan(documentRoot, validInsertion, target, out var adjustedInsertion);
            if (adjustedInsertion is not null)
            {
                insertion = adjustedInsertion;
            }

            if (insertionSpan is not null)
            {
                var snapshotSpan = GetSnapshotSpan(snapshot, insertionSpan.Value);
                var edit = new TextEdit(insertion, snapshotSpan);
                var mappedEdit = new MappedEdit(edit, uri);
                mappedEdits.Add(mappedEdit);
            }
        }

        // Merge edits when mapping has determined an insert.
        // This is a hotfix for now, because we don't have a way to handle multiple insertion nodes yet.
        // So this should help mitigate the issue we were seeing when we tried to insert more than one source node.
        if (mapperHelper is InsertMapperHelper && mappedEdits.Count > 1)
        {
            mappedEdits = new List<MappedEdit> { MappedEdit.MergeEdits(mappedEdits.ToArray()) };
        }

        return mappedEdits.ToArray();
    }

    private static SnapshotSpan GetSnapshotSpan(ITextSnapshot snapshot, FileLinePositionSpan position)
    {
        // find the position where the method is located in the document now that we have the node.
        var start = snapshot.GetLineFromLineNumber(position.StartLinePosition.Line).Start;
        var end = snapshot.GetLineFromLineNumber(position.EndLinePosition.Line).Start.Add(position.EndLinePosition.Character);
        // Return the snapshot span for the syntax node
        var span = new SnapshotSpan(start, end - start);
        return span;
    }
}
