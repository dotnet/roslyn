<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="de" original="../WorkspacesResources.resx">
    <body>
      <trans-unit id="Adding_analyzer_config_documents_is_not_supported">
        <source>Adding analyzer config documents is not supported.</source>
        <target state="translated">Das Hinzufügen von Konfigurationsdokumenten des Analysetools wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="An_error_occurred_while_reading_the_specified_configuration_file_colon_0">
        <source>An error occurred while reading the specified configuration file: {0}</source>
        <target state="translated">Beim Lesen der angegebenen Konfigurationsdatei ist ein Fehler aufgetreten: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="CSharp_files">
        <source>C# files</source>
        <target state="translated">C#-Dateien</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_analyzer_config_documents_is_not_supported">
        <source>Changing analyzer config documents is not supported.</source>
        <target state="translated">Das Ändern von Konfigurationsdokumenten des Analysetools wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_document_0_is_not_supported">
        <source>Changing document '{0}' is not supported.</source>
        <target state="translated">Das Ändern des Dokuments "{0}" wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Compilation_is_required_to_accomplish_the_task_but_is_not_supported_by_project_0">
        <source>Compilation is required to accomplish the task but is not supported by project {0}.</source>
        <target state="new">Compilation is required to accomplish the task but is not supported by project {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Core_EditorConfig_Options">
        <source>Core EditorConfig Options</source>
        <target state="translated">Wichtige EditorConfig-Optionen</target>
        <note />
      </trans-unit>
      <trans-unit id="DateTimeKind_must_be_Utc">
        <source>DateTimeKind must be Utc</source>
        <target state="translated">"DateTimeKind" muss UTC sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="Document_does_not_support_syntax_trees">
        <source>Document does not support syntax trees</source>
        <target state="translated">Das Dokument unterstützt keine Syntaxstrukturen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Expression_level_preferences">
        <source>Expression-level preferences</source>
        <target state="translated">Einstellungen für Ausdrucksebene</target>
        <note />
      </trans-unit>
      <trans-unit id="Field_preferences">
        <source>Field preferences</source>
        <target state="translated">Einstellungen für Felder</target>
        <note />
      </trans-unit>
      <trans-unit id="Indentation_and_spacing">
        <source>Indentation and spacing</source>
        <target state="translated">Einzüge und Abstände</target>
        <note />
      </trans-unit>
      <trans-unit id="Language_keywords_vs_BCL_types_preferences">
        <source>Language keywords vs BCL types preferences</source>
        <target state="translated">Einstellungen für Sprachschlüsselwörter und BCL-Typen</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifier_preferences">
        <source>Modifier preferences</source>
        <target state="translated">Einstellungen für Modifizierer</target>
        <note />
      </trans-unit>
      <trans-unit id="Naming_rules">
        <source>Naming rules</source>
        <target state="translated">Benennungsregeln</target>
        <note />
      </trans-unit>
      <trans-unit id="Naming_styles">
        <source>Naming styles</source>
        <target state="translated">Benennungsstile</target>
        <note />
      </trans-unit>
      <trans-unit id="New_line_preferences">
        <source>New line preferences</source>
        <target state="translated">Einstellungen für neue Zeilen</target>
        <note />
      </trans-unit>
      <trans-unit id="Organize_usings">
        <source>Organize usings</source>
        <target state="translated">Using-Direktiven organisieren</target>
        <note />
      </trans-unit>
      <trans-unit id="Parentheses_preferences">
        <source>Parentheses preferences</source>
        <target state="translated">Einstellungen für Klammern</target>
        <note />
      </trans-unit>
      <trans-unit id="Prefix_0_does_not_match_expected_prefix_1">
        <source>Prefix '{0}' does not match expected prefix '{1}'</source>
        <target state="translated">Das Präfix "{0}" entspricht nicht dem erwarteten Präfix "{1}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Prefix_0_is_not_expected">
        <source>Prefix '{0}' is not expected</source>
        <target state="translated">Das Präfix "{0}" wurde nicht erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="Refactoring_Only">
        <source>Refactoring Only</source>
        <target state="translated">Nur Refactoring</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_long">
        <source>All control characters. This includes the Cc, Cf, Cs, Co, and Cn categories.</source>
        <target state="translated">Alle Steuerzeichen. Hierzu gehören die Kategorien "Cc", "Cf", "Cs", "Co" und "Cn".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_short">
        <source>all control characters</source>
        <target state="translated">Alle Steuerzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_long">
        <source>All diacritic marks. This includes the Mn, Mc, and Me categories.</source>
        <target state="translated">Alle diakritischen Zeichen. Hierzu gehören die Kategorien "Mn", "Mc" und "Me".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_short">
        <source>all diacritic marks</source>
        <target state="translated">Alle diakritischen Zeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_long">
        <source>All letter characters. This includes the Lu, Ll, Lt, Lm, and Lo characters.</source>
        <target state="translated">Alle Buchstaben. Hierzu gehören die Zeichen "Lu", "Ll", "Lt", "Lm" und "Lo".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_short">
        <source>all letter characters</source>
        <target state="translated">Alle Buchstaben</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_long">
        <source>All numbers. This includes the Nd, Nl, and No categories.</source>
        <target state="translated">Alle Zahlen. Hierzu gehören die Kategorien "Nd", "Nl" und "No".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_short">
        <source>all numbers</source>
        <target state="translated">Alle Zahlen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_long">
        <source>All punctuation characters. This includes the Pc, Pd, Ps, Pe, Pi, Pf, and Po categories.</source>
        <target state="translated">Alle Satzzeichen. Hierzu gehören die Kategorien "Pc", "Pd", "Ps", "Pe", "Pi", "Pf" und "Po".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_short">
        <source>all punctuation characters</source>
        <target state="translated">Alle Satzzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_long">
        <source>All separator characters. This includes the Zs, Zl, and Zp categories.</source>
        <target state="translated">Alle Trennzeichen. Hierzu gehören die Kategorien "Zs", "Zl" und "Zp".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_short">
        <source>all separator characters</source>
        <target state="translated">Alle Trennzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_long">
        <source>All symbols. This includes the Sm, Sc, Sk, and So categories.</source>
        <target state="translated">Alle Symbole. Hierzu gehören die Kategorien "Sm", "Sc", "Sk" und "So".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_short">
        <source>all symbols</source>
        <target state="translated">Alle Symbole</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_long">
        <source>You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.</source>
        <target state="translated">Mit dem senkrechten Strich (|) können Sie eine beliebige Reihe von Mustern abgleichen, wobei das |-Zeichen die einzelnen Muster voneinander trennt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_short">
        <source>alternation</source>
        <target state="translated">Alternierung</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_long">
        <source>The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified by the 's' option, . matches any character.</source>
        <target state="translated">Der Punkt (.) stimmt mit einem beliebigen Zeichen außer "\n" überein (das Zeilenvorschubzeichen, \u000A). Wenn ein Muster für einen regulären Ausdruck durch die Option "RegexOptions.Singleline" geändert wird oder wenn der Teil des Musters, der die Zeichenklasse "." enthält, durch die Option "s" verändert wird, stimmt "." mit jedem beliebigen Zeichen überein.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_short">
        <source>any character</source>
        <target state="translated">Jedes Zeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_long">
        <source>Matches a backspace character, \u0008</source>
        <target state="translated">Entspricht einem Rückschrittzeichen, \u0008.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_short">
        <source>backspace character</source>
        <target state="translated">Rückschrittzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_long">
        <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.
    
'name1' is the current group (optional), 'name2' is a previously defined group, and 'subexpression' is any valid regular expression pattern. The balancing group definition deletes the definition of name2 and stores the interval between name2 and name1 in name1. If no name2 group is defined, the match backtracks. Because deleting the last definition of name2 reveals the previous definition of name2, this construct lets you use the stack of captures for group name2 as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.

The balancing group definition uses 'name2' as a stack. The beginning character of each nested construct is placed in the group and in its Group.Captures collection. When the closing character is matched, its corresponding opening character is removed from the group, and the Captures collection is decreased by one. After the opening and closing characters of all nested constructs have been matched, 'name1' is empty.</source>
        <target state="translated">Eine Ausgleichsgruppendefinition löscht die Definition einer zuvor definierten Gruppe und speichert in der aktuellen Gruppe das Intervall zwischen der zuvor definierten Gruppe und der aktuellen Gruppe.
    
"name1" ist die aktuelle Gruppe (optional), "name2" ist eine zuvor definierte Gruppe, und "teilausdruck" ist ein beliebiges gültiges Muster für reguläre Ausdrücke. Die Ausgleichsgruppendefinition löscht die Definition von "name2" und speichert das Intervall zwischen "name2" und "name1" in "name1". Wenn keine Gruppe "name2" definiert ist, wird für die Übereinstimmung eine Rückverfolgung durchgeführt. Weil durch das Löschen der letzten Definition von "name2" die vorherige Definition von "name2" angezeigt wird, können Sie mithilfe dieses Konstrukts den Stapel von Erfassungen für die Gruppe "name2" als Zähler für die Nachverfolgung geschachtelter Konstrukte wie z. B. öffnende und schließende Klammern verwenden.

Die Ausgleichsgruppendefinition verwendet "name2" als Stapel. Das Anfangszeichen der einzelnen geschachtelten Konstrukte wird in der Gruppe und in der zugehörigen Group.Captures-Sammlung platziert. Wenn das schließende Zeichen gefunden wurde, wird das entsprechende öffnende Zeichen aus der Gruppe entfernt, und die Captures-Sammlung wird um eins verringert. Nachdem die öffnenden und schließenden Zeichen aller geschachtelten Konstrukte abgeglichen wurden, ist "name1" leer.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_short">
        <source>balancing group</source>
        <target state="translated">Ausgleichsgruppe</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_base_group">
        <source>base-group</source>
        <target state="translated">Basisgruppe</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_long">
        <source>Matches a bell (alarm) character, \u0007</source>
        <target state="translated">Entspricht einem Glockenzeichen (Alarm), \u0007.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_short">
        <source>bell character</source>
        <target state="translated">Glockenzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_long">
        <source>Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n.</source>
        <target state="translated">Entspricht einem Wagenrücklaufzeichen, \u000D. Beachten Sie, dass "\r" nicht dem Zeilenvorschubzeichen "\n" entspricht.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_short">
        <source>carriage-return character</source>
        <target state="translated">Wagenrücklaufzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_long">
        <source>Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.

'base_group' is a positive or negative character group or range. The 'excluded_group' component is another positive or negative character group, or another character class subtraction expression (that is, you can nest character class subtraction expressions).</source>
        <target state="translated">Die Zeichenklassensubtraktion ergibt einen Satz von Zeichen, der auf dem Ausschließen der Zeichen einer Zeichenklasse von einer anderen Zeichenklasse beruht.

"base_group" ist eine positive oder negative Zeichengruppe bzw. ein positiver oder negativer Bereich. Die Komponente "excluded_group" ist eine andere positive oder negative Zeichengruppe oder ein anderer Ausdruck zur Zeichenklassensubtraktion (das heißt, Ausdrücke zur Zeichenklassensubtraktion können geschachtelt werden).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_short">
        <source>character class subtraction</source>
        <target state="translated">Zeichenklassensubtraktion</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_group">
        <source>character-group</source>
        <target state="translated">Zeichengruppe</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_comment">
        <source>comment</source>
        <target state="translated">Kommentar</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.

'expression' is the initial pattern to match, 'yes' is the pattern to match if expression is matched, and 'no' is the optional pattern to match if expression is not matched.</source>
        <target state="translated">Dieses Sprachelement unternimmt den Abgleich mit einem von zwei Mustern abhängig davon, ob der Abgleich mit einem Anfangsmuster möglich ist.

"expression" ist das anfängliche Muster für den Abgleich, "yes" ist das Muster, das bei Übereinstimmung des Ausdrucks abgeglichen werden soll, und "No" ist das optionale Muster, das abgeglichen werden soll, wenn der Ausdruck nicht übereinstimmt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_short">
        <source>conditional expression match</source>
        <target state="translated">Abgleich mit bedingtem Ausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.

'name' is the name (or number) of a capturing group, 'yes' is the expression to match if 'name' (or 'number') has a match, and 'no' is the optional expression to match if it does not.</source>
        <target state="translated">Dieses Sprachelement unternimmt den Abgleich mit einem von zwei Mustern abhängig davon, ob eine Übereinstimmung mit einer angegebenen Erfassungsgruppe vorliegt.

"name" ist der Name (oder die Zahl) einer Erfassungsgruppe, "yes" ist der Ausdruck, der bei einer Übereinstimmung für "name" (oder "number") abgeglichen werden soll, und "no" ist der optionale Ausdruck, der andernfalls abgeglichen wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_short">
        <source>conditional group match</source>
        <target state="translated">Abgleich mit bedingter Gruppe</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_long">
        <source>The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.</source>
        <target state="translated">Der \G-Anker gibt an, dass eine Übereinstimmung an dem Punkt erfolgen muss, an dem die vorherige Übereinstimmung endete. Wenn Sie diesen Anker mit der Regex.Matches- oder der Match.NextMatch-Methode verwenden, wird sichergestellt, dass alle Übereinstimmungen zusammenhängen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_short">
        <source>contiguous matches</source>
        <target state="translated">Zusammenhängende Übereinstimmungen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_long">
        <source>Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C.</source>
        <target state="translated">Entspricht einem ASCII-Steuerzeichen, wobei "X" der Buchstabe des Steuerzeichens ist. Beispiel: "\cC" steht für STRG-C.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_short">
        <source>control character</source>
        <target state="translated">Steuerzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_long">
        <source>\d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.

If ECMAScript-compliant behavior is specified, \d is equivalent to [0-9]</source>
        <target state="translated">"\d" entspricht einer beliebigen Dezimalzahl. Identisch mit dem Muster für reguläre Ausdrücke "\p{Nd}", welches die Standarddezimalzahlen 0–9 sowie die Dezimalzahlen einer Reihe anderer Zeichensätze enthält.

Wenn das ECMAScript-konforme Verhalten angegeben wird, ist "\d" gleichbedeutend mit "[0-9]".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_short">
        <source>decimal-digit character</source>
        <target state="translated">Dezimalzahl</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_long">
        <source>A number sign (#) marks an x-mode comment, which starts at the unescaped # character at the end of the regular expression pattern and continues until the end of the line. To use this construct, you must either enable the x option (through inline options) or supply the RegexOptions.IgnorePatternWhitespace value to the option parameter when instantiating the Regex object or calling a static Regex method.</source>
        <target state="translated">Ein Nummernzeichen (#) markiert einen Kommentar im x-Modus, der am Ende des Musters für reguläre Ausdrücke bei dem #-Zeichen ohne Escapezeichen beginnt und bis zum Zeilenende fortgesetzt wird. Um dieses Konstrukt zu verwenden, müssen Sie entweder die x-Option (über Inlineoptionen) aktivieren oder den RegexOptions.IgnorePatternWhitespace-Wert beim Instanziieren des Regex-Objekts oder beim Aufrufen einer statischen Regex-Methode an den Optionsparameter übergeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_short">
        <source>end-of-line comment</source>
        <target state="translated">Kommentar am Zeilenende</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_long">
        <source>The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, it can only match the last line of the input string.</source>
        <target state="translated">Der \z-Anker gibt an, dass eine Übereinstimmung am Ende der Eingabezeichenfolge erfolgen muss. Wie das $-Sprachelement ignoriert \z die Option "RegexOptions.Multiline". Im Gegensatz zum \Z-Sprachelement stimmt \z nicht mit einem \n-Zeichen am Ende einer Zeichenfolge überein. Daher ist nur eine Übereinstimmung mit der letzten Zeile der Eingabezeichenfolge möglich.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_short">
        <source>end of string only</source>
        <target state="translated">Nur Ende der Zeichenfolge</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_long">
        <source>The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can only match the end of the last line, or the last line before \n.

The \Z anchor matches \n but does not match \r\n (the CR/LF character combination). To match CR/LF, include \r?\Z in the regular expression pattern.</source>
        <target state="translated">Der \Z-Anker gibt an, dass eine Übereinstimmung am Ende der Eingabezeichenfolge oder vor "\n" am Ende der Eingabezeichenfolge erfolgen muss. \Z ist mit dem $-Anker identisch, außer dass \Z die Option "RegexOptions.Multiline" ignoriert. Daher ist in einer mehrzeiligen Zeichenfolge nur eine Übereinstimmung mit dem Ende der letzten Zeile oder der letzten Zeile vor "\n" möglich.

Der \Z-Anker entspricht "\n", stimmt jedoch nicht mit "\r\n" überein (CR/LF-Zeichenkombination). Schließen Sie "\r?\Z" in das Muster für reguläre Ausdrücke ein, um die Übereinstimmung mit CR/LF zu erreichen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_short">
        <source>end of string or before ending newline</source>
        <target state="translated">Ende der Zeichenfolge oder vor dem endenden Zeilenumbruch</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_long">
        <source>The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string. If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line.

The $ anchor matches \n but does not match \r\n (the combination of carriage return and newline characters, or CR/LF). To match the CR/LF character combination, include \r?$ in the regular expression pattern.</source>
        <target state="translated">Der $-Anker gibt an, dass das vorangehende Muster am Ende der Eingabezeichenfolge oder vor "\n" am Ende der Eingabezeichenfolge vorliegen muss. Wenn Sie $ mit der Option "RegexOptions.Multiline" verwenden, kann die Übereinstimmung auch am Ende einer Zeile erfolgen.

Der $-Anker stimmt mit "\n", aber nicht mit "\r\n" überein (Kombination aus Wagenrücklauf- und Zeilenvorschubzeichen, auch CR/LF). Um der Kombination aus CR/LF-Zeichen zu entsprechen, schließen Sie "\r?$" in das Muster für reguläre Ausdrücke ein.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_short">
        <source>end of string or line</source>
        <target state="translated">Ende der Zeichenfolge oder Zeile</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_long">
        <source>Matches an escape character, \u001B</source>
        <target state="translated">Entspricht einem Escapezeichen, \u001B.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_short">
        <source>escape character</source>
        <target state="translated">Escapezeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_excluded_group">
        <source>excluded-group</source>
        <target state="translated">Ausschlussgruppe</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_expression">
        <source>expression</source>
        <target state="translated">expression</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_long">
        <source>Matches a form-feed character, \u000C</source>
        <target state="translated">Entspricht einem Seitenvorschubzeichen, \u000C.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_short">
        <source>form-feed character</source>
        <target state="translated">Seitenvorschubzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_long">
        <source>This grouping construct applies or disables the specified options within a subexpression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly
	named or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">Dieses Gruppierungskonstrukt wendet die angegebenen Optionen innerhalb eines Unterausdrucks an oder deaktiviert sie. Die zu aktivierenden Optionen werden nach dem Fragezeichen und die zu deaktivierenden Optionen nach dem Minuszeichen angegeben. Zulässige Optionen:

    i	Führt den Abgleich ohne Unterscheidung nach Groß-/Kleinschreibung durch.
    m	Verwendet den mehrzeiligen Modus, wobei "^" und "$" mit Anfang und Ende jeder einzelnen Zeile übereinstimmen
	(anstelle von Anfang und Ende der Eingabezeichenfolge).
    s	Verwendet den einzeiligen Modus, wobei der Punkt (.) mit jedem Zeichen übereinstimmt
	(anstelle von jedem Zeichen außer "\n").
    n	Erfasst keine unbenannten Gruppen. Die einzigen gültigen Erfassungen sind explizit
	benannte oder nummerierte Gruppen im Format (?&lt;name&gt; Teilausdruck).
    x	Schließt Leerraum ohne Escapezeichen aus dem Muster aus und aktiviert Kommentare
	nach einem Nummernzeichen (#).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_short">
        <source>group options</source>
        <target state="translated">Gruppenoptionen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_long">
        <source>Matches an ASCII character, where ## is a two-digit hexadecimal character code.</source>
        <target state="translated">Entspricht einem ASCII-Zeichen, wobei ## ein zweistelliger hexadezimaler Zeichencode ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_short">
        <source>hexadecimal escape</source>
        <target state="translated">Hexadezimale Escapezeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_long">
        <source>The (?# comment) construct lets you include an inline comment in a regular expression. The regular expression engine does not use any part of the comment in pattern matching, although the comment is included in the string that is returned by the Regex.ToString method. The comment ends at the first closing parenthesis.</source>
        <target state="translated">Mit dem Konstrukt (?# Kommentar) können Sie einen Inlinekommentar in einen regulären Ausdruck einbeziehen. Die Engine für reguläre Ausdrücke verwendet keinen Teil des Kommentars beim Musterabgleich, auch wenn der Kommentar in der Zeichenfolge enthalten ist, die von der Regex.ToString-Methode zurückgegeben wird. Der Kommentar endet bei der ersten schließenden Klammer.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_short">
        <source>inline comment</source>
        <target state="translated">Inlinekommentar</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_long">
        <source>Enables or disables specific pattern matching options for the remainder of a regular expression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly named
	or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">Aktiviert oder deaktiviert bestimmte Optionen zum Musterabgleich für den Rest eines regulären Ausdrucks. Die zu aktivierenden Optionen werden nach dem Fragezeichen und die zu deaktivierenden Optionen nach dem Minuszeichen angegeben. Zulässige Optionen:

    i	Führt den Abgleich ohne Unterscheidung nach Groß-/Kleinschreibung durch.
    m	Verwendet den mehrzeiligen Modus, wobei "^" und "$" mit Anfang und Ende jeder einzelnen Zeile übereinstimmen
	(anstelle von Anfang und Ende der Eingabezeichenfolge).
    s	Verwendet den einzeiligen Modus, wobei der Punkt (.) mit jedem Zeichen übereinstimmt
	(anstelle von jedem Zeichen außer "\n").
    n	Erfasst keine unbenannten Gruppen. Die einzigen gültigen Erfassungen sind explizit
	benannte oder nummerierte Gruppen im Format (?&lt;name&gt; Teilausdruck).
    x	Schließt Leerraum ohne Escapezeichen aus dem Muster aus und aktiviert Kommentare
	nach einem Nummernzeichen (#).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_short">
        <source>inline options</source>
        <target state="translated">Inlineoptionen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_lowercase">
        <source>letter, lowercase</source>
        <target state="translated">Buchstabe, Kleinbuchstabe</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_modifier">
        <source>letter, modifier</source>
        <target state="translated">Buchstabe, Modifizierer</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_other">
        <source>letter, other</source>
        <target state="translated">Buchstabe, sonstiger</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_titlecase">
        <source>letter, titlecase</source>
        <target state="translated">Buchstabe, erster Buchstabe groß</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_uppercase">
        <source>letter, uppercase</source>
        <target state="translated">Buchstabe, Großbuchstabe</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_enclosing">
        <source>mark, enclosing</source>
        <target state="translated">Zeichen, einschließendes Zeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_nonspacing">
        <source>mark, nonspacing</source>
        <target state="translated">Zeichen, Zeichen ohne eigene Breite</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_spacing_combining">
        <source>mark, spacing combining</source>
        <target state="translated">Zeichen, Zeichen mit eigener Breite, Verbindung</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_long">
        <source>The {n,}? quantifier matches the preceding element at least n times, where n is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,}</source>
        <target state="translated">Der Quantifizierer "{n,}?" stimmt mit dem vorhergehenden Element mindestens n-mal, jedoch möglichst wenige Male überein. "n" steht hierbei für eine beliebige ganze Zahl. Dies ist das träge Äquivalent zum gierigen Quantifizierer "{n,}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">Mindestens n-malige Übereinstimmung (träge)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_long">
        <source>The {n,} quantifier matches the preceding element at least n times, where n is any integer. {n,} is a greedy quantifier whose lazy equivalent is {n,}?</source>
        <target state="translated">Der Quantifizierer "{n,}" stimmt mit dem vorhergehenden Element mindestens n-mal überein. "n" steht hierbei für eine beliebige ganze Zahl. "{n,}" ist ein gieriger Quantifizierer, dessen träges Äquivalent "{n,}?" lautet.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_short">
        <source>match at least 'n' times</source>
        <target state="translated">Mindestens n-malige Übereinstimmung</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_long">
        <source>The {n,m}? quantifier matches the preceding element between n and m times, where n and m are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,m}</source>
        <target state="translated">Der Quantifizierer "{n,m}?" stimmt mit dem vorhergehenden Element zwischen n- und m-mal, jedoch möglichst wenige Male überein. "n" und "m" stehen hierbei für ganze Zahlen. Dies ist das träge Äquivalent zum gierigen Quantifizierer "{n,m}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">Mindestens n-malige Übereinstimmung (träge)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_long">
        <source>The {n,m} quantifier matches the preceding element at least n times, but no more than m times, where n and m are integers. {n,m} is a greedy quantifier whose lazy equivalent is {n,m}?</source>
        <target state="translated">Der Quantifizierer "{n,m}" stimmt mit dem vorhergehenden Element mindestens n-mal, aber nicht häufiger als m-mal überein. "n" und "m" stehen hierbei für ganze Zahlen. "{n,m}" ist ein gieriger Quantifizierer, dessen träges Äquivalent "{n,m}?" lautet.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_short">
        <source>match between 'm' and 'n' times</source>
        <target state="translated">Zwischen m- und n-malige Übereinstimmung</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_long">
        <source>The {n}? quantifier matches the preceding element exactly n times, where n is any integer. It is the lazy counterpart of the greedy quantifier {n}+</source>
        <target state="translated">Der Quantifizierer {n}? stimmt mit dem vorhergehenden Element genau n-mal überein. "n" steht hierbei für eine beliebige ganze Zahl. Dies ist das träge Äquivalent zum gierigen Quantifizierer "{n}+".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_short">
        <source>match exactly 'n' times (lazy)</source>
        <target state="translated">Genau n-malige Übereinstimmung (träge)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_long">
        <source>The {n} quantifier matches the preceding element exactly n times, where n is any integer. {n} is a greedy quantifier whose lazy equivalent is {n}?</source>
        <target state="translated">Der Quantifizierer "{n}" stimmt mit dem vorhergehenden Element genau n-mal überein. "n" steht hierbei für eine beliebige ganze Zahl. "{n}" ist ein gieriger Quantifizierer, dessen träges Äquivalent "{n}?" lautet.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_short">
        <source>match exactly 'n' times</source>
        <target state="translated">Genau n-malige Übereinstimmung</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_long">
        <source>The +? quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier +</source>
        <target state="translated">Der Quantifizierer "+?" stimmt mit dem vorhergehenden Element mindestens einmal, jedoch möglichst wenige Male überein. Dies ist das träge Äquivalent zum gierigen Quantifizierer "+".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_short">
        <source>match one or more times (lazy)</source>
        <target state="translated">Mindestens einmalige Übereinstimmung (träge)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_long">
        <source>The + quantifier matches the preceding element one or more times. It is equivalent to the {1,} quantifier. + is a greedy quantifier whose lazy equivalent is +?.</source>
        <target state="translated">Der Quantifizierer "+" stimmt mit dem vorhergehenden Element mindestens einmal überein. Dieser Quantifizierer ist identisch mit "{1,}". "+" ist ein gieriger Quantifizierer, dessen träges Äquivalent "+?" lautet.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_short">
        <source>match one or more times</source>
        <target state="translated">Mindestens einmalige Übereinstimmung</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_long">
        <source>The *? quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier *</source>
        <target state="translated">Der Quantifizierer "*?" stimmt mit dem vorhergehenden Element mindestens nullmal, jedoch möglichst wenige Male überein. Dies ist das träge Äquivalent zum gierigen Quantifizierer "*".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_short">
        <source>match zero or more times (lazy)</source>
        <target state="translated">Mindestens nullmalige Übereinstimmung (träge)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_long">
        <source>The * quantifier matches the preceding element zero or more times. It is equivalent to the {0,} quantifier. * is a greedy quantifier whose lazy equivalent is *?.</source>
        <target state="translated">Der Quantifizierer "*" stimmt mit dem vorhergehenden Element mindestens nullmal überein. Dieser Quantifizierer ist identisch mit "{0,}". "*" ist ein gieriger Quantifizierer, dessen träges Äquivalent "*?" lautet.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_short">
        <source>match zero or more times</source>
        <target state="translated">Mindestens nullmalige Übereinstimmung</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_long">
        <source>The ?? quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier ?</source>
        <target state="translated">Der Quantifizierer "??" stimmt mit dem vorhergehenden Element null- oder einmal, jedoch möglichst wenige Male überein. Dies ist das träge Äquivalent zum gierigen Quantifizierer "?".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_short">
        <source>match zero or one time (lazy)</source>
        <target state="translated">Null- oder einmalige Übereinstimmung (träge)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_long">
        <source>The ? quantifier matches the preceding element zero or one time. It is equivalent to the {0,1} quantifier. ? is a greedy quantifier whose lazy equivalent is ??.</source>
        <target state="translated">Der Quantifizierer "?" stimmt mit dem vorhergehenden Element null- oder einmal überein. Dieser Quantifizierer ist identisch mit "{0,1}". "?" ist ein gieriger Quantifizierer, dessen träges Äquivalent "??" lautet.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_short">
        <source>match zero or one time</source>
        <target state="translated">Null- oder einmalige Übereinstimmung</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_long">
        <source>This grouping construct captures a matched 'subexpression', where 'subexpression' is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one. The capture that is numbered zero is the text matched by the entire regular expression pattern.</source>
        <target state="translated">Dieses Gruppierungskonstrukt erfasst einen übereinstimmenden "Teilausdruck", wobei "Teilausdruck" für ein beliebiges gültiges Muster für reguläre Ausdrücke steht. Erfassungen, die Klammern verwenden, werden basierend auf der Reihenfolge der öffnenden Klammern im regulären Ausdruck beginnend bei 1 automatisch von links nach rechts nummeriert. Bei der Erfassung mit der Nummerierung 0 handelt es sich um den Text, der mit dem gesamten Muster für reguläre Ausdrücke übereinstimmt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_short">
        <source>matched subexpression</source>
        <target state="translated">Übereinstimmender Teilausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name">
        <source>name</source>
        <target state="translated">Name</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name1">
        <source>name1</source>
        <target state="translated">name1</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name2">
        <source>name2</source>
        <target state="translated">name2</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name_or_number">
        <source>name-or-number</source>
        <target state="translated">name-or-number</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_long">
        <source>A named or numbered backreference.

'name' is the name of a capturing group defined in the regular expression pattern.</source>
        <target state="translated">Ein benannter oder nummerierter Rückverweis.

"Name" ist der Name einer Erfassungsgruppe, die im Muster für reguläre Ausdrücke definiert ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_short">
        <source>named backreference</source>
        <target state="translated">Benannter Rückverweis</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_long">
        <source>Captures a matched subexpression and lets you access it by name or by number.

'name' is a valid group name, and 'subexpression' is any valid regular expression pattern. 'name' must not contain any punctuation characters and cannot begin with a number.

If the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the only way to capture a subexpression is to explicitly name capturing groups.</source>
        <target state="translated">Erfasst einen übereinstimmenden Teilausdruck und ermöglicht Ihnen den Zugriff darauf anhand des Namens oder der Nummer.

"Name" ist ein gültiger Gruppenname, und "Teilausdruck" ist ein gültiges Muster für reguläre Ausdrücke. "Name" darf keine Satzzeichen enthalten und nicht mit einer Zahl beginnen.

Wenn der RegexOptions-Parameter einer Methode zum Abgleich von Mustern für reguläre Ausdrücke das Flag "RegexOptions.ExplicitCapture" enthält oder wenn die Option "n" auf diesen Teilausdruck angewendet wird, besteht die einzige Möglichkeit zum Erfassen eines Unterausdrucks darin, die Erfassungsgruppen explizit zu benennen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_short">
        <source>named matched subexpression</source>
        <target state="translated">Benannter übereinstimmender Teilausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_long">
        <source>A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters are specified individually.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">Eine negative Zeichengruppe gibt eine Liste von Zeichen an, die nicht in einer Eingabezeichenfolge vorkommen dürfen, damit eine Übereinstimmung vorliegt. Die Zeichen in der Liste werden einzeln angegeben.

Mehrere Zeichenbereiche können verkettet werden. Um beispielsweise den Bereich der Dezimalstellen von "0" bis "9", den Bereich der Kleinbuchstaben von "a" bis "f" und den Bereich der Großbuchstaben von "A" bis "F" anzugeben, verwenden Sie "[0-9a-fA-F]".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_short">
        <source>negative character group</source>
        <target state="translated">Negative Zeichengruppe</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_range_long">
        <source>A negative character range specifies a list of characters that must not appear in an input string for a match to occur. 'firstCharacter' is the character that begins the range, and 'lastCharacter' is the character that ends the range.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">Ein negativer Zeichenbereich gibt eine Liste von Zeichen an, die nicht in einer Eingabezeichenfolge vorkommen dürfen, damit eine Übereinstimmung vorliegt. "firstCharacter" entspricht dem ersten Zeichen und "lastCharacter" dem letzten Zeichen im Bereich.

Mehrere Zeichenbereiche können verkettet werden. Um beispielsweise den Bereich der Dezimalstellen von "0" bis "9", den Bereich der Kleinbuchstaben von "a" bis "f" und den Bereich der Großbuchstaben von "A" bis "F" anzugeben, verwenden Sie "[0-9a-fA-F]".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_range_short">
        <source>negative character range</source>
        <target state="translated">Negativer Zeichenbereich</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_long">
        <source>The regular expression construct \P{ name } matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">Das Konstrukt des regulären Ausdrucks "\P{ name }" entspricht einem beliebigen Zeichen, das zu keiner allgemeinen Unicode-Kategorie bzw. keinem benannten Block gehört, wobei "name" der Kategorieabkürzung oder dem Namen des benannten Blocks entspricht.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_short">
        <source>negative unicode category</source>
        <target state="translated">Negative Unicode-Kategorie</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_long">
        <source>Matches a new-line character, \u000A</source>
        <target state="translated">Entspricht einem Neue-Zeile-Zeichen, \u000A.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_short">
        <source>new-line character</source>
        <target state="translated">Neue-Zeile-Zeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_no">
        <source>no</source>
        <target state="translated">Nein</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_long">
        <source>\D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.

If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9]</source>
        <target state="translated">"\D" entspricht einem beliebigen Zeichen, das keine Ziffer darstellt. Entspricht dem Muster für reguläre Ausdrücke "\P{Nd}".

Wenn das ECMAScript-konforme Verhalten angegeben wird, ist "\D" gleichbedeutend mit "[^0-9]".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_short">
        <source>non-digit character</source>
        <target state="translated">Nicht-Ziffernzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_long">
        <source>\S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.

If ECMAScript-compliant behavior is specified, \S is equivalent to [^ \f\n\r\t\v]</source>
        <target state="translated">"\S" entspricht einem beliebigen Nicht-Leerraumzeichen. Dies ist identisch mit dem Muster für reguläre Ausdrücke "[^\f\n\r\t\v\x85\p{Z}]" oder mit dem Gegenteil des Musters für reguläre Ausdrücke "\s", welches mit Leerraumzeichen übereinstimmt.

Wenn das ECMAScript-konforme Verhalten angegeben wird, ist "\S" gleichbedeutend mit "[^ \f\n\r\t\v]".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_short">
        <source>non-white-space character</source>
        <target state="translated">Nicht-Leerraumzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_long">
        <source>The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor.</source>
        <target state="translated">Der \B-Anker gibt an, dass die Übereinstimmung nicht an einer Wortgrenze auftreten darf. Dies ist das Gegenteil vom \b-Anker.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_short">
        <source>non-word boundary</source>
        <target state="translated">Nicht-Wortgrenze</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_character_long">
        <source>\W matches any non-word character. It matches any character except for those in the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \W is equivalent to [^a-zA-Z_0-9]</source>
        <target state="translated">"\W" entspricht einem beliebigen Nicht-Wortzeichen. Stimmt mit einem beliebigen Zeichen überein, das nicht in den folgenden Unicode-Kategorien enthalten ist:

    Ll	Buchstabe, Kleinbuchstabe
    Lu	Buchstabe, Großbuchstabe
    Lt	Buchstabe, erster Buchstabe groß
    Lo	Buchstabe, sonstige
    Lm	Buchstabe, Modifizierer
    Mn	Zeichen, Zeichen ohne eigene Breite
    Nd	Zahl, Dezimalzahl
    Pc	Interpunktion, Verbindung

Wenn das ECMAScript-konforme Verhalten angegeben wird, ist "\W" gleichbedeutend mit "[^a-zA-Z_0-9]".</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized. </note>
      </trans-unit>
      <trans-unit id="Regex_non_word_character_short">
        <source>non-word character</source>
        <target state="translated">Nicht-Wortzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_nonbacktracking_subexpression_long">
        <source>This construct disables backtracking. The regular expression engine will match as many characters in the input string as it can. When no further match is possible, it will not backtrack to attempt alternate pattern matches. (That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)

This option is recommended if you know that backtracking will not succeed. Preventing the regular expression engine from performing unnecessary searching improves performance.</source>
        <target state="translated">Dieses Konstrukt deaktiviert die Rückverfolgung. Die Engine für reguläre Ausdrücke gleicht so viele Zeichen in der Eingabezeichenfolge wie möglich ab. Wenn kein weiterer Abgleich möglich ist, wird keine Rückverfolgung durchgeführt, um alternative Musterabgleiche zu versuchen. (Das heißt, der Teilausdruck stimmt nur mit Zeichenfolgen überein, die dem Teilausdruck allein entsprechen; es wird nicht versucht, eine Zeichenfolge basierend auf dem Teilausdruck und allen nachfolgenden Teilausdrücken abzugleichen.)

Diese Option empfiehlt sich, wenn Sie wissen, dass die Rückverfolgung nicht zum Erfolg führt. Indem Sie die Ausführung unnötiger Suchvorgänge durch die Engine für reguläre Ausdrücke verhindern, erzielen Sie eine verbesserte Leistung.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_nonbacktracking_subexpression_short">
        <source>nonbacktracking subexpression</source>
        <target state="translated">Teilausdruck ohne Rückverfolgung</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_long">
        <source>This construct does not capture the substring that is matched by a subexpression:

The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.

If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
        <target state="translated">Dieses Konstrukt erfasst nicht die Teilzeichenfolge, die mit einem Teilausdruck übereinstimmt:

Das Konstrukt der Nicht-Erfassungsgruppe wird normalerweise verwendet, wenn ein Quantifizierer auf eine Gruppe angewendet wird, die von der Gruppe erfassten Teilzeichenfolgen jedoch nicht relevant sind.

Wenn ein regulärer Ausdruck geschachtelte Gruppierungskonstrukte enthält, gilt ein äußeres Konstrukt von Nicht-Erfassungsgruppen nicht für die inneren geschachtelten Gruppenkonstrukte.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_short">
        <source>noncapturing group</source>
        <target state="translated">Nicht-Erfassungsgruppe</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_decimal_digit">
        <source>number, decimal digit</source>
        <target state="translated">Zahl, Dezimalzahl</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_letter">
        <source>number, letter</source>
        <target state="translated">Zahl, Buchstabe</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_other">
        <source>number, other</source>
        <target state="translated">Zahl, sonstige</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_long">
        <source>A numbered backreference, where 'number' is the ordinal position of the capturing group in the regular expression. For example, \4 matches the contents of the fourth capturing group.

There is an ambiguity between octal escape codes (such as \16) and \number backreferences that use the same notation. If the ambiguity is a problem, you can use the \k&lt;name&gt; notation, which is unambiguous and cannot be confused with octal character codes. Similarly, hexadecimal codes such as \xdd are unambiguous and cannot be confused with backreferences.</source>
        <target state="translated">Ein nummerierter Rückverweis, wobei "zahl" für die Ordnungsposition der Erfassungsgruppe im regulären Ausdruck steht. Beispiel: \4 entspricht dem Inhalt der vierten Erfassungsgruppe.

Es besteht eine Mehrdeutigkeit zwischen den Escapecodes für Oktalzahlen (z. B. \16) und den \zahl-Rückverweisen, die dieselbe Notation verwenden. Wenn die Mehrdeutigkeit ein Problem darstellt, können Sie die \k&lt;name&gt;-Notation verwenden, die eindeutig ist und nicht mit Oktalzeichencodes verwechselt werden kann. Ebenso eindeutig sind hexadezimale Codes wie \xdd, die nicht mit Rückverweisen verwechselt werden können.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_short">
        <source>numbered backreference</source>
        <target state="translated">Nummerierter Rückverweis</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_control">
        <source>other, control</source>
        <target state="translated">Sonstige, Steuerelement</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_format">
        <source>other, format</source>
        <target state="translated">Sonstige, Format</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_not_assigned">
        <source>other, not assigned</source>
        <target state="translated">Sonstige, nicht zugewiesen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_private_use">
        <source>other, private use</source>
        <target state="translated">Sonstige, private Nutzung</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_surrogate">
        <source>other, surrogate</source>
        <target state="translated">Sonstige, Ersatzzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_long">
        <source>A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur.</source>
        <target state="translated">Eine positive Zeichengruppe gibt eine Liste von Zeichen an, von denen jedes in einer Eingabezeichenfolge enthalten sein kann, damit eine Übereinstimmung auftritt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_short">
        <source>positive character group</source>
        <target state="translated">Positive Zeichengruppe</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_long">
        <source>A positive character range specifies a range of characters, any one of which may appear in an input string for a match to occur.  'firstCharacter' is the character that begins the range and 'lastCharacter' is the character that ends the range. </source>
        <target state="translated">Ein positiver Zeichenbereich gibt einen Bereich von Zeichen an, von denen jedes in einer Eingabezeichenfolge enthalten sein kann, damit eine Übereinstimmung auftritt. "firstCharacter" ist das erste Zeichen und "lastCharacter" das letzte Zeichen des Bereichs. </target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_short">
        <source>positive character range</source>
        <target state="translated">Positiver Zeichenbereich</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_close">
        <source>punctuation, close</source>
        <target state="translated">Interpunktion, schließen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_connector">
        <source>punctuation, connector</source>
        <target state="translated">Interpunktion, Verbindung</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_dash">
        <source>punctuation, dash</source>
        <target state="translated">Interpunktion, Bindestrich</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_final_quote">
        <source>punctuation, final quote</source>
        <target state="translated">Interpunktion, schließendes Anführungszeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_initial_quote">
        <source>punctuation, initial quote</source>
        <target state="translated">Interpunktion, öffnendes Anführungszeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_open">
        <source>punctuation, open</source>
        <target state="translated">Interpunktion, öffnen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_other">
        <source>punctuation, other</source>
        <target state="translated">Interpunktion, sonstige</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_line">
        <source>separator, line</source>
        <target state="translated">Trennzeichen, Zeile</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_paragraph">
        <source>separator, paragraph</source>
        <target state="translated">Trennzeichen, Absatz</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_space">
        <source>separator, space</source>
        <target state="translated">Trennzeichen, Leerzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_long">
        <source>The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input string.</source>
        <target state="translated">Der \A-Anker gibt an, dass eine Übereinstimmung am Anfang der Eingabezeichenfolge erfolgen muss. Er ist identisch mit dem ^-Anker, mit der Ausnahme, dass \A die Option "RegexOptions.Multiline" ignoriert. Daher ist nur eine Übereinstimmung mit dem Anfang der ersten Zeile in einer mehrzeiligen Eingabezeichenfolge möglich.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_short">
        <source>start of string only</source>
        <target state="translated">Nur Anfang der Zeichenfolge</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_long">
        <source>The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.</source>
        <target state="translated">Der ^-Anker gibt an, dass das folgende Muster an der ersten Zeichenposition der Zeichenfolge beginnen muss. Wenn Sie "^" mit der Option "RegexOptions.Multiline" verwenden, muss die Übereinstimmung am Anfang jeder Zeile erfolgen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_short">
        <source>start of string or line</source>
        <target state="translated">Anfang der Zeichenfolge oder Zeile</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_subexpression">
        <source>subexpression</source>
        <target state="translated">Teilausdruck</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_currency">
        <source>symbol, currency</source>
        <target state="translated">Symbol, Währung</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_math">
        <source>symbol, math</source>
        <target state="translated">Symbol, Mathematik</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_modifier">
        <source>symbol, modifier</source>
        <target state="translated">Symbol, Modifizierer</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_other">
        <source>symbol, other</source>
        <target state="translated">Symbol, sonstige</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_long">
        <source>Matches a tab character, \u0009</source>
        <target state="translated">Entspricht einem Tabstoppzeichen, \u0009.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_short">
        <source>tab character</source>
        <target state="translated">Tabstoppzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_long">
        <source>The regular expression construct \p{ name } matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">Das Konstrukt des regulären Ausdrucks "\p{ name }" entspricht einem beliebigen Zeichen, das zu einer allgemeinen Unicode-Kategorie oder einem benannten Block gehört, wobei "name" der Kategorieabkürzung oder dem Namen des benannten Blocks entspricht.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_short">
        <source>unicode category</source>
        <target state="translated">Unicode-Kategorie</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_long">
        <source>Matches a UTF-16 code unit whose value is #### hexadecimal.</source>
        <target state="translated">Entspricht einer UTF-16-Codeeinheit, deren Wert hexadezimal (####) ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_short">
        <source>unicode escape</source>
        <target state="translated">Unicode-Escapezeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_general_category_0">
        <source>Unicode General Category: {0}</source>
        <target state="translated">Allgemeine Unicode-Kategorie: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_long">
        <source>Matches a vertical-tab character, \u000B</source>
        <target state="translated">Entspricht einem vertikalen Tabstoppzeichen, \u000B.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_short">
        <source>vertical-tab character</source>
        <target state="translated">Vertikales Tabstoppzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_long">
        <source>\s matches any white-space character. It is equivalent to the following escape sequences and Unicode categories:

    \f	The form feed character, \u000C
    \n	The newline character, \u000A
    \r	The carriage return character, \u000D
    \t	The tab character, \u0009
    \v	The vertical tab character, \u000B
    \x85	The ellipsis or NEXT LINE (NEL) character (…), \u0085
    \p{Z}	Matches any separator character

If ECMAScript-compliant behavior is specified, \s is equivalent to [ \f\n\r\t\v]</source>
        <target state="translated">"\s" stimmt mit einem beliebigen Leerraumzeichen überein. Entspricht den folgenden Escapesequenzen und Unicode-Kategorien:

    \f	Das Seitenvorschubzeichen, \u000C
    \n	Das Zeilenvorschubzeichen, \u000A
    \r	Das Wagenrücklaufzeichen, \u000D
    \t	Das Tabstoppzeichen, \u0009
    \v	Das vertikale Tabstoppzeichen, \u000B
    \x85	Das Auslassungszeichen oder NEL-Zeichen für die nächste Zeile (...), \u0085
    \p{Z}	Entspricht einem beliebigen Trennzeichen

Wenn das ECMAScript-konforme Verhalten angegeben wird, ist "\s" gleichbedeutend mit "[\f\n\r\t\v]".</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_short">
        <source>white-space character</source>
        <target state="translated">Leerraumzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_long">
        <source>The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore. The match may also occur on a word boundary at the beginning or end of the string.

The \b anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
        <target state="translated">Der \b-Anker gibt an, dass die Übereinstimmung an einer Grenze zwischen einem Wortzeichen (dem \w-Sprachelement) und einem Nicht-Wortzeichen (dem \W-Sprachelement) erfolgen muss. Wortzeichen bestehen aus alphanumerischen Zeichen und Unterstrichen; ein Nicht-Wortzeichen ist ein beliebiges Zeichen, das nicht alphanumerisch oder ein Unterstrich ist. Die Übereinstimmung kann auch an einer Wortgrenze am Anfang oder Ende der Zeichenfolge auftreten.

Der \b-Anker wird häufig verwendet, um sicherzustellen, dass ein Teilausdruck mit einem ganzen Wort statt nur mit dem Anfang oder Ende eines Worts übereinstimmt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_short">
        <source>word boundary</source>
        <target state="translated">Wortgrenze</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_character_long">
        <source>\w matches any word character. A word character is a member of any of the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \w is equivalent to [a-zA-Z_0-9]</source>
        <target state="translated">"\w" entspricht einem beliebigen Wortzeichen. Ein Wortzeichen gehört zu einer der folgenden Unicode-Kategorien:

    Ll	Buchstabe, Kleinbuchstabe
    Lu	Buchstabe, Großbuchstabe
    Lt	Buchstabe, erster Buchstabe groß
    Lo	Buchstabe, sonstige
    Lm	Buchstabe, Modifizierer
    Mn	Zeichen, Zeichen ohne eigene Breite
    Nd	Zahl, Dezimalzahl
    Pc	Interpunktion, Verbindung

Wenn das ECMAScript-konforme Verhalten angegeben wird, ist "\w" gleichbedeutend mit "[a-zA-Z_0-9]".</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized.</note>
      </trans-unit>
      <trans-unit id="Regex_word_character_short">
        <source>word character</source>
        <target state="translated">Wortzeichen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_yes">
        <source>yes</source>
        <target state="translated">Ja</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_long">
        <source>A zero-width negative lookahead assertion, where for the match to be successful, the input string must not match the regular expression pattern in subexpression. The matched string is not included in the match result.

A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression. At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched. In this case, it is often used to limit backtracking. At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
        <target state="translated">Eine negative Lookaheadassertion mit Nullbreite, bei der eine Übereinstimmung erfolgreich ist, wenn die Eingabezeichenfolge nicht dem Muster für reguläre Ausdrücke im Teilausdruck entspricht. Die übereinstimmende Zeichenfolge ist im Übereinstimmungsergebnis nicht enthalten.

Eine negative Lookaheadassertion mit Nullbreite wird in der Regel entweder am Anfang oder am Ende eines regulären Ausdrucks verwendet. Am Anfang eines regulären Ausdrucks kann ein bestimmtes Muster definiert werden, das nicht übereinstimmen darf, wenn der Anfang des regulären Ausdrucks ein ähnliches, aber allgemeineres Muster für den Abgleich definiert. In diesem Fall wird sie häufig verwendet, um die Rückverfolgung einzuschränken. Am Ende eines regulären Ausdrucks kann ein Teilausdruck definiert werden, der nicht am Ende einer Übereinstimmung vorliegen darf.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_short">
        <source>zero-width negative lookahead assertion</source>
        <target state="translated">Negative Lookaheadassertion mit Nullbreite</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_long">
        <source>A zero-width negative lookbehind assertion, where for a match to be successful, 'subexpression' must not occur at the input string to the left of the current position. Any substring that does not match 'subexpression' is not included in the match result.

Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define precludes a match in the string that follows. They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</source>
        <target state="translated">Eine negative Lookbehindassertion mit Nullbreite, bei der eine Übereinstimmung erfolgreich ist, wenn "Teilausdruck" nicht in der Eingabezeichenfolge links von der aktuellen Position vorliegt. Teilzeichenfolgen, die nicht mit "Teilausdruck" übereinstimmen, sind im Übereinstimmungsergebnis nicht enthalten.

Negative Lookbehindassertionen mit Nullbreite werden normalerweise am Anfang regulärer Ausdrücke verwendet. Das von ihnen definierte Muster verhindert eine Übereinstimmung in der nachfolgenden Zeichenfolge. Sie werden zudem zum Begrenzen der Rückverfolgung verwendet, wenn das letzte Zeichen oder die Zeichen in einer erfassten Gruppe nicht mit einem oder mehreren Zeichen übereinstimmen dürfen, die dem Muster für reguläre Ausdrücke der Gruppe entsprechen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_short">
        <source>zero-width negative lookbehind assertion</source>
        <target state="translated">Negative Lookbehindassertion mit Nullbreite</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_long">
        <source>A zero-width positive lookahead assertion, where for a match to be successful, the input string must match the regular expression pattern in 'subexpression'. The matched substring is not included in the match result. A zero-width positive lookahead assertion does not backtrack.

Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern. It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match. It is also useful for preventing excessive backtracking. You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</source>
        <target state="translated">Eine positive Lookaheadassertion mit Nullbreite, bei der eine Übereinstimmung erfolgreich ist, wenn die Eingabezeichenfolge dem Muster für reguläre Ausdrücke im Teilausdruck entspricht. Die abgeglichene Zeichenfolge ist im Übereinstimmungsergebnis nicht enthalten. Für eine positive Lookaheadassertion wird keine Rückverfolgung durchgeführt.

Eine positive Lookaheadassertion mit Nullbreite wird in der Regel am Ende eines Musters für reguläre Ausdrücke verwendet. Sie definiert eine Teilzeichenfolge, die sich am Ende einer Zeichenfolge befinden muss, damit eine Übereinstimmung vorliegt, die aber nicht in der Übereinstimmung enthalten sein darf. Sie eignet sich auch zum Verhindern einer übermäßigen Rückverfolgung. Mit einer positiven Lookaheadassertion mit Nullbreite können Sie sicherstellen, dass eine bestimmte erfasste Gruppe mit einem Text beginnt, der einer Teilmenge des für die erfasste Gruppe definierten Musters entspricht.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_short">
        <source>zero-width positive lookahead assertion</source>
        <target state="translated">Positive Lookaheadassertion mit Nullbreite</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_long">
        <source>A zero-width positive lookbehind assertion, where for a match to be successful, 'subexpression' must occur at the input string to the left of the current position. 'subexpression' is not included in the match result. A zero-width positive lookbehind assertion does not backtrack.

Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
        <target state="translated">Eine positive Lookbehindassertion mit Nullbreite, bei der eine Übereinstimmung erfolgreich ist, wenn "Teilausdruck" in der Eingabezeichenfolge links von der aktuellen Position vorliegt. "Teilausdruck" ist im Übereinstimmungsergebnis nicht enthalten. Bei einer positiven Lookbehindassertion mit Nullbreite wird keine Rückverfolgung durchgeführt.

Positive Lookbehindassertionen mit Nullbreite werden normalerweise am Anfang regulärer Ausdrücke verwendet. Das von ihnen definierte Muster ist eine Vorbedingung für eine Übereinstimmung, auch wenn es nicht zum Übereinstimmungsergebnis gehört.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_short">
        <source>zero-width positive lookbehind assertion</source>
        <target state="translated">Positive Lookbehindassertion mit Nullbreite</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_the_line_below_if_you_want_to_inherit_dot_editorconfig_settings_from_higher_directories">
        <source>Remove the line below if you want to inherit .editorconfig settings from higher directories</source>
        <target state="translated">Entfernen Sie die folgende Zeile, wenn Sie EDITORCONFIG-Einstellungen von höheren Verzeichnissen vererben möchten.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_analyzer_config_documents_is_not_supported">
        <source>Removing analyzer config documents is not supported.</source>
        <target state="translated">Das Entfernen von Konfigurationsdokumenten des Analysetools wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbol_0_is_not_from_source">
        <source>Symbol "{0}" is not from source.</source>
        <target state="translated">Symbol "{0}" ist nicht aus Quelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="Documentation_comment_id_must_start_with_E_F_M_N_P_or_T">
        <source>Documentation comment id must start with E, F, M, N, P or T</source>
        <target state="translated">Dokumentationskommentar-ID muss mit E, F, M, N, P oder T beginnen</target>
        <note />
      </trans-unit>
      <trans-unit id="Cycle_detected_in_extensions">
        <source>Cycle detected in extensions</source>
        <target state="translated">Zyklus in Erweiterungen entdeckt</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_but_given_one_is_1">
        <source>Destination type must be a {0}, but given one is {1}.</source>
        <target state="translated">Zieltyp muss {0} sein. Es wurde jedoch {1} angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_or_a_1_but_given_one_is_2">
        <source>Destination type must be a {0} or a {1}, but given one is {2}.</source>
        <target state="translated">Zieltyp muss {0} oder {1} sein. Es wurde jedoch {2} angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_1_or_2_but_given_one_is_3">
        <source>Destination type must be a {0}, {1} or {2}, but given one is {3}.</source>
        <target state="translated">Zieltyp muss {0}, {1} oder {2} sein. Es wurde jedoch {3} angegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_find_location_to_generation_symbol_into">
        <source>Could not find location to generation symbol into.</source>
        <target state="translated">Konnte keinen Ort finden, in den das Symbol generiert werden kann.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_location_provided_to_add_statements_to">
        <source>No location provided to add statements to.</source>
        <target state="translated">Kein Ort angegeben, zu dem Anweisungen hinzugefügt werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_location_was_not_in_source">
        <source>Destination location was not in source.</source>
        <target state="translated">Zielort war nicht in Quelle.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_location_was_from_a_different_tree">
        <source>Destination location was from a different tree.</source>
        <target state="translated">Zielort stammt aus anderem Baum.</target>
        <note />
      </trans-unit>
      <trans-unit id="Node_is_of_the_wrong_type">
        <source>Node is of the wrong type.</source>
        <target state="translated">Knoten hat den falschen Typ.</target>
        <note />
      </trans-unit>
      <trans-unit id="Location_must_be_null_or_from_source">
        <source>Location must be null or from source.</source>
        <target state="translated">Ort muss null oder von Quelle sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="Duplicate_source_file_0_in_project_1">
        <source>Duplicate source file '{0}' in project '{1}'</source>
        <target state="translated">Doppelte Quelldatei "{0}" in Projekt "{1}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_projects_is_not_supported">
        <source>Removing projects is not supported.</source>
        <target state="translated">Das Entfernen von Projekten wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_projects_is_not_supported">
        <source>Adding projects is not supported.</source>
        <target state="translated">Das Hinzufügen von Projekten wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbol_specifications">
        <source>Symbol specifications</source>
        <target state="translated">Symbolspezifikationen</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTree_is_required_to_accomplish_the_task_but_is_not_supported_by_document_0">
        <source>Syntax tree is required to accomplish the task but is not supported by document {0}.</source>
        <target state="new">Syntax tree is required to accomplish the task but is not supported by document {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Visual_Basic_files">
        <source>Visual Basic files</source>
        <target state="translated">Visual Basic-Dateien</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_adding_imports_will_bring_an_extension_method_into_scope_with_the_same_name_as_member_access">
        <source>Adding imports will bring an extension method into scope with the same name as '{0}'</source>
        <target state="translated">Durch das Hinzufügen von Importen wird eine Erweiterungsmethode mit dem gleichen Namen wie "{0}" in den Bereich eingeführt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Workspace_is_not_empty">
        <source>Workspace is not empty.</source>
        <target state="translated">Arbeitsbereich ist nicht leer.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_part_of_the_workspace">
        <source>'{0}' is not part of the workspace.</source>
        <target state="translated">'"{0}" ist nicht Teil des Arbeitsbereichs.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_already_part_of_the_workspace">
        <source>'{0}' is already part of the workspace.</source>
        <target state="translated">'{0}' ist bereits Teil des Workspace.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_referenced">
        <source>'{0}' is not referenced.</source>
        <target state="translated">'"{0}" ist nicht referenziert.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_already_referenced">
        <source>'{0}' is already referenced.</source>
        <target state="translated">'"{0}" ist bereits referenziert.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_project_reference_from_0_to_1_will_cause_a_circular_reference">
        <source>Adding project reference from '{0}' to '{1}' will cause a circular reference.</source>
        <target state="translated">Das Hinzufügen der Projektreferenz "{0}" zu "{1}" wird einen Zirkelbezug verursachen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Metadata_is_not_referenced">
        <source>Metadata is not referenced.</source>
        <target state="translated">Metadaten sind nicht referenziert.</target>
        <note />
      </trans-unit>
      <trans-unit id="Metadata_is_already_referenced">
        <source>Metadata is already referenced.</source>
        <target state="translated">Metadaten sind bereits referenziert.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_present">
        <source>{0} is not present.</source>
        <target state="translated">{0} ist nicht vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_already_present">
        <source>{0} is already present.</source>
        <target state="translated">{0} ist bereits vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_specified_document_is_not_a_version_of_this_document">
        <source>The specified document is not a version of this document.</source>
        <target state="translated">Das angegebene Dokument ist keine Version dieses Dokuments.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_language_0_is_not_supported">
        <source>The language '{0}' is not supported.</source>
        <target state="translated">Die Sprache "{0}" wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_already_contains_the_specified_project">
        <source>The solution already contains the specified project.</source>
        <target state="translated">Die Lösung enthält bereits das angegebene Projekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_does_not_contain_the_specified_project">
        <source>The solution does not contain the specified project.</source>
        <target state="translated">Lösung enthält nicht das angegebene Projekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_project_already_references_the_target_project">
        <source>The project already references the target project.</source>
        <target state="translated">Das Projekt verweist bereits auf das Zielprojekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_project_already_transitively_references_the_target_project">
        <source>The project already transitively references the target project.</source>
        <target state="translated">Das Projekt verweist bereits transitiv auf das Zielprojekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_already_contains_the_specified_document">
        <source>The solution already contains the specified document.</source>
        <target state="translated">Die Lösung enthält bereits das angegebene Dokument.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_does_not_contain_the_specified_document">
        <source>The solution does not contain the specified document.</source>
        <target state="translated">Die Lösung enthält nicht das angegebene Dokument.</target>
        <note />
      </trans-unit>
      <trans-unit id="Temporary_storage_cannot_be_written_more_than_once">
        <source>Temporary storage cannot be written more than once.</source>
        <target state="translated">Temporärer Speicher kann nicht mehr als einmal geschrieben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_open">
        <source>'{0}' is not open.</source>
        <target state="translated">'"{0}" ist nicht geöffnet.</target>
        <note />
      </trans-unit>
      <trans-unit id="A_language_name_cannot_be_specified_for_this_option">
        <source>A language name cannot be specified for this option.</source>
        <target state="translated">Für diese Option kann kein Sprachenname angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="A_language_name_must_be_specified_for_this_option">
        <source>A language name must be specified for this option.</source>
        <target state="translated">Für diese Option muss ein Sprachenname angegeben werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="File_was_externally_modified_colon_0">
        <source>File was externally modified: {0}.</source>
        <target state="translated">Datei wurde extern modifiziert: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unrecognized_language_name">
        <source>Unrecognized language name.</source>
        <target state="translated">Unerkannter Sprachenname.</target>
        <note />
      </trans-unit>
      <trans-unit id="Can_t_resolve_metadata_reference_colon_0">
        <source>Can't resolve metadata reference: '{0}'.</source>
        <target state="translated">Metadatenreferenz kann nicht aufgelöst werden: "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Can_t_resolve_analyzer_reference_colon_0">
        <source>Can't resolve analyzer reference: '{0}'.</source>
        <target state="translated">Analysereferenz kann nicht aufgelöst werden: "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_block_expected_after_Project">
        <source>Invalid project block, expected "=" after Project.</source>
        <target state="translated">Ungültiger Projektblock, erwartet wird "=" nach Projekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_block_expected_after_project_name">
        <source>Invalid project block, expected "," after project name.</source>
        <target state="translated">Ungültiger Projektblock, erwartet wird "," nach Projektname.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_block_expected_after_project_path">
        <source>Invalid project block, expected "," after project path.</source>
        <target state="translated">Ungültiger Projektblock, erwartet wird "," nach Projektpfad.</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_0">
        <source>Expected {0}.</source>
        <target state="translated">Erwartet wird {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_must_be_a_non_null_and_non_empty_string">
        <source>"{0}" must be a non-null and non-empty string.</source>
        <target state="translated">"{0}" muss eine Zeichenfolge sein, die nicht null und nicht leer ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_header_colon_0">
        <source>Expected header: "{0}".</source>
        <target state="translated">Erwartete Überschrift: "{0}".</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_end_of_file">
        <source>Expected end-of-file.</source>
        <target state="translated">Erwartetes Dateiende.</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_0_line">
        <source>Expected {0} line.</source>
        <target state="translated">Erwartete {0}-Zeile.</target>
        <note />
      </trans-unit>
      <trans-unit id="This_submission_already_references_another_submission_project">
        <source>This submission already references another submission project.</source>
        <target state="translated">Diese Übermittlung verweist bereits auf ein anderes Übermittlungsprojekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_still_contains_open_documents">
        <source>{0} still contains open documents.</source>
        <target state="translated">{0} enthält noch offene Dokumente.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_still_open">
        <source>{0} is still open.</source>
        <target state="translated">"{0}" ist noch geöffnet.</target>
        <note />
      </trans-unit>
      <trans-unit id="An_element_with_the_same_key_but_a_different_value_already_exists">
        <source>An element with the same key but a different value already exists.</source>
        <target state="translated">Es ist bereits ein Element mit dem gleichen Schlüssel, jedoch einem anderen Wert vorhanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays_with_more_than_one_dimension_cannot_be_serialized">
        <source>Arrays with more than one dimension cannot be serialized.</source>
        <target state="translated">Arrays mit mehr als einer Dimension können nicht serialisiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer">
        <source>Value too large to be represented as a 30 bit unsigned integer.</source>
        <target state="translated">Der Wert ist zu groß, um als ganze 30-Bit-Zahl ohne Vorzeichen dargestellt zu werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Specified_path_must_be_absolute">
        <source>Specified path must be absolute.</source>
        <target state="translated">Angegebener Pfad muss absolut sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cast_is_redundant">
        <source>Cast is redundant.</source>
        <target state="translated">Umwandlung ist redundant.</target>
        <note />
      </trans-unit>
      <trans-unit id="Name_can_be_simplified">
        <source>Name can be simplified.</source>
        <target state="translated">Der Name kann vereinfacht werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_identifier">
        <source>Unknown identifier.</source>
        <target state="translated">Unbekannter Bezeichner.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_generate_code_for_unsupported_operator_0">
        <source>Cannot generate code for unsupported operator '{0}'</source>
        <target state="translated">Kann keinen Code für nicht unterstützten Operator "{0}" generieren</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_number_of_parameters_for_binary_operator">
        <source>Invalid number of parameters for binary operator.</source>
        <target state="translated">Ungültige Parameteranzahl für binären Operator.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_number_of_parameters_for_unary_operator">
        <source>Invalid number of parameters for unary operator.</source>
        <target state="translated">Ungültige Parameteranzahl für unären Operator.</target>
        <note />
      </trans-unit>
      <trans-unit id="Absolute_path_expected">
        <source>Absolute path expected.</source>
        <target state="translated">Absoluter Pfad erwartet.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_open_project_0_because_the_file_extension_1_is_not_associated_with_a_language">
        <source>Cannot open project '{0}' because the file extension '{1}' is not associated with a language.</source>
        <target state="translated">Projekt "{0}" kann nicht geöffnet werden, da die Dateierweiterung "{1}" keiner Sprache zugeordnet ist.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_open_project_0_because_the_language_1_is_not_supported">
        <source>Cannot open project '{0}' because the language '{1}' is not supported.</source>
        <target state="translated">Projekt "{0}" kann nicht geöffnet werden, da die Sprache "{1}" nicht unterstützt wird.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_file_path_colon_0">
        <source>Invalid project file path: '{0}'</source>
        <target state="translated">Ungültiger Projektdateipfad: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_solution_file_path_colon_0">
        <source>Invalid solution file path: '{0}'</source>
        <target state="translated">Ungültiger Lösungsdateipfad: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Project_file_not_found_colon_0">
        <source>Project file not found: '{0}'</source>
        <target state="translated">Projektdatei nicht gefunden: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Solution_file_not_found_colon_0">
        <source>Solution file not found: '{0}'</source>
        <target state="translated">Lösungsdatei nicht gefunden: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Unmerged_change_from_project_0">
        <source>Unmerged change from project '{0}'</source>
        <target state="translated">Nicht gemergte Änderung aus Projekt "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Added_colon">
        <source>Added:</source>
        <target state="translated">Hinzugefügt:</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_0">
        <source>Fix all '{0}'</source>
        <target state="translated">Alle '{0}' reparieren</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_0_in_1">
        <source>Fix all '{0}' in '{1}'</source>
        <target state="translated">Alle '{0}' in '{1}' reparieren</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_0_in_Solution">
        <source>Fix all '{0}' in Solution</source>
        <target state="translated">Alle '{0}' in Lösung reparieren</target>
        <note />
      </trans-unit>
      <trans-unit id="After_colon">
        <source>After:</source>
        <target state="translated">Nach:</target>
        <note />
      </trans-unit>
      <trans-unit id="Before_colon">
        <source>Before:</source>
        <target state="translated">Vor:</target>
        <note />
      </trans-unit>
      <trans-unit id="Removed_colon">
        <source>Removed:</source>
        <target state="translated">Entfernt:</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_CodePage_value_colon_0">
        <source>Invalid CodePage value: {0}</source>
        <target state="translated">Ungültiger CodePage-Wert: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_additional_documents_is_not_supported">
        <source>Adding additional documents is not supported.</source>
        <target state="translated">Das Hinzufügen weitere Dokumente wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_analyzer_references_is_not_supported">
        <source>Adding analyzer references is not supported.</source>
        <target state="translated">Das Hinzufügen von Verweisen der Analyse wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_documents_is_not_supported">
        <source>Adding documents is not supported.</source>
        <target state="translated">Das Hinzufügen von Dokumenten wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_metadata_references_is_not_supported">
        <source>Adding metadata references is not supported.</source>
        <target state="translated">Das Hinzufügen von Verweisen auf Metadaten wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_project_references_is_not_supported">
        <source>Adding project references is not supported.</source>
        <target state="translated">Das Hinzufügen von Projektverweisen wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_additional_documents_is_not_supported">
        <source>Changing additional documents is not supported.</source>
        <target state="translated">Das Ändern weiterer Dokumente wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_documents_is_not_supported">
        <source>Changing documents is not supported.</source>
        <target state="translated">Das Ändern von Dokumenten wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_project_properties_is_not_supported">
        <source>Changing project properties is not supported.</source>
        <target state="translated">Das Ändern von Projekteigenschaften wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_additional_documents_is_not_supported">
        <source>Removing additional documents is not supported.</source>
        <target state="translated">Das Entfernen weiterer Dokumente wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_analyzer_references_is_not_supported">
        <source>Removing analyzer references is not supported.</source>
        <target state="translated">Das Entfernen von Verweisen der Analyse wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_documents_is_not_supported">
        <source>Removing documents is not supported.</source>
        <target state="translated">Das Entfernen von Dokumenten wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_metadata_references_is_not_supported">
        <source>Removing metadata references is not supported.</source>
        <target state="translated">Das Entfernen von Verweisen auf Metadaten wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_project_references_is_not_supported">
        <source>Removing project references is not supported.</source>
        <target state="translated">Das Entfernen von Projektverweisen wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Service_of_type_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_workspace">
        <source>Service of type '{0}' is required to accomplish the task but is not available from the workspace.</source>
        <target state="translated">Ein Dienst vom Typ "{0}" ist zum Ausführen der Aufgabe erforderlich, steht aber im Arbeitsbereich nicht zur Verfügung.</target>
        <note />
      </trans-unit>
      <trans-unit id="Supplied_diagnostic_cannot_be_null">
        <source>Supplied diagnostic cannot be null.</source>
        <target state="translated">Bereitgestellte Diagnose darf nicht null sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="At_least_one_diagnostic_must_be_supplied">
        <source>At least one diagnostic must be supplied.</source>
        <target state="translated">Es muss mindestens eine Diagnose bereitgestellt sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="Diagnostic_must_have_span_0">
        <source>Diagnostic must have span '{0}'</source>
        <target state="translated">Diagnose muss den Bereich "{0}" enthalten</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_deserialize_type_0">
        <source>Cannot deserialize type '{0}'.</source>
        <target state="translated">Typ "{0}" kann nicht deserialisiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_serialize_type_0">
        <source>Cannot serialize type '{0}'.</source>
        <target state="translated">Typ "{0}" kann nicht serialisiert werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_type_0_is_not_understood_by_the_serialization_binder">
        <source>The type '{0}' is not understood by the serialization binder.</source>
        <target state="translated">Der Typ "{0}" wird vom Serialisierungsbinder nicht verstanden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Label_for_node_0_is_invalid_it_must_be_within_bracket_0_1">
        <source>Label for node '{0}' is invalid, it must be within [0, {1}).</source>
        <target state="translated">Die Bezeichnung für Knoten '{0}' ist ungültig, sie muss innerhalb von [0, {1}) liegen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Matching_nodes_0_and_1_must_have_the_same_label">
        <source>Matching nodes '{0}' and '{1}' must have the same label.</source>
        <target state="translated">Die übereinstimmenden Knoten '{0}' und '{1}' müssen dieselbe Bezeichnung aufweisen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Node_0_must_be_contained_in_the_new_tree">
        <source>Node '{0}' must be contained in the new tree.</source>
        <target state="translated">Der Knoten '{0}' muss im neuen Baum enthalten sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="Node_0_must_be_contained_in_the_old_tree">
        <source>Node '{0}' must be contained in the old tree.</source>
        <target state="translated">Der Knoten '{0}' muss im alten Baum enthalten sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_member_0_is_not_declared_within_the_declaration_of_the_symbol">
        <source>The member '{0}' is not declared within the declaration of the symbol.</source>
        <target state="translated">Der Member '{0}' wird nicht innerhalb der Deklaration des Symbols deklariert.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_position_is_not_within_the_symbol_s_declaration">
        <source>The position is not within the symbol's declaration</source>
        <target state="translated">Die Position liegt nicht innerhalb der Deklaration des Symbols.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_symbol_0_cannot_be_located_within_the_current_solution">
        <source>The symbol '{0}' cannot be located within the current solution.</source>
        <target state="translated">Das Symbol '{0}' kann nicht in die aktuelle Projektmappe geladen werden.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_compilation_options_is_not_supported">
        <source>Changing compilation options is not supported.</source>
        <target state="translated">Das Ändern von Kompilierungsoptionen wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_parse_options_is_not_supported">
        <source>Changing parse options is not supported.</source>
        <target state="translated">Das Ändern von Analyseoptionen wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_node_is_not_part_of_the_tree">
        <source>The node is not part of the tree.</source>
        <target state="translated">Dieser Knoten ist nicht Teil des Baums.</target>
        <note />
      </trans-unit>
      <trans-unit id="This_workspace_does_not_support_opening_and_closing_documents">
        <source>This workspace does not support opening and closing documents.</source>
        <target state="translated">Das Öffnen und Schließen von Dokumenten wird in diesem Arbeitsbereich nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Usage_colon">
        <source>Usage:</source>
        <target state="translated">Nutzung:</target>
        <note />
      </trans-unit>
      <trans-unit id="Exceptions_colon">
        <source>Exceptions:</source>
        <target state="translated">Ausnahmen:</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_returned_an_uninitialized_ImmutableArray">
        <source>'{0}' returned an uninitialized ImmutableArray</source>
        <target state="translated">'"{0}" hat ein nicht initialisiertes "ImmutableArray" zurückgegeben.</target>
        <note />
      </trans-unit>
      <trans-unit id="Failure">
        <source>Failure</source>
        <target state="translated">Fehler</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning">
        <source>Warning</source>
        <target state="translated">Warnung</target>
        <note />
      </trans-unit>
      <trans-unit id="Populate_switch">
        <source>Populate switch</source>
        <target state="translated">Switch mit Daten auffüllen</target>
        <note />
      </trans-unit>
      <trans-unit id="Member_access_should_be_qualified">
        <source>Member access should be qualified.</source>
        <target state="translated">Der Memberzugriff sollte qualifiziert sein.</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_braces_to_0_statement">
        <source>Add braces to '{0}' statement.</source>
        <target state="translated">Der Anweisung "{0}" geschweifte Klammern hinzufügen</target>
        <note />
      </trans-unit>
      <trans-unit id="Options_did_not_come_from_Workspace">
        <source>Options did not come from Workspace</source>
        <target state="translated">Optionen stammen nicht aus dem Arbeitsbereich.</target>
        <note />
      </trans-unit>
      <trans-unit id="Enable">
        <source>Enable</source>
        <target state="translated">Aktivieren</target>
        <note />
      </trans-unit>
      <trans-unit id="Enable_and_ignore_future_errors">
        <source>Enable and ignore future errors</source>
        <target state="translated">Aktivieren und weitere Fehler ignorieren</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_encountered_an_error_and_has_been_disabled">
        <source>'{0}' encountered an error and has been disabled.</source>
        <target state="translated">'"{0}" hat einen Fehler festgestellt und wurde deaktiviert.</target>
        <note />
      </trans-unit>
      <trans-unit id="Show_Stack_Trace">
        <source>Show Stack Trace</source>
        <target state="translated">Stapelüberwachung anzeigen</target>
        <note />
      </trans-unit>
      <trans-unit id="Stream_is_too_long">
        <source>Stream is too long.</source>
        <target state="translated">Der Datenstrom ist zu lang.</target>
        <note />
      </trans-unit>
      <trans-unit id="Deserialization_reader_for_0_read_incorrect_number_of_values">
        <source>Deserialization reader for '{0}' read incorrect number of values.</source>
        <target state="translated">Der Deserialisierungsreader für "{0}" hat eine falsche Anzahl von Werten gelesen.</target>
        <note />
      </trans-unit>
      <trans-unit id="Pascal_Case">
        <source>Pascal Case</source>
        <target state="translated">Pascal-Schreibweise</target>
        <note />
      </trans-unit>
      <trans-unit id="Abstract_Method">
        <source>Abstract Method</source>
        <target state="translated">Abstrakte Methode</target>
        <note>{locked: abstract}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Async_Method">
        <source>Async Method</source>
        <target state="translated">Asynchrone Methode</target>
        <note>{locked: async}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Begins_with_I">
        <source>Begins with I</source>
        <target state="translated">Beginnt mit I</target>
        <note>{locked:I}</note>
      </trans-unit>
      <trans-unit id="Class">
        <source>Class</source>
        <target state="new">Class</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Delegate">
        <source>Delegate</source>
        <target state="new">Delegate</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Enum">
        <source>Enum</source>
        <target state="new">Enum</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Event">
        <source>Event</source>
        <target state="new">Event</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Interface">
        <source>Interface</source>
        <target state="new">Interface</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Non_Field_Members">
        <source>Non-Field Members</source>
        <target state="translated">Nicht-Feldmember</target>
        <note>{locked:field}</note>
      </trans-unit>
      <trans-unit id="Private_Method">
        <source>Private Method</source>
        <target state="translated">Private Methode</target>
        <note>{locked: private}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Private_or_Internal_Field">
        <source>Private or Internal Field</source>
        <target state="translated">Privates oder internes Feld</target>
        <note>{locked: private}{locked: internal}{locked:field}</note>
      </trans-unit>
      <trans-unit id="Private_or_Internal_Static_Field">
        <source>Private or Internal Static Field</source>
        <target state="translated">Privates oder internes statisches Feld</target>
        <note>{locked: private}{locked: internal}{locked:static}{locked:field}</note>
      </trans-unit>
      <trans-unit id="Property">
        <source>Property</source>
        <target state="new">Property</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Public_or_Protected_Field">
        <source>Public or Protected Field</source>
        <target state="translated">Öffentliches oder geschütztes Feld</target>
        <note>{locked: public}{locked: protected}{locked:field}</note>
      </trans-unit>
      <trans-unit id="Static_Field">
        <source>Static Field</source>
        <target state="translated">Statisches Feld</target>
        <note>{locked:static}{locked:field} (unless the capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Static_Method">
        <source>Static Method</source>
        <target state="translated">Statische Methode</target>
        <note>{locked: static}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Struct">
        <source>Struct</source>
        <target state="new">Struct</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Types">
        <source>Types</source>
        <target state="translated">Typen</target>
        <note>{locked:types} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Method">
        <source>Method</source>
        <target state="translated">Methode</target>
        <note>{locked:method} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Missing_prefix_colon_0">
        <source>Missing prefix: '{0}'</source>
        <target state="translated">Fehlendes Präfix: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="Error">
        <source>Error</source>
        <target state="translated">Fehler</target>
        <note />
      </trans-unit>
      <trans-unit id="None">
        <source>None</source>
        <target state="translated">NONE</target>
        <note />
      </trans-unit>
      <trans-unit id="Missing_suffix_colon_0">
        <source>Missing suffix: '{0}'</source>
        <target state="translated">Fehlendes Suffix: "{0}"</target>
        <note />
      </trans-unit>
      <trans-unit id="These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0">
        <source>These non-leading words must begin with an upper case letter: {0}</source>
        <target state="translated">Diese nicht führenden Wörter müssen mit einem Großbuchstaben beginnen: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Suggestion">
        <source>Suggestion</source>
        <target state="translated">Vorschlag</target>
        <note />
      </trans-unit>
      <trans-unit id="These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0">
        <source>These non-leading words must begin with a lowercase letter: {0}</source>
        <target state="translated">Diese nicht führenden Wörter müssen mit einem Kleinbuchstaben beginnen: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="These_words_cannot_contain_lower_case_characters_colon_0">
        <source>These words cannot contain lower case characters: {0}</source>
        <target state="translated">Diese Wörter dürfen keine Kleinbuchstaben enthalten: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="These_words_cannot_contain_upper_case_characters_colon_0">
        <source>These words cannot contain upper case characters: {0}</source>
        <target state="translated">Diese Wörter dürfen keine Großbuchstaben enthalten: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="These_words_must_begin_with_upper_case_characters_colon_0">
        <source>These words must begin with upper case characters: {0}</source>
        <target state="translated">Diese Wörter müssen mit Großbuchstaben beginnen: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="The_first_word_0_must_begin_with_an_upper_case_character">
        <source>The first word, '{0}', must begin with an upper case character</source>
        <target state="translated">Das erste Wort ("{0}") muss mit einem Großbuchstaben beginnen.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_first_word_0_must_begin_with_a_lower_case_character">
        <source>The first word, '{0}', must begin with a lower case character</source>
        <target state="translated">Das erste Wort ("{0}") muss mit einem Kleinbuchstaben beginnen.</target>
        <note />
      </trans-unit>
      <trans-unit id="File_0_size_of_1_exceeds_maximum_allowed_size_of_2">
        <source>File '{0}' size of {1} exceeds maximum allowed size of {2}</source>
        <target state="translated">Die Größe der Datei "{0}" beträgt {1} und überschreitet so die maximal zulässige Größe von {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_document_property_is_not_supported">
        <source>Changing document properties is not supported</source>
        <target state="translated">Das Ändern der Dokumenteigenschaften wird nicht unterstützt.</target>
        <note />
      </trans-unit>
      <trans-unit id="Alternation_conditions_cannot_be_comments">
        <source>Alternation conditions cannot be comments</source>
        <target state="translated">Wechselbedingungen dürfen keine Kommentare sein.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a|(?#b)</note>
      </trans-unit>
      <trans-unit id="Alternation_conditions_do_not_capture_and_cannot_be_named">
        <source>Alternation conditions do not capture and cannot be named</source>
        <target state="translated">Wechselbedingungen werden nicht erfasst und können nicht benannt werden.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(?'x'))</note>
      </trans-unit>
      <trans-unit id="A_subtraction_must_be_the_last_element_in_a_character_class">
        <source>A subtraction must be the last element in a character class</source>
        <target state="translated">Eine Subtraktion muss das letzte Element in einer Zeichenklasse sein.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-[b]-c]</note>
      </trans-unit>
      <trans-unit id="Cannot_include_class_0_in_character_range">
        <source>Cannot include class \{0} in character range</source>
        <target state="translated">Die Klasse \{0} kann nicht in den Zeichenbereich aufgenommen werden.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-\w]. {0} is the invalid class (\w here)</note>
      </trans-unit>
      <trans-unit id="Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue">
        <source>Capture group numbers must be less than or equal to Int32.MaxValue</source>
        <target state="translated">Erfassungsgruppennummern müssen kleiner oder gleich Int32.MaxValue sein.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{2147483648}</note>
      </trans-unit>
      <trans-unit id="Capture_number_cannot_be_zero">
        <source>Capture number cannot be zero</source>
        <target state="translated">Aufzeichnungsnummer darf nicht 0 (null) sein.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;0&gt;a)</note>
      </trans-unit>
      <trans-unit id="Illegal_backslash_at_end_of_pattern">
        <source>Illegal \ at end of pattern</source>
        <target state="translated">Nicht zulässiges \-Zeichen am Ende des Musters.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \</note>
      </trans-unit>
      <trans-unit id="Illegal_x_y_with_x_less_than_y">
        <source>Illegal {x,y} with x &gt; y</source>
        <target state="translated">Illegaler {x,y}-Wert mit x &gt; y.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{1,0}</note>
      </trans-unit>
      <trans-unit id="Incomplete_character_escape">
        <source>Incomplete \p{X} character escape</source>
        <target state="translated">Unvollständiges \p{X}-Escapezeichen.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{ Cc }</note>
      </trans-unit>
      <trans-unit id="Insufficient_hexadecimal_digits">
        <source>Insufficient hexadecimal digits</source>
        <target state="translated">Nicht genügend Hexadezimalziffern.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \x</note>
      </trans-unit>
      <trans-unit id="Invalid_group_name_Group_names_must_begin_with_a_word_character">
        <source>Invalid group name: Group names must begin with a word character</source>
        <target state="translated">Ungültiger Gruppenname: Gruppennamen müssen mit einem Wortzeichen beginnen.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;a &gt;a)</note>
      </trans-unit>
      <trans-unit id="Malformed">
        <source>malformed</source>
        <target state="translated">fehlerhaft</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0</note>
      </trans-unit>
      <trans-unit id="Malformed_character_escape">
        <source>Malformed \p{X} character escape</source>
        <target state="translated">Falsch formatiertes \p{X}-Escapezeichen.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p {Cc}</note>
      </trans-unit>
      <trans-unit id="Malformed_named_back_reference">
        <source>Malformed \k&lt;...&gt; named back reference</source>
        <target state="translated">Falsch formatierter mit \k&lt;...&gt; benannter Verweis.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k'</note>
      </trans-unit>
      <trans-unit id="Missing_control_character">
        <source>Missing control character</source>
        <target state="translated">Fehlendes Steuerzeichen</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \c</note>
      </trans-unit>
      <trans-unit id="Nested_quantifier_0">
        <source>Nested quantifier {0}</source>
        <target state="translated">Geschachtelter Quantifizierer {0}.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a**. In this case {0} will be '*', the extra unnecessary quantifier.</note>
      </trans-unit>
      <trans-unit id="Not_enough_close_parens">
        <source>Not enough )'s</source>
        <target state="translated">Zu wenige )-Zeichen</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (a</note>
      </trans-unit>
      <trans-unit id="Quantifier_x_y_following_nothing">
        <source>Quantifier {x,y} following nothing</source>
        <target state="translated">Quantifizierer {x,y} nach nichts.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: *</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group">
        <source>reference to undefined group</source>
        <target state="translated">Verweis auf nicht definierte Gruppe</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(1))</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_name_0">
        <source>Reference to undefined group name {0}</source>
        <target state="translated">Verweis auf nicht definierten Gruppennamen {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k&lt;a&gt;. Here, {0} will be the name of the undefined group ('a')</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_number_0">
        <source>Reference to undefined group number {0}</source>
        <target state="translated">Verweis auf nicht definierte Gruppennummer {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;-1&gt;). Here, {0} will be the number of the undefined group ('1')</note>
      </trans-unit>
      <trans-unit id="Too_many_bars_in_conditional_grouping">
        <source>Too many | in (?()|)</source>
        <target state="translated">Zu viele |-Zeichen in (?()|).</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0)a|b|)</note>
      </trans-unit>
      <trans-unit id="Too_many_close_parens">
        <source>Too many )'s</source>
        <target state="translated">Zu viele )-Zeichen.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: )</note>
      </trans-unit>
      <trans-unit id="Unknown_property">
        <source>Unknown property</source>
        <target state="translated">Unbekannte Eigenschaft</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{}</note>
      </trans-unit>
      <trans-unit id="Unknown_property_0">
        <source>Unknown property '{0}'</source>
        <target state="translated">Unbekannte Eigenschaft "{0}"</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{xxx}. Here, {0} will be the name of the unknown property ('xxx')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_control_character">
        <source>Unrecognized control character</source>
        <target state="translated">Unbekanntes Steuerzeichen</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [\c]</note>
      </trans-unit>
      <trans-unit id="Unrecognized_escape_sequence_0">
        <source>Unrecognized escape sequence \{0}</source>
        <target state="translated">Unbekannte Escapesequenz \{0}.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \m. Here, {0} will be the unrecognized character ('m')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_grouping_construct">
        <source>Unrecognized grouping construct</source>
        <target state="translated">Unbekanntes Gruppierungskonstrukt.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;</note>
      </trans-unit>
      <trans-unit id="Unterminated_character_class_set">
        <source>Unterminated [] set</source>
        <target state="translated">Nicht abgeschlossener []-Satz</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [</note>
      </trans-unit>
      <trans-unit id="Unterminated_regex_comment">
        <source>Unterminated (?#...) comment</source>
        <target state="translated">Nicht abgeschlossener (?#...)-Kommentar.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?#</note>
      </trans-unit>
      <trans-unit id="dot_NET_Coding_Conventions">
        <source>.NET Coding Conventions</source>
        <target state="translated">.NET-Codierungskonventionen</target>
        <note />
      </trans-unit>
      <trans-unit id="this_dot_and_Me_dot_preferences">
        <source>this. and Me. preferences</source>
        <target state="translated">this.- und Me.-Einstellungen</target>
        <note />
      </trans-unit>
      <trans-unit id="x_y_range_in_reverse_order">
        <source>[x-y] range in reverse order</source>
        <target state="translated">[x-y]-Bereich in umgekehrter Reihenfolge</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [b-a]</note>
      </trans-unit>
      <trans-unit id="Variables_captured_colon">
        <source>Variables captured:</source>
        <target state="translated">Erfasste Variablen:</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_issue_0">
        <source>Regex issue: {0}</source>
        <target state="translated">RegEx-Fehler: {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. {0} will be the actual text of one of the above Regular Expression errors.</note>
      </trans-unit>
      <trans-unit id="Parameter_preferences">
        <source>Parameter preferences</source>
        <target state="translated">Einstellungen für Parameter</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>