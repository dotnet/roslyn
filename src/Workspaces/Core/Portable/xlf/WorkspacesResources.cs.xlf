<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="cs" original="../WorkspacesResources.resx">
    <body>
      <trans-unit id="Adding_analyzer_config_documents_is_not_supported">
        <source>Adding analyzer config documents is not supported.</source>
        <target state="translated">Přidávání dokumentů konfigurace analyzátoru se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="An_error_occurred_while_reading_the_specified_configuration_file_colon_0">
        <source>An error occurred while reading the specified configuration file: {0}</source>
        <target state="translated">Došlo k chybě při čtení zadaného konfiguračního souboru: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="CSharp_files">
        <source>C# files</source>
        <target state="translated">Soubory C#</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_analyzer_config_documents_is_not_supported">
        <source>Changing analyzer config documents is not supported.</source>
        <target state="translated">Změna dokumentů konfigurace analyzátoru se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_document_0_is_not_supported">
        <source>Changing document '{0}' is not supported.</source>
        <target state="translated">Změna dokumentu {0} není podporovaná.</target>
        <note />
      </trans-unit>
      <trans-unit id="Compilation_is_required_to_accomplish_the_task_but_is_not_supported_by_project_0">
        <source>Compilation is required to accomplish the task but is not supported by project {0}.</source>
        <target state="new">Compilation is required to accomplish the task but is not supported by project {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Core_EditorConfig_Options">
        <source>Core EditorConfig Options</source>
        <target state="translated">Základní možnosti pro EditorConfig</target>
        <note />
      </trans-unit>
      <trans-unit id="DateTimeKind_must_be_Utc">
        <source>DateTimeKind must be Utc</source>
        <target state="translated">DateTimeKind musí být Utc</target>
        <note />
      </trans-unit>
      <trans-unit id="Document_does_not_support_syntax_trees">
        <source>Document does not support syntax trees</source>
        <target state="new">Document does not support syntax trees</target>
        <note />
      </trans-unit>
      <trans-unit id="Expression_level_preferences">
        <source>Expression-level preferences</source>
        <target state="translated">Předvolby na úrovni výrazů</target>
        <note />
      </trans-unit>
      <trans-unit id="Field_preferences">
        <source>Field preferences</source>
        <target state="translated">Předvolby polí</target>
        <note />
      </trans-unit>
      <trans-unit id="Indentation_and_spacing">
        <source>Indentation and spacing</source>
        <target state="translated">Odsazení a mezery</target>
        <note />
      </trans-unit>
      <trans-unit id="Language_keywords_vs_BCL_types_preferences">
        <source>Language keywords vs BCL types preferences</source>
        <target state="translated">Předvolby klíčových slov jazyka a typů BCL</target>
        <note />
      </trans-unit>
      <trans-unit id="Modifier_preferences">
        <source>Modifier preferences</source>
        <target state="translated">Předvolby modifikátorů</target>
        <note />
      </trans-unit>
      <trans-unit id="Naming_rules">
        <source>Naming rules</source>
        <target state="translated">Pravidla pojmenování</target>
        <note />
      </trans-unit>
      <trans-unit id="Naming_styles">
        <source>Naming styles</source>
        <target state="translated">Styly pojmenování</target>
        <note />
      </trans-unit>
      <trans-unit id="New_line_preferences">
        <source>New line preferences</source>
        <target state="translated">Předvolby nových řádků</target>
        <note />
      </trans-unit>
      <trans-unit id="Organize_usings">
        <source>Organize usings</source>
        <target state="translated">Uspořádat direktivy using</target>
        <note />
      </trans-unit>
      <trans-unit id="Parentheses_preferences">
        <source>Parentheses preferences</source>
        <target state="translated">Předvolby závorek</target>
        <note />
      </trans-unit>
      <trans-unit id="Prefix_0_does_not_match_expected_prefix_1">
        <source>Prefix '{0}' does not match expected prefix '{1}'</source>
        <target state="translated">Předpona {0} neodpovídá očekávané předponě {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Prefix_0_is_not_expected">
        <source>Prefix '{0}' is not expected</source>
        <target state="translated">Předpona {0} se neočekávala.</target>
        <note />
      </trans-unit>
      <trans-unit id="Project_of_ID_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_solution">
        <source>Project of ID {0} is required to accomplish the task but is not available from the solution</source>
        <target state="new">Project of ID {0} is required to accomplish the task but is not available from the solution</target>
        <note />
      </trans-unit>
      <trans-unit id="Refactoring_Only">
        <source>Refactoring Only</source>
        <target state="translated">Pouze refaktoring</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_long">
        <source>All control characters. This includes the Cc, Cf, Cs, Co, and Cn categories.</source>
        <target state="translated">Všechny řídicí znaky. Patří k nim kategorie Cc, Cf, Cs, Co a Cn.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_short">
        <source>all control characters</source>
        <target state="translated">všechny řídicí znaky</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_long">
        <source>All diacritic marks. This includes the Mn, Mc, and Me categories.</source>
        <target state="translated">Všechny značky diakritických znamének. Patří k nim kategorie Mn, Mc a Me.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_short">
        <source>all diacritic marks</source>
        <target state="translated">všechny značky diakritických znamének</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_long">
        <source>All letter characters. This includes the Lu, Ll, Lt, Lm, and Lo characters.</source>
        <target state="translated">Všechny znaky písmen. Patří k nim znaky Lu, Ll, Lt, Lm a Lo.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_short">
        <source>all letter characters</source>
        <target state="translated">všechny znaky písmen</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_long">
        <source>All numbers. This includes the Nd, Nl, and No categories.</source>
        <target state="translated">Všechna čísla. Patří k nim kategorie Nd, Nl a No.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_short">
        <source>all numbers</source>
        <target state="translated">všechna čísla</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_long">
        <source>All punctuation characters. This includes the Pc, Pd, Ps, Pe, Pi, Pf, and Po categories.</source>
        <target state="translated">Všechny znaky interpunkce. Patří k nim kategorie Pc, Pd, Ps, Pe, Pi, Pf a Po.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_short">
        <source>all punctuation characters</source>
        <target state="translated">všechny znaky interpunkce</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_long">
        <source>All separator characters. This includes the Zs, Zl, and Zp categories.</source>
        <target state="translated">Všechny oddělovací znaky. Patří k nim kategorie Zs, Zl a Zp.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_short">
        <source>all separator characters</source>
        <target state="translated">všechny oddělovací znaky</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_long">
        <source>All symbols. This includes the Sm, Sc, Sk, and So categories.</source>
        <target state="translated">Všechny symboly. Patří k nim kategorie Sm, Sc, Sk a So.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_short">
        <source>all symbols</source>
        <target state="translated">všechny symboly</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_long">
        <source>You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.</source>
        <target state="translated">Můžete použít znak svislé čáry (|), pokud se má položka shodovat s libovolným vzorem z řady, ve které znak | odděluje jednotlivé vzory.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_short">
        <source>alternation</source>
        <target state="translated">alternace</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_long">
        <source>The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified by the 's' option, . matches any character.</source>
        <target state="translated">Znak tečky (.) odpovídá libovolnému znaku s výjimkou \n (znak nového řádku \u000A). Pokud je vzor regulárního výrazu modifikovaný možností RegexOptions.Singleline nebo pokud je část vzoru obsahující třídu znaků tečky modifikovaná parametrem s, pak znak tečky odpovídá libovolnému znaku.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_short">
        <source>any character</source>
        <target state="translated">libovolný znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_long">
        <source>Matches a backspace character, \u0008</source>
        <target state="translated">Shoda se znakem Backspace \u0008</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_short">
        <source>backspace character</source>
        <target state="translated">znak Backspace</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_long">
        <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.
    
'name1' is the current group (optional), 'name2' is a previously defined group, and 'subexpression' is any valid regular expression pattern. The balancing group definition deletes the definition of name2 and stores the interval between name2 and name1 in name1. If no name2 group is defined, the match backtracks. Because deleting the last definition of name2 reveals the previous definition of name2, this construct lets you use the stack of captures for group name2 as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.

The balancing group definition uses 'name2' as a stack. The beginning character of each nested construct is placed in the group and in its Group.Captures collection. When the closing character is matched, its corresponding opening character is removed from the group, and the Captures collection is decreased by one. After the opening and closing characters of all nested constructs have been matched, 'name1' is empty.</source>
        <target state="translated">Definice vyrovnávací skupiny odstraní definici dříve definované skupiny a uloží interval mezi dříve definovanou skupinou a aktuální skupinou do aktuální skupiny.
    
Skupina name1 je aktuální skupina (volitelná), skupina name2 je dříve definovaná skupina a subexpression je libovolný platný vzor regulárního výrazu. Definice vyrovnávací skupiny odstraní definici skupiny name2 a uloží interval mezi skupinami name2 a name1 do skupiny name1. Pokud není definována žádná skupina name2, porovnávání se vrátí zpět. Vzhledem k tomu, že odstraněním poslední definice skupiny name2 se odkryje předchozí definice skupiny name2, umožňuje tento konstruktor použít zásobník zachycení pro skupinu name2 jako čítač pro uchování přehledu o vnořených konstruktorech, jako jsou kulaté nebo hranaté otevírací a uzavírací závorky.

Definice vyrovnávací skupiny používá jako zásobník skupinu name2. Počáteční znak každého vnořeného konstruktoru se umístí do této skupiny a do její kolekce Group.Captures. Po nalezení uzavíracího znaku se odpovídající otevírací znak odebere ze skupiny a kolekce Captures se zmenší o jednu položku. Po nalezení otevíracích a uzavíracích znaků všech vnořených konstruktorů bude skupina name1 prázdná.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_short">
        <source>balancing group</source>
        <target state="translated">vyrovnávací skupina</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_base_group">
        <source>base-group</source>
        <target state="translated">základní skupina</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_long">
        <source>Matches a bell (alarm) character, \u0007</source>
        <target state="translated">Shoda se znakem zvonku \u0007</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_short">
        <source>bell character</source>
        <target state="translated">znak zvonku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_long">
        <source>Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n.</source>
        <target state="translated">Shoda se znakem návratu na začátek řádku \u000D. Upozorňujeme, že \r není ekvivalentem znaku nového řádku \n.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_short">
        <source>carriage-return character</source>
        <target state="translated">znak návratu na začátek řádku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_long">
        <source>Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.

'base_group' is a positive or negative character group or range. The 'excluded_group' component is another positive or negative character group, or another character class subtraction expression (that is, you can nest character class subtraction expressions).</source>
        <target state="translated">Odčítání třídy znaků poskytuje sadu znaků, která je výsledkem vyloučení znaků v jedné třídě znaků z jiné třídy znaků.

Base_group je pozitivní nebo negativní skupina znaků nebo rozsah. Komponenta excluded_group je jiná pozitivní nebo negativní skupina znaků nebo jiný výraz odčítání třídy znaků (to znamená, že výrazy odčítání třídy znaků lze vnořovat).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_short">
        <source>character class subtraction</source>
        <target state="translated">odčítání třídy znaků</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_group">
        <source>character-group</source>
        <target state="translated">skupina znaků</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_comment">
        <source>comment</source>
        <target state="translated">komentář</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.

'expression' is the initial pattern to match, 'yes' is the pattern to match if expression is matched, and 'no' is the optional pattern to match if expression is not matched.</source>
        <target state="translated">Tento element jazyka se pokusí najít shodu s jedním ze dvou vzorů na základě toho, jestli se najde shoda s počátečním vzorem.

Expression je počáteční vzor, pro který se hledá shoda, yes je vzor, pro který se hledá shoda, pokud se pro expression najde shoda, a no je volitelný vzor, pro který se hledá shoda, pokud se pro expression nenajde shoda.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_short">
        <source>conditional expression match</source>
        <target state="translated">podmíněná shoda výrazu</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.

'name' is the name (or number) of a capturing group, 'yes' is the expression to match if 'name' (or 'number') has a match, and 'no' is the optional expression to match if it does not.</source>
        <target state="translated">Tento element jazyka se pokusí najít shodu s jedním ze dvou vzorů na základě toho, jestli se najde shoda se zadanou zachycující skupinou.

Name je název (nebo číslo) zachycující skupiny, yes je výraz, pro který se hledá shoda, pokud se daný název (nebo číslo) najde, a no je volitelný výraz, pro který se hledá shoda, pokud se tato položka nenajde.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_short">
        <source>conditional group match</source>
        <target state="translated">podmíněná shoda skupiny</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_long">
        <source>The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.</source>
        <target state="translated">Ukotvení \G určuje, že ke shodě musí dojít v místě, kde bylo předchozí porovnávání ukončeno. Pokud použijete toto ukotvení s metodou Regex.Matches nebo Match.NextMatch, zajistí se, že všechna porovnávání budou souvislá.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_short">
        <source>contiguous matches</source>
        <target state="translated">souvislá porovnávání</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_long">
        <source>Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C.</source>
        <target state="translated">Shoda s řídicím znakem ASCII, kde X je písmeno řídicího znaku. Například \cC je CTRL-C.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_short">
        <source>control character</source>
        <target state="translated">řídicí znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_long">
        <source>\d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.

If ECMAScript-compliant behavior is specified, \d is equivalent to [0-9]</source>
        <target state="translated">\d odpovídá libovolné desítkové číslici. Jde o ekvivalent vzoru regulárního výrazu \p{Nd}, který zahrnuje standardní desítkové číslice 0–9 a také desítkové číslice některých jiných znakových sad.

Pokud je zadané chování kompatibilní s ECMAScriptem, je \d ekvivalentem [0-9].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_short">
        <source>decimal-digit character</source>
        <target state="translated">znak desítkové číslice</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_long">
        <source>A number sign (#) marks an x-mode comment, which starts at the unescaped # character at the end of the regular expression pattern and continues until the end of the line. To use this construct, you must either enable the x option (through inline options) or supply the RegexOptions.IgnorePatternWhitespace value to the option parameter when instantiating the Regex object or calling a static Regex method.</source>
        <target state="translated">Symbol čísla (#) označuje komentář v režimu X, který začíná znakem #, který není řídicím znakem, na konci vzoru regulárního výrazu a pokračuje do konce řádku. Pokud chcete použít tento konstruktor, musíte buď povolit možnost x (prostřednictvím vložených možností), nebo při vytváření instance objektu Regex nebo volání statické metody Regex zadat pro parametr možnosti hodnotu RegexOptions.IgnorePatternWhitespace.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_short">
        <source>end-of-line comment</source>
        <target state="translated">komentář na konci řádku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_long">
        <source>The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, it can only match the last line of the input string.</source>
        <target state="translated">Ukotvení \z určuje, že ke shodě musí dojít na konci vstupního řetězce. Podobně jako element jazyka $ i \z ignoruje možnost RegexOptions.Multiline. Na rozdíl od elementu jazyka \Z nenajde \z shodu se znakem \n na konci řetězce. Proto může hledat shodu jenom v posledním řádku vstupního řetězce.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_short">
        <source>end of string only</source>
        <target state="translated">jen konec řetězce</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_long">
        <source>The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can only match the end of the last line, or the last line before \n.

The \Z anchor matches \n but does not match \r\n (the CR/LF character combination). To match CR/LF, include \r?\Z in the regular expression pattern.</source>
        <target state="translated">Ukotvení \Z určuje, že ke shodě musí dojít na konci vstupního řetězce nebo před \n na konci vstupního řetězce. Je identické s ukotvením $, kromě toho, že \Z ignoruje možnost RegexOptions.Multiline. Proto ve víceřádkovém řetězci může najít shodu jenom na konci posledního řádku nebo v posledním řádku před \n.

Ukotvení \Z najde shodu s \n, ale nenajde shodu s \r\n (kombinace znaků CR/LF). Pokud chcete hledat znaky CR/LF, zadejte do vzoru regulárního výrazu \r?\Z.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_short">
        <source>end of string or before ending newline</source>
        <target state="translated">konec řetězce nebo před koncem nového řádku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_long">
        <source>The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string. If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line.

The $ anchor matches \n but does not match \r\n (the combination of carriage return and newline characters, or CR/LF). To match the CR/LF character combination, include \r?$ in the regular expression pattern.</source>
        <target state="translated">Ukotvení $ určuje, že se předchozí vzor musí vyskytovat na konci vstupního řetězce nebo před \n na konci vstupního řetězce. Pokud použijete $ s možností RegexOptions.Multiline, může ke shodě dojít i na konci řádku.

Ukotvení $ najde shodu s \n, ale nenajde shodu s \r\n (kombinace znaků návratu na začátek řádku a nového řádku, tedy znaků CR/LF). Pokud chcete hledat kombinaci znaků CR/LF, zadejte do vzoru regulárního výrazu \r?$.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_short">
        <source>end of string or line</source>
        <target state="translated">konec řetězce nebo řádku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_long">
        <source>Matches an escape character, \u001B</source>
        <target state="translated">Shoda s řídicím znakem \u001B</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_short">
        <source>escape character</source>
        <target state="translated">řídicí znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_excluded_group">
        <source>excluded-group</source>
        <target state="translated">vyloučená skupina</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_expression">
        <source>expression</source>
        <target state="translated">výraz</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_long">
        <source>Matches a form-feed character, \u000C</source>
        <target state="translated">Shoda se znakem pro novou stránku \u000C</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_short">
        <source>form-feed character</source>
        <target state="translated">znak pro novou stránku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_long">
        <source>This grouping construct applies or disables the specified options within a subexpression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly
	named or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">Tento seskupovací konstruktor povoluje nebo zakazuje možnosti zadané v rámci výrazu subexpression. Možnosti, které se povolují, se zadávají za otazník a možnosti, které se zakazují, za symbol minus. Povolené možnosti:

    i	Použije se porovnávání bez rozlišování malých a velkých písmen.
    m	Použije se víceřádkový režim, kde ^ a $ odpovídají začátku a konci každého řádku
	(místo začátku a konce vstupního řetězce).
    s	Použije se jednořádkový režim, kde tečka (.) odpovídá každému znaku
	(místo každému znaku kromě \n).
    n	Nezachytává nepojmenované skupiny. Jediná platná zachycení představují explicitně
	pojmenované nebo číslované skupiny formuláře (? &lt;name&gt; subexpression).
    x	Vyloučí ze vzoru prázdné znaky, které nejsou řídicími znaky, a povolí komentáře
	za symbolem čísla (#).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_short">
        <source>group options</source>
        <target state="translated">seskupovací možnosti</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_long">
        <source>Matches an ASCII character, where ## is a two-digit hexadecimal character code.</source>
        <target state="translated">Shoda se znakem ASCII, kde ## je dvouciferný šestnáctkový kód znaku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_short">
        <source>hexadecimal escape</source>
        <target state="needs-review-translation">šestnáctkový řídicí znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_long">
        <source>The (?# comment) construct lets you include an inline comment in a regular expression. The regular expression engine does not use any part of the comment in pattern matching, although the comment is included in the string that is returned by the Regex.ToString method. The comment ends at the first closing parenthesis.</source>
        <target state="translated">Konstruktor (?# komentář) umožňuje zahrnout vložený komentář do regulárního výrazu. Modul regulárních výrazů nepoužije při porovnávání vzorů žádnou část komentáře, i když je komentář obsažený v řetězci, který vrací metoda Regex.ToString. Komentář končí první uzavírací závorkou.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_short">
        <source>inline comment</source>
        <target state="translated">vložený komentář</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_long">
        <source>Enables or disables specific pattern matching options for the remainder of a regular expression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly named
	or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">Povoluje nebo zakazuje specifické možnosti pro porovnávání vzorů pro zbytek regulárního výrazu. Možnosti, které se povolují, se zadávají za otazník a možnosti, které se zakazují, za symbol minus. Povolené možnosti:

    i	Použije se porovnávání bez rozlišování malých a velkých písmen.
    m	Použije se víceřádkový režim, kde ^ a $ odpovídají začátku a konci každého řádku
	(místo začátku a konce vstupního řetězce).
    s	Použije se jednořádkový režim, kde tečka (.) odpovídá každému znaku
	(místo každému znaku kromě \n).
    n	Nezachytává nepojmenované skupiny. Jediná platná zachycení představují explicitně
	pojmenované nebo číslované skupiny formuláře (? &lt;name&gt; subexpression).
    x	Vyloučí ze vzoru prázdné znaky, které nejsou řídicími znaky, a povolí komentáře
	za symbolem čísla (#).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_short">
        <source>inline options</source>
        <target state="translated">vložené možnosti</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_lowercase">
        <source>letter, lowercase</source>
        <target state="translated">písmeno, malá písmena</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_modifier">
        <source>letter, modifier</source>
        <target state="translated">písmeno, modifikátor</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_other">
        <source>letter, other</source>
        <target state="translated">písmeno, jiné</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_titlecase">
        <source>letter, titlecase</source>
        <target state="translated">písmeno, velká počáteční písmena</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_uppercase">
        <source>letter, uppercase</source>
        <target state="translated">písmeno, velká písmena</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_enclosing">
        <source>mark, enclosing</source>
        <target state="translated">značka, uzavření</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_nonspacing">
        <source>mark, nonspacing</source>
        <target state="translated">značka, bez mezer</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_spacing_combining">
        <source>mark, spacing combining</source>
        <target state="translated">značka, kombinování mezer</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_long">
        <source>The {n,}? quantifier matches the preceding element at least n times, where n is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,}</source>
        <target state="translated">Kvantifikátor {n,}? najde shodu předchozího elementu nejméně n-krát, kde n je celé číslo, ale co nejméněkrát. Jedná se o líný protějšek hladového kvantifikátoru {n,}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">shoda nejméně n-krát (líný režim)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_long">
        <source>The {n,} quantifier matches the preceding element at least n times, where n is any integer. {n,} is a greedy quantifier whose lazy equivalent is {n,}?</source>
        <target state="translated">Kvantifikátor {n,} najde shodu předchozího elementu nejméně n-krát, kde n je celé číslo. {n,} je hladový kvantifikátor, jehož líným ekvivalentem je {n,}?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_short">
        <source>match at least 'n' times</source>
        <target state="translated">shoda nejméně n-krát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_long">
        <source>The {n,m}? quantifier matches the preceding element between n and m times, where n and m are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,m}</source>
        <target state="translated">Kvantifikátor {n,m}? najde shodu předchozího elementu v rozmezí n-krát a m-krát, kde n a m jsou celá čísla, ale co nejméněkrát. Jedná se o líný protějšek hladového kvantifikátoru {n,m}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">shoda nejméně n-krát (líný režim)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_long">
        <source>The {n,m} quantifier matches the preceding element at least n times, but no more than m times, where n and m are integers. {n,m} is a greedy quantifier whose lazy equivalent is {n,m}?</source>
        <target state="translated">Kvantifikátor {n,m} najde shodu předchozího elementu nejméně n-krát, ale nejvíce m-krát, kde n a m jsou celá čísla. {n,m} je hladový kvantifikátor, jehož líným ekvivalentem je {n,m}?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_short">
        <source>match between 'm' and 'n' times</source>
        <target state="translated">shoda v rozmezí m-krát a n-krát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_long">
        <source>The {n}? quantifier matches the preceding element exactly n times, where n is any integer. It is the lazy counterpart of the greedy quantifier {n}+</source>
        <target state="translated">Kvantifikátor {n}? najde shodu předchozího elementu přesně n-krát, kde n je celé číslo. Jedná se o líný protějšek hladového kvantifikátoru {n}+.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_short">
        <source>match exactly 'n' times (lazy)</source>
        <target state="translated">shoda přesně n-krát (líný režim)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_long">
        <source>The {n} quantifier matches the preceding element exactly n times, where n is any integer. {n} is a greedy quantifier whose lazy equivalent is {n}?</source>
        <target state="translated">Kvantifikátor {n} najde shodu předchozího elementu přesně n-krát, kde n je libovolné celé číslo. {n} je hladový kvantifikátor, jehož líným ekvivalentem je {n}?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_short">
        <source>match exactly 'n' times</source>
        <target state="translated">shoda přesně n-krát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_long">
        <source>The +? quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier +</source>
        <target state="translated">Kvantifikátor +? najde shodu předchozího elementu 1krát nebo vícekrát, ale co nejméněkrát. Jedná se o líný protějšek hladového kvantifikátoru +.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_short">
        <source>match one or more times (lazy)</source>
        <target state="translated">shoda 1krát nebo vícekrát (líný režim)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_long">
        <source>The + quantifier matches the preceding element one or more times. It is equivalent to the {1,} quantifier. + is a greedy quantifier whose lazy equivalent is +?.</source>
        <target state="translated">Kvantifikátor + najde shodu předchozího elementu 1krát nebo vícekrát. Jedná se o ekvivalent kvantifikátoru {1,}. + je hladový kvantifikátor, jehož líným ekvivalentem je +?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_short">
        <source>match one or more times</source>
        <target state="translated">shoda 1krát nebo vícekrát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_long">
        <source>The *? quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier *</source>
        <target state="translated">Kvantifikátor *? najde shodu předchozího elementu 0krát nebo vícekrát, ale co nejméněkrát. Jedná se o líný protějšek hladového kvantifikátoru *.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_short">
        <source>match zero or more times (lazy)</source>
        <target state="translated">shoda 0krát nebo vícekrát (líný režim)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_long">
        <source>The * quantifier matches the preceding element zero or more times. It is equivalent to the {0,} quantifier. * is a greedy quantifier whose lazy equivalent is *?.</source>
        <target state="translated">Kvantifikátor * najde shodu předchozího elementu 0krát nebo vícekrát. Jedná se o ekvivalent kvantifikátoru {0,}. * je hladový kvantifikátor, jehož líným ekvivalentem je *?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_short">
        <source>match zero or more times</source>
        <target state="translated">shoda 0krát nebo vícekrát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_long">
        <source>The ?? quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier ?</source>
        <target state="translated">Kvantifikátor ?? najde shodu předchozího elementu 0krát nebo 1krát, ale co nejméněkrát. Jedná se o líný protějšek hladového kvantifikátoru ?.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_short">
        <source>match zero or one time (lazy)</source>
        <target state="translated">shoda 0krát nebo 1krát (líný režim)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_long">
        <source>The ? quantifier matches the preceding element zero or one time. It is equivalent to the {0,1} quantifier. ? is a greedy quantifier whose lazy equivalent is ??.</source>
        <target state="translated">Kvantifikátor ? najde shodu předchozího elementu 0krát nebo 1krát. Jedná se o ekvivalent kvantifikátoru {0,1}. ? je hladový kvantifikátor, jehož líným ekvivalentem je ??.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_short">
        <source>match zero or one time</source>
        <target state="translated">shoda 0krát nebo 1krát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_long">
        <source>This grouping construct captures a matched 'subexpression', where 'subexpression' is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one. The capture that is numbered zero is the text matched by the entire regular expression pattern.</source>
        <target state="translated">Tento seskupovací konstruktor zachytává porovnávaný dílčí výraz, kde dílčí výraz je libovolný platný vzor regulárního výrazu. Zachycení, která používají závorky, jsou automaticky číslována zleva doprava podle pořadí otevíracích závorek v regulárním výrazu, počínaje od hodnoty jedna. Zachycení s číslem nula je text odpovídající celému vzoru regulárního výrazu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_short">
        <source>matched subexpression</source>
        <target state="translated">porovnávaný dílčí výraz</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name">
        <source>name</source>
        <target state="translated">název</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name1">
        <source>name1</source>
        <target state="translated">name1</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name2">
        <source>name2</source>
        <target state="translated">name2</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name_or_number">
        <source>name-or-number</source>
        <target state="translated">název nebo číslo</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_long">
        <source>A named or numbered backreference.

'name' is the name of a capturing group defined in the regular expression pattern.</source>
        <target state="translated">Pojmenovaná nebo číslovaná zpětná reference.

Název představuje název zachycující skupiny definované ve vzoru regulárního výrazu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_short">
        <source>named backreference</source>
        <target state="translated">pojmenovaná zpětná reference</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_long">
        <source>Captures a matched subexpression and lets you access it by name or by number.

'name' is a valid group name, and 'subexpression' is any valid regular expression pattern. 'name' must not contain any punctuation characters and cannot begin with a number.

If the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the only way to capture a subexpression is to explicitly name capturing groups.</source>
        <target state="translated">Zachytává porovnávaný dílčí výraz a umožňuje k němu přístup pomocí názvu nebo čísla.

Název je platný název skupiny a dílčí výraz je libovolný platný vzor regulárního výrazu. Název nesmí obsahovat znaky interpunkce a nesmí začínat číslicí.

Pokud parametr RegexOptions metody odpovídající vzoru regulárního výrazu obsahuje příznak RegexOptions.ExplicitCapture nebo pokud je u daného dílčího výrazu použitá možnost n, je jediným způsobem, jak zachytit dílčí výraz, explicitní pojmenování zachycujících skupin.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_short">
        <source>named matched subexpression</source>
        <target state="translated">pojmenovaný porovnávaný dílčí výraz</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_long">
        <source>A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters are specified individually.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">Negativní skupina znaků určuje seznam znaků, které se nesmí vyskytovat ve vstupním řetězci, aby došlo ke shodě. Seznam znaků se zadává jednotlivě.

Je možné zřetězit dva nebo více rozsahů znaků. Pokud chcete například zadat rozsah desítkových číslic od 0 do 9, rozsah malých písmen od a do f a rozsah velkých písmen od A do F, použijte [0-9A-fA-F].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_short">
        <source>negative character group</source>
        <target state="translated">negativní skupina znaků</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_range_long">
        <source>A negative character range specifies a list of characters that must not appear in an input string for a match to occur. 'firstCharacter' is the character that begins the range, and 'lastCharacter' is the character that ends the range.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">Negativní rozsah znaků určuje seznam znaků, které se nesmí vyskytovat ve vstupním řetězci, aby došlo ke shodě. firstCharacter je znak, kterým rozsah začíná, a lastCharacter je znak, kterým rozsah končí.

Je možné zřetězit dva nebo více rozsahů znaků. Pokud chcete například zadat rozsah desítkových číslic od 0 do 9, rozsah malých písmen od a do f a rozsah velkých písmen od A do F, použijte [0-9A-fA-F].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_range_short">
        <source>negative character range</source>
        <target state="translated">negativní rozsah znaků</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_long">
        <source>The regular expression construct \P{ name } matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">Konstruktor regulárního výrazu \P{ name } odpovídá libovolnému znaku, který nepatří do obecné kategorie Unicode nebo pojmenovaného bloku, kde name je zkratka pro kategorii nebo název pojmenovaného bloku.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_short">
        <source>negative unicode category</source>
        <target state="translated">negativní kategorie Unicode</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_long">
        <source>Matches a new-line character, \u000A</source>
        <target state="translated">Shoda se znakem pro nový řádek \u000A</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_short">
        <source>new-line character</source>
        <target state="translated">znak pro nový řádek</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_no">
        <source>no</source>
        <target state="translated">ne</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_long">
        <source>\D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.

If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9]</source>
        <target state="translated">\D odpovídá libovolnému nečíselnému znaku. Je ekvivalentem vzoru regulárního výrazu \P{Nd}.

Pokud je zadané chování kompatibilní s ECMAScriptem, je \D ekvivalentem [^0-9].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_short">
        <source>non-digit character</source>
        <target state="translated">nečíselný znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_long">
        <source>\S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.

If ECMAScript-compliant behavior is specified, \S is equivalent to [^ \f\n\r\t\v]</source>
        <target state="translated">\S odpovídá libovolnému neprázdnému znaku. Je ekvivalentem vzoru regulárního výrazu [^\f\n\r\t\v\x85\p{Z}] nebo opakem vzoru regulárního výrazu, který je ekvivalentem \s, který najde prázdné znaky.

Pokud je zadané chování kompatibilní s ECMAScriptem, je \S ekvivalentem [^ \f\n\r\t\v].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_short">
        <source>non-white-space character</source>
        <target state="translated">neprázdný znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_long">
        <source>The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor.</source>
        <target state="translated">Ukotvení \B určuje, že shoda se nesmí vyskytovat na hranici slova. Jedná se o opak ukotvení \b.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_short">
        <source>non-word boundary</source>
        <target state="translated">mimo hranici slova</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_character_long">
        <source>\W matches any non-word character. It matches any character except for those in the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \W is equivalent to [^a-zA-Z_0-9]</source>
        <target state="translated">\W odpovídá jakémukoli znaku, který není znakem slova. Odpovídá libovolnému znaku s výjimkou znaků v následujících kategoriích Unicode:

    Ll	písmeno, malá písmena
    Lu	písmeno, velká písmena
    Lt	písmeno, velká počáteční písmena
    Lo	písmeno, jiné
    Lm	písmeno, modifikátor
    Mn	značka, bez mezer
    Nd	číslo, desítkové číslo
    Pc	interpunkce, spojovník

Pokud je zadané chování kompatibilní s ECMAScriptem, je \W ekvivalentem [^a-zA-Z_0-9].</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized. </note>
      </trans-unit>
      <trans-unit id="Regex_non_word_character_short">
        <source>non-word character</source>
        <target state="translated">znak, který není znakem slova</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_nonbacktracking_subexpression_long">
        <source>This construct disables backtracking. The regular expression engine will match as many characters in the input string as it can. When no further match is possible, it will not backtrack to attempt alternate pattern matches. (That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)

This option is recommended if you know that backtracking will not succeed. Preventing the regular expression engine from performing unnecessary searching improves performance.</source>
        <target state="translated">Tento konstruktor zakazuje zpětné navracení. Modul regulárních výrazů najde shodu s co nejvíce znaky ve vstupním řetězci. Pokud se žádná další shoda nenajde, neprovede se zpětné navracení za účelem pokusu o porovnávání alternativního vzoru. (To znamená, že dílčí výraz najde shodu jenom s řetězci, které by odpovídaly samotnému dílčímu výrazu. Nepokusí se porovnávat řetězec na základě dílčího výrazu a jakýchkoli dílčích výrazů, které následují.)

Tato možnost se doporučuje, pokud víte, že zpětné navracení nepovede k úspěchu. Když zabráníte, aby modul regulárních výrazů prováděl zbytečná hledání, zlepší se výkon.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_nonbacktracking_subexpression_short">
        <source>nonbacktracking subexpression</source>
        <target state="translated">dílčí výraz bez zpětného navracení</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_long">
        <source>This construct does not capture the substring that is matched by a subexpression:

The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.

If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
        <target state="translated">Tento konstruktor nezachycuje dílčí řetězec, který odpovídá dílčímu výrazu:

Konstruktor nezachycující skupiny se obvykle používá, když se kvantifikátor aplikuje pro skupinu, ale dílčí řetězce zachycené skupinou uživatele nezajímají.

Pokud regulární výraz obsahuje vnořené seskupovací konstruktory, vnější konstruktor nezachycující skupiny se neaplikuje na vnitřní vnořené konstruktory skupiny.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_short">
        <source>noncapturing group</source>
        <target state="translated">nezachycující skupina</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_decimal_digit">
        <source>number, decimal digit</source>
        <target state="translated">číslo, desítkové číslo</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_letter">
        <source>number, letter</source>
        <target state="translated">číslo, písmeno</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_other">
        <source>number, other</source>
        <target state="translated">číslo, jiné</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_long">
        <source>A numbered backreference, where 'number' is the ordinal position of the capturing group in the regular expression. For example, \4 matches the contents of the fourth capturing group.

There is an ambiguity between octal escape codes (such as \16) and \number backreferences that use the same notation. If the ambiguity is a problem, you can use the \k&lt;name&gt; notation, which is unambiguous and cannot be confused with octal character codes. Similarly, hexadecimal codes such as \xdd are unambiguous and cannot be confused with backreferences.</source>
        <target state="translated">Číslovaná zpětná reference, kde číslo je pořadové umístění zachycující skupiny v regulárním výrazu. Například \4 odpovídá obsahu čtvrté zachycující skupiny.

Existuje nejednoznačnost mezi osmičkovými řídicími kódy (například \16) a zpětnými referencemi \číslo, které používají stejný zápis. Pokud nejednoznačnost způsobuje potíže, můžete použít zápis \k&lt;name&gt;, který je jednoznačný a nedá se zaměnit s osmičkovými kódy znaků. Stejně tak šestnáctkové kódy, například \xdd, jsou jednoznačné a nedají se zaměnit se zpětnými referencemi.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_short">
        <source>numbered backreference</source>
        <target state="translated">číslovaná zpětná reference</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_control">
        <source>other, control</source>
        <target state="translated">jiné, řídicí</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_format">
        <source>other, format</source>
        <target state="translated">jiné, formát</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_not_assigned">
        <source>other, not assigned</source>
        <target state="translated">jiné, nepřiřazeno</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_private_use">
        <source>other, private use</source>
        <target state="translated">jiné, privátní použití</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_surrogate">
        <source>other, surrogate</source>
        <target state="translated">jiné, náhradní</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_long">
        <source>A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur.</source>
        <target state="translated">Pozitivní skupina znaků určuje seznam znaků, z nichž kterýkoli se může objevit ve vstupním řetězci, aby došlo ke shodě.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_short">
        <source>positive character group</source>
        <target state="translated">pozitivní skupina znaků</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_long">
        <source>A positive character range specifies a range of characters, any one of which may appear in an input string for a match to occur.  'firstCharacter' is the character that begins the range and 'lastCharacter' is the character that ends the range. </source>
        <target state="translated">Pozitivní rozsah znaků určuje rozsah znaků, z nichž kterýkoli se může objevit ve vstupním řetězci, aby došlo ke shodě. firstCharacter je znak, kterým rozsah začíná, a lastCharacter je znak, kterým rozsah končí.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_short">
        <source>positive character range</source>
        <target state="translated">pozitivní rozsah znaků</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_close">
        <source>punctuation, close</source>
        <target state="translated">interpunkce, uzavření</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_connector">
        <source>punctuation, connector</source>
        <target state="translated">interpunkce, spojovník</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_dash">
        <source>punctuation, dash</source>
        <target state="translated">interpunkce, pomlčka</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_final_quote">
        <source>punctuation, final quote</source>
        <target state="translated">interpunkce, koncová uvozovka</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_initial_quote">
        <source>punctuation, initial quote</source>
        <target state="translated">interpunkce, počáteční uvozovka</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_open">
        <source>punctuation, open</source>
        <target state="translated">interpunkce, otevření</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_other">
        <source>punctuation, other</source>
        <target state="translated">interpunkce, jiné</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_line">
        <source>separator, line</source>
        <target state="translated">oddělovač, čára</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_paragraph">
        <source>separator, paragraph</source>
        <target state="translated">oddělovač, odstavec</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_space">
        <source>separator, space</source>
        <target state="translated">oddělovač, mezera</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_long">
        <source>The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input string.</source>
        <target state="translated">Ukotvení \A určuje, že ke shodě musí dojít na začátku vstupního řetězce. Je identické s ukotvením ^, kromě toho, že \A ignoruje možnost RegexOptions.Multiline. Proto může hledat shodu jenom na začátku prvního řádku ve víceřádkovém vstupním řetězci.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_short">
        <source>start of string only</source>
        <target state="translated">jen začátek řetězce</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_long">
        <source>The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.</source>
        <target state="translated">Ukotvení ^ určuje, že následující vzor musí začínat na pozici prvního znaku řetězce. Pokud použijete ^ s možností RegexOptions.Multiline, musí ke shodě dojít na začátku každého řádku.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_short">
        <source>start of string or line</source>
        <target state="translated">začátek řetězce nebo řádku</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_subexpression">
        <source>subexpression</source>
        <target state="translated">dílčí výraz</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_currency">
        <source>symbol, currency</source>
        <target state="translated">symbol, měna</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_math">
        <source>symbol, math</source>
        <target state="translated">symbol, matematický</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_modifier">
        <source>symbol, modifier</source>
        <target state="translated">symbol, modifikátor</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_other">
        <source>symbol, other</source>
        <target state="translated">symbol, jiné</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_long">
        <source>Matches a tab character, \u0009</source>
        <target state="translated">Shoda se znakem tabulátoru \u0009</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_short">
        <source>tab character</source>
        <target state="translated">znak tabulátoru</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_long">
        <source>The regular expression construct \p{ name } matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">Konstruktor regulárního výrazu \p{ name } odpovídá libovolnému znaku, který patří do obecné kategorie Unicode nebo pojmenovaného bloku, kde name je zkratka pro kategorii nebo název pojmenovaného bloku.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_short">
        <source>unicode category</source>
        <target state="translated">kategorie Unicode</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_long">
        <source>Matches a UTF-16 code unit whose value is #### hexadecimal.</source>
        <target state="translated">Shoda s jednotkou kódu UTF-16, jejíž šestnáctková hodnota je ####</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_short">
        <source>unicode escape</source>
        <target state="translated">řídicí znak Unicode</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_general_category_0">
        <source>Unicode General Category: {0}</source>
        <target state="translated">Obecná kategorie Unicode: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_long">
        <source>Matches a vertical-tab character, \u000B</source>
        <target state="translated">Shoda se znakem svislého tabulátoru \u000B</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_short">
        <source>vertical-tab character</source>
        <target state="translated">znak svislého tabulátoru</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_long">
        <source>\s matches any white-space character. It is equivalent to the following escape sequences and Unicode categories:

    \f	The form feed character, \u000C
    \n	The newline character, \u000A
    \r	The carriage return character, \u000D
    \t	The tab character, \u0009
    \v	The vertical tab character, \u000B
    \x85	The ellipsis or NEXT LINE (NEL) character (…), \u0085
    \p{Z}	Matches any separator character

If ECMAScript-compliant behavior is specified, \s is equivalent to [ \f\n\r\t\v]</source>
        <target state="translated">\s odpovídá jakémukoli prázdnému znaku. Je ekvivalentem následujících řídicích sekvencí a kategorií Unicode:

    \f	znak pro novou stránku \u000C
    \n	znak nového řádku \u000A
    \r	znak návratu na začátek řádku \u000D
    \t	znak tabulátoru \u0009
    \v	znak svislého tabulátoru \u000B
    \x85	znak tří teček nebo dalšího řádku (...) \u0085
    \p{Z}	shoda s libovolným znakem oddělovače

Pokud je zadané chování kompatibilní s ECMAScriptem, je \s ekvivalentem [ \f\n\r\t\v].</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_short">
        <source>white-space character</source>
        <target state="translated">prázdný znak</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_long">
        <source>The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore. The match may also occur on a word boundary at the beginning or end of the string.

The \b anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
        <target state="translated">Ukotvení \b určuje, že ke shodě musí dojít na hranici mezi znakem slova (element jazyka \w) a znakem, který není znakem slova (element jazyka \W). Mezi znaky slova patří alfanumerické znaky a podtržítka. Znak, který není znakem slova, je jakýkoli znak, který není alfanumerický ani podtržítko. Ke shodě může dojít i na hranici slova na začátku nebo na konci řetězce.

Ukotvení \b se často používá k ověření, že dílčí výraz odpovídá celému slovu, nikoli jenom začátku nebo konci slova.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_short">
        <source>word boundary</source>
        <target state="translated">hranice slova</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_character_long">
        <source>\w matches any word character. A word character is a member of any of the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \w is equivalent to [a-zA-Z_0-9]</source>
        <target state="translated">\w odpovídá jakémukoli znaku slova. Znak slova je členem libovolné z následujících kategorií Unicode:

    Ll	písmeno, malá písmena
    Lu	písmeno, velká písmena
    Lt	písmeno, velká počáteční písmena
    Lo	písmeno, jiné
    Lm	písmeno, modifikátor
    Mn	značka, bez mezer
    Nd	číslo, desítkové číslo
    Pc	interpunkce, spojovník

Pokud je zadané chování kompatibilní s ECMAScriptem, je \w ekvivalentem [a-zA-Z_0-9].</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized.</note>
      </trans-unit>
      <trans-unit id="Regex_word_character_short">
        <source>word character</source>
        <target state="translated">znak slova</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_yes">
        <source>yes</source>
        <target state="translated">ano</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_long">
        <source>A zero-width negative lookahead assertion, where for the match to be successful, the input string must not match the regular expression pattern in subexpression. The matched string is not included in the match result.

A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression. At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched. In this case, it is often used to limit backtracking. At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
        <target state="translated">Negativní kontrolní výraz dopředného vyhledávání s nulovou šířkou, při kterém úspěšná shoda nastane v případě, že vstupní řetězec neodpovídá vzoru regulárního výrazu v dílčím výrazu. Hledaný řetězec se do výsledku porovnávání nezahrnuje.

Negativní kontrolní výraz dopředného vyhledávání s nulovou šířkou se obvykle používá na začátku nebo na konci regulárního výrazu. Na začátku regulárního výrazu může definovat konkrétní vzor, který by se neměl shodovat, pokud začátek regulárního výrazu definuje podobný, ale obecnější vzor, který se má shodovat. V tomto případě se často používá k omezení zpětného navracení. Na konci regulárního výrazu může definovat dílčí výraz, který se nesmí vyskytovat na konci hledaného řetězce.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_short">
        <source>zero-width negative lookahead assertion</source>
        <target state="translated">negativní kontrolní výraz dopředného vyhledávání s nulovou šířkou</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_long">
        <source>A zero-width negative lookbehind assertion, where for a match to be successful, 'subexpression' must not occur at the input string to the left of the current position. Any substring that does not match 'subexpression' is not included in the match result.

Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define precludes a match in the string that follows. They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</source>
        <target state="translated">Negativní kontrolní výraz zpětného vyhledávání s nulovou šířkou, při kterém úspěšná shoda nastane v případě, že se dílčí výraz nenachází ve vstupním řetězci nalevo od aktuální pozice. Dílčí řetězce, které neodpovídají dílčímu výrazu, se do výsledku porovnávání nezahrnují.

Negativní kontrolní výrazy zpětného vyhledávání s nulovou šířkou se obvykle používají na začátku regulárních výrazů. Vzor, který definují, vylučuje shodu v řetězci, který následuje. Používají se také k omezení zpětného navracení, pokud poslední znak nebo znaky v zachycující skupině nesmí představovat jeden nebo více znaků, které odpovídají vzoru regulárního výrazu dané skupiny.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_short">
        <source>zero-width negative lookbehind assertion</source>
        <target state="translated">negativní kontrolní výraz zpětného vyhledávání s nulovou šířkou</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_long">
        <source>A zero-width positive lookahead assertion, where for a match to be successful, the input string must match the regular expression pattern in 'subexpression'. The matched substring is not included in the match result. A zero-width positive lookahead assertion does not backtrack.

Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern. It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match. It is also useful for preventing excessive backtracking. You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</source>
        <target state="translated">Pozitivní kontrolní výraz dopředného vyhledávání s nulovou šířkou, při kterém úspěšná shoda nastane v případě, že vstupní řetězec odpovídá vzoru regulárního výrazu v dílčím výrazu. Odpovídající dílčí řetězec se do výsledku porovnávání nezahrnuje. Pozitivní kontrolní výraz dopředného vyhledávání s nulovou šířkou neprovádí zpětné navracení.

Pozitivní kontrolní výraz dopředného vyhledávání s nulovou šířkou se obvykle nachází na konci vzoru regulárního výrazu. Definuje dílčí řetězec, který musí být nalezen na konci řetězce, aby došlo ke shodě, ale který by shoda neměla zahrnovat. Je také užitečný k zabránění nadměrnému zpětnému navracení. Pomocí pozitivního kontrolního výrazu dopředného vyhledávání s nulovou šířkou můžete zajistit, aby určitá zachycující skupina začínala textem, který odpovídá podmnožině vzoru definovaného pro danou zachycující skupinu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_short">
        <source>zero-width positive lookahead assertion</source>
        <target state="translated">pozitivní kontrolní výraz dopředného vyhledávání s nulovou šířkou</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_long">
        <source>A zero-width positive lookbehind assertion, where for a match to be successful, 'subexpression' must occur at the input string to the left of the current position. 'subexpression' is not included in the match result. A zero-width positive lookbehind assertion does not backtrack.

Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
        <target state="translated">Pozitivní kontrolní výraz zpětného vyhledávání s nulovou šířkou, při kterém úspěšná shoda nastane v případě, že se dílčí výraz nachází ve vstupním řetězci nalevo od aktuální pozice. Dílčí výraz se do výsledku porovnávání nezahrnuje. Pozitivní kontrolní výraz zpětného vyhledávání s nulovou šířkou neprovádí zpětné navracení.

Pozitivní kontrolní výrazy zpětného vyhledávání s nulovou šířkou se obvykle používají na začátku regulárních výrazů. Vzor, který definují, je podmínkou pro shodu, i když není součástí výsledku porovnávání.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_short">
        <source>zero-width positive lookbehind assertion</source>
        <target state="translated">pozitivní kontrolní výraz zpětného vyhledávání s nulovou šířkou</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_the_line_below_if_you_want_to_inherit_dot_editorconfig_settings_from_higher_directories">
        <source>Remove the line below if you want to inherit .editorconfig settings from higher directories</source>
        <target state="translated">Pokud chcete nastavení souboru .editorconfig zdědit z vyšších adresářů, odeberte řádek níže.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_analyzer_config_documents_is_not_supported">
        <source>Removing analyzer config documents is not supported.</source>
        <target state="translated">Odebírání dokumentů konfigurace analyzátoru se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbol_0_is_not_from_source">
        <source>Symbol "{0}" is not from source.</source>
        <target state="translated">Symbol {0} nepochází ze zdroje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Documentation_comment_id_must_start_with_E_F_M_N_P_or_T">
        <source>Documentation comment id must start with E, F, M, N, P or T</source>
        <target state="translated">ID komentáře dokumentace musí začínat znakem E, F, M, N, P nebo T.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cycle_detected_in_extensions">
        <source>Cycle detected in extensions</source>
        <target state="translated">V rozšířeních se zjistil cyklus.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_but_given_one_is_1">
        <source>Destination type must be a {0}, but given one is {1}.</source>
        <target state="translated">Cílový typ musí být {0}, ale zadaný typ je {1}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_or_a_1_but_given_one_is_2">
        <source>Destination type must be a {0} or a {1}, but given one is {2}.</source>
        <target state="translated">Cílový typ musí být {0} nebo {1}, ale zadaný typ je {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_1_or_2_but_given_one_is_3">
        <source>Destination type must be a {0}, {1} or {2}, but given one is {3}.</source>
        <target state="translated">Cílový typ musí být {0}, {1} nebo {2}, ale zadaný typ je {3}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_find_location_to_generation_symbol_into">
        <source>Could not find location to generation symbol into.</source>
        <target state="translated">Nenašlo se umístění, do kterého by se vygeneroval symbol.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_location_provided_to_add_statements_to">
        <source>No location provided to add statements to.</source>
        <target state="translated">Není zadané žádné umístění, kam by se daly přidávat příkazy.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_location_was_not_in_source">
        <source>Destination location was not in source.</source>
        <target state="translated">Cílové umístění není ve zdroji.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_location_was_from_a_different_tree">
        <source>Destination location was from a different tree.</source>
        <target state="translated">Cílové umístění pochází z jiného stromu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Node_is_of_the_wrong_type">
        <source>Node is of the wrong type.</source>
        <target state="translated">Uzel je chybného typu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Location_must_be_null_or_from_source">
        <source>Location must be null or from source.</source>
        <target state="translated">Umístění musí být null nebo ze zdroje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Duplicate_source_file_0_in_project_1">
        <source>Duplicate source file '{0}' in project '{1}'</source>
        <target state="translated">Duplicitní zdrojový soubor {0} v projektu {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_projects_is_not_supported">
        <source>Removing projects is not supported.</source>
        <target state="translated">Odebírání projektů se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_projects_is_not_supported">
        <source>Adding projects is not supported.</source>
        <target state="translated">Přidávání projektů se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbol_specifications">
        <source>Symbol specifications</source>
        <target state="translated">Specifikace symbolů</target>
        <note />
      </trans-unit>
      <trans-unit id="SyntaxTree_is_required_to_accomplish_the_task_but_is_not_supported_by_document_0">
        <source>Syntax tree is required to accomplish the task but is not supported by document {0}.</source>
        <target state="new">Syntax tree is required to accomplish the task but is not supported by document {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Visual_Basic_files">
        <source>Visual Basic files</source>
        <target state="translated">Soubory jazyka Visual Basic</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_adding_imports_will_bring_an_extension_method_into_scope_with_the_same_name_as_member_access">
        <source>Adding imports will bring an extension method into scope with the same name as '{0}'</source>
        <target state="new">Adding imports will bring an extension method into scope with the same name as '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Workspace_is_not_empty">
        <source>Workspace is not empty.</source>
        <target state="translated">Pracovní prostor není platný.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_part_of_the_workspace">
        <source>'{0}' is not part of the workspace.</source>
        <target state="translated">'{0} není součástí pracovního prostoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_already_part_of_the_workspace">
        <source>'{0}' is already part of the workspace.</source>
        <target state="translated">'{0} je už součástí pracovního prostoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_referenced">
        <source>'{0}' is not referenced.</source>
        <target state="translated">'Na {0} se neodkazuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_already_referenced">
        <source>'{0}' is already referenced.</source>
        <target state="translated">'Na {0} se už odkazuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_project_reference_from_0_to_1_will_cause_a_circular_reference">
        <source>Adding project reference from '{0}' to '{1}' will cause a circular reference.</source>
        <target state="translated">Přidání odkazu na projekt z {0} na {1} způsobí cyklický odkaz.</target>
        <note />
      </trans-unit>
      <trans-unit id="Metadata_is_not_referenced">
        <source>Metadata is not referenced.</source>
        <target state="translated">Na metadata se neodkazuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Metadata_is_already_referenced">
        <source>Metadata is already referenced.</source>
        <target state="translated">Na metadata se už odkazuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_present">
        <source>{0} is not present.</source>
        <target state="translated">{0} není k dispozici.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_already_present">
        <source>{0} is already present.</source>
        <target state="translated">{0} je už k dispozici.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_specified_document_is_not_a_version_of_this_document">
        <source>The specified document is not a version of this document.</source>
        <target state="translated">Zadaný dokument nepředstavuje verzi tohoto dokumentu.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_language_0_is_not_supported">
        <source>The language '{0}' is not supported.</source>
        <target state="translated">Jazyk {0} se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_already_contains_the_specified_project">
        <source>The solution already contains the specified project.</source>
        <target state="translated">Řešení už obsahuje zadaný projekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_does_not_contain_the_specified_project">
        <source>The solution does not contain the specified project.</source>
        <target state="translated">Řešení neobsahuje zadaný projekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_project_already_references_the_target_project">
        <source>The project already references the target project.</source>
        <target state="translated">Projekt už odkazuje na cílový projekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_project_already_transitively_references_the_target_project">
        <source>The project already transitively references the target project.</source>
        <target state="translated">Projekt už tranzitivně odkazuje na cílový projekt.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_already_contains_the_specified_document">
        <source>The solution already contains the specified document.</source>
        <target state="translated">Řešení už obsahuje zadaný dokument.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_does_not_contain_the_specified_document">
        <source>The solution does not contain the specified document.</source>
        <target state="translated">Řešení neobsahuje zadaný dokument.</target>
        <note />
      </trans-unit>
      <trans-unit id="Temporary_storage_cannot_be_written_more_than_once">
        <source>Temporary storage cannot be written more than once.</source>
        <target state="translated">Do dočasného úložiště se nedá zapisovat víc než jednou.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_open">
        <source>'{0}' is not open.</source>
        <target state="translated">'{0} není otevřený.</target>
        <note />
      </trans-unit>
      <trans-unit id="A_language_name_cannot_be_specified_for_this_option">
        <source>A language name cannot be specified for this option.</source>
        <target state="translated">Pro tuto možnost se nesmí zadat název jazyka.</target>
        <note />
      </trans-unit>
      <trans-unit id="A_language_name_must_be_specified_for_this_option">
        <source>A language name must be specified for this option.</source>
        <target state="translated">Pro tuto možnost se musí zadat název jazyka.</target>
        <note />
      </trans-unit>
      <trans-unit id="File_was_externally_modified_colon_0">
        <source>File was externally modified: {0}.</source>
        <target state="translated">Došlo k externí úpravě souboru: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unrecognized_language_name">
        <source>Unrecognized language name.</source>
        <target state="translated">Nerozpoznaný název jazyka</target>
        <note />
      </trans-unit>
      <trans-unit id="Can_t_resolve_metadata_reference_colon_0">
        <source>Can't resolve metadata reference: '{0}'.</source>
        <target state="translated">Nejde vyřešit odkaz na metadata: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Can_t_resolve_analyzer_reference_colon_0">
        <source>Can't resolve analyzer reference: '{0}'.</source>
        <target state="translated">Nejde vyřešit odkaz na analyzátor: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_block_expected_after_Project">
        <source>Invalid project block, expected "=" after Project.</source>
        <target state="translated">Neplatný blok projektu; za projektem se očekával znak „=“.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_block_expected_after_project_name">
        <source>Invalid project block, expected "," after project name.</source>
        <target state="translated">Neplatný blok projektu; za názvem projektu se očekával znak „,“.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_block_expected_after_project_path">
        <source>Invalid project block, expected "," after project path.</source>
        <target state="translated">Neplatný blok projektu; za cestou k projektu se očekával znak „,“.</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_0">
        <source>Expected {0}.</source>
        <target state="translated">Očekávalo se {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_must_be_a_non_null_and_non_empty_string">
        <source>"{0}" must be a non-null and non-empty string.</source>
        <target state="translated">{0} musí být neprázdný řetězec, který nemá hodnotu null.</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_header_colon_0">
        <source>Expected header: "{0}".</source>
        <target state="translated">Očekávaná hlavička: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_end_of_file">
        <source>Expected end-of-file.</source>
        <target state="translated">Očekával se konec souboru.</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_0_line">
        <source>Expected {0} line.</source>
        <target state="translated">Očekával se řádek {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="This_submission_already_references_another_submission_project">
        <source>This submission already references another submission project.</source>
        <target state="translated">Toto odeslání už odkazuje na jiný projekt odeslání.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_still_contains_open_documents">
        <source>{0} still contains open documents.</source>
        <target state="translated">{0} pořád obsahuje otevřené dokumenty.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_still_open">
        <source>{0} is still open.</source>
        <target state="translated">{0} je pořád otevřený.</target>
        <note />
      </trans-unit>
      <trans-unit id="An_element_with_the_same_key_but_a_different_value_already_exists">
        <source>An element with the same key but a different value already exists.</source>
        <target state="translated">Element se stejným klíčem, ale odlišnou hodnotou už existuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays_with_more_than_one_dimension_cannot_be_serialized">
        <source>Arrays with more than one dimension cannot be serialized.</source>
        <target state="translated">Pole s víc než jedním rozměrem nejsou serializované.</target>
        <note />
      </trans-unit>
      <trans-unit id="Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer">
        <source>Value too large to be represented as a 30 bit unsigned integer.</source>
        <target state="translated">Hodnota je moc velká, než aby se dala vyjádřit jako 30bitové nepodepsané celé číslo.</target>
        <note />
      </trans-unit>
      <trans-unit id="Specified_path_must_be_absolute">
        <source>Specified path must be absolute.</source>
        <target state="translated">Zadaná cesta musí být absolutní.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cast_is_redundant">
        <source>Cast is redundant.</source>
        <target state="translated">Přetypování je redundantní.</target>
        <note />
      </trans-unit>
      <trans-unit id="Name_can_be_simplified">
        <source>Name can be simplified.</source>
        <target state="translated">Název se dá zjednodušit.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_identifier">
        <source>Unknown identifier.</source>
        <target state="translated">Neznámý identifikátor</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_generate_code_for_unsupported_operator_0">
        <source>Cannot generate code for unsupported operator '{0}'</source>
        <target state="translated">Nejde generovat kód pro nepodporovaný operátor {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_number_of_parameters_for_binary_operator">
        <source>Invalid number of parameters for binary operator.</source>
        <target state="translated">Neplatný počet parametrů pro binární operátor</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_number_of_parameters_for_unary_operator">
        <source>Invalid number of parameters for unary operator.</source>
        <target state="translated">Neplatný počet parametrů pro unární operátor</target>
        <note />
      </trans-unit>
      <trans-unit id="Absolute_path_expected">
        <source>Absolute path expected.</source>
        <target state="translated">Očekávala se absolutní cesta.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_open_project_0_because_the_file_extension_1_is_not_associated_with_a_language">
        <source>Cannot open project '{0}' because the file extension '{1}' is not associated with a language.</source>
        <target state="translated">Nejde otevřít projekt {0}, protože přípona souboru {1} není přidružená k jazyku.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_open_project_0_because_the_language_1_is_not_supported">
        <source>Cannot open project '{0}' because the language '{1}' is not supported.</source>
        <target state="translated">Nejde otevřít projekt {0}, protože jazyk {1} se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_file_path_colon_0">
        <source>Invalid project file path: '{0}'</source>
        <target state="translated">Neplatná cesta k souboru projektu: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_solution_file_path_colon_0">
        <source>Invalid solution file path: '{0}'</source>
        <target state="translated">Neplatná cesta k souboru řešení: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Project_file_not_found_colon_0">
        <source>Project file not found: '{0}'</source>
        <target state="translated">Nenalezený soubor projektu: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Solution_file_not_found_colon_0">
        <source>Solution file not found: '{0}'</source>
        <target state="translated">Nenalezený soubor řešení: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Unmerged_change_from_project_0">
        <source>Unmerged change from project '{0}'</source>
        <target state="translated">Nesloučené změny z projektu '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Added_colon">
        <source>Added:</source>
        <target state="translated">Přidáno:</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_0">
        <source>Fix all '{0}'</source>
        <target state="translated">Opravit vše ({0})</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_0_in_1">
        <source>Fix all '{0}' in '{1}'</source>
        <target state="translated">Opravit vše ({0}) v: {1}</target>
        <note />
      </trans-unit>
      <trans-unit id="Fix_all_0_in_Solution">
        <source>Fix all '{0}' in Solution</source>
        <target state="translated">Opravit vše ({0}) v řešení</target>
        <note />
      </trans-unit>
      <trans-unit id="After_colon">
        <source>After:</source>
        <target state="translated">Po:</target>
        <note />
      </trans-unit>
      <trans-unit id="Before_colon">
        <source>Before:</source>
        <target state="translated">Před:</target>
        <note />
      </trans-unit>
      <trans-unit id="Removed_colon">
        <source>Removed:</source>
        <target state="translated">Odebráno:</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_CodePage_value_colon_0">
        <source>Invalid CodePage value: {0}</source>
        <target state="translated">Neplatná hodnota CodePage: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_additional_documents_is_not_supported">
        <source>Adding additional documents is not supported.</source>
        <target state="translated">Přidávání dalších dokumentů se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_analyzer_references_is_not_supported">
        <source>Adding analyzer references is not supported.</source>
        <target state="translated">Přidávání odkazů na analyzátory se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_documents_is_not_supported">
        <source>Adding documents is not supported.</source>
        <target state="translated">Přidávání dokumentů se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_metadata_references_is_not_supported">
        <source>Adding metadata references is not supported.</source>
        <target state="translated">Přidávání odkazů na metadata se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_project_references_is_not_supported">
        <source>Adding project references is not supported.</source>
        <target state="translated">Přidávání odkazů na projekty se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_additional_documents_is_not_supported">
        <source>Changing additional documents is not supported.</source>
        <target state="translated">Změna dalších dokumentů se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_documents_is_not_supported">
        <source>Changing documents is not supported.</source>
        <target state="translated">Změna dokumentů se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_project_properties_is_not_supported">
        <source>Changing project properties is not supported.</source>
        <target state="translated">Změna vlastností projektu se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_additional_documents_is_not_supported">
        <source>Removing additional documents is not supported.</source>
        <target state="translated">Odebírání dalších dokumentů se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_analyzer_references_is_not_supported">
        <source>Removing analyzer references is not supported.</source>
        <target state="translated">Odebírání odkazů na analyzátory se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_documents_is_not_supported">
        <source>Removing documents is not supported.</source>
        <target state="translated">Odebírání dokumentů se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_metadata_references_is_not_supported">
        <source>Removing metadata references is not supported.</source>
        <target state="translated">Odebírání odkazů na metadata se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_project_references_is_not_supported">
        <source>Removing project references is not supported.</source>
        <target state="translated">Odebírání odkazů na projekty se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Service_of_type_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_workspace">
        <source>Service of type '{0}' is required to accomplish the task but is not available from the workspace.</source>
        <target state="translated">Ke splnění úkolu se vyžaduje služba typu {0}, není ale z pracovního prostoru dostupná.</target>
        <note />
      </trans-unit>
      <trans-unit id="Supplied_diagnostic_cannot_be_null">
        <source>Supplied diagnostic cannot be null.</source>
        <target state="translated">Zadaná diagnostika nemůže být null.</target>
        <note />
      </trans-unit>
      <trans-unit id="At_least_one_diagnostic_must_be_supplied">
        <source>At least one diagnostic must be supplied.</source>
        <target state="translated">Musí se zadat aspoň jedna diagnostika.</target>
        <note />
      </trans-unit>
      <trans-unit id="Diagnostic_must_have_span_0">
        <source>Diagnostic must have span '{0}'</source>
        <target state="translated">Diagnostika musí mít rozpětí {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_deserialize_type_0">
        <source>Cannot deserialize type '{0}'.</source>
        <target state="translated">Typ {0} nejde deserializovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_serialize_type_0">
        <source>Cannot serialize type '{0}'.</source>
        <target state="translated">Typ {0} nejde serializovat.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_type_0_is_not_understood_by_the_serialization_binder">
        <source>The type '{0}' is not understood by the serialization binder.</source>
        <target state="translated">Vazač serializace nerozumí typu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Label_for_node_0_is_invalid_it_must_be_within_bracket_0_1">
        <source>Label for node '{0}' is invalid, it must be within [0, {1}).</source>
        <target state="translated">Popisek uzlu {0} je neplatný. Musí být uzavřený v syntaxi [0, {1}).</target>
        <note />
      </trans-unit>
      <trans-unit id="Matching_nodes_0_and_1_must_have_the_same_label">
        <source>Matching nodes '{0}' and '{1}' must have the same label.</source>
        <target state="translated">Odpovídající uzly {0} a {1} musí mít stejný popisek.</target>
        <note />
      </trans-unit>
      <trans-unit id="Node_0_must_be_contained_in_the_new_tree">
        <source>Node '{0}' must be contained in the new tree.</source>
        <target state="translated">Uzel {0} se musí umístit do nového stromu.</target>
        <note />
      </trans-unit>
      <trans-unit id="Node_0_must_be_contained_in_the_old_tree">
        <source>Node '{0}' must be contained in the old tree.</source>
        <target state="translated">Uzel {0} se musí umístit do starého stromu.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_member_0_is_not_declared_within_the_declaration_of_the_symbol">
        <source>The member '{0}' is not declared within the declaration of the symbol.</source>
        <target state="translated">Člen {0} se nedeklaruje při deklaraci symbolu.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_position_is_not_within_the_symbol_s_declaration">
        <source>The position is not within the symbol's declaration</source>
        <target state="translated">Pozice není v deklaraci symbolu.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_symbol_0_cannot_be_located_within_the_current_solution">
        <source>The symbol '{0}' cannot be located within the current solution.</source>
        <target state="translated">Symbol {0} se nemůže nacházet v aktuálním řešení.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_compilation_options_is_not_supported">
        <source>Changing compilation options is not supported.</source>
        <target state="translated">Změna možností kompilace se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_parse_options_is_not_supported">
        <source>Changing parse options is not supported.</source>
        <target state="translated">Změna možností analýzy se nepodporuje.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_node_is_not_part_of_the_tree">
        <source>The node is not part of the tree.</source>
        <target state="translated">Uzel není součástí stromu.</target>
        <note />
      </trans-unit>
      <trans-unit id="This_workspace_does_not_support_opening_and_closing_documents">
        <source>This workspace does not support opening and closing documents.</source>
        <target state="translated">Tento pracovní prostor nepodporuje otevírání a zavírání dokumentů.</target>
        <note />
      </trans-unit>
      <trans-unit id="Usage_colon">
        <source>Usage:</source>
        <target state="translated">Použití:</target>
        <note />
      </trans-unit>
      <trans-unit id="Exceptions_colon">
        <source>Exceptions:</source>
        <target state="translated">Výjimky:</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_returned_an_uninitialized_ImmutableArray">
        <source>'{0}' returned an uninitialized ImmutableArray</source>
        <target state="translated">'{0} vrací neinicializované ImmutableArray.</target>
        <note />
      </trans-unit>
      <trans-unit id="Failure">
        <source>Failure</source>
        <target state="translated">Selhání</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning">
        <source>Warning</source>
        <target state="translated">Upozornění</target>
        <note />
      </trans-unit>
      <trans-unit id="Populate_switch">
        <source>Populate switch</source>
        <target state="translated">Naplnit přepínač</target>
        <note />
      </trans-unit>
      <trans-unit id="Member_access_should_be_qualified">
        <source>Member access should be qualified.</source>
        <target state="translated">Přístup členů by měl být kvalifikovaný.</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_braces_to_0_statement">
        <source>Add braces to '{0}' statement.</source>
        <target state="translated">Přidat složené závorky do příkazu {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Options_did_not_come_from_Workspace">
        <source>Options did not come from Workspace</source>
        <target state="translated">Možnosti nepocházely z pracovního prostoru.</target>
        <note />
      </trans-unit>
      <trans-unit id="Enable">
        <source>Enable</source>
        <target state="translated">Povolit</target>
        <note />
      </trans-unit>
      <trans-unit id="Enable_and_ignore_future_errors">
        <source>Enable and ignore future errors</source>
        <target state="translated">Povolit a ignorovat budoucí chyby</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_encountered_an_error_and_has_been_disabled">
        <source>'{0}' encountered an error and has been disabled.</source>
        <target state="translated">'U analyzátoru {0} došlo k chybě a byl zakázán.</target>
        <note />
      </trans-unit>
      <trans-unit id="Show_Stack_Trace">
        <source>Show Stack Trace</source>
        <target state="translated">Zobrazit trasování zásobníku</target>
        <note />
      </trans-unit>
      <trans-unit id="Stream_is_too_long">
        <source>Stream is too long.</source>
        <target state="translated">Stream je moc dlouhý.</target>
        <note />
      </trans-unit>
      <trans-unit id="Deserialization_reader_for_0_read_incorrect_number_of_values">
        <source>Deserialization reader for '{0}' read incorrect number of values.</source>
        <target state="translated">Čtečka deserializace pro {0} přečetla nesprávný počet hodnot.</target>
        <note />
      </trans-unit>
      <trans-unit id="Pascal_Case">
        <source>Pascal Case</source>
        <target state="translated">PascalCase</target>
        <note />
      </trans-unit>
      <trans-unit id="Abstract_Method">
        <source>Abstract Method</source>
        <target state="translated">Abstraktní metoda</target>
        <note>{locked: abstract}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Async_Method">
        <source>Async Method</source>
        <target state="translated">Asynchronní metoda</target>
        <note>{locked: async}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Begins_with_I">
        <source>Begins with I</source>
        <target state="translated">Začíná na I</target>
        <note>{locked:I}</note>
      </trans-unit>
      <trans-unit id="Class">
        <source>Class</source>
        <target state="new">Class</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Delegate">
        <source>Delegate</source>
        <target state="new">Delegate</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Enum">
        <source>Enum</source>
        <target state="new">Enum</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Event">
        <source>Event</source>
        <target state="new">Event</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Interface">
        <source>Interface</source>
        <target state="new">Interface</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Non_Field_Members">
        <source>Non-Field Members</source>
        <target state="translated">Členové bez pole</target>
        <note>{locked:field}</note>
      </trans-unit>
      <trans-unit id="Private_Method">
        <source>Private Method</source>
        <target state="translated">Privátní metoda</target>
        <note>{locked: private}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Private_or_Internal_Field">
        <source>Private or Internal Field</source>
        <target state="translated">Privátní nebo interní pole</target>
        <note>{locked: private}{locked: internal}{locked:field}</note>
      </trans-unit>
      <trans-unit id="Private_or_Internal_Static_Field">
        <source>Private or Internal Static Field</source>
        <target state="translated">Privátní nebo interní statické pole</target>
        <note>{locked: private}{locked: internal}{locked:static}{locked:field}</note>
      </trans-unit>
      <trans-unit id="Property">
        <source>Property</source>
        <target state="new">Property</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Public_or_Protected_Field">
        <source>Public or Protected Field</source>
        <target state="translated">Veřejné nebo chráněné pole</target>
        <note>{locked: public}{locked: protected}{locked:field}</note>
      </trans-unit>
      <trans-unit id="Static_Field">
        <source>Static Field</source>
        <target state="translated">Statické pole</target>
        <note>{locked:static}{locked:field} (unless the capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Static_Method">
        <source>Static Method</source>
        <target state="translated">Statická metoda</target>
        <note>{locked: static}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Struct">
        <source>Struct</source>
        <target state="new">Struct</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Types">
        <source>Types</source>
        <target state="translated">Typy</target>
        <note>{locked:types} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Method">
        <source>Method</source>
        <target state="translated">metoda</target>
        <note>{locked:method} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Missing_prefix_colon_0">
        <source>Missing prefix: '{0}'</source>
        <target state="translated">Chybějící předpona: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Error">
        <source>Error</source>
        <target state="translated">Chyba</target>
        <note />
      </trans-unit>
      <trans-unit id="None">
        <source>None</source>
        <target state="translated">žádné</target>
        <note />
      </trans-unit>
      <trans-unit id="Missing_suffix_colon_0">
        <source>Missing suffix: '{0}'</source>
        <target state="translated">Chybějící přípona: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0">
        <source>These non-leading words must begin with an upper case letter: {0}</source>
        <target state="translated">Tato neúvodní slova musí začínat velkým písmenem: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Suggestion">
        <source>Suggestion</source>
        <target state="translated">Návrh</target>
        <note />
      </trans-unit>
      <trans-unit id="These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0">
        <source>These non-leading words must begin with a lowercase letter: {0}</source>
        <target state="translated">Tato neúvodní slova musí začínat malým písmenem: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="These_words_cannot_contain_lower_case_characters_colon_0">
        <source>These words cannot contain lower case characters: {0}</source>
        <target state="translated">Tato slova nemohou obsahovat malá písmena: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="These_words_cannot_contain_upper_case_characters_colon_0">
        <source>These words cannot contain upper case characters: {0}</source>
        <target state="translated">Tato slova nemohou obsahovat velká písmena: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="These_words_must_begin_with_upper_case_characters_colon_0">
        <source>These words must begin with upper case characters: {0}</source>
        <target state="translated">Tato slova musí začínat velkými písmeny: {0}.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_first_word_0_must_begin_with_an_upper_case_character">
        <source>The first word, '{0}', must begin with an upper case character</source>
        <target state="translated">První slovo ({0}) musí začínat velkým písmenem.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_first_word_0_must_begin_with_a_lower_case_character">
        <source>The first word, '{0}', must begin with a lower case character</source>
        <target state="translated">První slovo ({0}) musí začínat malým písmenem.</target>
        <note />
      </trans-unit>
      <trans-unit id="File_0_size_of_1_exceeds_maximum_allowed_size_of_2">
        <source>File '{0}' size of {1} exceeds maximum allowed size of {2}</source>
        <target state="translated">Soubor {0} s velikostí {1} překračuje maximální povolenou velikost: {2}.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_document_property_is_not_supported">
        <source>Changing document properties is not supported</source>
        <target state="translated">Změna vlastností dokumentu není podporovaná.</target>
        <note />
      </trans-unit>
      <trans-unit id="Alternation_conditions_cannot_be_comments">
        <source>Alternation conditions cannot be comments</source>
        <target state="translated">Podmínky alternativního výrazu nemůžou být komentáře.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a|(?#b)</note>
      </trans-unit>
      <trans-unit id="Alternation_conditions_do_not_capture_and_cannot_be_named">
        <source>Alternation conditions do not capture and cannot be named</source>
        <target state="translated">Podmínky alternativního výrazu nezachytávají a nejde je pojmenovat.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(?'x'))</note>
      </trans-unit>
      <trans-unit id="A_subtraction_must_be_the_last_element_in_a_character_class">
        <source>A subtraction must be the last element in a character class</source>
        <target state="translated">Odčítání musí být posledním prvkem ve třídě znaků.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-[b]-c]</note>
      </trans-unit>
      <trans-unit id="Cannot_include_class_0_in_character_range">
        <source>Cannot include class \{0} in character range</source>
        <target state="translated">Do rozsahu znaků nejde zahrnout třídu \{0}.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-\w]. {0} is the invalid class (\w here)</note>
      </trans-unit>
      <trans-unit id="Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue">
        <source>Capture group numbers must be less than or equal to Int32.MaxValue</source>
        <target state="translated">Čísla skupin digitalizace musí být menší nebo rovny hodnotě Int32.MaxValue</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{2147483648}</note>
      </trans-unit>
      <trans-unit id="Capture_number_cannot_be_zero">
        <source>Capture number cannot be zero</source>
        <target state="translated">Počet zachytávání nemůže být nulový</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;0&gt;a)</note>
      </trans-unit>
      <trans-unit id="Illegal_backslash_at_end_of_pattern">
        <source>Illegal \ at end of pattern</source>
        <target state="translated">Znak \ na konci vzorku je neplatný.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \</note>
      </trans-unit>
      <trans-unit id="Illegal_x_y_with_x_less_than_y">
        <source>Illegal {x,y} with x &gt; y</source>
        <target state="translated">Neplatné {x,y} s x &gt; y</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{1,0}</note>
      </trans-unit>
      <trans-unit id="Incomplete_character_escape">
        <source>Incomplete \p{X} character escape</source>
        <target state="translated">Neúplné uvození znaků \p{X}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{ Cc }</note>
      </trans-unit>
      <trans-unit id="Insufficient_hexadecimal_digits">
        <source>Insufficient hexadecimal digits</source>
        <target state="translated">Nedostatek šestnáctkových číslic</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \x</note>
      </trans-unit>
      <trans-unit id="Invalid_group_name_Group_names_must_begin_with_a_word_character">
        <source>Invalid group name: Group names must begin with a word character</source>
        <target state="translated">Neplatný název skupiny: Názvy skupin musí začínat znakem slova.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;a &gt;a)</note>
      </trans-unit>
      <trans-unit id="Malformed">
        <source>malformed</source>
        <target state="translated">chybný formát</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0</note>
      </trans-unit>
      <trans-unit id="Malformed_character_escape">
        <source>Malformed \p{X} character escape</source>
        <target state="translated">Chybně formátovaná řídicí sekvence znaků \p{X}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p {Cc}</note>
      </trans-unit>
      <trans-unit id="Malformed_named_back_reference">
        <source>Malformed \k&lt;...&gt; named back reference</source>
        <target state="translated">Chybně naformátovaný pojmenovaný zpětný odkaz \k&lt;...&gt;</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k'</note>
      </trans-unit>
      <trans-unit id="Missing_control_character">
        <source>Missing control character</source>
        <target state="translated">Chybí řídicí znak</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \c</note>
      </trans-unit>
      <trans-unit id="Nested_quantifier_0">
        <source>Nested quantifier {0}</source>
        <target state="translated">Vnořený kvantifikátor {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a**. In this case {0} will be '*', the extra unnecessary quantifier.</note>
      </trans-unit>
      <trans-unit id="Not_enough_close_parens">
        <source>Not enough )'s</source>
        <target state="translated">Nedostatek znaků )</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (a</note>
      </trans-unit>
      <trans-unit id="Quantifier_x_y_following_nothing">
        <source>Quantifier {x,y} following nothing</source>
        <target state="translated">Před kvantifikátorem {x,y} není nic uvedeno.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: *</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group">
        <source>reference to undefined group</source>
        <target state="translated">odkaz na nedefinovanou skupinu</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(1))</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_name_0">
        <source>Reference to undefined group name {0}</source>
        <target state="translated">Odkaz na nedefinovaný název skupiny {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k&lt;a&gt;. Here, {0} will be the name of the undefined group ('a')</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_number_0">
        <source>Reference to undefined group number {0}</source>
        <target state="translated">Odkaz na nedefinované číslo skupiny {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;-1&gt;). Here, {0} will be the number of the undefined group ('1')</note>
      </trans-unit>
      <trans-unit id="Too_many_bars_in_conditional_grouping">
        <source>Too many | in (?()|)</source>
        <target state="translated">Příliš mnoho znaků | ve výrazu (?()|)</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0)a|b|)</note>
      </trans-unit>
      <trans-unit id="Too_many_close_parens">
        <source>Too many )'s</source>
        <target state="translated">Příliš mnoho znaků )</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: )</note>
      </trans-unit>
      <trans-unit id="Unknown_property">
        <source>Unknown property</source>
        <target state="translated">Neznámá vlastnost</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{}</note>
      </trans-unit>
      <trans-unit id="Unknown_property_0">
        <source>Unknown property '{0}'</source>
        <target state="translated">Neznámá vlastnost {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{xxx}. Here, {0} will be the name of the unknown property ('xxx')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_control_character">
        <source>Unrecognized control character</source>
        <target state="translated">Nerozpoznaný řídicí znak</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [\c]</note>
      </trans-unit>
      <trans-unit id="Unrecognized_escape_sequence_0">
        <source>Unrecognized escape sequence \{0}</source>
        <target state="translated">Nerozpoznaná řídicí sekvence \{0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \m. Here, {0} will be the unrecognized character ('m')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_grouping_construct">
        <source>Unrecognized grouping construct</source>
        <target state="translated">Nerozpoznaný seskupovací konstrukt</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;</note>
      </trans-unit>
      <trans-unit id="Unterminated_character_class_set">
        <source>Unterminated [] set</source>
        <target state="translated">Nedokončená sada []</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [</note>
      </trans-unit>
      <trans-unit id="Unterminated_regex_comment">
        <source>Unterminated (?#...) comment</source>
        <target state="translated">Neukončený komentář (?#...)</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?#</note>
      </trans-unit>
      <trans-unit id="dot_NET_Coding_Conventions">
        <source>.NET Coding Conventions</source>
        <target state="translated">Konvence kódování v .NET</target>
        <note />
      </trans-unit>
      <trans-unit id="this_dot_and_Me_dot_preferences">
        <source>this. and Me. preferences</source>
        <target state="translated">Předvolby pro this. a Me.</target>
        <note />
      </trans-unit>
      <trans-unit id="x_y_range_in_reverse_order">
        <source>[x-y] range in reverse order</source>
        <target state="translated">Rozsah [x-y] je v obráceném pořadí.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [b-a]</note>
      </trans-unit>
      <trans-unit id="Variables_captured_colon">
        <source>Variables captured:</source>
        <target state="translated">Zachycené proměnné:</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_issue_0">
        <source>Regex issue: {0}</source>
        <target state="translated">Problém s regulárním výrazem: {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. {0} will be the actual text of one of the above Regular Expression errors.</note>
      </trans-unit>
      <trans-unit id="Parameter_preferences">
        <source>Parameter preferences</source>
        <target state="translated">Předvolby parametrů</target>
        <note />
      </trans-unit>
    </body>
  </file>
</xliff>