<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="ko" original="../WorkspacesResources.resx">
    <body>
      <trans-unit id="Adding_analyzer_config_documents_is_not_supported">
        <source>Adding analyzer config documents is not supported.</source>
        <target state="translated">분석기 구성 문서 추가는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="An_error_occurred_while_reading_the_specified_configuration_file_colon_0">
        <source>An error occurred while reading the specified configuration file: {0}</source>
        <target state="translated">지정한 구성 파일을 읽는 동안 오류가 발생했습니다({0}).</target>
        <note />
      </trans-unit>
      <trans-unit id="CSharp_files">
        <source>C# files</source>
        <target state="translated">C# 파일</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_analyzer_config_documents_is_not_supported">
        <source>Changing analyzer config documents is not supported.</source>
        <target state="translated">분석기 구성 문서 변경은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_document_0_is_not_supported">
        <source>Changing document '{0}' is not supported.</source>
        <target state="translated">'{0}' 문서 변경은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Core_EditorConfig_Options">
        <source>Core EditorConfig Options</source>
        <target state="translated">코어 EditorConfig 옵션</target>
        <note />
      </trans-unit>
      <trans-unit id="DateTimeKind_must_be_Utc">
        <source>DateTimeKind must be Utc</source>
        <target state="translated">DateTimeKind는 UTC여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_1_2_or_3_but_given_one_is_4">
        <source>Destination type must be a {0}, {1}, {2} or {3}, but given one is {4}.</source>
        <target state="translated">대상 형식은 {0}, {1}, {2} 또는 {3}이어야 하지만 지정된 대상 형식은 {4}입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Document_does_not_support_syntax_trees">
        <source>Document does not support syntax trees</source>
        <target state="translated">문서가 구문 트리를 지원하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="Error_reading_content_of_source_file_0_1">
        <source>Error reading content of source file '{0}' -- '{1}'.</source>
        <target state="translated">소스 파일 '{0}'의 콘텐츠를 읽는 동안 오류가 발생했습니다. -- '{1}'.</target>
        <note />
      </trans-unit>
      <trans-unit id="Indentation_and_spacing">
        <source>Indentation and spacing</source>
        <target state="translated">들여쓰기 및 간격</target>
        <note />
      </trans-unit>
      <trans-unit id="Naming_rules">
        <source>Naming rules</source>
        <target state="translated">명명 규칙</target>
        <note />
      </trans-unit>
      <trans-unit id="Naming_styles">
        <source>Naming styles</source>
        <target state="translated">명명 스타일</target>
        <note />
      </trans-unit>
      <trans-unit id="New_line_preferences">
        <source>New line preferences</source>
        <target state="translated">새 줄 기본 설정</target>
        <note />
      </trans-unit>
      <trans-unit id="Options_did_not_come_from_specified_Solution">
        <source>Options did not come from specified Solution</source>
        <target state="translated">옵션을 지정된 솔루션에서 가져오지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="Prefix_0_does_not_match_expected_prefix_1">
        <source>Prefix '{0}' does not match expected prefix '{1}'</source>
        <target state="translated">접두사 '{0}'이(가) 필요한 접두사 '{1}'과(와) 일치하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Prefix_0_is_not_expected">
        <source>Prefix '{0}' is not expected</source>
        <target state="translated">접두사 '{0}'은(는) 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Refactoring_Only">
        <source>Refactoring Only</source>
        <target state="translated">리팩터링만</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_long">
        <source>All control characters. This includes the Cc, Cf, Cs, Co, and Cn categories.</source>
        <target state="translated">모든 제어 문자입니다. Cc, Cf, Cs, Co 및 Cn 범주가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_control_characters_short">
        <source>all control characters</source>
        <target state="translated">모든 제어 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_long">
        <source>All diacritic marks. This includes the Mn, Mc, and Me categories.</source>
        <target state="translated">모든 분음 부호입니다. Mn, Mc 및 Me 범주가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_diacritic_marks_short">
        <source>all diacritic marks</source>
        <target state="translated">모든 분음 부호</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_long">
        <source>All letter characters. This includes the Lu, Ll, Lt, Lm, and Lo characters.</source>
        <target state="translated">모든 문자입니다. Lu, Ll, Lt, Lm 및 Lo 문자가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_letter_characters_short">
        <source>all letter characters</source>
        <target state="translated">모든 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_long">
        <source>All numbers. This includes the Nd, Nl, and No categories.</source>
        <target state="translated">모든 숫자입니다. Nd, Nl 및 No 범주가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_numbers_short">
        <source>all numbers</source>
        <target state="translated">모든 숫자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_long">
        <source>All punctuation characters. This includes the Pc, Pd, Ps, Pe, Pi, Pf, and Po categories.</source>
        <target state="translated">모든 문장 부호 문자입니다. Pc, Pd, Ps, Pe, Pi, Pf 및 Po 범주가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_punctuation_characters_short">
        <source>all punctuation characters</source>
        <target state="translated">모든 문장 부호 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_long">
        <source>All separator characters. This includes the Zs, Zl, and Zp categories.</source>
        <target state="translated">모든 구분 문자입니다. Zs, Zl 및 Zp 범주가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_separator_characters_short">
        <source>all separator characters</source>
        <target state="translated">모든 구분 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_long">
        <source>All symbols. This includes the Sm, Sc, Sk, and So categories.</source>
        <target state="translated">모든 기호입니다. Sm, Sc, Sk 및 So 범주가 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_all_symbols_short">
        <source>all symbols</source>
        <target state="translated">모든 기호</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_long">
        <source>You can use the vertical bar (|) character to match any one of a series of patterns, where the | character separates each pattern.</source>
        <target state="translated">세로 막대(|) 문자를 사용하여 일련의 패턴 중 하나를 일치시킬 수 있습니다. 여기서 | 문자는 각 패턴을 구분합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_alternation_short">
        <source>alternation</source>
        <target state="translated">대체</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_long">
        <source>The period character (.) matches any character except \n (the newline character, \u000A).  If a regular expression pattern is modified by the RegexOptions.Singleline option, or if the portion of the pattern that contains the . character class is modified by the 's' option, . matches any character.</source>
        <target state="translated">마침표(.) 문자는 \n(줄 바꿈 문자, \u000A)을 제외한 모든 문자와 일치시킵니다. 정규식 패턴이 RegexOptions.Singleline 옵션으로 수정되거나 . 문자 클래스가 포함된 패턴의 일부가 's' 옵션으로 수정된 경우 .는 모든 문자와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_any_character_group_short">
        <source>any character</source>
        <target state="translated">모든 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_long">
        <source>Matches a backspace character, \u0008</source>
        <target state="translated">백스페이스 문자 \u0008과 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_backspace_character_short">
        <source>backspace character</source>
        <target state="translated">백스페이스 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_long">
        <source>A balancing group definition deletes the definition of a previously defined group and stores, in the current group, the interval between the previously defined group and the current group.
    
'name1' is the current group (optional), 'name2' is a previously defined group, and 'subexpression' is any valid regular expression pattern. The balancing group definition deletes the definition of name2 and stores the interval between name2 and name1 in name1. If no name2 group is defined, the match backtracks. Because deleting the last definition of name2 reveals the previous definition of name2, this construct lets you use the stack of captures for group name2 as a counter for keeping track of nested constructs such as parentheses or opening and closing brackets.

The balancing group definition uses 'name2' as a stack. The beginning character of each nested construct is placed in the group and in its Group.Captures collection. When the closing character is matched, its corresponding opening character is removed from the group, and the Captures collection is decreased by one. After the opening and closing characters of all nested constructs have been matched, 'name1' is empty.</source>
        <target state="translated">균형 조정 그룹 정의는 이전에 정의된 그룹의 정의를 삭제하고, 이전에 정의된 그룹과 현재 그룹 사이의 간격을 현재 그룹에 저장합니다.
    
'name1'은 현재 그룹이고(선택 사항), 'name2'는 이전에 정의된 그룹이며, 'subexpression'은 유효한 정규식 패턴입니다. 균형 조정 그룹 정의는 name2의 정의를 삭제하고 name2와 name1 사이의 간격을 name1에 저장합니다. name2 그룹이 정의되어 있지 않으면 일치에서 역추적합니다. name2의 마지막 정의를 삭제하면 name2의 이전 정의가 표시되므로 이 구문을 통해 name2 그룹에 대한 캡처 스택을 괄호 또는 여는 대괄호 및 닫는 대괄호와 같은 중첩 구문을 추적하기 위한 카운터로 사용할 수 있습니다.

균형 조정 그룹 정의에서는 'name2'를 스택으로 사용합니다. 각 중첩 구문의 시작 문자는 그룹 및 해당 Group.Captures 컬렉션에 배치됩니다. 닫는 문자가 일치되면 해당하는 여는 문자가 그룹에서 제거되고 Captures 컬렉션이 하나 감소합니다. 모든 중첩 구문의 여는 문자와 닫는 문자가 일치되고 나면 'name1'은 비어 있는 상태가 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_balancing_group_short">
        <source>balancing group</source>
        <target state="translated">균형 조정 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_base_group">
        <source>base-group</source>
        <target state="translated">기본 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_long">
        <source>Matches a bell (alarm) character, \u0007</source>
        <target state="translated">벨(경보) 문자 \u0007과 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_bell_character_short">
        <source>bell character</source>
        <target state="translated">벨 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_long">
        <source>Matches a carriage-return character, \u000D.  Note that \r is not equivalent to the newline character, \n.</source>
        <target state="translated">캐리지 리턴 문자 \u000D와 일치시킵니다. \r은 줄 바꿈 문자 \n과 같지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_carriage_return_character_short">
        <source>carriage-return character</source>
        <target state="translated">캐리지 리턴 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_long">
        <source>Character class subtraction yields a set of characters that is the result of excluding the characters in one character class from another character class.

'base_group' is a positive or negative character group or range. The 'excluded_group' component is another positive or negative character group, or another character class subtraction expression (that is, you can nest character class subtraction expressions).</source>
        <target state="translated">문자 클래스 빼기를 사용하면 한 문자 클래스의 문자를 다른 문자 클래스에서 제외한 결과인 문자 집합을 얻게 됩니다.

'base_group'은 긍정 또는 부정 문자 그룹이거나 문자 범위입니다. 'excluded_group' 구성 요소는 다른 긍정 또는 부정 문자 그룹이거나 다른 문자 클래스 빼기 식입니다(즉, 문자 클래스 빼기 식을 중첩할 수 있음).</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_class_subtraction_short">
        <source>character class subtraction</source>
        <target state="translated">문자 클래스 빼기</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_character_group">
        <source>character-group</source>
        <target state="translated">문자 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_comment">
        <source>comment</source>
        <target state="translated">주석</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it can match an initial pattern.

'expression' is the initial pattern to match, 'yes' is the pattern to match if expression is matched, and 'no' is the optional pattern to match if expression is not matched.</source>
        <target state="translated">이 언어 요소는 초기 패턴과 일치시킬 수 있는지 여부에 따라 두 패턴 중 하나와 일치시키려고 시도합니다.

'expression'은 일치시킬 초기 패턴이며 'yes'는 식이 일치하는 경우 일치시킬 패턴이고 'no'는 식이 일치하지 않는 경우 일치시킬 선택적 패턴입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_expression_match_short">
        <source>conditional expression match</source>
        <target state="translated">조건식 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_long">
        <source>This language element attempts to match one of two patterns depending on whether it has matched a specified capturing group.

'name' is the name (or number) of a capturing group, 'yes' is the expression to match if 'name' (or 'number') has a match, and 'no' is the optional expression to match if it does not.</source>
        <target state="translated">이 언어 요소는 지정한 캡처링 그룹과 일치시켰는지 여부에 따라 두 패턴 중 하나와 일치시키려고 시도합니다.

'name'은 캡처링 그룹의 이름(또는 번호)이며 'yes'는 'name'(또는 'number')에 일치 항목이 있는 경우 일치시킬 식이고 'no'는 일치 항목이 없는 경우 일치시킬 선택적 식입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_conditional_group_match_short">
        <source>conditional group match</source>
        <target state="translated">조건 그룹 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_long">
        <source>The \G anchor specifies that a match must occur at the point where the previous match ended. When you use this anchor with the Regex.Matches or Match.NextMatch method, it ensures that all matches are contiguous.</source>
        <target state="translated">\G 앵커는 이전 일치 항목 찾기가 끝난 지점에서 일치 항목을 찾도록 지정합니다. 이 앵커를 Regex.Matches 또는 Match.NextMatch 메서드와 함께 사용하면 모든 일치 항목이 연속되도록 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_contiguous_matches_short">
        <source>contiguous matches</source>
        <target state="translated">연속 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_long">
        <source>Matches an ASCII control character, where X is the letter of the control character. For example, \cC is CTRL-C.</source>
        <target state="translated">ASCII 제어 문자와 일치시킵니다. 여기서, X는 제어 문자의 문자입니다. 예를 들어 \cC는 CTRL-C입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_control_character_short">
        <source>control character</source>
        <target state="translated">제어 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_long">
        <source>\d matches any decimal digit. It is equivalent to the \p{Nd} regular expression pattern, which includes the standard decimal digits 0-9 as well as the decimal digits of a number of other character sets.

If ECMAScript-compliant behavior is specified, \d is equivalent to [0-9]</source>
        <target state="translated">\d는 10진수와 일치시킵니다. 표준 10진수 0-9와 여러 다른 문자 집합의 10진수를 포함한 \p{Nd} 정규식 패턴과 같습니다.

ECMAScript 규격 동작을 지정한 경우 \d는 [0-9]와 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_decimal_digit_character_short">
        <source>decimal-digit character</source>
        <target state="translated">10진수 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_long">
        <source>A number sign (#) marks an x-mode comment, which starts at the unescaped # character at the end of the regular expression pattern and continues until the end of the line. To use this construct, you must either enable the x option (through inline options) or supply the RegexOptions.IgnorePatternWhitespace value to the option parameter when instantiating the Regex object or calling a static Regex method.</source>
        <target state="translated">숫자 기호(#)는 정규식 패턴의 끝에 있는 이스케이프되지 않은 # 문자에서 시작하고 줄의 끝까지 계속되는 x-모드 주석을 표시합니다. 이 구문을 사용하려면 인라인 옵션을 통해 x 옵션을 사용해야 합니다. 또는 Regex 개체를 인스턴스화하거나 정적 Regex 메서드를 호출할 때 RegexOptions.IgnorePatternWhitespace 값을 옵션 매개 변수에 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_line_comment_short">
        <source>end-of-line comment</source>
        <target state="translated">줄의 끝 주석</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_long">
        <source>The \z anchor specifies that a match must occur at the end of the input string. Like the $ language element, \z ignores the RegexOptions.Multiline option. Unlike the \Z language element, \z does not match a \n character at the end of a string. Therefore, it can only match the last line of the input string.</source>
        <target state="translated">\z 앵커는 입력 문자열의 끝부분에서 일치 항목을 찾도록 지정합니다. $ 언어 요소와 마찬가지로, \z는 RegexOptions.Multiline 옵션을 무시합니다. 하지만 \Z 언어 요소와 달리 \z는 문자열의 끝에 있는 \n 문자와 일치시키지 않습니다. 따라서 입력 문자열의 마지막 줄만 일치시킬 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_only_short">
        <source>end of string only</source>
        <target state="translated">문자열의 끝만</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_long">
        <source>The \Z anchor specifies that a match must occur at the end of the input string, or before \n at the end of the input string. It is identical to the $ anchor, except that \Z ignores the RegexOptions.Multiline option. Therefore, in a multiline string, it can only match the end of the last line, or the last line before \n.

The \Z anchor matches \n but does not match \r\n (the CR/LF character combination). To match CR/LF, include \r?\Z in the regular expression pattern.</source>
        <target state="translated">\Z 앵커는 입력 문자열의 끝부분이나 입력 문자열의 끝부분에 있는 \n 앞에서 일치 항목을 찾도록 지정합니다. \Z는 RegexOptions.Multiline 옵션을 무시한다는 점을 제외하고는 $ 앵커와 동일합니다. 따라서 여러 줄 문자열에서는 마지막 줄의 끝이나 \n 앞의 마지막 줄만 일치시킬 수 있습니다.

\Z 앵커는 \n은 일치시키지만 \r\n(CR/LF 문자 조합)은 일치시키지 않습니다. CR/LF와 일치시키려면 정규식 패턴에 \r?\Z를 포함하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_before_ending_newline_short">
        <source>end of string or before ending newline</source>
        <target state="translated">문자열의 끝 또는 줄 바꿈 종료 전</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_long">
        <source>The $ anchor specifies that the preceding pattern must occur at the end of the input string, or before \n at the end of the input string. If you use $ with the RegexOptions.Multiline option, the match can also occur at the end of a line.

The $ anchor matches \n but does not match \r\n (the combination of carriage return and newline characters, or CR/LF). To match the CR/LF character combination, include \r?$ in the regular expression pattern.</source>
        <target state="translated">$ 앵커는 입력 문자열의 끝부분이나 입력 문자열의 끝부분에 있는 \n 앞에 이전 패턴이 오도록 지정합니다. RegexOptions.Multiline 옵션과 함께 $를 사용하면 줄의 끝부분에서도 일치 항목을 찾을 수 있습니다.

$ 앵커는 \n은 일치시키지만 \r\n(캐리지 리턴 및 줄 바꿈 문자 조합 또는 CR/LF)은 일치시키지 않습니다. CR/LF 문자 조합과 일치시키려면 정규식 패턴에 \r?$를 포함하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_end_of_string_or_line_short">
        <source>end of string or line</source>
        <target state="translated">문자열 또는 줄의 끝</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_long">
        <source>Matches an escape character, \u001B</source>
        <target state="translated">이스케이프 문자 \u001B와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_escape_character_short">
        <source>escape character</source>
        <target state="translated">이스케이프 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_excluded_group">
        <source>excluded-group</source>
        <target state="translated">제외된 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_expression">
        <source>expression</source>
        <target state="translated">식</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_long">
        <source>Matches a form-feed character, \u000C</source>
        <target state="translated">용지 공급 문자 \u000C와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_form_feed_character_short">
        <source>form-feed character</source>
        <target state="translated">용지 공급 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_long">
        <source>This grouping construct applies or disables the specified options within a subexpression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly
	named or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">이 그룹화 생성자는 하위 식 내에서 지정된 옵션을 적용하거나 사용하지 않도록 설정합니다. 사용하도록 설정하는 옵션은 물음표 뒤에 지정되며 사용하지 않도록 설정하는 옵션은 빼기 기호 뒤에 지정됩니다. 허용되는 옵션은 다음과 같습니다.

    i	대/소문자를 구분하지 않는 일치를 사용합니다.
    m	여러 줄 모드를 사용합니다. 여기서, ^ 및 $는 각 줄의 시작 및 끝과 일치시킵니다(입력
	문자열의 시작 및 끝이 아님).
    s	한 줄 모드를 사용합니다. 여기서, 마침표(.)는 모든 문자(\n을 제외한
	모든 문자가 아님)와 일치시킵니다.
    n	명명되지 않은 그룹을 캡처하지 않습니다. 양식(?&lt;이름&gt; 하위 식)의 명시적으로 명명된 그룹
	또는 번호가 매겨진 그룹만 유효한 캡처입니다.
    x	이스케이프되지 않은 공백은 패턴에서 제외하고 주석은 숫자 기호(#) 다음에
	사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_group_options_short">
        <source>group options</source>
        <target state="translated">그룹 옵션</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_long">
        <source>Matches an ASCII character, where ## is a two-digit hexadecimal character code.</source>
        <target state="translated">ASCII 문자와 일치시킵니다. 여기서, ##은 두 자리 16진수 문자 코드입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_hexadecimal_escape_short">
        <source>hexadecimal escape</source>
        <target state="translated">16진수 이스케이프</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_long">
        <source>The (?# comment) construct lets you include an inline comment in a regular expression. The regular expression engine does not use any part of the comment in pattern matching, although the comment is included in the string that is returned by the Regex.ToString method. The comment ends at the first closing parenthesis.</source>
        <target state="translated">(?# comment) 구문에서는 정규식에 인라인 주석을 포함할 수 있습니다. Regex.ToString 메서드에서 반환된 문자열에 주석이 포함되어 있어도 정규식 엔진은 패턴 일치에 주석의 어떤 부분도 사용하지 않습니다. 주석은 첫 번째 닫는 괄호에서 종료됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_comment_short">
        <source>inline comment</source>
        <target state="translated">인라인 주석</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_long">
        <source>Enables or disables specific pattern matching options for the remainder of a regular expression. The options to enable are specified after the question mark, and the options to disable after the minus sign. The allowed options are:

    i	Use case-insensitive matching.
    m	Use multiline mode, where ^ and $ match the beginning and end of each line
	(instead of the beginning and end of the input string).
    s	Use single-line mode, where the period (.) matches every character
	(instead of every character except \n).
    n	Do not capture unnamed groups. The only valid captures are explicitly named
	or numbered groups of the form (?&lt;name&gt; subexpression).
    x	Exclude unescaped white space from the pattern, and enable comments
	after a number sign (#).</source>
        <target state="translated">정규식의 나머지 부분에 대해 특정 패턴 일치 옵션을 사용하거나 사용하지 않도록 설정합니다. 사용하도록 설정하는 옵션은 물음표 뒤에 지정되며 사용하지 않도록 설정하는 옵션은 빼기 기호 뒤에 지정됩니다. 허용되는 옵션은 다음과 같습니다.

    i	대/소문자를 구분하지 않는 일치를 사용합니다.
    m	여러 줄 모드를 사용합니다. 여기서, ^ 및 $는 각 줄의 시작 및 끝과 일치시킵니다(입력
	문자열의 시작 및 끝이 아님).
    s	한 줄 모드를 사용합니다. 여기서, 마침표(.)는 모든 문자(\n을 제외한
	모든 문자가 아님)와 일치시킵니다.
    n	명명되지 않은 그룹을 캡처하지 않습니다. 양식(?&lt;이름&gt; 하위 식)의 명시적으로 명명된 그룹
	또는 번호가 매겨진 그룹만 유효한 캡처입니다.
    x	이스케이프되지 않은 공백은 패턴에서 제외하고 주석은 숫자 기호(#) 다음에
	사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_inline_options_short">
        <source>inline options</source>
        <target state="translated">인라인 옵션</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_lowercase">
        <source>letter, lowercase</source>
        <target state="translated">문자, 소문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_modifier">
        <source>letter, modifier</source>
        <target state="translated">문자, 한정자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_other">
        <source>letter, other</source>
        <target state="translated">문자, 기타</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_titlecase">
        <source>letter, titlecase</source>
        <target state="translated">문자, 첫 글자만 대문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_letter_uppercase">
        <source>letter, uppercase</source>
        <target state="translated">문자, 대문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_enclosing">
        <source>mark, enclosing</source>
        <target state="translated">표시, 묶음</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_nonspacing">
        <source>mark, nonspacing</source>
        <target state="translated">표시, 공간을 차지하지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_mark_spacing_combining">
        <source>mark, spacing combining</source>
        <target state="translated">표시, 간격 결합</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_long">
        <source>The {n,}? quantifier matches the preceding element at least n times, where n is any integer, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,}</source>
        <target state="translated">{n,}? 수량자는 n번 이상 이전 요소와 일치시키지만 가능한 한 적은 횟수로 일치시킵니다. 여기서, n은 정수입니다. 탐욕적 수량자 {n,}에 대응되는 게으른 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">'n'번 이상 일치(지연)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_long">
        <source>The {n,} quantifier matches the preceding element at least n times, where n is any integer. {n,} is a greedy quantifier whose lazy equivalent is {n,}?</source>
        <target state="translated">{n,} 수량자는 n번 이상 이전 요소와 일치시킵니다. 여기서, n은 정수입니다. {n,}는 해당 게으른 수량자가 {n,}?인 탐욕적 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_at_least_n_times_short">
        <source>match at least 'n' times</source>
        <target state="translated">'n'번 이상 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_long">
        <source>The {n,m}? quantifier matches the preceding element between n and m times, where n and m are integers, but as few times as possible. It is the lazy counterpart of the greedy quantifier {n,m}</source>
        <target state="translated">{n,m}? 수량자는 n 및 m번 사이로 이전 요소와 일치시키지만 가능한 한 적은 횟수로 일치시킵니다. 여기서, n 및 m은 정수입니다. 탐욕적 수량자 {n,m}에 대응되는 게으른 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_lazy_short">
        <source>match at least 'n' times (lazy)</source>
        <target state="translated">'n'번 이상 일치(지연)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_long">
        <source>The {n,m} quantifier matches the preceding element at least n times, but no more than m times, where n and m are integers. {n,m} is a greedy quantifier whose lazy equivalent is {n,m}?</source>
        <target state="translated">{n,m} 수량자는 n번 이상 m번 이하로 이전 요소와 일치시킵니다. 여기서, n 및 m은 정수입니다. {n,m}는 해당 게으른 수량자가 {n,m}?인 탐욕적 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_between_m_and_n_times_short">
        <source>match between 'm' and 'n' times</source>
        <target state="translated">'m'에서 'n'번 사이 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_long">
        <source>The {n}? quantifier matches the preceding element exactly n times, where n is any integer. It is the lazy counterpart of the greedy quantifier {n}+</source>
        <target state="translated">{n}? 수량자는 정확히 n번을 이전 요소와 일치시킵니다. 여기서, n은 정수입니다. 탐욕적 수량자 {n}+에 대응되는 게으른 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_lazy_short">
        <source>match exactly 'n' times (lazy)</source>
        <target state="translated">정확하게 'n'번 일치(지연)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_long">
        <source>The {n} quantifier matches the preceding element exactly n times, where n is any integer. {n} is a greedy quantifier whose lazy equivalent is {n}?</source>
        <target state="translated">{n} 수량자는 정확히 n번을 이전 요소와 일치시킵니다. 여기서, n은 정수입니다. {n}는 해당 게으른 수량자가 {n}?인 탐욕적 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_exactly_n_times_short">
        <source>match exactly 'n' times</source>
        <target state="translated">정확하게 'n'번 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_long">
        <source>The +? quantifier matches the preceding element one or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier +</source>
        <target state="translated">+? 수량자는 1번 이상 이전 요소와 일치시키지만 가능한 한 적은 횟수로 일치시킵니다. 탐욕적 수량자 +에 대응되는 게으른 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_lazy_short">
        <source>match one or more times (lazy)</source>
        <target state="translated">1번 이상 일치(지연)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_long">
        <source>The + quantifier matches the preceding element one or more times. It is equivalent to the {1,} quantifier. + is a greedy quantifier whose lazy equivalent is +?.</source>
        <target state="translated">+ 수량자는 1번 이상 이전 요소와 일치시킵니다. {1,} 수량자와 같습니다. +는 해당 게으른 수량자가 +?인 탐욕적 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_one_or_more_times_short">
        <source>match one or more times</source>
        <target state="translated">1번 이상 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_long">
        <source>The *? quantifier matches the preceding element zero or more times, but as few times as possible. It is the lazy counterpart of the greedy quantifier *</source>
        <target state="translated">*? 수량자는 0번 이상 이전 요소와 일치시키지만 가능한 한 적은 횟수로 일치시킵니다. 탐욕적 수량자 *에 대응되는 게으른 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_lazy_short">
        <source>match zero or more times (lazy)</source>
        <target state="translated">0번 이상 일치(지연)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_long">
        <source>The * quantifier matches the preceding element zero or more times. It is equivalent to the {0,} quantifier. * is a greedy quantifier whose lazy equivalent is *?.</source>
        <target state="translated">* 수량자는 0번 이상 이전 요소와 일치시킵니다. {0,} 수량자와 같습니다. *는 해당 게으른 수량자가 *?인 탐욕적 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_more_times_short">
        <source>match zero or more times</source>
        <target state="translated">0번 이상 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_long">
        <source>The ?? quantifier matches the preceding element zero or one time, but as few times as possible. It is the lazy counterpart of the greedy quantifier ?</source>
        <target state="translated">?? 수량자는 0번 이상 이전 요소와 일치시키지만 가능한 한 적은 횟수로 일치시킵니다. 탐욕적 수량자 ?에 대응되는 게으른 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_lazy_short">
        <source>match zero or one time (lazy)</source>
        <target state="translated">0 또는 1번 일치(지연)</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_long">
        <source>The ? quantifier matches the preceding element zero or one time. It is equivalent to the {0,1} quantifier. ? is a greedy quantifier whose lazy equivalent is ??.</source>
        <target state="translated">? 수량자는 0번 이상 이전 요소와 일치시킵니다. {0,1} 수량자와 같습니다. ?는 해당 게으른 수량자가 ??인 탐욕적 수량자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_match_zero_or_one_time_short">
        <source>match zero or one time</source>
        <target state="translated">0 또는 1번 일치</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_long">
        <source>This grouping construct captures a matched 'subexpression', where 'subexpression' is any valid regular expression pattern. Captures that use parentheses are numbered automatically from left to right based on the order of the opening parentheses in the regular expression, starting from one. The capture that is numbered zero is the text matched by the entire regular expression pattern.</source>
        <target state="translated">이 그룹화 생성자는 일치하는 'subexpression'을 캡처합니다. 여기서, 'subexpression'은 임의의 유효한 정규식 패턴입니다. 괄호를 사용하는 캡처는 정규식의 여는 괄호 순서를 기준으로 왼쪽에서 오른쪽으로 1부터 자동으로 번호가 매겨집니다. 0으로 번호가 매겨진 캡처는 전체 정규식 패턴과 일치하는 텍스트입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_matched_subexpression_short">
        <source>matched subexpression</source>
        <target state="translated">일치하는 하위 식</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name">
        <source>name</source>
        <target state="translated">이름</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name1">
        <source>name1</source>
        <target state="translated">name1</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name2">
        <source>name2</source>
        <target state="translated">name2</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_name_or_number">
        <source>name-or-number</source>
        <target state="translated">이름 또는 번호</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_long">
        <source>A named or numbered backreference.

'name' is the name of a capturing group defined in the regular expression pattern.</source>
        <target state="translated">명명되거나 번호가 매겨진 역참조입니다.

'name'은 정규식 패턴에 정의된 캡처링 그룹의 이름입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_backreference_short">
        <source>named backreference</source>
        <target state="translated">명명된 역참조</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_long">
        <source>Captures a matched subexpression and lets you access it by name or by number.

'name' is a valid group name, and 'subexpression' is any valid regular expression pattern. 'name' must not contain any punctuation characters and cannot begin with a number.

If the RegexOptions parameter of a regular expression pattern matching method includes the RegexOptions.ExplicitCapture flag, or if the n option is applied to this subexpression, the only way to capture a subexpression is to explicitly name capturing groups.</source>
        <target state="translated">일치하는 하위 식을 캡처하고 이름 또는 번호를 통해 해당 하위 식에 액세스할 수 있도록 허용합니다.

'name'은 유효한 그룹 이름이고 'subexpression'은 유효한 정규식 패턴입니다. 'name'은 문장 부호 문자를 사용하지 않아야 하며 숫자로 시작할 수 없습니다.

정규식 패턴 일치 메서드의 RegexOptions 매개 변수에 RegexOptions.ExplicitCapture 플래그가 포함되어 있거나 이 하위 식에 n 옵션이 적용되는 경우 하위 식을 캡처하는 유일한 방법은 명시적으로 캡처링 그룹 이름을 지정하는 것입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_named_matched_subexpression_short">
        <source>named matched subexpression</source>
        <target state="translated">명명된 일치하는 하위 식</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_long">
        <source>A negative character group specifies a list of characters that must not appear in an input string for a match to occur. The list of characters are specified individually.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">부정 문자 그룹은 일치 항목을 찾을 입력 문자열에 표시되지 않아야 하는 문자 목록을 지정합니다. 문자 목록은 개별적으로 지정됩니다.

둘 이상의 문자 범위를 연결할 수 있습니다. 예를 들어 "0"에서 "9"까지의 10진수 범위, "a"에서 "f"까지의 소문자 범위 및 "A"에서 "F"까지의 대문자 범위를 지정하려면 [0-9a-fA-F]를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_group_short">
        <source>negative character group</source>
        <target state="translated">부정 문자 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_range_long">
        <source>A negative character range specifies a list of characters that must not appear in an input string for a match to occur. 'firstCharacter' is the character that begins the range, and 'lastCharacter' is the character that ends the range.

Two or more character ranges can be concatenated. For example, to specify the range of decimal digits from "0" through "9", the range of lowercase letters from "a" through "f", and the range of uppercase letters from "A" through "F", use [0-9a-fA-F].</source>
        <target state="translated">부정 문자 범위는 일치 항목을 찾을 입력 문자열에 표시되지 않아야 하는 문자 목록을 지정합니다. 'firstCharacter'는 범위를 시작하는 문자이고 'lastCharacter'는 범위를 끝내는 문자입니다.

둘 이상의 문자 범위를 연결할 수 있습니다. 예를 들어 "0"에서 "9"까지의 10진수 범위, "a"에서 "f"까지의 소문자 범위 및 "A"에서 "F"까지의 대문자 범위를 지정하려면 [0-9a-fA-F]를 사용합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_character_range_short">
        <source>negative character range</source>
        <target state="translated">부정 문자 범위</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_long">
        <source>The regular expression construct \P{ name } matches any character that does not belong to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">정규식 구문 \P{ name }는 유니코드 일반 범주 또는 명명된 블록에 속하지 않는 모든 문자와 일치시킵니다. 여기서, name은 범주 약어 또는 명명된 블록 이름입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_negative_unicode_category_short">
        <source>negative unicode category</source>
        <target state="translated">부정 유니코드 범주</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_long">
        <source>Matches a new-line character, \u000A</source>
        <target state="translated">줄 바꿈 문자 \u000A와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_new_line_character_short">
        <source>new-line character</source>
        <target state="translated">줄 바꿈 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_no">
        <source>no</source>
        <target state="translated">아니요</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_long">
        <source>\D matches any non-digit character. It is equivalent to the \P{Nd} regular expression pattern.

If ECMAScript-compliant behavior is specified, \D is equivalent to [^0-9]</source>
        <target state="translated">\D는 숫자가 아닌 문자와 일치시킵니다. \P{Nd} 정규식 패턴과 같습니다.

ECMAScript 규격 동작을 지정한 경우 \D는 [^0-9]와 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_digit_character_short">
        <source>non-digit character</source>
        <target state="translated">숫자가 아닌 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_long">
        <source>\S matches any non-white-space character. It is equivalent to the [^\f\n\r\t\v\x85\p{Z}] regular expression pattern, or the opposite of the regular expression pattern that is equivalent to \s, which matches white-space characters.

If ECMAScript-compliant behavior is specified, \S is equivalent to [^ \f\n\r\t\v]</source>
        <target state="translated">\S는 공백이 아닌 문자와 일치시킵니다. [^\f\n\r\t\v\x85\p{Z}] 정규식 패턴과 같거나, 공백 문자와 일치시키는 \s와 같은 정규식 패턴과 반대됩니다.

ECMAScript 규격 동작을 지정한 경우 \S는 [^ \f\n\r\t\v]와 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_white_space_character_short">
        <source>non-white-space character</source>
        <target state="translated">공백이 아닌 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_long">
        <source>The \B anchor specifies that the match must not occur on a word boundary. It is the opposite of the \b anchor.</source>
        <target state="translated">\B 앵커는 단어 경계에서 일치 항목을 찾도록 지정합니다. \b 앵커와 반대입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_boundary_short">
        <source>non-word boundary</source>
        <target state="translated">단어가 아닌 경계</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_non_word_character_long">
        <source>\W matches any non-word character. It matches any character except for those in the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \W is equivalent to [^a-zA-Z_0-9]</source>
        <target state="translated">\W는 단어가 아닌 문자와 일치시킵니다. 다음 유니코드 범주의 문자를 제외한 모든 문자와 일치시킵니다.

    Ll	문자, 소문자
    Lu	문자, 대문자
    Lt	문자, 첫 글자만 대문자
    Lo	문자, 기타
    Lm	문자, 한정자
    Mn	표시, 공간을 차지하지 않는 문자
    Nd	숫자, 10진수
    Pc	문장 부호, 연결선

ECMAScript 규격 동작을 지정한 경우 \W는 [^a-zA-Z_0-9]와 같습니다.</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized. </note>
      </trans-unit>
      <trans-unit id="Regex_non_word_character_short">
        <source>non-word character</source>
        <target state="translated">단어가 아닌 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_nonbacktracking_subexpression_long">
        <source>This construct disables backtracking. The regular expression engine will match as many characters in the input string as it can. When no further match is possible, it will not backtrack to attempt alternate pattern matches. (That is, the subexpression matches only strings that would be matched by the subexpression alone; it does not attempt to match a string based on the subexpression and any subexpressions that follow it.)

This option is recommended if you know that backtracking will not succeed. Preventing the regular expression engine from performing unnecessary searching improves performance.</source>
        <target state="translated">이 구문은 역추적을 사용하지 않도록 설정합니다. 정규식 엔진은 입력 문자열에서 가능한 한 많은 문자와 일치시킵니다. 더 이상 일치 항목을 찾을 수 없으면 대체 패턴 일치 항목 찾기를 시도하도록 역추적하지 않습니다. 즉, 하위 식은 해당 하위 식 단독으로 일치되는 문자열만 일치시킵니다. 해당 하위 식과 그 뒤에 오는 하위 식을 기반으로 문자열을 일치시키지 않습니다.

이 옵션은 역추적이 성공하지 못할 것을 알고 있는 경우에 사용하는 것이 좋습니다. 정규식 엔진이 불필요한 검색을 수행하지 않도록 하면 성능이 향상됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_nonbacktracking_subexpression_short">
        <source>nonbacktracking subexpression</source>
        <target state="translated">역추적하지 않는 하위 식</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_long">
        <source>This construct does not capture the substring that is matched by a subexpression:

The noncapturing group construct is typically used when a quantifier is applied to a group, but the substrings captured by the group are of no interest.

If a regular expression includes nested grouping constructs, an outer noncapturing group construct does not apply to the inner nested group constructs.</source>
        <target state="translated">이 구문은 하위 식으로 일치되는 하위 문자열을 캡처하지 않습니다.

한정사가 그룹에 적용되는 경우 일반적으로 비캡처링 그룹 구문이 사용되지만 그룹에서 캡처된 하위 문자열과는 관련이 없습니다.

정규식에 중첩 그룹화 생성자가 포함되는 경우 외부 비캡처링 그룹 구문은 내부 중첩 그룹 구문에 적용되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_noncapturing_group_short">
        <source>noncapturing group</source>
        <target state="translated">비캡처링 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_decimal_digit">
        <source>number, decimal digit</source>
        <target state="translated">숫자, 10진수</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_letter">
        <source>number, letter</source>
        <target state="translated">숫자, 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_number_other">
        <source>number, other</source>
        <target state="translated">숫자, 기타</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_long">
        <source>A numbered backreference, where 'number' is the ordinal position of the capturing group in the regular expression. For example, \4 matches the contents of the fourth capturing group.

There is an ambiguity between octal escape codes (such as \16) and \number backreferences that use the same notation. If the ambiguity is a problem, you can use the \k&lt;name&gt; notation, which is unambiguous and cannot be confused with octal character codes. Similarly, hexadecimal codes such as \xdd are unambiguous and cannot be confused with backreferences.</source>
        <target state="translated">번호가 매겨진 역참조입니다. 여기서 'number'는 정규식에 있는 캡처링 그룹의 서수 위치입니다. 예를 들어 \4는 네 번째 캡처링 그룹의 콘텐츠와 일치시킵니다.

8진수 이스케이프 코드(예: \16) 및 동일한 표기법을 사용하는 \number 역참조 사이에는 모호성이 있습니다. 모호성 문제가 발생하는 경우 명확하며 8진수 문자 코드와 혼동되지 않는 \k&lt;이름&gt; 표기법을 사용할 수 있습니다. 마찬가지로, \xdd와 같은 16진수 코드는 명확하며 역참조와 혼동되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_numbered_backreference_short">
        <source>numbered backreference</source>
        <target state="translated">번호가 매겨진 역참조</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_control">
        <source>other, control</source>
        <target state="translated">기타, 제어</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_format">
        <source>other, format</source>
        <target state="translated">기타, 형식</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_not_assigned">
        <source>other, not assigned</source>
        <target state="translated">기타, 할당되지 않음</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_private_use">
        <source>other, private use</source>
        <target state="translated">기타, 프라이빗 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_other_surrogate">
        <source>other, surrogate</source>
        <target state="translated">기타, 서로게이트</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_long">
        <source>A positive character group specifies a list of characters, any one of which may appear in an input string for a match to occur.</source>
        <target state="translated">긍정 문자 그룹은 일치 항목을 찾을 입력 문자열에 표시될 수 있는 문자 목록을 지정합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_group_short">
        <source>positive character group</source>
        <target state="translated">긍정 문자 그룹</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_long">
        <source>A positive character range specifies a range of characters, any one of which may appear in an input string for a match to occur.  'firstCharacter' is the character that begins the range and 'lastCharacter' is the character that ends the range. </source>
        <target state="translated">긍정 문자 범위는 일치 항목을 찾을 입력 문자열에 표시될 수 있는 문자 범위를 지정합니다. 'firstCharacter'는 범위를 시작하는 문자이고 'lastCharacter'는 범위를 끝내는 문자입니다. </target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_positive_character_range_short">
        <source>positive character range</source>
        <target state="translated">긍정 문자 범위</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_close">
        <source>punctuation, close</source>
        <target state="translated">문장 부호, 닫기</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_connector">
        <source>punctuation, connector</source>
        <target state="translated">문장 부호, 연결선</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_dash">
        <source>punctuation, dash</source>
        <target state="translated">문장 부호, 대시</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_final_quote">
        <source>punctuation, final quote</source>
        <target state="translated">문장 부호, 마지막 따옴표</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_initial_quote">
        <source>punctuation, initial quote</source>
        <target state="translated">문장 부호, 처음 따옴표</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_open">
        <source>punctuation, open</source>
        <target state="translated">문장 부호, 열기</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_punctuation_other">
        <source>punctuation, other</source>
        <target state="translated">문장 부호, 기타</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_line">
        <source>separator, line</source>
        <target state="translated">구분 기호, 줄</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_paragraph">
        <source>separator, paragraph</source>
        <target state="translated">구분 기호, 단락</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_separator_space">
        <source>separator, space</source>
        <target state="translated">구분 기호, 공백</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_long">
        <source>The \A anchor specifies that a match must occur at the beginning of the input string. It is identical to the ^ anchor, except that \A ignores the RegexOptions.Multiline option. Therefore, it can only match the start of the first line in a multiline input string.</source>
        <target state="translated">\A 앵커는 입력 문자열의 시작 부분에서 일치 항목을 찾도록 지정합니다. \A가 RegexOptions.Multiline 옵션을 무시한다는 점을 제외하고는 ^ 앵커와 동일합니다. 따라서 여러 줄 입력 문자열에서 첫 번째 줄의 시작 부분만 찾을 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_only_short">
        <source>start of string only</source>
        <target state="translated">문자열의 시작만</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_long">
        <source>The ^ anchor specifies that the following pattern must begin at the first character position of the string. If you use ^ with the RegexOptions.Multiline option, the match must occur at the beginning of each line.</source>
        <target state="translated">^ 앵커는 다음 패턴이 문자열의 첫 번째 문자 위치에서 시작하도록 지정합니다. ^ 기호를 RegexOptions.Multiline 옵션과 함께 사용하는 경우 각 줄의 시작 부분에 일치 항목이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_start_of_string_or_line_short">
        <source>start of string or line</source>
        <target state="translated">문자열 또는 줄의 시작</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_subexpression">
        <source>subexpression</source>
        <target state="translated">하위 식</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_currency">
        <source>symbol, currency</source>
        <target state="translated">기호, 통화</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_math">
        <source>symbol, math</source>
        <target state="translated">기호, 수학</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_modifier">
        <source>symbol, modifier</source>
        <target state="translated">기호, 한정자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_symbol_other">
        <source>symbol, other</source>
        <target state="translated">기호, 기타</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_long">
        <source>Matches a tab character, \u0009</source>
        <target state="translated">탭 문자 \u0009와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_tab_character_short">
        <source>tab character</source>
        <target state="translated">탭 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_long">
        <source>The regular expression construct \p{ name } matches any character that belongs to a Unicode general category or named block, where name is the category abbreviation or named block name.</source>
        <target state="translated">정규식 구문 \p{ name }는 유니코드 일반 범주 또는 명명된 블록에 속하는 모든 문자와 일치시킵니다. 여기서, name은 범주 약어 또는 명명된 블록 이름입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_category_short">
        <source>unicode category</source>
        <target state="translated">유니코드 범주</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_long">
        <source>Matches a UTF-16 code unit whose value is #### hexadecimal.</source>
        <target state="translated">값이 #### 16진수인 UTF-16 코드 단위와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_escape_short">
        <source>unicode escape</source>
        <target state="translated">유니코드 이스케이프</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_unicode_general_category_0">
        <source>Unicode General Category: {0}</source>
        <target state="translated">유니코드 일반 범주: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_long">
        <source>Matches a vertical-tab character, \u000B</source>
        <target state="translated">세로 탭 문자 \u000B와 일치시킵니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_vertical_tab_character_short">
        <source>vertical-tab character</source>
        <target state="translated">세로 탭 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_long">
        <source>\s matches any white-space character. It is equivalent to the following escape sequences and Unicode categories:

    \f	The form feed character, \u000C
    \n	The newline character, \u000A
    \r	The carriage return character, \u000D
    \t	The tab character, \u0009
    \v	The vertical tab character, \u000B
    \x85	The ellipsis or NEXT LINE (NEL) character (…), \u0085
    \p{Z}	Matches any separator character

If ECMAScript-compliant behavior is specified, \s is equivalent to [ \f\n\r\t\v]</source>
        <target state="translated">\s는 공백 문자와 일치시킵니다. 다음 이스케이프 시퀀스 및 유니코드 범주와 같습니다.

    \f	용지 공급 문자, \u000C
    \n	줄 바꿈 문자, \u000A
    \r	캐리지 리턴 문자, \u000D
    \t	탭 문자, \u0009
    \v	세로 탭 문자, \u000B
    \x85	줄임표 또는 NEXT LINE(NEL) 문자(…), \u0085
    \p{Z}	구분 문자와 일치시킵니다.

ECMAScript와 호환되는 동작을 지정한 경우 \s는 [ \f\n\r\t\v]와 같습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_white_space_character_short">
        <source>white-space character</source>
        <target state="translated">공백 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_long">
        <source>The \b anchor specifies that the match must occur on a boundary between a word character (the \w language element) and a non-word character (the \W language element). Word characters consist of alphanumeric characters and underscores; a non-word character is any character that is not alphanumeric or an underscore. The match may also occur on a word boundary at the beginning or end of the string.

The \b anchor is frequently used to ensure that a subexpression matches an entire word instead of just the beginning or end of a word.</source>
        <target state="translated">\b 앵커는 단어 문자(\w 언어 요소)와 단어가 아닌 문자(\W 언어 요소) 사이의 경계에서 일치 항목을 찾도록 지정합니다. 단어 문자는 영숫자 문자 및 밑줄로 구성되고, 단어가 아닌 문자는 영숫자나 밑줄이 아닌 모든 문자입니다. 문자열의 시작 또는 끝부분 단어 경계에서 일치 항목을 찾을 수도 있습니다.

\b 앵커는 하위 식이 단어의 시작 또는 끝부분이 아닌 전체 단어를 일치시키도록 하는 데 자주 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_boundary_short">
        <source>word boundary</source>
        <target state="translated">단어 경계</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_word_character_long">
        <source>\w matches any word character. A word character is a member of any of the following Unicode categories:

    Ll	Letter, Lowercase
    Lu	Letter, Uppercase
    Lt	Letter, Titlecase
    Lo	Letter, Other
    Lm	Letter, Modifier
    Mn	Mark, Nonspacing
    Nd	Number, Decimal Digit
    Pc	Punctuation, Connector

If ECMAScript-compliant behavior is specified, \w is equivalent to [a-zA-Z_0-9]</source>
        <target state="translated">\w는 단어 문자와 일치시킵니다. 단어 문자는 다음 유니코드 범주의 멤버입니다.

    Ll	문자, 소문자
    Lu	문자, 대문자
    Lt	문자, 첫 글자만 대문자
    Lo	문자, 기타
    Lm	문자, 한정자
    Mn	표시, 공간을 차지하지 않는 문자
    Nd	숫자, 10진수
    Pc	문장 부호, 연결선

ECMAScript 규격 동작을 지정한 경우 \w는 [a-zA-Z_0-9]와 같습니다.</target>
        <note>Note: Ll, Lu, Lt, Lo, Lm, Mn, Nd, and Pc are all things that should not be localized.</note>
      </trans-unit>
      <trans-unit id="Regex_word_character_short">
        <source>word character</source>
        <target state="translated">단어 문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_yes">
        <source>yes</source>
        <target state="translated">예</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_long">
        <source>A zero-width negative lookahead assertion, where for the match to be successful, the input string must not match the regular expression pattern in subexpression. The matched string is not included in the match result.

A zero-width negative lookahead assertion is typically used either at the beginning or at the end of a regular expression. At the beginning of a regular expression, it can define a specific pattern that should not be matched when the beginning of the regular expression defines a similar but more general pattern to be matched. In this case, it is often used to limit backtracking. At the end of a regular expression, it can define a subexpression that cannot occur at the end of a match.</source>
        <target state="translated">너비가 0인 부정 lookahead 어설션입니다. 여기서, 일치 항목을 찾으려면 입력 문자열이 하위 식의 정규식 패턴과 일치하면 안 됩니다. 일치하는 문자열은 일치 결과에 포함되지 않습니다.

너비가 0인 부정 lookahead 어설션은 일반적으로 정규식의 시작 부분이나 끝부분에 사용됩니다. 정규식의 시작 부분에서는 일치시켜야 하는 유사하지만 보다 일반적인 패턴을 정의할 때 일치시키면 안 되는 특정 패턴을 정의할 수 있습니다. 이 경우 보통 역추적을 제한하는 데 사용됩니다. 정규식의 끝부분에서는 일치 항목의 끝부분에 있으면 안 되는 하위 식을 정의할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookahead_assertion_short">
        <source>zero-width negative lookahead assertion</source>
        <target state="translated">너비가 0인 부정 lookahead 어설션</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_long">
        <source>A zero-width negative lookbehind assertion, where for a match to be successful, 'subexpression' must not occur at the input string to the left of the current position. Any substring that does not match 'subexpression' is not included in the match result.

Zero-width negative lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define precludes a match in the string that follows. They are also used to limit backtracking when the last character or characters in a captured group must not be one or more of the characters that match that group's regular expression pattern.</source>
        <target state="translated">너비가 0인 부정 lookbehind 어설션입니다. 여기서, 일치 항목을 찾으려면 입력 문자열에서 현재 위치 왼쪽에 'subexpression'이 없어야 합니다. 'subexpression'과 일치하지 않는 하위 문자열은 일치 결과에 포함되지 않습니다.

너비가 0인 부정 lookbehind 어설션은 일반적으로 정규식의 시작 부분에 사용됩니다. 어설션이 정의하는 패턴은 뒤에 오는 문자열에 일치 항목이 없도록 합니다. 캡처된 그룹에 있는 마지막 문자가 해당 그룹의 정규식 패턴과 일치하는 하나 이상의 문자가 아니어야 하는 경우 역추적을 제한하는 데도 사용됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_negative_lookbehind_assertion_short">
        <source>zero-width negative lookbehind assertion</source>
        <target state="translated">너비가 0인 부정 lookbehind 어설션</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_long">
        <source>A zero-width positive lookahead assertion, where for a match to be successful, the input string must match the regular expression pattern in 'subexpression'. The matched substring is not included in the match result. A zero-width positive lookahead assertion does not backtrack.

Typically, a zero-width positive lookahead assertion is found at the end of a regular expression pattern. It defines a substring that must be found at the end of a string for a match to occur but that should not be included in the match. It is also useful for preventing excessive backtracking. You can use a zero-width positive lookahead assertion to ensure that a particular captured group begins with text that matches a subset of the pattern defined for that captured group.</source>
        <target state="translated">너비가 0인 긍정 lookahead 어설션입니다. 여기서, 일치 항목을 찾으려면 입력 문자열이 'subexpression'의 정규식 패턴과 일치해야 합니다. 일치된 하위 문자열은 일치 결과에 포함되지 않습니다. 너비가 0인 긍정 lookahead 어설션은 역추적하지 않습니다.

일반적으로 너비가 0인 긍정 lookahead 어설션은 정규식 패턴 끝에 있습니다. 이 어설션은 일치 항목을 찾을 문자열 끝에 있어야 하지만 일치에 포함되면 안 되는 하위 문자열을 정의합니다. 또한, 과도한 역추적을 방지하는 데에도 유용합니다. 너비가 0인 긍정 lookahead 어설션을 사용하면 캡처된 특정 그룹이 이 캡처된 그룹에 정의된 패턴의 하위 집합과 일치하는 텍스트로 시작하도록 할 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookahead_assertion_short">
        <source>zero-width positive lookahead assertion</source>
        <target state="translated">너비가 0인 긍정 lookahead 어설션</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_long">
        <source>A zero-width positive lookbehind assertion, where for a match to be successful, 'subexpression' must occur at the input string to the left of the current position. 'subexpression' is not included in the match result. A zero-width positive lookbehind assertion does not backtrack.

Zero-width positive lookbehind assertions are typically used at the beginning of regular expressions. The pattern that they define is a precondition for a match, although it is not a part of the match result.</source>
        <target state="translated">너비가 0인 긍정 lookbehind 어설션입니다. 여기서, 일치 항목을 찾으려면 입력 문자열에서 현재 위치 왼쪽에 'subexpression'이 있어야 합니다. 'subexpression'은 일치 결과에 포함되지 않습니다. 너비가 0인 긍정 lookbehind 어설션은 역추적하지 않습니다.

너비가 0인 긍정 lookbehind 어설션은 일반적으로 정규식의 시작 부분에 사용됩니다. 어설션이 정의하는 패턴은 일치 항목의 사전 조건이지만 일치 결과에 포함되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_zero_width_positive_lookbehind_assertion_short">
        <source>zero-width positive lookbehind assertion</source>
        <target state="translated">너비가 0인 긍정 lookbehind 어설션</target>
        <note />
      </trans-unit>
      <trans-unit id="Remove_the_line_below_if_you_want_to_inherit_dot_editorconfig_settings_from_higher_directories">
        <source>Remove the line below if you want to inherit .editorconfig settings from higher directories</source>
        <target state="translated">상위 디렉터리에서 .editorconfig 설정을 상속하려면 아래 행을 제거하세요.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_analyzer_config_documents_is_not_supported">
        <source>Removing analyzer config documents is not supported.</source>
        <target state="translated">분석기 구성 문서 제거는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbol_0_is_not_from_source">
        <source>Symbol "{0}" is not from source.</source>
        <target state="translated">"{0}" 기호가 소스에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Documentation_comment_id_must_start_with_E_F_M_N_P_or_T">
        <source>Documentation comment id must start with E, F, M, N, P or T</source>
        <target state="translated">문서 주석 ID는 E, F, M, N, P 또는 T로 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cycle_detected_in_extensions">
        <source>Cycle detected in extensions</source>
        <target state="translated">확장에서 순환 발견</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_but_given_one_is_1">
        <source>Destination type must be a {0}, but given one is {1}.</source>
        <target state="translated">대상 형식은 {0}이어야 하지만 지정된 형식은 {1}입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_or_a_1_but_given_one_is_2">
        <source>Destination type must be a {0} or a {1}, but given one is {2}.</source>
        <target state="translated">대상 형식은 {0} 또는 {1}이어야 하지만 지정된 형식은 {2}입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_type_must_be_a_0_1_or_2_but_given_one_is_3">
        <source>Destination type must be a {0}, {1} or {2}, but given one is {3}.</source>
        <target state="translated">대상 형식은 {0}, {1} 또는 {2}이어야 하지만 지정된 형식은 {3}입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Could_not_find_location_to_generation_symbol_into">
        <source>Could not find location to generation symbol into.</source>
        <target state="translated">기호를 생성할 위치를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="No_location_provided_to_add_statements_to">
        <source>No location provided to add statements to.</source>
        <target state="translated">문을 추가할 위치가 제공되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_location_was_not_in_source">
        <source>Destination location was not in source.</source>
        <target state="translated">대상 위치가 소스에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Destination_location_was_from_a_different_tree">
        <source>Destination location was from a different tree.</source>
        <target state="translated">다른 트리에서 온 대상 위치입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Node_is_of_the_wrong_type">
        <source>Node is of the wrong type.</source>
        <target state="translated">잘못된 형식의 노드입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Location_must_be_null_or_from_source">
        <source>Location must be null or from source.</source>
        <target state="translated">위치는 null이거나 소스에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Duplicate_source_file_0_in_project_1">
        <source>Duplicate source file '{0}' in project '{1}'</source>
        <target state="translated">{1}' 프로젝트에서 중복된 '{0}' 소스 파일입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_projects_is_not_supported">
        <source>Removing projects is not supported.</source>
        <target state="translated">프로젝트 제거는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_projects_is_not_supported">
        <source>Adding projects is not supported.</source>
        <target state="translated">프로젝트 추가가 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Symbol_specifications">
        <source>Symbol specifications</source>
        <target state="translated">기호 사양</target>
        <note />
      </trans-unit>
      <trans-unit id="Visual_Basic_files">
        <source>Visual Basic files</source>
        <target state="translated">Visual Basic 파일</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning_adding_imports_will_bring_an_extension_method_into_scope_with_the_same_name_as_member_access">
        <source>Adding imports will bring an extension method into scope with the same name as '{0}'</source>
        <target state="translated">가져오기를 추가하면 '{0}'과(와) 같은 이름으로 확장 메서드가 범위에 포함됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Workspace_error">
        <source>Workspace error</source>
        <target state="translated">작업 영역 오류</target>
        <note />
      </trans-unit>
      <trans-unit id="Workspace_is_not_empty">
        <source>Workspace is not empty.</source>
        <target state="translated">작업 영역이 비어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_in_a_different_project">
        <source>{0} is in a different project.</source>
        <target state="new">{0} is in a different project.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_part_of_the_workspace">
        <source>'{0}' is not part of the workspace.</source>
        <target state="translated">'{0}'은(는) 작업 영역의 일부가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_already_part_of_the_workspace">
        <source>'{0}' is already part of the workspace.</source>
        <target state="translated">'{0}'은(는) 이미 작업 영역의 일부입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_referenced">
        <source>'{0}' is not referenced.</source>
        <target state="translated">'{0}'이(가) 참조되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_already_referenced">
        <source>'{0}' is already referenced.</source>
        <target state="translated">'{0}'은(는) 이미 참조되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_project_reference_from_0_to_1_will_cause_a_circular_reference">
        <source>Adding project reference from '{0}' to '{1}' will cause a circular reference.</source>
        <target state="translated">{0}'에서 '{1}'(으)로 프로젝트 참조를 추가하면 순환 참조가 됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Metadata_is_not_referenced">
        <source>Metadata is not referenced.</source>
        <target state="translated">메타데이터가 참조되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Metadata_is_already_referenced">
        <source>Metadata is already referenced.</source>
        <target state="translated">메타데이터가 이미 참조되었습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_present">
        <source>{0} is not present.</source>
        <target state="translated">{0}이(가) 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_already_present">
        <source>{0} is already present.</source>
        <target state="translated">{0}이(가) 이미 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_specified_document_is_not_a_version_of_this_document">
        <source>The specified document is not a version of this document.</source>
        <target state="translated">지정한 문서가 이 문서의 버전이 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_language_0_is_not_supported">
        <source>The language '{0}' is not supported.</source>
        <target state="translated">{0}' 언어는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_already_contains_the_specified_project">
        <source>The solution already contains the specified project.</source>
        <target state="translated">솔루션에 지정한 프로젝트가 이미 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_does_not_contain_the_specified_project">
        <source>The solution does not contain the specified project.</source>
        <target state="translated">솔루션에 지정한 프로젝트가 포함되어 있지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_project_already_references_the_target_project">
        <source>The project already references the target project.</source>
        <target state="translated">프로젝트가 대상 프로젝트를 이미 참조하고 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_project_already_transitively_references_the_target_project">
        <source>The project already transitively references the target project.</source>
        <target state="translated">프로젝트가 대상 프로젝트를 이미 타동적으로 참조하고 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_solution_already_contains_the_specified_document">
        <source>The solution already contains the specified document.</source>
        <target state="translated">솔루션에 지정한 문서가 이미 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Temporary_storage_cannot_be_written_more_than_once">
        <source>Temporary storage cannot be written more than once.</source>
        <target state="translated">임시 스토리지는 두 번 쓸 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_not_open">
        <source>'{0}' is not open.</source>
        <target state="translated">'{0}'이(가) 열리지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="A_language_name_cannot_be_specified_for_this_option">
        <source>A language name cannot be specified for this option.</source>
        <target state="translated">이 옵션에 대한 언어 이름을 지정할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="A_language_name_must_be_specified_for_this_option">
        <source>A language name must be specified for this option.</source>
        <target state="translated">이 옵션에 대한 언어 이름을 지정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="File_was_externally_modified_colon_0">
        <source>File was externally modified: {0}.</source>
        <target state="translated">파일이 외부에서 수정되었습니다({0}).</target>
        <note />
      </trans-unit>
      <trans-unit id="Unrecognized_language_name">
        <source>Unrecognized language name.</source>
        <target state="translated">인식할 수 없는 언어 이름입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Can_t_resolve_metadata_reference_colon_0">
        <source>Can't resolve metadata reference: '{0}'.</source>
        <target state="translated">메타데이터 참조를 확인할 수 없습니다('{0}').</target>
        <note />
      </trans-unit>
      <trans-unit id="Can_t_resolve_analyzer_reference_colon_0">
        <source>Can't resolve analyzer reference: '{0}'.</source>
        <target state="translated">분석기 참조를 확인할 수 없습니다('{0}').</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_block_expected_after_Project">
        <source>Invalid project block, expected "=" after Project.</source>
        <target state="translated">잘못된 프로젝트 블록입니다. Project 다음에 "="가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_block_expected_after_project_name">
        <source>Invalid project block, expected "," after project name.</source>
        <target state="translated">잘못된 프로젝트 블록입니다. 프로젝트 이름 다음에 ","가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_block_expected_after_project_path">
        <source>Invalid project block, expected "," after project path.</source>
        <target state="translated">잘못된 프로젝트 블록입니다. 프로젝트 경로 다음에 ","가 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_0">
        <source>Expected {0}.</source>
        <target state="translated">{0}이(가) 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_must_be_a_non_null_and_non_empty_string">
        <source>"{0}" must be a non-null and non-empty string.</source>
        <target state="translated">"{0}"은(는) null이 아니거나 비어 있지 않은 문자열이어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_header_colon_0">
        <source>Expected header: "{0}".</source>
        <target state="translated">헤더가 필요합니다("{0}").</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_end_of_file">
        <source>Expected end-of-file.</source>
        <target state="translated">파일 끝(EOF)이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Expected_0_line">
        <source>Expected {0} line.</source>
        <target state="translated">{0} 줄이 필요합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="This_submission_already_references_another_submission_project">
        <source>This submission already references another submission project.</source>
        <target state="translated">이 전송은 이미 다른 전송 프로젝트가 참조했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_still_contains_open_documents">
        <source>{0} still contains open documents.</source>
        <target state="translated">{0}에 열린 문서가 포함되어 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_is_still_open">
        <source>{0} is still open.</source>
        <target state="translated">{0}이(가) 열려 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Arrays_with_more_than_one_dimension_cannot_be_serialized">
        <source>Arrays with more than one dimension cannot be serialized.</source>
        <target state="translated">차원이 두 개 이상인 배열을 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer">
        <source>Value too large to be represented as a 30 bit unsigned integer.</source>
        <target state="translated">값이 너무 커서 30비트 정수로 표시할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Specified_path_must_be_absolute">
        <source>Specified path must be absolute.</source>
        <target state="translated">지정한 경로가 절대 경로여야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cast_is_redundant">
        <source>Cast is redundant.</source>
        <target state="translated">캐스팅이 중복됩니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Name_can_be_simplified">
        <source>Name can be simplified.</source>
        <target state="translated">이름을 간단하게 줄일 수 있습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unknown_identifier">
        <source>Unknown identifier.</source>
        <target state="translated">알 수 없는 식별자입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_generate_code_for_unsupported_operator_0">
        <source>Cannot generate code for unsupported operator '{0}'</source>
        <target state="translated">지원되지 않는 '{0}' 연산자에 대한 코드를 생성할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_number_of_parameters_for_binary_operator">
        <source>Invalid number of parameters for binary operator.</source>
        <target state="translated">이진 연산자에 대해 잘못된 매개 변수 수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_number_of_parameters_for_unary_operator">
        <source>Invalid number of parameters for unary operator.</source>
        <target state="translated">단항 연산자에 대해 잘못된 매개 변수 수입니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_open_project_0_because_the_file_extension_1_is_not_associated_with_a_language">
        <source>Cannot open project '{0}' because the file extension '{1}' is not associated with a language.</source>
        <target state="translated">{1}' 파일 확장명이 언어에 연결되어 있지 않아 '{0}' 프로젝트를 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_open_project_0_because_the_language_1_is_not_supported">
        <source>Cannot open project '{0}' because the language '{1}' is not supported.</source>
        <target state="translated">{1}' 언어를 지원하지 않아 '{0}' 프로젝트를 열 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_project_file_path_colon_0">
        <source>Invalid project file path: '{0}'</source>
        <target state="translated">잘못된 프로젝트 파일 경로입니다('{0}').</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_solution_file_path_colon_0">
        <source>Invalid solution file path: '{0}'</source>
        <target state="translated">잘못된 솔루션 파일 경로입니다('{0}').</target>
        <note />
      </trans-unit>
      <trans-unit id="Project_file_not_found_colon_0">
        <source>Project file not found: '{0}'</source>
        <target state="translated">{0}' 프로젝트 파일을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Solution_file_not_found_colon_0">
        <source>Solution file not found: '{0}'</source>
        <target state="translated">{0}' 솔루션 파일을 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Unmerged_change_from_project_0">
        <source>Unmerged change from project '{0}'</source>
        <target state="translated">{0}' 프로젝트에서 병합되지 않은 변경 내용</target>
        <note />
      </trans-unit>
      <trans-unit id="Added_colon">
        <source>Added:</source>
        <target state="translated">추가됨:</target>
        <note />
      </trans-unit>
      <trans-unit id="After_colon">
        <source>After:</source>
        <target state="translated">이후:</target>
        <note />
      </trans-unit>
      <trans-unit id="Before_colon">
        <source>Before:</source>
        <target state="translated">이전:</target>
        <note />
      </trans-unit>
      <trans-unit id="Removed_colon">
        <source>Removed:</source>
        <target state="translated">제거됨:</target>
        <note />
      </trans-unit>
      <trans-unit id="Invalid_CodePage_value_colon_0">
        <source>Invalid CodePage value: {0}</source>
        <target state="translated">잘못된 CodePage 값: {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_additional_documents_is_not_supported">
        <source>Adding additional documents is not supported.</source>
        <target state="translated">추가 문서 추가는 지원되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_analyzer_references_is_not_supported">
        <source>Adding analyzer references is not supported.</source>
        <target state="translated">분석기 참조 추가는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_documents_is_not_supported">
        <source>Adding documents is not supported.</source>
        <target state="translated">문서 추가는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_metadata_references_is_not_supported">
        <source>Adding metadata references is not supported.</source>
        <target state="translated">메타데이터 참조 추가는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Adding_project_references_is_not_supported">
        <source>Adding project references is not supported.</source>
        <target state="translated">프로젝트 참조 추가는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_additional_documents_is_not_supported">
        <source>Changing additional documents is not supported.</source>
        <target state="translated">추가 문서 변경은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_documents_is_not_supported">
        <source>Changing documents is not supported.</source>
        <target state="translated">문서 변경은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_project_properties_is_not_supported">
        <source>Changing project properties is not supported.</source>
        <target state="translated">프로젝트 속성 변경은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_additional_documents_is_not_supported">
        <source>Removing additional documents is not supported.</source>
        <target state="translated">추가 문서 제거는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_analyzer_references_is_not_supported">
        <source>Removing analyzer references is not supported.</source>
        <target state="translated">분석기 참조 제거는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_documents_is_not_supported">
        <source>Removing documents is not supported.</source>
        <target state="translated">문서 제거는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_metadata_references_is_not_supported">
        <source>Removing metadata references is not supported.</source>
        <target state="translated">메타데이터 참조 제거는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Removing_project_references_is_not_supported">
        <source>Removing project references is not supported.</source>
        <target state="translated">프로젝트 참조 제거는 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Service_of_type_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_workspace">
        <source>Service of type '{0}' is required to accomplish the task but is not available from the workspace.</source>
        <target state="translated">{0}' 유형의 서비스가 작업을 수행하는 데 필요하지만 작업 영역에서 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="At_least_one_diagnostic_must_be_supplied">
        <source>At least one diagnostic must be supplied.</source>
        <target state="translated">하나 이상의 진단을 제공해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Diagnostic_must_have_span_0">
        <source>Diagnostic must have span '{0}'</source>
        <target state="translated">진단에는 '{0}' 범위가 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_deserialize_type_0">
        <source>Cannot deserialize type '{0}'.</source>
        <target state="translated">{0}' 형식을 역직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Cannot_serialize_type_0">
        <source>Cannot serialize type '{0}'.</source>
        <target state="translated">{0}' 형식을 직렬화할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_type_0_is_not_understood_by_the_serialization_binder">
        <source>The type '{0}' is not understood by the serialization binder.</source>
        <target state="translated">직렬화 바인더가 '{0}' 형식을 인식할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Label_for_node_0_is_invalid_it_must_be_within_bracket_0_1">
        <source>Label for node '{0}' is invalid, it must be within [0, {1}).</source>
        <target state="translated">{0}' 노드의 레이블이 잘못되었습니다. [0, {1}) 내에 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Matching_nodes_0_and_1_must_have_the_same_label">
        <source>Matching nodes '{0}' and '{1}' must have the same label.</source>
        <target state="translated">일치하는 노드 '{0}' 및 '{1}'에 동일한 레이블이 있어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Node_0_must_be_contained_in_the_new_tree">
        <source>Node '{0}' must be contained in the new tree.</source>
        <target state="translated">{0}' 노드가 새 트리에 포함되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Node_0_must_be_contained_in_the_old_tree">
        <source>Node '{0}' must be contained in the old tree.</source>
        <target state="translated">{0}' 노드가 이전 트리에 포함되어야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_member_0_is_not_declared_within_the_declaration_of_the_symbol">
        <source>The member '{0}' is not declared within the declaration of the symbol.</source>
        <target state="translated">{0}' 멤버가 기호의 선언 내에서 선언되지 않았습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_position_is_not_within_the_symbol_s_declaration">
        <source>The position is not within the symbol's declaration</source>
        <target state="translated">위치가 기호의 선언 내에 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_symbol_0_cannot_be_located_within_the_current_solution">
        <source>The symbol '{0}' cannot be located within the current solution.</source>
        <target state="translated">현재 솔루션 내에서 '{0}' 기호를 찾을 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_compilation_options_is_not_supported">
        <source>Changing compilation options is not supported.</source>
        <target state="translated">컴파일 옵션 변경은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_parse_options_is_not_supported">
        <source>Changing parse options is not supported.</source>
        <target state="translated">구문 분석 옵션 변경은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_node_is_not_part_of_the_tree">
        <source>The node is not part of the tree.</source>
        <target state="translated">노드는 트리의 일부가 아닙니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="This_workspace_does_not_support_opening_and_closing_documents">
        <source>This workspace does not support opening and closing documents.</source>
        <target state="translated">이 작업 영역에서는 문서 열기 및 닫기를 지원하지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Exceptions_colon">
        <source>Exceptions:</source>
        <target state="translated">예외:</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_returned_an_uninitialized_ImmutableArray">
        <source>'{0}' returned an uninitialized ImmutableArray</source>
        <target state="translated">'{0}'에서 초기화되지 않은 ImmutableArray를 반환했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Failure">
        <source>Failure</source>
        <target state="translated">실패</target>
        <note />
      </trans-unit>
      <trans-unit id="Warning">
        <source>Warning</source>
        <target state="translated">경고</target>
        <note />
      </trans-unit>
      <trans-unit id="Populate_switch">
        <source>Populate switch</source>
        <target state="translated">스위치 채우기</target>
        <note />
      </trans-unit>
      <trans-unit id="Member_access_should_be_qualified">
        <source>Member access should be qualified.</source>
        <target state="translated">멤버 액세스를 한정해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Add_braces_to_0_statement">
        <source>Add braces to '{0}' statement.</source>
        <target state="translated">{0}' 문에 중괄호를 추가합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Enable">
        <source>Enable</source>
        <target state="translated">사용</target>
        <note />
      </trans-unit>
      <trans-unit id="Enable_and_ignore_future_errors">
        <source>Enable and ignore future errors</source>
        <target state="translated">추가 오류 무시하고 사용</target>
        <note />
      </trans-unit>
      <trans-unit id="_0_encountered_an_error_and_has_been_disabled">
        <source>'{0}' encountered an error and has been disabled.</source>
        <target state="translated">'{0}'에 오류가 발생하여 사용할 수 없습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Show_Stack_Trace">
        <source>Show Stack Trace</source>
        <target state="translated">스택 추적 표시</target>
        <note />
      </trans-unit>
      <trans-unit id="Stream_is_too_long">
        <source>Stream is too long.</source>
        <target state="translated">스트림이 너무 깁니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Deserialization_reader_for_0_read_incorrect_number_of_values">
        <source>Deserialization reader for '{0}' read incorrect number of values.</source>
        <target state="translated">{0}'에 대한 역직렬화 판독기가 잘못된 숫자 값을 읽습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Pascal_Case">
        <source>Pascal Case</source>
        <target state="translated">파스칼식 대/소문자</target>
        <note />
      </trans-unit>
      <trans-unit id="Abstract_Method">
        <source>Abstract Method</source>
        <target state="translated">추상 메서드</target>
        <note>{locked: abstract}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Async_Method">
        <source>Async Method</source>
        <target state="translated">비동기 메서드</target>
        <note>{locked: async}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Begins_with_I">
        <source>Begins with I</source>
        <target state="translated">I로 시작</target>
        <note>{locked:I}</note>
      </trans-unit>
      <trans-unit id="Class">
        <source>Class</source>
        <target state="new">Class</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Delegate">
        <source>Delegate</source>
        <target state="new">Delegate</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Enum">
        <source>Enum</source>
        <target state="new">Enum</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Event">
        <source>Event</source>
        <target state="new">Event</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Interface">
        <source>Interface</source>
        <target state="new">Interface</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Non_Field_Members">
        <source>Non-Field Members</source>
        <target state="translated">필드가 아닌 멤버</target>
        <note>{locked:field}</note>
      </trans-unit>
      <trans-unit id="Private_Method">
        <source>Private Method</source>
        <target state="translated">프라이빗 메서드</target>
        <note>{locked: private}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Private_or_Internal_Field">
        <source>Private or Internal Field</source>
        <target state="translated">프라이빗 또는 내부 필드</target>
        <note>{locked: private}{locked: internal}{locked:field}</note>
      </trans-unit>
      <trans-unit id="Private_or_Internal_Static_Field">
        <source>Private or Internal Static Field</source>
        <target state="translated">프라이빗 또는 내부 정적 필드</target>
        <note>{locked: private}{locked: internal}{locked:static}{locked:field}</note>
      </trans-unit>
      <trans-unit id="Property">
        <source>Property</source>
        <target state="new">Property</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Public_or_Protected_Field">
        <source>Public or Protected Field</source>
        <target state="translated">공용 또는 보호된 필드</target>
        <note>{locked: public}{locked: protected}{locked:field}</note>
      </trans-unit>
      <trans-unit id="Static_Field">
        <source>Static Field</source>
        <target state="translated">정적 필드</target>
        <note>{locked:static}{locked:field} (unless the capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Static_Method">
        <source>Static Method</source>
        <target state="translated">정적 메서드</target>
        <note>{locked: static}{locked: method} These are keywords (unless the order of words or capitalization should be handled differently)</note>
      </trans-unit>
      <trans-unit id="Struct">
        <source>Struct</source>
        <target state="new">Struct</target>
        <note>{locked} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Types">
        <source>Types</source>
        <target state="translated">형식</target>
        <note>{locked:types} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Method">
        <source>Method</source>
        <target state="translated">메서드</target>
        <note>{locked:method} unless the capitalization should be handled differently</note>
      </trans-unit>
      <trans-unit id="Missing_prefix_colon_0">
        <source>Missing prefix: '{0}'</source>
        <target state="translated">누락된 접두사: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="Error">
        <source>Error</source>
        <target state="translated">오류</target>
        <note />
      </trans-unit>
      <trans-unit id="None">
        <source>None</source>
        <target state="translated">None</target>
        <note />
      </trans-unit>
      <trans-unit id="Missing_suffix_colon_0">
        <source>Missing suffix: '{0}'</source>
        <target state="translated">누락된 접미사: '{0}'</target>
        <note />
      </trans-unit>
      <trans-unit id="These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0">
        <source>These non-leading words must begin with an upper case letter: {0}</source>
        <target state="translated">이러한 맨 앞에 있지 않는 단어는 대문자로 시작해야 합니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="Suggestion">
        <source>Suggestion</source>
        <target state="translated">제안</target>
        <note />
      </trans-unit>
      <trans-unit id="These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0">
        <source>These non-leading words must begin with a lowercase letter: {0}</source>
        <target state="translated">이러한 맨 앞에 있지 않는 단어는 소문자로 시작해야 합니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="These_words_cannot_contain_lower_case_characters_colon_0">
        <source>These words cannot contain lower case characters: {0}</source>
        <target state="translated">이러한 단어에는 소문자를 사용할 수 없습니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="These_words_cannot_contain_upper_case_characters_colon_0">
        <source>These words cannot contain upper case characters: {0}</source>
        <target state="translated">이러한 단어에는 대문자를 사용할 수 없습니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="These_words_must_begin_with_upper_case_characters_colon_0">
        <source>These words must begin with upper case characters: {0}</source>
        <target state="translated">이러한 단어는 대문자로 시작해야 합니다. {0}</target>
        <note />
      </trans-unit>
      <trans-unit id="The_first_word_0_must_begin_with_an_upper_case_character">
        <source>The first word, '{0}', must begin with an upper case character</source>
        <target state="translated">첫 번째 단어 '{0}'은(는) 대문자로 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="The_first_word_0_must_begin_with_a_lower_case_character">
        <source>The first word, '{0}', must begin with a lower case character</source>
        <target state="translated">첫 번째 단어 '{0}'은(는) 소문자로 시작해야 합니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="File_0_size_of_1_exceeds_maximum_allowed_size_of_2">
        <source>File '{0}' size of {1} exceeds maximum allowed size of {2}</source>
        <target state="translated">파일 '{0}'의 크기({1})가 최대 허용되는 크기({2})를 초과했습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Changing_document_property_is_not_supported">
        <source>Changing document properties is not supported</source>
        <target state="translated">문서 속성 변경은 지원되지 않습니다.</target>
        <note />
      </trans-unit>
      <trans-unit id="Alternation_conditions_cannot_be_comments">
        <source>Alternation conditions cannot be comments</source>
        <target state="translated">교체 조건은 주석이 될 수 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a|(?#b)</note>
      </trans-unit>
      <trans-unit id="Alternation_conditions_do_not_capture_and_cannot_be_named">
        <source>Alternation conditions do not capture and cannot be named</source>
        <target state="translated">교체 조건은 캡처하지 않고 이름을 지정할 수 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(?'x'))</note>
      </trans-unit>
      <trans-unit id="A_subtraction_must_be_the_last_element_in_a_character_class">
        <source>A subtraction must be the last element in a character class</source>
        <target state="translated">빼기는 문자 클래스의 마지막 요소여야 합니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-[b]-c]</note>
      </trans-unit>
      <trans-unit id="Cannot_include_class_0_in_character_range">
        <source>Cannot include class \{0} in character range</source>
        <target state="translated">문자 범위에 \{0} 클래스를 포함할 수 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [a-\w]. {0} is the invalid class (\w here)</note>
      </trans-unit>
      <trans-unit id="Capture_group_numbers_must_be_less_than_or_equal_to_Int32_MaxValue">
        <source>Capture group numbers must be less than or equal to Int32.MaxValue</source>
        <target state="translated">캡처 그룹 번호는 Int32.MaxValue보다 작거나 같아야 합니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{2147483648}</note>
      </trans-unit>
      <trans-unit id="Capture_number_cannot_be_zero">
        <source>Capture number cannot be zero</source>
        <target state="translated">캡처 번호는 0일 수 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;0&gt;a)</note>
      </trans-unit>
      <trans-unit id="Illegal_backslash_at_end_of_pattern">
        <source>Illegal \ at end of pattern</source>
        <target state="translated">패턴 끝에 \를 사용할 수 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \</note>
      </trans-unit>
      <trans-unit id="Illegal_x_y_with_x_less_than_y">
        <source>Illegal {x,y} with x &gt; y</source>
        <target state="translated">x &gt; y인 잘못된 {x,y}입니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a{1,0}</note>
      </trans-unit>
      <trans-unit id="Incomplete_character_escape">
        <source>Incomplete \p{X} character escape</source>
        <target state="translated">불완전한 \p{X} 문자 이스케이프</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{ Cc }</note>
      </trans-unit>
      <trans-unit id="Insufficient_hexadecimal_digits">
        <source>Insufficient hexadecimal digits</source>
        <target state="translated">16진수가 부족합니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \x</note>
      </trans-unit>
      <trans-unit id="Invalid_group_name_Group_names_must_begin_with_a_word_character">
        <source>Invalid group name: Group names must begin with a word character</source>
        <target state="translated">잘못된 그룹 이름: 그룹 이름은 단어 문자로 시작해야 합니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;a &gt;a)</note>
      </trans-unit>
      <trans-unit id="Malformed">
        <source>malformed</source>
        <target state="translated">형식이 잘못되었습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0</note>
      </trans-unit>
      <trans-unit id="Malformed_character_escape">
        <source>Malformed \p{X} character escape</source>
        <target state="translated">형식이 잘못된 \p{X} 문자 이스케이프</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p {Cc}</note>
      </trans-unit>
      <trans-unit id="Malformed_named_back_reference">
        <source>Malformed \k&lt;...&gt; named back reference</source>
        <target state="translated">\k&lt;...&gt; 역참조 형식이 잘못되었습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k'</note>
      </trans-unit>
      <trans-unit id="Missing_control_character">
        <source>Missing control character</source>
        <target state="translated">제어 문자가 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \c</note>
      </trans-unit>
      <trans-unit id="Nested_quantifier_0">
        <source>Nested quantifier {0}</source>
        <target state="translated">중첩 수량자 {0}입니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: a**. In this case {0} will be '*', the extra unnecessary quantifier.</note>
      </trans-unit>
      <trans-unit id="Not_enough_close_parens">
        <source>Not enough )'s</source>
        <target state="translated">부족 )'s</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (a</note>
      </trans-unit>
      <trans-unit id="Quantifier_x_y_following_nothing">
        <source>Quantifier {x,y} following nothing</source>
        <target state="translated">수량자 {x,y} 앞에 아무 것도 없습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: *</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group">
        <source>reference to undefined group</source>
        <target state="translated">정의되지 않은 그룹에 대한 참조</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(1))</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_name_0">
        <source>Reference to undefined group name {0}</source>
        <target state="translated">정의되지 않은 그룹 이름 {0}에 대한 참조입니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \k&lt;a&gt;. Here, {0} will be the name of the undefined group ('a')</note>
      </trans-unit>
      <trans-unit id="Reference_to_undefined_group_number_0">
        <source>Reference to undefined group number {0}</source>
        <target state="translated">정의되지 않은 그룹 번호 {0}을(를) 참조합니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;-1&gt;). Here, {0} will be the number of the undefined group ('1')</note>
      </trans-unit>
      <trans-unit id="Too_many_bars_in_conditional_grouping">
        <source>Too many | in (?()|)</source>
        <target state="translated">(?()|)에 |가 너무 많습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?(0)a|b|)</note>
      </trans-unit>
      <trans-unit id="Too_many_close_parens">
        <source>Too many )'s</source>
        <target state="translated">)가 너무 많습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: )</note>
      </trans-unit>
      <trans-unit id="Unknown_property">
        <source>Unknown property</source>
        <target state="translated">알 수 없는 속성</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{}</note>
      </trans-unit>
      <trans-unit id="Unknown_property_0">
        <source>Unknown property '{0}'</source>
        <target state="translated">알 수 없는 속성 '{0}'</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \p{xxx}. Here, {0} will be the name of the unknown property ('xxx')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_control_character">
        <source>Unrecognized control character</source>
        <target state="translated">인식할 수 없는 제어 문자입니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [\c]</note>
      </trans-unit>
      <trans-unit id="Unrecognized_escape_sequence_0">
        <source>Unrecognized escape sequence \{0}</source>
        <target state="translated">인식할 수 없는 이스케이프 시퀀스 \{0}입니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: \m. Here, {0} will be the unrecognized character ('m')</note>
      </trans-unit>
      <trans-unit id="Unrecognized_grouping_construct">
        <source>Unrecognized grouping construct</source>
        <target state="translated">인식할 수 없는 그룹화 생성자입니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?&lt;</note>
      </trans-unit>
      <trans-unit id="Unterminated_character_class_set">
        <source>Unterminated [] set</source>
        <target state="translated">종결되지 않은 [] 집합</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [</note>
      </trans-unit>
      <trans-unit id="Unterminated_regex_comment">
        <source>Unterminated (?#...) comment</source>
        <target state="translated">종격되지 않은 (?#...) 주석</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: (?#</note>
      </trans-unit>
      <trans-unit id="dot_NET_Coding_Conventions">
        <source>.NET Coding Conventions</source>
        <target state="translated">.NET 코딩 규칙</target>
        <note />
      </trans-unit>
      <trans-unit id="x_y_range_in_reverse_order">
        <source>[x-y] range in reverse order</source>
        <target state="translated">[x-y] 범위가 역순으로 되어 있습니다.</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. Example: [b-a]</note>
      </trans-unit>
      <trans-unit id="Variables_captured_colon">
        <source>Variables captured:</source>
        <target state="translated">캡처된 변수:</target>
        <note />
      </trans-unit>
      <trans-unit id="Regex_issue_0">
        <source>Regex issue: {0}</source>
        <target state="translated">Regex 문제: {0}</target>
        <note>This is an error message shown to the user when they write an invalid Regular Expression. {0} will be the actual text of one of the above Regular Expression errors.</note>
      </trans-unit>
    </body>
  </file>
</xliff>