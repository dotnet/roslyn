<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TypesThatOwnDisposableFieldsShouldBeDisposable" xml:space="preserve">
    <value>Types that own disposable fields should be disposable</value>
  </data>
  <data name="CategoryDesign" xml:space="preserve">
    <value>Design</value>
  </data>
  <data name="CategoryGlobalization" xml:space="preserve">
    <value>Globalization</value>
  </data>
  <data name="CategoryInteroperability" xml:space="preserve">
    <value>Interoperability</value>
  </data>
  <data name="CategoryNaming" xml:space="preserve">
    <value>Naming</value>
  </data>
  <data name="CategoryPerformance" xml:space="preserve">
    <value>Performance</value>
  </data>
  <data name="CategoryReliability" xml:space="preserve">
    <value>Reliability</value>
  </data>
  <data name="CategoryUsage" xml:space="preserve">
    <value>Usage</value>
  </data>
  <data name="ImplementIDisposableInterface" xml:space="preserve">
    <value>Implement IDisposable Interface</value>
  </data>
  <data name="TypeOwnsDisposableFieldButIsNotDisposable" xml:space="preserve">
    <value>Type '{0}' owns disposable fields but is not disposable</value>
  </data>
  <data name="CustomAttrShouldHaveAttributeUsage" xml:space="preserve">
    <value>Custom attributes should have AttributeUsage attribute defined.</value>
  </data>
  <data name="MarkAttributesWithAttributeUsage" xml:space="preserve">
    <value>Specify AttributeUsage attribute on '{0}' attribute class.</value>
  </data>
  <data name="DefineAccessorsForAttributeArguments" xml:space="preserve">
    <value>Define accessors for attribute arguments.</value>
  </data>
  <data name="DefineAccessorsForAttributeArgumentsDefault" xml:space="preserve">
    <value>Add a public read-only property accessor for positional argument '{0}' of attribute '{1}'.</value>
  </data>
  <data name="DefineAccessorsForAttributeArgumentsIncreaseVisibility" xml:space="preserve">
    <value>If '{0}' is the property accessor for positional argument '{1}', ensure that property getter is public.</value>
  </data>
  <data name="DefineAccessorsForAttributeArgumentsRemoveSetter" xml:space="preserve">
    <value>Remove the property setter from '{0}' or reduce its accessibility because it corresponds to positional argument '{1}'.</value>
  </data>
  <data name="OverloadOperatorEqualsOnIComparableInterface" xml:space="preserve">
    <value>Overload operator Equals and comparison operators when implementing System.IComparable</value>
  </data>
  <data name="OverloadOperatorEqualsOnIComparableInterfaceDescription" xml:space="preserve">
    <value>Types that implement IComparable should redefine Equals and comparison operators to keep the meanings of less than, greater than, and equals consistent throughout the type.</value>
  </data>
  <data name="CreatePropertyAccessorForParameter" xml:space="preserve">
    <value>Create a property accessor.</value>
  </data>
  <data name="ImplementComparable" xml:space="preserve">
    <value>Implement Equality and Comparison methods and operators</value>
  </data>
  <data name="MakeGetterPublic" xml:space="preserve">
    <value>Make the getter of the property public</value>
  </data>
  <data name="MakeSetterNonPublic" xml:space="preserve">
    <value>Make the setter of the property non-public</value>
  </data>
  <data name="OverloadOperatorEqualsOnOverridingValueTypeEquals" xml:space="preserve">
    <value>Overload operator equals on overriding ValueType.Equals</value>
  </data>
  <data name="OverloadOperatorEqualsOnOverridingValueTypeEqualsDescription" xml:space="preserve">
    <value>Value types that redefine System.ValueType.Equals should redefine the equality operator as well to ensure that these members return the same results. This helps ensure that types that rely on Equals (such as ArrayList and Hashtable) behave in a manner that is expected and consistent with the equality operator.</value>
  </data>
  <data name="OverloadOperatorEqualsOnOverridingValueTypeEquals1" xml:space="preserve">
    <value>Overload operator equals on overriding ValueType.Equals</value>
  </data>
  <data name="MarkAssembliesWithCLSCompliantAttribute" xml:space="preserve">
    <value>Mark assemblies with CLSCompliantAttribute</value>
  </data>
  <data name="MarkAssembliesWithCLSCompliantDescription" xml:space="preserve">
    <value>Assemblies should explicitly state their CLS compliance using the CLSCompliant attribute. An assembly without this attribute is not CLS-compliant. Assemblies, modules, and types can be CLS-compliant even if some parts of the assembly, module, or type are not CLS-compliant. The following rules apply: 1) If the element is marked CLSCompliant, any noncompliant members must have the CLSCompliant attribute present with its argument set to false. 2) A comparable CLS-compliant alternative member must be supplied for each member that is not CLS-compliant.</value>
  </data>
  <data name="AssembliesShouldBeMarkedWithAssemblyVersionAttribute" xml:space="preserve">
    <value>Assemblies should be marked with AssemblyVersionAttribute</value>
  </data>
  <data name="MarkAllAssembliesWithComVisible" xml:space="preserve">
    <value>Mark all assemblies with ComVisible</value>
  </data>
  <data name="MarkAllAssembliesWithComVisibleDescription" xml:space="preserve">
    <value>The System.Runtime.InteropServices.ComVisible attribute indicates whether COM clients can use the library. Good design dictates that developers explicitly indicate COM visibility. The default value for this attribute is 'true'. However, the best design is to mark the assembly ComVisible false, and then mark types, interfaces, and individual members as ComVisible true, as appropriate.</value>
  </data>
  <data name="ChangeAssemblyLevelComVisibleToFalse" xml:space="preserve">
    <value>Consider changing the ComVisible attribute on {0} to false, and opting in at the type level.</value>
  </data>
  <data name="AddAssemblyLevelComVisibleFalse" xml:space="preserve">
    <value>Because {0} exposes externally visible types, mark it with ComVisible(false) at the assembly level and then mark all types within the assembly that should be exposed to COM clients with ComVisible(true).</value>
  </data>
  <data name="AvoidUnsealedAttributes" xml:space="preserve">
    <value>Avoid unsealed attributes.</value>
  </data>
  <data name="SealAttributeTypesForImprovedPerf" xml:space="preserve">
    <value>Seal attribute types for improved performance. Sealing attribute types speeds up performance during reflection on custom attributes.</value>
  </data>
  <data name="AvoidUnsealedAttributesCodeFix" xml:space="preserve">
    <value>Seal attribute type.</value>
  </data>
  <data name="StringComparisonShouldBeOrdinalDescription" xml:space="preserve">
    <value>For non-linguistic comparisons, StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase should be used instead of the linguistically-sensitive StringComparison.InvariantCulture.</value>
  </data>
  <data name="StringComparisonShouldBeOrdinalOrOrdinalIgnoreCase" xml:space="preserve">
    <value>String comparison should use StringComparison.Ordinal or StringComparison.OrdinalIgnoreCase</value>
  </data>
  <data name="TestForEmptyStringsUsingStringLengthDescription" xml:space="preserve">
    <value>Comparing strings using the string.Length property or the string.IsNullOrEmpty method is significantly faster than using string.Equals. This is because Equals executes significantly more MSIL instructions than either IsNullOrEmpty or the number of instructions executed to retrieve the Length property value and compare it to zero.</value>
  </data>
  <data name="TestForEmptyStringsUsingStringLength" xml:space="preserve">
    <value>Test for empty strings using 'string.Length' property or 'string.IsNullOrEmpty' method instead of an Equality check.</value>
  </data>
  <data name="DisposableFieldsShouldBeDisposed" xml:space="preserve">
    <value>Disposable fields should be disposed</value>
  </data>
  <data name="DoNotMarkEnumsWithFlags" xml:space="preserve">
    <value>Do not mark Enum with FlagsAttribute</value>
  </data>
  <data name="DoNotMarkEnumsWithFlagsDescription" xml:space="preserve">
    <value>The enumeration does not appear to contain a consistent set values that can be combined using  the OR (|) and AND (&amp;amp;amp;amp;) operators. Using the Flags attribute on an enumeration suggests that the enumeration values are meant to be combined using the AND and OR operators. Typically, a flags enumeration uses values that are either powers of two, or combine other values that are powers of two.</value>
  </data>
  <data name="DoNotMarkEnumsWithFlagsMessage" xml:space="preserve">
    <value>'{0}' is marked with FlagsAttribute but a discrete member cannot be found for every settable bit that is used across the range of enum values. Remove FlagsAttribute from the type or define new members for the following (currently missing) values: '{1}'.</value>
  </data>
  <data name="MarkEnumsWithFlags" xml:space="preserve">
    <value>Mark Enum with FlagsAttribute</value>
  </data>
  <data name="MarkEnumsWithFlagsDescription" xml:space="preserve">
    <value>The enumeration appears to be made up of combinable flags. If this true, apply the Flags attribute to the enumeration.</value>
  </data>
  <data name="MarkEnumsWithFlagsMessage" xml:space="preserve">
    <value>The constituent members of '{0}' appear to represent flags that can be combined rather than discrete values. If this is correct, mark the enumeration with FlagsAttribute.</value>
  </data>
  <data name="DoNotMarkEnumsWithFlagsCodeFix" xml:space="preserve">
    <value>Remove FlagsAttribute from enum.</value>
  </data>
  <data name="MarkEnumsWithFlagsCodeFix" xml:space="preserve">
    <value>Apply FlagsAttribute to enum.</value>
  </data>
  <data name="DoNotLockOnObjectsWithWeakIdentity" xml:space="preserve">
    <value>Do not lock on objects with weak identity.</value>
  </data>
  <data name="DoNotLockOnWeakIdentity" xml:space="preserve">
    <value>Do not lock on a reference of type '{0}' as it has weak identity. Replace that with a lock against an object with strong identity.</value>
  </data>
  <data name="UseGenericEventHandlerInstances" xml:space="preserve">
    <value>Use System.EventHandler&lt;T&gt; where T inherits System.EventArgs or use System.EventHandler</value>
  </data>
</root>