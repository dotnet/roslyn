<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="TypeOwnsDisposableFieldButIsNotDisposable" xml:space="preserve">
    <value>Type '{0}' owns disposable fields but is not disposable</value>
  </data>
  <data name="TypeIsAbstractButHasPublicConstructors" xml:space="preserve">
    <value>Type '{0}' is abstract but has public constructors</value>
  </data>
  <data name="DoNotCallOverridableMethodsInConstructors" xml:space="preserve">
    <value>Do not call overridable methods in constructors</value>
  </data>
  <data name="StaticHolderTypeIsNotStatic" xml:space="preserve">
    <value>Type '{0}' is a static holder type but is neither static nor NotInheritable</value>
  </data>
  <data name="RethrowException" xml:space="preserve">
    <value>Re-throwing caught exception changes stack information.</value>
  </data>
  <data name="AddSerializableAttributeToType" xml:space="preserve">
    <value>Add [Serializable] to {0} as this type implements ISerializable</value>
  </data>
  <data name="FieldIsOfNonSerializableType" xml:space="preserve">
    <value>Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable</value>
  </data>
  <data name="SerializableTypeDoesntHaveCtor" xml:space="preserve">
    <value>Serializable type {0} doesn't have a serialization constructor</value>
  </data>
  <data name="SerializationCtorAccessibilityForSealedType" xml:space="preserve">
    <value>Declare serialization constructor for sealed type {0} as private</value>
  </data>
  <data name="SerializationCtorAccessibilityForUnSealedType" xml:space="preserve">
    <value>Declare serialization constructor for unsealed type {0} as protected</value>
  </data>
  <data name="RemoveEmptyFinalizers" xml:space="preserve">
    <value>Remove empty finalizers</value>
  </data>
  <data name="DoNotLockOnWeakIdentity" xml:space="preserve">
    <value>Do not lock on a reference of type '{0}' as it has weak identity. Replace that with a lock against an object with strong identity.</value>
  </data>
  <data name="EnumsShouldZeroValueFlagsRename" xml:space="preserve">
    <value>In enum '{0}', change the name of '{1}' to 'None'.</value>
  </data>
  <data name="EnumsShouldZeroValueFlagsMultipleZero" xml:space="preserve">
    <value>Remove all members that have the value zero from '{0}' except for one member that is named 'None'.</value>
  </data>
  <data name="EnumsShouldZeroValueNotFlagsNoZeroValue" xml:space="preserve">
    <value>Add a member to '{0}' that has a value of zero with a suggested name of 'None'.</value>
  </data>
  <data name="ChangeToAPropertyIfAppropriate" xml:space="preserve">
    <value>Change '{0}' to a property if appropriate.</value>
  </data>
  <data name="ImplementSerializationConstructor" xml:space="preserve">
    <value>Implement Serialization constructor</value>
  </data>
  <data name="IdentifierNamesShouldDifferMoreThanCase" xml:space="preserve">
    <value>{0} '{1}' have identical names in a case-insensitive manner.</value>
  </data>
  <data name="StaticHolderTypesShouldNotHaveConstructorsMessage" xml:space="preserve">
    <value>Type '{0}' is a static holder type and should not contain Instance Constructors</value>
  </data>
  <data name="DoNotLockOnObjectsWithWeakIdentity" xml:space="preserve">
    <value>Do not lock on objects with weak identity.</value>
  </data>
  <data name="EnumsShouldHaveZeroValue" xml:space="preserve">
    <value>Enums should have zero value.</value>
  </data>
  <data name="MarkAllNonSerializableFields" xml:space="preserve">
    <value>Mark all non-serializable fields.</value>
  </data>
  <data name="MarkISerializableTypesWithAttribute" xml:space="preserve">
    <value>Mark ISerializable types with SerializableAttribute.</value>
  </data>
  <data name="RethrowToPreserveStackDetails" xml:space="preserve">
    <value>Rethrow to preserve stack details.</value>
  </data>
  <data name="UsePropertiesWhereAppropriate" xml:space="preserve">
    <value>Use properties where appropriate.</value>
  </data>
  <data name="AbstractTypesShouldNotHavePublicConstructorsCodeFix" xml:space="preserve">
    <value>Change the accessibility of all public contructors in this class to protected.</value>
  </data>
  <data name="IdentifiersShouldDifferByMoreThanCase" xml:space="preserve">
    <value>Identifier names should differ by more than case</value>
  </data>
  <data name="AbstractTypesShouldNotHavePublicConstructors" xml:space="preserve">
    <value>Abstract classes should not have public constructors</value>
  </data>
  <data name="StaticHolderTypesShouldBeStaticOrNotInheritable" xml:space="preserve">
    <value>Static holder types should be Static or NotInheritable</value>
  </data>
  <data name="StaticHolderTypesShouldNotHaveConstructors" xml:space="preserve">
    <value>Static holder types should not have instance constructors</value>
  </data>
  <data name="TypesThatOwnDisposableFieldsShouldBeDisposable" xml:space="preserve">
    <value>Types that own disposable fields should be disposable</value>
  </data>
  <data name="InterfaceNamesShouldStartWithI" xml:space="preserve">
    <value>Interface names should be prefixed with 'I'</value>
  </data>
  <data name="TypeParameterNamesShouldStartWithT" xml:space="preserve">
    <value>Type parameter names should be prefixed with 'T'</value>
  </data>
  <data name="UseGenericEventHandlerInstances" xml:space="preserve">
    <value>Use System.EventHandler&lt;T&gt; where T inherits System.EventArgs or use System.EventHandler</value>
  </data>
  <data name="EnumsShouldHaveZeroValueDescription" xml:space="preserve">
    <value>An enum should generally have a zero value. If the enum is not decorated with the Flags attribute, it should have a member with a value of zero that represents the empty state. Optionally, this value is named 'None'. For a Flags-attributed enum, a zero-valued member is optional and, if it exists, should always be named 'None'. This value should indicate that no values have been set in the enum. Using a zero-valued member for other purposes is contrary to the use of the Flags attribute in that the bitwise AND and OR operators are useless with the member.</value>
  </data>
  <data name="UsePropertiesWhereAppropriateDescription" xml:space="preserve">
    <value>Properties should be used instead of Get/Set methods in most situations. Methods are preferable to properties in the following situations: the operation is a conversion, is expensive or has an observable side-effect; the order of execution is important; calling the member twice in succession creates different results; a member is static but returns a mutable value; or the member returns an array.</value>
  </data>
  <data name="DoNotCallOverridableMethodsInConstructorsDescription" xml:space="preserve">
    <value>Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called).</value>
  </data>
  <data name="IdentifiersShouldDifferByMoreThanCaseDescription" xml:space="preserve">
    <value>Do not use names that require case sensitivity for uniqueness. Components must be fully usable from both case-sensitive and case-insensitive languages. Since case-insensitive languages cannot distinguish between two names within the same context that differ only by case, components must avoid this situation.</value>
  </data>
  <data name="ImplementSerializationConstructorDescription" xml:space="preserve">
    <value>The constructor signature accepts the same arguments as ISerializable.GetObjectData, namely, a SerializationInfo instance and a StreamingContext instance. The constructor should be protected for non-sealed classes and private for sealed classes. Failure to implement a serialization constructor will cause deserialization to fail, and throw a SerializationException.</value>
  </data>
  <data name="MarkAllNonSerializableFieldsDescription" xml:space="preserve">
    <value>All fields that cannot be serialized directly should have the NonSerializedAttribute. Types that have the SerializableAttribute should not have fields of types that do not have the SerializableAttribute unless the fields are marked with the NonSerializedAttribute.</value>
  </data>
  <data name="MarkISerializableTypesWithAttributeDescription" xml:space="preserve">
    <value>The System.Runtime.Serialization.ISerializable interface allows the type to customize its serialization, while the Serializable attribute enables the runtime to recognize the type as being serializable.</value>
  </data>
  <data name="RemoveEmptyFinalizersDescription" xml:space="preserve">
    <value>Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime.</value>
  </data>
  <data name="CategoryDesign" xml:space="preserve">
    <value>Design</value>
  </data>
  <data name="CategoryGlobalization" xml:space="preserve">
    <value>Globalization</value>
  </data>
  <data name="CategoryInteroperability" xml:space="preserve">
    <value>Interoperability</value>
  </data>
  <data name="CategoryNaming" xml:space="preserve">
    <value>Naming</value>
  </data>
  <data name="CategoryPerformance" xml:space="preserve">
    <value>Performance</value>
  </data>
  <data name="CategoryReliability" xml:space="preserve">
    <value>Reliability</value>
  </data>
  <data name="CategoryUsage" xml:space="preserve">
    <value>Usage</value>
  </data>
</root>