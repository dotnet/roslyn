//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.AnalyzerPowerPack {
    using System;
    using System.Reflection;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    public class AnalyzerPowerPackRulesResources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal AnalyzerPowerPackRulesResources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.AnalyzerPowerPack.AnalyzerPowerPackRulesResources", typeof(AnalyzerPowerPackRulesResources).GetTypeInfo().Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        public static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Abstract classes should not have public constructors.
        /// </summary>
        public static string AbstractTypesShouldNotHavePublicConstructors {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHavePublicConstructors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change the accessibility of all public constructors in this class to protected..
        /// </summary>
        public static string AbstractTypesShouldNotHavePublicConstructorsCodeFix {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHavePublicConstructorsCodeFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add [Serializable] to {0} as this type implements ISerializable.
        /// </summary>
        public static string AddSerializableAttributeToType {
            get {
                return ResourceManager.GetString("AddSerializableAttributeToType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Design.
        /// </summary>
        public static string CategoryDesign {
            get {
                return ResourceManager.GetString("CategoryDesign", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Globalization.
        /// </summary>
        public static string CategoryGlobalization {
            get {
                return ResourceManager.GetString("CategoryGlobalization", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Interoperability.
        /// </summary>
        public static string CategoryInteroperability {
            get {
                return ResourceManager.GetString("CategoryInteroperability", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Naming.
        /// </summary>
        public static string CategoryNaming {
            get {
                return ResourceManager.GetString("CategoryNaming", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Performance.
        /// </summary>
        public static string CategoryPerformance {
            get {
                return ResourceManager.GetString("CategoryPerformance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Reliability.
        /// </summary>
        public static string CategoryReliability {
            get {
                return ResourceManager.GetString("CategoryReliability", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Usage.
        /// </summary>
        public static string CategoryUsage {
            get {
                return ResourceManager.GetString("CategoryUsage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change &apos;{0}&apos; to a property if appropriate..
        /// </summary>
        public static string ChangeToAPropertyIfAppropriate {
            get {
                return ResourceManager.GetString("ChangeToAPropertyIfAppropriate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not call overridable methods in constructors.
        /// </summary>
        public static string DoNotCallOverridableMethodsInConstructors {
            get {
                return ResourceManager.GetString("DoNotCallOverridableMethodsInConstructors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called)..
        /// </summary>
        public static string DoNotCallOverridableMethodsInConstructorsDescription {
            get {
                return ResourceManager.GetString("DoNotCallOverridableMethodsInConstructorsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enums should have zero value..
        /// </summary>
        public static string EnumsShouldHaveZeroValue {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An enum should generally have a zero value. If the enum is not decorated with the Flags attribute, it should have a member with a value of zero that represents the empty state. Optionally, this value is named &apos;None&apos;. For a Flags-attributed enum, a zero-valued member is optional and, if it exists, should always be named &apos;None&apos;. This value should indicate that no values have been set in the enum. Using a zero-valued member for other purposes is contrary to the use of the Flags attribute in that the bitwise AN [rest of string was truncated]&quot;;.
        /// </summary>
        public static string EnumsShouldHaveZeroValueDescription {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValueDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove all members that have the value zero from &apos;{0}&apos; except for one member that is named &apos;None&apos;..
        /// </summary>
        public static string EnumsShouldZeroValueFlagsMultipleZero {
            get {
                return ResourceManager.GetString("EnumsShouldZeroValueFlagsMultipleZero", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In enum &apos;{0}&apos;, change the name of &apos;{1}&apos; to &apos;None&apos;..
        /// </summary>
        public static string EnumsShouldZeroValueFlagsRename {
            get {
                return ResourceManager.GetString("EnumsShouldZeroValueFlagsRename", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add a member to &apos;{0}&apos; that has a value of zero with a suggested name of &apos;None&apos;..
        /// </summary>
        public static string EnumsShouldZeroValueNotFlagsNoZeroValue {
            get {
                return ResourceManager.GetString("EnumsShouldZeroValueNotFlagsNoZeroValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable.
        /// </summary>
        public static string FieldIsOfNonSerializableType {
            get {
                return ResourceManager.GetString("FieldIsOfNonSerializableType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; have identical names in a case-insensitive manner..
        /// </summary>
        public static string IdentifierNamesShouldDifferMoreThanCase {
            get {
                return ResourceManager.GetString("IdentifierNamesShouldDifferMoreThanCase", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifier names should differ by more than case.
        /// </summary>
        public static string IdentifiersShouldDifferByMoreThanCase {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCase", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not use names that require case sensitivity for uniqueness. Components must be fully usable from both case-sensitive and case-insensitive languages. Since case-insensitive languages cannot distinguish between two names within the same context that differ only by case, components must avoid this situation..
        /// </summary>
        public static string IdentifiersShouldDifferByMoreThanCaseDescription {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCaseDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement Serialization constructor.
        /// </summary>
        public static string ImplementSerializationConstructor {
            get {
                return ResourceManager.GetString("ImplementSerializationConstructor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The constructor signature accepts the same arguments as ISerializable.GetObjectData, namely, a SerializationInfo instance and a StreamingContext instance. The constructor should be protected for non-sealed classes and private for sealed classes. Failure to implement a serialization constructor will cause deserialization to fail, and throw a SerializationException..
        /// </summary>
        public static string ImplementSerializationConstructorDescription {
            get {
                return ResourceManager.GetString("ImplementSerializationConstructorDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An unsealed externally visible type provides an explicit method implementation of a public interface and does not provide an alternative externally visible method that has the same name.
        ///Consider a base type that explicitly implements a public interface method. A type that derives from the base type can access the inherited interface method only through a reference to the current instance that is cast to the interface. If the derived type re-implements (explicitly) the inherited interface method, the base  [rest of string was truncated]&quot;;.
        /// </summary>
        public static string InterfaceMethodsShouldBeCallableByChildTypesDescription {
            get {
                return ResourceManager.GetString("InterfaceMethodsShouldBeCallableByChildTypesDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Make &apos;{0}&apos; sealed (a breaking change if this class has previously shipped), implement the method non-explicitly, or implement a new method that exposes the functionality of &apos;{1}&apos; and is visible to derived classes..
        /// </summary>
        public static string InterfaceMethodsShouldBeCallableByChildTypesMessage {
            get {
                return ResourceManager.GetString("InterfaceMethodsShouldBeCallableByChildTypesMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Interface methods should be callable by child types.
        /// </summary>
        public static string InterfaceMethodsShouldBeCallableByChildTypesTitle {
            get {
                return ResourceManager.GetString("InterfaceMethodsShouldBeCallableByChildTypesTitle", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Interface names should be prefixed with &apos;I&apos;.
        /// </summary>
        public static string InterfaceNamesShouldStartWithI {
            get {
                return ResourceManager.GetString("InterfaceNamesShouldStartWithI", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark all non-serializable fields..
        /// </summary>
        public static string MarkAllNonSerializableFields {
            get {
                return ResourceManager.GetString("MarkAllNonSerializableFields", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All fields that cannot be serialized directly should have the NonSerializedAttribute. Types that have the SerializableAttribute should not have fields of types that do not have the SerializableAttribute unless the fields are marked with the NonSerializedAttribute..
        /// </summary>
        public static string MarkAllNonSerializableFieldsDescription {
            get {
                return ResourceManager.GetString("MarkAllNonSerializableFieldsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark ISerializable types with SerializableAttribute..
        /// </summary>
        public static string MarkISerializableTypesWithAttribute {
            get {
                return ResourceManager.GetString("MarkISerializableTypesWithAttribute", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The System.Runtime.Serialization.ISerializable interface allows the type to customize its serialization, while the Serializable attribute enables the runtime to recognize the type as being serializable..
        /// </summary>
        public static string MarkISerializableTypesWithAttributeDescription {
            get {
                return ResourceManager.GetString("MarkISerializableTypesWithAttributeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove empty finalizers.
        /// </summary>
        public static string RemoveEmptyFinalizers {
            get {
                return ResourceManager.GetString("RemoveEmptyFinalizers", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime..
        /// </summary>
        public static string RemoveEmptyFinalizersDescription {
            get {
                return ResourceManager.GetString("RemoveEmptyFinalizersDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Re-throwing caught exception changes stack information..
        /// </summary>
        public static string RethrowException {
            get {
                return ResourceManager.GetString("RethrowException", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rethrow to preserve stack details..
        /// </summary>
        public static string RethrowToPreserveStackDetails {
            get {
                return ResourceManager.GetString("RethrowToPreserveStackDetails", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Serializable type {0} doesn&apos;t have a serialization constructor.
        /// </summary>
        public static string SerializableTypeDoesntHaveCtor {
            get {
                return ResourceManager.GetString("SerializableTypeDoesntHaveCtor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declare serialization constructor for sealed type {0} as private.
        /// </summary>
        public static string SerializationCtorAccessibilityForSealedType {
            get {
                return ResourceManager.GetString("SerializationCtorAccessibilityForSealedType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declare serialization constructor for unsealed type {0} as protected.
        /// </summary>
        public static string SerializationCtorAccessibilityForUnSealedType {
            get {
                return ResourceManager.GetString("SerializationCtorAccessibilityForUnSealedType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; is a static holder type but is neither static nor NotInheritable.
        /// </summary>
        public static string StaticHolderTypeIsNotStatic {
            get {
                return ResourceManager.GetString("StaticHolderTypeIsNotStatic", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static holder types should be Static or NotInheritable.
        /// </summary>
        public static string StaticHolderTypesShouldBeStaticOrNotInheritable {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldBeStaticOrNotInheritable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static holder types should not have instance constructors.
        /// </summary>
        public static string StaticHolderTypesShouldNotHaveConstructors {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldNotHaveConstructors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; is a static holder type and should not contain Instance Constructors.
        /// </summary>
        public static string StaticHolderTypesShouldNotHaveConstructorsMessage {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldNotHaveConstructorsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; is abstract but has public constructors.
        /// </summary>
        public static string TypeIsAbstractButHasPublicConstructors {
            get {
                return ResourceManager.GetString("TypeIsAbstractButHasPublicConstructors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; owns disposable fields but is not disposable.
        /// </summary>
        public static string TypeOwnsDisposableFieldButIsNotDisposable {
            get {
                return ResourceManager.GetString("TypeOwnsDisposableFieldButIsNotDisposable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type parameter names should be prefixed with &apos;T&apos;.
        /// </summary>
        public static string TypeParameterNamesShouldStartWithT {
            get {
                return ResourceManager.GetString("TypeParameterNamesShouldStartWithT", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types that own disposable fields should be disposable.
        /// </summary>
        public static string TypesThatOwnDisposableFieldsShouldBeDisposable {
            get {
                return ResourceManager.GetString("TypesThatOwnDisposableFieldsShouldBeDisposable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use properties where appropriate..
        /// </summary>
        public static string UsePropertiesWhereAppropriate {
            get {
                return ResourceManager.GetString("UsePropertiesWhereAppropriate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Properties should be used instead of Get/Set methods in most situations. Methods are preferable to properties in the following situations: the operation is a conversion, is expensive or has an observable side-effect; the order of execution is important; calling the member twice in succession creates different results; a member is static but returns a mutable value; or the member returns an array..
        /// </summary>
        public static string UsePropertiesWhereAppropriateDescription {
            get {
                return ResourceManager.GetString("UsePropertiesWhereAppropriateDescription", resourceCulture);
            }
        }
    }
}
