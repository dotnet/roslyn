//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.0
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

namespace Microsoft.CodeAnalysis.FxCopAnalyzers {
    using System;
    
    
    /// <summary>
    ///   A strongly-typed resource class, for looking up localized strings, etc.
    /// </summary>
    // This class was auto-generated by the StronglyTypedResourceBuilder
    // class via a tool like ResGen or Visual Studio.
    // To add or remove a member, edit your .ResX file then rerun ResGen
    // with the /str option, or rebuild your VS project.
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    [global::System.Runtime.CompilerServices.CompilerGeneratedAttribute()]
    internal class FxCopRulesResources {
        
        private static global::System.Resources.ResourceManager resourceMan;
        
        private static global::System.Globalization.CultureInfo resourceCulture;
        
        [global::System.Diagnostics.CodeAnalysis.SuppressMessageAttribute("Microsoft.Performance", "CA1811:AvoidUncalledPrivateCode")]
        internal FxCopRulesResources() {
        }
        
        /// <summary>
        ///   Returns the cached ResourceManager instance used by this class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Resources.ResourceManager ResourceManager {
            get {
                if (object.ReferenceEquals(resourceMan, null)) {
                    global::System.Resources.ResourceManager temp = new global::System.Resources.ResourceManager("Microsoft.CodeAnalysis.FxCopAnalyzers.FxCopRulesResources", typeof(FxCopRulesResources).Assembly);
                    resourceMan = temp;
                }
                return resourceMan;
            }
        }
        
        /// <summary>
        ///   Overrides the current thread's CurrentUICulture property for all
        ///   resource lookups using this strongly typed resource class.
        /// </summary>
        [global::System.ComponentModel.EditorBrowsableAttribute(global::System.ComponentModel.EditorBrowsableState.Advanced)]
        internal static global::System.Globalization.CultureInfo Culture {
            get {
                return resourceCulture;
            }
            set {
                resourceCulture = value;
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Abstract classes should not have public constructors.
        /// </summary>
        internal static string AbstractTypesShouldNotHavePublicConstructors {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHavePublicConstructors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change the accessibility of all public contructors in this class to protected..
        /// </summary>
        internal static string AbstractTypesShouldNotHavePublicConstructorsCodeFix {
            get {
                return ResourceManager.GetString("AbstractTypesShouldNotHavePublicConstructorsCodeFix", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add [Serializable] to {0} as this type implements ISerializable.
        /// </summary>
        internal static string AddSerializableAttributeToType {
            get {
                return ResourceManager.GetString("AddSerializableAttributeToType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Design.
        /// </summary>
        internal static string CategoryDesign {
            get {
                return ResourceManager.GetString("CategoryDesign", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Globalization.
        /// </summary>
        internal static string CategoryGlobalization {
            get {
                return ResourceManager.GetString("CategoryGlobalization", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Interoperability.
        /// </summary>
        internal static string CategoryInteroperability {
            get {
                return ResourceManager.GetString("CategoryInteroperability", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Naming.
        /// </summary>
        internal static string CategoryNaming {
            get {
                return ResourceManager.GetString("CategoryNaming", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Performance.
        /// </summary>
        internal static string CategoryPerformance {
            get {
                return ResourceManager.GetString("CategoryPerformance", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Reliability.
        /// </summary>
        internal static string CategoryReliability {
            get {
                return ResourceManager.GetString("CategoryReliability", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Usage.
        /// </summary>
        internal static string CategoryUsage {
            get {
                return ResourceManager.GetString("CategoryUsage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Change &apos;{0}&apos; to a property if appropriate..
        /// </summary>
        internal static string ChangeToAPropertyIfAppropriate {
            get {
                return ResourceManager.GetString("ChangeToAPropertyIfAppropriate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not call overridable methods in constructors.
        /// </summary>
        internal static string DoNotCallOverridableMethodsInConstructors {
            get {
                return ResourceManager.GetString("DoNotCallOverridableMethodsInConstructors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Virtual methods defined on the class should not be called from constructors. If a derived class has overridden the method, the derived class version will be called (before the derived class constructor is called)..
        /// </summary>
        internal static string DoNotCallOverridableMethodsInConstructorsDescription {
            get {
                return ResourceManager.GetString("DoNotCallOverridableMethodsInConstructorsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not lock on objects with weak identity..
        /// </summary>
        internal static string DoNotLockOnObjectsWithWeakIdentity {
            get {
                return ResourceManager.GetString("DoNotLockOnObjectsWithWeakIdentity", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not lock on a reference of type &apos;{0}&apos; as it has weak identity. Replace that with a lock against an object with strong identity..
        /// </summary>
        internal static string DoNotLockOnWeakIdentity {
            get {
                return ResourceManager.GetString("DoNotLockOnWeakIdentity", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Enums should have zero value..
        /// </summary>
        internal static string EnumsShouldHaveZeroValue {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to An enum should generally have a zero value. If the enum is not decorated with the Flags attribute, it should have a member with a value of zero that represents the empty state. Optionally, this value is named &apos;None&apos;. For a Flags-attributed enum, a zero-valued member is optional and, if it exists, should always be named &apos;None&apos;. This value should indicate that no values have been set in the enum. Using a zero-valued member for other purposes is contrary to the use of the Flags attribute in that the bitwise AN [rest of string was truncated]&quot;;.
        /// </summary>
        internal static string EnumsShouldHaveZeroValueDescription {
            get {
                return ResourceManager.GetString("EnumsShouldHaveZeroValueDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove all members that have the value zero from &apos;{0}&apos; except for one member that is named &apos;None&apos;..
        /// </summary>
        internal static string EnumsShouldZeroValueFlagsMultipleZero {
            get {
                return ResourceManager.GetString("EnumsShouldZeroValueFlagsMultipleZero", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to In enum &apos;{0}&apos;, change the name of &apos;{1}&apos; to &apos;None&apos;..
        /// </summary>
        internal static string EnumsShouldZeroValueFlagsRename {
            get {
                return ResourceManager.GetString("EnumsShouldZeroValueFlagsRename", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Add a member to &apos;{0}&apos; that has a value of zero with a suggested name of &apos;None&apos;..
        /// </summary>
        internal static string EnumsShouldZeroValueNotFlagsNoZeroValue {
            get {
                return ResourceManager.GetString("EnumsShouldZeroValueNotFlagsNoZeroValue", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Field {0} is a member of type {1} which is serializable but is of type {2} which is not serializable.
        /// </summary>
        internal static string FieldIsOfNonSerializableType {
            get {
                return ResourceManager.GetString("FieldIsOfNonSerializableType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to {0} &apos;{1}&apos; have identical names in a case-insensitive manner..
        /// </summary>
        internal static string IdentifierNamesShouldDifferMoreThanCase {
            get {
                return ResourceManager.GetString("IdentifierNamesShouldDifferMoreThanCase", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Identifier names should differ by more than case.
        /// </summary>
        internal static string IdentifiersShouldDifferByMoreThanCase {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCase", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Do not use names that require case sensitivity for uniqueness. Components must be fully usable from both case-sensitive and case-insensitive languages. Since case-insensitive languages cannot distinguish between two names within the same context that differ only by case, components must avoid this situation..
        /// </summary>
        internal static string IdentifiersShouldDifferByMoreThanCaseDescription {
            get {
                return ResourceManager.GetString("IdentifiersShouldDifferByMoreThanCaseDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Implement Serialization constructor.
        /// </summary>
        internal static string ImplementSerializationConstructor {
            get {
                return ResourceManager.GetString("ImplementSerializationConstructor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The constructor signature accepts the same arguments as ISerializable.GetObjectData, namely, a SerializationInfo instance and a StreamingContext instance. The constructor should be protected for non-sealed classes and private for sealed classes. Failure to implement a serialization constructor will cause deserialization to fail, and throw a SerializationException..
        /// </summary>
        internal static string ImplementSerializationConstructorDescription {
            get {
                return ResourceManager.GetString("ImplementSerializationConstructorDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Interface names should be prefixed with &apos;I&apos;.
        /// </summary>
        internal static string InterfaceNamesShouldStartWithI {
            get {
                return ResourceManager.GetString("InterfaceNamesShouldStartWithI", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark all non-serializable fields..
        /// </summary>
        internal static string MarkAllNonSerializableFields {
            get {
                return ResourceManager.GetString("MarkAllNonSerializableFields", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to All fields that cannot be serialized directly should have the NonSerializedAttribute. Types that have the SerializableAttribute should not have fields of types that do not have the SerializableAttribute unless the fields are marked with the NonSerializedAttribute..
        /// </summary>
        internal static string MarkAllNonSerializableFieldsDescription {
            get {
                return ResourceManager.GetString("MarkAllNonSerializableFieldsDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Mark ISerializable types with SerializableAttribute..
        /// </summary>
        internal static string MarkISerializableTypesWithAttribute {
            get {
                return ResourceManager.GetString("MarkISerializableTypesWithAttribute", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to The System.Runtime.Serialization.ISerializable interface allows the type to customize its serialization, while the Serializable attribute enables the runtime to recognize the type as being serializable..
        /// </summary>
        internal static string MarkISerializableTypesWithAttributeDescription {
            get {
                return ResourceManager.GetString("MarkISerializableTypesWithAttributeDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Remove empty finalizers.
        /// </summary>
        internal static string RemoveEmptyFinalizers {
            get {
                return ResourceManager.GetString("RemoveEmptyFinalizers", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Finalizers should be avoided where possible, to avoid the additional performance overhead involved in tracking object lifetime..
        /// </summary>
        internal static string RemoveEmptyFinalizersDescription {
            get {
                return ResourceManager.GetString("RemoveEmptyFinalizersDescription", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Re-throwing caught exception changes stack information..
        /// </summary>
        internal static string RethrowException {
            get {
                return ResourceManager.GetString("RethrowException", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Rethrow to preserve stack details..
        /// </summary>
        internal static string RethrowToPreserveStackDetails {
            get {
                return ResourceManager.GetString("RethrowToPreserveStackDetails", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Serializable type {0} doesn&apos;t have a serialization constructor.
        /// </summary>
        internal static string SerializableTypeDoesntHaveCtor {
            get {
                return ResourceManager.GetString("SerializableTypeDoesntHaveCtor", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declare serialization constructor for sealed type {0} as private.
        /// </summary>
        internal static string SerializationCtorAccessibilityForSealedType {
            get {
                return ResourceManager.GetString("SerializationCtorAccessibilityForSealedType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Declare serialization constructor for unsealed type {0} as protected.
        /// </summary>
        internal static string SerializationCtorAccessibilityForUnSealedType {
            get {
                return ResourceManager.GetString("SerializationCtorAccessibilityForUnSealedType", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; is a static holder type but is neither static nor NotInheritable.
        /// </summary>
        internal static string StaticHolderTypeIsNotStatic {
            get {
                return ResourceManager.GetString("StaticHolderTypeIsNotStatic", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static holder types should be Static or NotInheritable.
        /// </summary>
        internal static string StaticHolderTypesShouldBeStaticOrNotInheritable {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldBeStaticOrNotInheritable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Static holder types should not have instance constructors.
        /// </summary>
        internal static string StaticHolderTypesShouldNotHaveConstructors {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldNotHaveConstructors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; is a static holder type and should not contain Instance Constructors.
        /// </summary>
        internal static string StaticHolderTypesShouldNotHaveConstructorsMessage {
            get {
                return ResourceManager.GetString("StaticHolderTypesShouldNotHaveConstructorsMessage", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; is abstract but has public constructors.
        /// </summary>
        internal static string TypeIsAbstractButHasPublicConstructors {
            get {
                return ResourceManager.GetString("TypeIsAbstractButHasPublicConstructors", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type &apos;{0}&apos; owns disposable fields but is not disposable.
        /// </summary>
        internal static string TypeOwnsDisposableFieldButIsNotDisposable {
            get {
                return ResourceManager.GetString("TypeOwnsDisposableFieldButIsNotDisposable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Type parameter names should be prefixed with &apos;T&apos;.
        /// </summary>
        internal static string TypeParameterNamesShouldStartWithT {
            get {
                return ResourceManager.GetString("TypeParameterNamesShouldStartWithT", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Types that own disposable fields should be disposable.
        /// </summary>
        internal static string TypesThatOwnDisposableFieldsShouldBeDisposable {
            get {
                return ResourceManager.GetString("TypesThatOwnDisposableFieldsShouldBeDisposable", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use System.EventHandler&lt;T&gt; where T inherits System.EventArgs or use System.EventHandler.
        /// </summary>
        internal static string UseGenericEventHandlerInstances {
            get {
                return ResourceManager.GetString("UseGenericEventHandlerInstances", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Use properties where appropriate..
        /// </summary>
        internal static string UsePropertiesWhereAppropriate {
            get {
                return ResourceManager.GetString("UsePropertiesWhereAppropriate", resourceCulture);
            }
        }
        
        /// <summary>
        ///   Looks up a localized string similar to Properties should be used instead of Get/Set methods in most situations. Methods are preferable to properties in the following situations: the operation is a conversion, is expensive or has an observable side-effect; the order of execution is important; calling the member twice in succession creates different results; a member is static but returns a mutable value; or the member returns an array..
        /// </summary>
        internal static string UsePropertiesWhereAppropriateDescription {
            get {
                return ResourceManager.GetString("UsePropertiesWhereAppropriateDescription", resourceCulture);
            }
        }
    }
}
