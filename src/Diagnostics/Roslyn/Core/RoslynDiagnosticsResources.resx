<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="DirectlyAwaitingTaskDescription" xml:space="preserve">
    <value>Do not directly await a Task</value>
  </data>
  <data name="DirectlyAwaitingTaskMessage" xml:space="preserve">
    <value>Do not directly await a Task without calling ConfigureAwait</value>
  </data>
  <data name="DontUseCodeActionCreateDescription" xml:space="preserve">
    <value>Do not use generic CodeAction.Create to create CodeAction</value>
  </data>
  <data name="DontUseCodeActionCreateMessage" xml:space="preserve">
    <value>Consider creating unique code action type per different fix. it will help us to see how each code action is used. otherwise, we will only see bunch of generic code actions being used.</value>
  </data>
  <data name="MissingSharedAttributeDescription" xml:space="preserve">
    <value>Parts exported with MEFv2 must be marked as Shared.</value>
  </data>
  <data name="MissingSharedAttributeMessage" xml:space="preserve">
    <value>Part exported with MEFv2 must be marked with the Shared attribute.</value>
  </data>
  <data name="MixedVersionsOfMefAttributesDescription" xml:space="preserve">
    <value>Do not mix attributes from different versions of MEF</value>
  </data>
  <data name="MixedVersionsOfMefAttributesMessage" xml:space="preserve">
    <value>Attribute '{0}' comes from a different version of MEF than the export attribute on '{1}'</value>
  </data>
  <data name="UseArrayEmptyDescription" xml:space="preserve">
    <value>Avoid zero-length array allocations.</value>
  </data>
  <data name="UseArrayEmptyMessage" xml:space="preserve">
    <value>Avoid unnecessary zero-length array allocations.  Use Array.Empty&lt;T&gt;() instead.</value>
  </data>
  <data name="ImplementIEquatableDescription" xml:space="preserve">
    <value>Implement IEquatable&lt;T&gt; when overriding Object.Equals</value>
  </data>
  <data name="ImplementIEquatableMessage" xml:space="preserve">
    <value>Type {0} should implement IEquatable&lt;T&gt; because it overrides Equals</value>
  </data>
  <data name="OverrideObjectEqualsDescription" xml:space="preserve">
    <value>Override Object.Equals(object) when implementing IEquatable&lt;T&gt; </value>
  </data>
  <data name="OverrideObjectEqualsMessage" xml:space="preserve">
    <value>Type {0} should override Equals because it implements IEquatable&lt;T&gt;</value>
  </data>
  <data name="UseEmptyEnumerableDescription" xml:space="preserve">
    <value>Use SpecializedCollections.EmptyEnumerable&lt;T&gt;()</value>
  </data>
  <data name="UseEmptyEnumerableMessage" xml:space="preserve">
    <value>Use SpecializedCollections.EmptyEnumerable&lt;T&gt;()</value>
  </data>
  <data name="UseSingletonEnumerableDescription" xml:space="preserve">
    <value>Use SpecializedCollections.SingletonEnumerable&lt;T&gt;()</value>
  </data>
  <data name="UseSingletonEnumerableMessage" xml:space="preserve">
    <value>Use SpecializedCollections.SingletonEnumerable&lt;T&gt;()</value>
  </data>
  <data name="UseSiteDiagnosticsCheckerDescription" xml:space="preserve">
    <value>Invoke the correct property to ensure correct use site diagnostics.</value>
  </data>
  <data name="UseSiteDiagnosticsCheckerMessage" xml:space="preserve">
    <value>Do not directly invoke the property '{0}', instead use '{0}NoUseSiteDiagnostics'.</value>
  </data>
  <data name="UseProperCrefTagsDescription" xml:space="preserve">
    <value>Use of cref tags with prefixes should be avoided, since it prevents the compiler from verifying references and the IDE from updating references during refactorings. It is permissible to suppress this error at a single documentation site if the cref must use a prefix because the type being mentioned is not findable by the compiler. For example, if a cref is mentioning a special attribute in the full framework but you're in a file that compiles against the portable framework, or if you want to reference a type at higher layer of Roslyn, you should suppress the error. You should not suppress the error just because you want to take a shortcut and avoid using the full syntax.</value>
  </data>
  <data name="UseProperCrefTagsMessage" xml:space="preserve">
    <value>cref tag has prefix '{0}', which should be removed unless the type or member cannot be accessed.</value>
  </data>
  <data name="CancellationTokenMustBeLastDescription" xml:space="preserve">
    <value>CancellationToken parameters must come last</value>
  </data>
  <data name="CancellationTokenMustBeLastMessage" xml:space="preserve">
    <value>Method '{0}' should take CancellationToken as the last parameter</value>
  </data>
  <data name="DoNotCallToImmutableArrayMessage" xml:space="preserve">
    <value>Do not call ToImmutableArray on an ImmutableArray&lt;T&gt; value.</value>
  </data>
  <data name="DiagnosticDescriptorAccessMessage" xml:space="preserve">
    <value>Do not invoke property '{0}' on type '{1}', instead directly access the required member{2} on '{1}'</value>
  </data>
  <data name="DiagnosticDescriptorAccessTitle" xml:space="preserve">
    <value>Do not invoke Diagnostic.Descriptor</value>
  </data>
  <data name="DiagnosticDescriptorAccessDescription" xml:space="preserve">
    <value>Accessing the Descriptor property of Diagnostic in compiler layer leads to unnecessary string allocations for fields of the descriptor that are not utilized in command line compilation. Hence, you should avoid accessing the Descriptor of the compiler diagnostics here. Instead you should directly access these properties off the Diagnostic type.</value>
  </data>
  <data name="DoNotUseLinqOnIndexableCollectionMessage" xml:space="preserve">
    <value>Do not use Enumerable methods on indexable collections.  Instead use the collection directly.</value>
  </data>
  <data name="DoNotUseLinqOnIndexableCollectionDescription" xml:space="preserve">
    <value>This collection is directly indexable.  Going through LINQ here causes unnecessary allocations and CPU work.</value>
  </data>
  <data name="UseProperCrefTagsTitle" xml:space="preserve">
    <value>Avoid using cref tags with a prefix</value>
  </data>
  <data name="ConsumePreserveSigTitle" xml:space="preserve">
    <value>Always consume the value returned by methods marked with PreserveSigAttribute</value>
  </data>
  <data name="ConsumePreserveSigMessage" xml:space="preserve">
    <value>Consume the hresult returned by method '{0}' and call Marshal.ThrowExceptionForHR.</value>
  </data>
  <data name="ConsumePreserveSigDescription" xml:space="preserve">
    <value>PreserveSigAttribute indicates that a method will return an HRESULT, rather than throwing an exception.  Therefore, it is important to consume the HRESULT returned by the method, so that errors can be detected.  Generally, this is done by calling Marshal.ThrowExceptionForHR.</value>
  </data>
  <data name="DeclarePublicApiTitle" xml:space="preserve">
    <value>Add public types and members to the declared API</value>
  </data>
  <data name="DeclarePublicApiMessage" xml:space="preserve">
    <value>Symbol '{0}' is not part of the declared API.</value>
  </data>
  <data name="DeclarePublicApiDescription" xml:space="preserve">
    <value>All public types and members should be declared in PublicAPI.txt. This draws attention to API changes in the code reviews and source control history, and helps prevent breaking changes.</value>
  </data>
  <data name="RemoveDeletedApiTitle" xml:space="preserve">
    <value>Remove deleted types and members from the declared API</value>
  </data>
  <data name="RemoveDeletedApiMessage" xml:space="preserve">
    <value>Symbol '{0}' is part of the declared API, but is either not public or could not be found</value>
  </data>
  <data name="RemoveDeletedApiDescription" xml:space="preserve">
    <value>When removing a public type or member the corresponding entry in PublicAPI.txt should also be removed. This draws attention to API changes in the code reviews and source control history, and helps prevent breaking changes.</value>
  </data>
  <data name="UnusedDeclarationsCodeFixTitle" xml:space="preserve">
    <value>Remove unused code</value>
    <comment>The title of the fix</comment>
  </data>
  <data name="UnusedDeclarationsMessage" xml:space="preserve">
    <value>'{0}' is not used in solution.</value>
    <comment>The format-able message the diagnostic displays.</comment>
  </data>
  <data name="UnusedDeclarationsTitle" xml:space="preserve">
    <value>unused code</value>
    <comment>The title of the diagnostic.</comment>
  </data>
  <data name="DoNotCreateTasksWithoutTaskSchedulerDescription" xml:space="preserve">
    <value>Do not create tasks unless you are using one of the overloads that takes a TaskScheduler. The default is to schedule on TaskScheduler.Current, which would lead to deadlocks. Either use TaskScheduler.Default to schedule on the thread pool, or explicitly pass TaskScheduler.Current to make your intentions clear.</value>
  </data>
  <data name="DoNotCreateTasksWithoutTaskSchedulerTitle" xml:space="preserve">
    <value>Do not create tasks without passing a TaskScheduler</value>
  </data>
  <data name="DoNotCreateTasksWithoutTaskSchedulerMessage" xml:space="preserve">
    <value>Do not call {0} without passing a TaskScheduler</value>
  </data>
  <data name="SymbolDeclaredEventRuleTitle" xml:space="preserve">
    <value>SymbolDeclaredEvent must be generated for source symbols</value>
  </data>
  <data name="SymbolDeclaredEventRuleMessage" xml:space="preserve">
    <value>Symbol '{0}' seems to be a source symbol, but neither the symbol nor any of it's base types invoke method '{1}.{2}' to register a symbol declared event.</value>
  </data>
  <data name="SymbolDeclaredEventRuleDescription" xml:space="preserve">
    <value>Compilation event queue is required to generate symbol declared events for all declared source symbols. Hence, every source symbol type or one of it's base types must generate a symbol declared event.</value>
  </data>
  <data name="ExposedNoninstantiableTypeDescription" xml:space="preserve">
    <value>When a base class is noninheritable because its constructor is internal, a derived class should not make it inheritable by having a public or protected constructor.</value>
  </data>
  <data name="ExposedNoninstantiableTypeMessage" xml:space="preserve">
    <value>Constructor makes its noninheritable base class inheritable, thereby exposing its protected members.</value>
  </data>
  <data name="ExposedNoninstantiableTypeTitle" xml:space="preserve">
    <value>Constructor make noninheritable base class inheritable</value>
  </data>
</root>