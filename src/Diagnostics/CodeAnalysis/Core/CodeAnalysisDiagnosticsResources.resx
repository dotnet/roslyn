<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="MissingAttributeMessage" xml:space="preserve">
    <value>Missing '{0}' attribute.</value>
  </data>
  <data name="MissingDiagnosticAnalyzerAttributeTitle" xml:space="preserve">
    <value>Missing diagnostic analyzer attribute.</value>
  </data>
  <data name="MissingDiagnosticAnalyzerAttributeDescription" xml:space="preserve">
    <value>Non-abstract sub-types of DiagnosticAnalyzer should be marked with DiagnosticAnalyzerAttribute(s). The argument to this attribute(s), if any, determine the supported languages for the analyzer. Analyzer types without this attribute will be ignored by the analysis engine.</value>
  </data>
  <data name="AddLanguageSupportToAnalyzerMessage" xml:space="preserve">
    <value>Diagnostic analyzer '{0}' may be able to support both C# and Visual Basic. Consider adding an argument to DiagnosticAnalyzerAttribute for '{1}' language support.</value>
  </data>
  <data name="AddLanguageSupportToAnalyzerTitle" xml:space="preserve">
    <value>Recommend adding language support to diagnostic analyzer.</value>
  </data>
  <data name="AddLanguageSupportToAnalyzerDescription" xml:space="preserve">
    <value>Diagnostic analyzer is marked as supporting only one language, but the analyzer assembly doesn't seem to refer to any language specific CodeAnalysis assemblies, and so is likely to work for more than one language. Consider adding an additional language argument to DiagnosticAnalyzerAttribute.</value>
  </data>
  <data name="ApplyDiagnosticAnalyzerAttribute_1" xml:space="preserve">
    <value>Apply DiagnosticAnalyzer attribute for '{0}'.</value>
  </data>
  <data name="ApplyDiagnosticAnalyzerAttribute_2" xml:space="preserve">
    <value>Apply DiagnosticAnalyzer attribute for both '{0}' and '{1}'.</value>
  </data>
  <data name="MissingKindArgumentToRegisterActionMessage" xml:space="preserve">
    <value>Specify at least one '{0}' of interest while registering a {1} analyzer action.</value>
  </data>
  <data name="MissingKindArgumentToRegisterActionTitle" xml:space="preserve">
    <value>Missing kind argument while registering an analyzer action.</value>
  </data>
  <data name="MissingKindArgumentToRegisterActionDescription" xml:space="preserve">
    <value>You must specify at least one syntax/symbol kinds of interest while registering a syntax/symbol analyzer action. Otherwise, the registered action will be dead code and will never be invoked during analysis.</value>
  </data>
  <data name="UnsupportedSymbolKindArgumentToRegisterActionMessage" xml:space="preserve">
    <value>SymbolKind '{0}' is not supported for symbol analyzer actions.</value>
  </data>
  <data name="UnsupportedSymbolKindArgumentToRegisterActionTitle" xml:space="preserve">
    <value>Unsupported SymbolKind argument while registering a symbol analyzer action.</value>
  </data>
  <data name="InvalidReportDiagnosticMessage" xml:space="preserve">
    <value>ReportDiagnostic invoked with an unsupported DiagnosticDescriptor '{0}'.</value>
  </data>
  <data name="InvalidReportDiagnosticTitle" xml:space="preserve">
    <value>ReportDiagnostic invoked with an unsupported DiagnosticDescriptor.</value>
  </data>
  <data name="InvalidReportDiagnosticDescription" xml:space="preserve">
    <value>ReportDiagnostic should only be invoked with supported DiagnosticDescriptors that are returned from DiagnosticAnalyzer.SupportedDiagnostics property. Otherwise, the reported diagnostic will be filtered out by the analysis engine.</value>
  </data>
  <data name="InvalidSyntaxKindTypeArgumentMessage" xml:space="preserve">
    <value>Type argument '{0}' for type parameter '{1}' of method '{2}' is not a SyntaxKind enum.</value>
  </data>
  <data name="InvalidSyntaxKindTypeArgumentTitle" xml:space="preserve">
    <value>Invalid type argument for DiagnosticAnalyzer's Register method.</value>
  </data>
  <data name="InvalidSyntaxKindTypeArgumentDescription" xml:space="preserve">
    <value>DiagnosticAnalyzer's language-specific Register methods, such as RegisterSyntaxNodeAction, RegisterCodeBlockStartAction and RegisterCodeBlockEndAction, expect a language-specific 'SyntaxKind' type argument for it's '{0}' type parameter. Otherwise, the registered analyzer action can never be invoked during analysis.</value>
  </data>
  <data name="StartActionWithOnlyEndActionTitle" xml:space="preserve">
    <value>Start action has no registered non-end actions.</value>
  </data>
  <data name="StartActionWithNoRegisteredActionsMessage" xml:space="preserve">
    <value>'{0}' does not register any analyzer actions. Consider moving actions registered in '{1}' that depend on this start action to '{0}'.</value>
  </data>
  <data name="StartActionWithNoRegisteredActionsTitle" xml:space="preserve">
    <value>Start action has no registered actions.</value>
  </data>
  <data name="StartActionWithOnlyEndActionMessage" xml:space="preserve">
    <value>'{0}' does not register any analyzer actions, except for a '{1}'. Consider replacing this start/end action pair with a '{2}' or moving actions registered in '{3}' that depend on this start action to '{0}'.</value>
  </data>
  <data name="StatefulAnalyzerRegisterActionsDescription" xml:space="preserve">
    <value>An analyzer start action enables performing stateful analysis over a given code unit, such as a code block, compilation, etc. Careful design is necessary to achieve efficient analyzer execution without memory leaks. Use the following guidelines for writing such analyzers:
1. Define a new scope for the registered start action, possibly with a private nested type for analyzing each code unit.
2. If required, define and initialize state in the start action.
3. Register at least one non-end action that refers to this state in the start action. If no such action is necessary, consider replacing the start action with a non-start action. For example, a CodeBlockStartAction with no registered actions or only a registered CodeBlockEndAction should be replaced with a CodeBlockAction.
4. If required, register an end action to report diagnostics based on the final state.
</value>
  </data>
  <data name="UseLocalizableStringsInDescriptorMessage" xml:space="preserve">
    <value>Consider providing localizable arguments of type '{0}' to diagnostic descriptor constructor to ensure the descriptor is localizable.</value>
  </data>
  <data name="UseLocalizableStringsInDescriptorTitle" xml:space="preserve">
    <value>Provide localizable arguments to diagnostic descriptor constructor.</value>
  </data>
  <data name="UseLocalizableStringsInDescriptorDescription" xml:space="preserve">
    <value>If your diagnostic analyzer and it's reported diagnostics need to be localizable, then the supported DiagnosticDescriptors used for constructing the diagnostics must also be localizable. If so, then localizable argument(s) must be provided for parameter 'title' (and optionally 'description') to the diagnostic descriptor constructor to ensure that the descriptor is localizable.</value>
  </data>
  <data name="DoNotStorePerCompilationDataOntoFieldsMessage" xml:space="preserve">
    <value>Avoid storing per-compilation data of type '{0}' into the fields of a diagnostic analyzer.</value>
  </data>
  <data name="DoNotStorePerCompilationDataOntoFieldsTitle" xml:space="preserve">
    <value>Avoid storing per-compilation data into the fields of a diagnostic analyzer.</value>
  </data>
  <data name="DoNotStorePerCompilationDataOntoFieldsDescription" xml:space="preserve">
    <value>Instance of a diagnostic analyzer might outlive the lifetime of compilation. Hence, storing per-compilation data, such as symbols, into the fields of a diagnostic analyzer might cause stale compilations to stay alive and cause memory leaks.  Instead, you should store this data on a separate type instantiated in a compilation start action, registered using '{0}.{1}' API. An instance of this type will be created per-compilation and it won't outlive compilation's lifetime, hence avoiding memory leaks.</value>
  </data>
  <data name="InternalImplementationOnlyDescription" xml:space="preserve">
    <value>The author of this interface did not intend to have third party implementations of this interface and reserves the right to change it. Implementing this interface could therefore result in a source or binary compatibility issue with a future version of this interface.</value>
  </data>
  <data name="InternalImplementationOnlyMessage" xml:space="preserve">
    <value>Type {0} cannot implement interface {1} because {1} is not available for public implementation.</value>
  </data>
  <data name="InternalImplementationOnlyTitle" xml:space="preserve">
    <value>Only internal implementations of this interface are allowed.</value>
  </data>
  <data name="CodeActionNeedsEquivalenceKeyDescription" xml:space="preserve">
    <value>A CodeFixProvider that intends to support fix all occurrences must classify the registered code actions into equivalence classes by assigning it an explicit, non-null equivalence key which is unique across all registered code actions by this fixer. This enables the FixAllProvider to fix all diagnostics in the required scope by applying code actions from this fixer that are in the equivalence class of the trigger code action.</value>
  </data>
  <data name="CreateCodeActionWithEquivalenceKeyMessage" xml:space="preserve">
    <value>Provide an explicit argument for optional parameter '{0}', which is non-null and unique across all code actions created by this fixer.</value>
  </data>
  <data name="CreateCodeActionWithEquivalenceKeyTitle" xml:space="preserve">
    <value>Create code actions should have a unique EquivalenceKey for FixAll occurrences support.</value>
  </data>
  <data name="OverrideCodeActionEquivalenceKeyMessage" xml:space="preserve">
    <value>'{0}' has the default value of 'null' for property '{1}'. Either override this property on '{0}' to return a non-null and unique value across all code actions per-fixer or use such an existing code action.</value>
  </data>
  <data name="OverrideCodeActionEquivalenceKeyTitle" xml:space="preserve">
    <value>Use code actions that have a unique EquivalenceKey for FixAll occurrences support.</value>
  </data>
</root>