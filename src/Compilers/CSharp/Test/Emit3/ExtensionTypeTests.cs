// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Reflection.Metadata;
using Microsoft.CodeAnalysis.CSharp.Symbols;
using Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;
using Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp.Test.Utilities;
using Microsoft.CodeAnalysis.Operations;
using Microsoft.CodeAnalysis.Test.Utilities;
using Roslyn.Test.Utilities;
using Roslyn.Utilities;
using Xunit;

namespace Microsoft.CodeAnalysis.CSharp.UnitTests.Semantics;

public class ExtensionTypeTests : CompilingTestBase
{
    private static readonly string[] objectStaticSymbols = [
        "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
        "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

    private static readonly string[] objectSymbols = [
        .. objectStaticSymbols,
        "System.String System.Object.ToString()",
        "System.Boolean System.Object.Equals(System.Object obj)",
        "System.Int32 System.Object.GetHashCode()",
        "System.Type System.Object.GetType()"];

    private static string IncludeExpectedOutput(string expectedOutput) => ExecutionConditionUtil.IsMonoOrCoreClr ? expectedOutput : null;

    private static void AssertSetStrictlyEqual(string[] expected, string[] actual)
    {
        Assert.True(expected.All(new HashSet<string>().Add), $"Duplicates were found in '{nameof(expected)}'");
        Assert.True(actual.All(new HashSet<string>().Add), $"Duplicates were found in '{nameof(actual)}'");
        AssertEx.SetEqual(expected, actual);
    }

    private static void VerifyNotExtension<T>(TypeSymbol type) where T : TypeSymbol
    {
        Assert.True(type is T, $"Found type '{type.GetType()}'");
        Assert.False(type.IsExtension);
        Assert.False(type.IsExplicitExtension);
        Assert.Null(type.GetExtendedTypeNoUseSiteDiagnostics(null));
        Assert.Empty(type.BaseExtensionsNoUseSiteDiagnostics);
        Assert.Empty(type.AllBaseExtensionsNoUseSiteDiagnostics);
    }

    // Verify things that are common for all extension types
    private static void VerifyExtension<T>(TypeSymbol type, bool? isExplicit, SpecialType specialType = SpecialType.None) where T : TypeSymbol
    {
        var namedType = (NamedTypeSymbol)type;
        Assert.True(namedType is T);
        Assert.True(namedType.IsExtension);
        if (isExplicit.HasValue)
        {
            Assert.Equal(isExplicit.Value, namedType.IsExplicitExtension);
        }

        Assert.Null(namedType.BaseTypeNoUseSiteDiagnostics);
        Assert.False(namedType.IsSealed);
        Assert.False(namedType.IsRecord);
        Assert.False(namedType.IsRecordStruct);
        Assert.False(namedType.IsReferenceType);
        Assert.False(namedType.IsValueType);
        Assert.False(namedType.IsTypeParameter());
        Assert.False(namedType.IsAnonymousType);
        Assert.False(namedType.IsEnumType());
        Assert.False(namedType.IsErrorType());
        Assert.Equal(specialType, namedType.SpecialType);
        Assert.False(namedType.IsObjectType());
        Assert.False(namedType.IsTupleType);
        Assert.True(namedType.TupleElements.IsDefault);
        Assert.Empty(namedType.InterfacesNoUseSiteDiagnostics());
        Assert.Empty(namedType.AllInterfacesNoUseSiteDiagnostics); // PROTOTYPE
        Assert.False(namedType.IsReadOnly);
        Assert.False(namedType.IsRefLikeType);
        Assert.False(namedType.IsPointerOrFunctionPointer());
        Assert.Equal(TypeKind.Extension, namedType.TypeKind);
        Assert.False(namedType.IsInterfaceType());
        Assert.False(namedType.IsAbstract);

        if (namedType.GetExtendedTypeNoUseSiteDiagnostics(null) is { } underlyingType)
        {
            // PROTOTYPE consider whether we want to expose invalid underlying types
            // in context of public APIs
            VerifyNotExtension<TypeSymbol>(underlyingType);
        }

        if (namedType != (object)namedType.OriginalDefinition)
        {
            VerifyExtension<TypeSymbol>(namedType.OriginalDefinition, isExplicit);
        }

        foreach (var baseExtension in namedType.AllBaseExtensionsNoUseSiteDiagnostics)
        {
            checkBaseExtension(baseExtension);
        }

        var managedKindUseSiteInfo = CompoundUseSiteInfo<AssemblySymbol>.Discarded;
        Assert.False(namedType.IsManagedType(ref managedKindUseSiteInfo));

        Assert.False(namedType.IsRestrictedType());
        Assert.True(namedType.IsType);
        Assert.True(namedType.CanBeReferencedByName);

        Assert.False(namedType.IsCustomTaskType(out _));
        Assert.Null(namedType.DelegateInvokeMethod);
        Assert.False(namedType.HasAnyRequiredMembers);
        Assert.False(namedType.IsNamespace);
        Assert.True(namedType.IsMetadataSealed);

        if (namedType is SourceNamedTypeSymbol sourceNamedType)
        {
            Assert.False(sourceNamedType.IsScriptClass);
            Assert.Null(sourceNamedType.EnumUnderlyingType);
            Assert.False(sourceNamedType.HasStructLayoutAttribute); // PROTOTYPE revisit when adding support for attributes
            Assert.False(sourceNamedType.IsAnonymousType);
            Assert.False(sourceNamedType.IsSimpleProgram);
            Assert.False(sourceNamedType.IsImplicitlyDeclared);
        }

        static void checkBaseExtension(NamedTypeSymbol baseExtension)
        {
            if (baseExtension.IsExtension)
            {
                VerifyExtension<TypeSymbol>(baseExtension, isExplicit: null);
            }
            else
            {
                Assert.True(baseExtension.IsErrorType());
            }
        }
    }

    [Theory, CombinatorialData]
    public void TestLanguageVersion(bool isExplicit, bool withParameterList)
    {
        var src = $$"""
            {{(isExplicit ? "explicit" : "implicit")}} extension E{{(withParameterList ? "(int i)" : "")}} { }
            """;

        foreach (var parseOptions in new[] { TestOptions.Regular12, TestOptions.RegularNext, TestOptions.RegularPreview })
        {
            var diagnostics = new List<DiagnosticDescription>();

            if (parseOptions.LanguageVersion == LanguageVersion.CSharp12)
            {
                diagnostics.Add(
                    // (1,10): error CS8652: The feature 'extension types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                    // implicit extension E { }
                    Diagnostic(ErrorCode.ERR_FeatureInPreview, "extension").WithArguments("extension types").WithLocation(1, 10));
            }

            diagnostics.Add(
                // (1,20): error CS9314: No part of a partial extension 'E' includes an underlying type specification.
                // implicit extension E { }
                Diagnostic(ErrorCode.ERR_ExtensionMissingUnderlyingType, "E").WithArguments("E").WithLocation(1, 20));

            if (withParameterList)
            {
                diagnostics.Add(
                    // (1,21): error CS9122: Unexpected parameter list.
                    // implicit extension E(int i) { }
                    Diagnostic(ErrorCode.ERR_UnexpectedParameterList, "(int i)").WithLocation(1, 21));
            }

            var comp = CreateCompilation(src, parseOptions: parseOptions)
                .VerifyEmitDiagnostics(diagnostics.ToArray());
        }
    }

    [Theory, CombinatorialData]
    public void ForClass(bool useImageReference, bool isExplicit)
    {
        var src = $$"""
interface I { }
public class UnderlyingClass : I { }
public {{(isExplicit ? "explicit" : "implicit")}} extension R for UnderlyingClass
{
    public static int StaticField = 42;
    public const string Const = "hello";

    public void Method() { }
    public static void StaticMethod() { }

    public int Property { get => throw null; set => throw null; }
    public static int StaticProperty { get => throw null; set => throw null; }
    public int this[int i] => throw null;

    class NestedType { }
    static class StaticNestedType { }
    explicit extension NestedR for UnderlyingClass { }
    public R(int i) { }
    public static implicit operator R(int i) => throw null;
    public static implicit operator R(UnderlyingClass c) => throw null;
    public static implicit operator UnderlyingClass(R r) => throw null;
    public static int operator+(R r, UnderlyingClass c) => throw null;
    public static int operator-(UnderlyingClass c, R r) => throw null;
}
""";
        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], options: TestOptions.DebugDll.WithMetadataImportOptions(MetadataImportOptions.All));
        // PROTOTYPE need to finalize the rules for operators (conversion and others)
        // PROTOTYPE constructor and destructor
        comp.VerifyDiagnostics();

        // TODO2
        // PEVerify failed for assembly '':
        // Error: Method has a duplicate, token = 0x0600000e.
        // Error: Method has a duplicate, token = 0x0600000d.
        var verifier = CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        verifier.VerifyIL($$"""R.{{ExtensionMarkerName(isExplicit)}}(UnderlyingClass)""", """
{
  // Code size        1 (0x1)
  .maxstack  0
  IL_0000:  ret
}
""");

        var src2 = """
explicit extension R2 for UnderlyingClass : R { }
""";
        var comp2 = CreateCompilation(src2, references: new[] { AsReference(comp, useImageReference) });
        comp2.VerifyDiagnostics(
            // (1,43): error CS8000: This language feature ('base extensions') is not yet implemented.
            // explicit extension R2 for UnderlyingClass : R { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R").WithArguments("base extensions").WithLocation(1, 43)
            );
        return;

        void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var r = module.GlobalNamespace.GetTypeMember("R");
            Assert.Equal("R", r.ToTestDisplayString());
            if (inSource)
            {
                VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: isExplicit);
            }
            else
            {
                VerifyExtension<PENamedTypeSymbol>(r, isExplicit: isExplicit);
            }

            Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);

            if (!inSource)
            {
                AssertSetStrictlyEqual(["""System.Reflection.DefaultMemberAttribute("Item")"""],
                    GetAttributeStrings(r.GetAttributes()).ToArray());
            }

            Assert.Equal(["R.NestedType", "R.StaticNestedType", "R.NestedR"],
                r.GetTypeMembers().ToTestDisplayStrings());

            Assert.False(r.IsStatic);
            Assert.Equal(Accessibility.Public, r.DeclaredAccessibility);
            Assert.Null(r.ContainingType);
            Assert.False(r.IsGenericType);
            Assert.Empty(r.TypeParameters);
            Assert.True(r.IsDefinition);
            Assert.Equal(0, r.Arity);
        }
    }

    [Fact]
    public void ForClass_DefaultAccessibility()
    {
        var src = """
interface I { }
public class UnderlyingClass : I { }
explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            var r = module.GlobalNamespace.GetTypeMember("R");
            Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
        }
    }

    [Fact]
    public void ForClass_MissingValueType()
    {
        var src = """
class C { }
explicit extension R for C { }
""";
        var comp = CreateCompilation(src);
        comp.MakeTypeMissing(SpecialType.System_ValueType);
        comp.VerifyDiagnostics(
            // (2,20): error CS0518: Predefined type 'System.ValueType' is not defined or imported
            // explicit extension R for C { }
            Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "R").WithArguments("System.ValueType").WithLocation(2, 20)
            );
    }

    [Fact]
    public void ForClass_MissingVoidType()
    {
        var src = """
class C { }
explicit extension R for C { }
""";
        var comp = CreateCompilation(src);
        comp.MakeTypeMissing(SpecialType.System_Void);
        comp.VerifyEmitDiagnostics(
            // (2,20): error CS0518: Predefined type 'System.Void' is not defined or imported
            // explicit extension R for C { }
            Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "R").WithArguments("System.Void").WithLocation(2, 20)
            );
    }

    [Fact]
    public void ForClass_Generic()
    {
        var src = """
class UnderlyingClass<T1, T2> { }
class C<T>
{
    explicit extension R<U> for UnderlyingClass<T, U> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            var c = module.GlobalNamespace.GetTypeMember("C");
            var r = c.GetTypeMember("R");
            Assert.Equal(1, r.Arity);
            var underlyingType = (NamedTypeSymbol)r.GetExtendedTypeNoUseSiteDiagnostics(null);
            Assert.Equal("UnderlyingClass<T, U>", underlyingType.ToTestDisplayString());
            Assert.Equal(2, underlyingType.TypeArguments().Length);
            Assert.Same(c.TypeArguments().Single(), underlyingType.TypeArguments()[0]);
            Assert.Same(r.TypeArguments().Single(), underlyingType.TypeArguments()[1]);
        }
    }

    [Theory, CombinatorialData]
    public void ForClass_Metadata_RefStruct(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.IsByRefLikeAttribute::.ctor() = ( 01 00 00 00 )
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        IL_0000: ret
    }
    .method public hidebysig static void M () cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
object.M();
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'M'
            // object.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(1, 8),
            // (2,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(2, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyNotExtension<PENamedTypeSymbol>(r1);

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Fact]
    public void ForClass_Metadata_MissingIsByRefLikeAttribute()
    {
        var src = """
class C { }
explicit extension R for C { }
""";
        var comp = CreateCompilation(src);
        comp.MakeTypeMissing(WellKnownType.System_Runtime_CompilerServices_IsByRefLikeAttribute);

        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            var r = module.GlobalNamespace.GetTypeMember("R");
            AssertSetStrictlyEqual([], GetAttributeNames(r.GetAttributes()).ToArray());

            Assert.Null(module.ContainingAssembly.GetTypeByMetadataName("System.Runtime.CompilerServices.IsByRefLikeAttribute"));
        }
    }

    [Fact]
    public void ForClass_Metadata_MissingCompilerFeature()
    {
        var src = """
class C { }
explicit extension R for C { }
""";
        var comp = CreateCompilation(src);
        comp.MakeTypeMissing(WellKnownType.System_Runtime_CompilerServices_CompilerFeatureRequiredAttribute);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void ForClass_Metadata_MissingObsolete()
    {
        var src = """
class C { }
explicit extension R for C { }
""";
        var comp = CreateCompilation(src);
        comp.MakeTypeMissing(WellKnownType.System_ObsoleteAttribute);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void ForClass_Metadata_MissingDynamicAttribute()
    {
        var src = """
class C<T> { }
explicit extension R for C<dynamic> { }
""";
        var comp = CreateCompilation(src);
        comp.MakeTypeMissing(WellKnownType.System_Runtime_CompilerServices_DynamicAttribute);
        comp.VerifyDiagnostics(
            // (2,28): error CS1980: Cannot define a class or member that utilizes 'dynamic' because the compiler required type 'System.Runtime.CompilerServices.DynamicAttribute' cannot be found. Are you missing a reference?
            // explicit extension R for C<dynamic> { }
            Diagnostic(ErrorCode.ERR_DynamicAttributeMissing, "dynamic").WithArguments("System.Runtime.CompilerServices.DynamicAttribute").WithLocation(2, 28)
            );
    }

    [Fact]
    public void ForClass_WithStaticReadonlyField()
    {
        var src = """
class C { }
static explicit extension R for C
{
    public static readonly int Field = 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void ForClass_WithoutStaticField()
    {
        var src = """
interface I { }
class UnderlyingClass : I { }
explicit extension R for UnderlyingClass
{
    void Method() { }
    static void StaticMethod() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var r = comp.GlobalNamespace.GetTypeMember("R");
        AssertEx.Equal(new[] { "void R.Method()", "void R.StaticMethod()" },
            r.GetMembers().ToTestDisplayStrings());
    }

    [Fact]
    public void ForClass_Nested()
    {
        var src = """
class UnderlyingClass { }
class ContainingType
{
    explicit extension R for UnderlyingClass
    {
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var r = comp.GlobalNamespace.GetTypeMember("ContainingType").GetTypeMember("R");
        Assert.Equal("ContainingType.R", r.ToTestDisplayString());
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("ContainingType", r.ContainingType.ToTestDisplayString());
    }

    [Fact]
    public void Members_DisallowedMembers()
    {
        var src = """
interface I { }
class UnderlyingClass : I { }
explicit extension R for UnderlyingClass
{
    public int field = 0; // 1, 2
    public volatile int field2 = 0; // 3, 4
    int AutoProperty { get; set; } // 5
    int AutoPropertyWithGetAccessor { get; } // 6
    int AutoPropertyWithoutGetAccessor { set; } // 7
    public event System.Action Event; // 8, 9
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,16): error CS9313: 'R.field': cannot declare instance members with state in extension types.
            //     public int field = 0; // 1, 2
            Diagnostic(ErrorCode.ERR_StateInExtension, "field").WithArguments("R.field").WithLocation(5, 16),
            // (5,16): warning CS0649: Field 'R.field' is never assigned to, and will always have its default value 0
            //     public int field = 0; // 1, 2
            Diagnostic(ErrorCode.WRN_UnassignedInternalField, "field").WithArguments("R.field", "0").WithLocation(5, 16),
            // (6,25): error CS9313: 'R.field2': cannot declare instance members with state in extension types.
            //     public volatile int field2 = 0; // 3, 4
            Diagnostic(ErrorCode.ERR_StateInExtension, "field2").WithArguments("R.field2").WithLocation(6, 25),
            // (6,25): warning CS0649: Field 'R.field2' is never assigned to, and will always have its default value 0
            //     public volatile int field2 = 0; // 3, 4
            Diagnostic(ErrorCode.WRN_UnassignedInternalField, "field2").WithArguments("R.field2", "0").WithLocation(6, 25),
            // (7,9): error CS9313: 'R.AutoProperty': cannot declare instance members with state in extension types.
            //     int AutoProperty { get; set; } // 5
            Diagnostic(ErrorCode.ERR_StateInExtension, "AutoProperty").WithArguments("R.AutoProperty").WithLocation(7, 9),
            // (8,9): error CS9313: 'R.AutoPropertyWithGetAccessor': cannot declare instance members with state in extension types.
            //     int AutoPropertyWithGetAccessor { get; } // 6
            Diagnostic(ErrorCode.ERR_StateInExtension, "AutoPropertyWithGetAccessor").WithArguments("R.AutoPropertyWithGetAccessor").WithLocation(8, 9),
            // (9,42): error CS8051: Auto-implemented properties must have get accessors.
            //     int AutoPropertyWithoutGetAccessor { set; } // 7
            Diagnostic(ErrorCode.ERR_AutoPropertyMustHaveGetAccessor, "set").WithLocation(9, 42),
            // (10,32): error CS9313: 'R.Event': cannot declare instance members with state in extension types.
            //     public event System.Action Event; // 8, 9
            Diagnostic(ErrorCode.ERR_StateInExtension, "Event").WithArguments("R.Event").WithLocation(10, 32),
            // (10,32): warning CS0067: The event 'R.Event' is never used
            //     public event System.Action Event; // 8, 9
            Diagnostic(ErrorCode.WRN_UnreferencedEvent, "Event").WithArguments("R.Event").WithLocation(10, 32)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        AssertEx.Equal(new[]
            {
                "System.Int32 R.field",
                "System.Int32 modreq(System.Runtime.CompilerServices.IsVolatile) R.field2",
                "System.Int32 R.<AutoProperty>k__BackingField",
                "System.Int32 R.AutoProperty { get; set; }",
                "System.Int32 R.AutoProperty.get",
                "void R.AutoProperty.set",
                "System.Int32 R.<AutoPropertyWithGetAccessor>k__BackingField",
                "System.Int32 R.AutoPropertyWithGetAccessor { get; }",
                "System.Int32 R.AutoPropertyWithGetAccessor.get",
                "System.Int32 R.AutoPropertyWithoutGetAccessor { set; }",
                "void R.AutoPropertyWithoutGetAccessor.set",
                "void R.Event.add",
                "void R.Event.remove",
                "event System.Action R.Event"
            },
            r.GetMembers().ToTestDisplayStrings());
    }

    [Fact]
    public void Members_EventWithoutField()
    {
        var src = """
class UnderlyingClass { }
explicit extension R for UnderlyingClass
{
    public event System.Action Event { add { throw null; } remove { throw null; } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var r = module.GlobalNamespace.GetTypeMember("R");
            Assert.Equal("R", r.ToTestDisplayString());
            if (inSource)
            {
                VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
            }
            else
            {
                VerifyExtension<PENamedTypeSymbol>(r, isExplicit: true);
            }

            AssertEx.Equal(new[]
                {
                    "event System.Action R.Event",
                    "void R.Event.add",
                    "void R.Event.remove"
                },
                r.GetMembers().ToTestDisplayStrings().OrderBy(s => s));
        }
    }

    [Fact]
    public void Members_MemberNamedAfterType()
    {
        var src = """
class C { }
explicit extension R for C
{
    public void R() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,17): error CS0542: 'R': member names cannot be the same as their enclosing type
            //     public void R() { }
            Diagnostic(ErrorCode.ERR_MemberNameSameAsType, "R").WithArguments("R").WithLocation(4, 17)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        AssertEx.Equal(new[] { "void R.R()" }, r.GetMembers().ToTestDisplayStrings());
    }

    [Fact]
    public void Members_MemberNamedAfterUnderlyingType()
    {
        var src = """
class C { }
explicit extension R for C
{
    public void C() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        AssertEx.Equal(new[] { "void R.C()" }, r.GetMembers().ToTestDisplayStrings());
    }

    [Fact]
    public void Members_DuplicateMemberNames()
    {
        var src = """
class C { }
explicit extension R for C
{
    public void M() { }
    private int M => 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,17): error CS0102: The type 'R' already contains a definition for 'M'
            //     private int M => 0;
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "M").WithArguments("R", "M").WithLocation(5, 17)
            );
    }

    [Fact]
    public void Members_TypeParameterNameConflict()
    {
        var src = """
class C { }
explicit extension R<M> for C
{
    private int M => 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,17): error CS0102: The type 'R<M>' already contains a definition for 'M'
            //     private int M => 0;
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "M").WithArguments("R<M>", "M").WithLocation(4, 17)
            );
    }

    [Fact]
    public void Members_UnmatchedOperator()
    {
        var src = """
class C { }
explicit extension R for C
{
    public static bool operator true(R r) => throw null;
    public static bool operator ==(R r1, R r2) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,20): warning CS0660: 'R' defines operator == or operator != but does not override Object.Equals(object o)
            // explicit extension R for C
            Diagnostic(ErrorCode.WRN_EqualityOpWithoutEquals, "R").WithArguments("R").WithLocation(2, 20),
            // (2,20): warning CS0661: 'R' defines operator == or operator != but does not override Object.GetHashCode()
            // explicit extension R for C
            Diagnostic(ErrorCode.WRN_EqualityOpWithoutGetHashCode, "R").WithArguments("R").WithLocation(2, 20),
            // (4,33): error CS0216: The operator 'R.operator true(R)' requires a matching operator 'false' to also be defined
            //     public static bool operator true(R r) => throw null;
            Diagnostic(ErrorCode.ERR_OperatorNeedsMatch, "true").WithArguments("R.operator true(R)", "false").WithLocation(4, 33),
            // (5,33): error CS0216: The operator 'R.operator ==(R, R)' requires a matching operator '!=' to also be defined
            //     public static bool operator ==(R r1, R r2) => throw null;
            Diagnostic(ErrorCode.ERR_OperatorNeedsMatch, "==").WithArguments("R.operator ==(R, R)", "!=").WithLocation(5, 33)
            );
        // PROTOTYPE need to finalize rules on operators. Equals and GetHashCode can't be overridden...
    }

    [Theory]
    [InlineData("class")]
    [InlineData("struct")]
    [InlineData("interface")]
    [InlineData("enum")]
    public void Members_DefaultAccessibility(string type)
    {
        var src = $$"""
{{type}} UnderlyingType { }
explicit extension R for UnderlyingType { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            var r = module.GlobalNamespace.GetTypeMember("R");
            Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
        }
    }

    [Fact]
    public void Members_NoDefaultCtor_Delegate()
    {
        var src = $$"""
delegate void UnderlyingType();
explicit extension R for UnderlyingType { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            var r = module.GlobalNamespace.GetTypeMember("R");
            Assert.Empty(r.GetMembers());
        }
    }

    [Fact]
    public void Members_Operators_UsingUnderlyingType()
    {
        // PROTOTYPE need to finalize the rules for operators
        var src = """
class UnderlyingClass { }
explicit extension R for UnderlyingClass
{
    public static int operator+(UnderlyingClass c1, UnderlyingClass c2) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,31): error CS0563: One of the parameters of a binary operator must be the containing type
            //     public static int operator+(UnderlyingClass c1, UnderlyingClass c2) => throw null;
            Diagnostic(ErrorCode.ERR_BadBinaryOperatorSignature, "+").WithLocation(4, 31)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        AssertEx.Equal(new[] { "System.Int32 R.op_Addition(UnderlyingClass c1, UnderlyingClass c2)" }, r.GetMembers().ToTestDisplayStrings());
    }

    [Fact]
    public void Members_StaticExtension()
    {
        var src = """
interface I { }
class UnderlyingClass : I { }
static explicit extension R for UnderlyingClass
{
    public static int StaticField = 0;
    const string Const = "hello";

    void Method() { } // 1
    static void StaticMethod() { }

    int Property { get => throw null; set => throw null; } // 2
    static int StaticProperty { get => throw null; set => throw null; }
    int this[int i] => throw null; // 3

    class NestedType { }
    static class StaticNestedType { }
    explicit extension NestedR for UnderlyingClass { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (8,10): error CS0708: 'Method': cannot declare instance members in a static type
            //     void Method() { } // 1
            Diagnostic(ErrorCode.ERR_InstanceMemberInStaticClass, "Method").WithArguments("Method").WithLocation(8, 10),
            // (11,9): error CS0708: 'R.Property': cannot declare instance members in a static type
            //     int Property { get => throw null; set => throw null; } // 2
            Diagnostic(ErrorCode.ERR_InstanceMemberInStaticClass, "Property").WithArguments("R.Property").WithLocation(11, 9),
            // (13,9): error CS0720: 'R.this[int]': cannot declare indexers in a static type
            //     int this[int i] => throw null; // 3
            Diagnostic(ErrorCode.ERR_IndexerInStaticClass, "this").WithArguments("R.this[int]").WithLocation(13, 9)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
        Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
        AssertEx.Equal(new[]
            {
                "System.Int32 R.StaticField",
                "System.String R.Const",
                "void R.Method()",
                "void R.StaticMethod()",
                "System.Int32 R.Property { get; set; }",
                "System.Int32 R.Property.get",
                "void R.Property.set",
                "System.Int32 R.StaticProperty { get; set; }",
                "System.Int32 R.StaticProperty.get",
                "void R.StaticProperty.set",
                "System.Int32 R.this[System.Int32 i] { get; }",
                "System.Int32 R.this[System.Int32 i].get",
                "R.NestedType",
                "R.StaticNestedType",
                "R.NestedR",
                "R..cctor()"
            },
            r.GetMembers().ToTestDisplayStrings());

        Assert.True(r.IsStatic);
        Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
        Assert.Null(r.ContainingType);
        Assert.Empty(r.TypeParameters);
        Assert.False(r.IsGenericType);
    }

    [Fact]
    public void Members_ExplicitInterfaceImplementation()
    {
        var src = """
interface I
{
    void M();
}
class UnderlyingClass : I
{
    public void M() { }
}
explicit extension R1 for UnderlyingClass
{
    void I.M() { }
}
explicit extension R2 for UnderlyingClass : I
{
    void I.M() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (11,12): error CS0541: 'R1.M()': explicit interface declaration can only be declared in a class, record, struct or interface
            //     void I.M() { }
            Diagnostic(ErrorCode.ERR_ExplicitInterfaceImplementationInNonClassOrStruct, "M").WithArguments("R1.M()").WithLocation(11, 12),
            // (13,43): error CS8000: This language feature ('base extensions') is not yet implemented.
            // explicit extension R2 for UnderlyingClass : I
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": I").WithArguments("base extensions").WithLocation(13, 43),
            // (15,12): error CS0541: 'R2.M()': explicit interface declaration can only be declared in a class, record, struct or interface
            //     void I.M() { }
            Diagnostic(ErrorCode.ERR_ExplicitInterfaceImplementationInNonClassOrStruct, "M").WithArguments("R2.M()").WithLocation(15, 12)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        AssertEx.Equal(new[] { "void R1.M()" }, r1.GetMembers().ToTestDisplayStrings());

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        AssertEx.Equal(new[] { "void R2.M()" }, r2.GetMembers().ToTestDisplayStrings());

        if (new NoBaseExtensions().ShouldSkip) return;

        comp.VerifyDiagnostics(
           // (11,12): error CS0541: 'R1.M()': explicit interface declaration can only be declared in a class, record, struct or interface
           //     void I.M() { }
           Diagnostic(ErrorCode.ERR_ExplicitInterfaceImplementationInNonClassOrStruct, "M").WithArguments("R1.M()").WithLocation(11, 12),
           // (13,45): error CS9307: A base extension must be an extension type.
           // explicit extension R2 for UnderlyingClass : I
           Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "I").WithLocation(13, 45),
           // (15,12): error CS0541: 'R2.M()': explicit interface declaration can only be declared in a class, record, struct or interface
           //     void I.M() { }
           Diagnostic(ErrorCode.ERR_ExplicitInterfaceImplementationInNonClassOrStruct, "M").WithArguments("R2.M()").WithLocation(15, 12)
           );
    }

    [Fact]
    public void Members_Methods_AllowedModifiers()
    {
        var src = """
class UnderlyingClass { }
partial explicit extension R for UnderlyingClass
{
    void MethodDefaultAccessibility() { }
    public void MethodPublic() { }
    private void MethodPrivate() { }
    internal void MethodInternal() { }
    protected void MethodProtected() { }
    private protected void MethodPrivateProtected() { }
    internal protected void MethodInternalProtected() { }

    unsafe int* MethodUnsafe(int* i) => i;
    int* MethodNotUnsafe(int* i) => i; // 1, 2, 3
    new string ToString() => "";
    new void MethodNotNew() { }

    async System.Threading.Tasks.Task<int> MethodAsync()
    {
        await System.Threading.Tasks.Task.Yield();
        return 1;
    }

    static extern void MethodExtern(); // 4

    [System.Runtime.InteropServices.DllImport("test")]
    static extern void MethodExtern2();

    public partial int MethodPartial(int i);
    ref int MethodRefInt() => throw null;
    static void MethodStatic() { }
    ref readonly int MethodRefReadonly => throw null;
}
partial explicit extension R for UnderlyingClass
{
    public partial int MethodPartial(int i) => 1;
}
""";
        // PROTOTYPE should warn that `new` isn't required
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (13,5): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            //     int* MethodNotUnsafe(int* i) => i; // 1, 2, 3
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "int*").WithLocation(13, 5),
            // (13,26): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            //     int* MethodNotUnsafe(int* i) => i; // 1, 2, 3
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "int*").WithLocation(13, 26),
            // (13,37): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            //     int* MethodNotUnsafe(int* i) => i; // 1, 2, 3
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "i").WithLocation(13, 37),
            // (23,24): warning CS0626: Method, operator, or accessor 'R.MethodExtern()' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.
            //     static extern void MethodExtern(); // 4
            Diagnostic(ErrorCode.WRN_ExternMethodNoImplementation, "MethodExtern").WithArguments("R.MethodExtern()").WithLocation(23, 24)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        MethodSymbol methodDefaultAccessibility = r.GetMethod("MethodDefaultAccessibility");
        Assert.Equal(Accessibility.Private, methodDefaultAccessibility.DeclaredAccessibility);
        Assert.False(methodDefaultAccessibility.IsStatic);
        Assert.False(methodDefaultAccessibility.IsAsync);
        Assert.False(methodDefaultAccessibility.IsExplicitInterfaceImplementation);

        Assert.Equal(Accessibility.Public, r.GetMethod("MethodPublic").DeclaredAccessibility);
        Assert.Equal(Accessibility.Private, r.GetMethod("MethodPrivate").DeclaredAccessibility);
        Assert.Equal(Accessibility.Internal, r.GetMethod("MethodInternal").DeclaredAccessibility);
        Assert.Equal(Accessibility.Protected, r.GetMethod("MethodProtected").DeclaredAccessibility);
        Assert.Equal(Accessibility.ProtectedAndInternal, r.GetMethod("MethodPrivateProtected").DeclaredAccessibility);
        Assert.Equal(Accessibility.ProtectedOrInternal, r.GetMethod("MethodInternalProtected").DeclaredAccessibility);
        Assert.True(r.GetMethod("MethodAsync").IsAsync);
        Assert.True(r.GetMethod("MethodExtern").IsExtern);
        Assert.True(r.GetMethod("MethodExtern2").IsExtern);
        Assert.True(r.GetMethod("MethodStatic").IsStatic);
        Assert.True(r.GetProperty("MethodRefReadonly").ReturnsByRefReadonly);
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void Members_Methods_AllowedModifiers_New()
    {
        var src = """
class UnderlyingClass { }
explicit extension R1 for UnderlyingClass
{
    public void Method() { }
}
partial explicit extension R2 for UnderlyingClass : R1
{
    public new void Method() { }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void Members_Methods_AllowedModifiers_New_Missing()
    {
        var src = """
class UnderlyingClass { }
explicit extension R1 for UnderlyingClass
{
    public void Method() { }
}
partial explicit extension R2 for UnderlyingClass : R1
{
    public void Method() { }
}
""";

        // PROTOTYPE should warn about missing `new`
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void Members_Methods_DisallowedModifiers()
    {
        var src = """
interface I { }
class UnderlyingClass : I { }
explicit extension R for UnderlyingClass
{
    public abstract void M1(); // 1, 2
    override string ToString() => ""; // 3
    readonly void M3() { } // 4
    sealed void M4() { } // 5
    virtual void M5() { } // 6
    required void M6() { } // 7
    scoped System.Span<int> M7() => throw null; // 8
    file void M10() { } // 9
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (5,26): error CS0106: The modifier 'abstract' is not valid for this item
            //     public abstract void M1(); // 1, 2
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "M1").WithArguments("abstract").WithLocation(5, 26),
            // (5,26): error CS0501: 'R.M1()' must declare a body because it is not marked abstract, extern, or partial
            //     public abstract void M1(); // 1, 2
            Diagnostic(ErrorCode.ERR_ConcreteMissingBody, "M1").WithArguments("R.M1()").WithLocation(5, 26),
            // (6,21): error CS0106: The modifier 'override' is not valid for this item
            //     override string ToString() => ""; // 3
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "ToString").WithArguments("override").WithLocation(6, 21),
            // (7,19): error CS0106: The modifier 'readonly' is not valid for this item
            //     readonly void M3() { } // 4
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "M3").WithArguments("readonly").WithLocation(7, 19),
            // (8,17): error CS0106: The modifier 'sealed' is not valid for this item
            //     sealed void M4() { } // 5
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "M4").WithArguments("sealed").WithLocation(8, 17),
            // (9,18): error CS0106: The modifier 'virtual' is not valid for this item
            //     virtual void M5() { } // 6
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "M5").WithArguments("virtual").WithLocation(9, 18),
            // (10,19): error CS0106: The modifier 'required' is not valid for this item
            //     required void M6() { } // 7
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "M6").WithArguments("required").WithLocation(10, 19),
            // (11,29): error CS0106: The modifier 'scoped' is not valid for this item
            //     scoped System.Span<int> M7() => throw null; // 8
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "M7").WithArguments("scoped").WithLocation(11, 29),
            // (12,15): error CS0106: The modifier 'file' is not valid for this item
            //     file void M10() { } // 9
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "M10").WithArguments("file").WithLocation(12, 15)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        MethodSymbol m1 = r.GetMethod("M1");
        Assert.Equal(Accessibility.Public, m1.DeclaredAccessibility);
        Assert.False(m1.IsAbstract);
        Assert.False(r.GetMethod("M4").IsSealed);
        Assert.Equal(Accessibility.Private, r.GetMethod("M5").DeclaredAccessibility);
        Assert.False(r.GetMethod("M6").IsRequired());
    }

    [Fact]
    public void Members_Properties_AllowedModifiers()
    {
        var src = """
class UnderlyingClass { }
explicit extension R for UnderlyingClass
{
    int DefaultAccessibility => 0;
    public int Public => 0;
    private int Private => 0;
    internal int Internal => 0;
    protected int Protected => 0;
    private protected int PrivateProtected => 0;
    internal protected int InternalProtected => 0;
    unsafe int* Unsafe => null;
    int* NotUnsafe => null; // 1
    new int NotNew => 0;
    ref int RefInt => throw null;
    static int Static => 0;

    extern int Extern { get; } // 2
    static extern int Extern2 { [System.Runtime.InteropServices.DllImport("test")] get; }
    ref readonly int RefReadonlyInt => throw null;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        // PROTOTYPE should warn that `new` isn't required
        comp.VerifyDiagnostics(
            // (12,5): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            //     int* NotUnsafe => null; // 1
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "int*").WithLocation(12, 5),
            // (17,25): warning CS0626: Method, operator, or accessor 'R.Extern.get' is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation.
            //     extern int Extern { get; } // 2
            Diagnostic(ErrorCode.WRN_ExternMethodNoImplementation, "get").WithArguments("R.Extern.get").WithLocation(17, 25)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        var defaultAccessibility = r.GetProperty("DefaultAccessibility");
        Assert.Equal(Accessibility.Private, defaultAccessibility.DeclaredAccessibility);
        Assert.False(defaultAccessibility.IsStatic);
        Assert.False(defaultAccessibility.IsAbstract);
        Assert.False(defaultAccessibility.IsIndexer);
        Assert.False(defaultAccessibility.IsOverride);
        Assert.False(defaultAccessibility.IsVirtual);
        Assert.False(defaultAccessibility.IsSealed);
        Assert.False(defaultAccessibility.IsRequired);
        Assert.False(defaultAccessibility.IsExtern);
        Assert.False(defaultAccessibility.GetMethod.IsExtern);
        Assert.False(defaultAccessibility.IsExplicitInterfaceImplementation);

        Assert.Equal(Accessibility.Public, r.GetProperty("Public").DeclaredAccessibility);
        Assert.Equal(Accessibility.Private, r.GetProperty("Private").DeclaredAccessibility);
        Assert.Equal(Accessibility.Internal, r.GetProperty("Internal").DeclaredAccessibility);
        Assert.Equal(Accessibility.Protected, r.GetProperty("Protected").DeclaredAccessibility);
        Assert.Equal(Accessibility.ProtectedAndInternal, r.GetProperty("PrivateProtected").DeclaredAccessibility);
        Assert.Equal(Accessibility.ProtectedOrInternal, r.GetProperty("InternalProtected").DeclaredAccessibility);
        Assert.True(r.GetProperty("Static").IsStatic);

        var externProperty = r.GetProperty("Extern");
        Assert.True(externProperty.IsExtern);
        Assert.True(externProperty.GetMethod.IsExtern);

        var externProperty2 = r.GetProperty("Extern2");
        Assert.True(externProperty2.IsExtern);
        Assert.True(externProperty2.IsStatic);
        Assert.True(externProperty2.GetMethod.IsExtern);

        Assert.True(r.GetProperty("RefReadonlyInt").ReturnsByRefReadonly);
    }

    [Fact]
    public void Members_Properties_AllowedModifiers_New()
    {
        var src = """
class UnderlyingClass
{
    public int Property => 0;
}
explicit extension R1 for UnderlyingClass
{
    public new int Property => 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void Members_Properties_AllowedModifiers_New_Missing()
    {
        var src = """
class UnderlyingClass
{
    public int Property => 0;
}
explicit extension R1 for UnderlyingClass
{
    public int Property => 0;
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void Members_Properties_DisallowedModifiers()
    {
        var src = """
class UnderlyingClass { }
partial explicit extension R for UnderlyingClass
{
    async int Async => 0; // 1
    partial int Partial { get; } // 2, 3
    scoped System.Span<int> Scoped => throw null; // 4
    abstract int Abstract { get; } // 5, 6
    override int Override => 0; // 7
    readonly int Readonly => 0; // 8
    sealed int Sealed => 0; // 9
    public virtual int Virtual => 0; // 10

    public required int Required { get => throw null; set => throw null; } // 11
    public static required int StaticRequired { get => throw null; set => throw null; } // 12

    file int File => 0; // 13
}
""";
        // PROTOTYPE confirm spec on `required`
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (4,15): error CS0106: The modifier 'async' is not valid for this item
            //     async int Async => 0; // 1
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Async").WithArguments("async").WithLocation(4, 15),
            // (5,17): error CS9248: Partial property 'R.Partial' must have an implementation part.
            //     partial int Partial { get; } // 2, 3
            Diagnostic(ErrorCode.ERR_PartialPropertyMissingImplementation, "Partial").WithArguments("R.Partial").WithLocation(5, 17),
            // (6,29): error CS0106: The modifier 'scoped' is not valid for this item
            //     scoped System.Span<int> Scoped => throw null; // 4
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Scoped").WithArguments("scoped").WithLocation(6, 29),
            // (7,18): error CS0106: The modifier 'abstract' is not valid for this item
            //     abstract int Abstract { get; } // 5, 6
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Abstract").WithArguments("abstract").WithLocation(7, 18),
            // (7,18): error CS9313: 'R.Abstract': cannot declare instance members with state in extension types.
            //     abstract int Abstract { get; } // 5, 6
            Diagnostic(ErrorCode.ERR_StateInExtension, "Abstract").WithArguments("R.Abstract").WithLocation(7, 18),
            // (8,18): error CS0106: The modifier 'override' is not valid for this item
            //     override int Override => 0; // 7
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Override").WithArguments("override").WithLocation(8, 18),
            // (9,18): error CS0106: The modifier 'readonly' is not valid for this item
            //     readonly int Readonly => 0; // 8
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Readonly").WithArguments("readonly").WithLocation(9, 18),
            // (10,16): error CS0106: The modifier 'sealed' is not valid for this item
            //     sealed int Sealed => 0; // 9
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Sealed").WithArguments("sealed").WithLocation(10, 16),
            // (11,24): error CS0106: The modifier 'virtual' is not valid for this item
            //     public virtual int Virtual => 0; // 10
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Virtual").WithArguments("virtual").WithLocation(11, 24),
            // (13,25): error CS0106: The modifier 'required' is not valid for this item
            //     public required int Required { get => throw null; set => throw null; } // 11
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Required").WithArguments("required").WithLocation(13, 25),
            // (14,32): error CS0106: The modifier 'required' is not valid for this item
            //     public static required int StaticRequired { get => throw null; set => throw null; } // 12
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "StaticRequired").WithArguments("required").WithLocation(14, 32),
            // (16,14): error CS0106: The modifier 'file' is not valid for this item
            //     file int File => 0; // 13
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "File").WithArguments("file").WithLocation(16, 14)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.False(r.GetProperty("Abstract").IsAbstract);
        Assert.False(r.GetProperty("Override").IsOverride);
        Assert.False(r.GetProperty("Sealed").IsSealed);
        Assert.False(r.GetProperty("Virtual").IsVirtual);
        Assert.False(r.GetProperty("Required").IsRequired);
        Assert.False(r.GetProperty("StaticRequired").IsRequired);
    }

    [Fact]
    public void Members_Indexers_DisallowedModifiers_Static()
    {
        var src = """
class UnderlyingClass { }
partial explicit extension R for UnderlyingClass
{
    static int this[int i] => i;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,16): error CS0106: The modifier 'static' is not valid for this item
            //     static int this[int i] => i;
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "this").WithArguments("static").WithLocation(4, 16)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        AssertEx.Equal(new[] { "System.Int32 R.this[System.Int32 i] { get; }", "System.Int32 R.this[System.Int32 i].get" },
            r.GetMembers().ToTestDisplayStrings());

        Assert.False(r.GetIndexer<SourcePropertySymbol>("Item").IsStatic);
    }

    [Fact]
    public void Members_Events_AllowedModifiers()
    {
        var src = """
class UnderlyingClass { }
explicit extension R for UnderlyingClass
{
    event System.Action DefaultAccessibility { add => throw null; remove => throw null; }
    public event System.Action Public { add => throw null; remove => throw null; }
    private event System.Action Private { add => throw null; remove => throw null; }
    internal event System.Action Internal { add => throw null; remove => throw null; }
    protected event System.Action Protected { add => throw null; remove => throw null; }
    private protected event System.Action PrivateProtected { add => throw null; remove => throw null; }
    internal protected event System.Action InternalProtected { add => throw null; remove => throw null; }

    unsafe event System.Action Unsafe { add { int* i = null; } remove => throw null; }
    event System.Action NotUnsafe { add { int* i = null; } remove => throw null; } // 1
    new event System.Action NotNew { add => throw null; remove => throw null; }
    static event System.Action Static { add => throw null; remove => throw null; }

    extern event System.Action Extern { add => throw null; remove => throw null; } // 2, 3

    static extern event System.Action Extern2
    {
        [System.Runtime.InteropServices.DllImport("test")] add; // 4
        [System.Runtime.InteropServices.DllImport("test")] remove; // 5
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        // PROTOTYPE should warn that `new` isn't required
        comp.VerifyDiagnostics(
            // (13,43): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            //     event System.Action NotUnsafe { add { int* i = null; } remove => throw null; } // 1
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "int*").WithLocation(13, 43),
            // (17,41): error CS0179: 'R.Extern.add' cannot be extern and declare a body
            //     extern event System.Action Extern { add => throw null; remove => throw null; } // 2, 3
            Diagnostic(ErrorCode.ERR_ExternHasBody, "add").WithArguments("R.Extern.add").WithLocation(17, 41),
            // (17,60): error CS0179: 'R.Extern.remove' cannot be extern and declare a body
            //     extern event System.Action Extern { add => throw null; remove => throw null; } // 2, 3
            Diagnostic(ErrorCode.ERR_ExternHasBody, "remove").WithArguments("R.Extern.remove").WithLocation(17, 60),
            // (21,63): error CS0073: An add or remove accessor must have a body
            //         [System.Runtime.InteropServices.DllImport("test")] add; // 4
            Diagnostic(ErrorCode.ERR_AddRemoveMustHaveBody, ";").WithLocation(21, 63),
            // (22,66): error CS0073: An add or remove accessor must have a body
            //         [System.Runtime.InteropServices.DllImport("test")] remove; // 5
            Diagnostic(ErrorCode.ERR_AddRemoveMustHaveBody, ";").WithLocation(22, 66)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        var defaultAccessibility = r.GetEvent("DefaultAccessibility");
        Assert.Equal(Accessibility.Private, defaultAccessibility.DeclaredAccessibility);
        Assert.False(defaultAccessibility.IsStatic);
        Assert.False(defaultAccessibility.IsAbstract);
        Assert.False(defaultAccessibility.IsOverride);
        Assert.False(defaultAccessibility.IsVirtual);
        Assert.False(defaultAccessibility.IsSealed);
        Assert.False(defaultAccessibility.IsExtern);
        Assert.False(defaultAccessibility.AddMethod.IsExtern);
        Assert.False(defaultAccessibility.RemoveMethod.IsExtern);
        Assert.False(defaultAccessibility.IsExplicitInterfaceImplementation);

        Assert.Equal(Accessibility.Public, r.GetEvent("Public").DeclaredAccessibility);
        Assert.Equal(Accessibility.Private, r.GetEvent("Private").DeclaredAccessibility);
        Assert.Equal(Accessibility.Internal, r.GetEvent("Internal").DeclaredAccessibility);
        Assert.Equal(Accessibility.Protected, r.GetEvent("Protected").DeclaredAccessibility);
        Assert.Equal(Accessibility.ProtectedAndInternal, r.GetEvent("PrivateProtected").DeclaredAccessibility);
        Assert.Equal(Accessibility.ProtectedOrInternal, r.GetEvent("InternalProtected").DeclaredAccessibility);
        Assert.True(r.GetEvent("Static").IsStatic);

        var externEvent = r.GetEvent("Extern");
        Assert.True(externEvent.IsExtern);
        Assert.True(externEvent.AddMethod.IsExtern);
        Assert.True(externEvent.RemoveMethod.IsExtern);

        var externEvent2 = r.GetEvent("Extern2");
        Assert.True(externEvent2.IsExtern);
        Assert.True(externEvent2.IsStatic);
        Assert.True(externEvent2.AddMethod.IsExtern);
        Assert.True(externEvent2.RemoveMethod.IsExtern);
    }

    [Fact]
    public void Members_Events_AllowedModifiers_New()
    {
        var src = """
class UnderlyingClass
{
    public event System.Action Event { add => throw null; remove => throw null; }
}
explicit extension R1 for UnderlyingClass
{
    public new event System.Action Event { add => throw null; remove => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void Members_Events_AllowedModifiers_New_Missing()
    {
        var src = """
class UnderlyingClass
{
    public event System.Action Event { add => throw null; remove => throw null; }
}
explicit extension R1 for UnderlyingClass
{
    public event System.Action Event { add => throw null; remove => throw null; }
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void Members_Events_DisallowedModifiers()
    {
        var src = """
class UnderlyingClass { }
partial explicit extension R for UnderlyingClass
{
    async event System.Action Async { add => throw null; remove => throw null; } // 1
    partial event System.Action Partial { add => throw null; remove => throw null; } // 2
    abstract event System.Action Abstract { add => throw null; remove => throw null; } // 3
    override event System.Action Override { add => throw null; remove => throw null; } // 4
    readonly event System.Action Readonly { add => throw null; remove => throw null; } // 5
    sealed event System.Action Sealed { add => throw null; remove => throw null; } // 6
    public virtual event System.Action Virtual { add => throw null; remove => throw null; } // 7
    public required event System.Action Required { add => throw null; remove => throw null; } // 8
    public static required event System.Action StaticRequired { add => throw null; remove => throw null; } // 9
    file event System.Action File { add => throw null; remove => throw null; } // 10
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE should refine message for ERR_InvalidMemberDecl
        comp.VerifyDiagnostics(
            // (4,31): error CS0106: The modifier 'async' is not valid for this item
            //     async event System.Action Async { add => throw null; remove => throw null; } // 1
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Async").WithArguments("async").WithLocation(4, 31),
            // (5,13): error CS1519: Invalid token 'event' in class, record, struct, or interface member declaration
            //     partial event System.Action Partial { add => throw null; remove => throw null; } // 2
            Diagnostic(ErrorCode.ERR_InvalidMemberDecl, "event").WithArguments("event").WithLocation(5, 13),
            // (6,34): error CS0106: The modifier 'abstract' is not valid for this item
            //     abstract event System.Action Abstract { add => throw null; remove => throw null; } // 3
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Abstract").WithArguments("abstract").WithLocation(6, 34),
            // (7,34): error CS0106: The modifier 'override' is not valid for this item
            //     override event System.Action Override { add => throw null; remove => throw null; } // 4
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Override").WithArguments("override").WithLocation(7, 34),
            // (8,34): error CS0106: The modifier 'readonly' is not valid for this item
            //     readonly event System.Action Readonly { add => throw null; remove => throw null; } // 5
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Readonly").WithArguments("readonly").WithLocation(8, 34),
            // (9,32): error CS0106: The modifier 'sealed' is not valid for this item
            //     sealed event System.Action Sealed { add => throw null; remove => throw null; } // 6
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Sealed").WithArguments("sealed").WithLocation(9, 32),
            // (10,40): error CS0106: The modifier 'virtual' is not valid for this item
            //     public virtual event System.Action Virtual { add => throw null; remove => throw null; } // 7
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Virtual").WithArguments("virtual").WithLocation(10, 40),
            // (11,41): error CS0106: The modifier 'required' is not valid for this item
            //     public required event System.Action Required { add => throw null; remove => throw null; } // 8
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Required").WithArguments("required").WithLocation(11, 41),
            // (12,48): error CS0106: The modifier 'required' is not valid for this item
            //     public static required event System.Action StaticRequired { add => throw null; remove => throw null; } // 9
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "StaticRequired").WithArguments("required").WithLocation(12, 48),
            // (13,30): error CS0106: The modifier 'file' is not valid for this item
            //     file event System.Action File { add => throw null; remove => throw null; } // 10
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "File").WithArguments("file").WithLocation(13, 30)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.False(r.GetEvent("Abstract").IsAbstract);
        Assert.False(r.GetEvent("Override").IsOverride);
        Assert.False(r.GetEvent("Sealed").IsSealed);
        Assert.False(r.GetEvent("Virtual").IsVirtual);
    }

    [Theory, CombinatorialData]
    public void Members_ExtensionMethod_DisallowedInExtensionTypes(bool isStatic, bool isExplicit)
    {
        var staticKeyword = isStatic ? "static " : "";
        var keyword = isExplicit ? "explicit" : "implicit";

        var text = $$"""
public class C { }

public {{staticKeyword}}{{keyword}} extension R1 for C
{
    static void M(this int i) { } // 1
}
""";
        var comp = CreateCompilation(text);
        comp.VerifyDiagnostics(
            // (5,17): error CS9321: Extension methods are not allowed in extension types.
            //     static void M(this int i) { } // 1
            Diagnostic(ErrorCode.ERR_ExtensionMethodInExtension, "M").WithLocation(5, 17)
            );
    }

    [Fact]
    public void Members_ExtensionMethod_DisallowedInExtensionTypes_Invocation()
    {
        var src = """
new object().M();
object.M();

new object().M(null);
object.M(null);

implicit extension E for object
{
    public static string M(this object o) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS7036: There is no argument given that corresponds to the required parameter 'o' of 'E.M(object)'
            // new object().M();
            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "M").WithArguments("o", "E.M(object)").WithLocation(1, 14),
            // (2,8): error CS7036: There is no argument given that corresponds to the required parameter 'o' of 'E.M(object)'
            // object.M();
            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "M").WithArguments("o", "E.M(object)").WithLocation(2, 8),
            // (4,1): error CS0176: Member 'E.M(object)' cannot be accessed with an instance reference; qualify it with a type name instead
            // new object().M(null);
            Diagnostic(ErrorCode.ERR_ObjectProhibited, "new object().M").WithArguments("E.M(object)").WithLocation(4, 1),
            // (9,26): error CS9321: Extension methods are not allowed in extension types.
            //     public static string M(this object o) => throw null;
            Diagnostic(ErrorCode.ERR_ExtensionMethodInExtension, "M").WithLocation(9, 26));
    }

    [Fact]
    public void Members_ExtensionMethod_DisallowedInExtensionTypes_InferredVariable_Static()
    {
        var src = """
var x = object.M;

implicit extension E for object
{
    public static string M(this object o) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,26): error CS9321: Extension methods are not allowed in extension types.
            //     public static string M(this object o) => throw null;
            Diagnostic(ErrorCode.ERR_ExtensionMethodInExtension, "M").WithLocation(5, 26));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.M(this System.Object o)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.M");
        Assert.Equal("System.Func<System.Object, System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void Members_ExtensionMethod_DisallowedInExtensionTypes_InferredVariable_Instance()
    {
        var src = """
var x = new object().M;

implicit extension E for object
{
    public static string M(this object o) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0176: Member 'E.M(object)' cannot be accessed with an instance reference; qualify it with a type name instead
            // var x = new object().M;
            Diagnostic(ErrorCode.ERR_ObjectProhibited, "new object().M").WithArguments("E.M(object)").WithLocation(1, 9),
            // (5,26): error CS9321: Extension methods are not allowed in extension types.
            //     public static string M(this object o) => throw null;
            Diagnostic(ErrorCode.ERR_ExtensionMethodInExtension, "M").WithLocation(5, 26));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);

        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = new object().M");
        Assert.Equal("System.Func<System.Object, System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void Members_ExtensionMethod_StaticExtension_StaticMethod_InThisParameter()
    {
        var src = """
class UnderlyingClass { }
static explicit extension R1 for UnderlyingClass
{
    public static void M(in this int i) { } // 1
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,24): error CS9321: Extension methods are not allowed in extension types.
            //     public static void M(in this int i) { } // 1
            Diagnostic(ErrorCode.ERR_ExtensionMethodInExtension, "M").WithLocation(4, 24)
            );
    }

    [Fact]
    public void Members_ExtensionMethod_DisallowExtensionThisParameter()
    {
        var text = $$"""
public class C { }

public implicit extension R for C { }

public static class E
{
    static void M(this R r) { } // 1
}
""";
        var comp = CreateCompilation(text);
        comp.VerifyDiagnostics(
            // (7,24): error CS1103: The first parameter of an extension method cannot be of type 'R'
            //     static void M(this R r) { } // 1
            Diagnostic(ErrorCode.ERR_BadTypeforThis, "R").WithArguments("R").WithLocation(7, 24)
            );
    }

    [Fact]
    public void TypeMembers_Delegate()
    {
        var src = """
explicit extension R for int
{
    delegate void Delegate();
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var d = comp.GlobalNamespace.GetTypeMember("R").GetTypeMember("Delegate");
        Assert.Equal("R.Delegate", d.ToTestDisplayString());
        Assert.Equal("R", d.ContainingType.ToTestDisplayString());
        Assert.True(d.IsDelegateType());
    }

    [Fact]
    public void TypeMembers_Struct()
    {
        var src = """
explicit extension R for int
{
    struct S { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var d = comp.GlobalNamespace.GetTypeMember("R").GetTypeMember("S");
        Assert.Equal("R.S", d.ToTestDisplayString());
        Assert.Equal("R", d.ContainingType.ToTestDisplayString());
    }

    [Fact]
    public void TypeMembers_Struct_AllowedModifiers()
    {
        var src = """
explicit extension R for int
{
    struct DefaultAccessibility { }
    public struct Public { }
    private struct Private { }
    internal struct Internal { }
    protected struct Protected { }
    private protected struct PrivateProtected { }
    internal protected struct InternalProtected { }
    unsafe struct Unsafe { void M(int* i) => throw null; }
    struct NotUnsafe { void M(int* i) => throw null; } // 1
    new struct NotNew { }
    partial struct Partial { }
    readonly struct Readonly { }
    ref struct Ref { }
}
partial explicit extension R2 for int
{
    partial struct Partial { }
}
partial explicit extension R2 for int
{
    partial struct Partial { }
}
""";
        // PROTOTYPE should warn that `new` isn't required
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (11,31): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            //     struct NotUnsafe { void M(int* i) => throw null; } // 1
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "int*").WithLocation(11, 31)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        var defaultAccessibility = r.GetTypeMember("DefaultAccessibility");
        Assert.Equal(Accessibility.Private, defaultAccessibility.DeclaredAccessibility);
        Assert.False(defaultAccessibility.IsStatic);
        Assert.False(defaultAccessibility.IsAbstract);
        Assert.False(defaultAccessibility.IsOverride);
        Assert.False(defaultAccessibility.IsVirtual);
        Assert.True(defaultAccessibility.IsSealed);
        Assert.False(defaultAccessibility.IsExtern);
        Assert.False(defaultAccessibility.IsReadOnly);

        Assert.Equal(Accessibility.Public, r.GetTypeMember("Public").DeclaredAccessibility);
        Assert.Equal(Accessibility.Private, r.GetTypeMember("Private").DeclaredAccessibility);
        Assert.Equal(Accessibility.Internal, r.GetTypeMember("Internal").DeclaredAccessibility);
        Assert.Equal(Accessibility.Protected, r.GetTypeMember("Protected").DeclaredAccessibility);
        Assert.Equal(Accessibility.ProtectedAndInternal, r.GetTypeMember("PrivateProtected").DeclaredAccessibility);
        Assert.Equal(Accessibility.ProtectedOrInternal, r.GetTypeMember("InternalProtected").DeclaredAccessibility);
        Assert.True(r.GetTypeMember("Readonly").IsReadOnly);
    }

    [Fact]
    public void TypeMembers_Struct_DisallowedModifiers()
    {
        var src = """
explicit extension R for int
{
    async struct Async { } // 1
    abstract struct Abstract { } // 2
    override struct Override { } // 3
    sealed struct Sealed { } // 4
    virtual struct Virtual { } // 5
    required struct Required { } // 6
    file struct File { } // 7
    static struct Static { } // 8
    ref record struct RefRecordStruct { } // 9
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (3,18): error CS0106: The modifier 'async' is not valid for this item
            //     async struct Async { } // 1
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Async").WithArguments("async").WithLocation(3, 18),
            // (4,21): error CS0106: The modifier 'abstract' is not valid for this item
            //     abstract struct Abstract { } // 2
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Abstract").WithArguments("abstract").WithLocation(4, 21),
            // (5,21): error CS0106: The modifier 'override' is not valid for this item
            //     override struct Override { } // 3
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Override").WithArguments("override").WithLocation(5, 21),
            // (6,19): error CS0106: The modifier 'sealed' is not valid for this item
            //     sealed struct Sealed { } // 4
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Sealed").WithArguments("sealed").WithLocation(6, 19),
            // (7,20): error CS0106: The modifier 'virtual' is not valid for this item
            //     virtual struct Virtual { } // 5
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Virtual").WithArguments("virtual").WithLocation(7, 20),
            // (8,21): error CS0106: The modifier 'required' is not valid for this item
            //     required struct Required { } // 6
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Required").WithArguments("required").WithLocation(8, 21),
            // (9,17): error CS9054: File-local type 'R.File' must be defined in a top level type; 'R.File' is a nested type.
            //     file struct File { } // 7
            Diagnostic(ErrorCode.ERR_FileTypeNested, "File").WithArguments("R.File").WithLocation(9, 17),
            // (10,19): error CS0106: The modifier 'static' is not valid for this item
            //     static struct Static { } // 8
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Static").WithArguments("static").WithLocation(10, 19),
            // (11,23): error CS0106: The modifier 'ref' is not valid for this item
            //     ref record struct RefRecordStruct { } // 9
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "RefRecordStruct").WithArguments("ref").WithLocation(11, 23)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.False(r.GetTypeMember("Abstract").IsAbstract);
        Assert.False(r.GetTypeMember("Override").IsOverride);
        Assert.True(r.GetTypeMember("Sealed").IsSealed);
        Assert.False(r.GetTypeMember("Virtual").IsVirtual);
    }

    [Fact]
    public void TypeMembers_Class_AllowedModifiers()
    {
        var src = """
explicit extension R for int
{
    class DefaultAccessibility { }
    public class Public { }
    private class Private { }
    internal class Internal { }
    protected class Protected { }
    private protected class PrivateProtected { }
    internal protected class InternalProtected { }
    unsafe class Unsafe { void M(int* i) => throw null; }
    class NotUnsafe { void M(int* i) => throw null; } // 1
    new class NotNew { }
    partial class Partial { }
    sealed class Sealed { }
    static class Static { }
    abstract class Abstract { }
}
""";
        // PROTOTYPE should warn that `new` isn't required
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (11,30): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            //     class NotUnsafe { void M(int* i) => throw null; } // 1
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "int*").WithLocation(11, 30)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        var defaultAccessibility = r.GetTypeMember("DefaultAccessibility");
        Assert.Equal(Accessibility.Private, defaultAccessibility.DeclaredAccessibility);
        Assert.False(defaultAccessibility.IsStatic);
        Assert.False(defaultAccessibility.IsAbstract);
        Assert.False(defaultAccessibility.IsOverride);
        Assert.False(defaultAccessibility.IsVirtual);
        Assert.False(defaultAccessibility.IsSealed);
        Assert.False(defaultAccessibility.IsExtern);
        Assert.False(defaultAccessibility.IsReadOnly);

        Assert.Equal(Accessibility.Public, r.GetTypeMember("Public").DeclaredAccessibility);
        Assert.Equal(Accessibility.Private, r.GetTypeMember("Private").DeclaredAccessibility);
        Assert.Equal(Accessibility.Internal, r.GetTypeMember("Internal").DeclaredAccessibility);
        Assert.Equal(Accessibility.Protected, r.GetTypeMember("Protected").DeclaredAccessibility);
        Assert.Equal(Accessibility.ProtectedAndInternal, r.GetTypeMember("PrivateProtected").DeclaredAccessibility);
        Assert.Equal(Accessibility.ProtectedOrInternal, r.GetTypeMember("InternalProtected").DeclaredAccessibility);
        Assert.True(r.GetTypeMember("Sealed").IsSealed);
        Assert.True(r.GetTypeMember("Abstract").IsAbstract);
    }

    [Fact]
    public void TypeMembers_Class_DisallowedModifiers()
    {
        var src = """
explicit extension R for int
{
    async class Async { } // 1
    override class Override { } // 2
    virtual class Virtual { } // 3
    required class Required { } // 4
    file class File { } // 5
    readonly class Readonly { } // 6
    static record StaticRecord { } // 7
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (3,17): error CS0106: The modifier 'async' is not valid for this item
            //     async class Async { } // 1
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Async").WithArguments("async").WithLocation(3, 17),
            // (4,20): error CS0106: The modifier 'override' is not valid for this item
            //     override class Override { } // 2
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Override").WithArguments("override").WithLocation(4, 20),
            // (5,19): error CS0106: The modifier 'virtual' is not valid for this item
            //     virtual class Virtual { } // 3
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Virtual").WithArguments("virtual").WithLocation(5, 19),
            // (6,20): error CS0106: The modifier 'required' is not valid for this item
            //     required class Required { } // 4
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Required").WithArguments("required").WithLocation(6, 20),
            // (7,16): error CS9054: File-local type 'R.File' must be defined in a top level type; 'R.File' is a nested type.
            //     file class File { } // 5
            Diagnostic(ErrorCode.ERR_FileTypeNested, "File").WithArguments("R.File").WithLocation(7, 16),
            // (8,20): error CS0106: The modifier 'readonly' is not valid for this item
            //     readonly class Readonly { } // 6
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Readonly").WithArguments("readonly").WithLocation(8, 20),
            // (9,19): error CS0106: The modifier 'static' is not valid for this item
            //     static record StaticRecord { } // 7
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "StaticRecord").WithArguments("static").WithLocation(9, 19)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.False(r.GetTypeMember("Override").IsOverride);
        Assert.False(r.GetTypeMember("Virtual").IsVirtual);
        Assert.False(r.GetTypeMember("Readonly").IsReadOnly);
    }

    [Fact]
    public void TypeMembers_Interface_AllowedModifiers()
    {
        var src = """
explicit extension R for int
{
    interface DefaultAccessibility { }
    public interface Public { }
    private interface Private { }
    internal interface Internal { }
    protected interface Protected { }
    private protected interface PrivateProtected { }
    internal protected interface InternalProtected { }
    unsafe interface Unsafe { void M(int* i) => throw null; }
    interface NotUnsafe { void M(int* i) => throw null; } // 1
    new interface NotNew { }
    partial interface Partial { }
}
""";
        // PROTOTYPE should warn that `new` isn't required
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (11,34): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            //     interface NotUnsafe { void M(int* i) => throw null; } // 1
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "int*").WithLocation(11, 34)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        var defaultAccessibility = r.GetTypeMember("DefaultAccessibility");
        Assert.Equal(Accessibility.Private, defaultAccessibility.DeclaredAccessibility);
        Assert.False(defaultAccessibility.IsStatic);
        Assert.True(defaultAccessibility.IsAbstract);
        Assert.False(defaultAccessibility.IsOverride);
        Assert.False(defaultAccessibility.IsVirtual);
        Assert.False(defaultAccessibility.IsSealed);
        Assert.False(defaultAccessibility.IsExtern);
        Assert.False(defaultAccessibility.IsReadOnly);

        Assert.Equal(Accessibility.Public, r.GetTypeMember("Public").DeclaredAccessibility);
        Assert.Equal(Accessibility.Private, r.GetTypeMember("Private").DeclaredAccessibility);
        Assert.Equal(Accessibility.Internal, r.GetTypeMember("Internal").DeclaredAccessibility);
        Assert.Equal(Accessibility.Protected, r.GetTypeMember("Protected").DeclaredAccessibility);
        Assert.Equal(Accessibility.ProtectedAndInternal, r.GetTypeMember("PrivateProtected").DeclaredAccessibility);
        Assert.Equal(Accessibility.ProtectedOrInternal, r.GetTypeMember("InternalProtected").DeclaredAccessibility);
    }

    [Fact]
    public void TypeMembers_Interface_DisallowedModifiers()
    {
        var src = """
explicit extension R for int
{
    async interface Async { } // 1
    abstract interface Abstract { } // 2
    override interface Override { } // 3
    virtual interface Virtual { } // 4
    required interface Required { } // 5
    file interface File { } // 6
    readonly interface Readonly { } // 7
    sealed interface Sealed { } // 8
    static interface Static { } // 9
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (3,21): error CS0106: The modifier 'async' is not valid for this item
            //     async interface Async { } // 1
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Async").WithArguments("async").WithLocation(3, 21),
            // (4,24): error CS0106: The modifier 'abstract' is not valid for this item
            //     abstract interface Abstract { } // 2
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Abstract").WithArguments("abstract").WithLocation(4, 24),
            // (5,24): error CS0106: The modifier 'override' is not valid for this item
            //     override interface Override { } // 3
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Override").WithArguments("override").WithLocation(5, 24),
            // (6,23): error CS0106: The modifier 'virtual' is not valid for this item
            //     virtual interface Virtual { } // 4
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Virtual").WithArguments("virtual").WithLocation(6, 23),
            // (7,24): error CS0106: The modifier 'required' is not valid for this item
            //     required interface Required { } // 5
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Required").WithArguments("required").WithLocation(7, 24),
            // (8,20): error CS9054: File-local type 'R.File' must be defined in a top level type; 'R.File' is a nested type.
            //     file interface File { } // 6
            Diagnostic(ErrorCode.ERR_FileTypeNested, "File").WithArguments("R.File").WithLocation(8, 20),
            // (9,24): error CS0106: The modifier 'readonly' is not valid for this item
            //     readonly interface Readonly { } // 7
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Readonly").WithArguments("readonly").WithLocation(9, 24),
            // (10,22): error CS0106: The modifier 'sealed' is not valid for this item
            //     sealed interface Sealed { } // 8
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Sealed").WithArguments("sealed").WithLocation(10, 22),
            // (11,22): error CS0106: The modifier 'static' is not valid for this item
            //     static interface Static { } // 9
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Static").WithArguments("static").WithLocation(11, 22)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.True(r.GetTypeMember("Abstract").IsAbstract);
        Assert.False(r.GetTypeMember("Override").IsOverride);
        Assert.False(r.GetTypeMember("Virtual").IsVirtual);
        Assert.False(r.GetTypeMember("Readonly").IsReadOnly);
        Assert.False(r.GetTypeMember("Sealed").IsSealed);
        Assert.False(r.GetTypeMember("Static").IsStatic);
    }

    [Fact]
    public void ForStruct()
    {
        var src = """
interface I { }
struct UnderlyingStruct : I { }
explicit extension R for UnderlyingStruct
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var r = module.GlobalNamespace.GetTypeMember("R");

            Assert.Equal("R", r.ToTestDisplayString());
            if (inSource)
            {
                VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
            }
            else
            {
                VerifyExtension<PENamedTypeSymbol>(r, isExplicit: true);
            }

            Assert.Equal("UnderlyingStruct", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.GetMembers());

            Assert.Null(r.BaseTypeNoUseSiteDiagnostics);
            Assert.False(r.IsStatic);

            Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
            Assert.Null(r.ContainingType);
            Assert.Empty(r.TypeParameters);
        }
    }

    [Theory, CombinatorialData]
    public void ForTypeParameter(bool isExplicit)
    {
        var src = $$"""
interface I { }
{{(isExplicit ? "explicit" : "implicit")}} extension R<T> for T where T : I
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var r = module.GlobalNamespace.GetTypeMember("R");
            Assert.Equal("R<T>", r.ToTestDisplayString());
            if (inSource)
            {
                VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: isExplicit);
            }
            else
            {
                VerifyExtension<PENamedTypeSymbol>(r, isExplicit: isExplicit);
            }

            Assert.Equal("T", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.GetMembers());

            Assert.Null(r.BaseTypeNoUseSiteDiagnostics);
            Assert.False(r.IsStatic);

            Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
            Assert.Null(r.ContainingType);
            Assert.Equal(new[] { "T" }, r.TypeParameters.ToTestDisplayStrings());
        }
    }

    [Theory, CombinatorialData]
    public void ForEnum(bool isExplicit)
    {
        var src = $$"""
enum E { }
{{(isExplicit ? "explicit" : "implicit")}} extension R for E
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var r = module.GlobalNamespace.GetTypeMember("R");
            Assert.Equal("R", r.ToTestDisplayString());
            if (inSource)
            {
                VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: isExplicit);
            }
            else
            {
                VerifyExtension<PENamedTypeSymbol>(r, isExplicit: isExplicit);
            }

            Assert.Equal("E", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.GetMembers());

            Assert.Null(r.BaseTypeNoUseSiteDiagnostics);
            Assert.False(r.IsStatic);

            Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
            Assert.Null(r.ContainingType);
            Assert.Empty(r.TypeParameters);
        }
    }

    [Fact]
    public void ForObject()
    {
        var src = """
explicit extension R for object
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("System.Object", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
        Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
        Assert.Empty(r.GetMembers());
        Assert.Null(r.BaseTypeNoUseSiteDiagnostics);
        Assert.False(r.IsStatic);

        Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
        Assert.Null(r.ContainingType);
        Assert.Empty(r.TypeParameters);
    }

    [Fact]
    public void ForSubstitutedType()
    {
        var src = """
class C<T> { }
explicit extension R<U> for C<U>
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var r = module.GlobalNamespace.GetTypeMember("R");
            Assert.Equal("R<U>", r.ToTestDisplayString());
            if (inSource)
            {
                VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
            }
            else
            {
                VerifyExtension<PENamedTypeSymbol>(r, isExplicit: true);
            }

            Assert.Equal("C<U>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.GetMembers());

            Assert.Null(r.BaseTypeNoUseSiteDiagnostics);
            Assert.False(r.IsStatic);

            Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
            Assert.Null(r.ContainingType);
            Assert.Equal(new[] { "U" }, r.TypeParameters.ToTestDisplayStrings());
        }
    }

    [Fact]
    public void ForTuple()
    {
        var src = """
explicit extension R for (int, int)
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var r = module.GlobalNamespace.GetTypeMember("R");
            Assert.Equal("R", r.ToTestDisplayString());
            if (inSource)
            {
                VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
            }
            else
            {
                VerifyExtension<PENamedTypeSymbol>(r, isExplicit: true);
            }

            Assert.Equal("(System.Int32, System.Int32)", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.GetMembers());

            Assert.Null(r.BaseTypeNoUseSiteDiagnostics);
            Assert.False(r.IsStatic);

            Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
            Assert.Null(r.ContainingType);
            Assert.Empty(r.TypeParameters);
        }
    }

    [Fact]
    public void ForArrayType()
    {
        var src = """
explicit extension R for int[]
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var r = module.GlobalNamespace.GetTypeMember("R");
            Assert.Equal("R", r.ToTestDisplayString());
            if (inSource)
            {
                VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
            }
            else
            {
                VerifyExtension<PENamedTypeSymbol>(r, isExplicit: true);
            }

            Assert.Equal("System.Int32[]", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.GetMembers());

            Assert.Null(r.BaseTypeNoUseSiteDiagnostics);
            Assert.False(r.IsStatic);

            Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
            Assert.Null(r.ContainingType);
            Assert.Empty(r.TypeParameters);
        }
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void Scopes()
    {
        var src = """
class ContainingType<TContaining>
{
    class UnderlyingClass<T> { }
    explicit extension BaseExtension<T> for UnderlyingClass<T> { }
    explicit extension R1 for UnderlyingClass<TContaining> : BaseExtension<TContaining> { }
    explicit extension R2<TCurrent> for UnderlyingClass<TCurrent> : BaseExtension<TCurrent> { }
    explicit extension R3 for UnderlyingClass<C> : BaseExtension<C>
    {
        class C { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (7,47): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)
            //     explicit extension R3 for UnderlyingClass<C> : BaseExtension<C>
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "C").WithArguments("C").WithLocation(7, 47),
            // (7,66): error CS0246: The type or namespace name 'C' could not be found (are you missing a using directive or an assembly reference?)
            //     explicit extension R3 for UnderlyingClass<C> : BaseExtension<C>
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "C").WithArguments("C").WithLocation(7, 66)
            );
    }

    [Fact]
    public void WithTypeParameters_Explicit()
    {
        var src = """
interface I { }
class UnderlyingClass : I { }
explicit extension R<T1, T2> for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal(new[] { "T1", "T2" }, r.TypeParameters.ToTestDisplayStrings());
        Assert.True(r.IsGenericType);
        Assert.Equal(2, r.Arity);
    }

    [Fact]
    public void WithTypeParameters_Variance()
    {
        var src = """
class C { }
explicit extension R<in T1, out T2> for C
{
    T1 M1(T1 t1) => throw null;
    T2 M2(T2 t2) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,22): error CS1960: Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.
            // explicit extension R<in T1, out T2> for UnderlyingClass
            Diagnostic(ErrorCode.ERR_IllegalVarianceSyntax, "in").WithLocation(2, 22),
            // (2,29): error CS1960: Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.
            // explicit extension R<in T1, out T2> for UnderlyingClass
            Diagnostic(ErrorCode.ERR_IllegalVarianceSyntax, "out").WithLocation(2, 29)
            );
    }

    [Fact]
    public void VarianceInterfaceNesting()
    {
        var src = """
class C { }
interface I<T>
{
    explicit extension R for C { }
}
interface IIn<in T>
{
    explicit extension R for C { }
}
interface IOut<out T>
{
    explicit extension R for C { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (8,24): error CS8427: Enums, classes, structures, and extensions cannot be declared in an interface that has an 'in' or 'out' type parameter.
            //     explicit extension R for C { }
            Diagnostic(ErrorCode.ERR_VarianceInterfaceNesting, "R").WithLocation(8, 24),
            // (12,24): error CS8427: Enums, classes, structures, and extensions cannot be declared in an interface that has an 'in' or 'out' type parameter.
            //     explicit extension R for C { }
            Diagnostic(ErrorCode.ERR_VarianceInterfaceNesting, "R").WithLocation(12, 24)
            );
    }

    [Fact]
    public void WithPrimaryConstructor()
    {
        var src = """
interface I { }
class UnderlyingClass : I { }
explicit extension R(int i) for UnderlyingClass { }
""";
        // PROTOTYPE should parse but remain error
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,21): error CS9122: Unexpected parameter list.
            // explicit extension R(int i) for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_UnexpectedParameterList, "(int i)").WithLocation(3, 21));

        // No constructor, despite the presence of an invalid primary constructor in syntax.
        var rType = comp.GetTypeByMetadataName("R");
        Assert.Empty(rType.Constructors);
    }

    [Fact]
    public void UnderlyingType_InstanceType_StaticExtension()
    {
        var src = """
class UnderlyingClass { }
static explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.True(r.IsStatic);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void UnderlyingType_StaticType_StaticExtension()
    {
        var src = """
static class UnderlyingClass { }
static explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.True(r.IsStatic);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void UnderlyingType_StaticType_InstanceExtension()
    {
        var src = """
static class UnderlyingClass { }
explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.False(r.IsStatic);
        comp.VerifyDiagnostics(
            // (2,26): error CS9306: Instance extension 'R' cannot extend type 'UnderlyingClass' because it is static.
            // explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_StaticBaseTypeOnInstanceExtension, "UnderlyingClass").WithArguments("R", "UnderlyingClass").WithLocation(2, 26)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void UnderlyingType_StaticType_InstanceExtension_PE()
    {
        // static class C { }
        // explicit extension R for C { }
        var ilSource = """
.class public auto ansi abstract sealed beforefieldinit C
    extends [mscorlib]System.Object
{
}

.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method private hidebysig static void '<ExplicitExtension>$'(class C '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R3 for C : R1 { }
public static explicit extension R4 for C : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        // PROTOTYPE: should report use-site diagnostics for R1 instead
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R3' extends 'C' but base extension 'R1' extends 'C'.
            // public explicit extension R3 for C : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R3").WithArguments("R3", "C", "R1", "C").WithLocation(1, 27),
            // (1,34): error CS9306: Instance extension 'R3' cannot extend type 'C' because it is static.
            // public explicit extension R3 for C : R1 { }
            Diagnostic(ErrorCode.ERR_StaticBaseTypeOnInstanceExtension, "C").WithArguments("R3", "C").WithLocation(1, 34),
            // (2,34): error CS9316: Extension 'R4' extends 'C' but base extension 'R1' extends 'C'.
            // public static explicit extension R4 for C : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R4").WithArguments("R4", "C", "R1", "C").WithLocation(2, 34)
            );

        var r1 = (PENamedTypeSymbol)comp.GlobalNamespace.GetTypeMember("R1");
        var r1ExtendedType = r1.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.Equal("C", r1ExtendedType.ToTestDisplayString());
        Assert.True(r1ExtendedType.IsErrorType());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void UnderlyingType_StaticType_InstanceExtension_Retargeting()
    {
        var src1 = """
public class C { }
""";
        var comp1 = CreateCompilation(src1,
            assemblyName: "first");
        comp1.VerifyDiagnostics();

        var src2 = """
public explicit extension E1 for C { }
""";
        var comp2 = CreateCompilation(src2,
            references: new[] { comp1.EmitToImageReference() });
        comp2.VerifyDiagnostics();

        var src1Updated = """
public static class C { }
""";
        var comp1Updated = CreateCompilation(src1Updated,
            assemblyName: "first");
        comp1Updated.VerifyDiagnostics();

        var src = """
public explicit extension E2 for C : E1 { }
""";
        // PROTOTYPE : should report use-site diagnostics for using E1
        var comp = CreateCompilation(src,
            references: new[] { comp2.ToMetadataReference(), comp1Updated.EmitToImageReference() });
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'E2' extends 'C' but base extension 'E1' extends 'C'.
            // public explicit extension E2 for C : E1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "E2").WithArguments("E2", "C", "E1", "C").WithLocation(1, 27),
            // (1,34): error CS9306: Instance extension 'E2' cannot extend type 'C' because it is static.
            // public explicit extension E2 for C : E1 { }
            Diagnostic(ErrorCode.ERR_StaticBaseTypeOnInstanceExtension, "C").WithArguments("E2", "C").WithLocation(1, 34)
            );

        if (new NoBaseExtensions().ShouldSkip) return;

        var e2 = comp.GlobalNamespace.GetTypeMember("E2");
        var e1 = (RetargetingNamedTypeSymbol)e2.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("E1", e1.Name);
        AssertEx.Equal("error CS8090: There is an error in a referenced assembly 'first, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.",
            ((ErrorTypeSymbol)e1.GetExtendedTypeNoUseSiteDiagnostics(null)).ErrorInfo.ToString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingType_Extension(bool isExplicit)
    {
        var keyword = isExplicit ? "explicit" : "implicit";

        var text = $$"""
public explicit extension E0 for object { }

public {{keyword}} extension E1 for E0
{
}
""";
        var comp = CreateCompilation(text);
        comp.VerifyDiagnostics(
            // (3,34): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // public explicit extension E1 for E0
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "E0").WithLocation(3, 34)
            );
    }

    [ConditionalTheory(typeof(NoBaseExtensions)), CombinatorialData]
    public void UnderlyingType_Extension_Retargeting(bool isExplicit)
    {
        var src1 = $$"""
public class E0 { }
public {{(isExplicit ? "explicit" : "implicit")}} extension E1 for E0 { }
""";
        var comp1 = CreateCompilation(src1, assemblyName: "first",
            targetFramework: TargetFramework.Net70);
        comp1.VerifyDiagnostics();

        var src2 = """
public explicit extension E2 for E0 : E1 { }
""";

        var comp2 = CreateCompilation(src2, references: new[] { comp1.ToMetadataReference() },
            targetFramework: TargetFramework.Net70);
        comp2.VerifyDiagnostics();

        var src1Updated = $$"""
public {{(isExplicit ? "explicit" : "implicit")}} extension E0 for E1 { }
public class E1 { }
""";
        var comp1Updated = CreateCompilation(src1Updated, assemblyName: "first",
            targetFramework: TargetFramework.Net70);
        comp1Updated.VerifyDiagnostics();

        var src = """
public explicit extension E3 for E1 : E2 { }
public explicit extension E4 for E0 : E2 { }
""";
        var comp = CreateCompilation(src,
            references: new[] { comp2.ToMetadataReference(), comp1Updated.EmitToImageReference() });
        // PROTOTYPE The diagnostic for using E2 should mention the faulty type
        comp.VerifyDiagnostics(
            // (1,27): error CS8090: There is an error in a referenced assembly 'first, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // public explicit extension E3 for E1 : E2 { }
            Diagnostic(ErrorCode.ERR_ErrorInReferencedAssembly, "E3").WithArguments("first, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 27),
            // (1,27): error CS9316: Extension 'E3' extends 'E1' but base extension 'E2' extends 'E0'.
            // public explicit extension E3 for E1 : E2 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "E3").WithArguments("E3", "E1", "E2", "E0").WithLocation(1, 27),
            // (2,27): error CS8090: There is an error in a referenced assembly 'first, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // public explicit extension E4 for E0 : E2 { }
            Diagnostic(ErrorCode.ERR_ErrorInReferencedAssembly, "E4").WithArguments("first, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(2, 27),
            // (2,34): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // public explicit extension E4 for E0 : E2 { }
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "E0").WithLocation(2, 34)
            );

        var e2 = (RetargetingNamedTypeSymbol)comp.GlobalNamespace.GetTypeMember("E2");

        AssertEx.Equal("error CS8090: There is an error in a referenced assembly 'first, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.",
            ((ErrorTypeSymbol)e2.GetExtendedTypeNoUseSiteDiagnostics(null)).ErrorInfo.ToString());

        AssertEx.Equal("error CS8090: There is an error in a referenced assembly 'first, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.",
            ((ErrorTypeSymbol)e2.BaseExtensionsNoUseSiteDiagnostics.Single()).ErrorInfo.ToString());
    }

    [Fact]
    public void UnderlyingType_SealedType()
    {
        var src = """
sealed class UnderlyingClass { }
explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.False(r.IsSealed);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void UnderlyingType_FileType_FileExtension()
    {
        var src = """
file class UnderlyingClass { }
file explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R@<tree 0>", r.ToTestDisplayString());
        Assert.Equal("UnderlyingClass@<tree 0>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void UnderlyingType_FileType_NonFileExtension()
    {
        var src = """
file class UnderlyingClass { }
explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,20): error CS9312: File-local type 'UnderlyingClass' cannot be used as a underlying type of non-file-local extension 'R'.
            // explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_FileTypeUnderlying, "R").WithArguments("UnderlyingClass", "R").WithLocation(2, 20)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("UnderlyingClass@<tree 0>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void UnderlyingType_FileContainingType_NonFileExtension()
    {
        var src = """
file class Outer
{
    internal class UnderlyingClass { }
}
explicit extension R for Outer.UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,20): error CS9312: File-local type 'Outer.UnderlyingClass' cannot be used as a underlying type of non-file-local extension 'R'.
            // explicit extension R for Outer.UnderlyingClass
            Diagnostic(ErrorCode.ERR_FileTypeUnderlying, "R").WithArguments("Outer.UnderlyingClass", "R").WithLocation(5, 20)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.Equal("Outer@<tree 0>.UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void UnderlyingType_FileContainingType_NonFileExtension_Partial()
    {
        var src = """
file class Outer
{
    internal class UnderlyingClass { }
}
partial explicit extension R for Outer.UnderlyingClass { } // 1
partial explicit extension R for Outer.UnderlyingClass { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,28): error CS9312: File-local type 'Outer.UnderlyingClass' cannot be used as a underlying type of non-file-local extension 'R'.
            // partial explicit extension R for Outer.UnderlyingClass { } // 1
            Diagnostic(ErrorCode.ERR_FileTypeUnderlying, "R").WithArguments("Outer.UnderlyingClass", "R").WithLocation(5, 28)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.Equal("Outer@<tree 0>.UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void UnderlyingType_DuplicatesWithDifferentUnderlyingTypes()
    {
        var src = """
class UnderlyingClass1 { }
class UnderlyingClass2 { }

explicit extension R1 for UnderlyingClass1 { } // 1
explicit extension R1 for UnderlyingClass2 { } // 2

explicit extension R2 for UnderlyingClass1 { } // 3, 4
implicit extension R2 for UnderlyingClass2 { } // 5
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,20): error CS9308: Partial declarations of 'R1' must not extend different types.
            // explicit extension R1 for UnderlyingClass1 { } // 1
            Diagnostic(ErrorCode.ERR_PartialMultipleUnderlyingTypes, "R1").WithArguments("R1").WithLocation(4, 20),
            // (5,20): error CS0101: The namespace '<global namespace>' already contains a definition for 'R1'
            // explicit extension R1 for UnderlyingClass2 { } // 2
            Diagnostic(ErrorCode.ERR_DuplicateNameInNS, "R1").WithArguments("R1", "<global namespace>").WithLocation(5, 20),
            // (7,20): error CS9315: Partial declarations of 'R2' must specify the same extension modifier ('implicit' or 'explicit').
            // explicit extension R2 for UnderlyingClass1 { } // 3, 4
            Diagnostic(ErrorCode.ERR_PartialDifferentExtensionModifiers, "R2").WithArguments("R2").WithLocation(7, 20),
            // (7,20): error CS9308: Partial declarations of 'R2' must not extend different types.
            // explicit extension R2 for UnderlyingClass1 { } // 3, 4
            Diagnostic(ErrorCode.ERR_PartialMultipleUnderlyingTypes, "R2").WithArguments("R2").WithLocation(7, 20),
            // (8,20): error CS0101: The namespace '<global namespace>' already contains a definition for 'R2'
            // implicit extension R2 for UnderlyingClass2 { } // 5
            Diagnostic(ErrorCode.ERR_DuplicateNameInNS, "R2").WithArguments("R2", "<global namespace>").WithLocation(8, 20)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        Assert.Equal("UnderlyingClass1", r1.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        Assert.Equal("UnderlyingClass1", r2.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void UnderlyingType_TypeConstraints()
    {
        var src = """
#nullable enable
interface I { }

class CDefault<T> { }
class CClass<T> where T : class { }
class CStruct<T> where T : struct { }
class CNotNull<T> where T : notnull { }

partial explicit extension RDefault1<T> for CDefault<T> { } // 1, 2
partial explicit extension RDefault1<U> for CDefault<U> { } // 3

explicit extension RDefault2<T> for CDefault<T> { }

partial explicit extension RClass1 { }
partial explicit extension RClass1 for CClass<string> { }

partial explicit extension RClass2 { }
partial explicit extension RClass2 for CClass<int> { } // 4

partial explicit extension RClass3 for CClass<int> { } // 5
partial explicit extension RClass3 { }

partial explicit extension RStruct1 { }
partial explicit extension RStruct1 for CStruct<string> { } // 6

partial explicit extension RStruct2 { }
partial explicit extension RStruct2 for CStruct<int> { }

partial explicit extension RStruct3<T> for CStruct<T> { } // 7
partial explicit extension RStruct3<T> { }

partial explicit extension RNotNull1 for CNotNull<string> { }

partial explicit extension RNotNull2 for CNotNull<string?> { } // 8
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (9,28): error CS0264: Partial declarations of 'RDefault1<T>' must have the same type parameter names in the same order
            // partial explicit extension RDefault1<T> for CDefault<T> { } // 1, 2
            Diagnostic(ErrorCode.ERR_PartialWrongTypeParams, "RDefault1").WithArguments("RDefault1<T>").WithLocation(9, 28),
            // (9,28): error CS9308: Partial declarations of 'RDefault1<T>' must not extend different types.
            // partial explicit extension RDefault1<T> for CDefault<T> { } // 1, 2
            Diagnostic(ErrorCode.ERR_PartialMultipleUnderlyingTypes, "RDefault1").WithArguments("RDefault1<T>").WithLocation(9, 28),
            // (10,54): error CS0246: The type or namespace name 'U' could not be found (are you missing a using directive or an assembly reference?)
            // partial explicit extension RDefault1<U> for CDefault<U> { } // 3
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "U").WithArguments("U").WithLocation(10, 54),
            // (18,28): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'T' in the generic type or method 'CClass<T>'
            // partial explicit extension RClass2 for CClass<int> { } // 4
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "RClass2").WithArguments("CClass<T>", "T", "int").WithLocation(18, 28),
            // (20,28): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'T' in the generic type or method 'CClass<T>'
            // partial explicit extension RClass3 for CClass<int> { } // 5
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "RClass3").WithArguments("CClass<T>", "T", "int").WithLocation(20, 28),
            // (24,28): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'CStruct<T>'
            // partial explicit extension RStruct1 for CStruct<string> { } // 6
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "RStruct1").WithArguments("CStruct<T>", "T", "string").WithLocation(24, 28),
            // (29,28): error CS0453: The type 'T' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'CStruct<T>'
            // partial explicit extension RStruct3<T> for CStruct<T> { } // 7
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "RStruct3").WithArguments("CStruct<T>", "T", "T").WithLocation(29, 28),
            // (34,28): warning CS8714: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'CNotNull<T>'. Nullability of type argument 'string?' doesn't match 'notnull' constraint.
            // partial explicit extension RNotNull2 for CNotNull<string?> { } // 8
            Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterNotNullConstraint, "RNotNull2").WithArguments("CNotNull<T>", "T", "string?").WithLocation(34, 28)
            );
    }

    [Fact]
    public void UnderlyingType_TypeParametersMustBeUsed()
    {
        var src = """
class C { }
class D<T> { }

explicit extension R1<T> for C { }
explicit extension R2<T> for D<T> { }

implicit extension R3<T> for C { } // 1
implicit extension R4<T> for D<T> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (7,20): error CS9328: The underlying type 'C' of implicit extension 'R3<T>' must reference all the type parameters declared by the extension, but type parameter 'T' is missing.
            // implicit extension R3<T> for C { } // 1
            Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "R3").WithArguments("C", "R3<T>", "T").WithLocation(7, 20)
            );
    }

    [Fact]
    public void UnderlyingType_TypeParametersMustBeUsed_MissingOne()
    {
        var src = """
string s = C<int>.f;

class C<T> { }

implicit extension E<T, U> for C<T>
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,19): error CS0117: 'C<int>' does not contain a definition for 'f'
            // string s = C<int>.f;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "f").WithArguments("C<int>", "f").WithLocation(1, 19),
            // (5,20): error CS9328: The underlying type 'C<T>' of implicit extension 'E<T, U>' must reference all the type parameters declared by the extension, but type parameter 'U' is missing.
            // implicit extension E<T, U> for C<T>
            Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E").WithArguments("C<T>", "E<T, U>", "U").WithLocation(5, 20)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.f");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void UnderlyingType_TypeParametersMustBeUsed_Container()
    {
        var src = """
#nullable enable

string s1 = C<int>.f; // 1

class C<T> { }

class Container<T, U>
{
    implicit extension E for C<T>
    {
        public static string f = "hi";
    }

    void M()
    {
        string s2 = C<long>.f; // 2
        string s3 = C<T>.f;

        string s4 = C<T?>.f;

        string s5 = C<
#nullable disable
            T
#nullable enable
            >.f;
    }
}
""";
        // PROTOTYPE handle nullability differences on s4 and s5
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,20): error CS0117: 'C<int>' does not contain a definition for 'f'
            // string s1 = C<int>.f; // 1
            Diagnostic(ErrorCode.ERR_NoSuchMember, "f").WithArguments("C<int>", "f").WithLocation(3, 20),
            // (16,29): error CS0117: 'C<long>' does not contain a definition for 'f'
            //         string s2 = C<long>.f; // 2
            Diagnostic(ErrorCode.ERR_NoSuchMember, "f").WithArguments("C<long>", "f").WithLocation(16, 29)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var s1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.f");
        Assert.Null(model.GetSymbolInfo(s1).Symbol);

        var s2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<long>.f");
        Assert.Null(model.GetSymbolInfo(s2).Symbol);

        var s3 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<T>.f");
        Assert.Equal("System.String Container<T, U>.E.f", model.GetSymbolInfo(s3).Symbol.ToTestDisplayString());

        var s4 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<T?>.f");
        Assert.Equal("System.String Container<T, U>.E.f", model.GetSymbolInfo(s4).Symbol.ToTestDisplayString());

        var s5 = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Last();
        Assert.Equal("""
            C<
            #nullable disable
                        T
            #nullable enable
                        >.f
            """, s5.ToString());

        Assert.Equal("System.String Container<T, U>.E.f", model.GetSymbolInfo(s5).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void UnderlyingType_TypeParametersMustBeUsed_ContainerContainer()
    {
        var src = """
#nullable enable

class C<T> { }

class ContainerContainer<T>
{
    class Container<U>
    {
        implicit extension E for C<T>
        {
            public static string f = "hi";
        }

        void M()
        {
            string s2 = C<long>.f; // 1
            string s3 = C<T>.f;

            string s4 = C<T?>.f;

            string s5 = C<
#nullable disable
                T
#nullable enable
                >.f;
        }
    }
}
""";
        // PROTOTYPE handle nullability differences on s4 and s5
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (16,33): error CS0117: 'C<long>' does not contain a definition for 'f'
            //             string s2 = C<long>.f; // 1
            Diagnostic(ErrorCode.ERR_NoSuchMember, "f").WithArguments("C<long>", "f").WithLocation(16, 33)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var s2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<long>.f");
        Assert.Null(model.GetSymbolInfo(s2).Symbol);

        var s3 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<T>.f");
        Assert.Equal("System.String ContainerContainer<T>.Container<U>.E.f", model.GetSymbolInfo(s3).Symbol.ToTestDisplayString());

        var s4 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<T?>.f");
        Assert.Equal("System.String ContainerContainer<T>.Container<U>.E.f", model.GetSymbolInfo(s4).Symbol.ToTestDisplayString());

        var s5 = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Last();
        Assert.Equal("""
            C<
            #nullable disable
                            T
            #nullable enable
                            >.f
            """, s5.ToString());

        Assert.Equal("System.String ContainerContainer<T>.Container<U>.E.f", model.GetSymbolInfo(s5).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void UnderlyingType_TypeParametersMustBeUsed_MissingTwo()
    {
        var src = """
string s = C.f;

class C { }

implicit extension E<T, U> for C
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,14): error CS0117: 'C' does not contain a definition for 'f'
            // string s = C.f;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "f").WithArguments("C", "f").WithLocation(1, 14),
            // (5,20): error CS9328: The underlying type 'C' of implicit extension 'E<T, U>' must reference all the type parameters declared by the extension, but type parameter 'T' is missing.
            // implicit extension E<T, U> for C
            Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E").WithArguments("C", "E<T, U>", "T").WithLocation(5, 20),
            // (5,20): error CS9328: The underlying type 'C' of implicit extension 'E<T, U>' must reference all the type parameters declared by the extension, but type parameter 'U' is missing.
            // implicit extension E<T, U> for C
            Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E").WithArguments("C", "E<T, U>", "U").WithLocation(5, 20));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.f");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void UnderlyingType_MissingTypeSyntax()
    {
        var src = """
explicit extension R for { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,26): error CS1031: Type expected
            // explicit extension R for { }
            Diagnostic(ErrorCode.ERR_TypeExpected, "{").WithLocation(1, 26)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.True(r.GetExtendedTypeNoUseSiteDiagnostics(null).IsErrorType());
    }

    [Theory, CombinatorialData]
    public void UnderlyingType_NativeInt(bool useImageReference)
    {
        var src = """
public explicit extension R for nint { }
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        Assert.True(comp.SupportsRuntimeCapability(RuntimeCapability.NumericIntPtr));
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate, verify: Verification.FailsPEVerify);

        if (new NoBaseExtensions().ShouldSkip) return;

        var src2 = """
explicit extension R2 for nint : R { }
""";
        var comp2 = CreateCompilation(src2, references: new[] { AsReference(comp, useImageReference) });
        comp2.VerifyDiagnostics();

        var src3 = """
explicit extension R3 for System.IntPtr : R { }
""";
        var comp3 = CreateCompilation(src3, references: new[] { AsReference(comp, useImageReference) });
        comp3.VerifyDiagnostics();

        return;

        static void validate(ModuleSymbol module)
        {
            var r = module.GlobalNamespace.GetTypeMember("R");
            VerifyExtension<TypeSymbol>(r, isExplicit: true);
            Assert.Equal("nint", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
        }
    }

    [Theory, CombinatorialData]
    public void UnderlyingType_NativeInt_OlderFramework(bool useImageReference)
    {
        var src = """
public explicit extension R for nint { }
""";
        var comp = CreateCompilation(new[] { src, CompilerFeatureRequiredAttribute });
        Assert.False(comp.SupportsRuntimeCapability(RuntimeCapability.NumericIntPtr));
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);

        if (new NoBaseExtensions().ShouldSkip) return;

        var src2 = """
explicit extension R2 for nint : R { }
""";
        var comp2 = CreateCompilation(src2, references: new[] { AsReference(comp, useImageReference) });
        comp2.VerifyDiagnostics();

        var src3 = """
explicit extension R3 for System.IntPtr : R { }
""";
        var comp3 = CreateCompilation(src3, references: new[] { AsReference(comp, useImageReference) });
        comp3.VerifyDiagnostics(
            // (1,20): error CS9316: Extension 'R3' extends 'IntPtr' but base extension 'R' extends 'nint'.
            // explicit extension R3 for System.IntPtr : R { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R3").WithArguments("R3", "System.IntPtr", "R", "nint").WithLocation(1, 20)
            );

        return;

        static void validate(ModuleSymbol module)
        {
            var r = module.GlobalNamespace.GetTypeMember("R");
            VerifyExtension<TypeSymbol>(r, isExplicit: true);
            Assert.Equal("nint", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
        }
    }

    [Fact]
    public void UnderlyingType_NativeInt_Nested()
    {
        var src = """
public class C<T> { }
public explicit extension R for C<nint> { }
""";
        var comp = CreateCompilation(new[] { src, CompilerFeatureRequiredAttribute }, targetFramework: TargetFramework.Mscorlib45);
        Assert.False(comp.Assembly.RuntimeSupportsNumericIntPtr);
        Assert.False(comp.SupportsRuntimeCapability(RuntimeCapability.NumericIntPtr));
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);

        if (new NoBaseExtensions().ShouldSkip) return;

        var src2 = """
explicit extension R2 for C<nint> : R { }
""";
        var comp2 = CreateCompilation(src2, references: new[] { comp.EmitToImageReference() }, targetFramework: TargetFramework.Mscorlib45);
        comp2.VerifyDiagnostics();

        var src3 = """
explicit extension R3 for C<System.IntPtr> : R { }
""";
        var comp3 = CreateCompilation(src3, references: new[] { comp.EmitToImageReference() }, targetFramework: TargetFramework.Mscorlib45);
        comp3.VerifyDiagnostics(
            // (1,20): error CS9316: Extension 'R3' extends 'C<IntPtr>' but base extension 'R' extends 'C<nint>'.
            // explicit extension R3 for C<System.IntPtr> : R { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R3").WithArguments("R3", "C<System.IntPtr>", "R", "C<nint>").WithLocation(1, 20)
            );

        return;

        static void validate(ModuleSymbol module)
        {
            var r = module.GlobalNamespace.GetTypeMember("R");
            VerifyExtension<TypeSymbol>(r, isExplicit: true);
            Assert.Equal("C<nint>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
        }
    }

    [Fact]
    public void UnderlyingType_Dynamic_Nested()
    {
        var src = """
public class C<T> { }
public explicit extension R for C<dynamic> { }
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate, verify: Verification.FailsPEVerify);

        if (new NoBaseExtensions().ShouldSkip) return;

        var src2 = """
explicit extension R2 for C<dynamic> : R { }
""";
        var comp2 = CreateCompilation(src2, references: new[] { comp.EmitToImageReference() });
        comp2.VerifyDiagnostics();

        var src3 = """
explicit extension R3 for C<object> : R { }
""";
        var comp3 = CreateCompilation(src3, references: new[] { comp.EmitToImageReference() });
        comp3.VerifyDiagnostics(
            // (1,20): error CS9316: Extension 'R3' extends 'C<object>' but base extension 'R' extends 'C<dynamic>'.
            // explicit extension R3 for C<object> : R { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R3").WithArguments("R3", "C<object>", "R", "C<dynamic>").WithLocation(1, 20)
            );

        return;

        static void validate(ModuleSymbol module)
        {
            var r = module.GlobalNamespace.GetTypeMember("R");
            VerifyExtension<TypeSymbol>(r, isExplicit: true);
            Assert.Equal("C<dynamic>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
        }
    }

    [Fact]
    public void UnderlyingType_NestedTypeWithNullability_Annotated()
    {
        var src = """
#nullable enable
public class C<T> { }
public explicit extension R for C<object?> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);

        if (new NoBaseExtensions().ShouldSkip) return;

        var src2 = """
#nullable enable
explicit extension R2 for C<object?> : R { }
""";
        var comp2 = CreateCompilation(src2, references: new[] { comp.EmitToImageReference() });
        comp2.VerifyDiagnostics();

        var src3 = """
#nullable enable
explicit extension R3 for C<object> : R { }
""";
        // PROTOTYPE this should at most be a nullability warning
        var comp3 = CreateCompilation(src3, references: new[] { comp.EmitToImageReference() });
        comp3.VerifyDiagnostics(
            // (2,20): error CS9316: Extension 'R3' extends 'C<object>' but base extension 'R' extends 'C<object?>'.
            // explicit extension R3 for C<object> : R { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R3").WithArguments("R3", "C<object>", "R", "C<object?>").WithLocation(2, 20)
            );

        var src4 = """
explicit extension R3 for C<object> : R { }
""";
        // PROTOTYPE the nullability warning should be silenced here (oblivious context)
        var comp4 = CreateCompilation(src4, references: new[] { comp.EmitToImageReference() });
        comp4.VerifyDiagnostics(
            // (1,20): error CS9316: Extension 'R3' extends 'C<object>' but base extension 'R' extends 'C<object?>'.
            // explicit extension R3 for C<object> : R { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R3").WithArguments("R3", "C<object>", "R", "C<object?>").WithLocation(1, 20)
            );

        return;

        static void validate(ModuleSymbol module)
        {
            var r = module.GlobalNamespace.GetTypeMember("R");
            VerifyExtension<TypeSymbol>(r, isExplicit: true);
            Assert.Equal("C<System.Object?>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString(includeNonNullable: true));
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
        }
    }

    [Fact]
    public void UnderlyingType_NestedTypeWithNullability_Unannotated()
    {
        var src = """
#nullable enable
public class C<T> { }
public explicit extension R for C<object> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);

        if (new NoBaseExtensions().ShouldSkip) return;

        var src2 = """
#nullable enable
explicit extension R2 for C<object> : R { }
""";
        var comp2 = CreateCompilation(src2, references: new[] { comp.EmitToImageReference() });
        comp2.VerifyDiagnostics();

        var src3 = """
#nullable enable
explicit extension R3 for C<object?> : R { }
""";
        // PROTOTYPE this should at most be a nullability warning
        var comp3 = CreateCompilation(src3, references: new[] { comp.EmitToImageReference() });
        comp3.VerifyDiagnostics(
            // (2,20): error CS9316: Extension 'R3' extends 'C<object?>' but base extension 'R' extends 'C<object>'.
            // explicit extension R3 for C<object?> : R { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R3").WithArguments("R3", "C<object?>", "R", "C<object>").WithLocation(2, 20)
            );

        var src4 = """
explicit extension R3 for C<object> : R { }
""";
        // PROTOTYPE the nullability warning should be silenced here (oblivious context)
        var comp4 = CreateCompilation(src4, references: new[] { comp.EmitToImageReference() });
        comp4.VerifyDiagnostics(
            // (1,20): error CS9316: Extension 'R3' extends 'C<object>' but base extension 'R' extends 'C<object>'.
            // explicit extension R3 for C<object> : R { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R3").WithArguments("R3", "C<object>", "R", "C<object>").WithLocation(1, 20)
            );

        return;

        static void validate(ModuleSymbol module)
        {
            var r = module.GlobalNamespace.GetTypeMember("R");
            VerifyExtension<TypeSymbol>(r, isExplicit: true);
            Assert.Equal("C<System.Object!>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString(includeNonNullable: true));
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
        }
    }

    [Fact]
    public void UnderlyingType_TupleWithElementNames()
    {
        var src = """
public explicit extension R for (int a, int b) { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);

        var comp1 = CreateCompilation(src);
        comp1.MakeTypeMissing(WellKnownType.System_Runtime_CompilerServices_TupleElementNamesAttribute);
        comp1.VerifyDiagnostics(
            // (1,33): error CS8137: Cannot define a class or member that utilizes tuples because the compiler required type 'System.Runtime.CompilerServices.TupleElementNamesAttribute' cannot be found. Are you missing a reference?
            // public explicit extension R for (int a, int b) { }
            Diagnostic(ErrorCode.ERR_TupleElementNamesAttributeMissing, "(int a, int b)").WithArguments("System.Runtime.CompilerServices.TupleElementNamesAttribute").WithLocation(1, 33)
            );

        if (new NoBaseExtensions().ShouldSkip) return;

        var src2 = """
explicit extension R2 for (int a, int b)  : R { }
""";
        var comp2 = CreateCompilation(src2, references: new[] { comp.EmitToImageReference() });
        comp2.VerifyDiagnostics();

        var src3 = """
explicit extension R3 for (int, int) : R { }
""";
        // PROTOTYPE consider warning instead, when revisiting rules for variance of underlying types
        var comp3 = CreateCompilation(src3, references: new[] { comp.EmitToImageReference() });
        comp3.VerifyDiagnostics(
            // (1,20): error CS9316: Extension 'R3' extends '(int, int)' but base extension 'R' extends '(int a, int b)'.
            // explicit extension R3 for (int, int) : R { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R3").WithArguments("R3", "(int, int)", "R", "(int a, int b)").WithLocation(1, 20)
            );

        var src4 = """
explicit extension R4 for (int a, int other) : R { }
""";
        var comp4 = CreateCompilation(src4, references: new[] { comp.EmitToImageReference() });
        comp4.VerifyDiagnostics(
            // (1,20): error CS9316: Extension 'R4' extends '(int a, int other)' but base extension 'R' extends '(int a, int b)'.
            // explicit extension R4 for (int a, int other) : R { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R4").WithArguments("R4", "(int a, int other)", "R", "(int a, int b)").WithLocation(1, 20)
            );

        return;

        static void validate(ModuleSymbol module)
        {
            var r = module.GlobalNamespace.GetTypeMember("R");
            VerifyExtension<TypeSymbol>(r, isExplicit: true);
            Assert.Equal("(System.Int32 a, System.Int32 b)", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
        }
    }

    [Fact]
    public void ForPointer()
    {
        var src = """
unsafe explicit extension R for int*
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,27): error CS0227: Unsafe code may only appear if compiling with /unsafe
            // unsafe explicit extension R for int*
            Diagnostic(ErrorCode.ERR_IllegalUnsafe, "R").WithLocation(1, 27),
            // (1,33): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // unsafe explicit extension R for int*
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "int*").WithLocation(1, 33)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Null(r.GetExtendedTypeNoUseSiteDiagnostics(null));
        Assert.Empty(r.GetMembers());
    }

    [Fact]
    public void ForRefType()
    {
        var src = """
explicit extension R for ref int
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,26): error CS1073: Unexpected token 'ref'
            // explicit extension R for ref int
            Diagnostic(ErrorCode.ERR_UnexpectedToken, "ref").WithArguments("ref").WithLocation(1, 26)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("System.Int32", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void ForPointer_InUnsafeCompilation()
    {
        var src = """
class C
{
    unsafe void M()
    {
        int* i = null;
        i.M2(); // 1
    }
}

unsafe explicit extension R for int* // 2
{
    int* M(int* i) => i;
}

implicit extension R2 for int* // 3, 4
{
    int* M(int* i) => i; // 5, 6, 7
    public void M2() => throw null;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (6,11): error CS1061: 'int*' does not contain a definition for 'M2' and no accessible extension method 'M2' accepting a first argument of type 'int*' could be found (are you missing a using directive or an assembly reference?)
            //         i.M2(); // 1
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M2").WithArguments("int*", "M2").WithLocation(6, 11),
            // (10,33): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // unsafe explicit extension R for int* // 2
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "int*").WithLocation(10, 33),
            // (15,27): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            // implicit extension R2 for int* // 3, 4
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "int*").WithLocation(15, 27),
            // (15,27): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // implicit extension R2 for int* // 3, 4
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "int*").WithLocation(15, 27),
            // (17,5): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            //     int* M(int* i) => i; // 5, 6, 7
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "int*").WithLocation(17, 5),
            // (17,12): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            //     int* M(int* i) => i; // 5, 6, 7
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "int*").WithLocation(17, 12),
            // (17,23): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            //     int* M(int* i) => i; // 5, 6, 7
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "i").WithLocation(17, 23)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Null(r.GetExtendedTypeNoUseSiteDiagnostics(null));
    }

    [Fact]
    public void ForFunctionPointer()
    {
        var src = """
unsafe explicit extension R for delegate*<void>
{
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (1,33): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // unsafe explicit extension R for delegate*<void>
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "delegate*<void>").WithLocation(1, 33)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Null(r.GetExtendedTypeNoUseSiteDiagnostics(null));
        Assert.Empty(r.GetMembers());
    }

    [Fact]
    public void ForDynamic()
    {
        var src = """
explicit extension R for dynamic
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,26): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // explicit extension R for dynamic
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "dynamic").WithLocation(1, 26)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Null(r.GetExtendedTypeNoUseSiteDiagnostics(null));
        Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
        Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);
    }

    [Fact]
    public void ForNullableReferenceType()
    {
        var src = """
#nullable enable
class C<T> { }

explicit extension R1 for string { }
explicit extension R2 for string? { }
explicit extension R3 for C<string> { }
explicit extension R4 for C<string?> { }

#nullable disable
explicit extension R5 for string { }
explicit extension R6 for C<string> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void ForLessAccessibleType()
    {
        var src = """
internal struct UnderlyingStruct { }
public explicit extension R for UnderlyingStruct
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,27): error CS9309: Inconsistent accessibility: underlying type 'UnderlyingStruct' is less accessible than extension 'R'
            // public explicit extension R for UnderlyingStruct
            Diagnostic(ErrorCode.ERR_BadVisUnderlyingType, "R").WithArguments("R", "UnderlyingStruct").WithLocation(2, 27)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal(Accessibility.Public, r.DeclaredAccessibility);
    }

    [Fact]
    public void ForRefLikeType()
    {
        var src = """
ref struct RS {  }
explicit extension R for RS { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,26): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // explicit extension R for RS { }
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "RS").WithLocation(2, 26)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Empty(r.GetMembers());
    }

    [Fact]
    public void Partial_OnePartWithoutUnderlyingType()
    {
        var src = """
class UnderlyingClass { }
partial explicit extension R for UnderlyingClass { }
partial explicit extension R { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void Partial_OtherPartWithoutUnderlyingType()
    {
        var src = """
class UnderlyingClass { }
partial explicit extension R { }
partial explicit extension R for UnderlyingClass { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void Partial_PartsWithTwoDifferentUnderlyingTypes()
    {
        var src = """
class UnderlyingClass { }
class UnderlyingClass2 { }
partial explicit extension R for UnderlyingClass { }
partial explicit extension R for UnderlyingClass2 { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,28): error CS9308: Partial declarations of 'R' must not extend different types.
            // partial explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_PartialMultipleUnderlyingTypes, "R").WithArguments("R").WithLocation(3, 28)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void Partial_PartsWithThreeDifferentUnderlyingTypes()
    {
        var src = """
class UnderlyingClass { }
class UnderlyingClass2 { }
class UnderlyingClass3 { }
partial explicit extension R for UnderlyingClass { }
partial explicit extension R for UnderlyingClass2 { }
partial explicit extension R for UnderlyingClass3 { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,28): error CS9308: Partial declarations of 'R' must not extend different types.
            // partial explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_PartialMultipleUnderlyingTypes, "R").WithArguments("R").WithLocation(4, 28)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void Partial_PartsWithThreeDifferentUnderlyingTypes_IncludingErrorType()
    {
        var src = """
class UnderlyingClass { }
class UnderlyingClass3 { }
partial explicit extension R for UnderlyingClass { }
partial explicit extension R for ErrorType { }
partial explicit extension R for UnderlyingClass3 { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,28): error CS9308: Partial declarations of 'R' must not extend different types.
            // partial explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_PartialMultipleUnderlyingTypes, "R").WithArguments("R").WithLocation(3, 28),
            // (4,34): error CS0246: The type or namespace name 'ErrorType' could not be found (are you missing a using directive or an assembly reference?)
            // partial explicit extension R for ErrorType { }
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "ErrorType").WithArguments("ErrorType").WithLocation(4, 34)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void Partial_PartsWithThreeDifferentUnderlyingTypes_IncludingErrorType_DifferentOrder()
    {
        var src = """
class UnderlyingClass { }
class UnderlyingClass3 { }
partial explicit extension R for ErrorType { }
partial explicit extension R for UnderlyingClass { }
partial explicit extension R for UnderlyingClass3 { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,28): error CS9308: Partial declarations of 'R' must not extend different types.
            // partial explicit extension R for ErrorType { }
            Diagnostic(ErrorCode.ERR_PartialMultipleUnderlyingTypes, "R").WithArguments("R").WithLocation(3, 28),
            // (3,34): error CS0246: The type or namespace name 'ErrorType' could not be found (are you missing a using directive or an assembly reference?)
            // partial explicit extension R for ErrorType { }
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "ErrorType").WithArguments("ErrorType").WithLocation(3, 34)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("ErrorType", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void Partial_PartsWithMatchingUnderlyingTypes()
    {
        var src = """
#nullable enable

class C<T> { }
partial explicit extension R for C<object> { }
partial explicit extension R for C<object> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("C<System.Object>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void Partial_PartsWithDifferentUnderlyingTypes_Dynamic()
    {
        var src = """
class C<T> { }
partial explicit extension R for C<object> { }
partial explicit extension R for C<dynamic> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,28): error CS9308: Partial declarations of 'R' must not extend different types.
            // partial explicit extension R for C<object> { }
            Diagnostic(ErrorCode.ERR_PartialMultipleUnderlyingTypes, "R").WithArguments("R").WithLocation(2, 28)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("C<>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.True(r.GetExtendedTypeNoUseSiteDiagnostics(null).IsErrorType());
    }

    [Fact]
    public void Partial_PartsWithDifferentUnderlyingTypes_TupleNames()
    {
        var src = """
class C<T> { }
partial explicit extension R for C<(int x, int b)> { }
partial explicit extension R for C<(int y, int b)> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,28): error CS9308: Partial declarations of 'R' must not extend different types.
            // partial explicit extension R for C<(int x, int b)> { }
            Diagnostic(ErrorCode.ERR_PartialMultipleUnderlyingTypes, "R").WithArguments("R").WithLocation(2, 28)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("C<>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.True(r.GetExtendedTypeNoUseSiteDiagnostics(null).IsErrorType());
    }

    [Fact]
    public void Partial_PartsWithDifferentUnderlyingTypes_TopLevelNullability()
    {
        var src = """
#nullable enable

class C<T> { }
partial explicit extension R for object { }
partial explicit extension R for object? { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("System.Object", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString(includeNonNullable: true));
        Assert.False(r.GetExtendedTypeNoUseSiteDiagnostics(null).IsErrorType());
    }

    [Fact]
    public void Partial_PartsWithDifferentUnderlyingTypes_NestedNullability()
    {
        var src = """
#nullable enable

class C<T> { }
partial explicit extension R for C<object> { }
partial explicit extension R for C<object?> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,28): error CS9308: Partial declarations of 'R' must not extend different types.
            // partial explicit extension R for C<object> { }
            Diagnostic(ErrorCode.ERR_PartialMultipleUnderlyingTypes, "R").WithArguments("R").WithLocation(4, 28)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("C<>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.True(r.GetExtendedTypeNoUseSiteDiagnostics(null).IsErrorType());
    }

    [Fact]
    public void Partial_PartsWithDifferentUnderlyingTypes_Nullability_OneIsOblivious()
    {
        var src = """
#nullable enable

class C<T> { }
#nullable disable
partial explicit extension R for C<object> { }
#nullable enable
partial explicit extension R for C<object?> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("C<System.Object?>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void Partial_PartsWithDifferentUnderlyingTypes_Nullability_OtherIsOblivious()
    {
        var src = """
#nullable enable

class C<T> { }
partial explicit extension R for C<object?> { }
#nullable disable
partial explicit extension R for C<object> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("C<System.Object?>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void Partial_PartsWithDifferentUnderlyingTypes_Nullability_MultipleObliviousDifferences()
    {
        var src = """
#nullable enable

class C<T1, T2> { }

partial explicit extension R for C<
#nullable disable
    object,
#nullable enable
    object?> { }

partial explicit extension R for C<
#nullable enable
    object?,
#nullable disable
    object
#nullable enable
    > { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,28): error CS9308: Partial declarations of 'R' must not extend different types.
            // partial explicit extension R for C<
            Diagnostic(ErrorCode.ERR_PartialMultipleUnderlyingTypes, "R").WithArguments("R").WithLocation(5, 28)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("C<, >", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.True(r.GetExtendedTypeNoUseSiteDiagnostics(null).IsErrorType());
    }

    [Fact]
    public void Partial_OnePartIsErrorType()
    {
        var src = """
class UnderlyingClass { }
partial explicit extension R for Error { }
partial explicit extension R for UnderlyingClass { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,28): error CS9308: Partial declarations of 'R' must not extend different types.
            // partial explicit extension R for Error { }
            Diagnostic(ErrorCode.ERR_PartialMultipleUnderlyingTypes, "R").WithArguments("R").WithLocation(2, 28),
            // (2,34): error CS0246: The type or namespace name 'Error' could not be found (are you missing a using directive or an assembly reference?)
            // partial explicit extension R for Error { }
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Error").WithArguments("Error").WithLocation(2, 34)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("Error", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void Partial_OtherPartIsErrorType()
    {
        var src = """
class UnderlyingClass { }
partial explicit extension R for UnderlyingClass { }
partial explicit extension R for Error { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,34): error CS0246: The type or namespace name 'Error' could not be found (are you missing a using directive or an assembly reference?)
            // partial explicit extension R for Error { }
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Error").WithArguments("Error").WithLocation(3, 34)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void Partial_NoPartHasUnderlyingType(bool isImplicit)
    {
        var keyword = isImplicit ? "implicit" : "explicit";
        var src = $$"""
partial {{keyword}} extension R { }
partial {{keyword}} extension R { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,28): error CS9314: No part of a partial extension 'R' includes an underlying type specification.
            // partial explicit extension R { }
            Diagnostic(ErrorCode.ERR_ExtensionMissingUnderlyingType, "R").WithArguments("R").WithLocation(1, 28)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Null(r.GetExtendedTypeNoUseSiteDiagnostics(null));
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void Partial_DifferentBaseExtensions()
    {
        var src = """
class C { }
explicit extension R1 for C { }
explicit extension R2 for C { }

partial explicit extension R3 for C : R1 { }
partial explicit extension R3 for C : R2 { }

partial explicit extension R4 for C : R1, R2 { }
partial explicit extension R4 for C : R2 { }

partial explicit extension R5 for C : R1 { }
partial explicit extension R5 for C : R1, R2 { }

partial explicit extension R6 for C { }
partial explicit extension R6 for C : R1, R2 { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var r3 = comp.GlobalNamespace.GetTypeMember("R3");
        Assert.Equal(new[] { "R1", "R2" }, r3.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.Equal(new[] { "R1", "R2" }, r3.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.True(r3.IsPartial());

        var r4 = comp.GlobalNamespace.GetTypeMember("R4");
        Assert.Equal(new[] { "R1", "R2" }, r4.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.Equal(new[] { "R1", "R2" }, r4.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.True(r4.IsPartial());

        var r5 = comp.GlobalNamespace.GetTypeMember("R5");
        Assert.Equal(new[] { "R1", "R2" }, r5.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.Equal(new[] { "R1", "R2" }, r5.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.True(r5.IsPartial());

        var r6 = comp.GlobalNamespace.GetTypeMember("R6");
        Assert.Equal(new[] { "R1", "R2" }, r6.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.Equal(new[] { "R1", "R2" }, r6.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.True(r6.IsPartial());
    }

    [Theory]
    [InlineData("class    ")]
    [InlineData("struct   ")]
    [InlineData("interface")]
    public void Partial_PartsWithConflictingTypeKinds(string typeKind)
    {
        var src = $$"""
class C { }
partial explicit extension R for C { }
partial {{typeKind}} R { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,19): error CS0261: Partial declarations of 'R' must all be the same kind of type.
            // partial class     R { }
            Diagnostic(ErrorCode.ERR_PartialTypeKindConflict, "R").WithArguments("R").WithLocation(3, 19)
            );
    }

    [Fact]
    public void Partial_PartialModifierConflict()
    {
        var src = """
class C { }
public partial explicit extension R1 for C { }
internal partial explicit extension R1 for C { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,35): error CS0262: Partial declarations of 'R1' have conflicting accessibility modifiers
            // public partial explicit extension R1 for C { }
            Diagnostic(ErrorCode.ERR_PartialModifierConflict, "R1").WithArguments("R1").WithLocation(2, 35),
            // (2,35): error CS9309: Inconsistent accessibility: underlying type 'C' is less accessible than extension 'R1'
            // public partial explicit extension R1 for C { }
            Diagnostic(ErrorCode.ERR_BadVisUnderlyingType, "R1").WithArguments("R1", "C").WithLocation(2, 35)
            );
    }

    [Fact]
    public void Partial_OnePartialModifier_OtherDefault()
    {
        var src = """
class C { }
internal partial explicit extension R1 for C { }
partial explicit extension R1 for C { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        Assert.Equal(Accessibility.Internal, comp.GlobalNamespace.GetTypeMember("R1").DeclaredAccessibility);
    }

    [Fact]
    public void Partial_MergeMembers()
    {
        var src = """
class C { }
partial explicit extension R for C
{
    public void M1() { }
}
partial explicit extension R for C
{
    public void M2() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var r = comp.GlobalNamespace.GetTypeMember("R");
        AssertEx.Equal(new[] { "void R.M1()", "void R.M2()" }, r.GetMembers().ToTestDisplayStrings());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void Partial_MergeConstraintsNullability()
    {
        var src = """
class C { }

#nullable enable
partial explicit extension R1<T> for C where T : class { }
partial explicit extension R1<T> for C where T : class { }

#nullable enable
partial explicit extension R2<T> for C where T : class { }
#nullable disable
partial explicit extension R2<T> for C where T : class { }

#nullable disable
partial explicit extension R3<T> for C where T : class { }
#nullable enable
partial explicit extension R3<T> for C where T : class { }

#nullable disable
partial explicit extension R4<T> for C where T : class { }
partial explicit extension R4<T> for C where T : class { }

#nullable enable
explicit extension R5 for C : R1<string?>, R2<string?> , R3<string?>, R4<string?> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (22,20): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'R1<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
            // explicit extension R5 for C : R1<string?>, R2<string?> , R3<string?>, R4<string?> { }
            Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "R5").WithArguments("R1<T>", "T", "string?").WithLocation(22, 20),
            // (22,20): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'R2<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
            // explicit extension R5 for C : R1<string?>, R2<string?> , R3<string?>, R4<string?> { }
            Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "R5").WithArguments("R2<T>", "T", "string?").WithLocation(22, 20),
            // (22,20): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'R3<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
            // explicit extension R5 for C : R1<string?>, R2<string?> , R3<string?>, R4<string?> { }
            Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "R5").WithArguments("R3<T>", "T", "string?").WithLocation(22, 20)
            );
    }

    [Fact]
    public void ForErrorType()
    {
        var src = """
explicit extension R for error
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,26): error CS0246: The type or namespace name 'error' could not be found (are you missing a using directive or an assembly reference?)
            // explicit extension R for error
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "error").WithArguments("error").WithLocation(1, 26)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        var underlyingType = r.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.Equal("error", underlyingType.ToTestDisplayString());
        Assert.True(underlyingType.IsErrorType());
    }

    [Fact]
    public void ForErrorType_Nested()
    {
        var src = """
class C<T> { }
explicit extension R for C<error>
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,28): error CS0246: The type or namespace name 'error' could not be found (are you missing a using directive or an assembly reference?)
            // explicit extension R for C<error>
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "error").WithArguments("error").WithLocation(2, 28)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        var underlyingType = r.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.Equal("C<error>", underlyingType.ToTestDisplayString());
    }

    [Fact]
    public void ForTypeWithUseSiteError()
    {
        var lib1_cs = "public class MissingBase { }";
        var comp1 = CreateCompilation(lib1_cs, assemblyName: "missing");
        comp1.VerifyDiagnostics();

        var lib2_cs = "public class UseSiteError : MissingBase { }";
        var comp2 = CreateCompilation(lib2_cs, new[] { comp1.EmitToImageReference() });
        comp2.VerifyDiagnostics();

        var src = """
class C<T> { }
explicit extension R1 for UseSiteError { }
explicit extension R2 for C<UseSiteError> { }
class C1 : UseSiteError { }
class C2 : C<UseSiteError> { }
""";
        var comp = CreateCompilation(src, new[] { comp2.EmitToImageReference() });
        comp.VerifyDiagnostics(
            // (2,27): error CS0012: The type 'MissingBase' is defined in an assembly that is not referenced. You must add a reference to assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // explicit extension R1 for UseSiteError { }
            Diagnostic(ErrorCode.ERR_NoTypeDef, "UseSiteError").WithArguments("MissingBase", "missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(2, 27),
            // (4,12): error CS0012: The type 'MissingBase' is defined in an assembly that is not referenced. You must add a reference to assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // class C1 : UseSiteError { }
            Diagnostic(ErrorCode.ERR_NoTypeDef, "UseSiteError").WithArguments("MissingBase", "missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(4, 12));
    }

    [Fact]
    public void TypeDepends_SelfReference()
    {
        var src = """
explicit extension R for R { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,26): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // explicit extension R for R { }
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "R").WithLocation(1, 26)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Null(r.GetExtendedTypeNoUseSiteDiagnostics(null));
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void TypeDepends_SelfReference_AsContainingType()
    {
        var src = """
public explicit extension One<T> for object : One<int>.Two
{
    public explicit extension Two for object { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,27): error CS9311: Base extension 'One<int>.Two' causes a cycle in the extension hierarchy of 'One<T>'.
            // public explicit extension One<T> for object : One<int>.Two
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "One").WithArguments("One<T>", "One<int>.Two").WithLocation(1, 27)
            );

        var one = comp.GlobalNamespace.GetTypeMember("One");
        var two = one.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("One<System.Int32>.Two", two.ToTestDisplayString());
        Assert.True(two.IsErrorType());
    }

    [Fact]
    public void TypeDepends_SelfReference_WithArray()
    {
        var src = """
explicit extension R for R[] { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R[]", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void TypeDepends_SelfReference_WithTuple()
    {
        var src = """
explicit extension R for (R, R) { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("(R, R)", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void TypeDepends_SelfReference_WithStruct()
    {
        var src = """
struct S<T> { }
explicit extension R for S<R> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("S<R>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void TypeDepends_SelfReference_WithStruct_WithField()
    {
        var src = """
public struct S<T>
{
    public T field;
}

explicit extension R for S<R> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("S<R>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal("R", r.GetExtendedTypeNoUseSiteDiagnostics(null).GetMember("field").GetTypeOrReturnType().ToTestDisplayString());
    }

    [Fact]
    public void TypeDepends_CircularityViaTypeArgument()
    {
        var src = """
class C<T> { }
explicit extension R for C<R> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("C<R>", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void TypeDepends_CircularityViaBaseExtensions()
    {
        var src = """
struct S { }
explicit extension X for S : Y { }
explicit extension Y for S : Z { }
explicit extension Z for S : X { }
""";

        var comp = CreateCompilation(new[] { src, CompilerFeatureRequiredAttribute }, targetFramework: TargetFramework.Mscorlib40);
        comp.VerifyDiagnostics(
            // (2,20): error CS9311: Base extension 'Y' causes a cycle in the extension hierarchy of 'X'.
            // explicit extension X for S : Y { }
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "X").WithArguments("X", "Y").WithLocation(2, 20),
            // (3,20): error CS9311: Base extension 'Z' causes a cycle in the extension hierarchy of 'Y'.
            // explicit extension Y for S : Z { }
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "Y").WithArguments("Y", "Z").WithLocation(3, 20),
            // (4,20): error CS9311: Base extension 'X' causes a cycle in the extension hierarchy of 'Z'.
            // explicit extension Z for S : X { }
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "Z").WithArguments("Z", "X").WithLocation(4, 20)
            );

        var x = comp.GlobalNamespace.GetTypeMember("X");
        verifyBase(x, "Y");

        var y = comp.GlobalNamespace.GetTypeMember("Y");
        verifyBase(y, "Z");

        var z = comp.GlobalNamespace.GetTypeMember("Z");
        verifyBase(z, "X");

        static void verifyBase(NamedTypeSymbol type, string expectedBaseName)
        {
            var baseExtension = type.BaseExtensionsNoUseSiteDiagnostics.Single();
            Assert.Equal(expectedBaseName, baseExtension.ToTestDisplayString());
            Assert.True(baseExtension.IsErrorType());
            Assert.Same(baseExtension, type.AllBaseExtensionsNoUseSiteDiagnostics.Single());
        }
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void TypeDepends_CircularityViaBaseExtensions_Metadata()
    {
        var src1 = """
public struct S { }
public explicit extension X for S { }
""";

        var comp1 = CreateCompilation(src1, assemblyName: "first",
            targetFramework: TargetFramework.Net70);
        comp1.VerifyDiagnostics();

        var src2 = """
public explicit extension Y for S : X { }
""";

        var comp2 = CreateCompilation(src2, references: new[] { comp1.EmitToImageReference() },
            assemblyName: "second");
        comp2.VerifyDiagnostics();

        var src1Updated = """
public struct S { }
public explicit extension X for S : Y { }
""";

        comp1 = CreateCompilation(src1Updated, references: new[] { comp2.EmitToImageReference() },
            assemblyName: "first");
        comp1.VerifyDiagnostics(
            // (2,27): error CS9311: Base extension 'Y' causes a cycle in the extension hierarchy of 'X'.
            // public explicit extension X for S : Y { }
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "X").WithArguments("X", "Y").WithLocation(2, 27)
            );

        var x = comp1.GlobalNamespace.GetTypeMember("X");
        var xBaseExtension = x.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("Y", xBaseExtension.ToTestDisplayString());
        Assert.True(xBaseExtension.IsErrorType());

        var y = comp1.GlobalNamespace.GetTypeMember("Y");
        var yBaseExtension = y.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("X", yBaseExtension.ToTestDisplayString());
        Assert.True(yBaseExtension.IsErrorType());

        var retargetingComp = CreateCompilation(src1Updated, references: new[] { comp2.ToMetadataReference() },
            assemblyName: "first");
        retargetingComp.VerifyDiagnostics(
            // (2,27): error CS9311: Base extension 'Y' causes a cycle in the extension hierarchy of 'X'.
            // public explicit extension X for S : Y { }
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "X").WithArguments("X", "Y").WithLocation(2, 27)
            );

        x = retargetingComp.GlobalNamespace.GetTypeMember("X");
        VerifyExtension<SourceExtensionTypeSymbol>(x, isExplicit: true);
        xBaseExtension = x.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("Y", xBaseExtension.ToTestDisplayString());
        Assert.True(xBaseExtension.IsErrorType());

        y = retargetingComp.GlobalNamespace.GetTypeMember("Y");
        VerifyExtension<RetargetingNamedTypeSymbol>(y, isExplicit: true);
        yBaseExtension = y.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("X", yBaseExtension.ToTestDisplayString());
        Assert.True(yBaseExtension.IsErrorType());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void TypeDepends_CircularityViaUnderlyingType()
    {
        var src = """
explicit extension R for R2.Nested { }
explicit extension R2 for object : R
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,20): error CS0146: Circular base type dependency involving 'R2.Nested' and 'R'
            // explicit extension R for R2.Nested { }
            Diagnostic(ErrorCode.ERR_CircularBase, "R").WithArguments("R2.Nested", "R").WithLocation(1, 20),
            // (2,20): error CS9311: Base extension 'R' causes a cycle in the extension hierarchy of 'R2'.
            // explicit extension R2 for object : R
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "R2").WithArguments("R2", "R").WithLocation(2, 20)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.True(r.IsExtension);
        Assert.Equal("R2.Nested", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
        Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        Assert.True(r2.IsExtension);
        Assert.Equal("System.Object", r2.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal(new[] { "R" }, r2.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.True(r2.BaseExtensionsNoUseSiteDiagnostics.Single().IsErrorType());
        Assert.Equal(new[] { "R" }, r2.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.True(r2.AllBaseExtensionsNoUseSiteDiagnostics.Single().IsErrorType());
    }

    [Fact]
    public void TypeDepends_CircularityViaUnderlyingType_Metadata()
    {
        var src1 = """
public struct R1 { }
""";
        var comp1 = CreateCompilation(src1, assemblyName: "first");
        comp1.VerifyDiagnostics();

        var src2 = """
public explicit extension R2 for R1 { }
""";
        var comp2 = CreateCompilation(src2, references: new[] { comp1.EmitToImageReference() },
            targetFramework: TargetFramework.Net70, assemblyName: "second");
        comp2.VerifyDiagnostics();

        var src3 = """
public struct R2 { }
""";
        var comp3 = CreateCompilation(src3, assemblyName: "second");
        comp1.VerifyDiagnostics();

        var src4 = """
public explicit extension R1 for R2 { }
""";
        var comp4 = CreateCompilation(src4, references: new[] { comp3.EmitToImageReference() },
            targetFramework: TargetFramework.Net70, assemblyName: "first");
        comp4.VerifyDiagnostics();

        var comp5 = CreateCompilation("", references: new[] { comp2.EmitToImageReference(), comp4.EmitToImageReference() },
            targetFramework: TargetFramework.Net70);
        comp5.VerifyDiagnostics();

        var r1 = comp5.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: true);
        var r2FromR1 = (ExtendedErrorTypeSymbol)r1.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.Equal("R2", r2FromR1.ToTestDisplayString());
        AssertEx.Equal("error CS9322: Extension marker method on type 'R1' is malformed.", r2FromR1.ErrorInfo.ToString());

        if (new NoBaseExtensions().ShouldSkip) return;

        var src6 = """
public explicit extension R6 for object : R1 { }
public explicit extension R7 for object : R2 { }
public explicit extension R8 for R1 { }
public explicit extension R9 for R2 { }
""";
        var comp6 = CreateCompilation(src6, references: new[] { comp2.ToMetadataReference(), comp4.ToMetadataReference() },
            targetFramework: TargetFramework.Net70);
        // PROTOTYPE we should report use-site errors for the uses of R1 and R2
        comp6.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R6' extends 'object' but base extension 'R1' extends 'R2'.
            // public explicit extension R6 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R6").WithArguments("R6", "object", "R1", "R2").WithLocation(1, 27),
            // (2,27): error CS9316: Extension 'R7' extends 'object' but base extension 'R2' extends 'R1'.
            // public explicit extension R7 for object : R2 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R7").WithArguments("R7", "object", "R2", "R1").WithLocation(2, 27),
            // (3,34): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // public explicit extension R8 for R1 { }
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "R1").WithLocation(3, 34),
            // (4,34): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // public explicit extension R9 for R2 { }
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "R2").WithLocation(4, 34)
            );

        r1 = comp6.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<RetargetingNamedTypeSymbol>(r1, isExplicit: true);
        r2FromR1 = (ExtendedErrorTypeSymbol)r1.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.True(r2FromR1.IsErrorType());
        AssertEx.Equal("error CS8090: There is an error in a referenced assembly 'second, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.",
            r2FromR1.ErrorInfo.ToString());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void TypeDepends_CircularityViaUnderlyingType_WithArray()
    {
        var src = """
explicit extension R for R2.Nested[] { }
explicit extension R2 for R2.Nested[] : R
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.True(r.IsExtension);
        Assert.Equal("R2.Nested[]", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
        Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        Assert.True(r2.IsExtension);
        Assert.Equal("R2.Nested[]", r2.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal(new[] { "R" }, r2.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.Equal(new[] { "R" }, r2.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void TypeDepends_CircularityViaUnderlyingType_WithTuple()
    {
        var src = """
explicit extension R for (R2.Nested, int) { }
explicit extension R2 for (R2.Nested, int) : R
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("(R2.Nested, System.Int32)", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Empty(r.BaseExtensionsNoUseSiteDiagnostics);
        Assert.Empty(r.AllBaseExtensionsNoUseSiteDiagnostics);

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        Assert.Equal("(R2.Nested, System.Int32)", r2.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal(new[] { "R" }, r2.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.Equal(new[] { "R" }, r2.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void TypeDepends_CircularityViaUnderlyingTypeAndBaseExtensions()
    {
        var src = """
explicit extension E1 for object : E2 { }
explicit extension E2 for E2 : E2 { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,20): error CS9311: Base extension 'E2' causes a cycle in the extension hierarchy of 'E2'.
            // explicit extension E2 for E2 : E2 { }
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "E2").WithArguments("E2", "E2").WithLocation(2, 20),
            // (2,27): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // explicit extension E2 for E2 : E2 { }
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "E2").WithLocation(2, 27)
            );
        var e2 = comp.GlobalNamespace.GetTypeMember("E2");
        Assert.True(e2.IsExtension);
        Assert.Null(e2.GetExtendedTypeNoUseSiteDiagnostics(null));
        Assert.Equal("E2", e2.BaseExtensionsNoUseSiteDiagnostics.Single().ToTestDisplayString());
    }

    [Fact]
    public void TypeDepends_CircularityAttemptWithUnderylingType()
    {
        var src1 = """
public explicit extension R1 for object
{
    public class Nested1 { }
}
""";
        var comp1 = CreateCompilation(src1, assemblyName: "first");
        comp1.VerifyDiagnostics();

        var src2 = """
public explicit extension R2 for R1.Nested1
{
    public class Nested2 { }
}
""";
        var comp2 = CreateCompilation(src2, references: new[] { comp1.EmitToImageReference() },
            assemblyName: "second");
        comp2.VerifyDiagnostics();

        var src1_updated = """
public explicit extension R1 for R2.Nested2
{
    public class Nested1 { }
}
""";
        comp1 = CreateCompilation(src1_updated, references: new[] { comp2.EmitToImageReference() },
            assemblyName: "first");
        comp1.VerifyDiagnostics();

        var r1 = comp1.GlobalNamespace.GetTypeMember("R1");
        Assert.True(r1.IsExtension);
        Assert.Equal("R2.Nested2", r1.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void TypeDepends_CircularityAttemptWithUnderylingType2()
    {
        var src1 = """
public explicit extension R1 for object
{
    public class Nested1<T> { }
}
""";
        var comp1 = CreateCompilation(src1, assemblyName: "first");
        comp1.VerifyDiagnostics();

        var src2 = """
public explicit extension R2 for R1.Nested1<R1>
{
    public class Nested2<T> { }
}
""";
        var comp2 = CreateCompilation(src2, references: new[] { comp1.EmitToImageReference() },
            assemblyName: "second");
        comp2.VerifyDiagnostics();

        var src1_updated = """
public explicit extension R1 for R2.Nested2<R2>
{
    public class Nested1<T> { }
}
""";
        comp1 = CreateCompilation(src1_updated, references: new[] { comp2.EmitToImageReference() },
            assemblyName: "first");
        comp1.VerifyDiagnostics();
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void TypeDepends_CircularityAttemptWithUnderylingType3()
    {
        var ilSource = """
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method private hidebysig static void '<ExplicitExtension>$'(valuetype R2 '') cil managed
    {
        IL_0000: ret
    }
}

.class public sequential ansi sealed beforefieldinit R2
    extends [mscorlib]System.ValueType
{
    .method private hidebysig static void '<ExplicitExtension>$'(valuetype R1 '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R3 for object : R1 { }
""";

        // PROTOTYPE this test should be updated once we emit erase references to extensions (different metadata format)
        // PROTOTYPE expecting some use-site diagnostics (bad metadata, as underlying type cannot be an extension)
        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R3' extends 'object' but base extension 'R1' extends 'R2'.
            // public explicit extension R3 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R3").WithArguments("R3", "object", "R1", "R2").WithLocation(1, 27)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        var r1ExtendedType = r1.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.Equal("R2", r1ExtendedType.ToTestDisplayString());
        Assert.True(r1ExtendedType.IsErrorType());

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        var r2ExtendedType = r2.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.Equal("R1", r2ExtendedType.ToTestDisplayString());
        Assert.True(r2ExtendedType.IsErrorType());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void TypeDepends_CircularityWithBaseExtension()
    {
        var ilSource = """
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method private hidebysig static void '<ExplicitExtension>$'(object '', valuetype R2 '') cil managed
    {
        IL_0000: ret
    }
}

.class public sequential ansi sealed beforefieldinit R2
    extends [mscorlib]System.ValueType
{
    .method private hidebysig static void '<ExplicitExtension>$'(object o, valuetype R1 '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R3 for object : R1 { }
public explicit extension R4 for object : R2 { }
""";

        // PROTOTYPE this test should be updated once we emit erase references to extensions (different metadata format)
        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,27): error CS0268: Imported type 'R2' is invalid. It contains a circular base type dependency.
            // public explicit extension R3 for object : R1 { }
            Diagnostic(ErrorCode.ERR_ImportedCircularBase, "R3").WithArguments("R2").WithLocation(1, 27),
            // (2,27): error CS0268: Imported type 'R1' is invalid. It contains a circular base type dependency.
            // public explicit extension R4 for object : R2 { }
            Diagnostic(ErrorCode.ERR_ImportedCircularBase, "R4").WithArguments("R1").WithLocation(2, 27)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        var r1BaseExtension = r1.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("R2", r1BaseExtension.ToTestDisplayString());
        Assert.True(r1BaseExtension.IsErrorType());

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        var r2BaseExtension = r2.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("R1", r2BaseExtension.ToTestDisplayString());
        Assert.True(r2BaseExtension.IsErrorType());
    }

    [Fact]
    public void ImplicitVsExplicit()
    {
        var src = """
struct S { }
explicit extension X for S { }
implicit extension X for S { }
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,20): error CS9315: Partial declarations of 'X' must specify the same extension modifier ('implicit' or 'explicit').
            // explicit extension X for S { }
            Diagnostic(ErrorCode.ERR_PartialDifferentExtensionModifiers, "X").WithArguments("X").WithLocation(2, 20),
            // (3,20): error CS0101: The namespace '<global namespace>' already contains a definition for 'X'
            // implicit extension X for S { }
            Diagnostic(ErrorCode.ERR_DuplicateNameInNS, "X").WithArguments("X", "<global namespace>").WithLocation(3, 20)
            );
    }

    [Fact]
    public void ImplicitVsExplicit_PartialExplicitAndImplicit()
    {
        var src = """
struct S { }
partial explicit extension X for S { }
partial implicit extension X for S { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,28): error CS9315: Partial declarations of 'X' must specify the same extension modifier ('implicit' or 'explicit').
            // partial explicit extension X for S { }
            Diagnostic(ErrorCode.ERR_PartialDifferentExtensionModifiers, "X").WithArguments("X").WithLocation(2, 28)
            );
        // PROTOTYPE add and verify an IsExplicit API on the symbol
    }

    [Fact]
    public void ImplicitVsExplicit_PartialImplicitAndExplicit()
    {
        var src = """
struct S { }
partial implicit extension X for S { }
partial explicit extension X for S { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,28): error CS9315: Partial declarations of 'X' must specify the same extension modifier ('implicit' or 'explicit').
            // partial implicit extension X for S { }
            Diagnostic(ErrorCode.ERR_PartialDifferentExtensionModifiers, "X").WithArguments("X").WithLocation(2, 28)
            );
        // PROTOTYPE add and verify an IsExplicit API on the symbol
    }

    [Fact]
    public void ImplicitVsExplicit_PartialImplicitAndExplicitAndExplicit()
    {
        var src = """
struct S { }
partial implicit extension X for S { }
partial explicit extension X for S { }
partial explicit extension X for S { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,28): error CS9315: Partial declarations of 'X' must specify the same extension modifier ('implicit' or 'explicit').
            // partial implicit extension X for S { }
            Diagnostic(ErrorCode.ERR_PartialDifferentExtensionModifiers, "X").WithArguments("X").WithLocation(2, 28),
            // (2,28): error CS9315: Partial declarations of 'X' must specify the same extension modifier ('implicit' or 'explicit').
            // partial implicit extension X for S { }
            Diagnostic(ErrorCode.ERR_PartialDifferentExtensionModifiers, "X").WithArguments("X").WithLocation(2, 28)
            );
        // PROTOTYPE add and verify an IsExplicit API on the symbol
    }

    [Theory, CombinatorialData, WorkItem(67050, "https://github.com/dotnet/roslyn/issues/67050")]
    public void ImplicitVsExplicit_PartialAndMissingImplicitOrExplicit(bool isExplicit)
    {
        var keyword = isExplicit ? "explicit" : "implicit";
        var src = $$"""
struct S { }
partial {{keyword}} extension X for S { }
partial extension X for S { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,39): error CS1031: Type expected
            // partial explicit extension X for S { }
            Diagnostic(ErrorCode.ERR_TypeExpected, "").WithLocation(2, 39),
            // (2,39): error CS1525: Invalid expression term 'partial'
            // partial explicit extension X for S { }
            Diagnostic(ErrorCode.ERR_InvalidExprTerm, "").WithArguments("partial").WithLocation(2, 39),
            // (2,39): error CS1003: Syntax error, ',' expected
            // partial explicit extension X for S { }
            Diagnostic(ErrorCode.ERR_SyntaxError, "").WithArguments(",").WithLocation(2, 39),
            // (3,1): error CS8803: Top-level statements must precede namespace and type declarations.
            // partial extension X for S { }
            Diagnostic(ErrorCode.ERR_TopLevelStatementAfterNamespaceOrType, "p").WithLocation(3, 1),
            // (3,29): error CS1002: ; expected
            // partial extension X for S { }
            Diagnostic(ErrorCode.ERR_SemicolonExpected, "}").WithLocation(3, 29),
            // (3,29): error CS1022: Type or namespace definition, or end-of-file expected
            // partial extension X for S { }
            Diagnostic(ErrorCode.ERR_EOFExpected, "}").WithLocation(3, 29)
            );
    }

    [Fact]
    public void ExtensionAsBase_ForClass()
    {
        var src = """
class C1 { }
explicit extension R for C1 { }
class C2 : R { } // 1
class C3 : C1, R { } // 2
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,12): error CS0527: Type 'R' in interface list is not an interface
            // class C2 : R { } // 1
            Diagnostic(ErrorCode.ERR_NonInterfaceInInterfaceList, "R").WithArguments("R").WithLocation(3, 12),
            // (4,16): error CS0527: Type 'R' in interface list is not an interface
            // class C3 : C1, R { } // 2
            Diagnostic(ErrorCode.ERR_NonInterfaceInInterfaceList, "R").WithArguments("R").WithLocation(4, 16)
            );
    }

    [Fact]
    public void ExtensionAsBase_ForStruct()
    {
        var src = """
struct S1 { }
explicit extension R for S1 { }
struct S2 : R { } // 1
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,13): error CS0527: Type 'R' in interface list is not an interface
            // struct S2 : R { } // 1
            Diagnostic(ErrorCode.ERR_NonInterfaceInInterfaceList, "R").WithArguments("R").WithLocation(3, 13)
            );
    }

    [Fact]
    public void ExtensionAsBase_ForInterface()
    {
        var src = """
interface I1 { }
explicit extension R for I1 { }
interface I2 : R { } // 1
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,16): error CS0527: Type 'R' in interface list is not an interface
            // interface I2 : R { } // 1
            Diagnostic(ErrorCode.ERR_NonInterfaceInInterfaceList, "R").WithArguments("R").WithLocation(3, 16)
            );
    }

    [Fact]
    public void ExtensionAsBase_ForEnum()
    {
        var src = """
enum E1 { }
explicit extension R for E1 { }
enum E2 : R { } // 1
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,11): error CS1008: Type byte, sbyte, short, ushort, int, uint, long, or ulong expected
            // enum E2 : R { } // 1
            Diagnostic(ErrorCode.ERR_IntegralTypeExpected, "R").WithLocation(3, 11)
            );
    }

    [Fact]
    public void ExtensionAsBase_ForRecordClass()
    {
        var src = """
record R1(int i) { }
explicit extension Extension for R1 { }
record R2(int j) : Extension { } // 1
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (3,20): error CS0527: Type 'Extension' in interface list is not an interface
            // record R2(int j) : Extension { } // 1
            Diagnostic(ErrorCode.ERR_NonInterfaceInInterfaceList, "Extension").WithArguments("Extension").WithLocation(3, 20)
            );
    }

    [Fact]
    public void ExtensionAsBase_ForRecordStruct()
    {
        var src = """
record struct R1(int i) { }
explicit extension Extension for R1 { }
record struct R2(int j) : Extension { } // 1
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,27): error CS0527: Type 'Extension' in interface list is not an interface
            // record struct R2(int j) : Extension { } // 1
            Diagnostic(ErrorCode.ERR_NonInterfaceInInterfaceList, "Extension").WithArguments("Extension").WithLocation(3, 27)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension()
    {
        var src = """
class C { }
explicit extension R1 for C { }
explicit extension R2 for C { }
explicit extension R3 for C : R1, R2 { }

partial explicit extension R4 for C : R1 { }
partial explicit extension R4 for C : R2 { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);

        return;

        static void validate(ModuleSymbol module)
        {
            var r3 = module.GlobalNamespace.GetTypeMember("R3");
            Assert.Equal("C", r3.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Equal(new[] { "R1", "R2" }, r3.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
            Assert.Equal(new[] { "R1", "R2" }, r3.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());

            var r4 = module.GlobalNamespace.GetTypeMember("R4");
            Assert.Equal("C", r4.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Equal(new[] { "R1", "R2" }, r4.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
            Assert.Equal(new[] { "R1", "R2" }, r4.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        }
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_Generic()
    {
        var src = """
class C<T1, T2> { }
class D<U>
{
    explicit extension R1<T1, T2> for C<T1, T2> { }
    explicit extension R2<T1, T2> for C<T1, T2> { }
    explicit extension R3<V> for C<U, V> : R1<U, V>, R2<U, V> { }

    partial explicit extension R4<V> for C<U, V> : R1<U, V> { }
    partial explicit extension R4<V> for C<U, V> : R2<U, V> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            var d = module.GlobalNamespace.GetTypeMember("D");
            var r1 = d.GetTypeMember("R1");
            Assert.Equal(2, r1.Arity);

            var r3 = d.GetTypeMember("R3");
            Assert.Equal(1, r3.Arity);
            Assert.Equal("C<U, V>", r3.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Equal(new[] { "D<U>.R1<U, V>", "D<U>.R2<U, V>" }, r3.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
            Assert.Equal(new[] { "D<U>.R1<U, V>", "D<U>.R2<U, V>" }, r3.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());

            var r4 = d.GetTypeMember("R4");
            Assert.Equal(1, r4.Arity);
            Assert.Equal("C<U, V>", r4.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
            Assert.Equal(new[] { "D<U>.R1<U, V>", "D<U>.R2<U, V>" }, r4.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
            Assert.Equal(new[] { "D<U>.R1<U, V>", "D<U>.R2<U, V>" }, r4.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());

            var r4FirstBase = r4.BaseExtensionsNoUseSiteDiagnostics.First();
            Assert.Equal(2, r4FirstBase.TypeArguments().Length);
            Assert.Same(d.TypeArguments().Single(), r4FirstBase.TypeArguments()[0]);
            Assert.Same(r4.TypeArguments().Single(), r4FirstBase.TypeArguments()[1]);
        }
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtensions_ErrorType()
    {
        var src = """
class C { }
explicit extension R for C : error
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,30): error CS0246: The type or namespace name 'error' could not be found (are you missing a using directive or an assembly reference?)
            // explicit extension R for C : error
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "error").WithArguments("error").WithLocation(2, 30)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.True(r.IsExtension);
        Assert.Equal("C", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        var baseExtensions = r.BaseExtensionsNoUseSiteDiagnostics;
        Assert.Equal(new[] { "error" }, baseExtensions.ToTestDisplayStrings());
        Assert.True(baseExtensions.Single().IsErrorType());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtensions_ErrorType_Nested()
    {
        var src = """
class C { }
explicit extension R1<T> for C { }
explicit extension R2 for C : R1<error>
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,34): error CS0246: The type or namespace name 'error' could not be found (are you missing a using directive or an assembly reference?)
            // explicit extension R2 for C : R1<error>
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "error").WithArguments("error").WithLocation(3, 34)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R2");
        var baseExtensions = r.BaseExtensionsNoUseSiteDiagnostics;
        Assert.Equal(new[] { "R1<error>" }, baseExtensions.ToTestDisplayStrings());
    }

    [ConditionalTheory(typeof(NoBaseExtensions))]
    [InlineData("internal", "public")]
    [InlineData("protected", "public")]
    [InlineData("private protected", "public")]
    [InlineData("internal protected", "public")]
    [InlineData("private protected", "protected")]
    [InlineData("private", "public")]
    [InlineData("internal", "protected")]
    [InlineData("private protected", "internal")]
    [InlineData("internal", "internal protected")]
    [InlineData("private", "internal")]
    [InlineData("protected", "internal")]
    public void BaseExtensions_LessAccessibleBaseExtension(string baseAccessibility, string thisAccessibility)
    {
        var src = $$"""
public struct UnderlyingStruct { }
public class C
{
    {{baseAccessibility}} explicit extension R1 for UnderlyingStruct { }
    {{thisAccessibility}} explicit extension R2 for UnderlyingStruct : R1 { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,43): error CS9310: Inconsistent accessibility: base extension 'C.R1' is less accessible than extension 'C.R2'
            //     internal protected explicit extension R2 for UnderlyingStruct : R1 { }
            Diagnostic(ErrorCode.ERR_BadVisBaseExtension, "R2").WithArguments("C.R2", "C.R1")
            );
    }

    [ConditionalTheory(typeof(NoBaseExtensions))]
    [InlineData("public", "public")]
    [InlineData("public", "internal")]
    [InlineData("public", "protected")]
    [InlineData("public", "private protected")]
    [InlineData("public", "internal protected")]
    [InlineData("public", "private")]
    [InlineData("internal", "internal")]
    [InlineData("internal", "private protected")]
    [InlineData("internal protected", "internal")]
    [InlineData("protected", "protected")]
    [InlineData("protected", "private protected")]
    [InlineData("private", "private")]
    public void BaseExtensions_AtLeastAsAccessibleBaseExtension(string baseAccessibility, string thisAccessibility)
    {
        var src = $$"""
public class C
{
    public struct UnderlyingStruct { }
    {{baseAccessibility}} explicit extension R1 for UnderlyingStruct { }
    {{thisAccessibility}} explicit extension R2 for UnderlyingStruct : R1 { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_FileType_NonFileExtension()
    {
        var src = """
class UnderlyingClass { }
file explicit extension R1 for UnderlyingClass { }
explicit extension R for UnderlyingClass : R1 { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,20): error CS9053: File-local type 'R1' cannot be used as a base type of non-file-local type 'R'.
            // explicit extension R for UnderlyingClass : R1 { }
            Diagnostic(ErrorCode.ERR_FileTypeBase, "R").WithArguments("R1", "R").WithLocation(3, 20)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal(new[] { "R1@<tree 0>" }, r.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.Equal(new[] { "R1@<tree 0>" }, r.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_FileType_NonFileExtension_SecondPosition()
    {
        var src = """
class UnderlyingClass { }
explicit extension R1 for UnderlyingClass { }
file explicit extension R2 for UnderlyingClass { }
explicit extension R for UnderlyingClass : R1, R2 { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,20): error CS9053: File-local type 'R2' cannot be used as a base type of non-file-local type 'R'.
            // explicit extension R for UnderlyingClass : R1, R2 { }
            Diagnostic(ErrorCode.ERR_FileTypeBase, "R").WithArguments("R2", "R").WithLocation(4, 20)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R", r.ToTestDisplayString());
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal(new[] { "R1", "R2@<tree 0>" }, r.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_FileType_NonFileExtension_Both()
    {
        var src = """
class UnderlyingClass { }
file explicit extension R1 for UnderlyingClass { }
file explicit extension R2 for UnderlyingClass { }
explicit extension R for UnderlyingClass : R1, R2 { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,20): error CS9053: File-local type 'R1' cannot be used as a base type of non-file-local type 'R'.
            // explicit extension R for UnderlyingClass : R1, R2 { }
            Diagnostic(ErrorCode.ERR_FileTypeBase, "R").WithArguments("R1", "R").WithLocation(4, 20),
            // (4,20): error CS9053: File-local type 'R2' cannot be used as a base type of non-file-local type 'R'.
            // explicit extension R for UnderlyingClass : R1, R2 { }
            Diagnostic(ErrorCode.ERR_FileTypeBase, "R").WithArguments("R2", "R").WithLocation(4, 20)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal(new[] { "R1@<tree 0>", "R2@<tree 0>" }, r.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
    }

    [ConditionalTheory(typeof(NoBaseExtensions)), CombinatorialData]
    public void BaseExtension_ImplicitVsExplicit(bool baseIsExplicit, bool thisIsExplicit)
    {
        var src = $$"""
class C { }
{{(baseIsExplicit ? "explicit" : "implicit")}} extension R1 for C { }
{{(thisIsExplicit ? "explicit" : "implicit")}} extension R for C : R1 { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_MiscTypes()
    {
        var src = """
class C { }
interface I { }
struct S { }
enum E { }
explicit extension R1 for C : I { } // 1
explicit extension R2 for C : C { } // 2
explicit extension R3 for C : S { } // 3
explicit extension R4 for C : E { } // 4

#nullable enable
explicit extension R5 for C { }
explicit extension R6 for C : R5? { } // 5

explicit extension R7 for S { }
explicit extension R8 for S : R7? { } // PROTOTYPE

unsafe explicit extension R9 for C : C* { } // 6
""";
        // PROTOTYPE need to revisit binding of annotated types to account for extension types
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (5,31): error CS9307: A base extension must be an extension type.
            // explicit extension R1 for C : I { } // 1
            Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "I").WithLocation(5, 31),
            // (6,31): error CS9307: A base extension must be an extension type.
            // explicit extension R2 for C : C { } // 2
            Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "C").WithLocation(6, 31),
            // (7,31): error CS9307: A base extension must be an extension type.
            // explicit extension R3 for C : S { } // 3
            Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "S").WithLocation(7, 31),
            // (8,31): error CS9307: A base extension must be an extension type.
            // explicit extension R4 for C : E { } // 4
            Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "E").WithLocation(8, 31),
            // (12,31): error CS9307: A base extension must be an extension type.
            // explicit extension R6 for C : R5? { } // 5
            Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "R5?").WithLocation(12, 31),
            // (15,31): error CS9307: A base extension must be an extension type.
            // explicit extension R8 for S : R7? { } // PROTOTYPE
            Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "R7?").WithLocation(15, 31),
            // (17,38): error CS9307: A base extension must be an extension type.
            // unsafe explicit extension R9 for C : C* { } // 6
            Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "C*").WithLocation(17, 38)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        Assert.Empty(r1.BaseExtensionsNoUseSiteDiagnostics);

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        Assert.Empty(r2.BaseExtensionsNoUseSiteDiagnostics);

        var r3 = comp.GlobalNamespace.GetTypeMember("R3");
        Assert.Empty(r3.BaseExtensionsNoUseSiteDiagnostics);

        var r4 = comp.GlobalNamespace.GetTypeMember("R4");
        Assert.Empty(r4.BaseExtensionsNoUseSiteDiagnostics);

        var r5 = comp.GlobalNamespace.GetTypeMember("R5");
        Assert.Empty(r5.BaseExtensionsNoUseSiteDiagnostics);

        var r6 = comp.GlobalNamespace.GetTypeMember("R6");
        Assert.Equal("R5", r6.BaseExtensionsNoUseSiteDiagnostics.Single().ToTestDisplayString());

        var r8 = comp.GlobalNamespace.GetTypeMember("R8");
        Assert.Equal("R7", r8.BaseExtensionsNoUseSiteDiagnostics.Single().ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_Pointer()
    {
        var src = """
class C { }
explicit extension D<T> for C { }
unsafe explicit extension R1 for C : D<int*> { } // 1
explicit extension R2 for C : D<int*> { } // 2, 3
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (3,27): error CS0306: The type 'int*' may not be used as a type argument
            // unsafe explicit extension R1 for C : D<int*> { } // 1
            Diagnostic(ErrorCode.ERR_BadTypeArgument, "R1").WithArguments("int*").WithLocation(3, 27),
            // (4,20): error CS0306: The type 'int*' may not be used as a type argument
            // explicit extension R2 for C : D<int*> { } // 2, 3
            Diagnostic(ErrorCode.ERR_BadTypeArgument, "R2").WithArguments("int*").WithLocation(4, 20),
            // (4,33): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            // explicit extension R2 for C : D<int*> { } // 2, 3
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "int*").WithLocation(4, 33)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_Constraints()
    {
        var src = """
class C { }
explicit extension D<T> for C where T : class { }

explicit extension R1 for C : D<string> { }
explicit extension R2 for C : D<int> { } // 1
explicit extension R3<T> for C : D<T> where T : class { }
explicit extension R4<T> for C : D<T> where T : struct { } // 2
explicit extension R5<T> for C : D<T> { } // 3
explicit extension R6 for C : D<R1> { } // 4
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,20): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'T' in the generic type or method 'D<T>'
            // explicit extension R2 for C : D<int> { } // 1
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "R2").WithArguments("D<T>", "T", "int").WithLocation(5, 20),
            // (7,20): error CS0452: The type 'T' must be a reference type in order to use it as parameter 'T' in the generic type or method 'D<T>'
            // explicit extension R4<T> for C : D<T> where T : struct { } // 2
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "R4").WithArguments("D<T>", "T", "T").WithLocation(7, 20),
            // (8,20): error CS0452: The type 'T' must be a reference type in order to use it as parameter 'T' in the generic type or method 'D<T>'
            // explicit extension R5<T> for C : D<T> { } // 3
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "R5").WithArguments("D<T>", "T", "T").WithLocation(8, 20),
            // (9,20): error CS0452: The type 'R1' must be a reference type in order to use it as parameter 'T' in the generic type or method 'D<T>'
            // explicit extension R6 for C : D<R1> { } // 4
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "R6").WithArguments("D<T>", "T", "R1").WithLocation(9, 20)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_DeriveWithWeakerConstraints()
    {
        var src = """
class C { }
interface I1 { }
interface I2 { }
explicit extension R1<T> for C where T : I1, I2 { }
explicit extension R2<T> for C : R1<T> where T : I2 { } // 1
explicit extension R3<T> for C : R2<T>, R1<T> { } // 2, 3, 4
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,20): error CS0314: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'R1<T>'. There is no boxing conversion or type parameter conversion from 'T' to 'I1'.
            // explicit extension R2<T> for C : R1<T> where T : I2 { } // 1
            Diagnostic(ErrorCode.ERR_GenericConstraintNotSatisfiedTyVar, "R2").WithArguments("R1<T>", "I1", "T", "T").WithLocation(5, 20),
            // (6,20): error CS0314: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'R2<T>'. There is no boxing conversion or type parameter conversion from 'T' to 'I2'.
            // explicit extension R3<T> for C : R2<T>, R1<T> { } // 2, 3, 4
            Diagnostic(ErrorCode.ERR_GenericConstraintNotSatisfiedTyVar, "R3").WithArguments("R2<T>", "I2", "T", "T").WithLocation(6, 20),
            // (6,20): error CS0314: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'R1<T>'. There is no boxing conversion or type parameter conversion from 'T' to 'I1'.
            // explicit extension R3<T> for C : R2<T>, R1<T> { } // 2, 3, 4
            Diagnostic(ErrorCode.ERR_GenericConstraintNotSatisfiedTyVar, "R3").WithArguments("R1<T>", "I1", "T", "T").WithLocation(6, 20),
            // (6,20): error CS0314: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'R1<T>'. There is no boxing conversion or type parameter conversion from 'T' to 'I2'.
            // explicit extension R3<T> for C : R2<T>, R1<T> { } // 2, 3, 4
            Diagnostic(ErrorCode.ERR_GenericConstraintNotSatisfiedTyVar, "R3").WithArguments("R1<T>", "I2", "T", "T").WithLocation(6, 20)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_DuplicatesAndVariations()
    {
        var src = """
class C { }
explicit extension R0 for C { }

explicit extension R1 for C : R0, R0 { } // 1

partial explicit extension R2 for C : R0 { }
partial explicit extension R2 for C : R0, R0 { } // 2

explicit extension R3<T> for C { }

explicit extension R4 for C :
#nullable enable
    R3<object?>,
#nullable disable
    R3<object> // no diagnostic since reported on oblivious location
#nullable enable
{
}

interface I<T> { }
class D :
#nullable enable
    I<object?>,
#nullable disable
    I<object> // no diagnostic since reported on oblivious location
#nullable enable
{
}

explicit extension R5 for C :
#nullable disable
    R3<object>,
#nullable enable
    R3<object?> // 3
    { }

#nullable enable
explicit extension R6 for C : R3<object>, R3<object?> { } // 4

explicit extension R7 for C : R3<object>, R3<dynamic> { } // 5

explicit extension R8 for C : R3<(int i, int j)>, R3<(int, int)> { } // 6
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,35): error CS9320: 'R0' is already listed in the base extension list
            // explicit extension R1 for C : R0, R0 { } // 1
            Diagnostic(ErrorCode.ERR_DuplicateExtensionInBaseList, "R0").WithArguments("R0").WithLocation(4, 35),
            // (7,43): error CS9320: 'R0' is already listed in the base extension list
            // partial explicit extension R2 for C : R0, R0 { } // 2
            Diagnostic(ErrorCode.ERR_DuplicateExtensionInBaseList, "R0").WithArguments("R0").WithLocation(7, 43),
            // (34,5): warning CS9317: 'R3<object?>' is already listed in the base extension list on type 'R5' with different nullability of reference types.
            //     R3<object?> // 3
            Diagnostic(ErrorCode.WRN_DuplicateExtensionWithNullabilityMismatchInBaseList, "R3<object?>").WithArguments("R3<object?>", "R5").WithLocation(34, 5),
            // (38,20): warning CS9317: 'R3<object?>' is already listed in the base extension list on type 'R6' with different nullability of reference types.
            // explicit extension R6 for C : R3<object>, R3<object?> { } // 4
            Diagnostic(ErrorCode.WRN_DuplicateExtensionWithNullabilityMismatchInBaseList, "R6").WithArguments("R3<object?>", "R6").WithLocation(38, 20),
            // (40,20): error CS9319: 'R3<dynamic>' is already listed in the base extension list on type 'R7' as 'R3<object>'.
            // explicit extension R7 for C : R3<object>, R3<dynamic> { } // 5
            Diagnostic(ErrorCode.ERR_DuplicateExtensionWithDifferencesInBaseList, "R7").WithArguments("R3<dynamic>", "R3<object>", "R7").WithLocation(40, 20),
            // (42,20): error CS9318: 'R3<(int, int)>' is already listed in the base extension list on type 'R8' with different tuple element names, as 'R3<(int i, int j)>'.
            // explicit extension R8 for C : R3<(int i, int j)>, R3<(int, int)> { } // 6
            Diagnostic(ErrorCode.ERR_DuplicateExtensionWithTupleNamesInBaseList, "R8").WithArguments("R3<(int, int)>", "R3<(int i, int j)>", "R8").WithLocation(42, 20)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_DuplicatesAndVariations_FromBase()
    {
        var src = """
class C { }
explicit extension R0 for C { }

explicit extension R1a for C : R0 { }
explicit extension R1b for C : R0, R1a { }

partial explicit extension R2 for C : R0 { }
partial explicit extension R2 for C : R1a, R0 { }

explicit extension R3<T> for C { }

#nullable disable
explicit extension R5a for C : R3<object> { }
#nullable enable
explicit extension R5b for C : R5a, R3<object?> { }

#nullable enable
explicit extension R6a for C : R3<object> { }
explicit extension R6b for C : R6a, R3<object?> { } // 1

explicit extension R7a for C : R3<object> { }
explicit extension R7b for C : R7a, R3<dynamic> { } // 2

explicit extension R8a for C : R3<(int i, int j)> { }
explicit extension R8b for C : R8a, R3<(int, int)> { } // 3
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (19,20): warning CS9317: 'R3<object?>' is already listed in the base extension list on type 'R6b' with different nullability of reference types.
            // explicit extension R6b for C : R6a, R3<object?> { } // 1
            Diagnostic(ErrorCode.WRN_DuplicateExtensionWithNullabilityMismatchInBaseList, "R6b").WithArguments("R3<object?>", "R6b").WithLocation(19, 20),
            // (22,20): error CS9319: 'R3<dynamic>' is already listed in the base extension list on type 'R7b' as 'R3<object>'.
            // explicit extension R7b for C : R7a, R3<dynamic> { } // 2
            Diagnostic(ErrorCode.ERR_DuplicateExtensionWithDifferencesInBaseList, "R7b").WithArguments("R3<dynamic>", "R3<object>", "R7b").WithLocation(22, 20),
            // (25,20): error CS9318: 'R3<(int, int)>' is already listed in the base extension list on type 'R8b' with different tuple element names, as 'R3<(int i, int j)>'.
            // explicit extension R8b for C : R8a, R3<(int, int)> { } // 3
            Diagnostic(ErrorCode.ERR_DuplicateExtensionWithTupleNamesInBaseList, "R8b").WithArguments("R3<(int, int)>", "R3<(int i, int j)>", "R8b").WithLocation(25, 20)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_CouldUnify()
    {
        var src = """
class C { }
explicit extension R1<T> for C { }
explicit extension R2<T1, T2> for C : R1<T1>, R1<T2> { }

interface I1<T> { }
interface I2<T1, T2> : I1<T1>, I1<T2> { } // 1
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (6,11): error CS0695: 'I2<T1, T2>' cannot implement both 'I1<T1>' and 'I1<T2>' because they may unify for some type parameter substitutions
            // interface I2<T1, T2> : I1<T1>, I1<T2> { } // 1
            Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "I2").WithArguments("I2<T1, T2>", "I1<T1>", "I1<T2>").WithLocation(6, 11)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_UnderlyingTypeMismatch()
    {
        var src = """
explicit extension R1 for int { }
explicit extension R2 for long : R1 { } // 1

class C<T> { }
explicit extension R3 for C<object> { }
explicit extension R4 for C<dynamic> : R3 { } // 2

explicit extension R5 for (int i, int j) { }
explicit extension R6 for (int, int) : R5 { } // 3

#nullable enable
explicit extension R7 for string { }
#nullable disable
explicit extension R8 for string : R7 { }

#nullable enable
explicit extension R9 for C<string> { }
#nullable disable
explicit extension R10 for C<string> : R9 { } // 4

explicit extension R12 for C<string> : R11 { } // 5
#nullable enable
explicit extension R11 for C<string> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,20): error CS9316: Extension 'R2' extends 'long' but base extension 'R1' extends 'int'.
            // explicit extension R2 for long : R1 { } // 1
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "long", "R1", "int").WithLocation(2, 20),
            // (6,20): error CS9316: Extension 'R4' extends 'C<dynamic>' but base extension 'R3' extends 'C<object>'.
            // explicit extension R4 for C<dynamic> : R3 { } // 2
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R4").WithArguments("R4", "C<dynamic>", "R3", "C<object>").WithLocation(6, 20),
            // (9,20): error CS9316: Extension 'R6' extends '(int, int)' but base extension 'R5' extends '(int i, int j)'.
            // explicit extension R6 for (int, int) : R5 { } // 3
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R6").WithArguments("R6", "(int, int)", "R5", "(int i, int j)").WithLocation(9, 20),
            // (19,20): error CS9316: Extension 'R10' extends 'C<string>' but base extension 'R9' extends 'C<string>'.
            // explicit extension R10 for C<string> : R9 { } // 4
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R10").WithArguments("R10", "C<string>", "R9", "C<string>").WithLocation(19, 20),
            // (21,20): error CS9316: Extension 'R12' extends 'C<string>' but base extension 'R11' extends 'C<string>'.
            // explicit extension R12 for C<string> : R11 { } // 5
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R12").WithArguments("R12", "C<string>", "R11", "C<string>").WithLocation(21, 20)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_UnderlyingTypeMismatch_Generic()
    {
        var src = """
explicit extension R1<T> for T { }
explicit extension R2<U> for U : R1<U> { }

class C<T> { }
explicit extension R3<T> for C<T> { }
explicit extension R4<U> for C<U> : R3<U> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        Assert.Equal("U", r2.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal("U", r2.BaseExtensionsNoUseSiteDiagnostics.Single().GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());

        var r4 = comp.GlobalNamespace.GetTypeMember("R4");
        Assert.Equal("C<U>", r4.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal("C<U>", r4.BaseExtensionsNoUseSiteDiagnostics.Single().GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_UnderlyingTypeMismatch_PE()
    {
        // class C { }
        // explicit extension R1 for object { }
        // explicit extension R2 for C : R1 { }
        var ilSource = """
.class public auto ansi beforefieldinit C
    extends [mscorlib]System.Object
{
    .method public hidebysig specialname rtspecialname instance void .ctor() cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Object::.ctor()
        IL_0006: ret
    }
}

.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method private hidebysig static void '<ExplicitExtension>$'(object '') cil managed
    {
        IL_0000: ret
    }
}

.class public sequential ansi sealed beforefieldinit R2
    extends [mscorlib]System.ValueType
{
    .method private hidebysig static void '<ExplicitExtension>$'(class C '', valuetype R1 '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R3 for object : R2 { }
public explicit extension R4 for C : R2 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R3' extends 'object' but base extension 'R2' extends 'C'.
            // public explicit extension R3 for object : R2 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R3").WithArguments("R3", "object", "R2", "C").WithLocation(1, 27),
            // (2,27): error CS9316: Extension 'R4' extends 'C' but base extension 'R1' extends 'object'.
            // public explicit extension R4 for C : R2 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R4").WithArguments("R4", "C", "R1", "object").WithLocation(2, 27)
            );

        var r2 = (PENamedTypeSymbol)comp.GlobalNamespace.GetTypeMember("R2");
        var r2BaseExtension = r2.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("R1", r2BaseExtension.ToTestDisplayString());
        Assert.False(r2BaseExtension.IsErrorType());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_UnderlyingTypeMismatch_Retargeting()
    {
        var src1 = """
public class C { }
public explicit extension E1 for C { }
""";
        var comp1 = CreateCompilation(src1,
            assemblyName: "first");
        comp1.VerifyDiagnostics();

        var src2 = """
public explicit extension E2 for C : E1 { }
""";
        var comp2 = CreateCompilation(src2,
            references: new[] { comp1.EmitToImageReference() });
        comp2.VerifyDiagnostics();

        var src1Updated = """
public class C { }
public explicit extension E1 for object { }
""";
        var comp1Updated = CreateCompilation(src1Updated,
            assemblyName: "first");
        comp1Updated.VerifyDiagnostics();

        var src = """
explicit extension E3 for C : E2 { }
explicit extension E4 for object : E2 { }
""";
        var comp = CreateCompilation(src,
            references: new[] { comp1Updated.EmitToImageReference(), comp2.ToMetadataReference() });
        comp.VerifyDiagnostics(
            // (1,20): error CS8090: There is an error in a referenced assembly 'first, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // explicit extension E3 for C : E2 { }
            Diagnostic(ErrorCode.ERR_ErrorInReferencedAssembly, "E3").WithArguments("first, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 20),
            // (2,20): error CS8090: There is an error in a referenced assembly 'first, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // explicit extension E4 for object : E2 { }
            Diagnostic(ErrorCode.ERR_ErrorInReferencedAssembly, "E4").WithArguments("first, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(2, 20),
            // (2,20): error CS9316: Extension 'E4' extends 'object' but base extension 'E2' extends 'C'.
            // explicit extension E4 for object : E2 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "E4").WithArguments("E4", "object", "E2", "C").WithLocation(2, 20)
            );

        var e2 = (RetargetingNamedTypeSymbol)comp.GlobalNamespace.GetTypeMember("E2");
        var e2BaseExtension = e2.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("E1", e2BaseExtension.ToTestDisplayString());

        AssertEx.Equal("error CS8090: There is an error in a referenced assembly 'first, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.",
            ((ErrorTypeSymbol)e2BaseExtension).ErrorInfo.ToString());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_StaticType_InstanceExtension()
    {
        var src = """
class UnderlyingClass { }
static explicit extension StaticExtension for UnderlyingClass { }
explicit extension R for UnderlyingClass : StaticExtension { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("StaticExtension", r.BaseExtensionsNoUseSiteDiagnostics.Single().ToTestDisplayString());
        Assert.False(r.IsStatic);

        var staticExtension = comp.GlobalNamespace.GetTypeMember("StaticExtension");
        Assert.True(staticExtension.IsStatic);
    }

    [Fact]
    public void Modifiers_Partial()
    {
        var src = """
class UnderlyingClass { }
partial explicit extension R for UnderlyingClass
{
}
partial explicit extension R for UnderlyingClass
{
}
partial explicit extension R
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.False(r.IsStatic);
    }

    [Fact]
    public void Modifiers_Partial_UnpartialDeclaration()
    {
        var src = """
class C { }
partial explicit extension R for C { }
explicit extension R for C { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,20): error CS0260: Missing partial modifier on declaration of type 'R'; another partial declaration of this type exists
            // explicit extension R for C { }
            Diagnostic(ErrorCode.ERR_MissingPartial, "R").WithArguments("R").WithLocation(3, 20)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("C", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void Modifiers_Unsafe()
    {
        var src = """
class UnderlyingClass { }
unsafe explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,27): error CS0227: Unsafe code may only appear if compiling with /unsafe
            // unsafe explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_IllegalUnsafe, "R").WithLocation(2, 27)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.False(r.IsStatic);
    }

    [Fact]
    public void Modifiers_Unsafe_InUnsafeCompilation()
    {
        var src = """
class UnderlyingClass { }
unsafe explicit extension R for UnderlyingClass
{
    int* M(int* i) => i;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.False(r.IsStatic);
        comp.VerifyDiagnostics();
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void Modifiers_New()
    {
        var src = """
class UnderlyingClass { }
explicit extension BaseExtension for UnderlyingClass
{
    class R { }
}
class UnderlyingClass2 { }
explicit extension DerivedExtension for UnderlyingClass : BaseExtension
{
    new explicit extension R for UnderlyingClass2 { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("DerivedExtension").GetTypeMember("R");
        Assert.Equal("DerivedExtension.R", r.ToTestDisplayString());
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass2", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        // PROTOTYPE verify hiding in usages/lookups
    }

    [Fact]
    public void Modifiers_Public()
    {
        var src = """
public struct UnderlyingStruct { }
public explicit extension R for UnderlyingStruct
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal(Accessibility.Public, r.DeclaredAccessibility);
        // PROTOTYPE verify accessibility from source and metadata references
    }

    [Fact]
    public void Modifiers_Protected()
    {
        var src = """
struct UnderlyingStruct { }
protected explicit extension R for UnderlyingStruct
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,30): error CS1527: Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected
            // protected explicit extension R for UnderlyingStruct
            Diagnostic(ErrorCode.ERR_NoNamespacePrivate, "R").WithLocation(2, 30),
            // (2,30): error CS9309: Inconsistent accessibility: underlying type 'UnderlyingStruct' is less accessible than extension 'R'
            // protected explicit extension R for UnderlyingStruct
            Diagnostic(ErrorCode.ERR_BadVisUnderlyingType, "R").WithArguments("R", "UnderlyingStruct").WithLocation(2, 30)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal(Accessibility.Protected, r.DeclaredAccessibility);
    }

    [Fact]
    public void Modifiers_Protected_InSealedContainingType()
    {
        var src = """
struct S { }
sealed class C
{
    protected explicit extension R for S { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,34): warning CS0628: 'C.R': new protected member declared in sealed type
            //     protected explicit extension R for S { }
            Diagnostic(ErrorCode.WRN_ProtectedInSealed, "R").WithArguments("C.R").WithLocation(4, 34)
            );
    }

    [Fact]
    public void Modifiers_Protected_Nested()
    {
        var src = """
struct UnderlyingStruct { }
class C
{
    protected explicit extension R for UnderlyingStruct
    {
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("C").GetTypeMember("R");
        Assert.Equal("C.R", r.ToTestDisplayString());
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal(Accessibility.Protected, r.DeclaredAccessibility);
        Assert.Equal("C", r.ContainingType.ToTestDisplayString());
        // PROTOTYPE verify accessibility from source and metadata references
    }

    [Fact]
    public void Modifiers_Internal()
    {
        var src = """
struct UnderlyingStruct { }
internal explicit extension R for UnderlyingStruct
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
        // PROTOTYPE verify accessibility from source and metadata references
    }

    [Fact]
    public void Modifiers_ProtectedInternal()
    {
        var src = """
struct UnderlyingStruct { }
protected internal explicit extension R for UnderlyingStruct
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,39): error CS1527: Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected
            // protected internal explicit extension R for UnderlyingStruct
            Diagnostic(ErrorCode.ERR_NoNamespacePrivate, "R").WithLocation(2, 39),
            // (2,39): error CS9309: Inconsistent accessibility: underlying type 'UnderlyingStruct' is less accessible than extension 'R'
            // protected internal explicit extension R for UnderlyingStruct
            Diagnostic(ErrorCode.ERR_BadVisUnderlyingType, "R").WithArguments("R", "UnderlyingStruct").WithLocation(2, 39)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal(Accessibility.ProtectedOrInternal, r.DeclaredAccessibility);
    }

    [Fact]
    public void Modifiers_ProtectedInternal_Nested()
    {
        var src = """
struct UnderlyingStruct { }
class C
{
    protected internal explicit extension R for UnderlyingStruct
    {
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("C").GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal(Accessibility.ProtectedOrInternal, r.DeclaredAccessibility);
        // PROTOTYPE verify accessibility from source and metadata references
    }

    [Fact]
    public void Modifiers_Private()
    {
        var src = """
struct UnderlyingStruct { }
private explicit extension R for UnderlyingStruct
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,28): error CS1527: Elements defined in a namespace cannot be explicitly declared as private, protected, protected internal, or private protected
            // private explicit extension R for UnderlyingStruct
            Diagnostic(ErrorCode.ERR_NoNamespacePrivate, "R").WithLocation(2, 28)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal(Accessibility.Private, r.DeclaredAccessibility);
    }

    [Fact]
    public void Modifiers_Private_Nested()
    {
        var src = """
struct UnderlyingStruct { }
class C
{
    private explicit extension R for UnderlyingStruct
    {
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("C").GetTypeMember("R");
        Assert.Equal("C.R", r.ToTestDisplayString());
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal(Accessibility.Private, r.DeclaredAccessibility);
    }

    [Fact]
    public void Modifiers_File()
    {
        var src = """
struct UnderlyingStruct { }
file explicit extension R for UnderlyingStruct
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R@<tree 0>", r.ToTestDisplayString());
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
        // PROTOTYPE verify visibility from source references, in name or extension lookup
    }

    [Fact]
    public void Modifiers_File_WithAccessibility()
    {
        var src = """
struct UnderlyingStruct { }
file internal explicit extension R for UnderlyingStruct
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,34): error CS9052: File-local type 'R' cannot use accessibility modifiers.
            // file internal explicit extension R for UnderlyingStruct
            Diagnostic(ErrorCode.ERR_FileTypeNoExplicitAccessibility, "R").WithArguments("R").WithLocation(2, 34)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("R@<tree 0>", r.ToTestDisplayString());
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
    }

    [Fact]
    public void Modifiers_File_DuplicateName()
    {
        var src = """
struct S { }
file explicit extension R for S { }
file explicit extension R for S { }

class C
{
    explicit extension R2 for S { }
    explicit extension R2 for S { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,25): error CS9071: The namespace '<global namespace>' already contains a definition for 'R' in this file.
            // file explicit extension R for S { }
            Diagnostic(ErrorCode.ERR_FileLocalDuplicateNameInNS, "R").WithArguments("R", "<global namespace>").WithLocation(3, 25),
            // (8,24): error CS0102: The type 'C' already contains a definition for 'R2'
            //     explicit extension R2 for S { }
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "R2").WithArguments("C", "R2").WithLocation(8, 24)
            );
    }

    [Fact]
    public void Modifiers_File_DuplicateName_SeparateFiles()
    {
        var src1 = """
struct S { }
file explicit extension R for S { }

partial class C
{
    explicit extension R2 for S { }
}
""";
        var src2 = """
file explicit extension R for S { }

partial class C
{
    explicit extension R2 for S { }
}
""";
        var comp = CreateCompilation(new[] { (src1, "1.cs"), (src2, "2.cs") });
        comp.VerifyDiagnostics(
            // 2.cs(5,24): error CS0102: The type 'C' already contains a definition for 'R2'
            //     explicit extension R2 for S { }
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "R2").WithArguments("C", "R2").WithLocation(5, 24)
            );
    }

    [Fact]
    public void Modifiers_Duplicate()
    {
        var src = """
class UnderlyingClass { }
internal internal explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,10): error CS1004: Duplicate 'internal' modifier
            // internal internal explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_DuplicateModifier, "internal").WithArguments("internal").WithLocation(2, 10)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal(Accessibility.Internal, r.DeclaredAccessibility);
    }

    [Fact]
    public void Modifiers_IncompatibleAccessibilities()
    {
        var src = """
class UnderlyingClass { }
public internal explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,36): error CS0107: More than one protection modifier
            // public internal explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_BadMemberProtection, "R").WithLocation(2, 36),
            // (2,36): error CS9309: Inconsistent accessibility: underlying type 'UnderlyingClass' is less accessible than extension 'R'
            // public internal explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_BadVisUnderlyingType, "R").WithArguments("R", "UnderlyingClass").WithLocation(2, 36)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal(Accessibility.Public, r.DeclaredAccessibility);
    }

    [Fact]
    public void Modifiers_IncompatibleAccessibilities_ReverseOrder()
    {
        var src = """
class UnderlyingClass { }
internal public explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,36): error CS0107: More than one protection modifier
            // internal public explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_BadMemberProtection, "R").WithLocation(2, 36),
            // (2,36): error CS9309: Inconsistent accessibility: underlying type 'UnderlyingClass' is less accessible than extension 'R'
            // internal public explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_BadVisUnderlyingType, "R").WithArguments("R", "UnderlyingClass").WithLocation(2, 36)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal(Accessibility.Public, r.DeclaredAccessibility);
    }

    [Fact]
    public void Modifiers_Abstract()
    {
        var src = """
class UnderlyingClass { }
abstract explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,29): error CS0106: The modifier 'abstract' is not valid for this item
            // abstract explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "R").WithArguments("abstract").WithLocation(2, 29)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
        Assert.Equal("UnderlyingClass", r.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
    }

    [Fact]
    public void Modifiers_Readonly()
    {
        var src = """
class UnderlyingClass { }
readonly explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,29): error CS0106: The modifier 'readonly' is not valid for this item
            // readonly explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "R").WithArguments("readonly").WithLocation(2, 29)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
    }

    [Fact]
    public void Modifiers_Const()
    {
        var src = """
class UnderlyingClass { }
const explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,1): error CS8803: Top-level statements must precede namespace and type declarations.
            // const explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_TopLevelStatementAfterNamespaceOrType, "const ").WithLocation(2, 1),
            // (2,7): error CS1031: Type expected
            // const explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_TypeExpected, "explicit").WithLocation(2, 7),
            // (2,7): error CS1001: Identifier expected
            // const explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_IdentifierExpected, "explicit").WithLocation(2, 7),
            // (2,7): error CS0145: A const field requires a value to be provided
            // const explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_ConstValueRequired, "explicit").WithLocation(2, 7),
            // (2,7): error CS1002: ; expected
            // const explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_SemicolonExpected, "explicit").WithLocation(2, 7)
            );
    }

    [Fact]
    public void Modifiers_Volatile()
    {
        var src = """
class UnderlyingClass { }
volatile explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,29): error CS0106: The modifier 'volatile' is not valid for this item
            // volatile explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "R").WithArguments("volatile").WithLocation(2, 29)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
    }

    [Fact]
    public void Modifiers_Extern()
    {
        var src = """
class UnderlyingClass { }
extern explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,27): error CS0106: The modifier 'extern' is not valid for this item
            // extern explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "R").WithArguments("extern").WithLocation(2, 27)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
    }

    [Fact]
    public void Modifiers_Fixed()
    {
        var src = """
class UnderlyingClass { }
fixed explicit extension R for UnderlyingClass { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,7): error CS1031: Type expected
            // fixed explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_TypeExpected, "explicit").WithLocation(2, 7),
            // (2,7): error CS1001: Identifier expected
            // fixed explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_IdentifierExpected, "explicit").WithLocation(2, 7),
            // (2,7): error CS1003: Syntax error, '[' expected
            // fixed explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_SyntaxError, "explicit").WithArguments("[").WithLocation(2, 7),
            // (2,7): error CS1003: Syntax error, ']' expected
            // fixed explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_SyntaxError, "explicit").WithArguments("]").WithLocation(2, 7),
            // (2,7): error CS0443: Syntax error; value expected
            // fixed explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_ValueExpected, "explicit").WithLocation(2, 7),
            // (2,7): error CS1002: ; expected
            // fixed explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_SemicolonExpected, "explicit").WithLocation(2, 7),
            // (2,7): error CS1642: Fixed size buffer fields may only be members of structs
            // fixed explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_FixedNotInStruct, "").WithLocation(2, 7),
            // (2,7): error CS1663: Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double
            // fixed explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_IllegalFixedType, "").WithLocation(2, 7),
            // (2,7): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            // fixed explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "").WithLocation(2, 7)
            );
    }

    [Fact]
    public void Modifiers_Virtual()
    {
        var src = """
class UnderlyingClass { }
virtual explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,28): error CS0106: The modifier 'virtual' is not valid for this item
            // virtual explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "R").WithArguments("virtual").WithLocation(2, 28)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
    }

    [Fact]
    public void Modifiers_Override()
    {
        var src = """
class UnderlyingClass { }
override explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,29): error CS0106: The modifier 'override' is not valid for this item
            // override explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "R").WithArguments("override").WithLocation(2, 29)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
    }

    [Fact]
    public void Modifiers_Async()
    {
        var src = """
class UnderlyingClass { }
async explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,26): error CS0106: The modifier 'async' is not valid for this item
            // async explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "R").WithArguments("async").WithLocation(2, 26)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
    }

    [Fact]
    public void Modifiers_Ref()
    {
        var src = """
class UnderlyingClass { }
ref explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,5): error CS1031: Type expected
            // ref explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_TypeExpected, "explicit").WithLocation(2, 5)
            );
    }

    [Fact]
    public void Modifiers_Required()
    {
        var src = """
class UnderlyingClass { }
required explicit extension R for UnderlyingClass
{
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,29): error CS0106: The modifier 'required' is not valid for this item
            // required explicit extension R for UnderlyingClass
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "R").WithArguments("required").WithLocation(2, 29)
            );
        var r = comp.GlobalNamespace.GetTypeMember("R");
        VerifyExtension<SourceExtensionTypeSymbol>(r, isExplicit: true);
    }

    [Fact]
    public void Modifiers_Scoped()
    {
        var src = """
class UnderlyingClass { }
scoped explicit extension R for UnderlyingClass { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,1): error CS1553: Declaration is not valid; use '+ operator <dest-type> (...' instead
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_BadOperatorSyntax, "scoped").WithArguments("+").WithLocation(2, 1),
            // (2,1): error CS0246: The type or namespace name 'scoped' could not be found (are you missing a using directive or an assembly reference?)
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "scoped").WithArguments("scoped").WithLocation(2, 1),
            // (2,8): error CS1003: Syntax error, 'operator' expected
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_SyntaxError, "explicit").WithArguments("operator").WithLocation(2, 8),
            // (2,8): error CS1020: Overloadable binary operator expected
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_OvlBinaryOperatorExpected, "explicit").WithLocation(2, 8),
            // (2,8): error CS0558: User-defined operator '<invalid-global-code>.operator +(extension, UnderlyingClass)' must be declared static and public
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_OperatorsMustBeStatic, "").WithArguments("<invalid-global-code>.operator +(extension, UnderlyingClass)").WithLocation(2, 8),
            // (2,8): error CS0501: '<invalid-global-code>.operator +(extension, UnderlyingClass)' must declare a body because it is not marked abstract, extern, or partial
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_ConcreteMissingBody, "").WithArguments("<invalid-global-code>.operator +(extension, UnderlyingClass)").WithLocation(2, 8),
            // (2,8): error CS0563: One of the parameters of a binary operator must be the containing type
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_BadBinaryOperatorSignature, "").WithLocation(2, 8),
            // (2,17): error CS1003: Syntax error, '(' expected
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_SyntaxError, "extension").WithArguments("(").WithLocation(2, 17),
            // (2,17): error CS0246: The type or namespace name 'extension' could not be found (are you missing a using directive or an assembly reference?)
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "extension").WithArguments("extension").WithLocation(2, 17),
            // (2,29): error CS1003: Syntax error, ',' expected
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_SyntaxError, "for").WithArguments(",").WithLocation(2, 29),
            // (2,33): error CS1003: Syntax error, ',' expected
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_SyntaxError, "UnderlyingClass").WithArguments(",").WithLocation(2, 33),
            // (2,49): error CS1001: Identifier expected
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_IdentifierExpected, "{").WithLocation(2, 49),
            // (2,49): error CS1003: Syntax error, ',' expected
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_SyntaxError, "{").WithArguments(",").WithLocation(2, 49),
            // (2,51): error CS1026: ) expected
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_CloseParenExpected, "}").WithLocation(2, 51),
            // (2,51): error CS1002: ; expected
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_SemicolonExpected, "}").WithLocation(2, 51),
            // (2,51): error CS1022: Type or namespace definition, or end-of-file expected
            // scoped explicit extension R for UnderlyingClass { }
            Diagnostic(ErrorCode.ERR_EOFExpected, "}").WithLocation(2, 51)
            );
    }

    [Theory]
    [InlineData("int")]
    [InlineData("string")]
    [InlineData("T")]
    public void NotExtension_ArrayTypeSymbol(string type)
    {
        var src = $$"""
class C<T>
{
    {{type}}[] M() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var m = comp.GetMember<MethodSymbol>("C.M");
        VerifyNotExtension<ArrayTypeSymbol>(m.ReturnType);
    }

    [Fact]
    public void NotExtension_DynamicTypeSymbol()
    {
        var src = $$"""
class C
{
    dynamic M() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var m = comp.GetMember<MethodSymbol>("C.M");
        VerifyNotExtension<DynamicTypeSymbol>(m.ReturnType);
    }

    [Fact]
    public void NotExtension_AnonymousTypeSymbol()
    {
        var src = $$"""
class C
{
    void M()
    {
        var a = new { A = 1 };
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var variableDeclarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        var variable = model.GetDeclaredSymbol(variableDeclarator);
        var publicType = (Symbols.PublicModel.NonErrorNamedTypeSymbol)variable.GetTypeOrReturnType();
        VerifyNotExtension<AnonymousTypeManager.AnonymousTypePublicSymbol>(publicType.UnderlyingNamedTypeSymbol);
    }

    [Fact]
    public void NotExtension_ErrorTypeSymbol()
    {
        var src = $$"""
class C
{
    error M() => throw null;
}
""";
        var comp = CreateCompilation(src);
        var m = comp.GetMember<MethodSymbol>("C.M");
        VerifyNotExtension<ErrorTypeSymbol>(m.ReturnType);
    }

    [Fact]
    public void NotExtension_FunctionTypeSymbol()
    {
        var src = $$"""
delegate void M();
""";
        var comp = CreateCompilation(src);
        var m = comp.GetMember<NamedTypeSymbol>("M");
        var functionType = new FunctionTypeSymbol(m);
        VerifyNotExtension<FunctionTypeSymbol>(functionType);
    }

    [Fact]
    public void NotExtension_NativeIntegerTypeSymbol()
    {
        var src = $$"""
class C
{
    nint M() => throw null;
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net60);
        var m = comp.GetMember<MethodSymbol>("C.M");
        VerifyNotExtension<NativeIntegerTypeSymbol>(m.ReturnType);
    }

    [Fact]
    public void NotExtension_NativeIntegerTypeSymbol_Custom()
    {
        var src = $$"""
namespace System
{
    public class Object { }
    public struct Void { }
    public struct Boolean { }
    public struct Int32 { }
    public class String { }
    public class Exception { }
    public class ValueType { }
    public class Enum { }
    public class Attribute { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets t) { }
        public bool AllowMultiple { get; set; }
        public bool Inherited { get; set; }
    }
    public enum AttributeTargets { All = 32767, }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute() { }
        public ObsoleteAttribute(string message) { }
        public ObsoleteAttribute(string message, bool error) { }

        public string DiagnosticId { get; set; }
        public string UrlFormat { get; set; }
    }
    public explicit extension IntPtr for object { }
}
class C
{
    nint M() => throw null;
}
""";
        var comp = CreateEmptyCompilation(new[] { src, CompilerFeatureRequiredAttribute });
        comp.VerifyDiagnostics(
            // 0.cs(32,5): error CS0518: Predefined type 'IntPtr' is not defined or imported
            //     nint M() => throw null;
            Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "nint").WithArguments("IntPtr").WithLocation(32, 5)
            );
        var m = comp.GetMember<MethodSymbol>("C.M");
        VerifyNotExtension<MissingMetadataTypeSymbol.TopLevel>(m.ReturnType);
        Assert.True(comp.GetSpecialType(SpecialType.System_IntPtr).IsErrorType());

        var intPtr = comp.GetTypeByMetadataName("System.IntPtr");
        VerifyExtension<SourceExtensionTypeSymbol>(intPtr, isExplicit: true, SpecialType.System_IntPtr);
    }

    [Fact]
    public void NotExtension_Tuple_Custom()
    {
        var src = $$"""
namespace System
{
    public class Object { }
    public struct Void { }
    public struct Boolean { }
    public struct Int32 { }
    public class String { }
    public class Exception { }
    public class ValueType { }
    public explicit extension ValueTuple<T1, T2> for object { }
    public class Enum { }
    public class Attribute { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets t) { }
        public bool AllowMultiple { get; set; }
        public bool Inherited { get; set; }
    }
    public enum AttributeTargets { All = 32767, }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute() { }
        public ObsoleteAttribute(string message) { }
        public ObsoleteAttribute(string message, bool error) { }

        public string DiagnosticId { get; set; }
        public string UrlFormat { get; set; }
    }
}
class C
{
    (object, object) M() => throw null;
}
""";
        var comp = CreateEmptyCompilation(new[] { src, CompilerFeatureRequiredAttribute });
        comp.VerifyDiagnostics(
            // 0.cs(32,5): error CS8179: Predefined type 'System.ValueTuple`2' is not defined or imported
            //     (object, object) M() => throw null;
            Diagnostic(ErrorCode.ERR_PredefinedValueTupleTypeNotFound, "(object, object)").WithArguments("System.ValueTuple`2").WithLocation(32, 5)
            );
        var m = comp.GetMember<MethodSymbol>("C.M");
        VerifyNotExtension<ConstructedErrorTypeSymbol>(m.ReturnType);
        Assert.True(comp.GetWellKnownType(WellKnownType.System_ValueTuple_T2).IsErrorType());

        var valueTuple = comp.GetTypeByMetadataName("System.ValueTuple`2");
        VerifyExtension<SourceExtensionTypeSymbol>(valueTuple, isExplicit: true);
    }

    [Fact]
    public void NotExtension_PointerTypeSymbol()
    {
        var src = $$"""
unsafe class C
{
    int* M() => throw null;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics();
        var m = comp.GetMember<MethodSymbol>("C.M");
        VerifyNotExtension<PointerTypeSymbol>(m.ReturnType);
    }

    [Fact]
    public void NotExtension_FunctionPointerTypeSymbol()
    {
        var src = $$"""
unsafe class C
{
    delegate*<void> M() => throw null;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics();
        var m = comp.GetMember<MethodSymbol>("C.M");
        VerifyNotExtension<FunctionPointerTypeSymbol>(m.ReturnType);
    }

    [ConditionalTheory(typeof(NoBaseExtensions)), CombinatorialData]
    public void IsExtension_SubstitutedNamedTypeSymbol(bool isExplicit)
    {
        var src = $$"""
{{(isExplicit ? "explicit" : "implicit")}} extension E1<T> for int { }
explicit extension E2 for int : E1<object> { }
""";
        var comp = CreateCompilation(src);
        if (isExplicit)
        {
            comp.VerifyDiagnostics();
            CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        }
        else
        {
            comp.VerifyDiagnostics(
                // (1,20): error CS9328: The underlying type 'int' of implicit extension 'E1<T>' must reference all the type parameters declared by the extension, but type parameter 'T' is missing.
                // implicit extension E1<T> for int { }
                Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E1").WithArguments("int", "E1<T>", "T").WithLocation(1, 20)
                );

            validate(comp.SourceModule);
        }

        return;

        void validate(ModuleSymbol module)
        {
            var e2 = module.GlobalNamespace.GetTypeMember("E2");
            var substE1 = e2.BaseExtensionsNoUseSiteDiagnostics.Single();
            Assert.Equal("E1<object>", substE1.ToDisplayString());
            VerifyExtension<SubstitutedNamedTypeSymbol>(substE1, isExplicit: isExplicit);

            Assert.False(substE1.IsDefinition);
            Assert.Equal("E1<T>", substE1.OriginalDefinition.ToTestDisplayString());
        }
    }

    [Theory, CombinatorialData]
    public void IsExtension_NestedNamedTypeSymbol(bool isExplicit, bool isExplicit2)
    {
        var src = $$"""
{{(isExplicit ? "explicit" : "implicit")}} extension E1 for int
{
    {{(isExplicit2 ? "explicit" : "implicit")}} extension E2 for int { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        void validate(ModuleSymbol module)
        {
            var e2 = module.GlobalNamespace.GetTypeMember("E1").GetTypeMember("E2");
            VerifyExtension<NamedTypeSymbol>(e2.ContainingType, isExplicit: isExplicit);
            VerifyExtension<NamedTypeSymbol>(e2, isExplicit: isExplicit2);
        }
    }

    [ConditionalTheory(typeof(NoBaseExtensions)), CombinatorialData]
    public void IsExtension_Retargeting(bool isExplicit)
    {
        var src = $$"""
public explicit extension E0 for int { }
public {{(isExplicit ? "explicit" : "implicit")}} extension E1 for int : E0 { }
""";
        var comp1 = CreateCompilation(new[] { src, CompilerFeatureRequiredAttribute }, targetFramework: TargetFramework.Mscorlib40);
        comp1.VerifyDiagnostics();

        var src2 = """
explicit extension E2 for int : E1 { }
""";

        var comp2 = CreateCompilation(src2, references: new[] { comp1.ToMetadataReference() }, targetFramework: TargetFramework.Mscorlib46);
        comp2.VerifyDiagnostics();

        var e1 = comp2.GlobalNamespace.GetTypeMember("E1");
        VerifyExtension<RetargetingNamedTypeSymbol>(e1, isExplicit: isExplicit);
        Assert.Equal("System.Int32", e1.GetExtendedTypeNoUseSiteDiagnostics(null).ToTestDisplayString());
        Assert.Equal(new[] { "E0" }, e1.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
    }

    [Fact]
    public void NotExtension_Retargeting()
    {
        var src = $$"""
class C { }
""";
        var comp1 = CreateCompilation(new[] { src, CompilerFeatureRequiredAttribute }, targetFramework: TargetFramework.Mscorlib40);
        comp1.VerifyDiagnostics();

        var comp2 = CreateCompilation("", references: new[] { comp1.ToMetadataReference() }, targetFramework: TargetFramework.Mscorlib46);
        var c = comp2.GlobalNamespace.GetTypeMember("C");
        VerifyNotExtension<RetargetingNamedTypeSymbol>(c);
        Assert.Null(c.GetExtendedTypeNoUseSiteDiagnostics(null));
        Assert.Empty(c.BaseExtensionsNoUseSiteDiagnostics);
    }

    [Fact]
    public void NotExtension_TypeParameterSymbol()
    {
        var src = $$"""
class C<T>
{
    T M() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        var m = comp.GetMember<MethodSymbol>("C.M");
        VerifyNotExtension<TypeParameterSymbol>(m.ReturnType);
    }

    [Fact]
    public void NotExtension_TypeParameterSymbol_ExtensionConstraintDisallowed()
    {
        var src = $$"""
explicit extension R for string { }
class C<T> where T : R
{
    T M() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,22): error CS0706: Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
            // class C<T> where T : R
            Diagnostic(ErrorCode.ERR_BadConstraintType, "R").WithLocation(2, 22)
            );
        var m = comp.GetMember<MethodSymbol>("C.M");
        VerifyNotExtension<TypeParameterSymbol>(m.ReturnType);
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void NotExtension_TypeParameterSymbol_ViaSubstitution()
    {
        var src = $$"""
public explicit extension R for string { }
public explicit extension R2 for string : R { }

public class Container<T>
{
    public class C<U> where U : T
    {
        T M() => throw null;
    }
}
class C2
{
    Container<R> M2() => throw null;
    void M3(Container<R>.C<R> cr, Container<R>.C<R2> cr2) { }
}
""";
        // PROTOTYPE the diagnostic will disappear once we have an identity between R and R2
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (14,54): error CS0315: The type 'R2' cannot be used as type parameter 'U' in the generic type or method 'Container<R>.C<U>'. There is no boxing conversion from 'R2' to 'R'.
            //     void M3(Container<R>.C<R> cr, Container<R>.C<R2> cr2) { }
            Diagnostic(ErrorCode.ERR_GenericConstraintNotSatisfiedValType, "cr2").WithArguments("Container<R>.C<U>", "R", "U", "R2").WithLocation(14, 54)
            );
        var containerR = comp.GetMember<MethodSymbol>("C2.M2").ReturnType;
        var c = containerR.GetTypeMembers().Single();
        Assert.Equal("Container<R>.C<U>", c.ToTestDisplayString());
        VerifyNotExtension<SubstitutedTypeParameterSymbol>(c.TypeParameters.Single());
    }

    [Fact]
    public void ArrayTypeConstraintViaSubstitution()
    {
        var src = $$"""
public class Container<T>
{
    public class C<U> where U : T
    {
        T M() => throw null;
    }
}
class C2
{
    Container<int[]> M2() => throw null;
    void M3(Container<int[]>.C<int[]> c, Container<int[]>.C<byte[]> c2, Container<int[]>.C<long[]> c3) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (11,69): error CS0311: The type 'byte[]' cannot be used as type parameter 'U' in the generic type or method 'Container<int[]>.C<U>'. There is no implicit reference conversion from 'byte[]' to 'int[]'.
            //     void M3(Container<int[]>.C<int[]> c, Container<int[]>.C<byte[]> c2, Container<int[]>.C<long[]> c3) { }
            Diagnostic(ErrorCode.ERR_GenericConstraintNotSatisfiedRefType, "c2").WithArguments("Container<int[]>.C<U>", "int[]", "U", "byte[]").WithLocation(11, 69),
            // (11,100): error CS0311: The type 'long[]' cannot be used as type parameter 'U' in the generic type or method 'Container<int[]>.C<U>'. There is no implicit reference conversion from 'long[]' to 'int[]'.
            //     void M3(Container<int[]>.C<int[]> c, Container<int[]>.C<byte[]> c2, Container<int[]>.C<long[]> c3) { }
            Diagnostic(ErrorCode.ERR_GenericConstraintNotSatisfiedRefType, "c3").WithArguments("Container<int[]>.C<U>", "int[]", "U", "long[]").WithLocation(11, 100)
            );
        var containerR = comp.GetMember<MethodSymbol>("C2.M2").ReturnType;
        var c = containerR.GetTypeMembers().Single();
        Assert.Equal("Container<System.Int32[]>.C<U>", c.ToTestDisplayString());
        var substitutedTypeParameter = c.TypeParameters.Single();
        Assert.False(substitutedTypeParameter.IsArray());
    }

    [Fact]
    public void Attributes()
    {
        var src = """
class MyAttribute : System.Attribute { }
class C { }

[My]
explicit extension R for C
{
    [My] void M() { }
}
""";
        // PROTOTYPE what attribute target should be used for extensions?
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,2): error CS0592: Attribute 'My' is not valid on this declaration type. It is only valid on 'assembly, module, class, struct, enum, constructor, method, property, indexer, field, event, interface, parameter, delegate, return, type parameter' declarations.
            // [My]
            Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "My").WithArguments("My", "assembly, module, class, struct, enum, constructor, method, property, indexer, field, event, interface, parameter, delegate, return, type parameter").WithLocation(4, 2)
            );

        var r = comp.GlobalNamespace.GetTypeMember("R");
        Assert.Equal("MyAttribute", r.GetAttributes().Single().ToString());

        var m = r.GetMethod("M");
        Assert.Equal("MyAttribute", m.GetAttributes().Single().ToString());
    }

    [Fact]
    public void ReservedTypeNames()
    {
        var src = $$"""
class C { }

explicit extension record for C { }
explicit extension file for C { }
explicit extension required for C { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,20): warning CS8860: Types and aliases should not be named 'record'.
            // explicit extension record for C { }
            Diagnostic(ErrorCode.WRN_RecordNamedDisallowed, "record").WithLocation(3, 20),
            // (4,20): error CS9056: Types and aliases cannot be named 'file'.
            // explicit extension file for C { }
            Diagnostic(ErrorCode.ERR_FileTypeNameDisallowed, "file").WithLocation(4, 20),
            // (5,20): error CS9029: Types and aliases cannot be named 'required'.
            // explicit extension required for C { }
            Diagnostic(ErrorCode.ERR_RequiredNameDisallowed, "required").WithLocation(5, 20)
            );
    }

    [Fact]
    public void ReservedTypeNames_Keyword()
    {
        var text = """explicit extension unsafe for var { }""";
        var comp = CreateCompilation(text);
        comp.VerifyDiagnostics(
            // (1,20): error CS1001: Identifier expected
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_IdentifierExpected, "unsafe").WithLocation(1, 20),
            // (1,20): error CS1514: { expected
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_LbraceExpected, "unsafe").WithLocation(1, 20),
            // (1,20): error CS1513: } expected
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_RbraceExpected, "unsafe").WithLocation(1, 20),
            // (1,20): error CS0116: A namespace cannot directly contain members such as fields, methods or statements
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_NamespaceUnexpected, "unsafe").WithLocation(1, 20),
            // (1,20): error CS9314: No part of a partial extension '' includes an underlying type specification.
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_ExtensionMissingUnderlyingType, "").WithArguments("").WithLocation(1, 20),
            // (1,27): error CS8803: Top-level statements must precede namespace and type declarations.
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_TopLevelStatementAfterNamespaceOrType, "for var { }").WithLocation(1, 27),
            // (1,31): error CS1003: Syntax error, '(' expected
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_SyntaxError, "var").WithArguments("(").WithLocation(1, 31),
            // (1,31): error CS0103: The name 'var' does not exist in the current context
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_NameNotInContext, "var").WithArguments("var").WithLocation(1, 31),
            // (1,31): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_IllegalStatement, "var").WithLocation(1, 31),
            // (1,35): error CS1002: ; expected
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_SemicolonExpected, "{").WithLocation(1, 35),
            // (1,35): error CS1525: Invalid expression term '{'
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_InvalidExprTerm, "{").WithArguments("{").WithLocation(1, 35),
            // (1,35): error CS1002: ; expected
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_SemicolonExpected, "{").WithLocation(1, 35),
            // (1,35): error CS1026: ) expected
            // explicit extension unsafe for var { }
            Diagnostic(ErrorCode.ERR_CloseParenExpected, "{").WithLocation(1, 35)
            );
    }

    [Fact]
    public void Entrypoint_Implicit()
    {
        var src = $$"""
class C { }

explicit extension R for C
{
    public static void Main()
    {
        System.Console.Write("hello");
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics();
        Assert.Equal("void R.Main()", comp.GetEntryPoint(cancellationToken: default).ToTestDisplayString());
        // PROTOTYPE confirm we want this and verify execution
    }

    [Fact]
    public void Entrypoint_Explicit()
    {
        string source = @"
class C { }

explicit extension R for C
{
    static void Main() { }
}
";
        var compilation = CreateCompilation(source, options: TestOptions.ReleaseExe.WithMainTypeName("R"));
        compilation.VerifyDiagnostics(
            // (4,20): error CS1556: 'R' specified for Main method must be a non-generic class, record, struct, or interface
            // explicit extension R for C
            Diagnostic(ErrorCode.ERR_MainClassNotClass, "R").WithArguments("R").WithLocation(4, 20)
            );
        // PROTOTYPE confirm whether we want this
    }

    [Fact]
    public void Partial_PartialMisplaced()
    {
        string source = @"
public class C { }

partial public explicit extension R for C { }
";
        var compilation = CreateCompilation(source);
        compilation.VerifyDiagnostics(
            // (4,1): error CS0267: The 'partial' modifier can only appear immediately before 'class', 'record', 'struct', 'interface', 'implicit/explicit extension', or a method return type.
            // partial public explicit extension R for C { }
            Diagnostic(ErrorCode.ERR_PartialMisplaced, "partial").WithLocation(4, 1)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void SuppressConstraintChecksInitially()
    {
        var text = @"
public class C { }

public explicit extension R1<T> for C where T : C { }
public explicit extension R2<T> for C : R1<R2<T>> { }
";
        var comp = CreateCompilation(text);
        comp.VerifyDiagnostics(
            // (5,27): error CS0315: The type 'R2<T>' cannot be used as type parameter 'T' in the generic type or method 'R1<T>'. There is no boxing conversion from 'R2<T>' to 'C'.
            // public explicit extension R2<T> for C : R1<R2<T>> { }
            Diagnostic(ErrorCode.ERR_GenericConstraintNotSatisfiedValType, "R2").WithArguments("R1<T>", "C", "T", "R2<T>").WithLocation(5, 27)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void SuppressConstraintChecksInitially_PointerAsTypeArgument()
    {
        var text = @"
public class C { }

public explicit extension R1<T> for C { }
public unsafe explicit extension R2<T> for C : R1<int*> { }
";
        var comp = CreateCompilation(text, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (5,34): error CS0306: The type 'int*' may not be used as a type argument
            // public unsafe explicit extension R2<T> for C : R1<int*> { }
            Diagnostic(ErrorCode.ERR_BadTypeArgument, "R2").WithArguments("int*").WithLocation(5, 34)
            );
    }

    [Fact]
    public void ImplicitAndExplicit()
    {
        var text = """implicit explicit extension R for var { }""";

        var comp = CreateCompilation(text);
        comp.VerifyDiagnostics(
            // (1,10): error CS1003: Syntax error, 'operator' expected
            // implicit explicit extension R for var { }
            Diagnostic(ErrorCode.ERR_SyntaxError, "explicit").WithArguments("operator").WithLocation(1, 10),
            // (1,10): error CS1031: Type expected
            // implicit explicit extension R for var { }
            Diagnostic(ErrorCode.ERR_TypeExpected, "explicit").WithLocation(1, 10),
            // (1,10): error CS1003: Syntax error, '(' expected
            // implicit explicit extension R for var { }
            Diagnostic(ErrorCode.ERR_SyntaxError, "explicit").WithArguments("(").WithLocation(1, 10),
            // (1,10): error CS1026: ) expected
            // implicit explicit extension R for var { }
            Diagnostic(ErrorCode.ERR_CloseParenExpected, "explicit").WithLocation(1, 10),
            // (1,10): error CS1002: ; expected
            // implicit explicit extension R for var { }
            Diagnostic(ErrorCode.ERR_SemicolonExpected, "explicit").WithLocation(1, 10),
            // (1,10): error CS0558: User-defined operator '<invalid-global-code>.implicit operator ?()' must be declared static and public
            // implicit explicit extension R for var { }
            Diagnostic(ErrorCode.ERR_OperatorsMustBeStatic, "").WithArguments("<invalid-global-code>.implicit operator ?()").WithLocation(1, 10),
            // (1,10): error CS0501: '<invalid-global-code>.implicit operator ?()' must declare a body because it is not marked abstract, extern, or partial
            // implicit explicit extension R for var { }
            Diagnostic(ErrorCode.ERR_ConcreteMissingBody, "").WithArguments("<invalid-global-code>.implicit operator ?()").WithLocation(1, 10),
            // (1,10): error CS1019: Overloadable unary operator expected
            // implicit explicit extension R for var { }
            Diagnostic(ErrorCode.ERR_OvlUnaryOperatorExpected, "").WithLocation(1, 10),
            // (1,35): error CS0825: The contextual keyword 'var' may only appear within a local variable declaration or in script code
            // implicit explicit extension R for var { }
            Diagnostic(ErrorCode.ERR_TypeVarNotFound, "var").WithLocation(1, 35)
            );
    }

    private string ExtensionMarkerName(bool isExplicit)
    {
        return isExplicit ? "<ExplicitExtension>$" : "<ImplicitExtension>$";
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_Baseline(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Theory]
    [InlineData("private")]
    [InlineData("family")]
    [InlineData("assembly")]
    public void ExtensionMarkerMethod_NotPublicMethod(string methodAccessibility)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method {{methodAccessibility}} hidebysig static void '{{ExtensionMarkerName(false)}}'(object '') cil managed
    {
        IL_0000: ret
    }

    .method public hidebysig static void M () cil managed 
    {
        IL_0000: ret
    }
}
""";

        var src = """
object.M();
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'M'
            // object.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(1, 8));

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: false);
        Assert.True(r1.GetExtendedTypeNoUseSiteDiagnostics(null).IsErrorType());
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_NotByValueParameter(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object& '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);
        var r1ExtendedType = r1.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.Equal("System.Object", r1ExtendedType.ToTestDisplayString());
        Assert.True(r1ExtendedType.IsErrorType());

        if (new NoBaseExtensions().ShouldSkip) return;

        // PROTOTYPE should have an error like "Extension marker method on type '...' is malformed" instead
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends 'Object'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "System.Object").WithLocation(1, 27)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_WithModoptOnReturn(bool isExplicit)
    {
        // PROTOTYPE consider allowing modopts in extension marker methods
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method private hidebysig static void modopt(object) '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);

        if (new NoBaseExtensions().ShouldSkip) return;

        // PROTOTYPE should have an error like "Extension marker method on type '...' is malformed" instead (if we keep an error)
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends '?'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "?").WithLocation(1, 27)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_WithModreqOnReturn(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method private hidebysig static void modreq(object) '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);

        if (new NoBaseExtensions().ShouldSkip) return;

        // PROTOTYPE should have an error like "Extension marker method on type '...' is malformed" instead
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends '?'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "?").WithLocation(1, 27)
            );
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_WithModoptOnFirstParameter(bool isExplicit)
    {
        // PROTOTYPE consider allowing modopts in extension marker methods
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object modopt(object) '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);
        var r1ExtendedType = r1.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.Equal("System.Object", r1ExtendedType.ToTestDisplayString());
        Assert.True(r1ExtendedType.IsErrorType());

        if (new NoBaseExtensions().ShouldSkip) return;

        // PROTOTYPE should have an error like "Extension marker method on type '...' is malformed" instead (if we keep an error)
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends 'Object'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "System.Object").WithLocation(1, 27)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_WithModreqOnFirstParameter(bool isExplicit)
    {
        // PROTOTYPE consider allowing modopts in extension marker methods
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object modreq(object) '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);
        var r1ExtendedType = (ExtendedErrorTypeSymbol)r1.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.Equal("System.Object", r1ExtendedType.ToTestDisplayString());
        Assert.True(r1ExtendedType.IsErrorType());
        AssertEx.Equal("error CS9322: Extension marker method on type 'R1' is malformed.", r1ExtendedType.ErrorInfo.ToString());

        if (new NoBaseExtensions().ShouldSkip) return;

        // PROTOTYPE should have an error like "Extension marker method on type '...' is malformed" instead
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends 'Object'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "System.Object").WithLocation(1, 27)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_WithModoptOnSecondParameter(bool isExplicit)
    {
        // PROTOTYPE consider allowing modopts in extension marker methods
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        IL_0000: ret
    }
}

.class public sequential ansi sealed beforefieldinit R2
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object '', valuetype R2 modopt(object) '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R3 for object : R2 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R3 for object : R2 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R2").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);

        if (new NoBaseExtensions().ShouldSkip) return;

        comp.VerifyDiagnostics(
            // (1,27): error CS9322: Extension marker method on type 'R2' is malformed.
            // public explicit extension R3 for object : R2 { }
            Diagnostic(ErrorCode.ERR_MalformedExtensionInMetadata, "R3").WithArguments("R2").WithLocation(1, 27)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<PENamedTypeSymbol>(r2, isExplicit: isExplicit);
        var r2BaseExtension = r2.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("R2", r2BaseExtension.ToTestDisplayString());
        Assert.True(r2BaseExtension.IsErrorType());

        var r3 = comp.GlobalNamespace.GetTypeMember("R3");
        VerifyExtension<SourceExtensionTypeSymbol>(r3, isExplicit: true);
    }

    [Fact]
    public void ExtensionMarkerMethod_Missing()
    {
        var ilSource = """
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyNotExtension<PENamedTypeSymbol>(r1);

        if (new NoBaseExtensions().ShouldSkip) return;

        comp.VerifyDiagnostics(
            // (1,43): error CS9307: A base extension must be an extension type.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "R1").WithLocation(1, 43)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_Overloaded(bool isExplicit)
    {
        // A mix between `extension R1 for object { }` and `extension R1 for string { }`
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        IL_0000: ret
    }
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(string '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyNotExtension<PENamedTypeSymbol>(r1);

        if (!new NoBaseExtensions().ShouldSkip)
        {
            comp.VerifyDiagnostics(
                // (1,43): error CS9307: A base extension must be an extension type.
                // public explicit extension R2 for object : R1 { }
                Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "R1").WithLocation(1, 43)
                );

            var r2 = comp.GlobalNamespace.GetTypeMember("R2");
            VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
        }

        comp = CreateCompilationWithIL(src, ilSource,
            options: TestOptions.ReleaseDll.WithMetadataImportOptions(MetadataImportOptions.All));

        Assert.Equal(new[]
            {
                "R1..ctor()",
                $$"""void R1.{{ExtensionMarkerName(isExplicit)}}(System.Object A_0)""",
                $$"""void R1.{{ExtensionMarkerName(isExplicit)}}(System.String A_0)"""
            },
            comp.GlobalNamespace.GetTypeMember("R1").GetMembers().ToTestDisplayStrings());
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_Overloaded_DifferentExplicitness(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        IL_0000: ret
    }
    .method public hidebysig static void '{{ExtensionMarkerName(!isExplicit)}}'(string '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyNotExtension<PENamedTypeSymbol>(r1);

        if (!new NoBaseExtensions().ShouldSkip)
        {
            comp.VerifyDiagnostics(
                // (1,43): error CS9307: A base extension must be an extension type.
                // public explicit extension R2 for object : R1 { }
                Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "R1").WithLocation(1, 43)
                );

            var r2 = comp.GlobalNamespace.GetTypeMember("R2");
            VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
        }

        comp = CreateCompilationWithIL(src, ilSource,
            options: TestOptions.ReleaseDll.WithMetadataImportOptions(MetadataImportOptions.All));

        Assert.Equal(new[]
            {
                "R1..ctor()",
                $$"""void R1.{{ExtensionMarkerName(isExplicit)}}(System.Object A_0)""",
                $$"""void R1.{{ExtensionMarkerName(!isExplicit)}}(System.String A_0)"""
            },
            comp.GlobalNamespace.GetTypeMember("R1").GetMembers().ToTestDisplayStrings());
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_ExtensionMethod(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = ( 01 00 00 00)
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = ( 01 00 00 00 )
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
static class OtherExtension
{
    public static void M(this object o) { }
}
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_WithThisParameter(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = ( 01 00 00 01 )
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );
        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_WithDynamicFirstParameter(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        .param [1]
        .custom instance void [mscorlib]System.Runtime.CompilerServices.DynamicAttribute::.ctor() = ( 01 00 00 00 )
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);
        var r1Underyling = r1.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.Equal("dynamic", r1Underyling.ToTestDisplayString());
        Assert.True(r1Underyling.IsErrorType());
        Assert.Empty(r1.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());

        if (new NoBaseExtensions().ShouldSkip) return;

        // PROTOTYPE should have a use-site error too
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends 'dynamic'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "dynamic").WithLocation(1, 27)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_WithExtensionFirstParameter(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R0
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        IL_0000: ret
    }
}

.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(valuetype R0 '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        // PROTOTYPE this test should be updated once we emit erase references to extensions (different metadata format)
        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);
        var r1Underyling = (ExtendedErrorTypeSymbol)r1.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.Equal("R0", r1Underyling.ToTestDisplayString());
        Assert.True(r1Underyling.IsErrorType());
        AssertEx.Equal("error CS9322: Extension marker method on type 'R1' is malformed.", r1Underyling.ErrorInfo.ToString());
        Assert.Empty(r1.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());

        if (new NoBaseExtensions().ShouldSkip) return;

        // PROTOTYPE should have an error like "Extension marker method on type '...' is malformed" instead
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends 'R0'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "R0").WithLocation(1, 27)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Fact]
    public void ExtensionMarkerMethod_WithSelfExtensionFirstParameter()
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: true)}}'(valuetype R1 '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        // PROTOTYPE this test should be updated once we emit erase references to extensions (different metadata format)
        // PROTOTYPE should have a use-site error too
        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: true);
        var r1Underyling = r1.GetExtendedTypeNoUseSiteDiagnostics(null);
        Assert.Equal("R1", r1Underyling.ToTestDisplayString());
        Assert.True(r1Underyling.IsErrorType());
        Assert.Empty(r1.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());

        if (new NoBaseExtensions().ShouldSkip) return;

        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends 'R1'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "R1").WithLocation(1, 27)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void ExtensionMarkerMethod_WithNonExtensionSecondParameter()
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: true)}}'(object '', object '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,27): error CS9322: Extension marker method on type 'R1' is malformed.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_MalformedExtensionInMetadata, "R2").WithArguments("R1").WithLocation(1, 27)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: true);
        var r1BaseExtension = r1.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("System.Object", r1BaseExtension.ToTestDisplayString());
        Assert.True(r1BaseExtension.IsErrorType());

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceNamedTypeSymbol>(r2, isExplicit: true);
        var r2BaseExtension = r2.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("R1", r2BaseExtension.ToTestDisplayString());
        Assert.False(r2BaseExtension.IsErrorType());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void ExtensionMarkerMethod_WithSelfReferentialSecondParameter()
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: true)}}'(object '', valuetype R1 '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        // PROTOTYPE this test should be updated once we emit erase references to extensions (different metadata format)
        var comp = CreateCompilationWithIL(src, ilSource);
        // PROTOTYPE consider a dedicated error message
        comp.VerifyDiagnostics(
            // (1,27): error CS0268: Imported type 'R1' is invalid. It contains a circular base type dependency.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_ImportedCircularBase, "R2").WithArguments("R1").WithLocation(1, 27)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: true);
        var r1BaseExtension = r1.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("R1", r1BaseExtension.ToTestDisplayString());
        Assert.True(r1BaseExtension.IsErrorType());

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
        var r2BaseExtension = r2.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("R1", r2BaseExtension.ToTestDisplayString());
        Assert.False(r2BaseExtension.IsErrorType());
    }

    [Fact]
    public void ExtensionMarkerMethod_WithDuplicateSecondAndThirdParameters()
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: true)}}'(object '') cil managed
    {
        IL_0000: ret
    }
}

.class public sequential ansi sealed beforefieldinit R2
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: true)}}'(object '', valuetype R1 '', valuetype R1 '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R3 for object : R2 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        // PROTOTYPE should we consider duplicate base extensions to be bad metadata?
        // PROTOTYPE this test should be updated once we emit erase references to extensions (different metadata format)
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R3 for object : R2 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R2").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: true);
        Assert.Empty(r1.BaseExtensionsNoUseSiteDiagnostics);

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<PENamedTypeSymbol>(r2, isExplicit: true);

        if (new NoBaseExtensions().ShouldSkip) return;

        Assert.Equal(new[] { "R1", "R1" }, r2.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        Assert.True(r2.BaseExtensionsNoUseSiteDiagnostics.All(b => !b.IsErrorType()));

        var r3 = comp.GlobalNamespace.GetTypeMember("R3");
        VerifyExtension<SourceExtensionTypeSymbol>(r3, isExplicit: true);
        var r3BaseExtensions = r3.BaseExtensionsNoUseSiteDiagnostics;
        Assert.Equal("R2", r3BaseExtensions.Single().ToTestDisplayString());
        Assert.False(r3BaseExtensions.Single().IsErrorType());
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_NotPublic(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method private hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);
        Assert.True(r1.GetExtendedTypeNoUseSiteDiagnostics(null).IsErrorType());

        if (new NoBaseExtensions().ShouldSkip) return;

        // PROTOTYPE should have a use-site error too
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends '?'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "?").WithLocation(1, 27)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_NotStatic(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method private hidebysig void '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);
        Assert.True(r1.GetExtendedTypeNoUseSiteDiagnostics(null).IsErrorType());

        if (new NoBaseExtensions().ShouldSkip) return;

        // PROTOTYPE should have a use-site error too
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends '?'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "?").WithLocation(1, 27)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Fact]
    public void ExtensionMarkerMethod_NotHideBySig()
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public static void '{{ExtensionMarkerName(isExplicit: true)}}'(object '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: true);
        Assert.False(r1.GetExtendedTypeNoUseSiteDiagnostics(null).IsErrorType());

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_NoParameters(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit)}}'() cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);
        Assert.True(r1.GetExtendedTypeNoUseSiteDiagnostics(null).IsErrorType());

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);

        if (new NoBaseExtensions().ShouldSkip) return;

        // PROTOTYPE should have a use-site error too
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends '?'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "?").WithLocation(1, 27)
            );
    }

    [Theory, CombinatorialData]
    public void ExtensionMarkerMethod_NotVoidReturn(bool isExplicit)
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method private hidebysig static int32 '{{ExtensionMarkerName(isExplicit)}}'(object '') cil managed
    {
        IL_0000: ldnull
        IL_0001: throw
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: isExplicit);
        Assert.True(r1.GetExtendedTypeNoUseSiteDiagnostics(null).IsErrorType());

        if (new NoBaseExtensions().ShouldSkip) return;

        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends '?'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "?").WithLocation(1, 27)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [Fact]
    public void ExtensionMarkerMethod_GenericMethod()
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: true)}}'<T>(object '') cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyExtension<PENamedTypeSymbol>(r1, isExplicit: true);

        if (new NoBaseExtensions().ShouldSkip) return;

        // PROTOTYPE should have a use-site error too
        comp.VerifyDiagnostics(
            // (1,27): error CS9316: Extension 'R2' extends 'object' but base extension 'R1' extends '?'.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_UnderlyingTypesMismatch, "R2").WithArguments("R2", "object", "R1", "?").WithLocation(1, 27)
            );

        var r2 = comp.GlobalNamespace.GetTypeMember("R2");
        VerifyExtension<SourceExtensionTypeSymbol>(r2, isExplicit: true);
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_Dynamic_Nested()
    {
        // PROTOTYPE type references to extensions should be emitted with erasure
        var src1 = """
public explicit extension R1<T> for object { }
public explicit extension R2 for object : R1<dynamic> { }
""";

        var comp = CreateCompilation(src1);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            var r2 = module.GlobalNamespace.GetTypeMember("R2");
            Assert.Equal("R1<dynamic>", r2.BaseExtensionsNoUseSiteDiagnostics.Single().ToTestDisplayString());
            Assert.Equal("R1<dynamic>", r2.AllBaseExtensionsNoUseSiteDiagnostics.Single().ToTestDisplayString());
        }
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_Dynamic_Nested_MissingDynamicAttribute()
    {
        var src = """
explicit extension R1<T> for object { }
explicit extension R2 for object : R1<dynamic> { }
""";
        var comp = CreateCompilation(src);
        comp.MakeTypeMissing(WellKnownType.System_Runtime_CompilerServices_DynamicAttribute);
        comp.VerifyDiagnostics(
            // (2,39): error CS1980: Cannot define a class or member that utilizes 'dynamic' because the compiler required type 'System.Runtime.CompilerServices.DynamicAttribute' cannot be found. Are you missing a reference?
            // explicit extension R2 for object : R1<dynamic> { }
            Diagnostic(ErrorCode.ERR_DynamicAttributeMissing, "dynamic").WithArguments("System.Runtime.CompilerServices.DynamicAttribute").WithLocation(2, 39)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_Tuple_Nested()
    {
        // PROTOTYPE type references to extensions should be emitted with erasure
        var src1 = """
public explicit extension R1<T> for object { }
public explicit extension R2 for object : R1<(int a, int b)> { }
""";

        var comp = CreateCompilation(src1);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            var r2 = module.GlobalNamespace.GetTypeMember("R2");
            Assert.Equal("R1<(System.Int32 a, System.Int32 b)>", r2.BaseExtensionsNoUseSiteDiagnostics.Single().ToTestDisplayString());
            Assert.Equal("R1<(System.Int32 a, System.Int32 b)>", r2.AllBaseExtensionsNoUseSiteDiagnostics.Single().ToTestDisplayString());
        }
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_Nullability_Nested()
    {
        // PROTOTYPE type references to extensions should be emitted with erasure
        var src1 = """
#nullable enable
public explicit extension R1<T> for object { }
public explicit extension R2 for object : R1<object?> { }
""";

        var comp = CreateCompilation(src1);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            var r2 = module.GlobalNamespace.GetTypeMember("R2");
            Assert.Equal("R1<System.Object?>", r2.BaseExtensionsNoUseSiteDiagnostics.Single().ToTestDisplayString());
        }
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_Nullability_Nested_MissingNullableAttribute()
    {
        var lib_cs = """
public explicit extension R1<T> for object { }
""";
        var libComp = CreateCompilation(lib_cs);
        libComp.VerifyDiagnostics();

        var src = """
#nullable enable
public explicit extension R2 for object : R1<object?> { }
""";

        var comp = CreateCompilation(src, references: new[] { libComp.EmitToImageReference() });
        comp.MakeTypeMissing(WellKnownType.System_Runtime_CompilerServices_NullableAttribute);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;

            var r2 = module.GlobalNamespace.GetTypeMember("R2");
            Assert.Equal("R1<System.Object?>", r2.BaseExtensionsNoUseSiteDiagnostics.Single().ToTestDisplayString());

            var nullableAttribute = module.ContainingAssembly.GetTypeByMetadataName("System.Runtime.CompilerServices.NullableAttribute");
            Assert.Equal(inSource, nullableAttribute is null);
        }
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_Nullability_Nested_MissingNullableContextAttribute()
    {
        var src1 = """
#nullable enable
public explicit extension R1<T> for object { }
public explicit extension R2 for object : R1<object?> { }
""";

        var comp = CreateCompilation(src1);
        comp.MakeTypeMissing(WellKnownType.System_Runtime_CompilerServices_NullableContextAttribute);
        comp.VerifyDiagnostics();
        var verifier = CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;

            var r2 = module.GlobalNamespace.GetTypeMember("R2");
            Assert.Equal("R1<System.Object?>", r2.BaseExtensionsNoUseSiteDiagnostics.Single().ToTestDisplayString());

            var nullableContextAttribute = module.ContainingAssembly.GetTypeByMetadataName("System.Runtime.CompilerServices.NullableContextAttribute");
            Assert.Equal(inSource, nullableContextAttribute is null);
        }
    }

    [Fact]
    public void GenerateNullableContextAttribute()
    {
        var source = @"
public explicit extension R1 for object
{
#nullable enable
    private object M1() => null!;
    private object M2() => null!;
    private object M3() => null!;
}";
        var comp = CreateCompilation(source, assemblyName: "comp");
        comp.MakeTypeMissing(WellKnownType.System_Runtime_CompilerServices_NullableContextAttribute);

        CompileAndVerify(comp, symbolValidator: module =>
        {
            var attributeType = module.GlobalNamespace.GetMember<NamedTypeSymbol>("System.Runtime.CompilerServices.NullableContextAttribute");
            Assert.NotNull(attributeType);
            Assert.Equal("comp", attributeType.ContainingAssembly.Name);
            AttributeUsageInfo attributeUsage = attributeType.GetAttributeUsageInfo();
            Assert.False(attributeUsage.Inherited);
            Assert.False(attributeUsage.AllowMultiple);
            Assert.True(attributeUsage.HasValidAttributeTargets);
        });
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void BaseExtension_NativeInteger_Nested()
    {
        // PROTOTYPE type references to extensions should be emitted with erasure
        var src1 = """
public explicit extension R1<T> for object { }
public explicit extension R2 for object : R1<nint> { }
""";

        var comp = CreateCompilation(new[] { src1, CompilerFeatureRequiredAttribute });
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);
        return;

        static void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;

            var r2 = module.GlobalNamespace.GetTypeMember("R2");
            Assert.Equal("R1<nint>", r2.BaseExtensionsNoUseSiteDiagnostics.Single().ToTestDisplayString());

            var nativeIntegerAttribute = module.ContainingAssembly.GetTypeByMetadataName("System.Runtime.CompilerServices.NativeIntegerAttribute");
            Assert.Equal(inSource, nativeIntegerAttribute is null);
        }
    }

    [Fact]
    public void BadMember_ExtensionMethod()
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = ( 01 00 00 00)
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: true)}}'(object '') cil managed
    {
        IL_0000: ret
    }
    .method public hidebysig static void M(object '') cil managed
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = ( 01 00 00 00 )
        IL_0000: ret
    }
}
""";

        var src = """
public explicit extension R2 for object : R1 { }
static class OtherExtension
{
    public static void M(this object o) { }
}
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(1, 41)
            );

        var m = comp.GlobalNamespace.GetTypeMember("R1").GetMethod("M");
        Assert.False(m.IsExtensionMethod);
    }

    [Fact]
    public void BadMember_InstanceField()
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: true)}}'(object '') cil managed
    {
        IL_0000: ret
    }
    .field public int32 'field'

    .method public hidebysig static void M () cil managed
    {
        IL_0000: ret
    }
}
""";

        var src = """
object.M();
public explicit extension R2 for object : R1 { }
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'M'
            // object.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(1, 8),
            // (2,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": R1").WithArguments("base extensions").WithLocation(2, 41)
            );

        var r1 = comp.GlobalNamespace.GetTypeMember("R1");
        VerifyNotExtension<PENamedTypeSymbol>(r1);

        if (new NoBaseExtensions().ShouldSkip) return;

        comp.VerifyDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'M'
            // object.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(1, 8),
            // (1,43): error CS9307: A base extension must be an extension type.
            // public explicit extension R2 for object : R1 { }
            Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "R1").WithLocation(1, 43)
            );
    }

    [Fact]
    public void ExtensionMarkerMethodHiddenInMetadata()
    {
        var src = """
public explicit extension R for object { }
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var comp2 = CreateCompilation("", references: new[] { comp.EmitToImageReference() },
            options: TestOptions.ReleaseDll.WithMetadataImportOptions(MetadataImportOptions.All));

        Assert.Empty(comp2.GlobalNamespace.GetTypeMember("R").GetMembers());
    }

    [Fact]
    public void ObsoleteOnType()
    {
        var src1 = """
[System.Obsolete("message", true)]
public explicit extension R for object { }
""";

        var comp = CreateCompilation(src1);
        comp.VerifyDiagnostics(
            // (1,2): error CS0592: Attribute 'System.Obsolete' is not valid on this declaration type. It is only valid on 'class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate' declarations.
            // [System.Obsolete("message")]
            Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "System.Obsolete").WithArguments("System.Obsolete", "class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate").WithLocation(1, 2)
            );
        // PROTOTYPE revisit once attributes are allowed on extension types.
        // The Obsolete poison attribute should not be emitted when the user marked the type as obsolete.
    }

    [Fact]
    public void MemberLookup()
    {
        var src = """
E.M();
_ = E.Property;

public explicit extension E for object
{
    public static void M()
    {
        System.Console.Write("Method ");
    }

    public static int Property
    {
        get
        {
            System.Console.Write("Property");
            return 0;
        }
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "Method Property",
            symbolValidator: validate, sourceSymbolValidator: validate);

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("E.M()", invocation.ToString());
        Assert.Equal("void E.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(1).First();
        Assert.Equal("E.Property", property.ToString());
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());

        AssertSetStrictlyEqual(["E"], model.LookupSymbols(position: 0, name: "E").ToTestDisplayStrings());

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");
        AssertSetStrictlyEqual(["void E.M()"], model.LookupSymbols(position: 0, e, name: "M").ToTestDisplayStrings());

        AssertSetStrictlyEqual(["void E.M()"], model.LookupSymbols(position: 0, e, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["System.Int32 E.Property { get; }"], model.LookupSymbols(position: 0, e, name: "Property").ToTestDisplayStrings());

        AssertSetStrictlyEqual(["System.Int32 E.Property { get; }"],
            model.LookupSymbols(position: 0, e, name: "Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["System.String System.Object.ToString()"], model.LookupSymbols(position: 0, e, name: "ToString").ToTestDisplayStrings());

        AssertSetStrictlyEqual(["System.String System.Object.ToString()"],
            model.LookupSymbols(position: 0, e, name: "ToString", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, o, name: "M").ToTestDisplayStrings());
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, o, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        string[] objectSymbols = [
            "System.String System.Object.ToString()",
            "System.Boolean System.Object.Equals(System.Object obj)",
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Int32 System.Object.GetHashCode()",
            "System.Type System.Object.GetType()",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, o).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, o, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var e = module.GlobalNamespace.GetTypeMember("E");
            Assert.Empty(e.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(e.AllBaseExtensionsNoUseSiteDiagnostics);
        }
    }

    [Fact]
    public void MemberLookup_Implicit_Instance()
    {
        var src = """
E.M();
_ = E.Property;

public implicit extension E for object
{
    public static void M()
    {
        System.Console.Write("Method ");
    }

    public static int Property
    {
        get
        {
            System.Console.Write("Property");
            return 0;
        }
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "Method Property",
            symbolValidator: validate, sourceSymbolValidator: validate);

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("E.M()", invocation.ToString());
        Assert.Equal("void E.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(1).First();
        Assert.Equal("E.Property", property.ToString());
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());

        AssertSetStrictlyEqual(["E"], model.LookupSymbols(position: 0, name: "E").ToTestDisplayStrings());

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");
        AssertSetStrictlyEqual(["void E.M()"], model.LookupSymbols(position: 0, e, name: "M").ToTestDisplayStrings());

        AssertSetStrictlyEqual(["void E.M()"], model.LookupSymbols(position: 0, e, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["System.Int32 E.Property { get; }"], model.LookupSymbols(position: 0, e, name: "Property").ToTestDisplayStrings());

        AssertSetStrictlyEqual(["System.Int32 E.Property { get; }"],
            model.LookupSymbols(position: 0, e, name: "Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["System.String System.Object.ToString()"], model.LookupSymbols(position: 0, e, name: "ToString").ToTestDisplayStrings());

        AssertSetStrictlyEqual(["System.String System.Object.ToString()"],
            model.LookupSymbols(position: 0, e, name: "ToString", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, o, name: "M").ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, o, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, o).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, o, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var e = module.GlobalNamespace.GetTypeMember("E");
            Assert.Empty(e.BaseExtensionsNoUseSiteDiagnostics);
            Assert.Empty(e.AllBaseExtensionsNoUseSiteDiagnostics);
        }
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void MemberLookup_Instance()
    {
        var src = """
void M(E e)
{
    e.M();
    _ = e.Property;
}

public explicit extension E for object
{
    public void M()
    {
        System.Console.Write("Method ");
    }

    public int Property
    {
        get
        {
            System.Console.Write("Property");
            return 0;
        }
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,6): warning CS8321: The local function 'M' is declared but never used
            // void M(E e)
            Diagnostic(ErrorCode.WRN_UnreferencedLocalFunction, "M").WithArguments("M").WithLocation(1, 6)
            );
        // PROTOTYPE execute once instance invocation is implemented

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("e.M()", invocation.ToString());
        Assert.Equal("void E.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(1).First();
        Assert.Equal("e.Property", property.ToString());
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_BaseExtension()
    {
        var src = """
E.M();
_ = E.Property;

public explicit extension Base for object
{
    public static void M()
    {
        System.Console.Write("Method ");
    }

    public static int Property
    {
        get
        {
            System.Console.Write("Property");
            return 0;
        }
    }
}

public explicit extension E for object : Base { }
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "Method Property",
            symbolValidator: validate, sourceSymbolValidator: validate);

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("E.M()", invocation.ToString());
        Assert.Equal("void Base.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(1).First();
        Assert.Equal("E.Property", property.ToString());
        Assert.Equal("System.Int32 Base.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());

        static void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var e = module.GlobalNamespace.GetTypeMember("E");
            AssertEx.Equal(new[] { "Base" }, e.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
            AssertEx.Equal(new[] { "Base" }, e.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        }
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_BaseExtension_Instance()
    {
        var src = """
#pragma warning disable CS8321 // unused local function
void M(E e)
{
    e.M();
    _ = e.Property;
}

public explicit extension Base for object
{
    public void M()
    {
        System.Console.Write("Method ");
    }

    public int Property
    {
        get
        {
            System.Console.Write("Property");
            return 0;
        }
    }
}

public explicit extension E for object : Base { }
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE execute once instance invocation is implemented

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("e.M()", invocation.ToString());
        Assert.Equal("void Base.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(1).First();
        Assert.Equal("e.Property", property.ToString());
        Assert.Equal("System.Int32 Base.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_BaseExtension_DifferentArities()
    {
        var src = """
E.M<int>();

public explicit extension Base for object
{
    public static void M<T>()
    {
        System.Console.Write("Method ");
    }
    public static void M() => throw null;
}

public explicit extension E for object : Base
{
    public static void M() => throw null;
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "Method");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("E.M<int>()", invocation.ToString());
        Assert.Equal("void Base.M<System.Int32>()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_BaseExtension_Ambiguous()
    {
        var src = """
E.M();
_ = E.Property;

public explicit extension Base1 for object
{
    public static void M() => throw null;
    public static int Property => throw null;
}

public explicit extension Base2 for object
{
    public static void M() => throw null;
    public static int Property => throw null;
}

public explicit extension E for object : Base1, Base2 { }
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
             // (1,3): error CS0121: The call is ambiguous between the following methods or properties: 'Base1.M()' and 'Base2.M()'
             // E.M();
             Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("Base1.M()", "Base2.M()").WithLocation(1, 3),
             // (2,7): error CS0229: Ambiguity between 'Base1.Property' and 'Base2.Property'
             // _ = E.Property;
             Diagnostic(ErrorCode.ERR_AmbigMember, "Property").WithArguments("Base1.Property", "Base2.Property").WithLocation(2, 7)
             );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("E.M()", invocation.ToString());
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Equal(["void Base1.M()", "void Base2.M()"], model.GetSymbolInfo(invocation).CandidateSymbols.ToTestDisplayStrings());

        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(1).First();
        Assert.Equal("E.Property", property.ToString());
        Assert.Null(model.GetSymbolInfo(property).Symbol);
        Assert.Equal(["System.Int32 Base1.Property { get; }", "System.Int32 Base2.Property { get; }"],
            model.GetSymbolInfo(property).CandidateSymbols.ToTestDisplayStrings());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_NestedType()
    {
        var src = """
public explicit extension E2 for object : E.Nested, E.BaseNested, E.HidingNested { }

public explicit extension Base for object
{
    public explicit extension BaseNested for object { }
    public explicit extension HidingNested for object { }
}

public explicit extension E for object : Base
{
    public explicit extension Nested for object { }
    public explicit extension HidingNested for object { }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var e2 = comp.GlobalNamespace.GetTypeMember("E2");
        AssertEx.Equal(new[] { "E.Nested", "Base.BaseNested", "E.HidingNested" },
            e2.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_NestedType_DifferentArities()
    {
        var src = """
public explicit extension E2 for object : E.Nested, E.Nested<int> { }

public explicit extension Base for object
{
    public explicit extension Nested<T> for object { }
    public explicit extension Nested for object { }
}

public explicit extension E for object : Base
{
    public explicit extension Nested for object { }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var e2 = comp.GlobalNamespace.GetTypeMember("E2");
        AssertEx.Equal(new[] { "E.Nested", "Base.Nested<System.Int32>" },
            e2.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_NestedType_Ambiguous()
    {
        var src = """
public explicit extension E2 for object : E.Ambiguous { }

public explicit extension Base1 for object
{
    public explicit extension Ambiguous for object { }
}

public explicit extension Base2 for object
{
    public explicit extension Ambiguous for object { }
}

public explicit extension E for object : Base1, Base2
{
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,45): error CS0104: 'Ambiguous' is an ambiguous reference between 'Base1.Ambiguous' and 'Base2.Ambiguous'
            // public explicit extension E2 for object : E.Ambiguous { }
            Diagnostic(ErrorCode.ERR_AmbigContext, "Ambiguous").WithArguments("Ambiguous", "Base1.Ambiguous", "Base2.Ambiguous").WithLocation(1, 45)
            );

        var e2 = comp.GlobalNamespace.GetTypeMember("E2");
        AssertEx.Equal(new[] { "Base1.Ambiguous" }, e2.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        // PROTOTYPE(inheritance) test lookup APIs
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_BaseExtension_Hiding()
    {
        var src = """
E.M();
_ = E.Property;

public explicit extension Base for object
{
    public static void M() => throw null;
    public static int Property => throw null;
}

public explicit extension E for object : Base
{
    public static void M()
    {
        System.Console.Write("Method ");
    }

    public static int Property
    {
        get
        {
            System.Console.Write("Property");
            return 0;
        }
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "Method Property",
            symbolValidator: validate, sourceSymbolValidator: validate);

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("E.M()", invocation.ToString());
        Assert.Equal("void E.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(1).First();
        Assert.Equal("E.Property", property.ToString());
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        // PROTOTYPE(inheritance) test lookup APIs

        static void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var e = module.GlobalNamespace.GetTypeMember("E");
            AssertEx.Equal(new[] { "Base" }, e.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
            AssertEx.Equal(new[] { "Base" }, e.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        }
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_BaseExtension_MethodHidesProperty()
    {
        var src = """
E.Member();

var m = E.Member;
m();

public explicit extension Base for object
{
    public static int Member => throw null;
}

public explicit extension E for object : Base
{
    public static void Member()
    {
        System.Console.Write("Member ");
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "Member Member",
            symbolValidator: validate, sourceSymbolValidator: validate);

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("E.Member()", invocation.ToString());
        Assert.Equal("void E.Member()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(1).First();
        Assert.Equal("E.Member", property.ToString());
        Assert.Equal("void E.Member()", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());

        static void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var e = module.GlobalNamespace.GetTypeMember("E");
            AssertEx.Equal(new[] { "Base" }, e.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
            AssertEx.Equal(new[] { "Base" }, e.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        }
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_MultipleCandidates()
    {
        var src = """
E.M((int)0);
E.M("hi");
E.M((long)0);

public explicit extension Base for object
{
    public static void M(int i)
    {
        System.Console.Write("Method(int) ");
    }
    public static void M(string i)
    {
        System.Console.Write("Method(string) ");
    }
}

public explicit extension E for object : Base
{
    public static void M(long l)
    {
        System.Console.Write("Method(long) ");
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "Method(long) Method(string) Method(long)");
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_BaseExtension_Diamond()
    {
        var src = """
_ = E2.Prop;
_ = E4.Prop;

public explicit extension E1 for object
{
    public static int Prop => throw null;
}

public explicit extension E2 for object : E1
{
    public static long Prop
    {
        get
        {
            System.Console.Write("E2.Prop ");
            return 42;
        }
    }
}

public explicit extension E3 for object : E1 { }

public explicit extension E4 for object : E2, E3 { }
""";

        // PROTOTYPE should warn about hiding
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "E2.Prop E2.Prop");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().First();
        Assert.Equal("E2.Prop", property.ToString());
        Assert.Equal("System.Int64 E2.Prop { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());

        var property2 = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(1).First();
        Assert.Equal("E4.Prop", property2.ToString());
        Assert.Equal("System.Int64 E2.Prop { get; }", model.GetSymbolInfo(property2).Symbol.ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoBaseExtensions), typeof(ClrOnly))]
    public void MemberLookup_BaseExtension_Inaccessible()
    {
        var src = """
E.M();
_ = E.Property;

public explicit extension Base for object
{
    private static void M() => throw null;
    private static int Property => throw null;
}

public explicit extension E for object : Base
{
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,3): error CS0122: 'Base.M()' is inaccessible due to its protection level
            // E.M();
            Diagnostic(ErrorCode.ERR_BadAccess, "M").WithArguments("Base.M()").WithLocation(1, 3),
            // (2,7): error CS0122: 'Base.Property' is inaccessible due to its protection level
            // _ = E.Property;
            Diagnostic(ErrorCode.ERR_BadAccess, "Property").WithArguments("Base.Property").WithLocation(2, 7)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions), typeof(ClrOnly))]
    public void MemberLookup_BaseExtension_Circular()
    {
        var src = """
E2.M();
_ = E2.Property;

public explicit extension E1 for object : E2
{
    public static void M() { }
    public static int Property => 0;
}

public explicit extension E2 for object : E1 { }
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,4): error CS0117: 'E2' does not contain a definition for 'M'
            // E2.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("E2", "M").WithLocation(1, 4),
            // (2,8): error CS0117: 'E2' does not contain a definition for 'Property'
            // _ = E2.Property;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property").WithArguments("E2", "Property").WithLocation(2, 8),
            // (4,27): error CS9311: Base extension 'E2' causes a cycle in the extension hierarchy of 'E1'.
            // public explicit extension E1 for object : E2
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "E1").WithArguments("E1", "E2").WithLocation(4, 27),
            // (10,27): error CS9311: Base extension 'E1' causes a cycle in the extension hierarchy of 'E2'.
            // public explicit extension E2 for object : E1 { }
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "E2").WithArguments("E2", "E1").WithLocation(10, 27)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("E2.M()", invocation.ToString());
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);

        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(1).First();
        Assert.Equal("E2.Property", property.ToString());
        Assert.Null(model.GetSymbolInfo(property).Symbol);
    }

    [ConditionalTheory(typeof(NoBaseExtensions))]
    [InlineData(0)]
    [InlineData(1)]
    [InlineData(2)]
    [InlineData(3)]
    public void MemberLookup_GrandBaseExtension(int offset)
    {
        var src = $$"""
E.M();
_ = E.Property;

public explicit extension GrandBase{{offset}} for object
{
    public static void M()
    {
        System.Console.Write("Method ");
    }

    public static int Property
    {
        get
        {
            System.Console.Write("Property");
            return 0;
        }
    }
}
public explicit extension GrandBase{{(offset + 1) % 4}} for object
{
}
public explicit extension GrandBase{{(offset + 2) % 4}} for object
{
}
public explicit extension GrandBase{{(offset + 3) % 4}} for object
{
}

public explicit extension Base1 for object : GrandBase0, GrandBase1
{
}
public explicit extension Base2 for object : GrandBase2, GrandBase3
{
}

public explicit extension E for object : Base1, Base2 { }
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "Method Property",
            symbolValidator: validate, sourceSymbolValidator: validate);

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("E.M()", invocation.ToString());
        Assert.Equal($$"""void GrandBase{{offset}}.M()""", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(1).First();
        Assert.Equal("E.Property", property.ToString());
        Assert.Equal($$"""System.Int32 GrandBase{{offset}}.Property { get; }""", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());

        static void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var e = module.GlobalNamespace.GetTypeMember("E");
            AssertEx.Equal(new[] { "Base1", "Base2" }, e.BaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());

            AssertEx.Equal(new[] { "Base1", "GrandBase0", "GrandBase1", "Base2", "GrandBase2", "GrandBase3" },
                e.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
        }
    }

    [ConditionalFact(typeof(NoBaseExtensions), typeof(ClrOnly))]
    public void MemberLookup_BaseExtension_CircularityAcrossNestedExtensions()
    {
        var src = """
D.E.M();
_ = D.E.Property;

public explicit extension C for object : D.E
{
    public explicit extension Base for object
    {
        public static void M()
        {
            System.Console.Write("Method ");
        }

        public static int Property
        {
            get
            {
                System.Console.Write("Property");
                return 0;
            }
        }
    }
}

public explicit extension D for object : C.Base
{
    public explicit extension E for object : C.Base { }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,5): error CS0117: 'D.E' does not contain a definition for 'M'
            // D.E.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("D.E", "M").WithLocation(1, 5),
            // (2,9): error CS0117: 'D.E' does not contain a definition for 'Property'
            // _ = D.E.Property;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property").WithArguments("D.E", "Property").WithLocation(2, 9),
            // (4,27): error CS9311: Base extension 'D.E' causes a cycle in the extension hierarchy of 'C'.
            // public explicit extension C for object : D.E
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "C").WithArguments("C", "D.E").WithLocation(4, 27),
            // (24,27): error CS9311: Base extension 'C.Base' causes a cycle in the extension hierarchy of 'D'.
            // public explicit extension D for object : C.Base
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "D").WithArguments("D", "C.Base").WithLocation(24, 27),
            // (26,31): error CS9311: Base extension 'C.Base' causes a cycle in the extension hierarchy of 'D.E'.
            //     public explicit extension E for object : C.Base { }
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "E").WithArguments("D.E", "C.Base").WithLocation(26, 31)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("D.E.M()", invocation.ToString());
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);

        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(2).First();
        Assert.Equal("D.E.Property", property.ToString());
        Assert.Null(model.GetSymbolInfo(property).Symbol);
    }

    [ConditionalFact(typeof(NoBaseExtensions), typeof(ClrOnly))]
    public void MemberLookup_BaseExtension_CircularityAcrossNestedExtensions_MissingBase()
    {
        var src1 = """
public explicit extension A for object { }
""";
        var comp1 = CreateCompilation(src1, assemblyName: "missing");

        var src2 = """
public explicit extension B for object : A { }
""";
        var comp2 = CreateCompilation(src2,
            references: new[] { comp1.ToMetadataReference() });
        comp2.VerifyDiagnostics();

        var src3 = """
D.E.M();
_ = D.E.Property;

public explicit extension C for object : D.E, B
{
    public explicit extension Base for object
    {
        public static void M()
        {
            System.Console.Write("Method ");
        }

        public static int Property
        {
            get
            {
                System.Console.Write("Property");
                return 0;
            }
        }
    }
}

public explicit extension D for object : C.Base
{
    public explicit extension E for object : C.Base { }
}
""";

        var comp3 = CreateCompilation(src3,
            references: new[] { comp2.ToMetadataReference() });

        comp3.VerifyDiagnostics(
            // (1,5): error CS0117: 'D.E' does not contain a definition for 'M'
            // D.E.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("D.E", "M").WithLocation(1, 5),
            // (2,9): error CS0117: 'D.E' does not contain a definition for 'Property'
            // _ = D.E.Property;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property").WithArguments("D.E", "Property").WithLocation(2, 9),
            // (4,27): error CS9311: Base extension 'D.E' causes a cycle in the extension hierarchy of 'C'.
            // public explicit extension C for object : D.E, B
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "C").WithArguments("C", "D.E").WithLocation(4, 27),
            // (4,27): error CS8090: There is an error in a referenced assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // public explicit extension C for object : D.E, B
            Diagnostic(ErrorCode.ERR_ErrorInReferencedAssembly, "C").WithArguments("missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(4, 27),
            // (10,13): error CS8090: There is an error in a referenced assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            //             System.Console.Write("Method ");
            Diagnostic(ErrorCode.ERR_ErrorInReferencedAssembly, "System").WithArguments("missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(10, 13),
            // (17,17): error CS8090: There is an error in a referenced assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            //                 System.Console.Write("Property");
            Diagnostic(ErrorCode.ERR_ErrorInReferencedAssembly, "System").WithArguments("missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(17, 17),
            // (24,27): error CS9311: Base extension 'C.Base' causes a cycle in the extension hierarchy of 'D'.
            // public explicit extension D for object : C.Base
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "D").WithArguments("D", "C.Base").WithLocation(24, 27),
            // (26,31): error CS9311: Base extension 'C.Base' causes a cycle in the extension hierarchy of 'D.E'.
            //     public explicit extension E for object : C.Base { }
            Diagnostic(ErrorCode.ERR_CycleInBaseExtensions, "E").WithArguments("D.E", "C.Base").WithLocation(26, 31)
            );

        var tree = comp3.SyntaxTrees.Single();
        var model = comp3.GetSemanticModel(tree);
        var invocation = tree.GetRoot().DescendantNodes().OfType<InvocationExpressionSyntax>().First();
        Assert.Equal("D.E.M()", invocation.ToString());
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);

        var property = tree.GetRoot().DescendantNodes().OfType<MemberAccessExpressionSyntax>().Skip(2).First();
        Assert.Equal("D.E.Property", property.ToString());
        Assert.Null(model.GetSymbolInfo(property).Symbol);
    }

    [Fact]
    public void MemberLookup_WithTypeArgumentInvolvingMissingBase()
    {
        var src1 = """
public explicit extension Missing for object { }
""";
        var comp1 = CreateCompilation(src1, assemblyName: "missing");

        var src2 = """
public explicit extension B for object : Missing
{
    public class C { }
}
""";
        var comp2 = CreateCompilation(src2,
            references: new[] { comp1.ToMetadataReference() });

        var src3 = """
E1.Method();

public explicit extension E2<T> for object
{
}
public explicit extension E1 for object : E2<B.C>
{
    public static void Method()
    {
        System.Console.Write("Method");
    }
}
""";

        var comp3 = CreateCompilation(src3,
            references: new[] { comp2.ToMetadataReference() });

        // PROTOTYPE should we have a diagnostic for using B (whose base extension is missing)?
        comp3.VerifyDiagnostics(
            // (6,41): error CS8000: This language feature ('base extensions') is not yet implemented.
            // public explicit extension E1 for object : E2<B.C>
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": E2<B.C>").WithArguments("base extensions").WithLocation(6, 41)
            );

        if (new NoBaseExtensions().ShouldSkip) return;
        CompileAndVerify(comp3, expectedOutput: "Method");
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void RecursiveExtensionLookup()
    {
        var src = """
explicit extension A<T> for object { }
explicit extension B for object : A<B.Garbage> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,39): error CS0426: The type name 'Garbage' does not exist in the type 'B'
            // explicit extension B for object : A<B.Garbage> { }
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Garbage").WithArguments("Garbage", "B").WithLocation(2, 39)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void RecursiveExtensionLookup_BaseWithTypeFromUnderlyingType()
    {
        var src = """
class C
{
    class Nested { }
}
explicit extension A<T> for C { }
explicit extension B for C : A<B.Nested> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void RecursiveExtensionLookup_BaseWithTypeFromBaseExtension()
    {
        var src = """
class C { }
explicit extension A<T> for C
{
    class Nested { }
}
explicit extension B for C : A<B.Nested> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void RecursiveExtensionLookup_UnderlyingTypeWithTypeFromUnderlyingType()
    {
        var src = """
class C<T>
{
    class Nested { }
}
explicit extension A<T> for C<T> { }
explicit extension B for C<B.Nested> : A<int> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void UseSiteErrorReporting_MissingGrandBase()
    {
        var source1 = """
public explicit extension A for object { }
""";
        var compilation1 = CreateCompilation(source1, assemblyName: "missing",
            targetFramework: TargetFramework.Net70);

        compilation1.VerifyDiagnostics();

        var source2 = """
public explicit extension B for object : A { }
public explicit extension C<T> for object : B { }
""";
        var compilation2 = CreateCompilation(source2, references: new[] { compilation1.ToMetadataReference() },
            targetFramework: TargetFramework.Net70);

        compilation2.VerifyDiagnostics();

        var source3 = """
D.M();

public explicit extension D for object : C<string>
{
    public static void M() { }
}
""";
        var compilation3 = CreateCompilation(source3, references: new[] { compilation2.ToMetadataReference() },
            targetFramework: TargetFramework.Net70);

        compilation3.VerifyDiagnostics(
            // (1,3): error CS8090: There is an error in a referenced assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // D.M();
            Diagnostic(ErrorCode.ERR_ErrorInReferencedAssembly, "M").WithArguments("missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 3),
            // (3,27): error CS8090: There is an error in a referenced assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // public explicit extension D for object : C<string>
            Diagnostic(ErrorCode.ERR_ErrorInReferencedAssembly, "D").WithArguments("missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(3, 27)
            );
    }

    [Fact]
    public void MemberLookup_MethodsFromObject_Static()
    {
        var src = """
A.ToString();

public explicit extension A for object { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,1): error CS0120: An object reference is required for the non-static field, method, or property 'object.ToString()'
            // A.ToString();
            Diagnostic(ErrorCode.ERR_ObjectRequired, "A.ToString").WithArguments("object.ToString()").WithLocation(1, 1)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var typeInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "A.ToString()");
        Assert.Null(model.GetSymbolInfo(typeInvocation).Symbol);
        Assert.Empty(model.GetMemberGroup(typeInvocation));
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void MemberLookup_MethodsFromObject_Instance()
    {
        var src = """
//E e = new object();
//e.M(e);

public explicit extension E for object
{
    void M(E e)
    {
        this.ToString();
        e.ToString();
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.ToString()");
        Assert.Equal("System.String System.Object.ToString()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.ToString()");
        Assert.Equal("System.String System.Object.ToString()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation)); // PROTOTYPE need to fix the semantic model
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_InUsing()
    {
        var src = """
explicit extension Base for object
{
    public class BaseMember { }
    public class HidingMember { }
}

explicit extension E for object : Base
{
    public class Member { }
    public class HidingMember { }
}

namespace N
{
#pragma warning disable CS8019 // unnecessary using
    using Alias1 = E.Member;
    using Alias2 = E.BaseMember;
    using Alias3 = E.HidingMember;
}
""";
        // PROTOTYPE should warn for hiding
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var alias1 = tree.GetRoot().DescendantNodes().OfType<UsingDirectiveSyntax>().First();
        Assert.Equal("Alias1=E.Member", model.GetDeclaredSymbol(alias1).ToTestDisplayString());

        var alias2 = tree.GetRoot().DescendantNodes().OfType<UsingDirectiveSyntax>().Skip(1).First();
        Assert.Equal("Alias2=Base.BaseMember", model.GetDeclaredSymbol(alias2).ToTestDisplayString());

        var alias3 = tree.GetRoot().DescendantNodes().OfType<UsingDirectiveSyntax>().Skip(2).First();
        Assert.Equal("Alias3=E.HidingMember", model.GetDeclaredSymbol(alias3).ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_InGlobalAlias()
    {
        var src = """
_ = typeof(global::E.Member);
_ = typeof(global::E.BaseMember);
_ = typeof(global::E.HidingMember);

explicit extension Base for object
{
    public class BaseMember { }
    public class HidingMember { }
}

explicit extension E for object : Base
{
    public class Member { }
    public class HidingMember { }
}
""";
        // PROTOTYPE should warn for hiding
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var member = tree.GetRoot().DescendantNodes().OfType<TypeOfExpressionSyntax>().First().Type;
        Assert.Equal("E.Member", model.GetSymbolInfo(member).Symbol.ToTestDisplayString());

        var baseMember = tree.GetRoot().DescendantNodes().OfType<TypeOfExpressionSyntax>().Skip(1).First().Type;
        Assert.Equal("Base.BaseMember", model.GetSymbolInfo(baseMember).Symbol.ToTestDisplayString());

        var hidingMember = tree.GetRoot().DescendantNodes().OfType<TypeOfExpressionSyntax>().Skip(2).First().Type;
        Assert.Equal("E.HidingMember", model.GetSymbolInfo(hidingMember).Symbol.ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void MemberLookup_InAlias()
    {
        var src = """
using Alias = E;

_ = typeof(Alias.Member);
_ = typeof(Alias.BaseMember);
_ = typeof(Alias.HidingMember);

explicit extension Base for object
{
    public class BaseMember { }
    public class HidingMember { }
}

explicit extension E for object : Base
{
    public class Member { }
    public class HidingMember { }
}
""";
        // PROTOTYPE should warn for hiding
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var member = tree.GetRoot().DescendantNodes().OfType<TypeOfExpressionSyntax>().First().Type;
        Assert.Equal("E.Member", model.GetSymbolInfo(member).Symbol.ToTestDisplayString());

        var baseMember = tree.GetRoot().DescendantNodes().OfType<TypeOfExpressionSyntax>().Skip(1).First().Type;
        Assert.Equal("Base.BaseMember", model.GetSymbolInfo(baseMember).Symbol.ToTestDisplayString());

        var hidingMember = tree.GetRoot().DescendantNodes().OfType<TypeOfExpressionSyntax>().Skip(2).First().Type;
        Assert.Equal("E.HidingMember", model.GetSymbolInfo(hidingMember).Symbol.ToTestDisplayString());
    }

    [ConditionalTheory(typeof(NoBaseExtensions), typeof(ClrOnly))]
    [InlineData(0)]
    [InlineData(1)]
    [InlineData(2)]
    [InlineData(3)]
    public void AllBaseExtensions_Retargeting(int offset)
    {
        var src1 = """
public explicit extension E1 for object { }
""";

        var comp1 = CreateCompilation(src1, assemblyName: "first");
        comp1.VerifyDiagnostics();

        var src2 = """
public explicit extension E2 for object : E1 { }
""";
        var comp2 = CreateCompilation(src2,
            references: new[] { comp1.EmitToImageReference() });

        comp2.VerifyDiagnostics();

        var src1Updated = $$"""
public explicit extension GrandBase{{offset}} for object
{
}
public explicit extension GrandBase{{(offset + 1) % 4}} for object
{
}
public explicit extension GrandBase{{(offset + 2) % 4}} for object
{
}
public explicit extension GrandBase{{(offset + 3) % 4}} for object
{
}

public explicit extension Base1 for object : GrandBase0, GrandBase1
{
}
public explicit extension Base2 for object : GrandBase2, GrandBase3
{
}

public explicit extension E1 for object : Base1, Base2 { }
""";

        var comp1Updated = CreateCompilation(src1Updated, assemblyName: "first");
        comp1Updated.VerifyDiagnostics();

        var src = """
public explicit extension E3 for object : E2 { }
""";
        var comp = CreateCompilation(src,
            references: new[] { comp2.ToMetadataReference(), comp1Updated.EmitToImageReference() });
        comp.VerifyDiagnostics();

        var e3 = comp.GlobalNamespace.GetTypeMember("E3");
        var e2 = e3.BaseExtensionsNoUseSiteDiagnostics.Single();
        Assert.Equal("E2", e2.ToTestDisplayString());
        VerifyExtension<RetargetingNamedTypeSymbol>(e2, isExplicit: true);

        AssertEx.Equal(new[] { "E1", "Base1", "GrandBase0", "GrandBase1", "Base2", "GrandBase2", "GrandBase3" },
            e2.AllBaseExtensionsNoUseSiteDiagnostics.ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMemberLookup_Simple_Static_InConversion()
    {
        var src = """
int p = object.Property;
System.Action p2 = object.Property2;

int f = object.Field;
System.Console.Write($"Field({f}) ");

System.Action m = object.Method;
m();

implicit extension E for object
{
    public static int Property
    {
        get
        {
            System.Console.Write("Property ");
            return 0;
        }
    }

    public static System.Action Property2
    {
        get
        {
            System.Console.Write("Property2 ");
            return () => { };
        }
    }

    public static int Field = 42;

    public static void Method()
    {
        System.Console.Write("Method ");
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, expectedOutput: "Property Property2 Field(42) Method");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        ITypeSymbol int32 = comp.GetSpecialType(SpecialType.System_Int32).GetPublicSymbol();
        ITypeSymbol stringType = comp.GetSpecialType(SpecialType.System_String).GetPublicSymbol();
        ITypeSymbol action = comp.GetWellKnownType(WellKnownType.System_Action).GetPublicSymbol();

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property));
        Assert.Equal(ConversionKind.Identity, model.GetConversion(property).Kind);
        Assert.Equal(ConversionKind.Identity, model.ClassifyConversion(property, int32).Kind);
        Assert.Equal(ConversionKind.NoConversion, model.ClassifyConversion(property, stringType).Kind);
        Assert.Equal(ConversionKind.NoConversion, model.ClassifyConversion(property, action).Kind);

        var property2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property2");
        Assert.Equal("System.Action E.Property2 { get; }", model.GetSymbolInfo(property2).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property2));
        Assert.Equal(ConversionKind.Identity, model.GetConversion(property2).Kind);
        Assert.Equal(ConversionKind.Identity, model.ClassifyConversion(property2, action).Kind);
        Assert.Equal(ConversionKind.NoConversion, model.ClassifyConversion(property2, stringType).Kind);
        Assert.Equal(ConversionKind.NoConversion, model.ClassifyConversion(property2, int32).Kind);

        var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
        Assert.Equal("System.Int32 E.Field", model.GetSymbolInfo(field).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(field));
        Assert.Equal(ConversionKind.Identity, model.GetConversion(field).Kind);
        Assert.Equal(ConversionKind.Identity, model.ClassifyConversion(field, int32).Kind);

        var method = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Method");
        Assert.Equal("void E.Method()", model.GetSymbolInfo(method).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(method)); // PROTOTYPE need to fix the semantic model
        Assert.Equal(ConversionKind.MethodGroup, model.GetConversion(method).Kind);
        Assert.Equal(ConversionKind.MethodGroup, model.ClassifyConversion(method, action).Kind);
    }

    [Fact]
    public void ExtensionMemberLookup_Simple_Static_InNumericConversion()
    {
        var src = """
long p = object.Property;

long f = object.Field;
System.Console.Write($"Field({f}) ");

implicit extension E for object
{
    public static int Property
    {
        get
        {
            System.Console.Write("Property ");
            return 0;
        }
    }

    public static int Field = 42;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, expectedOutput: "Property Field(42)");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property));
        Assert.Equal(ConversionKind.ImplicitNumeric, model.GetConversion(property).Kind);
        ITypeSymbol int64 = comp.GetSpecialType(SpecialType.System_Int64).GetPublicSymbol();
        Assert.Equal(ConversionKind.ImplicitNumeric, model.ClassifyConversion(property, int64).Kind);

        var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
        Assert.Equal("System.Int32 E.Field", model.GetSymbolInfo(field).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(field));
        Assert.Equal(ConversionKind.ImplicitNumeric, model.GetConversion(field).Kind);
        Assert.Equal(ConversionKind.ImplicitNumeric, model.ClassifyConversion(field, int64).Kind);
    }

    [Fact]
    public void ExtensionMemberLookup_Simple_Static_InFailedConversion()
    {
        var src = """
System.Action p = object.Property;
int p2 = object.Property2;

implicit extension E for object
{
    public static int Property => throw null;
    public static System.Action Property2 => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,19): error CS0029: Cannot implicitly convert type 'int' to 'System.Action'
            // System.Action p = object.Property;
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "object.Property").WithArguments("int", "System.Action").WithLocation(1, 19),
            // (2,10): error CS0029: Cannot implicitly convert type 'System.Action' to 'int'
            // int p2 = object.Property2;
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "object.Property2").WithArguments("System.Action", "int").WithLocation(2, 10)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property));
        Assert.Equal(ConversionKind.NoConversion, model.GetConversion(property).Kind);
        ITypeSymbol int64 = comp.GetSpecialType(SpecialType.System_Int64).GetPublicSymbol();
        Assert.Equal(ConversionKind.ImplicitNumeric, model.ClassifyConversion(property, int64).Kind);

        var property2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property2");
        Assert.Equal("System.Action E.Property2 { get; }", model.GetSymbolInfo(property2).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property2));
        Assert.Equal(ConversionKind.NoConversion, model.GetConversion(property2).Kind);
        ITypeSymbol action = comp.GetWellKnownType(WellKnownType.System_Action).GetPublicSymbol();
        Assert.Equal(ConversionKind.Identity, model.ClassifyConversion(property2, action).Kind);
    }

    [Fact]
    public void ExtensionMemberLookup_Simple_Static_InMemberAccess()
    {
        var src = """
object.Property.ToString();
System.Console.Write($"Field({object.Field.ToString()}) ");
object.Type.M();
object.StaticType.M();

implicit extension E for object
{
    public static int Property
    {
        get
        {
            System.Console.Write("Property ");
            return 0;
        }
    }

    public static int Field = 42;

    public class Type
    {
        public static void M()
        {
            System.Console.Write("Type ");
        }
    }

    public class StaticType
    {
        public static void M()
        {
            System.Console.Write("StaticType ");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, expectedOutput: "Property Field(42) Type StaticType");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());

        var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
        Assert.Equal("System.Int32 E.Field", model.GetSymbolInfo(field).Symbol.ToTestDisplayString());

        var type = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Type");
        Assert.Equal("E.Type", model.GetSymbolInfo(type).Symbol.ToTestDisplayString());

        var staticType = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticType");
        Assert.Equal("E.StaticType", model.GetSymbolInfo(staticType).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_Simple_Static_Discards()
    {
        var src = """
_ = object.Property;
_ = object.Field;

implicit extension E for object
{
    public static int Property { get { System.Console.Write("Property"); return 42; } }
    public static int Field = 42;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Property").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property));

        var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
        Assert.Equal("System.Int32 E.Field", model.GetSymbolInfo(field).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(field));
    }

    [Fact]
    public void ExtensionMemberLookup_Simple_Static_Method()
    {
        var src = """
object.Method();

implicit extension E for object
{
    public static void Method()
    {
        System.Console.Write("Method ");
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var method = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Method");
        Assert.Equal("void E.Method()", model.GetSymbolInfo(method).Symbol.ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void ExtensionMemberLookup_Simple_Static_FromBaseExtension()
    {
        var src = """
_ = object.Property;
System.Console.Write($"Field({object.Field}) ");
object.Type.M();
object.StaticType.M();

implicit extension Derived for object : Base { }

implicit extension Base for object
{
    public static int Property
    {
        get
        {
            System.Console.Write("Property ");
            return 0;
        }
    }

    public static int Field = 42;

    public class Type
    {
        public static void M()
        {
            System.Console.Write("Type ");
        }
    }

    public class StaticType
    {
        public static void M()
        {
            System.Console.Write("StaticType ");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Property Field(42) Type StaticType").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Equal("System.Int32 Base.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property));

        var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
        Assert.Equal("System.Int32 Base.Field", model.GetSymbolInfo(field).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(field));

        var type = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Type");
        Assert.Equal("Base.Type", model.GetSymbolInfo(type).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(type));

        var staticType = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticType");
        Assert.Equal("Base.StaticType", model.GetSymbolInfo(staticType).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(staticType));
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void ExtensionMemberLookup_Simple_Static_FromBaseExtension_OnlyDerivedInScope()
    {
        var src = """
_ = object.Property;
System.Console.Write($"Field({object.Field}) ");
object.Type.M();
object.StaticType.M();

implicit extension Derived for object : N.Base { }

namespace N
{
    implicit extension Base for object
    {
        public static int Property
        {
            get
            {
                System.Console.Write("Property ");
                return 0;
            }
        }

        public static int Field = 42;

        public class Type
        {
            public static void M()
            {
                System.Console.Write("Type ");
            }
        }

        public class StaticType
        {
            public static void M()
            {
                System.Console.Write("StaticType ");
            }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Property Field(42) Type StaticType").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Equal("System.Int32 N.Base.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property));

        var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
        Assert.Equal("System.Int32 N.Base.Field", model.GetSymbolInfo(field).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(field));

        var type = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Type");
        Assert.Equal("N.Base.Type", model.GetSymbolInfo(type).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(type));

        var staticType = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticType");
        Assert.Equal("N.Base.StaticType", model.GetSymbolInfo(staticType).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(staticType));
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void ExtensionMemberLookup_Simple_Static_FromBaseExtension_OnlyDerivedInScope_Inaccessible()
    {
        var src = """
_ = object.Property;
System.Console.Write($"Field({object.Field}) ");
object.Type.M();

implicit extension Derived for object : N.Base { }

namespace N
{
    implicit extension Base for object
    {
        private static int Property
        {
            get
            {
                System.Console.Write("Property ");
                return 0;
            }
        }

        private static int Field = 42;

        private class Type
        {
            public static void M()
            {
                System.Console.Write("Type ");
            }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,12): error CS0117: 'object' does not contain a definition for 'Property'
            // _ = object.Property;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property").WithArguments("object", "Property").WithLocation(1, 12),
            // (2,38): error CS0117: 'object' does not contain a definition for 'Field'
            // System.Console.Write($"Field({object.Field}) ");
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Field").WithArguments("object", "Field").WithLocation(2, 38),
            // (3,8): error CS0117: 'object' does not contain a definition for 'Type'
            // object.Type.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Type").WithArguments("object", "Type").WithLocation(3, 8),
            // (20,28): warning CS0414: The field 'Base.Field' is assigned but its value is never used
            //         private static int Field = 42;
            Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "Field").WithArguments("N.Base.Field").WithLocation(20, 28)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Null(model.GetSymbolInfo(property).Symbol);
        Assert.Empty(model.GetMemberGroup(property));

        var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
        Assert.Null(model.GetSymbolInfo(field).Symbol);
        Assert.Empty(model.GetMemberGroup(field));

        var type = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Type");
        Assert.Null(model.GetSymbolInfo(type).Symbol);
        Assert.Empty(model.GetMemberGroup(type));
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void ExtensionMemberLookup_Simple_Static_FromBaseExtension_Method()
    {
        var src = """
object.Method();

implicit extension Derived for object : Base { }

implicit extension Base for object
{
    public static void Method()
    {
        System.Console.Write("Method ");
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var method = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Method");
        Assert.Equal("void Base.Method()", model.GetSymbolInfo(method).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(method)); // PROTOTYPE need to fix the semantic model
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void ExtensionMemberLookup_Simple_Static_FromBaseExtension_Method_OnlyDerivedInScope()
    {
        var src = """
object.Method();

implicit extension Derived for object : N.Base { }

namespace N
{
    implicit extension Base for object
    {
        public static void Method()
        {
            System.Console.Write("Method ");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var method = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Method");
        Assert.Equal("void N.Base.Method()", model.GetSymbolInfo(method).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(method)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionMemberLookup_Simple_Static_Protected()
    {
        var src = """
_ = object.Property;
System.Console.Write($"Field({object.Field}) ");
object.Type.M();

implicit extension E for object
{
    protected static int Property
    {
        get
        {
            System.Console.Write("Property ");
            return 0;
        }
    }

    protected static int Field = 42;

    protected class Type
    {
        public static void M()
        {
            System.Console.Write("Type ");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,12): error CS0117: 'object' does not contain a definition for 'Property'
            // _ = object.Property;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property").WithArguments("object", "Property").WithLocation(1, 12),
            // (2,38): error CS0117: 'object' does not contain a definition for 'Field'
            // System.Console.Write($"Field({object.Field}) ");
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Field").WithArguments("object", "Field").WithLocation(2, 38),
            // (3,8): error CS0117: 'object' does not contain a definition for 'Type'
            // object.Type.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Type").WithArguments("object", "Type").WithLocation(3, 8)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Null(model.GetSymbolInfo(property).Symbol);
        Assert.Empty(model.GetMemberGroup(property));

        var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
        Assert.Null(model.GetSymbolInfo(field).Symbol);
        Assert.Empty(model.GetMemberGroup(field));

        var type = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Type");
        Assert.Null(model.GetSymbolInfo(type).Symbol);
        Assert.Empty(model.GetMemberGroup(type));
    }

    [Fact]
    public void ExtensionMemberLookup_Simple_Static_MethodGroupExists()
    {
        var src = """
C.M();

class C
{
    public static void M(int i) { }
    public static void M(string s) { }
}

implicit extension E for C
{
    public static void M()
    {
        System.Console.Write("M");
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "M").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var method = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E.M()", model.GetSymbolInfo(method).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M(System.Int32 i)", "void C.M(System.String s)" }, model.GetMemberGroup(method).ToTestDisplayStrings());
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void ExtensionMemberLookup_Simple_Static_Shadowing()
    {
        var src = """
_ = object.Property;
System.Console.Write($"Field({object.Field}) ");
object.Type.M();

implicit extension Derived for object : Base
{
    public static int Property
    {
        get
        {
            System.Console.Write("Property ");
            return 0;
        }
    }

    public static int Field = 42;

    public class Type
    {
        public static void M()
        {
            System.Console.Write("Type ");
        }
    }

    public class StaticType
    {
        public static void M()
        {
            System.Console.Write("StaticType ");
        }
    }
}

implicit extension Base for object
{
    public static int Property
    {
        get => throw null;
    }

    public static int Field = 42;

    public class Type { }
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, expectedOutput: "Property Field(42) Type");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Equal("System.Int32 Derived.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property));

        var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
        Assert.Equal("System.Int32 Derived.Field", model.GetSymbolInfo(field).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(field));

        var type = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Type");
        Assert.Equal("Derived.Type", model.GetSymbolInfo(type).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(type));
    }

    [Fact]
    public void ExtensionMemberLookup_Simple_Static_Shadowing_OnlyDerivedInScope()
    {
        var src = """
_ = object.Property;
System.Console.Write($"Field({object.Field}) ");
object.Type.M();

implicit extension Derived for object : N.Base
{
    public static int Property
    {
        get
        {
            System.Console.Write("Property ");
            return 0;
        }
    }

    public static int Field = 42;

    public class Type
    {
        public static void M()
        {
            System.Console.Write("Type ");
        }
    }

    public class StaticType
    {
        public static void M()
        {
            System.Console.Write("StaticType ");
        }
    }
}

namespace N
{
    implicit extension Base for object
    {
        public static int Property
        {
            get => throw null;
        }

        public static int Field = 42;

        public class Type { }
    }
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics(
            // (5,39): error CS8000: This language feature ('base extensions') is not yet implemented.
            // implicit extension Derived for object : N.Base
            Diagnostic(ErrorCode.ERR_NotYetImplementedInRoslyn, ": N.Base").WithArguments("base extensions").WithLocation(5, 39)
            );

        if (!new NoBaseExtensions().ShouldSkip)
        {
            CompileAndVerify(comp, expectedOutput: "Property Field(42) Type");
        }

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Equal("System.Int32 Derived.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property));

        var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
        Assert.Equal("System.Int32 Derived.Field", model.GetSymbolInfo(field).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(field));

        var type = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Type");
        Assert.Equal("Derived.Type", model.GetSymbolInfo(type).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(type));
    }

    [Fact]
    public void ExtensionMemberLookup_TypeOnlyContext_AmbiguityBetweenTypes()
    {
        var src = """
using System;

class C<T> where T : Object.Member { }

implicit extension E1 for object
{
    public class Member { }
}

implicit extension E2 for object
{
    public class Member { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,29): error CS0104: 'Member' is an ambiguous reference between 'E1.Member' and 'E2.Member'
            // class C<T> where T : Object.Member { }
            Diagnostic(ErrorCode.ERR_AmbigContext, "Member").WithArguments("Member", "E1.Member", "E2.Member").WithLocation(3, 29)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "Object.Member");
        Assert.Null(model.GetSymbolInfo(qualifiedName).Symbol);
        Assert.Equal(CandidateReason.Ambiguous, model.GetSymbolInfo(qualifiedName).CandidateReason);
        Assert.Equal(["E1.Member", "E2.Member"], model.GetSymbolInfo(qualifiedName).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(qualifiedName));
    }

    [Fact]
    public void ExtensionMemberLookup_TypeOnlyContext_OtherMembersIgnored()
    {
        var src = """
using System;

class C<T> where T : Object.Member { }

implicit extension E1 for object
{
    public class Member { }
}

implicit extension E2 for object
{
    public int Member() => throw null;
}

implicit extension E3 for object
{
    public static int Member = 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "Object.Member");
        Assert.Equal("E1.Member", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(qualifiedName));
    }

    [Fact]
    public void ExtensionMemberLookup_TypeOnlyContext_OtherMembersIgnored_Generic()
    {
        var src = """
using System;

class C<T> where T : Object.Member<int> { }

implicit extension E1 for object
{
    public class Member<T> { }
}

implicit extension E2 for object
{
    public int Member<T>() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "Object.Member<int>");
        Assert.Equal("E1.Member<System.Int32>", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(qualifiedName));
    }

    [Fact]
    public void ExtensionMemberLookup_VariousScopes()
    {
        var cSrc = """
class C
{
    public static void Main()
    {
        _ = object.Property;
        System.Console.Write($"Field({object.Field}) ");
        object.Type.M();
        object.StaticType.M();
    }
}
""";

        var eSrc = """
implicit extension E for object
{
    public static int Property
    {
        get
        {
            System.Console.Write("Property ");
            return 0;
        }
    }

    public static int Field = 42;

    public class Type
    {
        public static void M()
        {
            System.Console.Write("Type ");
        }
    }

    public class StaticType
    {
        public static void M()
        {
            System.Console.Write("StaticType ");
        }
    }
}
""";

        var src1 = $$"""
namespace N
{
    {{cSrc}}
    {{eSrc}}
}
""";
        verify(src1, "N.E");

        var src2 = $$"""
namespace N
{
    namespace N2
    {
        {{cSrc}}
    }

    {{eSrc}}
}
""";
        verify(src2, "N.E");

        var src3 = $$"""
{{eSrc}}
namespace N
{
    {{cSrc}}
}
""";
        verify(src3, extensionName: "E");

        var src4 = $$"""
file {{eSrc}}
{{cSrc}}
""";
        verify(src4, extensionName: "E@<tree 0>");

        var src5 = $$"""
class Container
{
    {{eSrc}}
    {{cSrc}}
}
""";
        verify(src5, extensionName: "Container.E");

        void verify(string src, string extensionName)
        {
            var comp = CreateCompilation(src, options: TestOptions.DebugExe);
            CompileAndVerify(comp, expectedOutput: "Property Field(42) Type StaticType").VerifyDiagnostics();

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
            Assert.Equal($$"""System.Int32 {{extensionName}}.Property { get; }""", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
            Assert.Empty(model.GetMemberGroup(property));

            var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
            Assert.Equal($$"""System.Int32 {{extensionName}}.Field""", model.GetSymbolInfo(field).Symbol.ToTestDisplayString());
            Assert.Empty(model.GetMemberGroup(field));

            var type = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Type");
            Assert.Equal($$"""{{extensionName}}.Type""", model.GetSymbolInfo(type).Symbol.ToTestDisplayString());
            Assert.Empty(model.GetMemberGroup(type));

            var staticType = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticType");
            Assert.Equal($$"""{{extensionName}}.StaticType""", model.GetSymbolInfo(staticType).Symbol.ToTestDisplayString());
            Assert.Empty(model.GetMemberGroup(staticType));
        }
    }

    [Fact]
    public void ExtensionMemberLookup_VariousScopes_Errors()
    {
        var cSrc = """
class C
{
    public static void Main()
    {
        object.Method();
        _ = object.Property;
        System.Console.Write($"Field({object.Field}) ");
        object.StaticType.M();
    }
}
""";

        var eSrc = """
implicit extension E for object
{
    public static void Method() => throw null;
    public static int Property => throw null;
    public static int Field = 42;

    public static class StaticType
    {
        public static void M() => throw null;
    }
}
""";

        var src1 = $$"""
        namespace N
        {
            {{cSrc}}
            namespace N2
            {
                {{eSrc}}
            }
        }
        """;
        verify(src1,
            // (7,16): error CS0117: 'object' does not contain a definition for 'Method'
            //         object.Method();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Method").WithArguments("object", "Method").WithLocation(7, 16),
            // (8,20): error CS0117: 'object' does not contain a definition for 'Property'
            //         _ = object.Property;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property").WithArguments("object", "Property").WithLocation(8, 20),
            // (9,46): error CS0117: 'object' does not contain a definition for 'Field'
            //         System.Console.Write($"Field({object.Field}) ");
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Field").WithArguments("object", "Field").WithLocation(9, 46),
            // (10,16): error CS0117: 'object' does not contain a definition for 'StaticType'
            //         object.StaticType.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "StaticType").WithArguments("object", "StaticType").WithLocation(10, 16)
            );

        var src2 = $$"""
file {{eSrc}}
""";
        verify(new[] { cSrc, src2 },
            // 0.cs(5,16): error CS0117: 'object' does not contain a definition for 'Method'
            //         object.Method();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Method").WithArguments("object", "Method").WithLocation(5, 16),
            // 0.cs(6,20): error CS0117: 'object' does not contain a definition for 'Property'
            //         _ = object.Property;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property").WithArguments("object", "Property").WithLocation(6, 20),
            // 0.cs(7,46): error CS0117: 'object' does not contain a definition for 'Field'
            //         System.Console.Write($"Field({object.Field}) ");
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Field").WithArguments("object", "Field").WithLocation(7, 46),
            // 0.cs(8,16): error CS0117: 'object' does not contain a definition for 'StaticType'
            //         object.StaticType.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "StaticType").WithArguments("object", "StaticType").WithLocation(8, 16)
            );

        static void verify(CSharpTestSource src, params DiagnosticDescription[] expected)
        {
            var comp = CreateCompilation(src, options: TestOptions.DebugExe);
            comp.VerifyDiagnostics(expected);

            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);

            var method = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Method");
            Assert.Null(model.GetSymbolInfo(method).Symbol);
            Assert.Empty(model.GetMemberGroup(method));

            var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
            Assert.Null(model.GetSymbolInfo(property).Symbol);
            Assert.Empty(model.GetMemberGroup(property));

            var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
            Assert.Null(model.GetSymbolInfo(field).Symbol);
            Assert.Empty(model.GetMemberGroup(field));

            var staticType = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticType");
            Assert.Null(model.GetSymbolInfo(staticType).Symbol);
            Assert.Empty(model.GetMemberGroup(staticType));
        }
    }

    [Fact]
    public void ExtensionMemberLookup_FromUsingNamespace()
    {
        var cSrc = """
class C
{
    public static void Main()
    {
        _ = object.Property;
        System.Console.Write($"Field({object.Field}) ");
        object.Type.M();
        object.StaticType.M();
    }
}
""";

        var eSrc = """
namespace N2
{
    implicit extension E for object
    {
        public static int Property
        {
            get
            {
                System.Console.Write("Property ");
                return 0;
            }
        }

        public static int Field = 42;

        public class Type
        {
            public static void M()
            {
                System.Console.Write("Type ");
            }
        }

        public class StaticType
        {
            public static void M()
            {
                System.Console.Write("StaticType ");
            }
        }
    }
}
""";

        var src1 = $$"""
using N2;
{{cSrc}}

{{eSrc}}
""";
        verify(src1, "N2.E");

        var src2 = $$"""
using N2;
using N2; // 1, 2
{{cSrc}}

{{eSrc}}
""";

        var comp = CreateCompilation(src2, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (2,1): hidden CS8019: Unnecessary using directive.
            // using N2; // 1, 2
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N2;").WithLocation(2, 1),
            // (2,7): warning CS0105: The using directive for 'N2' appeared previously in this namespace
            // using N2; // 1, 2
            Diagnostic(ErrorCode.WRN_DuplicateUsing, "N2").WithArguments("N2").WithLocation(2, 7)
            );

        var src3 = $$"""
namespace N3
{
    using N2;

    namespace N4
    {
        {{cSrc}}
    }

    {{eSrc}}
}
""";
        verify(src3, "N3.N2.E");

        void verify(string src, string extensionName)
        {
            var comp = CreateCompilation(src, options: TestOptions.DebugExe);
            CompileAndVerify(comp, expectedOutput: "Property Field(42) Type StaticType").VerifyDiagnostics();

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
            Assert.Equal($$"""System.Int32 {{extensionName}}.Property { get; }""", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
            Assert.Empty(model.GetMemberGroup(property));

            var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
            Assert.Equal($$"""System.Int32 {{extensionName}}.Field""", model.GetSymbolInfo(field).Symbol.ToTestDisplayString());
            Assert.Empty(model.GetMemberGroup(field));

            var type = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Type");
            Assert.Equal($$"""{{extensionName}}.Type""", model.GetSymbolInfo(type).Symbol.ToTestDisplayString());
            Assert.Empty(model.GetMemberGroup(type));

            var staticType = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticType");
            Assert.Equal($$"""{{extensionName}}.StaticType""", model.GetSymbolInfo(staticType).Symbol.ToTestDisplayString());
            Assert.Empty(model.GetMemberGroup(staticType));
        }
    }

    [Fact]
    public void ExtensionMemberLookup_UsingNamespaceNecessity_Property()
    {
        var src = """
using N1;
using N2;

class C
{
    public static void Main()
    {
        _ = object.Property;
    }
}

namespace N1
{
    class D { }
}

namespace N2
{
    implicit extension E for object
    {
        public static int Property { get { System.Console.Write("property"); return 0; } }
    }
}
""";

        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N1;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N1;").WithLocation(1, 1)
            );

        CompileAndVerify(comp, expectedOutput: "property");
    }

    [Fact]
    public void ExtensionMemberLookup_UsingNamespaceNecessity_Method()
    {
        var src = """
using N1;
using N2;

class C
{
    public static void Main()
    {
        object.Method();
    }
}

namespace N1
{
    class D { }
}

namespace N2
{
    implicit extension E for object
    {
        public static void Method()
        {
            System.Console.Write("method");
        }
    }
}
""";

        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N1;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N1;").WithLocation(1, 1)
            );

        CompileAndVerify(comp, expectedOutput: "method");
    }

    [Fact]
    public void ExtensionMemberLookup_UsingNamespaceNecessity_UnusedImplicitExtension_Property()
    {
        var src = """
using N1;
using N2;

class C
{
    public static void Main()
    {
        _ = object.Property;
    }
}

namespace N1
{
    implicit extension D for string { }
}

namespace N2
{
    implicit extension E for object
    {
        public static int Property => throw null;
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_UsingNamespaceNecessity_UnusedImplicitExtension_Field()
    {
        var src = """
using N1;
using N2;

class C
{
    public static void Main()
    {
        _ = object.Field;
    }
}

namespace N1
{
    implicit extension D for string { }
}

namespace N2
{
    implicit extension E for object
    {
        public static int Field = 0;
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_UsingNamespaceNecessity_UnusedExplicitExtension_Method()
    {
        var src = """
using N1;
using N2;

class C
{
    public static void Main()
    {
        object.Method();
    }
}

namespace N1
{
    explicit extension D for string { }
}

namespace N2
{
    implicit extension E for object
    {
        public static void Method()
        {
            System.Console.Write("method");
        }
    }
}
""";

        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N1;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N1;").WithLocation(1, 1)
            );

        CompileAndVerify(comp, expectedOutput: "method");
    }

    [Fact]
    public void ExtensionMemberLookup_ExplicitExtension()
    {
        var src = """
object.Method();
_ = object.Property;
System.Console.Write($"Field({object.Field}) ");
object.StaticType.M();

explicit extension E for object
{
    public static void Method() => throw null;
    public static int Property => throw null;
    public static int Field = 42;

    public class StaticType
    {
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'Method'
            // object.Method();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Method").WithArguments("object", "Method").WithLocation(1, 8),
            // (2,12): error CS0117: 'object' does not contain a definition for 'Property'
            // _ = object.Property;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property").WithArguments("object", "Property").WithLocation(2, 12),
            // (3,38): error CS0117: 'object' does not contain a definition for 'Field'
            // System.Console.Write($"Field({object.Field}) ");
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Field").WithArguments("object", "Field").WithLocation(3, 38),
            // (4,8): error CS0117: 'object' does not contain a definition for 'StaticType'
            // object.StaticType.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "StaticType").WithArguments("object", "StaticType").WithLocation(4, 8)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_InaccessibleMembers()
    {
        var src = """
object.Method();
_ = object.Property;
System.Console.Write($"Field({object.Field}) ");
object.StaticType.M();

implicit extension E for object
{
    private static void Method() => throw null;
    private static int Property => throw null;
    private static int Field = 42;

    private class StaticType
    {
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'Method'
            // object.Method();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Method").WithArguments("object", "Method").WithLocation(1, 8),
            // (2,12): error CS0117: 'object' does not contain a definition for 'Property'
            // _ = object.Property;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property").WithArguments("object", "Property").WithLocation(2, 12),
            // (3,38): error CS0117: 'object' does not contain a definition for 'Field'
            // System.Console.Write($"Field({object.Field}) ");
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Field").WithArguments("object", "Field").WithLocation(3, 38),
            // (4,8): error CS0117: 'object' does not contain a definition for 'StaticType'
            // object.StaticType.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "StaticType").WithArguments("object", "StaticType").WithLocation(4, 8),
            // (10,24): warning CS0414: The field 'E.Field' is assigned but its value is never used
            //     private static int Field = 42;
            Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "Field").WithArguments("E.Field").WithLocation(10, 24)
            );
    }

    [Theory, CombinatorialData]
    public void ExtensionMemberLookup_Ambiguity(bool e1BeforeE2)
    {
        var e1 = """
implicit extension E1 for object
{
    public static void Method() => throw null;
    public static int Property => throw null;
    public static int Field = 42;
    public class Type
    {
        public static void M() => throw null;
    }
}
""";

        var e2 = """
implicit extension E2 for object
{
    public static void Method() => throw null;
    public static int Property => throw null;
    public static int Field = 42;
    public class Type
    {
        public static void M() => throw null;
    }
}
""";

        var src = $$"""
object.Method();
_ = object.Property;
_ = object.Field;
_ = object.Type.M();

{{(e1BeforeE2 ? e1 : e2)}}
{{(e1BeforeE2 ? e2 : e1)}}
""";
        var comp = CreateCompilation(src);
        if (!e1BeforeE2)
        {
            comp.VerifyEmitDiagnostics(
                // (1,8): error CS0121: The call is ambiguous between the following methods or properties: 'E2.Method()' and 'E1.Method()'
                // object.Method();
                Diagnostic(ErrorCode.ERR_AmbigCall, "Method").WithArguments("E2.Method()", "E1.Method()").WithLocation(1, 8),
                // (2,12): error CS0229: Ambiguity between 'E1.Property' and 'E2.Property'
                // _ = object.Property;
                Diagnostic(ErrorCode.ERR_AmbigMember, "Property").WithArguments("E1.Property", "E2.Property").WithLocation(2, 12),
                // (3,12): error CS0229: Ambiguity between 'E1.Field' and 'E2.Field'
                // _ = object.Field;
                Diagnostic(ErrorCode.ERR_AmbigMember, "Field").WithArguments("E1.Field", "E2.Field").WithLocation(3, 12),
                // (4,12): error CS0104: 'Type' is an ambiguous reference between 'E1.Type' and 'E2.Type'
                // _ = object.Type.M();
                Diagnostic(ErrorCode.ERR_AmbigContext, "Type").WithArguments("Type", "E1.Type", "E2.Type").WithLocation(4, 12)
                );
        }
        else
        {
            comp.VerifyEmitDiagnostics(
                // (1,8): error CS0121: The call is ambiguous between the following methods or properties: 'E1.Method()' and 'E2.Method()'
                // object.Method();
                Diagnostic(ErrorCode.ERR_AmbigCall, "Method").WithArguments("E1.Method()", "E2.Method()").WithLocation(1, 8),
                // (2,12): error CS0229: Ambiguity between 'E1.Property' and 'E2.Property'
                // _ = object.Property;
                Diagnostic(ErrorCode.ERR_AmbigMember, "Property").WithArguments("E1.Property", "E2.Property").WithLocation(2, 12),
                // (3,12): error CS0229: Ambiguity between 'E1.Field' and 'E2.Field'
                // _ = object.Field;
                Diagnostic(ErrorCode.ERR_AmbigMember, "Field").WithArguments("E1.Field", "E2.Field").WithLocation(3, 12),
                // (4,12): error CS0104: 'Type' is an ambiguous reference between 'E1.Type' and 'E2.Type'
                // _ = object.Type.M();
                Diagnostic(ErrorCode.ERR_AmbigContext, "Type").WithArguments("Type", "E1.Type", "E2.Type").WithLocation(4, 12)
                );
        }
    }

    [Fact]
    public void ExtensionMemberLookup_Overloads()
    {
        var src = """
object.Method(42);
object.Method("hello");

implicit extension E1 for object
{
    public static void Method(int i)
    {
        System.Console.Write($"E1.Method({i}) ");
    }
}

implicit extension E2 for object
{
    public static void Method(string s)
    {
        System.Console.Write($"E2.Method({s}) ");
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "E1.Method(42) E2.Method(hello)").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_Overloads_DifferentScopes_NestedNamespace()
    {
        var src = """
namespace N1
{
    implicit extension E1 for object
    {
        public static void Method(int i)
        {
            System.Console.Write($"E1.Method({i}) ");
        }
    }

    namespace N2
    {
        implicit extension E2 for object
        {
            public static void Method(string s)
            {
                System.Console.Write($"E2.Method({s}) ");
            }
        }

        class C
        {
            public static void Main()
            {
                object.Method(42);
                object.Method("hello");
            }
        }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "E1.Method(42) E2.Method(hello)").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_Overloads_DifferentScopes_NestedType()
    {
        var src = """
namespace N1
{
    implicit extension E1 for object
    {
        public static void Method(int i)
        {
            System.Console.Write($"E1.Method({i}) ");
        }
    }

    class Nested
    {
        implicit extension E2 for object
        {
            public static void Method(string s)
            {
                System.Console.Write($"E2.Method({s})");
            }
        }

        class C
        {
            public static void Main()
            {
                object.Method(42);
                object.Method("hello");
            }
        }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "E1.Method(42) E2.Method(hello)").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_NamespaceVsUsing_FromNamespace_Property()
    {
        var src = """
using N2; // 1

class C
{
    public static void Main()
    {
        _ = object.Property;
    }
}

implicit extension E1 for object
{
    public static int Property
    {
        get
        {
            System.Console.Write("E1.Property");
            return 0;
        }
    }
}

namespace N2
{
    implicit extension E2 for object
    {
        public static int Property => throw null;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N2; // 1
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N2;").WithLocation(1, 1)
            );
        CompileAndVerify(comp, expectedOutput: "E1.Property");
    }

    [Fact]
    public void ExtensionMemberLookup_NamespaceVsUsing_FromNamespace_Method()
    {
        var src = """
using N2;

object.Method(42);
object.Method("hello");

implicit extension E1 for object
{
    public static void Method(int i)
    {
        System.Console.Write("E1.Method ");
    }
}

namespace N2
{
    implicit extension E2 for object
    {
        public static void Method(string s)
        {
            System.Console.Write("E2.Method");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "E1.Method E2.Method").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_NamespaceVsUsing_FromUsing_Method()
    {
        var src = """
using N2;

object.Method("hello");

implicit extension E1 for object
{
    public static void Method2(int i) => throw null;
}

namespace N2
{
    implicit extension E2 for object
    {
        public static void Method(string s)
        {
            System.Console.Write("Method");
        }
    }
}
""";

        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Method").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_DerivedType()
    {
        var src = """
string.StaticType.M();

implicit extension E for object
{
    public static class StaticType
    {
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var staticType = GetSyntax<MemberAccessExpressionSyntax>(tree, "string.StaticType");
        Assert.Equal("E.StaticType", model.GetSymbolInfo(staticType).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(staticType));
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_DerivedDerivedType()
    {
        var src = """
Derived.StaticType.M();

class Base { }
class Derived : Base { }

implicit extension E for object
{
    public static class StaticType
    {
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var staticType = GetSyntax<MemberAccessExpressionSyntax>(tree, "Derived.StaticType");
        Assert.Equal("E.StaticType", model.GetSymbolInfo(staticType).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(staticType));
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_ImplementedInterface()
    {
        var src = """
C.StaticType.M();

interface I { }
class C : I { }

implicit extension E for I
{
    public static class StaticType
    {
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var staticType = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.StaticType");
        Assert.Equal("E.StaticType", model.GetSymbolInfo(staticType).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(staticType));
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_IndirectlyImplementedInterface()
    {
        var src = """
C.StaticType.M();

interface I { }
interface Indirect : I { }
class C : Indirect { }

implicit extension E for I
{
    public static class StaticType
    {
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var staticType = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.StaticType");
        Assert.Equal("E.StaticType", model.GetSymbolInfo(staticType).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(staticType));
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_TypeParameterImplementedInterface()
    {
        var src = """
class C
{
    void M<T>() where T : I
    {
        T.StaticType.M(); // 1
        _ = T.Property; // 2
    }
}

interface I
{
    int Property => 0;
}

implicit extension E for I
{
    public static class StaticType
    {
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (5,9): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         T.StaticType.M(); // 1
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(5, 9),
            // (6,13): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         _ = T.Property; // 2
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(6, 13)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_TypeParameterWithBaseClass()
    {
        var src = $$"""
class C<T> { }
implicit extension R<T> for C<T> where T : C<T>
{
    void M()
    {
        T.M(); // 1
        T.Type.M2(); // 2
    }

    class Type
    {
        public static void M2() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (6,9): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         T.M(); // 1
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(6, 9),
            // (7,9): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         T.Type.M2(); // 2
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(7, 9)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_BaseType()
    {
        var src = """
object.StaticType.M();

implicit extension E for string
{
    public static class StaticType
    {
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'StaticType'
            // object.StaticType.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "StaticType").WithArguments("object", "StaticType").WithLocation(1, 8)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_GenericType()
    {
        var src = """
C<int>.StaticType.M();

class C<T> { }

implicit extension E<T> for C<T>
{
    public static class StaticType
    {
        public static void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran")
           .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.StaticType");
        Assert.Equal("E<System.Int32>.StaticType", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");
        AssertSetStrictlyEqual(["E<T>.StaticType"], model.LookupSymbols(position: 0, e, name: "StaticType").ToTestDisplayStrings());
        AssertSetStrictlyEqual(["E<T>.StaticType"], model.LookupSymbols(position: 0, e, name: "StaticType", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, c, name: "StaticType").ToTestDisplayStrings());
        // PROTOTYPE(static) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([/*"E<T>.StaticType"*/], model.LookupSymbols(position: 0, c, name: "StaticType", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        var cInt = model.GetTypeInfo(memberAccess.Expression).Type;
        Assert.Equal("C<System.Int32>", cInt.ToTestDisplayString());
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, cInt, name: "StaticType").ToTestDisplayStrings());
        // PROTOTYPE(static) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([/*"E<System.Int32>.StaticType"*/], model.LookupSymbols(position: 0, cInt, name: "StaticType", includeReducedExtensionMethods: true).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_GenericType_GenericMember()
    {
        var src = """
C<int>.StaticType<string>.M();

class C<T> { }

implicit extension E<T> for C<T>
{
    public static class StaticType<U>
    {
        public static void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran")
           .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.StaticType<string>");
        Assert.Equal("E<System.Int32>.StaticType<System.String>", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");
        AssertSetStrictlyEqual(["E<T>.StaticType<U>"], model.LookupSymbols(position: 0, e, name: "StaticType").ToTestDisplayStrings());
        AssertSetStrictlyEqual(["E<T>.StaticType<U>"], model.LookupSymbols(position: 0, e, name: "StaticType", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");
        Assert.Equal("C<T>", c.ToTestDisplayString());
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, c, name: "StaticType").ToTestDisplayStrings());

        // PROTOTYPE(static) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([/*"E<T>.StaticType<U>"*/],
            model.LookupSymbols(position: 0, c, name: "StaticType", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E<T>.StaticType<U>"], model.LookupStaticMembers(position: 0, c, name: "StaticType").ToTestDisplayStrings());

        var cInt = model.GetTypeInfo(memberAccess.Expression).Type;
        Assert.Equal("C<System.Int32>", cInt.ToTestDisplayString());
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, cInt, name: "StaticType").ToTestDisplayStrings());

        // PROTOTYPE(static) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([/*"E<System.Int32>.StaticType<U>"*/],
            model.LookupSymbols(position: 0, cInt, name: "StaticType", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E<System.Int32>.StaticType<U>"], model.LookupStaticMembers(position: 0, cInt, name: "StaticType").ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_GenericMember_TypeOnlyContext()
    {
        var src = """
D<C.Nested<string>>.M();

class D<T> where T : C.Nested<string>
{
    public static void M()
    {
        System.Console.Write(typeof(T));
    }
}

class C { }

implicit extension E for C
{
    public class Nested<U>
    {
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "E+Nested`1[System.String]")
           .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntaxes<QualifiedNameSyntax>(tree, "C.Nested<string>").ToArray();
        Assert.Equal("E.Nested<System.String>", model.GetSymbolInfo(qualifiedName[0]).Symbol.ToTestDisplayString());
        Assert.Equal("E.Nested<System.String>", model.GetSymbolInfo(qualifiedName[1]).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_GenericMember_TypeOnlyContext_UnderspecifiedGenericExtension()
    {
        var src = """
D<C.Nested<string>>.M();

class D<T> where T : C.Nested<string>
{
    public static void M()
    {
        System.Console.Write(typeof(T));
    }
}

class C { }

implicit extension E<T> for C
{
    public class Nested<U>
    {
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0426: The type name 'Nested<>' does not exist in the type 'C'
            // D<C.Nested<string>>.M();
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Nested<string>").WithArguments("Nested<>", "C").WithLocation(1, 5),
            // (3,24): error CS0426: The type name 'Nested<>' does not exist in the type 'C'
            // class D<T> where T : C.Nested<string>
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Nested<string>").WithArguments("Nested<>", "C").WithLocation(3, 24),
            // (13,20): error CS9328: The underlying type 'C' of implicit extension 'E<T>' must reference all the type parameters declared by the extension, but type parameter 'T' is missing.
            // implicit extension E<T> for C
            Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E").WithArguments("C", "E<T>", "T").WithLocation(13, 20));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntaxes<QualifiedNameSyntax>(tree, "C.Nested<string>").ToArray();
        Assert.Null(model.GetSymbolInfo(qualifiedName[0]).Symbol);
        Assert.Null(model.GetSymbolInfo(qualifiedName[1]).Symbol);
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_GenericMember_TypeOnlyContext_AmbiguousGenericExtension()
    {
        var src = """
I.Nested<string>.M2();
D<I.Nested<string>>.M();

class D<T> where T : I.Nested<string>
{
    public static void M()
    {
        System.Console.Write(typeof(T));
    }
}

interface I2<T> { }
interface I : I2<long>, I2<byte> { }

implicit extension E<T, U> for I2<T>
{
    public class Nested<V>
    {
        public static void M2() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,3): error CS0117: 'I' does not contain a definition for 'Nested'
            // I.Nested<string>.M2();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Nested<string>").WithArguments("I", "Nested").WithLocation(1, 3),
            // (2,5): error CS0426: The type name 'Nested<>' does not exist in the type 'I'
            // D<I.Nested<string>>.M();
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Nested<string>").WithArguments("Nested<>", "I").WithLocation(2, 5),
            // (4,24): error CS0426: The type name 'Nested<>' does not exist in the type 'I'
            // class D<T> where T : I.Nested<string>
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Nested<string>").WithArguments("Nested<>", "I").WithLocation(4, 24),
            // (15,20): error CS9328: The underlying type 'I2<T>' of implicit extension 'E<T, U>' must reference all the type parameters declared by the extension, but type parameter 'U' is missing.
            // implicit extension E<T, U> for I2<T>
            Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E").WithArguments("I2<T>", "E<T, U>", "U").WithLocation(15, 20));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntaxes<QualifiedNameSyntax>(tree, "I.Nested<string>").ToArray();
        Assert.Null(model.GetSymbolInfo(qualifiedName[0]).Symbol);
        Assert.Null(model.GetSymbolInfo(qualifiedName[1]).Symbol);
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_GenericMember_TypeOnlyContext_UnderspecifiedGenericExtension_Metadata()
    {
        //implicit extension E<T> for object
        //{
        //    public class Nested<U>
        //    {
        //    }
        //}

        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit E`1<T>
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: false)}}'(object '') cil managed
    {
        IL_0000: ret
    }

    .class nested public auto ansi beforefieldinit Nested`1<T, U>
        extends [mscorlib]System.Object
    {
        .method public hidebysig specialname rtspecialname instance void .ctor () cil managed
        {
            IL_0000: ldarg.0
            IL_0001: call instance void [mscorlib]System.Object::.ctor()
            IL_0006: ret
        }
    }
}
""";

        var src = """
E<int> x = default;
E<int>.Nested<string> y = default;
D<System.Object.Nested<string>>.M();

class D<T> where T : System.Object.Nested<string>
{
    public static void M()
    {
        System.Console.Write(typeof(T));
    }
}
""";
        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyEmitDiagnostics(
            // (1,8): warning CS0219: The variable 'x' is assigned but its value is never used
            // E<int> x = default;
            Diagnostic(ErrorCode.WRN_UnreferencedVarAssg, "x").WithArguments("x").WithLocation(1, 8),
            // (2,23): warning CS0219: The variable 'y' is assigned but its value is never used
            // E<int>.Nested<string> y = default;
            Diagnostic(ErrorCode.WRN_UnreferencedVarAssg, "y").WithArguments("y").WithLocation(2, 23),
            // (3,17): error CS0426: The type name 'Nested<>' does not exist in the type 'object'
            // D<System.Object.Nested<string>>.M();
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Nested<string>").WithArguments("Nested<>", "object").WithLocation(3, 17),
            // (5,36): error CS0426: The type name 'Nested<>' does not exist in the type 'object'
            // class D<T> where T : System.Object.Nested<string>
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Nested<string>").WithArguments("Nested<>", "object").WithLocation(5, 36));

        var e = comp.GlobalNamespace.GetTypeMember("E");
        VerifyExtension<PENamedTypeSymbol>(e, isExplicit: false);

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntaxes<QualifiedNameSyntax>(tree, "System.Object.Nested<string>").ToArray();
        Assert.Null(model.GetSymbolInfo(qualifiedName[0]).Symbol);
        Assert.Null(model.GetSymbolInfo(qualifiedName[1]).Symbol);
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_GenericType_GenericMember_OmittedTypeArgument()
    {
        var src = """
C<int>.StaticType<,>.M();

class C<T> { }

implicit extension E<T> for C<T>
{
    public static class StaticType<U, V>
    {
        public static void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS8389: Omitting the type argument is not allowed in the current context
            // C<int>.StaticType<,>.M();
            Diagnostic(ErrorCode.ERR_OmittedTypeArgument, "C<int>.StaticType<,>").WithLocation(1, 1),
            // (1,1): error CS0305: Using the generic type 'E<int>.StaticType<U, V>' requires 2 type arguments
            // C<int>.StaticType<,>.M();
            Diagnostic(ErrorCode.ERR_BadArity, "C<int>.StaticType<,>").WithArguments("E<int>.StaticType<U, V>", "type", "2").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.StaticType<,>");
        Assert.Equal("E<System.Int32>.StaticType<U, V>", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_GenericType_GenericMember_BrokenConstraint()
    {
        var src = """
C<int>.StaticType<string>.M();

class C<T> { }

implicit extension E<T> for C<T>
{
    public static class StaticType<U> where U : struct
    {
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,19): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'U' in the generic type or method 'E<int>.StaticType<U>'
            // C<int>.StaticType<string>.M();
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "string").WithArguments("E<int>.StaticType<U>", "U", "string").WithLocation(1, 19));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.StaticType<string>");
        Assert.Equal("E<System.Int32>.StaticType<System.String>", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");
        AssertSetStrictlyEqual(["E<T>.StaticType<U>"], model.LookupSymbols(position: 0, e, name: "StaticType").ToTestDisplayStrings());
        AssertSetStrictlyEqual(["E<T>.StaticType<U>"], model.LookupSymbols(position: 0, e, name: "StaticType", includeReducedExtensionMethods: true).ToTestDisplayStrings());
        AssertSetStrictlyEqual(["E<T>.StaticType<U>"], model.LookupStaticMembers(position: 0, e, name: "StaticType").ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");
        Assert.Equal("C<T>", c.ToTestDisplayString());
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, c, name: "StaticType").ToTestDisplayStrings());
        // PROTOTYPE(static) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([/*"E<T>.StaticType<U>"*/], model.LookupSymbols(position: 0, c, name: "StaticType", includeReducedExtensionMethods: true).ToTestDisplayStrings());
        AssertSetStrictlyEqual(["E<T>.StaticType<U>"], model.LookupStaticMembers(position: 0, c, name: "StaticType").ToTestDisplayStrings());

        var cInt = model.GetTypeInfo(memberAccess.Expression).Type;
        Assert.Equal("C<System.Int32>", cInt.ToTestDisplayString());
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, cInt, name: "StaticType").ToTestDisplayStrings());

        // PROTOTYPE(static) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([/*"E<System.Int32>.StaticType<U>"*/],
            model.LookupSymbols(position: 0, cInt, name: "StaticType", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E<System.Int32>.StaticType<U>"], model.LookupStaticMembers(position: 0, cInt, name: "StaticType").ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_GenericType_Nested()
    {
        var src = """
C<int>.D.StaticType.M();

class C<T>
{
    public class D { }
}

implicit extension E<T> for C<T>.D
{
    public static class StaticType
    {
        public static void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.D.StaticType");
        Assert.Equal("E<System.Int32>.StaticType", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_DynamicDifference()
    {
        // Note: no dynamic resolution of implicit extensions
        var src = """
dynamic.StaticType.M(); // 1
dynamic.Method(); // 2
_ = dynamic.Property; // 3
_ = dynamic.Field; // 4

dynamic d = new object();
d.StaticType.M(); // This will fail at runtime

object o = new object();
o.StaticType.M(); // 5

implicit extension E for object
{
    public static class StaticType
    {
        public static void M() => throw null;
    }

    public static void Method() => throw null;
    public static int Property => throw null;
    public static int Field = 42;
}
""";
        // PROTOTYPE see if we can improve the diagnostic location for 5 (should be on "StaticType", not "o.StaticType")
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (1,1): error CS0103: The name 'dynamic' does not exist in the current context
            // dynamic.StaticType.M(); // 1
            Diagnostic(ErrorCode.ERR_NameNotInContext, "dynamic").WithArguments("dynamic").WithLocation(1, 1),
            // (2,1): error CS0103: The name 'dynamic' does not exist in the current context
            // dynamic.Method(); // 2
            Diagnostic(ErrorCode.ERR_NameNotInContext, "dynamic").WithArguments("dynamic").WithLocation(2, 1),
            // (3,5): error CS0103: The name 'dynamic' does not exist in the current context
            // _ = dynamic.Property; // 3
            Diagnostic(ErrorCode.ERR_NameNotInContext, "dynamic").WithArguments("dynamic").WithLocation(3, 5),
            // (4,5): error CS0103: The name 'dynamic' does not exist in the current context
            // _ = dynamic.Field; // 4
            Diagnostic(ErrorCode.ERR_NameNotInContext, "dynamic").WithArguments("dynamic").WithLocation(4, 5),
            // (10,1): error CS0572: 'StaticType': cannot reference a type through an expression; try 'E.StaticType' instead
            // o.StaticType.M(); // 5
            Diagnostic(ErrorCode.ERR_BadTypeReference, "o.StaticType").WithArguments("StaticType", "E.StaticType").WithLocation(10, 1)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingTypeParameter()
    {
        var src = """
C.StaticType.M();

class C { }

implicit extension E<T> for T where T : C
{
    public static class StaticType
    {
        public static void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran")
           .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.StaticType");
        Assert.Equal("E<C>.StaticType", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void DynamicArgument()
    {
        // No extension members in dynamic invocation
        var src = """
dynamic d = null;
object.M(d);

implicit extension E for object
{
    public static void Method(object o) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,8): error CS0117: 'object' does not contain a definition for 'M'
            // object.M(d);
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(2, 8)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_DynamicDifference_Nested()
    {
        var src = """
C<dynamic>.StaticType.M();

class C<T> { }

implicit extension E for C<object>
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "M").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_DynamicDifference_InBase()
    {
        var src = """
D.StaticType.M();

class C<T> { }
class D : C<dynamic> { }

implicit extension E for C<object>
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "M").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_DynamicDifference_InInterface()
    {
        var src = """
D.StaticType.M();

interface I<T> { }
class D : I<dynamic> { }

implicit extension E for I<object>
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,11): error CS1966: 'D': cannot implement a dynamic interface 'I<dynamic>'
            // class D : I<dynamic> { }
            Diagnostic(ErrorCode.ERR_DeriveFromConstructedDynamic, "I<dynamic>").WithArguments("D", "I<dynamic>").WithLocation(4, 11)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_TupleNamesDifference()
    {
        var src = """
C<(int a, int b)>.StaticType.M();
C<(int, int)>.StaticType.M();
C<(int other, int)>.StaticType.M();

class C<T> { }

implicit extension E for C<(int a, int b)>
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        // PROTOTYPE consider warning for certain tuple name differences
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_TupleNamesDifference_InBase()
    {
        var src = """
D1.StaticType.M();
D2.StaticType.M();
D3.StaticType.M();

class C<T> { }
class D1 : C<(int a, int b)> { }
class D2 : C<(int, int)> { }
class D3 : C<(int other, int)> { }

implicit extension E for C<(int a, int b)>
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        // PROTOTYPE consider warning for certain tuple name differences
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_MatchingExtendedType_TupleNamesDifference_InInterface()
    {
        var src = """
D1.StaticType.M();
D2.StaticType.M();
D3.StaticType.M();

class I<T> { }
class D1 : I<(int a, int b)> { }
class D2 : I<(int, int)> { }
class D3 : I<(int other, int)> { }

implicit extension E for I<(int a, int b)>
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        // PROTOTYPE consider warning for certain tuple name differences
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_NullabilityDifference_AnnotatedInExtendedType()
    {
        var src = """
#nullable enable
C<object>.StaticType.M();
C<object?>.StaticType.M();

C<
#nullable disable
    object
#nullable enable
    >.StaticType.M();

class C<T> { }

implicit extension E for C<object?>
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        // PROTOTYPE consider warning for certain nullability differences
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_NullabilityDifference_AnnotatedInExtendedType_InBase()
    {
        var src = """
#nullable enable

D1.StaticType.M();
D2.StaticType.M();
D3.StaticType.M();

class C<T> { }

class D1 : C<object> { }
class D2 : C<object?> { }

class D3 : C<
#nullable disable
    object
#nullable enable
    > { }

implicit extension E for C<object?>
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        // PROTOTYPE consider warning for certain nullability differences
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_NullabilityDifference_AnnotatedInExtendedType_InInterface()
    {
        var src = """
#nullable enable

D1.StaticType.M();
D2.StaticType.M();
D3.StaticType.M();

interface I<T> { }

class D1 : I<object> { }
class D2 : I<object?> { }

class D3 : I<
#nullable disable
    object
#nullable enable
    > { }

implicit extension E for I<object?>
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        // PROTOTYPE consider warning for certain nullability differences
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_NullabilityDifference_UnannotatedInExtendedType()
    {
        var src = """
#nullable enable
C<object>.StaticType.M();
C<object?>.StaticType.M();

C<
#nullable disable
    object
#nullable enable
    >.StaticType.M();

class C<T> { }

implicit extension E for C<object>
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        // PROTOTYPE consider warning for certain nullability differences
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_NullabilityDifference_UnannotatedInExtendedType_InBase()
    {
        var src = """
#nullable enable
D1.StaticType.M();
D2.StaticType.M();
D3.StaticType.M();

class C<T> { }

class D1 : C<object> { }
class D2 : C<object?> { }

class D3 : C<
#nullable disable
    object
#nullable enable
    > { }

implicit extension E for C<object>
{
    public static class StaticType
    {
        public static void M() { }
    }
}
""";
        // PROTOTYPE consider warning for certain nullability differences
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_NullabilityDifference_UnannotatedInExtendedType_InInterface()
    {
        var src = """
#nullable enable
D1.StaticType.M();
D2.StaticType.M();
D3.StaticType.M();

interface I<T> { }

class D1 : I<object> { }
class D2 : I<object?> { }

class D3 : I<
#nullable disable
    object
#nullable enable
    > { }

implicit extension E for I<object>
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        // PROTOTYPE consider warning for certain nullability differences
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_NullabilityDifference_ObliviousInExtendedType()
    {
        var src = """
#nullable enable
C<object>.StaticType.M();
C<object?>.StaticType.M();

C<
#nullable disable
    object
#nullable enable
    >.StaticType.M();

class C<T> { }

implicit extension E for C<
#nullable disable
    object
#nullable enable
    >
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        // PROTOTYPE consider warning for certain nullability differences
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_NullabilityDifference_ObliviousInExtendedType_InBase()
    {
        var src = """
#nullable enable
D1.StaticType.M();
D2.StaticType.M();
D3.StaticType.M();

class C<T> { }

class D1 : C<object> { }
class D2 : C<object?> { }

class D3 : C<
#nullable disable
    object
#nullable enable
    > { }

implicit extension E for C<
#nullable disable
    object
#nullable enable
    >
{
    public static class StaticType
    {
        public static void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        // PROTOTYPE consider warning for certain nullability differences
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_NullabilityDifference_AnnotatedTypeParameterInExtendedType()
    {
        var src = """
#nullable enable
C<object>.StaticType.M();
C<object?>.StaticType.M();

C<
#nullable disable
    object
#nullable enable
    >.StaticType.M();

class C<T> { }

implicit extension E<T> for C<T?>
{
    public static class StaticType
    {
        public static void M() { System.Console.Write("ran "); }
    }
}
""";
        // PROTOTYPE consider warning for certain nullability differences
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran ran ran")
          .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<object>.StaticType");
        Assert.Equal("E<System.Object>.StaticType", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<object?>.StaticType");
        Assert.Equal("E<System.Object?>.StaticType", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_NullabilityDifference_AnnotatedTypeParameterInExtendedType_Constrained()
    {
        var src = """
#nullable enable
C<object>.StaticType.M();
C<object?>.StaticType.M();

C<
#nullable disable
    object
#nullable enable
    >.StaticType.M();

class C<T> { }

implicit extension E<T> for C<T?> where T : class
{
    public static class StaticType
    {
        public static void M() { System.Console.Write("ran "); }
    }
}
""";
        // PROTOTYPE consider warning for certain nullability differences
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, expectedOutput: "ran ran ran")
           .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<object>.StaticType");
        Assert.Equal("E<System.Object>.StaticType", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<object?>.StaticType");
        Assert.Equal("E<System.Object?>.StaticType", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_Nameof()
    {
        var src = """
System.Console.Write($"{nameof(object.M)} ");
System.Console.Write($"{nameof(object.StaticType)}");

implicit extension E for object
{
    public static void M() { }
    public static class StaticType { }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "M StaticType").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_Nameof_Overloads()
    {
        var src = """
System.Console.Write($"{nameof(object.M)} ");

implicit extension E for object
{
    public static void M() { }
    public static void M(int i) { }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "M").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_Nameof_SimpleName()
    {
        var src = """
class C
{
    void M()
    {
        _ = nameof(Method);
        _ = nameof(StaticType);
    }
}

implicit extension E for object
{
    public static void Method() { }
    public static class StaticType { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,20): error CS0103: The name 'Method' does not exist in the current context
            //         _ = nameof(Method);
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Method").WithArguments("Method").WithLocation(5, 20),
            // (6,20): error CS0103: The name 'StaticType' does not exist in the current context
            //         _ = nameof(StaticType);
            Diagnostic(ErrorCode.ERR_NameNotInContext, "StaticType").WithArguments("StaticType").WithLocation(6, 20)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_Indexer_Static()
    {
        var src = """
implicit extension E for object
{
    public static int this[int i]
    {
        get
        {
            return 0;
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,23): error CS0106: The modifier 'static' is not valid for this item
            //     public static int this[int i]
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "this").WithArguments("static").WithLocation(3, 23)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_Indexer_Instance_Getter()
    {
        var src = """
object o = new object();

/*<bind>*/
_ = o[42];
/*</bind>*/

implicit extension E for object
{
    public int this[int i]
    {
        get
        {
            System.Console.Write("indexer");
            return 0;
        }
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "indexer");

        string expectedOperationTree = """
ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: System.Int32) (Syntax: '_ = o[42]')
Left:
  IDiscardOperation (Symbol: System.Int32 _) (OperationKind.Discard, Type: System.Int32) (Syntax: '_')
Right:
  IPropertyReferenceOperation: System.Int32 E.this[System.Int32 i] { get; } (OperationKind.PropertyReference, Type: System.Int32) (Syntax: 'o[42]')
    Instance Receiver:
      ILocalReferenceOperation: o (OperationKind.LocalReference, Type: System.Object) (Syntax: 'o')
    Arguments(1):
        IArgumentOperation (ArgumentKind.Explicit, Matching Parameter: i) (OperationKind.Argument, Type: null) (Syntax: '42')
          ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 42) (Syntax: '42')
          InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
          OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
""";
        var expectedDiagnostics = DiagnosticDescription.None;

        VerifyOperationTreeAndDiagnosticsForTest<AssignmentExpressionSyntax>(src,
            expectedOperationTree, expectedDiagnostics);
    }

    [Fact]
    public void ExtensionMemberLookup_Indexer_Instance_Setter()
    {
        var src = """
object o = new object();

/*<bind>*/
o[42] = 0;
/*</bind>*/

implicit extension E for object
{
    public int this[int i]
    {
        set
        {
            System.Console.Write("indexer");
        }
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "indexer");

        string expectedOperationTree = """
ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: System.Int32) (Syntax: 'o[42] = 0')
Left:
  IPropertyReferenceOperation: System.Int32 E.this[System.Int32 i] { set; } (OperationKind.PropertyReference, Type: System.Int32) (Syntax: 'o[42]')
    Instance Receiver:
      ILocalReferenceOperation: o (OperationKind.LocalReference, Type: System.Object) (Syntax: 'o')
    Arguments(1):
        IArgumentOperation (ArgumentKind.Explicit, Matching Parameter: i) (OperationKind.Argument, Type: null) (Syntax: '42')
          ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 42) (Syntax: '42')
          InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
          OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
Right:
  ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 0) (Syntax: '0')
""";
        var expectedDiagnostics = DiagnosticDescription.None;

        VerifyOperationTreeAndDiagnosticsForTest<AssignmentExpressionSyntax>(src,
            expectedOperationTree, expectedDiagnostics);
    }

    [Fact]
    public void ExtensionMemberLookup_Instance_Simple_Property()
    {
        var src = """
object o = new object();
_ = o.Property;

implicit extension E for object
{
    public int Property
    {
        get
        {
            System.Console.Write("Property ");
            return 0;
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        // PROTOTYPE Revisit when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "Property");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.Property");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property));
    }

    [Fact]
    public void ExtensionMemberLookup_Instance_Simple_Method()
    {
        var src = """
object o = new object();
o.Method();

implicit extension E for object
{
    public void Method()
    {
        System.Console.Write("Method");
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        // PROTOTYPE Revisit when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "Method");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var method = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.Method");
        Assert.Equal("void E.Method()", model.GetSymbolInfo(method).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(method)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionMemberLookup_Instance_Null_Property()
    {
        var src = """
#nullable enable

object? o2 = null;
_ = o2.Property;

implicit extension E for object
{
    public int Property
    {
        get
        {
            System.Console.Write("Property ");
            return 0;
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,5): warning CS8602: Dereference of a possibly null reference.
            // _ = o2.Property;
            Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o2").WithLocation(4, 5)
            );

        // PROTOTYPE What is the expected runtime behavior? NRE? The nullability checks should be adjusted correspondingly.
        // PROTOTYPE Revisit when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "Property");
    }

    [Fact]
    public void ExtensionMemberLookup_Instance_Null_Method()
    {
        var src = """
#nullable enable

object? o = null;
o.Method();

implicit extension E for object
{
    public void Method()
    {
        System.Console.Write("Method ");
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,1): warning CS8602: Dereference of a possibly null reference.
            // o.Method();
            Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(4, 1)
            );

        // PROTOTYPE What is the expected runtime behavior? NRE? The nullability checks should be adjusted correspondingly.
        // PROTOTYPE Revisit when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "Method");
    }

    [Fact]
    public void ExtensionMemberLookup_InstanceVsStatic()
    {
        var src = """
object o = new object();
o.Method();
_ = o.Property;

implicit extension E for object
{
    public static void Method() => throw null;
    public static int Property => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,1): error CS0176: Member 'E.Method()' cannot be accessed with an instance reference; qualify it with a type name instead
            // o.Method();
            Diagnostic(ErrorCode.ERR_ObjectProhibited, "o.Method").WithArguments("E.Method()").WithLocation(2, 1),
            // (3,5): error CS0176: Member 'E.Property' cannot be accessed with an instance reference; qualify it with a type name instead
            // _ = o.Property;
            Diagnostic(ErrorCode.ERR_ObjectProhibited, "o.Property").WithArguments("E.Property").WithLocation(3, 5)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var method = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.Method");
        Assert.Null(model.GetSymbolInfo(method).Symbol);
        Assert.Empty(model.GetMemberGroup(method));

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.Property");
        Assert.Null(model.GetSymbolInfo(property).Symbol);
        Assert.Empty(model.GetMemberGroup(property));
    }

    [Fact]
    public void ExtensionMemberLookup_StaticVsInstance()
    {
        var src = """
_ = object.Property;
_ = object.Field;

public implicit extension E for object
{
    public int Property => 0;
    public int Field = 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,5): error CS0120: An object reference is required for the non-static field, method, or property 'E.Property'
            // _ = object.Property;
            Diagnostic(ErrorCode.ERR_ObjectRequired, "object.Property").WithArguments("E.Property").WithLocation(1, 5),
            // (2,5): error CS0120: An object reference is required for the non-static field, method, or property 'E.Field'
            // _ = object.Field;
            Diagnostic(ErrorCode.ERR_ObjectRequired, "object.Field").WithArguments("E.Field").WithLocation(2, 5),
            // (7,16): error CS9313: 'E.Field': cannot declare instance members with state in extension types.
            //     public int Field = 0;
            Diagnostic(ErrorCode.ERR_StateInExtension, "Field").WithArguments("E.Field").WithLocation(7, 16)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Null(model.GetSymbolInfo(property).Symbol);
        Assert.Empty(model.GetMemberGroup(property));

        var field = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Field");
        Assert.Null(model.GetSymbolInfo(field).Symbol);
        Assert.Empty(model.GetMemberGroup(field));
    }

    [Fact]
    public void ExtensionMemberLookup_StaticVsInstance_Method()
    {
        var src = """
object.Method();

implicit extension E for object
{
    public void Method() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,1): error CS0120: An object reference is required for the non-static field, method, or property 'E.Method()'
            // object.Method();
            Diagnostic(ErrorCode.ERR_ObjectRequired, "object.Method").WithArguments("E.Method()").WithLocation(1, 1)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var method = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Method");
        Assert.Null(model.GetSymbolInfo(method).Symbol);
        Assert.Empty(model.GetMemberGroup(method));
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ExtensionMemberLookup_ColorColor_Property()
    {
        var src = """
class C
{
    static void M(C C)
    {
        C.Property = 42;
    }
}

implicit extension E for C
{
    public int Property
    {
        set
        {
            System.Console.Write("Property");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "Property");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property");
        Assert.Equal("System.Int32 E.Property { set; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property));
    }

    [Fact]
    public void ExtensionMemberLookup_ColorColor_Method()
    {
        var src = """
class C
{
    static void M(C C)
    {
        C.Method();
    }
}

implicit extension E for C
{
    public void Method()
    {
        System.Console.Write("Method ");
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "Method");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var method = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Equal("void E.Method()", model.GetSymbolInfo(method).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(method)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionMemberLookup_ColorColor_Static_Property()
    {
        var src = """
C.M(null);

class C
{
    public static void M(C C)
    {
        System.Console.Write(C.Property.ToString());
    }
}

implicit extension E for C
{
    public static int Property => 42;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property));

        var receiver = property.Expression;
        Assert.Equal("C", model.GetSymbolInfo(receiver).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_ColorColor_Static_Method()
    {
        var src = """
C.M(null);

class C
{
    public static void M(C C)
    {
        C.Method();
    }
}

implicit extension E for C
{
    public static void Method()
    {
        System.Console.Write("Method");
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var method = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Equal("void E.Method()", model.GetSymbolInfo(method).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(method)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionMemberLookup_AttributeProperty()
    {
        var src = """
[My(Property = 0)]
class MyAttribute : System.Attribute
{
}

[My(Property = 1)]
implicit extension E for MyAttribute
{
    [My(Property = 2)]
    public int Property
    {
        [My(Property = 3)]
        get => throw null;

        [My(Property = 4)]
        set => throw null;
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (1,5): error CS0246: The type or namespace name 'Property' could not be found (are you missing a using directive or an assembly reference?)
            // [My(Property = 0)]
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Property").WithArguments("Property").WithLocation(1, 5),
            // (6,5): error CS0246: The type or namespace name 'Property' could not be found (are you missing a using directive or an assembly reference?)
            // [My(Property = 1)]
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Property").WithArguments("Property").WithLocation(6, 5),
            // (9,9): error CS0246: The type or namespace name 'Property' could not be found (are you missing a using directive or an assembly reference?)
            //     [My(Property = 2)]
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Property").WithArguments("Property").WithLocation(9, 9),
            // (12,13): error CS0246: The type or namespace name 'Property' could not be found (are you missing a using directive or an assembly reference?)
            //         [My(Property = 3)]
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Property").WithArguments("Property").WithLocation(12, 13),
            // (15,13): error CS0246: The type or namespace name 'Property' could not be found (are you missing a using directive or an assembly reference?)
            //         [My(Property = 4)]
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Property").WithArguments("Property").WithLocation(15, 13)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_AttributeValue_SimpleName()
    {
        var src = """
[My(Property = Constant)]
class MyAttribute : System.Attribute
{
    public int Property { get; set; }
}

implicit extension E for MyAttribute
{
    public const int Constant = 42;
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (1,16): error CS0103: The name 'Constant' does not exist in the current context
            // [My(Property = Constant)]
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Constant").WithArguments("Constant").WithLocation(1, 16)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_AttributeValue_MemberAccess()
    {
        var src = """
[My(Property = MyAttribute.Constant)]
class MyAttribute : System.Attribute
{
    public int Property { get; set; }
}

implicit extension E for MyAttribute
{
    public const int Constant = 42;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp,
            sourceSymbolValidator: attributeValidator, symbolValidator: attributeValidator);

        return;

        static void attributeValidator(ModuleSymbol m)
        {
            var attributeType = m.GlobalNamespace.GetTypeMember("MyAttribute");
            var attributes = attributeType.GetAttributes();
            Assert.Equal(1, attributes.Length);
            attributes[0].VerifyNamedArgumentValue(0, "Property", TypedConstantKind.Primitive, 42);
            Assert.Equal("MyAttribute(Property = 42)", attributes[0].ToString());
        };
    }

    [Fact]
    public void ExtensionMemberLookup_AttributeValue_MemberAccess_NotAConstant()
    {
        var src = """
[My(Property = MyAttribute.NotConstant)]
class MyAttribute : System.Attribute
{
    public int Property { get; set; }
}

implicit extension E for MyAttribute
{
    public static int NotConstant = 42;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,16): error CS0182: An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type
            // [My(Property = MyAttribute.NotConstant)]
            Diagnostic(ErrorCode.ERR_BadAttributeArgument, "MyAttribute.NotConstant").WithLocation(1, 16)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_Literals_Methods()
    {
        var src = """
1.M();
2L.M();
"hello".M();

implicit extension E1 for int
{
    public void M()
    {
        System.Console.Write("M(int) ");
    }
}

implicit extension E2 for long
{
    public void M()
    {
        System.Console.Write("M(long) ");
    }
}

implicit extension E3 for string
{
    public void M()
    {
        System.Console.Write("M(string) ");
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "M(int) M(long) M(string)");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var intM = GetSyntax<MemberAccessExpressionSyntax>(tree, "1.M");
        Assert.Equal("void E1.M()", model.GetSymbolInfo(intM).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(intM)); // PROTOTYPE need to fix the semantic model

        var longM = GetSyntax<MemberAccessExpressionSyntax>(tree, "2L.M");
        Assert.Equal("void E2.M()", model.GetSymbolInfo(longM).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(longM)); // PROTOTYPE need to fix the semantic model

        var stringM = GetSyntax<MemberAccessExpressionSyntax>(tree, "\"hello\".M");
        Assert.Equal("void E3.M()", model.GetSymbolInfo(stringM).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(stringM)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionMemberLookup_Literals_Properties()
    {
        var src = """
_ = 1.Property;
_ = 2L.Property;
_ = "hello".Property;

implicit extension E1 for int
{
    public int Property
    {
        get
        {
            System.Console.Write("Property(int) ");
            return 42;
        }
    }
}

implicit extension E2 for long
{
    public int Property
    {
        get
        {
            System.Console.Write("Property(long) ");
            return 42;
        }
    }
}

implicit extension E3 for string
{
    public int Property
    {
        get
        {
            System.Console.Write("Property(string) ");
            return 42;
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "Property(int) Property(long) Property(string)");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var intM = GetSyntax<MemberAccessExpressionSyntax>(tree, "1.Property");
        Assert.Equal("System.Int32 E1.Property { get; }", model.GetSymbolInfo(intM).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(intM)); // PROTOTYPE need to fix the semantic model

        var longM = GetSyntax<MemberAccessExpressionSyntax>(tree, "2L.Property");
        Assert.Equal("System.Int32 E2.Property { get; }", model.GetSymbolInfo(longM).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(longM)); // PROTOTYPE need to fix the semantic model

        var stringM = GetSyntax<MemberAccessExpressionSyntax>(tree, "\"hello\".Property");
        Assert.Equal("System.Int32 E3.Property { get; }", model.GetSymbolInfo(stringM).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(stringM)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionMemberLookup_InTypeConstraint_Generic()
    {
        var src = """
class C { }

implicit extension E for C
{
    public class Nested<T> where T : C.Nested<T> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var nested = comp.GlobalNamespace.GetTypeMember("E").GetTypeMember("Nested");
        var t = nested.TypeParameters.Single();
        Assert.Equal("E.Nested<T>", t.ConstraintTypes().Single().ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_InTypeConstraint_Generic_OuterScope()
    {
        var src = """
public class C { }

public implicit extension E1 for C
{
    public class Nested<T> { }
}

namespace N
{
    public class D<T> where T : C.Nested<T> { }

    public static class E2
    {
        public static void Nested(this C c) { }
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var d = comp.GetTypeByMetadataName("N.D`1");
        Assert.Equal("E1.Nested<T>", d.TypeParameters.Single().ConstraintTypes().Single().ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_InTypeConstraint_NonGeneric()
    {
        var src = """
class C { }
class D<T> where T : C.Nested { }

implicit extension E for C
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var d = comp.GlobalNamespace.GetTypeMember("D");
        var t = d.TypeParameters.Single();
        Assert.Equal("E.Nested", t.ConstraintTypes().Single().ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_InTypeConstraint_NonGeneric_OnExtensionType()
    {
        var src = """
class C<T> { }

implicit extension E<U> for C<U> where U : C<U>.Nested
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var e = comp.GlobalNamespace.GetTypeMember("E");
        var u = e.TypeParameters.Single();
        Assert.Equal("E<U>.Nested", u.ConstraintTypes().Single().ToTestDisplayString());
        Assert.False(u.ConstraintTypes().Single().IsErrorType());
    }

    [Fact]
    public void ExtensionMemberLookup_InTypeConstraint_WithInaccessibleNestedType()
    {
        var src = """
class C
{
    protected class Nested { } // inaccessible
}

class D<T> where T : C.Nested { }

implicit extension E for C
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var d = comp.GlobalNamespace.GetTypeMember("D");
        var t = d.TypeParameters.Single();
        Assert.Equal("E.Nested", t.ConstraintTypes().Single().ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_InTypeConstraint_Generic_WithInaccessibleNestedType()
    {
        var src = """
class C
{
    protected class Nested<T> { } // inaccessible
}

class D<T> where T : C.Nested<int> { }

implicit extension E for C
{
    public class Nested<T> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var d = comp.GlobalNamespace.GetTypeMember("D");
        var t = d.TypeParameters.Single();
        Assert.Equal("E.Nested<System.Int32>", t.ConstraintTypes().Single().ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_InTypeConstraint_AttemptingAmbiguousNestedType()
    {
        var ilSrc = """
.class public auto ansi beforefieldinit C extends [mscorlib]System.Object
{
    .class nested public auto ansi beforefieldinit Nested extends [mscorlib]System.Object
    {
    }

    .class nested public auto ansi beforefieldinit Nested extends [mscorlib]System.Object
    {
    }
}
""";

        var src = """
class D<T> where T : C.Nested { }

implicit extension E for C
{
    public class Nested { }
}
""";
        var comp = CreateCompilationWithIL(src, ilSrc);
        comp.VerifyDiagnostics();

        var d = comp.GlobalNamespace.GetTypeMember("D");
        var t = d.TypeParameters.Single();
        Assert.Equal("C.Nested", t.ConstraintTypes().Single().ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_InTypeConstraint_Generic_AttemptingAmbiguousNestedType()
    {
        var ilSrc = """
.class public auto ansi beforefieldinit C extends [mscorlib]System.Object
{
    .class nested public auto ansi beforefieldinit Nested`1<T> extends [mscorlib]System.Object
    {
    }

    .class nested public auto ansi beforefieldinit Nested`1<valuetype .ctor ([mscorlib]System.ValueType) T> extends [mscorlib]System.Object
    {
    }
}
""";

        var src = """
class D<T> where T : C.Nested<int> { }

implicit extension E for C
{
    public class Nested<T> { }
}
""";
        var comp = CreateCompilationWithIL(src, ilSrc);
        comp.VerifyDiagnostics();

        var d = comp.GlobalNamespace.GetTypeMember("D");
        var t = d.TypeParameters.Single();
        Assert.Equal("C.Nested<System.Int32>", t.ConstraintTypes().Single().ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_InTypeConstraint_AsTypeParameter()
    {
        var src = """
class C { }

implicit extension E for C
{
    public class Nested<T> where T : C.Nested<C.Nested<T>> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,25): error CS0311: The type 'E.Nested<T>' cannot be used as type parameter 'T' in the generic type or method 'E.Nested<T>'. There is no implicit reference conversion from 'E.Nested<T>' to 'E.Nested<E.Nested<E.Nested<T>>>'.
            //     public class Nested<T> where T : C.Nested<C.Nested<T>> { }
            Diagnostic(ErrorCode.ERR_GenericConstraintNotSatisfiedRefType, "T").WithArguments("E.Nested<T>", "E.Nested<E.Nested<E.Nested<T>>>", "T", "E.Nested<T>").WithLocation(5, 25)
            );

        var nested = comp.GlobalNamespace.GetTypeMember("E").GetTypeMember("Nested");
        var t = nested.TypeParameters.Single();
        Assert.Equal("E.Nested<E.Nested<T>>", t.ConstraintTypes().Single().ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_SimpleName()
    {
        var src = """
class C
{
    void M()
    {
        Method(); // 1
        StaticMethod(); // 2
        _ = Property; // 3
        _ = StaticProperty; // 4
        _ = Field; // 5
        Type.M2(); // 6
    }
}

implicit extension E for C
{
    public void Method() { }
    public static void StaticMethod() { }
    public int Property => 0;
    public static int StaticProperty => 0;
    public static int Field = 42;
    public class Type
    {
        public void M2() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,9): error CS0103: The name 'Method' does not exist in the current context
            //         Method(); // 1
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Method").WithArguments("Method").WithLocation(5, 9),
            // (6,9): error CS0103: The name 'StaticMethod' does not exist in the current context
            //         StaticMethod(); // 2
            Diagnostic(ErrorCode.ERR_NameNotInContext, "StaticMethod").WithArguments("StaticMethod").WithLocation(6, 9),
            // (7,13): error CS0103: The name 'Property' does not exist in the current context
            //         _ = Property; // 3
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Property").WithArguments("Property").WithLocation(7, 13),
            // (8,13): error CS0103: The name 'StaticProperty' does not exist in the current context
            //         _ = StaticProperty; // 4
            Diagnostic(ErrorCode.ERR_NameNotInContext, "StaticProperty").WithArguments("StaticProperty").WithLocation(8, 13),
            // (9,13): error CS0103: The name 'Field' does not exist in the current context
            //         _ = Field; // 5
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Field").WithArguments("Field").WithLocation(9, 13),
            // (10,9): error CS0103: The name 'Type' does not exist in the current context
            //         Type.M2(); // 6
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Type").WithArguments("Type").WithLocation(10, 9)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_AsFunctionType_StaticMethod()
    {
        var src = """
var x = C.Method;
System.Console.Write(x());

class C { }

implicit extension E for C
{
    public static string Method() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_AsFunctionType_StaticMethod_Overloads()
    {
        var src = """
class C
{
    void M()
    {
        var x = C.Method;
    }
}

implicit extension E for C
{
    public static string Method() => throw null;
    public static string Method(int i) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,17): error CS8917: The delegate type could not be inferred.
            //         var x = C.Method;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "C.Method").WithLocation(5, 17)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void ExtensionMemberLookup_AsFunctionType_StaticMethod_Duplicate(bool e1BeforeE2)
    {
        var e1 = """
implicit extension E1 for C
{
    public static string Method() => throw null;
}
""";

        var e2 = """
implicit extension E2 for C
{
    public static string Method() => throw null;
}
""";

        var src = $$"""
var x = C.Method;
class C { }

{{(e1BeforeE2 ? e1 : e2)}}
{{(e1BeforeE2 ? e2 : e1)}}
""";
        var comp = CreateCompilation(src);
        if (!e1BeforeE2)
        {
            comp.VerifyDiagnostics(
                // (1,9): error CS0121: The call is ambiguous between the following methods or properties: 'E2.Method()' and 'E1.Method()'
                // var x = C.Method;
                Diagnostic(ErrorCode.ERR_AmbigCall, "C.Method").WithArguments("E2.Method()", "E1.Method()").WithLocation(1, 9));
        }
        else
        {
            comp.VerifyDiagnostics(
                // (1,9): error CS0121: The call is ambiguous between the following methods or properties: 'E1.Method()' and 'E2.Method()'
                // var x = C.Method;
                Diagnostic(ErrorCode.ERR_AmbigCall, "C.Method").WithArguments("E1.Method()", "E2.Method()").WithLocation(1, 9));
        }

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        // PROTOTYPE need to fix the semantic model
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMemberLookup_AsFunctionType_StaticMethod_Difference()
    {
        var src = """
class C
{
    void M()
    {
        var x = C.Method;
    }
}

implicit extension E1 for C
{
    public static string Method() => throw null;
}
implicit extension E2 for C
{
    public static int Method(int i) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,17): error CS8917: The delegate type could not be inferred.
            //         var x = C.Method;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "C.Method").WithLocation(5, 17)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_AsFunctionType_StaticMethod_Duplicate_FromDifferentScopes()
    {
        var src = """
using N;

class C
{
    void M()
    {
        var x = C.Method;
    }
}

implicit extension E1 for C
{
    public static string Method() => throw null;
}

namespace N
{
    implicit extension E2 for C
    {
        public static string Method() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1));
        // PROTOTYPE we will want to merge extension type members and extension methods, resulting in an error here

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_AsFunctionType_StaticMethod_Difference_FromDifferentScopes()
    {
        var src = """
using N;

var x = C.Method;
System.Console.Write(x(42).ToString());

class C { }

implicit extension E1 for C
{
    public static int Method(int i) => i;
}

namespace N
{
    implicit extension E2 for C
    {
        public static string Method() => throw null;
    }
}
""";
        // PROTOTYPE(static) for static scenarios, we should not require TargetFramework.Net70, enabling us to execute on Desktop (applies to all static tests in this file)
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("System.Func<System.Int32, System.Int32> x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_AsFunctionType_StaticMethod_FromStaticUsing()
    {
        // PROTOTYPE should a static using of extended type bring the static extension members in scope?
        var src = """
using static C;

var x = Method;

class C { }

implicit extension E for C
{
    public static string Method() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using static C;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using static C;").WithLocation(1, 1),
            // (3,9): error CS0103: The name 'Method' does not exist in the current context
            // var x = Method;
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Method").WithArguments("Method").WithLocation(3, 9)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_AsFunctionType_StaticMethod_WithTypeArgument()
    {
        var src = """
var x = C.Method<int>;
x();

class C { }

implicit extension E for C
{
    public static T Method<T>() { System.Console.Write("ran"); return default; }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("System.Func<System.Int32> x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_AsFunctionType_StaticMethod_WithTypeArgument_WrongArity()
    {
        var src = """
class C
{
    void M()
    {
        var x = C.Method<int>;
    }
}

implicit extension E for C
{
    public static T Method<T, U>(U u) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,19): error CS0117: 'C' does not contain a definition for 'Method'
            //         var x = C.Method<int>;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Method<int>").WithArguments("C", "Method").WithLocation(5, 19)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ExtensionMemberLookup_AsFunctionType_InstanceMethod()
    {
        var src = """
class C
{
    void M()
    {
        var x = this.Method;
    }
}

implicit extension E for C
{
    public string Method() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void InferredVariable_TypeReceiver_StaticMethod_DifferentSignatures()
    {
        var src = """
var x = C.Method;

class C { }

implicit extension E1 for C
{
    public static string Method() => throw null;
}
implicit extension E2 for C
{
    public static int Method(int i) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,9): error CS8917: The delegate type could not be inferred.
            // var x = C.Method;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "C.Method").WithLocation(1, 9)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void InferredVariable_TypeReceiver_StaticMethod_Duplicate_FromDifferentScopes()
    {
        var src = """
using N;

class C
{
    public static void Main()
    {
        var x = C.Method;
        x();
    }
}

implicit extension E1 for C
{
    public static void Method() { System.Console.Write("ran"); }
}

namespace N
{
    implicit extension E2 for C
    {
        public static void Method() => throw null;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("System.Action x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Equal("void E1.Method()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void InferredVariable_TypeReceiver_StaticMethod_DifferentSignatures_FromDifferentScopes()
    {
        var src = """
using N;

var x = object.Method;
x(42);

implicit extension E1 for object
{
    public static void Method(int i) { System.Console.Write("ran"); }
}

namespace N
{
    implicit extension E2 for object
    {
        public static void Method() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("System.Action<System.Int32> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Method");
        Assert.Equal("void E1.Method(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void InferredVariable_TypeReceiver_GenericType()
    {
        var src = """
var x = C<int>.StaticType<string>;
var y = E<int>.StaticType<string>;

class C<T> { }

implicit extension E<T> for C<T>
{
    public static class StaticType<U> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,1): error CS0723: Cannot declare a variable of static type 'E<int>.StaticType<string>'
            // var x = C<int>.StaticType<string>;
            Diagnostic(ErrorCode.ERR_VarDeclIsStaticClass, "var").WithArguments("E<int>.StaticType<string>").WithLocation(1, 1),
            // (1,9): error CS0119: 'E<int>.StaticType<string>' is a type, which is not valid in the given context
            // var x = C<int>.StaticType<string>;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "C<int>.StaticType<string>").WithArguments("E<int>.StaticType<string>", "type").WithLocation(1, 9),
            // (2,1): error CS0723: Cannot declare a variable of static type 'E<int>.StaticType<string>'
            // var y = E<int>.StaticType<string>;
            Diagnostic(ErrorCode.ERR_VarDeclIsStaticClass, "var").WithArguments("E<int>.StaticType<string>").WithLocation(2, 1),
            // (2,9): error CS0119: 'E<int>.StaticType<string>' is a type, which is not valid in the given context
            // var y = E<int>.StaticType<string>;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "E<int>.StaticType<string>").WithArguments("E<int>.StaticType<string>", "type").WithLocation(2, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.StaticType<string>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void InferredVariable_TypeReceiver_GenericType_BrokenConstraint()
    {
        var src = """
var x = C<int>.StaticType<string>;

class C<T> { }

implicit extension E<T> for C<T>
{
    public static class StaticType<U> where U : struct { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,1): error CS0723: Cannot declare a variable of static type 'E<int>.StaticType<string>'
            // var x = C<int>.StaticType<string>;
            Diagnostic(ErrorCode.ERR_VarDeclIsStaticClass, "var").WithArguments("E<int>.StaticType<string>").WithLocation(1, 1),
            // (1,9): error CS0119: 'E<int>.StaticType<string>' is a type, which is not valid in the given context
            // var x = C<int>.StaticType<string>;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "C<int>.StaticType<string>").WithArguments("E<int>.StaticType<string>", "type").WithLocation(1, 9),
            // (1,27): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'U' in the generic type or method 'E<int>.StaticType<U>'
            // var x = C<int>.StaticType<string>;
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "string").WithArguments("E<int>.StaticType<U>", "U", "string").WithLocation(1, 27));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.StaticType<string>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void InferredVariable_TypeReceiver_GenericType_OmittedTypeArgument()
    {
        var src = """
var x = C<int>.StaticType<>;

class C<T> { }

implicit extension E<T> for C<T>
{
    public static class StaticType<U> where U : struct { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,1): error CS0723: Cannot declare a variable of static type 'E<int>.StaticType<U>'
            // var x = C<int>.StaticType<>;
            Diagnostic(ErrorCode.ERR_VarDeclIsStaticClass, "var").WithArguments("E<int>.StaticType<U>").WithLocation(1, 1),
            // (1,9): error CS8389: Omitting the type argument is not allowed in the current context
            // var x = C<int>.StaticType<>;
            Diagnostic(ErrorCode.ERR_OmittedTypeArgument, "C<int>.StaticType<>").WithLocation(1, 9),
            // (1,9): error CS0305: Using the generic type 'E<int>.StaticType<U>' requires 1 type arguments
            // var x = C<int>.StaticType<>;
            Diagnostic(ErrorCode.ERR_BadArity, "C<int>.StaticType<>").WithArguments("E<int>.StaticType<U>", "type", "1").WithLocation(1, 9),
            // (1,9): error CS0119: 'E<int>.StaticType<U>' is a type, which is not valid in the given context
            // var x = C<int>.StaticType<>;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "C<int>.StaticType<>").WithArguments("E<int>.StaticType<U>", "type").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.StaticType<>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void ExtensionMemberLookup_AsFunctionType_StaticMethod_OnExtension()
    {
        var src = """
class C
{
    void M()
    {
        var x = E.Method;
    }
}

implicit extension E for C
{
    public static string Method() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_AsFunctionType_StaticMethod_OnExtension_FromStaticUsing()
    {
        var src = """
using static E;

class C
{
    void M()
    {
        var x = Method;
    }
}

implicit extension E for C
{
    public static string Method() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_AsFunctionType_InstanceMethod_OnExtension()
    {
        var src = """
class C { }

implicit extension E for C
{
    public string Method() => throw null;

    void M()
    {
        var x = this.Method;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact(Skip = "PROTOTYPE: crash when binding foreach")]
    public void ExtensionMemberLookup_PatternBased_ForEach_NoMethod()
    {
        var src = """
foreach (var x in new C())
{
    System.Console.Write(x);
    break;
}

class C { }
class D { }

implicit extension E1 for C
{
    public D GetEnumerator() => new D();
}
implicit extension E2 for D
{
    public bool MoveNext() => true;
    public int Current => 42;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,19): error CS1579: foreach statement cannot operate on variables of type 'C' because 'C' does not contain a public instance or extension definition for 'GetEnumerator'
            // foreach (var x in new C())
            Diagnostic(ErrorCode.ERR_ForEachMissingMember, "new C()").WithArguments("C", "GetEnumerator").WithLocation(1, 19)
            );
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "42");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var loop = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().Single();
        Assert.Null(model.GetForEachStatementInfo(loop).GetEnumeratorMethod);
        Assert.Null(model.GetForEachStatementInfo(loop).MoveNextMethod);
        Assert.Null(model.GetForEachStatementInfo(loop).CurrentProperty);
    }

    [Fact(Skip = "PROTOTYPE: crash when binding foreach")]
    public void ExtensionMemberLookup_PatternBased_ForEach_NoApplicableMethod()
    {
        var src = """
foreach (var x in new C())
{
    System.Console.Write(x);
    break;
}

class C
{
    public void GetEnumerator(int notApplicable) { } // not applicable
}
class D { }

implicit extension E1 for C
{
    public D GetEnumerator() => new D();
}
implicit extension E2 for D
{
    public bool MoveNext() => true;
    public int Current => 42;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,19): error CS1579: foreach statement cannot operate on variables of type 'C' because 'C' does not contain a public instance or extension definition for 'GetEnumerator'
            // foreach (var x in new C())
            Diagnostic(ErrorCode.ERR_ForEachMissingMember, "new C()").WithArguments("C", "GetEnumerator").WithLocation(1, 19)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var loop = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().Single();
        Assert.Null(model.GetForEachStatementInfo(loop).GetEnumeratorMethod);
        Assert.Null(model.GetForEachStatementInfo(loop).MoveNextMethod);
        Assert.Null(model.GetForEachStatementInfo(loop).CurrentProperty);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_ForEach_WrongArity()
    {
        var src = """
using System.Collections;

foreach (var x in new C()) { }

class C { }

implicit extension E for C
{
    public IEnumerator GetEnumerator<T>() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,19): error CS0411: The type arguments for method 'E.GetEnumerator<T>()' cannot be inferred from the usage. Try specifying the type arguments explicitly.
            // foreach (var x in new C()) { }
            Diagnostic(ErrorCode.ERR_CantInferMethTypeArgs, "new C()").WithArguments("E.GetEnumerator<T>()").WithLocation(3, 19),
            // (3,19): error CS1579: foreach statement cannot operate on variables of type 'C' because 'C' does not contain a public instance or extension definition for 'GetEnumerator'
            // foreach (var x in new C()) { }
            Diagnostic(ErrorCode.ERR_ForEachMissingMember, "new C()").WithArguments("C", "GetEnumerator").WithLocation(3, 19)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var loop = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().Single();
        Assert.Null(model.GetForEachStatementInfo(loop).GetEnumeratorMethod);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_ForEach_NonInvocable()
    {
        var src = """
using System.Collections;

foreach (var x in new C()) { }

class C { }

implicit extension E for C
{
    public IEnumerator GetEnumerator => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,19): error CS1579: foreach statement cannot operate on variables of type 'C' because 'C' does not contain a public instance or extension definition for 'GetEnumerator'
            // foreach (var x in new C()) { }
            Diagnostic(ErrorCode.ERR_ForEachMissingMember, "new C()").WithArguments("C", "GetEnumerator").WithLocation(3, 19)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var loop = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().Single();
        Assert.Null(model.GetForEachStatementInfo(loop).GetEnumeratorMethod);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Deconstruct_NoMethod()
    {
        var src = """
var (x, y) = new C();
System.Console.Write((x, y));

class C { }

implicit extension E for C
{
    public void Deconstruct(out int i, out int j)
    {
        i = 42;
        j = 43;
    }
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE confirm when spec'ing pattern-based deconstruction
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "(42, 43)");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var deconstruction = tree.GetRoot().DescendantNodes().OfType<AssignmentExpressionSyntax>().First();

        Assert.Equal("void E.Deconstruct(out System.Int32 i, out System.Int32 j)",
            model.GetDeconstructionInfo(deconstruction).Method.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Deconstruct_FallbackToExtensionMethod()
    {
        // If the method from the extension type is not applicable, we fall back
        // to a Deconstruct extension method
        var src = """
var (x, y) = new C();
System.Console.Write((x, y));

public class C { }

implicit extension E1 for C
{
    public void Deconstruct(int inapplicable) => throw null;
}

public static class E2
{
    public static void Deconstruct(this C c, out int i, out int j)
    {
        i = 42;
        j = 43;
    }
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE confirm when spec'ing pattern-based deconstruction
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "(42, 43)");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var deconstruction = tree.GetRoot().DescendantNodes().OfType<AssignmentExpressionSyntax>().First();

        Assert.Equal("void E2.Deconstruct(this C c, out System.Int32 i, out System.Int32 j)",
            model.GetDeconstructionInfo(deconstruction).Method.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Deconstruct_DelegateTypeProperty()
    {
        var src = """
var (x, y) = new C();

class C { }

delegate void D(out int i, out int j);

implicit extension E for C
{
    public D Deconstruct => throw null;
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE revisit pattern-based deconstruction
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "(42, 43)");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var deconstruction = tree.GetRoot().DescendantNodes().OfType<AssignmentExpressionSyntax>().First();

        Assert.Equal("void D.Invoke(out System.Int32 i, out System.Int32 j)",
            model.GetDeconstructionInfo(deconstruction).Method.ToTestDisplayString());
    }

    [Fact(Skip = "PROTOTYPE Asserts in BindDynamicInvocation")]
    public void ExtensionMemberLookup_PatternBased_Deconstruct_DynamicProperty()
    {
        var src = """
var (x, y) = new C();

class C { }

implicit extension E for C
{
    public dynamic Deconstruct => throw null;
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE revisit pattern-based deconstruction
        comp.VerifyDiagnostics(
            // (1,6): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'x'.
            // var (x, y) = new C();
            Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "x").WithArguments("x").WithLocation(1, 6),
            // (1,9): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'y'.
            // var (x, y) = new C();
            Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "y").WithArguments("y").WithLocation(1, 9),
            // (1,14): error CS8129: No suitable 'Deconstruct' instance or extension method was found for type 'C', with 2 out parameters and a void return type.
            // var (x, y) = new C();
            Diagnostic(ErrorCode.ERR_MissingDeconstruct, "new C()").WithArguments("C", "2").WithLocation(1, 14)
            );
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "(42, 43)");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var deconstruction = tree.GetRoot().DescendantNodes().OfType<AssignmentExpressionSyntax>().First();

        Assert.Null(model.GetDeconstructionInfo(deconstruction).Method);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Deconstruct_NoApplicableMethod()
    {
        var src = """
var (x, y) = new C();
System.Console.Write((x, y));

class C
{
    public void Deconstruct() { } // not applicable
}

implicit extension E for C
{
    public void Deconstruct(out int i, out int j)
    {
        i = 42;
        j = 43;
    }
}
""";
        // PROTOTYPE confirm when spec'ing pattern-based deconstruction
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "(42, 43)");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var deconstruction = tree.GetRoot().DescendantNodes().OfType<AssignmentExpressionSyntax>().First();

        Assert.Equal("void E.Deconstruct(out System.Int32 i, out System.Int32 j)",
            model.GetDeconstructionInfo(deconstruction).Method.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Dispose_Async_NoMethod()
    {
        var src = """
using System.Threading.Tasks;

/*<bind>*/
await using var x = new C();
/*</bind>*/

class C { }

implicit extension E for C
{
    public async Task DisposeAsync()
    {
        System.Console.Write("RAN");
        await Task.Yield();
    }
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE confirm when spec'ing pattern-based disposal
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "RAN");

        //        string expectedOperationTree = """
        //IUsingDeclarationOperation(IsAsynchronous: True, DisposeMethod: System.Threading.Tasks.Task E.DisposeAsync()) (OperationKind.UsingDeclaration, Type: null) (Syntax: 'await using ...  = new C();')
        //DeclarationGroup:
        //  IVariableDeclarationGroupOperation (1 declarations) (OperationKind.VariableDeclarationGroup, Type: null, IsImplicit) (Syntax: 'await using ...  = new C();')
        //    IVariableDeclarationOperation (1 declarators) (OperationKind.VariableDeclaration, Type: null) (Syntax: 'var x = new C()')
        //      Declarators:
        //          IVariableDeclaratorOperation (Symbol: C x) (OperationKind.VariableDeclarator, Type: null) (Syntax: 'x = new C()')
        //            Initializer:
        //              IVariableInitializerOperation (OperationKind.VariableInitializer, Type: null) (Syntax: '= new C()')
        //                IObjectCreationOperation (Constructor: C..ctor()) (OperationKind.ObjectCreation, Type: C) (Syntax: 'new C()')
        //                  Arguments(0)
        //                  Initializer:
        //                    null
        //      Initializer:
        //        null
        //""";
        //        var expectedDiagnostics = DiagnosticDescription.None;

        //        VerifyOperationTreeAndDiagnosticsForTest<LocalDeclarationStatementSyntax>(src,
        //            expectedOperationTree, expectedDiagnostics);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Dispose_Async_DelegateTypeProperty()
    {
        var src = """
using System.Threading.Tasks;

await using var x = new C();

class C { }

implicit extension E for C
{
    public System.Func<Task> DisposeAsync => throw null;
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE(instance) confirm when spec'ing pattern-based disposal
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Dispose_Async_NoApplicableMethod()
    {
        var src = """
using System.Threading.Tasks;

/*<bind>*/
await using var x = new C();
/*</bind>*/

class C
{
    public Task DisposeAsync(int notApplicable) => throw null; // not applicable
}

implicit extension E for C
{
    public async Task DisposeAsync()
    {
        System.Console.Write("RAN");
        await Task.Yield();
    }
}
""";
        // PROTOTYPE confirm when spec'ing pattern-based disposal
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "RAN");

        // PROTOTYPE verify IOperation
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Dispose_RefStruct()
    {
        var src = """
using var x = new S();

ref struct S { }

implicit extension E for S
{
    public void Dispose()
    {
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,1): error CS1674: 'S': type used in a using statement must be implicitly convertible to 'System.IDisposable'.
            // using var x = new S();
            Diagnostic(ErrorCode.ERR_NoConvToIDisp, "using var x = new S();").WithArguments("S").WithLocation(1, 1),
            // (5,26): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // implicit extension E for S
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "S").WithLocation(5, 26)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Fixed_NoMethod()
    {
        var text = @"
unsafe class C
{
    public static void Main()
    {
        fixed (int* p = new Fixable())
        {
            System.Console.WriteLine(p[1]);
        }
    }
}

class Fixable { }

implicit extension E for Fixable
{
    public ref int GetPinnableReference()
    {
        return ref (new int[] { 1, 2, 3 })[0];
    }
}
";
        var comp = CreateCompilation(text, options: TestOptions.UnsafeReleaseExe);
        // PROTOTYPE confirm when spec'ing pattern-based fixed
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //        var compVerifier = CompileAndVerify(comp, expectedOutput: @"2", verify: Verification.Fails);

        //        compVerifier.VerifyIL("C.Main", """
        //{
        //  // Code size       33 (0x21)
        //  .maxstack  2
        //  .locals init (pinned int& V_0)
        //  IL_0000:  newobj     "Fixable..ctor()"
        //  IL_0005:  dup
        //  IL_0006:  brtrue.s   IL_000d
        //  IL_0008:  pop
        //  IL_0009:  ldc.i4.0
        //  IL_000a:  conv.u
        //  IL_000b:  br.s       IL_0015
        //  IL_000d:  call       "ref int E.GetPinnableReference()"
        //  IL_0012:  stloc.0
        //  IL_0013:  ldloc.0
        //  IL_0014:  conv.u
        //  IL_0015:  ldc.i4.4
        //  IL_0016:  add
        //  IL_0017:  ldind.i4
        //  IL_0018:  call       "void System.Console.WriteLine(int)"
        //  IL_001d:  ldc.i4.0
        //  IL_001e:  conv.u
        //  IL_001f:  stloc.0
        //  IL_0020:  ret
        //}
        //""");
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Fixed_NoMethod_DelegateTypeProperty()
    {
        var text = @"
unsafe class C
{
    public static void Main()
    {
        fixed (int* p = new Fixable())
        {
            System.Console.WriteLine(p[1]);
        }
    }
}

class Fixable { }

delegate ref int MyDelegate();

implicit extension E for Fixable
{
    public MyDelegate GetPinnableReference => throw null;
}
";
        var comp = CreateCompilation(text, options: TestOptions.UnsafeReleaseExe);
        // PROTOTYPE confirm when spec'ing pattern-based fixed
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //        var compVerifier = CompileAndVerify(comp, expectedOutput: @"2", verify: Verification.Fails);

        //        compVerifier.VerifyIL("C.Main", """
        //{
        //  // Code size       33 (0x21)
        //  .maxstack  2
        //  .locals init (pinned int& V_0)
        //  IL_0000:  newobj     "Fixable..ctor()"
        //  IL_0005:  dup
        //  IL_0006:  brtrue.s   IL_000d
        //  IL_0008:  pop
        //  IL_0009:  ldc.i4.0
        //  IL_000a:  conv.u
        //  IL_000b:  br.s       IL_0015
        //  IL_000d:  call       "ref int E.GetPinnableReference()"
        //  IL_0012:  stloc.0
        //  IL_0013:  ldloc.0
        //  IL_0014:  conv.u
        //  IL_0015:  ldc.i4.4
        //  IL_0016:  add
        //  IL_0017:  ldind.i4
        //  IL_0018:  call       "void System.Console.WriteLine(int)"
        //  IL_001d:  ldc.i4.0
        //  IL_001e:  conv.u
        //  IL_001f:  stloc.0
        //  IL_0020:  ret
        //}
        //""");
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Fixed_NoApplicableMethod()
    {
        var src = """
unsafe class C
{
    public static void Main()
    {
        fixed (int* p = new Fixable())
        {
            System.Console.WriteLine(p[1]);
        }
    }
}

class Fixable
{
    public ref int GetPinnableReference(int notApplicable) => throw null; // not applicable
}

implicit extension E for Fixable
{
    public ref int GetPinnableReference()
    {
        return ref (new int[] { 1, 2, 3 })[0];
    }
}
""";

        // PROTOTYPE confirm when spec'ing pattern-based fixed
        var comp = CreateCompilation(src, options: TestOptions.UnsafeReleaseExe);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "2");

        // PROTOTYPE verify IOperation
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Fixed_Static()
    {
        var text = @"
unsafe class C
{
    public static void Main()
    {
        fixed (int* p = new Fixable())
        {
        }
    }
}

class Fixable { }

implicit extension E for Fixable
{
    public static ref int GetPinnableReference() => throw null;
}
";

        var comp = CreateCompilation(text, options: TestOptions.UnsafeReleaseExe);
        // PROTOTYPE confirm when spec'ing pattern-based fixed
        comp.VerifyDiagnostics(
            // (6,25): error CS0176: Member 'E.GetPinnableReference()' cannot be accessed with an instance reference; qualify it with a type name instead
            //         fixed (int* p = new Fixable())
            Diagnostic(ErrorCode.ERR_ObjectProhibited, "new Fixable()").WithArguments("E.GetPinnableReference()").WithLocation(6, 25),
            // (6,25): error CS8385: The given expression cannot be used in a fixed statement
            //         fixed (int* p = new Fixable())
            Diagnostic(ErrorCode.ERR_ExprCannotBeFixed, "new Fixable()").WithLocation(6, 25)
            );
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void ExtensionMemberLookup_PatternBased_Await_NoMethod()
    {
        var text = @"
using System;
using System.Runtime.CompilerServices;

int i = await new C();
System.Console.Write(i);

class C { }
class D { }

implicit extension E1 for C
{
    public D GetAwaiter() => new D();
}

implicit extension E2 for D : INotifyCompletion
{
    public bool IsCompleted => true;
    public int GetResult() => 42;
    public void OnCompleted(Action continuation) => throw null;
}
";

        var comp = CreateCompilation(text);
        // PROTOTYPE confirm when spec'ing pattern-based await
        comp.VerifyDiagnostics(
            // (5,9): error CS0117: 'D' does not contain a definition for 'IsCompleted'
            // int i = await new C();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "await new C()").WithArguments("D", "IsCompleted").WithLocation(5, 9),
            // (16,31): error CS9307: A base extension must be an extension type.
            // implicit extension E2 for D : INotifyCompletion
            Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "INotifyCompletion").WithLocation(16, 31)
            );
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members and adding interfaces
        //CompileAndVerify(comp, expectedOutput: "42");
    }

    [ConditionalFact(typeof(NoBaseExtensions))]
    public void ExtensionMemberLookup_PatternBased_Await_NoApplicableGetAwaiterMethod()
    {
        var text = @"
using System;
using System.Runtime.CompilerServices;

int i = await new C();
System.Console.Write(i);

class C
{
    public D GetAwaiter(int notApplicable) => throw null; // not applicable
}
class D { }

implicit extension E1 for C
{
    public D GetAwaiter() => new D();
}

implicit extension E2 for D : INotifyCompletion
{
    public bool IsCompleted => true;
    public int GetResult() => 42;
    public void OnCompleted(Action continuation) => throw null;
}
";

        // PROTOTYPE confirm when spec'ing pattern-based await
        // PROTOTYPE Revisit when adding support for emitting non-static members and adding interfaces
        var comp = CreateCompilation(text);
        comp.VerifyDiagnostics(
            // (5,9): error CS0117: 'D' does not contain a definition for 'IsCompleted'
            // int i = await new C();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "await new C()").WithArguments("D", "IsCompleted").WithLocation(5, 9),
            // (19,31): error CS9307: A base extension must be an extension type.
            // implicit extension E2 for D : INotifyCompletion
            Diagnostic(ErrorCode.ERR_OnlyBaseExtensionAllowed, "INotifyCompletion").WithLocation(19, 31)
            );
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(roles) enable once we can handle lowering/emit
    public void ExtensionMemberLookup_PatternBased_Await_ExtensionIsCompleted()
    {
        var text = @"
using System;
using System.Runtime.CompilerServices;

int i = await new C();
System.Console.Write(i);

class C
{
    public D GetAwaiter() => new D();
}

class D : INotifyCompletion
{
    public int GetResult() => 42;
    public void OnCompleted(Action continuation) => throw null;
}

implicit extension E for D
{
    public bool IsCompleted => true;
}
";

        // PROTOTYPE confirm when spec'ing pattern-based await
        var comp = CreateCompilation(text);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Await_ExtensionGetAwaiter()
    {
        var text = @"
using System;
using System.Runtime.CompilerServices;

int i = await new C();
System.Console.Write(i);

class C
{
}

class D : INotifyCompletion
{
    public int GetResult() => 42;
    public void OnCompleted(Action continuation) => throw null;
    public bool IsCompleted => true;
}

implicit extension E for C
{
    public D GetAwaiter() => new D();
}
";

        // PROTOTYPE confirm when spec'ing pattern-based await
        var comp = CreateCompilation(text);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(roles) enable once we can handle lowering/emit
    public void ExtensionMemberLookup_PatternBased_Await_ExtensionGetResult()
    {
        var text = @"
using System;
using System.Runtime.CompilerServices;

int i = await new C();
System.Console.Write(i);

class C
{
    public D GetAwaiter() => new D();
}

class D : INotifyCompletion
{
    public void OnCompleted(Action continuation) => throw null;
    public bool IsCompleted => true;
}

implicit extension E for D
{
    public int GetResult() => 42;
}
";

        // PROTOTYPE confirm when spec'ing pattern-based await
        var comp = CreateCompilation(text);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_IndexIndexer_NoIndexer()
    {
        var src = """
var c = new C();

/*<bind>*/
_ = c[^1];
/*</bind>*/

class C
{
    public int Length
    {
        get
        {
            System.Console.Write("length ");
            return 42;
        }
    }
}

implicit extension E for C
{
    public int this[int i]
    {
        get
        {
            System.Console.Write("indexer ");
            return 0;
        }
    }
}
""";

        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        // PROTOTYPE revisit as part of "implicit indexer access" section
        comp.VerifyDiagnostics(
            // (4,5): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            // _ = c[^1];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "c[^1]").WithArguments("C").WithLocation(4, 5)
            );
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "length indexer");

        //        string expectedOperationTree = """
        //ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: System.Int32) (Syntax: '_ = c[^1]')
        //Left:
        //  IDiscardOperation (Symbol: System.Int32 _) (OperationKind.Discard, Type: System.Int32) (Syntax: '_')
        //Right:
        //  IImplicitIndexerReferenceOperation (OperationKind.ImplicitIndexerReference, Type: System.Int32) (Syntax: 'c[^1]')
        //    Instance:
        //      ILocalReferenceOperation: c (OperationKind.LocalReference, Type: C) (Syntax: 'c')
        //    Argument:
        //      IUnaryOperation (UnaryOperatorKind.Hat) (OperationKind.Unary, Type: System.Index) (Syntax: '^1')
        //        Operand:
        //          ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 1) (Syntax: '1')
        //    LengthSymbol: System.Int32 E.Length { get; }
        //    IndexerSymbol: System.Int32 E.this[System.Int32 i] { get; }
        //""";
        //        var expectedDiagnostics = DiagnosticDescription.None;

        //        VerifyOperationTreeAndDiagnosticsForTest<AssignmentExpressionSyntax>(src,
        //            expectedOperationTree, expectedDiagnostics);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_IndexIndexer_NoLength()
    {
        var src = """
var c = new C();

/*<bind>*/
_ = c[^1];
/*</bind>*/

class C
{
    public int this[int i]
    {
        get
        {
            System.Console.Write("indexer ");
            return 0;
        }
    }
}

implicit extension E for C
{
    public int Length
    {
        get
        {
            System.Console.Write("length ");
            return 42;
        }
    }
}
""";

        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        // PROTOTYPE revisit as part of "implicit indexer access" section
        comp.VerifyDiagnostics(
            // (4,7): error CS1503: Argument 1: cannot convert from 'System.Index' to 'int'
            // _ = c[^1];
            Diagnostic(ErrorCode.ERR_BadArgType, "^1").WithArguments("1", "System.Index", "int").WithLocation(4, 7)
            );
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "length indexer");

        //        string expectedOperationTree = """
        //ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: System.Int32) (Syntax: '_ = c[^1]')
        //Left:
        //  IDiscardOperation (Symbol: System.Int32 _) (OperationKind.Discard, Type: System.Int32) (Syntax: '_')
        //Right:
        //  IImplicitIndexerReferenceOperation (OperationKind.ImplicitIndexerReference, Type: System.Int32) (Syntax: 'c[^1]')
        //    Instance:
        //      ILocalReferenceOperation: c (OperationKind.LocalReference, Type: C) (Syntax: 'c')
        //    Argument:
        //      IUnaryOperation (UnaryOperatorKind.Hat) (OperationKind.Unary, Type: System.Index) (Syntax: '^1')
        //        Operand:
        //          ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 1) (Syntax: '1')
        //    LengthSymbol: System.Int32 E.Length { get; }
        //    IndexerSymbol: System.Int32 E.this[System.Int32 i] { get; }
        //""";
        //        var expectedDiagnostics = DiagnosticDescription.None;

        //        VerifyOperationTreeAndDiagnosticsForTest<AssignmentExpressionSyntax>(src,
        //            expectedOperationTree, expectedDiagnostics);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_IndexIndexer_NoApplicableIndexer()
    {
        var src = """
var c = new C();

/*<bind>*/
_ = c[^1];
/*</bind>*/

class C
{
    public int this[string notApplicable] { } // not applicable
}

implicit extension E for C
{
    public int this[int i]
    {
        get
        {
            System.Console.Write("indexer ");
            return 0;
        }
    }

    public int Length
    {
        get
        {
            System.Console.Write("length ");
            return 42;
        }
    }
}
""";

        // PROTOTYPE revisit as part of "implicit indexer access" section
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (4,7): error CS1503: Argument 1: cannot convert from 'System.Index' to 'string'
            // _ = c[^1];
            Diagnostic(ErrorCode.ERR_BadArgType, "^1").WithArguments("1", "System.Index", "string").WithLocation(4, 7),
            // (9,16): error CS0548: 'C.this[string]': property or indexer must have at least one accessor
            //     public int this[string notApplicable] { } // not applicable
            Diagnostic(ErrorCode.ERR_PropertyWithNoAccessors, "this").WithArguments("C.this[string]").WithLocation(9, 16)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_RangeIndexer_NoMethod()
    {
        var src = """
var c = new C();

/*<bind>*/
_ = c[1..^1];
/*</bind>*/

class C { }

implicit extension E for C
{
    public int Slice(int i, int j)
    {
        System.Console.Write("slice ");
        return 0;
    }

    public int Length
    {
        get
        {
            System.Console.Write("length ");
            return 42;
        }
    }
}
""";

        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        // PROTOTYPE revisit as part of "implicit indexer access" section
        comp.VerifyDiagnostics(
            // (4,5): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            // _ = c[1..^1];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "c[1..^1]").WithArguments("C").WithLocation(4, 5)
            );
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "length slice");

        //        string expectedOperationTree = """
        //ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: System.Int32) (Syntax: '_ = c[1..^1]')
        //Left:
        //  IDiscardOperation (Symbol: System.Int32 _) (OperationKind.Discard, Type: System.Int32) (Syntax: '_')
        //Right:
        //  IImplicitIndexerReferenceOperation (OperationKind.ImplicitIndexerReference, Type: System.Int32) (Syntax: 'c[1..^1]')
        //    Instance:
        //      ILocalReferenceOperation: c (OperationKind.LocalReference, Type: C) (Syntax: 'c')
        //    Argument:
        //      IRangeOperation (OperationKind.Range, Type: System.Range) (Syntax: '1..^1')
        //        LeftOperand:
        //          IConversionOperation (TryCast: False, Unchecked) (OperatorMethod: System.Index System.Index.op_Implicit(System.Int32 value)) (OperationKind.Conversion, Type: System.Index, IsImplicit) (Syntax: '1')
        //            Conversion: CommonConversion (Exists: True, IsIdentity: False, IsNumeric: False, IsReference: False, IsUserDefined: True) (MethodSymbol: System.Index System.Index.op_Implicit(System.Int32 value))
        //            Operand:
        //              ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 1) (Syntax: '1')
        //        RightOperand:
        //          IUnaryOperation (UnaryOperatorKind.Hat) (OperationKind.Unary, Type: System.Index) (Syntax: '^1')
        //            Operand:
        //              ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 1) (Syntax: '1')
        //    LengthSymbol: System.Int32 E.Length { get; }
        //    IndexerSymbol: System.Int32 E.Slice(System.Int32 i, System.Int32 j)
        //""";
        //        var expectedDiagnostics = DiagnosticDescription.None;

        //        VerifyOperationTreeAndDiagnosticsForTest<AssignmentExpressionSyntax>(src,
        //            expectedOperationTree, expectedDiagnostics);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_RangeIndexer_NoApplicableMethod()
    {
        var src = """
var c = new C();

/*<bind>*/
_ = c[1..^1];
/*</bind>*/

class C
{
    public int Slice(int notApplicable) => throw null; // not applicable
}

implicit extension E for C
{
    public int Slice(int i, int j)
    {
        System.Console.Write("slice ");
        return 0;
    }

    public int Length
    {
        get
        {
            System.Console.Write("length ");
            return 42;
        }
    }
}
""";

        // PROTOTYPE revisit as part of "implicit indexer access" section
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (4,5): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            // _ = c[1..^1];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "c[1..^1]").WithArguments("C").WithLocation(4, 5)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_Patterns()
    {
        var src = """
var c = new C();

_ = c is { Property: 42 };

class C { }

implicit extension E for C
{
    public int Property
    {
        get
        {
            System.Console.Write("property");
            return 42;
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "property");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var nameColon = GetSyntax<NameColonSyntax>(tree, "Property:");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(nameColon.Name).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_Patterns_ExtendedPropertyPattern()
    {
        var src = """
var c = new C();

_ = c is { Property.Property2: 43 };

class C { }

implicit extension E1 for C
{
    public int Property { get { System.Console.Write("property "); return 42; } }
}

implicit extension E2 for int
{
    public int Property2 { get { System.Console.Write("property2"); return 43; } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "property property2");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var expressionColon = GetSyntax<ExpressionColonSyntax>(tree, "Property.Property2:");
        Assert.Equal("System.Int32 E2.Property2 { get; }", model.GetSymbolInfo(expressionColon.Expression).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_Patterns_ListPattern_NoInstanceLength()
    {
        var src = """
System.Console.Write(new C() is ["hi"]);

class C
{
    public string this[System.Index i]
    {
        get
        {
            System.Console.Write("indexer ");
            return "hi";
        }
    }
}

implicit extension E for C
{
    public int Length
    {
        get
        {
            System.Console.Write("length ");
            return 42;
        }
    }
}
""";

        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        // PROTOTYPE confirm that we want extensions to contribute to list-patterns
        comp.VerifyDiagnostics(
            // (1,33): error CS8985: List patterns may not be used for a value of type 'C'. No suitable 'Length' or 'Count' property was found.
            // System.Console.Write(new C() is ["hi"]);
            Diagnostic(ErrorCode.ERR_ListPatternRequiresLength, @"[""hi""]").WithArguments("C").WithLocation(1, 33)
            );
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "length indexer");

        //        string expectedOperationTree = """
        //ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: System.Int32) (Syntax: '_ = c[^1]')
        //Left:
        //  IDiscardOperation (Symbol: System.Int32 _) (OperationKind.Discard, Type: System.Int32) (Syntax: '_')
        //Right:
        //  IImplicitIndexerReferenceOperation (OperationKind.ImplicitIndexerReference, Type: System.Int32) (Syntax: 'c[^1]')
        //    Instance:
        //      ILocalReferenceOperation: c (OperationKind.LocalReference, Type: C) (Syntax: 'c')
        //    Argument:
        //      IUnaryOperation (UnaryOperatorKind.Hat) (OperationKind.Unary, Type: System.Index) (Syntax: '^1')
        //        Operand:
        //          ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 1) (Syntax: '1')
        //    LengthSymbol: System.Int32 E.Length { get; }
        //    IndexerSymbol: System.Int32 E.this[System.Int32 i] { get; }
        //""";
        //        var expectedDiagnostics = DiagnosticDescription.None;

        //        VerifyOperationTreeAndDiagnosticsForTest<AssignmentExpressionSyntax>(src,
        //            expectedOperationTree, expectedDiagnostics);
    }

    [Fact]
    public void ExtensionMemberLookup_Patterns_ListPattern_NoInstanceIndexer()
    {
        var src = """
System.Console.Write(/*<bind>*/ new C() is ["hi"] /*</bind>*/) ;

class C
{
    public int Length
    {
        get
        {
            System.Console.Write("length ");
            return 42;
        }
    }
}

implicit extension E for C
{
    public string this[System.Index i]
    {
        get
        {
            System.Console.Write("indexer ");
            return "hi";
        }
    }
}
""";

        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        // PROTOTYPE confirm that we want extensions to contribute to list-patterns
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "length indexer");

        string expectedOperationTree = """
IIsPatternOperation (OperationKind.IsPattern, Type: System.Boolean) (Syntax: 'new C() is ["hi"]')
Value:
  IObjectCreationOperation (Constructor: C..ctor()) (OperationKind.ObjectCreation, Type: C) (Syntax: 'new C()')
    Arguments(0)
    Initializer:
      null
Pattern:
  IListPatternOperation (OperationKind.ListPattern, Type: null) (Syntax: '["hi"]') (InputType: C, NarrowedType: C, DeclaredSymbol: null, LengthSymbol: System.Int32 C.Length { get; }, IndexerSymbol: System.String E.this[System.Index i] { get; })
    Patterns (1):
        IConstantPatternOperation (OperationKind.ConstantPattern, Type: null) (Syntax: '"hi"') (InputType: System.String, NarrowedType: System.String)
          Value:
            ILiteralOperation (OperationKind.Literal, Type: System.String, Constant: "hi") (Syntax: '"hi"')
""";
        var expectedDiagnostics = DiagnosticDescription.None;

        VerifyOperationTreeAndDiagnosticsForTest<IsPatternExpressionSyntax>(src,
            expectedOperationTree, expectedDiagnostics, targetFramework: TargetFramework.Net70);
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ExtensionMemberLookup_ObjectInitializer()
    {
        var src = """
/*<bind>*/
_ = new C() { Property = 42 };
/*</bind>*/

class C { }

implicit extension E for C
{
    public int Property
    {
        set
        {
            System.Console.Write("property");
        }
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "property");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var assignment = GetSyntax<AssignmentExpressionSyntax>(tree, "Property = 42");
        Assert.Equal("System.Int32 E.Property { set; }", model.GetSymbolInfo(assignment.Left).Symbol.ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ExtensionMemberLookup_With()
    {
        var src = """
/*<bind>*/
_ = new S() with { Property = 42 };
/*</bind>*/

struct S { }

implicit extension E for S
{
    public int Property
    {
        set
        {
            System.Console.Write("property");
        }
    }
}
""";

        var comp = CreateCompilation(src);
        // PROTOTYPE need to decide whether extensions apply here
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "property");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var assignment = GetSyntax<AssignmentExpressionSyntax>(tree, "Property = 42");
        Assert.Equal("System.Int32 E.Property { set; }", model.GetSymbolInfo(assignment.Left).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_CollectionInitializer_NoMethod()
    {
        var src = """
using System.Collections;
using System.Collections.Generic;

/*<bind>*/
_ = new C() { 42 };
/*</bind>*/

class C : IEnumerable<int>, IEnumerable
{
    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}

implicit extension E for C
{
    public void Add(int i)
    {
        System.Console.Write("add");
    }
}
""";

        var comp = CreateCompilation(src);
        // PROTOTYPE confirm when spec'ing pattern-based collection initializer
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "add");

        //        string expectedOperationTree = """
        //ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: C) (Syntax: '_ = new C() { 42 }')
        //Left:
        //  IDiscardOperation (Symbol: C _) (OperationKind.Discard, Type: C) (Syntax: '_')
        //Right:
        //  IObjectCreationOperation (Constructor: C..ctor()) (OperationKind.ObjectCreation, Type: C) (Syntax: 'new C() { 42 }')
        //    Arguments(0)
        //    Initializer:
        //      IObjectOrCollectionInitializerOperation (OperationKind.ObjectOrCollectionInitializer, Type: C) (Syntax: '{ 42 }')
        //        Initializers(1):
        //            IInvocationOperation ( void E.Add(System.Int32 i)) (OperationKind.Invocation, Type: System.Void, IsImplicit) (Syntax: '42')
        //              Instance Receiver:
        //                IInstanceReferenceOperation (ReferenceKind: ImplicitReceiver) (OperationKind.InstanceReference, Type: C, IsImplicit) (Syntax: 'C')
        //              Arguments(1):
        //                  IArgumentOperation (ArgumentKind.Explicit, Matching Parameter: i) (OperationKind.Argument, Type: null, IsImplicit) (Syntax: '42')
        //                    ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 42) (Syntax: '42')
        //                    InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
        //                    OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
        //""";
        //        var expectedDiagnostics = DiagnosticDescription.None;

        //        VerifyOperationTreeAndDiagnosticsForTest<AssignmentExpressionSyntax>(src,
        //            expectedOperationTree, expectedDiagnostics);
    }

    [Fact]
    public void ExtensionMemberLookup_CollectionInitializer_NoApplicableMethod()
    {
        var src = """
using System.Collections;
using System.Collections.Generic;

/*<bind>*/
_ = new C() { 42 };
/*</bind>*/

class C : IEnumerable<int>, IEnumerable
{
    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
    public void Add(string notApplicable) => throw null;
}

implicit extension E for C
{
    public void Add(int i)
    {
        System.Console.Write("add");
    }
}
""";

        // PROTOTYPE confirm when spec'ing pattern-based collection initializer
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "add");
    }

    [Fact]
    public void ExtensionMemberLookup_InterpolationHandler_Simple()
    {
        var src = """
/*<bind>*/
_ = f($"{(object)1} {f2()}");
/*</bind>*/

static int f(InterpolationHandler s) => 0;
static string f2() => "hello";

[System.Runtime.CompilerServices.InterpolatedStringHandler]
public struct InterpolationHandler
{
    public InterpolationHandler(int literalLength, int formattedCount) => throw null;
    public void AppendLiteral(string value) { }
    public void AppendFormatted<T>(T hole, int alignment = 0, string format = null) => throw null;
}
""";

        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_InterpolationHandler_AppendLiteralExtensionMethod()
    {
        var src = """
/*<bind>*/
_ = f($"{(object)1} {f2()}");
/*</bind>*/

static int f(InterpolationHandler s) => 0;
static string f2() => "hello";

[System.Runtime.CompilerServices.InterpolatedStringHandler]
public struct InterpolationHandler
{
    public InterpolationHandler(int literalLength, int formattedCount) => throw null;
    public void AppendFormatted<T>(T hole, int alignment = 0, string format = null) => throw null;
}

public static class Extensions
{
    public static void AppendLiteral(this InterpolationHandler ih, string value) { }
}
""";

        // Interpolation handlers don't allow extension methods
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (2,20): error CS1061: 'InterpolationHandler' does not contain a definition for 'AppendLiteral' and no accessible extension method 'AppendLiteral' accepting a first argument of type 'InterpolationHandler' could be found (are you missing a using directive or an assembly reference?)
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, " ").WithArguments("InterpolationHandler", "AppendLiteral").WithLocation(2, 20),
            // (2,20): error CS8941: Interpolated string handler method '?.()' is malformed. It does not return 'void' or 'bool'.
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_InterpolatedStringHandlerMethodReturnMalformed, " ").WithArguments("?.()").WithLocation(2, 20)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_InterpolationHandler_AppendLiteralExtensionTypeMethod()
    {
        var src = """
/*<bind>*/
_ = f($"{(object)1} {f2()}");
/*</bind>*/

static int f(InterpolationHandler s) => 0;
static string f2() => "hello";

[System.Runtime.CompilerServices.InterpolatedStringHandler]
public struct InterpolationHandler
{
    public InterpolationHandler(int literalLength, int formattedCount) => throw null;
    public void AppendFormatted<T>(T hole, int alignment = 0, string format = null) => throw null;
}

public implicit extension E for InterpolationHandler
{
    public void AppendLiteral(string value) { }
}
""";

        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (2,20): error CS1061: 'InterpolationHandler' does not contain a definition for 'AppendLiteral' and no accessible extension method 'AppendLiteral' accepting a first argument of type 'InterpolationHandler' could be found (are you missing a using directive or an assembly reference?)
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, " ").WithArguments("InterpolationHandler", "AppendLiteral").WithLocation(2, 20),
            // (2,20): error CS8941: Interpolated string handler method '?.()' is malformed. It does not return 'void' or 'bool'.
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_InterpolatedStringHandlerMethodReturnMalformed, " ").WithArguments("?.()").WithLocation(2, 20)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_InterpolationHandler_AppendFormattedExtensionMethod()
    {
        var src = """
/*<bind>*/
_ = f($"{(object)1} {f2()}");
/*</bind>*/

static int f(InterpolationHandler s) => 0;
static string f2() => "hello";

[System.Runtime.CompilerServices.InterpolatedStringHandler]
public struct InterpolationHandler
{
    public InterpolationHandler(int literalLength, int formattedCount) => throw null;
    public void AppendLiteral(string value) { }
}

public static class Extensions
{
    public static void AppendFormatted<T>(this InterpolationHandler ih, T hole, int alignment = 0, string format = null) { }
}
""";

        // Interpolation handlers don't allow extension methods
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (2,9): error CS1061: 'InterpolationHandler' does not contain a definition for 'AppendFormatted' and no accessible extension method 'AppendFormatted' accepting a first argument of type 'InterpolationHandler' could be found (are you missing a using directive or an assembly reference?)
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "{(object)1}").WithArguments("InterpolationHandler", "AppendFormatted").WithLocation(2, 9),
            // (2,9): error CS8941: Interpolated string handler method '?.()' is malformed. It does not return 'void' or 'bool'.
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_InterpolatedStringHandlerMethodReturnMalformed, "{(object)1}").WithArguments("?.()").WithLocation(2, 9),
            // (2,21): error CS1061: 'InterpolationHandler' does not contain a definition for 'AppendFormatted' and no accessible extension method 'AppendFormatted' accepting a first argument of type 'InterpolationHandler' could be found (are you missing a using directive or an assembly reference?)
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "{f2()}").WithArguments("InterpolationHandler", "AppendFormatted").WithLocation(2, 21),
            // (2,21): error CS8941: Interpolated string handler method '?.()' is malformed. It does not return 'void' or 'bool'.
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_InterpolatedStringHandlerMethodReturnMalformed, "{f2()}").WithArguments("?.()").WithLocation(2, 21)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_InterpolationHandler_AppendFormattedExtensionTypeMethod()
    {
        var src = """
/*<bind>*/
_ = f($"{(object)1} {f2()}");
/*</bind>*/

static int f(InterpolationHandler s) => 0;
static string f2() => "hello";

[System.Runtime.CompilerServices.InterpolatedStringHandler]
public struct InterpolationHandler
{
    public InterpolationHandler(int literalLength, int formattedCount) => throw null;
    public void AppendLiteral(string value) { }
}

public implicit extension E for InterpolationHandler
{
    public void AppendFormatted<T>(T hole, int alignment = 0, string format = null) { }
}
""";

        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (2,9): error CS1061: 'InterpolationHandler' does not contain a definition for 'AppendFormatted' and no accessible extension method 'AppendFormatted' accepting a first argument of type 'InterpolationHandler' could be found (are you missing a using directive or an assembly reference?)
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "{(object)1}").WithArguments("InterpolationHandler", "AppendFormatted").WithLocation(2, 9),
            // (2,9): error CS8941: Interpolated string handler method '?.()' is malformed. It does not return 'void' or 'bool'.
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_InterpolatedStringHandlerMethodReturnMalformed, "{(object)1}").WithArguments("?.()").WithLocation(2, 9),
            // (2,21): error CS1061: 'InterpolationHandler' does not contain a definition for 'AppendFormatted' and no accessible extension method 'AppendFormatted' accepting a first argument of type 'InterpolationHandler' could be found (are you missing a using directive or an assembly reference?)
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "{f2()}").WithArguments("InterpolationHandler", "AppendFormatted").WithLocation(2, 21),
            // (2,21): error CS8941: Interpolated string handler method '?.()' is malformed. It does not return 'void' or 'bool'.
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_InterpolatedStringHandlerMethodReturnMalformed, "{f2()}").WithArguments("?.()").WithLocation(2, 21)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_Query_NoMethod()
    {
        var src = """
/*<bind>*/
string query = from x in new C() select x;
/*</bind>*/

System.Console.Write(query);

class C { }

implicit extension E for C
{
    public string Select(System.Func<C, C> selector) => "hello";
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "hello");

        //        string expectedOperationTree = """
        //IVariableDeclarationGroupOperation (1 declarations) (OperationKind.VariableDeclarationGroup, Type: null) (Syntax: 'string quer ... ) select x;')
        //IVariableDeclarationOperation (1 declarators) (OperationKind.VariableDeclaration, Type: null) (Syntax: 'string quer ... () select x')
        //  Declarators:
        //      IVariableDeclaratorOperation (Symbol: System.String query) (OperationKind.VariableDeclarator, Type: null) (Syntax: 'query = fro ... () select x')
        //        Initializer:
        //          IVariableInitializerOperation (OperationKind.VariableInitializer, Type: null) (Syntax: '= from x in ... () select x')
        //            ITranslatedQueryOperation (OperationKind.TranslatedQuery, Type: System.String) (Syntax: 'from x in n ... () select x')
        //              Expression:
        //                IInvocationOperation ( System.String E.Select(System.Func<C, C> selector)) (OperationKind.Invocation, Type: System.String, IsImplicit) (Syntax: 'select x')
        //                  Instance Receiver:
        //                    IObjectCreationOperation (Constructor: C..ctor()) (OperationKind.ObjectCreation, Type: C) (Syntax: 'new C()')
        //                      Arguments(0)
        //                      Initializer:
        //                        null
        //                  Arguments(1):
        //                      IArgumentOperation (ArgumentKind.Explicit, Matching Parameter: selector) (OperationKind.Argument, Type: null, IsImplicit) (Syntax: 'x')
        //                        IDelegateCreationOperation (OperationKind.DelegateCreation, Type: System.Func<C, C>, IsImplicit) (Syntax: 'x')
        //                          Target:
        //                            IAnonymousFunctionOperation (Symbol: lambda expression) (OperationKind.AnonymousFunction, Type: null, IsImplicit) (Syntax: 'x')
        //                              IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsImplicit) (Syntax: 'x')
        //                                IReturnOperation (OperationKind.Return, Type: null, IsImplicit) (Syntax: 'x')
        //                                  ReturnedValue:
        //                                    IParameterReferenceOperation: x (OperationKind.ParameterReference, Type: C) (Syntax: 'x')
        //                        InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
        //                        OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
        //  Initializer:
        //    null
        //""";
        //        VerifyOperationTreeAndDiagnosticsForTest<LocalDeclarationStatementSyntax>(src,
        //            expectedOperationTree, DiagnosticDescription.None);
    }

    [Fact]
    public void ExtensionMemberLookup_Query_NoApplicableMethod()
    {
        var src = """
/*<bind>*/
string query = from x in new C() select x;
/*</bind>*/

System.Console.Write(query);

class C
{
    public string Select(int notApplicable) => throw null; // not applicable
}

implicit extension E for C
{
    public string Select(System.Func<C, C> selector) => "hello";
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "hello");

        // PROTOTYPE verify IOperation
    }

    [Fact]
    public void ExtensionMemberLookup_NameOf_NoParameter()
    {
        var src = """
class C
{
    void M()
    {
        System.Console.Write(nameof());
    }
}

implicit extension E for C
{
    public string nameof() => throw null;
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,30): error CS0103: The name 'nameof' does not exist in the current context
            //         System.Console.Write(nameof());
            Diagnostic(ErrorCode.ERR_NameNotInContext, "nameof").WithArguments("nameof").WithLocation(5, 30)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_NameOf_SingleParameter()
    {
        var src = """
class C
{
    public static void Main()
    {
        string x = "";
        System.Console.Write(nameof(x));
    }
}

implicit extension E for C
{
    public string nameof(string s) => throw null;
}
""";

        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "x").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_GotoLabel()
    {
        var src = """
class C
{
    void M()
    {
        goto label;
    }
}

implicit extension E for C
{
    public const int label = 42;
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,14): error CS0159: No such label 'label' within the scope of the goto statement
            //         goto label;
            Diagnostic(ErrorCode.ERR_LabelNotFound, "label").WithArguments("label").WithLocation(5, 14)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_LabelDeclaration()
    {
        var src = """
class C
{
    void M()
    {
label:;
    }
}

implicit extension E for C
{
    public const int label = 42;
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,1): warning CS0164: This label has not been referenced
            // label:;
            Diagnostic(ErrorCode.WRN_UnreferencedLabel, "label").WithLocation(5, 1)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_SimpleTypeNameAsTypeConstraint()
    {
        var src = """
class C<T> where T : ExtensionType
{
}

implicit extension E<T> for C<T> where T : ExtensionType
{
    public class ExtensionType { }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,22): error CS0246: The type or namespace name 'ExtensionType' could not be found (are you missing a using directive or an assembly reference?)
            // class C<T> where T : ExtensionType
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "ExtensionType").WithArguments("ExtensionType").WithLocation(1, 22),
            // (5,20): error CS0314: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'C<T>'. There is no boxing conversion or type parameter conversion from 'T' to 'ExtensionType'.
            // implicit extension E<T> for C<T> where T : ExtensionType
            Diagnostic(ErrorCode.ERR_GenericConstraintNotSatisfiedTyVar, "E").WithArguments("C<T>", "ExtensionType", "T", "T").WithLocation(5, 20),
            // (5,44): error CS0246: The type or namespace name 'ExtensionType' could not be found (are you missing a using directive or an assembly reference?)
            // implicit extension E<T> for C<T> where T : ExtensionType
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "ExtensionType").WithArguments("ExtensionType").WithLocation(5, 44)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_AliasQualifiedName()
    {
        var src = """
using C1 = C;

C1::ExtensionType.M(); // 1
C1.ExtensionType.M();

class C { }

implicit extension E for C
{
    public class ExtensionType
    {
        public static void M() { }
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (3,1): error CS0431: Cannot use alias 'C1' with '::' since the alias references a type. Use '.' instead.
            // C1::ExtensionType.M(); // 1
            Diagnostic(ErrorCode.ERR_ColColWithTypeAlias, "C1").WithArguments("C1").WithLocation(3, 1)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_TypeParameter()
    {
        var src = """
class C<T>
{
    explicit extension R for T
    {
        void M1() { }

        class Type
        {
            static void M2() { }
        }
    }

    void M3()
    {
        T.M1();
        T.Type.M2();
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (15,9): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         T.M1();
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(15, 9),
            // (16,9): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         T.Type.M2();
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(16, 9)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var invocation = GetSyntax<MemberAccessExpressionSyntax>(tree, "T.M1");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Empty(model.GetMemberGroup(invocation));

        var type = GetSyntax<MemberAccessExpressionSyntax>(tree, "T.Type");
        Assert.Null(model.GetSymbolInfo(type).Symbol);
        Assert.Empty(model.GetMemberGroup(type));
    }

    [Fact]
    public void ExtensionMemberLookup_DuplicateFieldNamesInUnderlyingType()
    {
        var ilSource = """
.class public auto ansi beforefieldinit C
    extends [mscorlib]System.Object
{
    .field public int32 'member'
    .field public string 'member'
}
""";

        var src = """
class D
{
    void M(C c)
    {
        _ = c.member;
    }
}

implicit extension E for C
{
    public string member => throw null;
}
""";
        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics(
            // (5,15): error CS0229: Ambiguity between 'C.member' and 'C.member'
            //         _ = c.member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "member").WithArguments("C.member", "C.member").WithLocation(5, 15)
            );
    }

    [Fact]
    public void ParameterCapturing_054_ColorColor_QualifiedName_Type_WithExtension()
    {
        var source = @"
class Color
{
    public class C1(Color Color)
    {
        public object M1(object input)
        {
            if (input is Color.Red)
            {
                return ""Red"";
            }

            return ""Blue"";
        }
    }
}

implicit extension E for Color
{
    public class Red;
}

class Program
{
    static void Main()
    {
        var c1 = new Color.C1(default);
        object val = c1.M1(new Color.Red());
        System.Console.Write(val);
    }
}
";
        var comp = CreateCompilation(source, options: TestOptions.ReleaseExe);

        // PROTOTYPE missing WRN_UnreadPrimaryConstructorParameter
        CompileAndVerify(comp, expectedOutput: "Red").VerifyDiagnostics(
            //// (4,27): warning CS9113: Parameter 'Color' is unread.
            ////     public class C1(Color Color)
            //Diagnostic(ErrorCode.WRN_UnreadPrimaryConstructorParameter, "Color").WithArguments("Color").WithLocation(4, 27)
            );

        //Assert.Empty(comp.GetTypeByMetadataName("Color+C1").InstanceConstructors.OfType<SynthesizedPrimaryConstructor>().Single().GetCapturedParameters());
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_Simple()
    {
        // We look at methods in extension types if the method group on type has no applicable candidates
        var source = """
C.M(42);

class C
{
    public static void M() => throw null;
}

implicit extension E for C
{
    public static void M(int i)
    {
        System.Console.Write("E.M");
    }
}
""";
        var comp = CreateCompilation(source);

        var verifier = CompileAndVerify(comp, expectedOutput: "E.M").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M()" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model

        verifier.VerifyIL("<top-level-statements-entry-point>", """
            {
              // Code size        8 (0x8)
              .maxstack  1
              IL_0000:  ldc.i4.s   42
              IL_0002:  call       "void E.M(int)"
              IL_0007:  ret
            }
            """);
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_Simple_ExpressionTree()
    {
        // PROTOTYPE decide whether to allow expression tree scenarios. Verify shape of the tree if we decide to allow
        var source = """
using System.Linq.Expressions;
Expression<System.Action> x = () => C.M(42);

class C
{
    public static void M() => throw null;
}

implicit extension E for C
{
    public static void M(int i)
    {
        System.Console.Write("E.M");
    }
}
""";
        var comp = CreateCompilation(source);

        CompileAndVerify(comp, expectedOutput: "").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_InstanceReceiver_Simple()
    {
        // We look at methods in extension types if the method group on type has no applicable candidates
        var source = """
new C().M(42);

class C
{
    public void M() => throw null;
}

implicit extension E for C
{
    public void M(int i)
    {
        System.Console.Write("E.M");
    }
}
""";
        var comp = CreateCompilation(source);

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "E.M");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M()" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_InstanceReceiver_Simple_ExpressionTree()
    {
        // PROTOTYPE decide whether to allow expression tree scenarios. Verify shape of the tree if we decide to allow
        var source = """
using System.Linq.Expressions;
Expression<System.Action> x = () => new C().M(42);

class C
{
    public void M() => throw null;
}

implicit extension E for C
{
    public void M(int i)
    {
        System.Console.Write("E.M");
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();
        //CompileAndVerify(comp, expectedOutput: "").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_InstanceReceiver_Simple_DynamicArgument()
    {
        var source = """
dynamic d = 42;
new C().M(d);

class C { }

implicit extension E for C
{
    public void M(int i)
    {
        System.Console.Write("E.M");
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE need to confirm what we want for invocations with dynamic arguments (should likely be disallowed)
        comp.VerifyDiagnostics();
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ExtensionInvocation_InstanceReceiver_ComImportReceiver()
    {
        string source = """
using System;
using System.Runtime.InteropServices;

I i = new C();
System.Console.Write(i.M(1));

[ComImport]
[Guid("1FC6664D-C61E-4131-81CD-A3EE0DD6098F")]
[CoClass(typeof(C))]
interface I
{
}

class C : I
{
}

implicit extension E for I
{
    public int M(ref int i) => 42;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<InvocationExpressionSyntax>(tree, "i.M(1)");
        Assert.Equal("System.Int32 E.M(ref System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_Overloads()
    {
        // When we look at methods in extension types, we perform overload resolution
        var source = """
C.M(42);

class C
{
    public static void M() => throw null;
}

implicit extension E for C
{
    public static void M(int i)
    {
        System.Console.Write($"E.M({i})");
    }

    public static void M(string s) => throw null;
}
""";
        var comp = CreateCompilation(source);

        CompileAndVerify(comp, expectedOutput: "E.M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M()" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_InstanceReceiver_Overloads()
    {
        // When we look at methods in extension types, we perform overload resolution
        var source = """
new C().M(42);

class C
{
    public void M() => throw null;
}

implicit extension E for C
{
    public void M(int i)
    {
        System.Console.Write($"E.M({i})");
    }

    public static void M(string s) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "E.M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_NextScope()
    {
        // If overload resolution on extension type methods yields no applicable candidates,
        // we look in the next scope.
        var source = """
using N;

C.M(42);

class C
{
    public static void M() => throw null;
}

implicit extension E1 for C
{
    public static void M(string s) => throw null;
}

namespace N
{
    implicit extension E2 for C
    {
        public static void M(int i)
        {
            System.Console.Write($"E2.M({i})");
        }
    }
}
""";
        var comp = CreateCompilation(source);

        CompileAndVerify(comp, expectedOutput: "E2.M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void N.E2.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M()" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_InstanceReceiver_NextScope()
    {
        // If overload resolution on extension type methods yields no applicable candidates,
        // we look in the next scope.
        var source = """
using N;

new C().M(42);

class C
{
    public void M() => throw null;
}

implicit extension E1 for C
{
    public void M(string s) => throw null;
}

namespace N
{
    implicit extension E2 for C
    {
        public void M(int i)
        {
            System.Console.Write($"E2.M({i})");
        }
    }
}
""";
        var comp = CreateCompilation(source);

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "E2.M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void N.E2.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M()" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_ExtensionTypePriority()
    {
        // The method from the extension type comes before the extension method
        var source = """
new C().M(42);

class C
{
    public void M() => throw null;
}

implicit extension E1 for C
{
    public void M(int i)
    {
        System.Console.Write($"E1.M({i})");
    }
}

static class E2
{
    public void M(this C c, int i) => throw null;
}
""";
        var comp = CreateCompilation(source);

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "E1.M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E1.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M()", "void C.M(System.Int32 i)" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_FallbackToExtensionMethod()
    {
        // The extension method is picked up if extension type candidates were not applicable
        var source = """
new C().M(42);

class C
{
    public static void M() => throw null;
}

implicit extension E1 for C
{
    public void M(string s) => throw null;
    public void M(char c) => throw null;
}

static class E2
{
    public static void M(this C c, int i)
    {
        System.Console.Write($"E2.M({i})");
    }
}
""";
        var comp = CreateCompilation(source);

        CompileAndVerify(comp, expectedOutput: "E2.M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void C.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M()", "void C.M(System.Int32 i)" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_InaccessibleExtensionTypeMember()
    {
        var source = """
C.M(42);

class C
{
    public static void M() => throw null;
}

implicit extension E1 for C
{
    protected static void M(int i) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(1,3): error CS1501: No overload for method 'M' takes 1 arguments
            // C.M(42);
            Diagnostic(ErrorCode.ERR_BadArgCount, "M").WithArguments("M", "1").WithLocation(1, 3)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(new[] { "void C.M()" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionInvocation_InaccessibleExtensionTypeMember_FallbackToExtensionMethod()
    {
        // Extension method is picked up after inaccessible extension type member was found
        var source = """
new C().M(42);

class C
{
    public void M() => throw null;
}

implicit extension E1 for C
{
    protected void M(int i) => throw null;
}

static class E2
{
    public static void M(this C c, int i)
    {
        System.Console.Write($"E2.M({i})");
    }
}
""";
        var comp = CreateCompilation(source);

        CompileAndVerify(comp, expectedOutput: "E2.M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void C.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M()", "void C.M(System.Int32 i)" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_SimpleName()
    {
        // Extension invocation comes into play on an invocation on a member access but not an invocation on a simple name
        var source = """
class C
{
    public void M() => throw null;

    void M2()
    {
        M(42); // 1
    }
}

implicit extension E for C
{
    public void M(int i) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(7,9): error CS1501: No overload for method 'M' takes 1 arguments
            //         M(42); // 1
            Diagnostic(ErrorCode.ERR_BadArgCount, "M").WithArguments("M", "1").WithLocation(7, 9)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "M(42)");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Empty(model.GetMemberGroup(invocation));
    }

    [Fact]
    public void ExtensionInvocation_OnlyDelegateFieldExists()
    {
        // Invocable fields are considered during extension invocation
        var source = """
E.Field = (i) => { System.Console.Write($"ran({i})"); };
C.Field(42);

class C { }

delegate void D(int i);

implicit extension E for C
{
    public static D Field;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran(42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Field");
        Assert.Equal("D E.Field", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionInvocation_OnlyIntegerFieldExists()
    {
        var source = """
C.Field(42);

public class C { }

public implicit extension E for C
{
    public static int Field = 0;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,3): error CS0117: 'C' does not contain a definition for 'Field'
            // C.Field(42);
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Field").WithArguments("C", "Field").WithLocation(1, 3));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Field");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionInvocation_OnlyDelegatePropertyExists()
    {
        // Invocable properties are considered during extension invocation
        var source = """
C.Property(42);

class C { }

delegate void D(int i);

implicit extension E for C
{
    public static D Property
    {
        get
        {
            return (i) => { System.Console.Write($"ran({i})"); };
        }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran(42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property");
        Assert.Equal("D E.Property { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionInvocation_OnlyDynamicPropertyExists()
    {
        // Invocable properties are considered during extension invocation
        var source = """
C.Property(42);

class C { }

implicit extension E for C
{
    public static dynamic Property
    {
        get
        {
            return (System.Action<int>)((i) => { System.Console.Write($"ran({i})"); });
        }
    }
}
""";
        var comp = CreateCompilationWithCSharp(source);
        CompileAndVerify(comp, expectedOutput: "ran(42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property");
        Assert.Equal("dynamic E.Property { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable once we can lower/emit for non-static scenarios
    public void ExtensionInvocation_OnlyEventExists()
    {
        var source = """
new C().Event(42);

class C { }

delegate void D(int i);

implicit extension E for C
{
    public event D Event { add => throw null; remove => throw null; }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,9): error CS0079: The event 'E.Event' can only appear on the left hand side of += or -=
            // new C().Event(42);
            Diagnostic(ErrorCode.ERR_BadEventUsageNoField, "Event").WithArguments("E.Event").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().Event");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["event D E.Event"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAValue, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Empty(model.GetMemberGroup(memberAccess));

        source = """
new C().Event(42);

delegate void D(int i);

class C
{
    public event D Event { add => throw null; remove => throw null; }
}
""";

        comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0079: The event 'C.Event' can only appear on the left hand side of += or -=
            // new C().Event(42);
            Diagnostic(ErrorCode.ERR_BadEventUsageNoField, "Event").WithArguments("C.Event").WithLocation(1, 9));

        tree = comp.SyntaxTrees.First();
        model = comp.GetSemanticModel(tree);
        memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().Event");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["event D C.Event"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAValue, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionInvocation_ArgumentName()
    {
        // Instance method with incompatible parameter name is skipped in favor of extension type method
        var source = """
C.M(b: 42);

class C
{
    public static void M(int a) => throw null;
}

implicit extension E1 for C
{
    public static void M(int b)
    {
        System.Console.Write($"E1.M({b})");
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, expectedOutput: "E1.M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E1.M(System.Int32 b)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M(System.Int32 a)" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_ArgumentName_02()
    {
        // Extension type method with incompatible parameter name is skipped in favor of extension method
        var source = """
new C().M(c: 42);

public class C
{
    public static void M(int a) => throw null;
}

implicit extension E1 for C
{
    public static void M(int b) => throw null;
}

public static class E2
{
    public static void M(this C self, int c)
    {
        System.Console.Write($"E2.M({c})");
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        CompileAndVerify(comp, expectedOutput: "E2.M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void C.M(System.Int32 c)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        Assert.Equal(new[] { "void C.M(System.Int32 a)", "void C.M(System.Int32 c)" },
            model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_Instance_AmbiguityWithExtensionOnBaseType_PreferMoreSpecific()
    {
        var source = """
System.Console.Write(new C().M(42));

class Base { }

class C : Base { }

implicit extension E1 for Base
{
    public int M(int i) => throw null;
}

implicit extension E2 for C
{
    public int M(int i) => i;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new C().M(42)");
        Assert.Equal("System.Int32 E2.M(System.Int32 i)", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(invocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(invocation).CandidateReason);
        Assert.Empty(model.GetMemberGroup(invocation)); // PROTOTYPE need to fix the semantic model

        source = """
System.Console.Write(new C().M(42));

public class Base { }

public class C : Base { }

public static class E1
{
    public static int M(this Base b, int i) => throw null;
}

public static class E2
{
    public static int M(this C c, int i) => i;
}
""";
        comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionInvocation_Static_AmbiguityWithExtensionOnBaseType_PreferMoreSpecific()
    {
        var source = """
System.Console.Write(C.M(42));

class Base { }

class C : Base { }

implicit extension E1 for Base
{
    public static int M(int i) => throw null;
}

implicit extension E2 for C
{
    public static int M(int i) => i;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "C.M(42)");
        Assert.Equal("System.Int32 E2.M(System.Int32 i)", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(invocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(invocation).CandidateReason);
        Assert.Empty(model.GetMemberGroup(invocation)); // PROTOTYPE need to fix the semantic model
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ExtensionInvocation_Instance_ExtensionOnUnderlying_WithInapplicableInstanceMethod()
    {
        var src = """
class C
{
    public void Method(E1 e)
    {
        e.M();
    }

    public int M<T>() => throw null;
}

implicit extension E1 for C { }

implicit extension E2 for C
{
    public string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "e.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        // PROTOTYPE need to fix the semantic model
        Assert.Equal(["System.Int32 C.M<T>()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ExtensionInvocation_Instance_ExtensionOnUnderlying()
    {
        var src = """
class C
{
    public void Method(E1 e)
    {
        e.M();
    }
}

implicit extension E1 for C { }

implicit extension E2 for C
{
    public string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "e.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        // PROTOTYPE need to fix the semantic model
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionInvocation_Instance_ExtensionMethodOnUnderlying()
    {
        var src = """
class C
{
    public void Method(E1 e)
    {
        e.M();
    }
}

implicit extension E1 for C { }

static class E2
{
    public static string M(this C c) => "ran";
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE need to bind and emit an extension method on a receiver of an extension type
        comp.VerifyDiagnostics(
            // (5,9): error CS1929: 'E1' does not contain a definition for 'M' and the best extension method overload 'E2.M(C)' requires a receiver of type 'C'
            //         e.M();
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "e").WithArguments("E1", "M", "E2.M(C)", "C").WithLocation(5, 9));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "e.M");
        // PROTOTYPE need to fix the semantic model
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionInvocation_Static_ExtensionOnUnderlying()
    {
        var src = """
System.Console.Write(E1.M());

class C { }

implicit extension E1 for C { }

implicit extension E2 for C
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E1.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        // PROTOTYPE need to fix the semantic model
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionInvocation_Static_ExtensionMethodOnUnderlying()
    {
        var src = """
E1.M();

class C { }

implicit extension E1 for C { }

static class E2
{
    public static string M(this C c) => "ran";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,1): error CS1929: 'E1' does not contain a definition for 'M' and the best extension method overload 'E2.M(C)' requires a receiver of type 'C'
            // E1.M();
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "E1").WithArguments("E1", "M", "E2.M(C)", "C").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E1.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ExtensionProperty_Instance_AmbiguityWithExtensionOnBaseType_PreferMoreSpecific()
    {
        var source = """
System.Console.Write(new C().P.ToString());

class Base { }

class C : Base { }

implicit extension E1 for Base
{
    public int P => throw null;
}

implicit extension E2 for C
{
    public int P => 42;
}
""";
        // PROTOTYPE E2 might be a better choice because it extends a more specific type. we have rules around receiver types for regular extension methods.
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "42");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().P");
        Assert.Equal("System.Int32 E2.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionProperty_Static_AmbiguityWithExtensionOnBaseType_PreferMoreSpecific()
    {
        var source = """
System.Console.Write(C.P.ToString());

class Base { }

class C : Base { }

implicit extension E1 for Base
{
    public static int P => throw null;
}

implicit extension E2 for C
{
    public static int P => 42;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.P");
        Assert.Equal("System.Int32 E2.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void DelegateConversion_TypeReceiver()
    {
        var source = """
D d = C.M;
d(42);

delegate void D(int i);

class C { }

implicit extension E for C
{
    public static void M(int i)
    {
        System.Console.Write("E.M");
    }
}
""";
        var comp = CreateCompilation(source);

        CompileAndVerify(comp, expectedOutput: "E.M");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_InstanceReceiver()
    {
        var source = """
D d = new C().M;
d(42);

delegate void D(int i);

class C
{
    public void M() => throw null;
}

implicit extension E for C
{
    public void M(int i)
    {
        System.Console.Write("E.M");
    }
}
""";
        var comp = CreateCompilation(source);

        var verifier = CompileAndVerify(comp, expectedOutput: "E.M");

        verifier.VerifyDiagnostics();

        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size       24 (0x18)
  .maxstack  2
  IL_0000:  newobj     "C..ctor()"
  IL_0005:  ldftn      "void E.M(C, int)"
  IL_000b:  newobj     "D..ctor(object, System.IntPtr)"
  IL_0010:  ldc.i4.s   42
  IL_0012:  callvirt   "void D.Invoke(int)"
  IL_0017:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M()" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_SimpleName()
    {
        var source = """
delegate void D(int i);

class C
{
    public void M() => throw null;

    void M2()
    {
        D d = M;
        d(42);
    }
}

implicit extension E for C
{
    public void M(int i)
    {
        System.Console.Write("E.M");
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(9,15): error CS0123: No overload for 'M' matches delegate 'D'
            //         D d = M;
            Diagnostic(ErrorCode.ERR_MethDelegateMismatch, "M").WithArguments("M", "D").WithLocation(9, 15)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var simpleName = GetSyntax<EqualsValueClauseSyntax>(tree, "= M").Value;
        Assert.Equal(new[] { "void C.M()" }, model.GetMemberGroup(simpleName).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_TypeArguments()
    {
        var source = """
C.M<object>(42);

class C { }

implicit extension E for C
{
    public static void M(int i) => throw null;
    public static void M<T>(int i)
    {
        System.Console.Write("ran");
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M<object>");
        Assert.Equal("void E.M<System.Object>(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_InstanceReceiver_TypeArguments()
    {
        var source = """
new C().M<object>(42);

class C { }

implicit extension E for C
{
    public void M(int i) => throw null;
    public void M<T>(int i)
    {
        System.Console.Write("ran");
    }
}
""";
        var comp = CreateCompilation(source);

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M<object>");
        Assert.Equal("void E.M<System.Object>(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Overloads()
    {
        var source = """
D d = C.M;
d(42);

C.M(42);

delegate void D(int i);

class C { }

implicit extension E for C
{
    public static void M(int i)
    {
        System.Console.Write("ran ");
    }

    public static void M(string s) => throw null;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.M").First();
        Assert.Equal("void E.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_ValueReceiver_Overloads()
    {
        var source = """
D d = new C().M;
d(42);

new C().M(42);

delegate void D(int i);

class C { }

implicit extension E for C
{
    public void M(int i)
    {
        System.Console.Write("ran ");
    }

    public void M(string s) => throw null;
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "ran ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new C().M").First();
        Assert.Equal("void E.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Overloads_DifferentExtensions()
    {
        var source = """
D d = C.M;
d(42);

C.M(42);

delegate void D(int i);

class C { }

implicit extension E1 for C
{
    public static void M(int i)
    {
        System.Console.Write("ran ");
    }
}

implicit extension E2 for C
{
    public static void M(string s) => throw null;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.M").First();
        Assert.Equal("void E1.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_ValueReceiver_Overloads_DifferentExtensions()
    {
        var source = """
D d = new C().M;
d(42);

new C().M(42);

delegate void D(int i);

class C { }

implicit extension E1 for C
{
    public void M(int i)
    {
        System.Console.Write("ran ");
    }
}

implicit extension E2 for C
{
    public void M(string s) => throw null;
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "ran ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new C().M").First();
        Assert.Equal("void E1.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Overloads_OuterScope()
    {
        var source = """
using N;

D d = C.M; // 1
d(42);

C.M(42);

delegate void D(int i);

class C { }

namespace N
{
    implicit extension E1 for C
    {
        public static void M(int i)
        {
            System.Console.Write("ran ");
        }
    }
}

implicit extension E2 for C
{
    public static void M(string s) => throw null;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.M").First();
        Assert.Equal("void N.E1.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_ValueReceiver_Overloads_OuterScope()
    {
        var source = """
using N;

D d = new C().M;
d(42);

new C().M(42);

delegate void D(int i);

class C { }

namespace N
{
    implicit extension E1 for C
    {
        public void M(int i)
        {
            System.Console.Write("ran");
        }
    }
}

implicit extension E2 for C
{
    public void M(string s) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new C().M").First();
        Assert.Equal("void N.E1.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Overloads_OuterScope_WithInapplicableInstanceMember()
    {
        var source = """
using N;

D d = C.M;
d(42);

C.M(42);

delegate void D(int i);

class C
{
    public static void M(char c) { }
}

namespace N
{
    implicit extension E1 for C
    {
        public static void M(int i)
        {
            System.Console.Write("ran ");
        }
    }
}

implicit extension E2 for C
{
    public static void M(string s) => throw null;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.M").First();
        Assert.Equal("void N.E1.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M(System.Char c)" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_ValueReceiver_Overloads_OuterScope_WithInapplicableInstanceMember()
    {
        var source = """
using N;

D d = new C().M;
d(42);

new C().M(42);

delegate void D(int i);

class C
{
    public void M(char c) { }
}

namespace N
{
    implicit extension E1 for C
    {
        public void M(int i)
        {
            System.Console.Write("ran ran");
        }
    }
}

implicit extension E2 for C
{
    public void M(string s) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "ran ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new C().M").First();
        Assert.Equal("void N.E1.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M(System.Char c)" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Overloads_InnerScope()
    {
        var source = """
using N;

D d = C.M;
d(42);

delegate void D(int i);

class C { }

implicit extension E1 for C
{
    public static void M(int i)
    {
        System.Console.Write("ran");
    }
}

namespace N
{
    implicit extension E2 for C
    {
        public static void M(int i) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1)
            );

        CompileAndVerify(comp, expectedOutput: "ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E1.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_TypeArguments()
    {
        var source = """
D d = C.M<object>;
d(42);

delegate void D(int i);
class C { }

implicit extension E for C
{
    public static void M(int i) => throw null;
    public static void M<T>(int i)
    {
        System.Console.Write("ran");
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M<object>");
        Assert.Equal("void E.M<System.Object>(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void DelegateConversion_InstanceReceiver_TypeArguments()
    {
        var source = """
D d = new C().M<object>;
d(42);

delegate void D(int i);
class C { }

implicit extension E for C
{
    public void M(int i) => throw null;
    public void M<T>(int i)
    {
        System.Console.Write("ran");
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M<object>");
        Assert.Equal("void E.M<System.Object>(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_TypeArguments_WrongNumber()
    {
        var source = """
C.M<object, object>(42);

class C { }

implicit extension E for C
{
    public static void M(int i) => throw null;
    public static void M<T>(int i) => throw null;
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should give an updated error message (possibly ERR_NoSuchMemberOrExtension)
        comp.VerifyDiagnostics(
            // 0.cs(1,3): error CS0117: 'C' does not contain a definition for 'M'
            // C.M<object, object>(42);
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M<object, object>").WithArguments("C", "M").WithLocation(1, 3)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M<object, object>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionInvocation_InstanceReceiver_TypeArguments_WrongNumber()
    {
        var source = """
new C().M<object, object>(42);

class C { }

implicit extension E for C
{
    public void M(int i) => throw null;
    public void M<T>(int i) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(1,9): error CS1061: 'C' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            // new C().M<object, object>(42);
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M<object, object>").WithArguments("C", "M").WithLocation(1, 9)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M<object, object>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_TypeArguments_Omitted()
    {
        var source = """
C.M<>(42);

class C { }

implicit extension E for C
{
    public static void M<T>(int i) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(1,1): error CS8389: Omitting the type argument is not allowed in the current context
            // C.M<>(42);
            Diagnostic(ErrorCode.ERR_OmittedTypeArgument, "C.M<>").WithLocation(1, 1)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M<>");
        Assert.Equal("void E.M<?>(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_InstanceReceiver_TypeArguments_Omitted()
    {
        var source = """
new C().M<>(42);

class C { }

implicit extension E for C
{
    public void M<T>(int i) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,1): error CS8389: Omitting the type argument is not allowed in the current context
            // new C().M<>(42);
            Diagnostic(ErrorCode.ERR_OmittedTypeArgument, "new C().M<>").WithLocation(1, 1)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M<>");
        Assert.Equal("void E.M<?>(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_TypeArguments_Inferred()
    {
        // No type arguments passed, but the extension type method is found and the type parameter inferred
        var source = """
C.M(42);

class C { }

implicit extension E for C
{
    public static void M<T>(T t)
    {
        System.Console.Write($"M({t})");
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "M(42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E.M<System.Int32>(System.Int32 t)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_InstanceReceiver_TypeArguments_Inferred()
    {
        // No type arguments passed, but the extension type method is found and the type parameter inferred
        var source = """
new C().M(42);

class C { }

implicit extension E for C
{
    public void M<T>(T t)
    {
        System.Console.Write($"M({t})");
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E.M<System.Int32>(System.Int32 t)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_StaticReceiver_InstanceExtensionMethod()
    {
        // The extension method is not static, but the receiver is a type
        var source = """
C.M();

class C { }

implicit extension E for C
{
    public void M() => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(1,1): error CS0120: An object reference is required for the non-static field, method, or property 'E.M()'
            // C.M();
            Diagnostic(ErrorCode.ERR_ObjectRequired, "C.M").WithArguments("E.M()").WithLocation(1, 1)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionInvocation_InstanceReceiver_StaticExtensionMethod()
    {
        // The extension method is static but the receiver is a value
        var source = """
new C().M();

class C { }

implicit extension E for C
{
    public static void M() => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(1,1): error CS0176: Member 'E.M()' cannot be accessed with an instance reference; qualify it with a type name instead
            // new C().M();
            Diagnostic(ErrorCode.ERR_ObjectProhibited, "new C().M").WithArguments("E.M()").WithLocation(1, 1)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void IndexerAccess_Simple()
    {
        var source = """
/*<bind>*/
_ = (new C())[42];
/*</bind>*/

class C
{
    public int this[string s]
    {
        get => throw null;
    }
}

implicit extension E for C
{
    public int this[int i]
    {
        get
        {
            System.Console.Write("ran");
            return 0;
        }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        string expectedOperationTree = """
ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: System.Int32) (Syntax: '_ = (new C())[42]')
Left:
  IDiscardOperation (Symbol: System.Int32 _) (OperationKind.Discard, Type: System.Int32) (Syntax: '_')
Right:
  IPropertyReferenceOperation: System.Int32 E.this[System.Int32 i] { get; } (OperationKind.PropertyReference, Type: System.Int32) (Syntax: '(new C())[42]')
    Instance Receiver:
      IObjectCreationOperation (Constructor: C..ctor()) (OperationKind.ObjectCreation, Type: C) (Syntax: 'new C()')
        Arguments(0)
        Initializer:
          null
    Arguments(1):
        IArgumentOperation (ArgumentKind.Explicit, Matching Parameter: i) (OperationKind.Argument, Type: null) (Syntax: '42')
          ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 42) (Syntax: '42')
          InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
          OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
""";
        var expectedDiagnostics = DiagnosticDescription.None;

        VerifyOperationTreeAndDiagnosticsForTest<AssignmentExpressionSyntax>(source,
            expectedOperationTree, expectedDiagnostics);
    }

    [Fact]
    public void ExtensionMethodOnTypeReceiver()
    {
        var source = """
C.Method();

public class C { }

public static class E
{
    public static void Method(this C c) { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(1,1): error CS0120: An object reference is required for the non-static field, method, or property 'E.Method(C)'
            // C.Method();
            Diagnostic(ErrorCode.ERR_ObjectRequired, "C.Method").WithArguments("E.Method(C)").WithLocation(1, 1)
            );
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_WithExtensionMethod()
    {
        var source = """
C.Method();

public class C { }

public static class E1
{
    public static void Method(this C c) { }
}

implicit extension E2 for C
{
    public static void Method() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Equal("void E2.Method()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.Method()" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_TypeParameter()
    {
        var source = """
public class C<T>
{
    void M()
    {
        T.Method();
    }

    implicit extension E for T
    {
        public static void Method() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(5,9): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         T.Method();
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(5, 9)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "T.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_TypeParameter_InNameof()
    {
        var source = """
public class C<T>
{
    void M()
    {
        _ = nameof(T.Method);
    }

    implicit extension E for T
    {
        public static void Method() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(5,20): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         _ = nameof(T.Method);
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(5, 20)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "T.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_TypeParameterWithStaticMethod()
    {
        var source = """
public interface I
{
    public static void Method() { }
}

public class C<T> where T : I
{
    void M()
    {
        T.Method();
    }

    implicit extension E for T
    {
        public static void Method() { }
    }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // 0.cs(10,9): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         T.Method();
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(10, 9)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "T.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_TypeParameterWithStaticAbstractMethod()
    {
        var source = """
public interface I
{
    public static abstract void Method();
}

public class C<T> where T : I
{
    void M()
    {
        T.Method();
    }

    implicit extension E for T
    {
        public static void Method() { }
    }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "T.Method");
        Assert.Equal("void I.Method()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void I.Method()" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_TypeParameterWithStaticAbstractMethod_Overloads()
    {
        var source = """
public interface I
{
    public static abstract void Method();
}

public class C<T> where T : I
{
    void M()
    {
        T.Method(42);
    }

    implicit extension E for T
    {
        public static void Method(int i) { }
    }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // 0.cs(10,11): error CS1501: No overload for method 'Method' takes 1 arguments
            //         T.Method(42);
            Diagnostic(ErrorCode.ERR_BadArgCount, "Method").WithArguments("Method", "1").WithLocation(10, 11)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "T.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(new[] { "void I.Method()" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_ValueReceiver_TypeParameter()
    {
        var source = """
public class C<T>
{
    void M(T t)
    {
        t.Method();
    }

    implicit extension E for T
    {
        public void Method() { }
    }
}
""";
        // PROTOTYPE need to confirm what we want for extension invocations on type parameters
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (5,11): error CS1061: 'T' does not contain a definition for 'Method' and no accessible extension method 'Method' accepting a first argument of type 'T' could be found (are you missing a using directive or an assembly reference?)
            //         t.Method();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Method").WithArguments("T", "Method").WithLocation(5, 11)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "t.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionInvocation_GenericType()
    {
        var src = """
C<int>.StaticType<string>();

class C<T> { }

implicit extension E<T> for C<T>
{
    public static class StaticType<U> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,8): error CS0117: 'C<int>' does not contain a definition for 'StaticType'
            // C<int>.StaticType<string>();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "StaticType<string>").WithArguments("C<int>", "StaticType").WithLocation(1, 8));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.StaticType<string>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        // PROTOTYPE need to fix the semantic model
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void ExtensionInvocation_InvokableField_WithTypeArguments()
    {
        var src = """
C<int>.Field<string>();

class C<T> { }

implicit extension E<T> for C<T>
{
    public static System.Action Field = null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,8): error CS0117: 'C<int>' does not contain a definition for 'Field'
            // C<int>.Field<string>();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Field<string>").WithArguments("C<int>", "Field").WithLocation(1, 8));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.Field<string>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void RefOmittedComCall()
    {
        // For COM import type, omitting the ref is allowed
        string source = @"
using System;
using System.Runtime.InteropServices;

[ComImport, Guid(""1234C65D-1234-447A-B786-64682CBEF136"")]
class C { }

implicit extension E for C
{
    public void M(ref short p) { }
    public void M(sbyte p) { }
    public void I(ref int p) { }
}

class X
{
    public static void Goo()
    {
        short x = 123;
        C c = new C();
        c.M(x);
        c.I(123);
    }
}
";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void ExtensionMethodGroup_TypeReceiver_StaticExtension()
    {
        var source = """
var d = C.M;
d(42);

class C { }

implicit extension E for C
{
    public static void M(int i)
    {
        System.Console.Write("E.M");
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE need to infer delegate type
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "E.M");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void FunctionType_ValueReceiver_StaticExtension()
    {
        // The method from extension is static
        var source = """
var d = new C().M; // 1

class C { }

implicit extension E for C
{
    public static void M() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,9): error CS0176: Member 'E.M()' cannot be accessed with an instance reference; qualify it with a type name instead
            // var d = new C().M; // 1
            Diagnostic(ErrorCode.ERR_ObjectProhibited, "new C().M").WithArguments("E.M()").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        // PROTOTYPE need to fix the semantic model
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void FunctionType_TypeReceiver_InstanceAndExtension_DifferentSignatures()
    {
        // The instance method and the method from extension have different signatures
        var source = """
var d = C.M; // 1

class C
{
    public static void M() { }
}

implicit extension E for C
{
    public static void M(int i)
    {
        System.Console.Write("E.M");
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void C.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M()" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void FunctionType_ValueReceiver_ExtensionAndExtensionMethod_DifferentSignatures()
    {
        // The extension method and the method from extension have different signatures
        var source = """
var d = new C().M; // 1

public class C { }

implicit extension E1 for C
{
    public void M(int i) { }
}

public static class E2
{
    public static void M(this C c, string s) { }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE we will want to merge extension type members and extension methods, resulting in an error here
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E1.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        Assert.Equal(["void C.M(System.String s)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void FunctionType_TypeReceiver_InstanceAndExtension_SameSignatures()
    {
        var source = """
var d = C.M;

class C
{
    public static void M() { }
}

implicit extension E for C
{
    public static void M() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void C.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void C.M()" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void InferredVariable_TypeReceiver_InstanceAndExtension_SameSignatures()
    {
        var source = """
var d = C.M;
d();

class C
{
    public static void M() { System.Console.Write("ran"); }
}

implicit extension E for C
{
    public static void M() => throw null;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void C.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void InferredVariable_TypeReceiver_InstanceAndExtension_DifferentSignatures()
    {
        // The instance method and the method from extension have different signatures
        var source = """
var d = C.M;
d();

class C
{
    public static void M() { System.Console.Write("ran"); }
}

implicit extension E for C
{
    public static void M(int i) => throw null;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void C.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionMethodAsReceiverOfMemberAccess()
    {
        var source = """
C.M.ToString();

class C { }

implicit extension E for C
{
    public static void M() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(1,3): error CS0119: 'E.M()' is a method, which is not valid in the given context
            // C.M.ToString();
            Diagnostic(ErrorCode.ERR_BadSKunknown, "M").WithArguments("E.M()", "method").WithLocation(1, 3)
            );

        // PROTOTYPE could improve the semantic model to return symbol `E.M()`
        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionMethodAsReceiverOfMemberAccess_FindIndexer()
    {
        var source = """
C c = null;
c.Item.ToString();
c.get_Item.ToString();

class C { }

implicit extension E for C
{
    public int this[int i] { get { throw null; } set { throw null; } }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (2,3): error CS1061: 'C' does not contain a definition for 'Item' and no accessible extension method 'Item' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            // c.Item.ToString();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Item").WithArguments("C", "Item").WithLocation(2, 3),
            // (3,3): error CS1061: 'C' does not contain a definition for 'get_Item' and no accessible extension method 'get_Item' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            // c.get_Item.ToString();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "get_Item").WithArguments("C", "get_Item").WithLocation(3, 3)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "c.Item");
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess1));

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "c.get_Item");
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess2));
    }

    [Fact]
    public void SymbolInfoForMethodGroup03()
    {
        var source = """
public class A { }

implicit extension E for A
{
    public string Extension() { return null; }
}
public class Program
{
    public static void Main(string[] args)
    {
        A a = null;
        _ = nameof(a.Extension);
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should we produce ERR_NameofExtensionMethod (Extension method groups are not allowed as an argument to 'nameof') or something similar?
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "a.Extension");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void NotInvocable_TypeReceiver()
    {
        var source = """
C.f();

public class C
{
    public int f;
}
""";

        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,3): error CS1955: Non-invocable member 'C.f' cannot be used like a method.
            // C.f();
            Diagnostic(ErrorCode.ERR_NonInvocableMemberCalled, "f").WithArguments("C.f").WithLocation(1, 3)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.f");
        var symbolInfo = model.GetSymbolInfo(memberAccess);
        Assert.Null(symbolInfo.Symbol);
        Assert.Empty(symbolInfo.CandidateSymbols);
        Assert.Null(model.GetTypeInfo(memberAccess).Type);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void NotInvocable_InstanceReceiver()
    {
        var source = """
new C().f();

public class C
{
    public int f;
}
""";

        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,9): error CS1955: Non-invocable member 'C.f' cannot be used like a method.
            // new C().f();
            Diagnostic(ErrorCode.ERR_NonInvocableMemberCalled, "f").WithArguments("C.f").WithLocation(1, 9)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().f");
        var symbolInfo = model.GetSymbolInfo(memberAccess);
        Assert.Null(symbolInfo.Symbol);
        Assert.Empty(symbolInfo.CandidateSymbols);
        Assert.Null(model.GetTypeInfo(memberAccess).Type);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void NotInvocable_TypeReceiver_WithExtensionType()
    {
        var source = """
C.f();

public class C
{
    public int f;
}

implicit extension E for C
{
    public static void f()
    {
        System.Console.Write("f");
    }
}
""";

        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "f").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.f");
        Assert.Equal("void E.f()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Null(model.GetTypeInfo(memberAccess).Type);
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void NotInvocable_InstanceReceiver_WithExtensionType()
    {
        var source = """
new C().f();

public class C
{
    public int f;
}

implicit extension E for C
{
    public void f() { System.Console.Write("ran"); }
}
""";

        var comp = CreateCompilation(source);
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().f");
        Assert.Equal("void E.f()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Null(model.GetTypeInfo(memberAccess).Type);
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_InstanceReceiver_InTypeInference()
    {
        // We resolve the method group for `M` as part of overload resolution for `Select`
        var source = """
class D
{
    public static void Main()
    {
        int i = new D().Select(new C().M);
    }

    T Select<T>(System.Func<T> t)
    {
        t();
        return default;
    }
}

public class C { }

implicit extension E for C
{
    public int M() { System.Console.Write("ran"); return 0; }
}
""";

        var comp = CreateCompilation(source, options: TestOptions.DebugExe);

        var verifier = CompileAndVerify(comp, expectedOutput: "ran");

        verifier.VerifyDiagnostics();

        verifier.VerifyIL("D.Main", """
{
  // Code size       29 (0x1d)
  .maxstack  3
  .locals init (int V_0) //i
  IL_0000:  nop
  IL_0001:  newobj     "D..ctor()"
  IL_0006:  newobj     "C..ctor()"
  IL_000b:  ldftn      "int E.M(C)"
  IL_0011:  newobj     "System.Func<int>..ctor(object, System.IntPtr)"
  IL_0016:  call       "int D.Select<int>(System.Func<int>)"
  IL_001b:  stloc.0
  IL_001c:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("System.Int32 E.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionInvocation_TypeReceiver_TypeInference()
    {
        // We resolve the method group for `M` as part of overload resolution for `Select`
        var source = """
class D
{
    public static void Main()
    {
        new D().Select(C.M);
    }

    T Select<T>(System.Func<T> t)
    {
        t();
        return default;
    }
}

public class C { }

implicit extension E for C
{
    public static int M() { System.Console.Write("ran"); return 0; }
}
""";

        var comp = CreateCompilation(source, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.Int32 E.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void AddressOf_AmbiguousBestMethod()
    {
        var src = """
unsafe class C
{
    static void M1()
    {
        delegate*<string, string, void> ptr = &C.M;
    }
}

implicit extension E for C
{
    public static void M(string s, object o) {}
    public static void M(object o, string s) {}
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (5,48): error CS0121: The call is ambiguous between the following methods or properties: 'E.M(string, object)' and 'E.M(object, string)'
            //         delegate*<string, string, void> ptr = &C.M;
            Diagnostic(ErrorCode.ERR_AmbigCall, "C.M").WithArguments("E.M(string, object)", "E.M(object, string)").WithLocation(5, 48)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionMethodsInNonInvocationLookup()
    {
        var src = """
public implicit extension E1 for object
{
    public int Member => throw null;
}

namespace N
{
    public static class E2
    {
        public static void Member(this object o)
        {
            System.Console.Write("ran ");
        }
    }

    class C
    {
        public static void Main()
        {
            var o = new object();

            var x = o.Member;
            x();

            System.Action y = o.Member;
            y();

            o.Member();
        }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "ran ran ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").First();
        Assert.Equal("void System.Object.Member()", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void System.Object.Member()" }, model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").Skip(1).First();
        Assert.Equal("void System.Object.Member()", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void System.Object.Member()" }, model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());

        var memberAccess3 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").Skip(2).Single();
        Assert.Equal("void System.Object.Member()", model.GetSymbolInfo(memberAccess3).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void System.Object.Member()" }, model.GetMemberGroup(memberAccess3).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMethodsInNonInvocationLookup_Generic()
    {
        var src = """
public implicit extension E1 for object
{
    public int Member => throw null;
}

namespace N
{
    public static class E2
    {
        public static void Member<T>(this T o)
        {
            System.Console.Write("ran ");
        }
    }

    class C
    {
        public static void Main()
        {
            var o = new object();

            var x = o.Member;
            x();

            System.Action y = o.Member;
            y();

            o.Member();
        }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").First();
        Assert.Equal("void System.Object.Member<System.Object>()", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void System.Object.Member<System.Object>()" }, model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").Skip(1).First();
        Assert.Equal("void System.Object.Member<System.Object>()", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void System.Object.Member<System.Object>()" }, model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());

        var memberAccess3 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").Skip(2).Single();
        Assert.Equal("void System.Object.Member<System.Object>()", model.GetSymbolInfo(memberAccess3).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void System.Object.Member<System.Object>()" }, model.GetMemberGroup(memberAccess3).ToTestDisplayStrings());
    }

    [Fact]
    public void InferredVariable_ValueReceiver_InapplicableGeneric()
    {
        var src = """
public implicit extension E1 for object
{
    public int Member { get { System.Console.Write("ran "); return 42; } }
}

namespace N
{
    public static class E2
    {
        public static void Member<T>(this T o) where T : struct { }
    }

    class C
    {
        public static void Main()
        {
            var o = new object();
            var x = o.Member;
            System.Console.Write(x);
        }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.Member");
        Assert.Equal("System.Int32 E1.Member { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMethodsInInvocationLookup_AfterExtensionType()
    {
        var src = """
var o = new object();
var x = o.Member;
System.Console.Write(x);

o.Member();

public implicit extension E1 for object
{
    public string Member => "not-invocation ";
}

public static class E2
{
    public static void Member(this object o)
    {
        System.Console.Write("invocation ");
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var verifier = CompileAndVerify(comp, expectedOutput: "not-invocation invocation");
        verifier.VerifyDiagnostics();
        // PROTOTYPE Fix IL when adding support for emitting non-static members
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size       22 (0x16)
  .maxstack  2
  IL_0000:  newobj     "object..ctor()"
  IL_0005:  dup
  IL_0006:  call       "string E1.Member[object].get"
  IL_000b:  call       "void System.Console.Write(string)"
  IL_0010:  call       "void E2.Member(object)"
  IL_0015:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").ToArray();
        Assert.Equal("System.String E1.Member { get; }", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess[0]));

        Assert.Equal("void System.Object.Member()", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());
        Assert.Equal(["void System.Object.Member()"], model.GetMemberGroup(memberAccess[1]).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMethodsInInvocationLookup_AfterExtensionType_ConversionToDelegateType()
    {
        var src = """
var o = new object();
System.Action y = o.Member;

public implicit extension E1 for object
{
    public string Member => throw null;
}

public static class E2
{
    public static void Member(this object o) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,19): error CS0029: Cannot implicitly convert type 'string' to 'System.Action'
            // System.Action y = o.Member;
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "o.Member").WithArguments("string", "System.Action").WithLocation(2, 19));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.Member");
        Assert.Equal("System.String E1.Member { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionMethodsInInvocationLookup_AfterExtensionType_Import()
    {
        var src = """
using N;

var o = new object();
var x = o.Member;
System.Console.Write(x);

o.Member();

namespace N
{
    public implicit extension E1 for object
    {
        public string Member => "not-invocation ";
    }

    public static class E2
    {
        public static void Member(this object o)
        {
            System.Console.Write("invocation ");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        var verifier = CompileAndVerify(comp, expectedOutput: "not-invocation invocation");
        verifier.VerifyDiagnostics();
        // PROTOTYPE Fix IL when adding support for emitting non-static members
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size       22 (0x16)
  .maxstack  2
  IL_0000:  newobj     "object..ctor()"
  IL_0005:  dup
  IL_0006:  call       "string N.E1.Member[object].get"
  IL_000b:  call       "void System.Console.Write(string)"
  IL_0010:  call       "void N.E2.Member(object)"
  IL_0015:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").ToArray();
        Assert.Equal("System.String N.E1.Member { get; }", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess[0]));

        Assert.Equal("void System.Object.Member()", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());
        Assert.Equal(["void System.Object.Member()"], model.GetMemberGroup(memberAccess[1]).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMethodsInInvocationLookup_AfterExtensionType_Import_ConversionToDelegateType()
    {
        var src = """
using N;

var o = new object();
System.Action y = o.Member;

namespace N
{
    public implicit extension E1 for object
    {
        public string Member => throw null;
    }

    public static class E2
    {
        public static void Member(this object o) => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (4,19): error CS0029: Cannot implicitly convert type 'string' to 'System.Action'
            // System.Action y = o.Member;
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "o.Member").WithArguments("string", "System.Action").WithLocation(4, 19));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.Member");
        Assert.Equal("System.String N.E1.Member { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionMethodsInNonInvocationLookup_ComesBeforeExtensionTypeInNextScope()
    {
        // Imported extension methods come before extension type members in outer scope
        var src = """
public implicit extension E1 for object
{
    public int Member => throw null;
}

namespace N1
{
    using N2;

    class C
    {
        public static void Main()
        {
            var o = new object();
            var x = o.Member;
            x();

            System.Action y = o.Member;
            y();

            o.Member();
        }
    }
}

namespace N2
{
    public static class E2
    {
        public static void Member(this object o)
        {
            System.Console.Write("ran ");
        }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics();
        var verifier = CompileAndVerify(comp, expectedOutput: "ran ran ran");

        verifier.VerifyIL("N1.C.Main", """
{
  // Code size       55 (0x37)
  .maxstack  2
  .locals init (object V_0, //o
                System.Action V_1, //x
                System.Action V_2) //y
  IL_0000:  nop
  IL_0001:  newobj     "object..ctor()"
  IL_0006:  stloc.0
  IL_0007:  ldloc.0
  IL_0008:  ldftn      "void N2.E2.Member(object)"
  IL_000e:  newobj     "System.Action..ctor(object, System.IntPtr)"
  IL_0013:  stloc.1
  IL_0014:  ldloc.1
  IL_0015:  callvirt   "void System.Action.Invoke()"
  IL_001a:  nop
  IL_001b:  ldloc.0
  IL_001c:  ldftn      "void N2.E2.Member(object)"
  IL_0022:  newobj     "System.Action..ctor(object, System.IntPtr)"
  IL_0027:  stloc.2
  IL_0028:  ldloc.2
  IL_0029:  callvirt   "void System.Action.Invoke()"
  IL_002e:  nop
  IL_002f:  ldloc.0
  IL_0030:  call       "void N2.E2.Member(object)"
  IL_0035:  nop
  IL_0036:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").First();
        Assert.Equal("void System.Object.Member()", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void System.Object.Member()" }, model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").Skip(1).First();
        Assert.Equal("void System.Object.Member()", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void System.Object.Member()" }, model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());

        var memberAccess3 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").Skip(2).Single();
        Assert.Equal("void System.Object.Member()", model.GetSymbolInfo(memberAccess3).Symbol.ToTestDisplayString());
        Assert.Equal(new[] { "void System.Object.Member()" }, model.GetMemberGroup(memberAccess3).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMethodsInInvocationLookup_GenericExtension_ThisParameterNotCompatible()
    {
        var src = """
using N;

C<int> c = new C<int>();
int i = c.Member;
System.Console.Write(i);

public class C<T> { }

public static class E1
{
    public static void Member<T>(this C<T> o) where T : class => throw null;
}

namespace N
{
    public implicit extension E2 for object
    {
        public int Member => 42;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "c.Member").First();
        Assert.Equal("System.Int32 N.E2.Member { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionMethodsInInvocationLookup_GenericExtension_ExtraParameter()
    {
        var src = """
using N;

C<int> c = new C<int>();
int i = c.Member;
System.Console.Write(i);

public class C<T> { }

public static class E1
{
    public static void Member<T>(this C<T> o, string s) => throw null;
}

namespace N
{
    public implicit extension E2 for object
    {
        public int Member => 42;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1),
            // (4,11): error CS0428: Cannot convert method group 'Member' to non-delegate type 'int'. Did you intend to invoke the method?
            // int i = c.Member;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "Member").WithArguments("Member", "int").WithLocation(4, 11)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "c.Member").First();
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);

        Assert.Equal(new[] { "void C<System.Int32>.Member<System.Int32>(System.String s)" },
            model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMethodsInInvocationLookup_GenericExtension_UndeterminedTypeParameter()
    {
        var src = """
using N;

C<int> c = new C<int>();
int i = c.Member;
System.Console.Write(i);

public class C<T> { }

public static class E1
{
    public static void Member<T, U>(this C<T> o, U u) => throw null;
}

namespace N
{
    public implicit extension E2 for object
    {
        public int Member => 42;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1),
            // (4,11): error CS0428: Cannot convert method group 'Member' to non-delegate type 'int'. Did you intend to invoke the method?
            // int i = c.Member;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "Member").WithArguments("Member", "int").WithLocation(4, 11)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "c.Member").First();
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);

        Assert.Equal(new[] { "void C<System.Int32>.Member<System.Int32, U>(U u)" },
            model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMethodsInNonInvocationLookup_Inaccessible()
    {
        // An inaccessible extension method is skipped in favor of an extension type member in outer scope
        var src = """
public implicit extension E1 for object
{
    public int Member { get { System.Console.Write("ran "); return 0; } }
}

namespace N
{
    public static class E2
    {
        private static void Member(this object o) => throw null;
    }

    class C
    {
        public static void Main()
        {
            var o = new object();
            int x = o.Member;
        }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //        var verifier = CompileAndVerify(comp, expectedOutput: "ran");

        //        verifier.VerifyIL("N.C.Main", """
        //{
        //  // Code size       15 (0xf)
        //  .maxstack  1
        //  .locals init (object V_0, //o
        //                int V_1) //x
        //  IL_0000:  nop
        //  IL_0001:  newobj     "object..ctor()"
        //  IL_0006:  stloc.0
        //  IL_0007:  ldloc.0
        //  IL_0008:  callvirt   "int E1.Member.get"
        //  IL_000d:  stloc.1
        //  IL_000e:  ret
        //}
        //""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").Single();
        Assert.Equal("System.Int32 E1.Member { get; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMethodsInNonInvocationLookup_Ineligible()
    {
        // An ineligible extension method comes before an extension type member in outer scope
        var src = """
public implicit extension E1 for object
{
    public int Member { get { System.Console.Write("ran "); return 0; } }
}

namespace N
{
    public static class E2
    {
        public static void Member(this string o) => throw null;
    }

    class C
    {
        public static void Main()
        {
            var o = new object();
            int x = o.Member;
        }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").Single();
        Assert.Equal("System.Int32 E1.Member { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionMethodsInNonInvocationLookup_ExtraParameter()
    {
        var src = """
public implicit extension E1 for object
{
    public int Member { get { System.Console.Write("ran "); return 0; } }
}

namespace N
{
    public static class E2
    {
        public static void Member(this object o, int i) => throw null;
    }

    class C
    {
        public static void Main()
        {
            var o = new object();
            int x = o.Member;
        }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (18,23): error CS0428: Cannot convert method group 'Member' to non-delegate type 'int'. Did you intend to invoke the method?
            //             int x = o.Member;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "Member").WithArguments("Member", "int").WithLocation(18, 23)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "o.Member").Single();
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(new[] { "void System.Object.Member(System.Int32 i)" }, model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMethodsInNonInvocationLookup_FieldBlocksInstanceMethod()
    {
        // A non-invocable field blocks an instance method from base type in non-invocation scenario
        var src = """
C c = null;
System.Action a = c.M; // 1
c.M();

public class Base
{
    public void M() { }
}

public class C : Base
{
    public new int M;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,19): error CS0029: Cannot implicitly convert type 'int' to 'System.Action'
            // System.Action a = c.M; // 1
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "c.M").WithArguments("int", "System.Action").WithLocation(2, 19)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "c.M").First();
        Assert.Equal("System.Int32 C.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "c.M").Skip(1).Single();
        Assert.Equal("void Base.M()", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMethodsInNonInvocationLookup_FieldBlocksExtensionMethod()
    {
        // A non-invocable field blocks an extension method in non-invocation scenario
        var src = """
C c = null;
System.Action a = c.M; // 1
c.M();

public static class E
{
    public static void M(this C c) { }
}

public class C
{
    public int M;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,19): error CS0029: Cannot implicitly convert type 'int' to 'System.Action'
            // System.Action a = c.M; // 1
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "c.M").WithArguments("int", "System.Action").WithLocation(2, 19)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "c.M").First();
        Assert.Equal("System.Int32 C.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "c.M").Skip(1).Single();
        Assert.Equal("void C.M()", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMethodsInNonInvocationLookup_PropertyBlocksExtensionMethod()
    {
        // A non-invocable property blocks an extension method in non-invocation scenario
        var src = """
C c = null;
System.Action a = c.M; // 1
c.M();

public static class E
{
    public static void M(this C c) { }
}

public class C
{
    public int M => 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,19): error CS0029: Cannot implicitly convert type 'int' to 'System.Action'
            // System.Action a = c.M; // 1
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "c.M").WithArguments("int", "System.Action").WithLocation(2, 19)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "c.M").First();
        Assert.Equal("System.Int32 C.M { get; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "c.M").Skip(1).Single();
        Assert.Equal("void C.M()", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMethodsInNonInvocationLookup_PropertyBlocksExtensionTypeMethod()
    {
        // A non-invocable property blocks an extension type method in non-invocation scenario
        var src = """
C c = null;
System.Action a = c.M; // 1
c.M();

implicit extension E for C
{
    public void M() { }
}

public class C
{
    public int M => 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,19): error CS0029: Cannot implicitly convert type 'int' to 'System.Action'
            // System.Action a = c.M; // 1
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "c.M").WithArguments("int", "System.Action").WithLocation(2, 19)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "c.M").First();
        Assert.Equal("System.Int32 C.M { get; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "c.M").Skip(1).Single();
        Assert.Equal("void E.M()", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ParameterCapturing_023_ColorColor_MemberAccess_InstanceAndStatic_ExtensionTypeMethods()
    {
        // See ParameterCapturing_023_ColorColor_MemberAccess_InstanceAndStatic_Method
        var source = """
struct S1(Color Color)
{
    public void Test()
    {
        Color.M1(this);
    }
}

class Color { }

implicit extension E for Color
{
    public void M1(S1 x, int y = 0)
    {
        System.Console.WriteLine("instance");
    }

    public static void M1<T>(T x) where T : unmanaged
    {
        System.Console.WriteLine("static");
    }
}
""";
        // PROTOTYPE missing ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver
        var comp = CreateCompilation(source, options: TestOptions.ReleaseDll);
        comp.VerifyDiagnostics(
            //// (5,9): error CS9106: Identifier 'Color' is ambiguous between type 'Color' and parameter 'Color Color' in this context.
            ////         Color.M1(this);
            //Diagnostic(ErrorCode.ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver, "Color").WithArguments("Color", "Color", "Color Color").WithLocation(5, 9)
            );

        Assert.NotEmpty(comp.GetTypeByMetadataName("S1").InstanceConstructors.OfType<SynthesizedPrimaryConstructor>().Single().GetCapturedParameters());

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.M1");
        Assert.Equal("void E.M1(S1 x, [System.Int32 y = 0])", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ParameterCapturing_023_ColorColor_MemberAccess_InstanceAndStatic_ExtensionTypeProperties()
    {
        var source = """
struct S1(Color Color)
{
    public void Test()
    {
        _ = Color.P1;
    }
}

class Color { }

implicit extension E1 for Color
{
    public int P1 => 0;
}

implicit extension E2 for Color
{
    public static int P1 => 0;
}
""";
        var comp = CreateCompilation(source, options: TestOptions.ReleaseDll);
        comp.VerifyDiagnostics(
            // (5,19): error CS0229: Ambiguity between 'E1.P1' and 'E2.P1'
            //         _ = Color.P1;
            Diagnostic(ErrorCode.ERR_AmbigMember, "P1").WithArguments("E1.P1", "E2.P1").WithLocation(5, 19));

        Assert.NotEmpty(comp.GetTypeByMetadataName("S1").InstanceConstructors.OfType<SynthesizedPrimaryConstructor>().Single().GetCapturedParameters());

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.P1");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void ParameterCapturing_023_ColorColor_MemberAccess_InstanceAndStatic_ExtensionTypeMembersVsExtensionMethod()
    {
        var source = """
public struct S1(Color Color)
{
    public void Test()
    {
        Color.M1(this);
    }
}

public class Color { }

public static class E1
{
    public static void M1(this Color c, S1 x, int y = 0)
    {
        System.Console.WriteLine("instance");
    }
}

implicit extension E2 for Color
{
    public static void M1<T>(T x) where T : unmanaged
    {
        System.Console.WriteLine("static");
    }
}
""";
        // PROTOTYPE missing ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver
        var comp = CreateCompilation(source, options: TestOptions.ReleaseDll);
        comp.VerifyDiagnostics(
            //// (5,9): error CS9106: Identifier 'Color' is ambiguous between type 'Color' and parameter 'Color Color' in this context.
            ////         Color.M1(this);
            //Diagnostic(ErrorCode.ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver, "Color").WithArguments("Color", "Color", "Color Color").WithLocation(5, 9)
            );

        Assert.NotEmpty(comp.GetTypeByMetadataName("S1").InstanceConstructors.OfType<SynthesizedPrimaryConstructor>().Single().GetCapturedParameters());

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.M1");
        Assert.Equal("void Color.M1(S1 x, [System.Int32 y = 0])", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void NotOnBase()
    {
        // Unlike `this`, `base` is not an expression in itself.
        // "Extension invocation" and "extension member lookup" do not apply to `base_access` syntax.
        var src = """
class Base { }

class Derived : Base
{
    void Main()
    {
        M(); // 1
        this.M();
        base.M(); // 2
        _ = P; // 3
        _ = this.P;
        _ = base.P; // 4
    }
}

implicit extension E for Base
{
    public void M() { }
    public int P => 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (7,9): error CS0103: The name 'M' does not exist in the current context
            //         M(); // 1
            Diagnostic(ErrorCode.ERR_NameNotInContext, "M").WithArguments("M").WithLocation(7, 9),
            // (9,14): error CS0117: 'Base' does not contain a definition for 'M'
            //         base.M(); // 2
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("Base", "M").WithLocation(9, 14),
            // (10,13): error CS0103: The name 'P' does not exist in the current context
            //         _ = P; // 3
            Diagnostic(ErrorCode.ERR_NameNotInContext, "P").WithArguments("P").WithLocation(10, 13),
            // (12,18): error CS0117: 'Base' does not contain a definition for 'P'
            //         _ = base.P; // 4
            Diagnostic(ErrorCode.ERR_NoSuchMember, "P").WithArguments("Base", "P").WithLocation(12, 18)
            );
    }

    [Fact]
    public void CompoundAssignment()
    {
        var src = """
object.P += 1;
System.Console.Write($"Property({object.P}) ");

object.Field += 1;
System.Console.Write($"Field({object.Field}) ");

implicit extension E for object
{
    public static int P { get; set; } = 42;
    public static int Field = 42;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Property(43) Field(43)")
            .VerifyDiagnostics();
    }

    [Fact]
    public void LookupKind_DelegateConversion()
    {
        var src = """
using N;

System.Action a = object.Member;
a();

implicit extension E1 for object
{
    public class Member { }
}

namespace N
{
    implicit extension E2 for object
    {
        public static void Member()
        {
            System.Console.Write("ran ");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,19): error CS0119: 'E1.Member' is a type, which is not valid in the given context
            // System.Action a = object.Member;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "object.Member").WithArguments("E1.Member", "type").WithLocation(3, 19));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Member");
        Assert.Equal("E1.Member", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void LookupKind_Invocation()
    {
        // Non-invcable extension member in inner scope is skipped in favor of invocable one from outer scope
        var src = """
using N;

object.Member();

implicit extension E1 for object
{
    public class Member { }
}

namespace N
{
    implicit extension E2 for object
    {
        public static void Member()
        {
            System.Console.Write("ran ");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Member");
        Assert.Equal("void N.E2.Member()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void LookupKind_OtherConversion()
    {
        var src = """
using N;

int a = object.Member;

implicit extension E1 for object
{
    public class Member { }
}

namespace N
{
    implicit extension E2 for object
    {
        public static void Member() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1),
            // (3,9): error CS0119: 'E1.Member' is a type, which is not valid in the given context
            // int a = object.Member;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "object.Member").WithArguments("E1.Member", "type").WithLocation(3, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Member");
        Assert.Equal("E1.Member", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ReturnType_FindExtensionTypeMethod()
    {
        var src = """
System.Console.Write(local(object.M));

T local<T>(System.Func<T> f) => f();

implicit extension E for object
{
    public static int M() => 42;
}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp, expectedOutput: "42")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ReturnType_FindExtensionTypeMethod_PickBestOverload()
    {
        var src = """
System.Console.Write(local(object.M));

T local<T>(System.Func<int, T> f) => f(42);

implicit extension E for object
{
    public static int M(int i) => i;
    public static string M(string s) => throw null;
}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp, expectedOutput: "42")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ReturnType_FindType()
    {
        var src = """
int i = object.M;

implicit extension E for object
{
    public class M { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,9): error CS0119: 'E.M' is a type, which is not valid in the given context
            // int i = object.M;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "object.M").WithArguments("E.M", "type").WithLocation(1, 9)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ReturnType_FindType_DelegateType()
    {
        var src = """
System.Console.Write(local(object.M));

T local<T>(System.Func<T> f) => f();

implicit extension E1 for object
{
    public class M { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,28): error CS0119: 'E1.M' is a type, which is not valid in the given context
            // System.Console.Write(local(object.M));
            Diagnostic(ErrorCode.ERR_BadSKunknown, "object.M").WithArguments("E1.M", "type").WithLocation(1, 28),
            // (3,3): warning CS8321: The local function 'local' is declared but never used
            // T local<T>(System.Func<T> f) => f();
            Diagnostic(ErrorCode.WRN_UnreferencedLocalFunction, "local").WithArguments("local").WithLocation(3, 3));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void IndexExpression()
    {
        var src = """
var x = new[] { 1, 2, 3 };
System.Console.Write(x[^object.f]);

implicit extension E for object
{
    public static int f = 2;
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: Verification.FailsPEVerify)
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.f");
        Assert.Equal("System.Int32 E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void RangeExpression()
    {
        var src = """
var x = new[] { 1, 2, 3 };
System.Console.Write(x[0..object.f].Length);

implicit extension E for object
{
    public static int f = 2;
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: Verification.FailsPEVerify)
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.f");
        Assert.Equal("System.Int32 E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ArrayIndexer()
    {
        var src = """
var x = new[] { 1, 2, 3 };
System.Console.Write(x[object.f]);

implicit extension E for object
{
    public static int f = 2;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "3")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.f");
        Assert.Equal("System.Int32 E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void CollectionInitializer()
    {
        var src = """
var x = new System.Collections.Generic.List<int> { object.f };
System.Console.Write(x[0]);

implicit extension E for object
{
    public static int f = 2;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "2")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.f");
        Assert.Equal("System.Int32 E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ArrayInitializer()
    {
        var src = """
var x = new[] { object.f };
System.Console.Write(x[0]);

implicit extension E for object
{
    public static int f = 2;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "2").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.f");
        Assert.Equal("System.Int32 E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ArrayInitializer_Null()
    {
        var src = """
var x = new[] { object.f, null };
System.Console.Write(x[0]);

implicit extension E for object
{
    public static string f = "ran";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.f");
        Assert.Equal("System.String E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void BinaryOperator_Default()
    {
        var src = """
int i = default + object.f;

implicit extension E for object
{
    public static int f = 2;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,9): error CS8310: Operator '+' cannot be applied to operand 'default'
            // int i = default + object.f;
            Diagnostic(ErrorCode.ERR_BadOpOnNullOrDefaultOrNew, "default + object.f").WithArguments("+", "default").WithLocation(1, 9)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.f");
        Assert.Equal("System.Int32 E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void BinaryOperator()
    {
        var src = """
int i = object.f + object.f;
System.Console.Write(i);

implicit extension E for object
{
    public static int f = 2;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "4")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.Int32 E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var binaryOp = GetSyntax<BinaryExpressionSyntax>(tree, "object.f + object.f");
        Assert.Equal("System.Int32 System.Int32.op_Addition(System.Int32 left, System.Int32 right)", model.GetSymbolInfo(binaryOp).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void NullCoalescingAssignment_LHS()
    {
        var src = """
object.f ??= "hi";
System.Console.Write(object.f);

implicit extension E for object
{
    public static string f = null;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.String E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void NullCoalescingAssignment_RHS()
    {
        var src = """
string s = null;
s ??= object.f;
System.Console.Write(s);

implicit extension E for object
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.String E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void Ternary()
    {
        var src = """
bool b = true;
var x = b ? object.f : object.f;
System.Console.Write(object.f);

implicit extension E for object
{
    public static string f = "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.String E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void Ternary_Null()
    {
        var src = """
bool b = true;
var x = b ? object.f : null;
System.Console.Write(object.f);

implicit extension E for object
{
    public static string f = "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.String E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void RefExpression()
    {
        var src = """
ref var x = ref object.f;
System.Console.Write(object.f);

implicit extension E for object
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.String E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ReturnStatement()
    {
        var src = """
System.Console.Write(local());

string local()
{
    return object.f;
}

implicit extension E for object
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.String E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void LambdaReturn()
    {
        var src = """
var l = () => object.f;
System.Console.Write(l());

implicit extension E for object
{
    public static string f = "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.String E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void IfStatement()
    {
        var src = """
if (object.f)
    System.Console.Write("hi");
else
    throw null;

implicit extension E for object
{
    public static bool f = true;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.Boolean E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ForeachStatement()
    {
        var src = """
foreach (var x in object.f)
{
    System.Console.Write(x);
}

implicit extension E for object
{
    public static string[] f = new[] { "hi" };
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.String[] E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void GotoStatement()
    {
        var src = """
goto object.f;

implicit extension E for object
{
    public static string[] f = new[] { "hi" };
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,6): error CS1001: Identifier expected
            // goto object.f;
            Diagnostic(ErrorCode.ERR_IdentifierExpected, "object").WithLocation(1, 6),
            // (1,6): error CS1002: ; expected
            // goto object.f;
            Diagnostic(ErrorCode.ERR_SemicolonExpected, "object").WithLocation(1, 6),
            // (1,6): error CS0159: No such label '' within the scope of the goto statement
            // goto object.f;
            Diagnostic(ErrorCode.ERR_LabelNotFound, "").WithArguments("").WithLocation(1, 6),
            // (1,6): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
            // goto object.f;
            Diagnostic(ErrorCode.ERR_IllegalStatement, "object.f").WithLocation(1, 6)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.String[] E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void SwitchExpression()
    {
        var src = """
var s = object.f switch { true => "ran", false => "" };
System.Console.Write(s);

implicit extension E for object
{
    public static bool f = true;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.f");
        Assert.Equal("System.Boolean E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void SwitchExpression_Arm()
    {
        var src = """
bool b = true;
var s = b switch { true => object.f, false => object.f2 };
System.Console.Write(s);

implicit extension E for object
{
    public static string f = "ran";
    public static string f2 = null;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.f");
        Assert.Equal("System.String E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void SwitchExpression_Arm_TwoExtensions()
    {
        var src = """
bool b = true;
System.Action a = b switch { true => D.f, false => throw null };

class D { }

implicit extension E1 for D
{
    public static string f = null;
}

implicit extension E2 for object
{
    public static void f() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,38): error CS0029: Cannot implicitly convert type 'string' to 'System.Action'
            // System.Action a = b switch { true => D.f, false => throw null };
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "D.f").WithArguments("string", "System.Action").WithLocation(2, 38));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "D.f");
        Assert.Equal("System.String E1.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void RefArgument()
    {
        var src = """
write(ref object.P);

void write(ref object o)
{
    System.Console.Write(o.ToString());
}

implicit extension E for object
{
    static object o = "hi";
    public static ref object P => ref o;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.P");
        Assert.Equal("ref System.Object E.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void GenericExtension_Simple()
    {
        var src = """
string s = C<int>.f;
System.Console.Write(s);

class C<T> { }

implicit extension E<T> for C<T>
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp, expectedOutput: "hi")
           .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.f");
        Assert.Equal("System.String E<System.Int32>.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void GenericExtension_NotUnique()
    {
        var src = """
string s1 = C<object, dynamic>.f;
string s2 = C<dynamic, object>.f;

class C<T ,U> { }

implicit extension E<T> for C<T ,T>
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<object, dynamic>.f");
        Assert.Equal("System.String E<System.Object>.f", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        // PROTOTYPE we could refine the algorithm to "merge" options
        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<dynamic, object>.f");
        Assert.Equal("System.String E<dynamic>.f", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void GenericExtension_GenericNestedType()
    {
        var src = """
string s = C<string>.Nested<int>.f;
System.Console.Write(s);

internal class C<T>
{
    internal class Nested<U> { }
}

implicit extension E<T1, T2> for C<T1>.Nested<T2>
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);
        var verifier = CompileAndVerify(comp, expectedOutput: "hi")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<string>.Nested<int>.f");
        Assert.Equal("System.String E<System.String, System.Int32>.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void GenericExtension_InGenericContainer()
    {
        var src = """
string s = C<string>.Nested1<bool>.Nested2<int>.f;
System.Console.Write(s);

internal class C<T>
{
    internal class Nested1<U>
    {
        internal class Nested2<V> { }
    }
}

implicit extension E<T1, T2, T3> for C<T1>.Nested1<T2>.Nested2<T3>
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi")
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<string>.Nested1<bool>.Nested2<int>.f");
        Assert.Equal("System.String E<System.String, System.Boolean, System.Int32>.f",
            model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void GenericExtension_InaccessibleNestedType()
    {
        var src = """
string s = C<string>.Nested<int>.f;
System.Console.Write(s);

class C<T>
{
    private class Nested<U> { }
}

implicit extension E<T1, T2> for C<T1>.Nested<T2>
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,22): error CS0122: 'C<string>.Nested<U>' is inaccessible due to its protection level
            // string s = C<string>.Nested<int>.f;
            Diagnostic(ErrorCode.ERR_BadAccess, "Nested<int>").WithArguments("C<string>.Nested<U>").WithLocation(1, 22),
            // (9,40): error CS0122: 'C<T1>.Nested<U>' is inaccessible due to its protection level
            // implicit extension E<T1, T2> for C<T1>.Nested<T2>
            Diagnostic(ErrorCode.ERR_BadAccess, "Nested<T2>").WithArguments("C<T1>.Nested<U>").WithLocation(9, 40)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<string>.Nested<int>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void GenericExtension_Tuples()
    {
        var src = """
string s = (string, string).Nested.f;
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,13): error CS1525: Invalid expression term 'string'
            // string s = (string, string).Nested.f;
            Diagnostic(ErrorCode.ERR_InvalidExprTerm, "string").WithArguments("string").WithLocation(1, 13),
            // (1,21): error CS1525: Invalid expression term 'string'
            // string s = (string, string).Nested.f;
            Diagnostic(ErrorCode.ERR_InvalidExprTerm, "string").WithArguments("string").WithLocation(1, 21)
            );
    }

    [Fact]
    public void GenericExtension_NestedTuples()
    {
        var src = """
string s = C<(string, string)>.Nested<(int, int)>.f;
System.Console.Write(s);

class C<T>
{
    internal class Nested<U> { }
}

implicit extension E<T1, T2> for C<(T1, T1)>.Nested<(T2, T2)>
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<(string, string)>.Nested<(int, int)>.f");
        Assert.Equal("System.String E<System.String, System.Int32>.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void GenericExtension_PointerArray()
    {
        var src = """
unsafe
{
    string s = C<long*[]>.Nested<int*[]>.f;
    System.Console.Write(s);
}

unsafe class C<T>
{
    internal class Nested<U> { }
}

unsafe implicit extension E<T1, T2> for C<T1*[]>.Nested<T2*[]>
    where T1 : unmanaged
    where T2 : unmanaged
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugExe);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<long*[]>.Nested<int*[]>.f");
        Assert.Equal("System.String E<System.Int64, System.Int32>.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void GenericExtension_Pointer()
    {
        // A type parameter cannot unify with a pointer type
        var src = """
unsafe
{
    string s = C<long*[]>.Nested<int*[]>.f;
    System.Console.Write(s);
}

unsafe class C<T>
{
    internal class Nested<U> { }
}

unsafe implicit extension E<T1, T2> for C<T1[]>.Nested<T2[]>
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugExe);
        comp.VerifyDiagnostics(
            // (3,42): error CS0117: 'C<long*[]>.Nested<int*[]>' does not contain a definition for 'f'
            //     string s = C<long*[]>.Nested<int*[]>.f;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "f").WithArguments("C<long*[]>.Nested<int*[]>", "f").WithLocation(3, 42)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<long*[]>.Nested<int*[]>.f");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void GenericExtension_FunctionPointer()
    {
        // PROTOTYPE type unification should handle function pointer types
        var src = """
unsafe
{
    string s = C<delegate*<int>[]>.Nested<delegate*<long>[]>.f;
    System.Console.Write(s);
}

unsafe class C<T>
{
    internal class Nested<U> { }
}

unsafe implicit extension E<T1, T2> for C<delegate*<T1>[]>.Nested<delegate*<T2>[]>
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugExe);
        comp.VerifyDiagnostics(
            // (3,62): error CS0117: 'C<delegate*<int>[]>.Nested<delegate*<long>[]>' does not contain a definition for 'f'
            //     string s = C<delegate*<int>[]>.Nested<delegate*<long>[]>.f;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "f").WithArguments("C<delegate*<int>[]>.Nested<delegate*<long>[]>", "f").WithLocation(3, 62)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<delegate*<int>[]>.Nested<delegate*<long>[]>.f");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void GenericExtension_OccursCheck()
    {
        var src = """
class C<T>
{
    internal class Nested<U> { }
}

implicit extension E<T1, T2> for C<T1>.Nested<T2>
{
    public static string f = "hi";

    public static void M()
    {
        string s = C<C<T1>>.Nested<int>.f;
        System.Console.Write(s);
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (12,41): error CS0117: 'C<C<T1>>.Nested<int>' does not contain a definition for 'f'
            //         string s = C<C<T1>>.Nested<int>.f;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "f").WithArguments("C<C<T1>>.Nested<int>", "f").WithLocation(12, 41)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<C<T1>>.Nested<int>.f");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void GenericExtension_ForInterface()
    {
        var src = """
string s = C<int>.f;
System.Console.Write(s);

class C<T> : I<T> { }
interface I<T> { }

implicit extension E<T> for I<T>
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp, expectedOutput: "hi")
           .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.f");
        Assert.Equal("System.String E<System.Int32>.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void GenericExtension_ForBaseInterface()
    {
        var src = """
string s = C<int>.f;
System.Console.Write(s);

class C<T> : I<T> { }
interface I<T> : I2<T> { }
interface I2<T> { }

implicit extension E<T> for I2<T>
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp, expectedOutput: "hi")
           .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.f");
        Assert.Equal("System.String E<System.Int32>.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Theory]
    [InlineData("in")]
    [InlineData("out")]
    public void GenericExtension_ForInterfaceWithVariance(string variance)
    {
        var src = $$"""
interface I<{{variance}} T> { }

implicit extension E<T> for I<T> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Theory, CombinatorialData]
    public void GenericExtension_Variance_In(bool isExplicit)
    {
        var src = $$"""
interface I<in T> { }

{{(isExplicit ? "explicit" : "implicit")}} extension E<in T> for I<T> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,22): error CS1960: Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.
            // implicit extension E<in T> for I<T> { }
            Diagnostic(ErrorCode.ERR_IllegalVarianceSyntax, "in").WithLocation(3, 22)
            );
    }

    [Theory, CombinatorialData]
    public void GenericExtension_Variance_Out(bool isExplicit)
    {
        var src = $$"""
interface I<out T> { }

{{(isExplicit ? "explicit" : "implicit")}} extension E<out T> for I<T> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,22): error CS1960: Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.
            // explicit extension E<out T> for I<T> { }
            Diagnostic(ErrorCode.ERR_IllegalVarianceSyntax, "out").WithLocation(3, 22)
            );
    }

    [Fact]
    public void GenericExtension_ForBase()
    {
        var src = """
string s = C<int, string>.f;
System.Console.Write(s);

class Base<T, U> { }
class C<T, U> : Base<U, T> { }

implicit extension E<T, U> for Base<T, U>
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp, expectedOutput: "hi")
           .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int, string>.f");
        Assert.Equal("System.String E<System.String, System.Int32>.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void UnderlyingType_SelfReference_Generic()
    {
        // While binding the underlying type of an extension type,
        // we cannot afford to involve the extension type (that would be a cycle)
        var src = """
string s = C<string>.Nested<int>.f;
System.Console.Write(s);

class C<T>
{
}

implicit extension E<T1, T2> for C<T1>.Nested<T2>
{
    public static string f = "hi";
    public class Nested<U> { }
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE could give a better diagnostic, such as the underlying type of an extension type may not rely on the extension declaration
        comp.VerifyDiagnostics(
            // (1,22): error CS0117: 'C<string>' does not contain a definition for 'Nested'
            // string s = C<string>.Nested<int>.f;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Nested<int>").WithArguments("C<string>", "Nested").WithLocation(1, 22),
            // (8,40): error CS0426: The type name 'Nested<>' does not exist in the type 'C<T1>'
            // implicit extension E<T1, T2> for C<T1>.Nested<T2>
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Nested<T2>").WithArguments("Nested<>", "C<T1>").WithLocation(8, 40)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<string>.Nested<int>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void UnderlyingType_SelfReference()
    {
        // While binding the underlying type of an extension type,
        // we cannot afford to involve the extension type (that would be a cycle)
        var src = """
string s = C.Nested.f;
System.Console.Write(s);

class C
{
}

implicit extension E for C.Nested
{
    public static string f = "hi";
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,14): error CS0117: 'C' does not contain a definition for 'Nested'
            // string s = C.Nested.f;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Nested").WithArguments("C", "Nested").WithLocation(1, 14),
            // (8,28): error CS0426: The type name 'Nested' does not exist in the type 'C'
            // implicit extension E for C.Nested
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Nested").WithArguments("Nested", "C").WithLocation(8, 28)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Nested");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void UnderlyingType_SelfReference_Unqualified()
    {
        var src = """
implicit extension E for Nested
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,26): error CS0246: The type or namespace name 'Nested' could not be found (are you missing a using directive or an assembly reference?)
            // implicit extension E for Nested
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Nested").WithArguments("Nested").WithLocation(1, 26)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var underlyingType = GetSyntax<ForTypeSyntax>(tree, "for Nested").UnderlyingType;
        Assert.Null(model.GetSymbolInfo(underlyingType).Symbol);
    }

    [Fact]
    public void Obsolete_TypeReceiver()
    {
        var src = """
int p = object.Property; // 1
object.Property = 42; // 2
System.Action p2 = object.Property2; // 3

int f = object.Field; // 4

System.Action m = object.Method; // 5

object.Method(); // 6

object.Event += null; // 7
object.Event -= null; // 8

implicit extension E for object
{
    [System.Obsolete("Property is obsolete", true)]
    public static int Property { get { throw null; } set { throw null; } }

    [System.Obsolete("Property2 is obsolete", true)]
    public static System.Action Property2 => throw null;

    [System.Obsolete("Field is obsolete", true)]
    public static int Field = 42;

    [System.Obsolete("Method is obsolete", true)]
    public static void Method() => throw null;

    [System.Obsolete("Event is obsolete", true)]
    public static event System.Action Event { add { throw null; } remove { throw null; } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,9): error CS0619: 'E.Property' is obsolete: 'Property is obsolete'
            // int p = object.Property; // 1
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Property").WithArguments("E.Property", "Property is obsolete").WithLocation(1, 9),
            // (2,1): error CS0619: 'E.Property' is obsolete: 'Property is obsolete'
            // object.Property = 42; // 2
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Property").WithArguments("E.Property", "Property is obsolete").WithLocation(2, 1),
            // (3,20): error CS0619: 'E.Property2' is obsolete: 'Property2 is obsolete'
            // System.Action p2 = object.Property2; // 3
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Property2").WithArguments("E.Property2", "Property2 is obsolete").WithLocation(3, 20),
            // (5,9): error CS0619: 'E.Field' is obsolete: 'Field is obsolete'
            // int f = object.Field; // 4
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Field").WithArguments("E.Field", "Field is obsolete").WithLocation(5, 9),
            // (7,19): error CS0619: 'E.Method()' is obsolete: 'Method is obsolete'
            // System.Action m = object.Method; // 5
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Method").WithArguments("E.Method()", "Method is obsolete").WithLocation(7, 19),
            // (9,1): error CS0619: 'E.Method()' is obsolete: 'Method is obsolete'
            // object.Method(); // 6
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Method()").WithArguments("E.Method()", "Method is obsolete").WithLocation(9, 1),
            // (11,1): error CS0619: 'E.Event' is obsolete: 'Event is obsolete'
            // object.Event += null; // 7
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Event").WithArguments("E.Event", "Event is obsolete").WithLocation(11, 1),
            // (12,1): error CS0619: 'E.Event' is obsolete: 'Event is obsolete'
            // object.Event -= null; // 8
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Event").WithArguments("E.Event", "Event is obsolete").WithLocation(12, 1)
            );
    }

    [Fact]
    public void Obsolete_InstanceReceiver()
    {
        var src = """
int p = new object().Property; // 1
new object().Property += 42; // 2

System.Action p2 = new object().Property2; // 3

System.Action m = new object().Method; // 4

new object().Method(); // 5

_ = (new object())[42]; // 6

implicit extension E for object
{
    [System.Obsolete("Property is obsolete", true)]
    public int Property { get { throw null; } set { throw null; } }

    [System.Obsolete("Property2 is obsolete", true)]
    public System.Action Property2 => throw null;

    [System.Obsolete("Method is obsolete", true)]
    public void Method() => throw null;

    [System.Obsolete("Indexer is obsolete", true)]
    public int this[int i] { get { throw null; } set { throw null; } }
}
""";
        // PROTOTYPE add event
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,9): error CS0619: 'E.Property' is obsolete: 'Property is obsolete'
            // int p = new object().Property; // 1
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Property").WithArguments("E.Property", "Property is obsolete").WithLocation(1, 9),
            // (2,1): error CS0619: 'E.Property' is obsolete: 'Property is obsolete'
            // new object().Property += 42; // 2
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Property").WithArguments("E.Property", "Property is obsolete").WithLocation(2, 1),
            // (4,20): error CS0619: 'E.Property2' is obsolete: 'Property2 is obsolete'
            // System.Action p2 = new object().Property2; // 3
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Property2").WithArguments("E.Property2", "Property2 is obsolete").WithLocation(4, 20),
            // (6,19): error CS0619: 'E.Method()' is obsolete: 'Method is obsolete'
            // System.Action m = new object().Method; // 4
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Method").WithArguments("E.Method()", "Method is obsolete").WithLocation(6, 19),
            // (8,1): error CS0619: 'E.Method()' is obsolete: 'Method is obsolete'
            // new object().Method(); // 5
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Method()").WithArguments("E.Method()", "Method is obsolete").WithLocation(8, 1),
            // (10,5): error CS0619: 'E.this[int]' is obsolete: 'Indexer is obsolete'
            // _ = (new object())[42]; // 6
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "(new object())[42]").WithArguments("E.this[int]", "Indexer is obsolete").WithLocation(10, 5)
            );
    }

    [Fact]
    public void ExtensionIndexerAccess_Simple_Getter()
    {
        var source = """
System.Console.Write(new C()[42]);

class C
{
}

implicit extension E for C
{
    public int this[int i] => i;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "42")
        //    .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[42]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_Simple_Setter()
    {
        var source = """
new C()[42] = 43;

class C { }

implicit extension E for C
{
    public int this[int i] { set { System.Console.Write($"[{i}] = {value}"); } }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "[42] = 43")
        //    .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[42]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { set; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_Simple_Getter_ExpressionTree()
    {
        // PROTOTYPE decide whether to allow expression tree scenarios. Verify shape of the tree if we decide to allow
        var source = """
using System.Linq.Expressions;
Expression<System.Action> x = () => new C()[42].ToString();

class C { }

implicit extension E for C
{
    public int this[int i] => i;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[42]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_Simple_Setter_ExpressionTree()
    {
        // PROTOTYPE decide whether to allow expression tree scenarios. Verify shape of the tree if we decide to allow
        var source = """
using System.Linq.Expressions;
Expression<System.Action> x = () => new C()[42] = 43;

class C { }

implicit extension E for C
{
    public int this[int i] { set { throw null; } }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (2,37): error CS0832: An expression tree may not contain an assignment operator
            // Expression<System.Action> x = () => new C()[42] = 43;
            Diagnostic(ErrorCode.ERR_ExpressionTreeContainsAssignment, "new C()[42] = 43").WithLocation(2, 37)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[42]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { set; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_InapplicableInstanceIndexer()
    {
        // We look at indexers in extension types if the property group on type has no applicable candidates
        var source = """
System.Console.Write(new C()[42]);

class C
{
    public int this[string s] => throw null;
}

implicit extension E for C
{
    public int this[int i] => i;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "42")
        //    .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[42]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_BaseReceiver()
    {
        var source = """
class Base { }

class C : Base
{
    public void M()
    {
        System.Console.Write(base[42]);
    }
}

implicit extension E for Base
{
    public int this[int i] => throw null;
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE confirm we don't want to add special rules for `base`
        comp.VerifyEmitDiagnostics(
            // (7,30): error CS0021: Cannot apply indexing with [] to an expression of type 'Base'
            //         System.Console.Write(base[42]);
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "base[42]").WithArguments("Base").WithLocation(7, 30)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "base[42]");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionIndexerAccess_AmbiguityWithExtensionOnBaseType_PreferMoreSpecific()
    {
        var source = """
System.Console.Write(new C()[42]);

class Base { }

class C : Base { }

implicit extension E1 for Base
{
    public int this[int i] => throw null;
}

implicit extension E2 for C
{
    public int this[int i] => i;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        //CompileAndVerify(comp, expectedOutput: "42", verify: Verification.Fails).VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[42]");
        Assert.Equal("System.Int32 E2.this[System.Int32 i] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_ExtensionOnBaseType()
    {
        var source = """
System.Console.Write(new C()[42]);

class Base { }

class C : Base { }

implicit extension E for Base
{
    public int this[int i] => 42;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "42")
        //    .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[42]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionIndexerAccess_ExtensionComesAfterImplicitIndexer()
    {
        var source = """
System.Console.Write(new C()[^1]);

class C
{
    public int Length => 42;
    public string this[int i]
    {
        get
        {
            return "ran";
        }
    }
}

implicit extension E for C
{
    public string this[int i] => throw null;
}
""";
        // PROTOTYPE confirm that we want extensions to come after implicit indexers
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);

        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("ran"), verify: Verification.FailsPEVerify)
            .VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[^1]");
        Assert.Equal("System.String C.this[System.Int32 i] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionIndexerAccess_InaccessibleIndexer()
    {
        var source = """
_ = new C()[1];
new C()[2] = 42;
new C()[3] += 42;

class C { }

implicit extension E for C
{
    protected int this[int i] { get { throw null; } set { throw null; } }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            // _ = new C()[1];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "new C()[1]").WithArguments("C").WithLocation(1, 5),
            // (2,1): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            // new C()[2] = 42;
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "new C()[2]").WithArguments("C").WithLocation(2, 1),
            // (3,1): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            // new C()[3] += 42;
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "new C()[3]").WithArguments("C").WithLocation(3, 1)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess0 = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[1]");
        Assert.Null(model.GetSymbolInfo(memberAccess0).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess0));

        var memberAccess1 = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[2]");
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess1));

        var memberAccess2 = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[3]");
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess2));
    }

    [Fact]
    public void ExtensionIndexerAccess_InaccessibleGetter()
    {
        var source = """
_ = new C()[1];
new C()[2] = 42;
new C()[3] += 42;

class C { }

implicit extension E for C
{
    public int this[int i] { protected get { throw null; } set { throw null; } }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0271: The property or indexer 'E.this[int]' cannot be used in this context because the get accessor is inaccessible
            // _ = new C()[1];
            Diagnostic(ErrorCode.ERR_InaccessibleGetter, "new C()[1]").WithArguments("E.this[int]").WithLocation(1, 5),
            // (3,1): error CS0271: The property or indexer 'E.this[int]' cannot be used in this context because the get accessor is inaccessible
            // new C()[3] += 42;
            Diagnostic(ErrorCode.ERR_InaccessibleGetter, "new C()[3]").WithArguments("E.this[int]").WithLocation(3, 1)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess0 = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[1]");
        Assert.Null(model.GetSymbolInfo(memberAccess0).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess0));

        var memberAccess1 = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[2]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { protected get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess1)); // PROTOTYPE need to fix the semantic model

        var memberAccess2 = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[3]");
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess2));
    }

    [Fact]
    public void ExtensionIndexerAccess_InaccessibleSetter()
    {
        var source = """
_ = new C()[1];
new C()[2] = 42;
new C()[3] += 42;

class C { }

implicit extension E for C
{
    public int this[int i] { get { throw null; } protected set { throw null; } }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,1): error CS0272: The property or indexer 'E.this[int]' cannot be used in this context because the set accessor is inaccessible
            // new C()[2] = 42;
            Diagnostic(ErrorCode.ERR_InaccessibleSetter, "new C()[2]").WithArguments("E.this[int]").WithLocation(2, 1),
            // (3,1): error CS0272: The property or indexer 'E.this[int]' cannot be used in this context because the set accessor is inaccessible
            // new C()[3] += 42;
            Diagnostic(ErrorCode.ERR_InaccessibleSetter, "new C()[3]").WithArguments("E.this[int]").WithLocation(3, 1)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess0 = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[1]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { get; protected set; }", model.GetSymbolInfo(memberAccess0).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess0)); // PROTOTYPE need to fix the semantic model

        var memberAccess1 = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[2]");
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess1));

        var memberAccess2 = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[3]");
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess2));
    }

    [Fact]
    public void ExtensionIndexerAccess_TypeReceiver()
    {
        var source = """
_ = C[1];

class C { }

implicit extension E for C
{
    public string this[int i] => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0119: 'C' is a type, which is not valid in the given context
            // _ = C[1];
            Diagnostic(ErrorCode.ERR_BadSKunknown, "C").WithArguments("C", "type").WithLocation(1, 5)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "C[1]");
        Assert.Equal("System.String E.this[System.Int32 i] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_ColorColorReceiver()
    {
        var source = """
class C
{
    void M(C C)
    {
        _ = C[1];
    }
}

implicit extension E for C
{
    public string this[int i] => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "C[1]");
        Assert.Equal("System.String E.this[System.Int32 i] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_ParameterNames()
    {
        var source = """
_ = new C()[i: 1, 2];

class C { }

implicit extension E for C
{
    public string this[int i, int j] => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[i: 1, 2]");
        Assert.Equal("System.String E.this[System.Int32 i, System.Int32 j] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_ParameterNames_OutOfOrder()
    {
        var source = """
_ = new C()[j: 2, i: 1];

class C { }

implicit extension E for C
{
    public string this[int i, int j] => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[j: 2, i: 1]");
        Assert.Equal("System.String E.this[System.Int32 i, System.Int32 j] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_OnTypeParameter()
    {
        var source = """
class C
{
    void M<T>(T t) where T : C
    {
        _ = t[0];
    }
}

implicit extension E for C
{
    public string this[int i, int j] => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (5,13): error CS0021: Cannot apply indexing with [] to an expression of type 'T'
            //         _ = t[0];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "t[0]").WithArguments("T").WithLocation(5, 13)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "t[0]");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_OnArrayType()
    {
        var source = """
int[] o = new[] { 42 };
C.M(o);

class C
{
    public static void M(int[] o)
    {
        System.Console.Write(o[0]);
    }
}

implicit extension E for object[]
{
    public string this[int i] => throw null;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "o[0]");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionIndexerAccess_OnDynamicReceiver()
    {
        var source = """
C.M(new C());

class C
{
    public static void M(dynamic d)
    {
        System.Console.Write(d[0]);
    }

    public int this[int i] => 42;
}

implicit extension E for C
{
    public int this[int i] => throw null;
}
""";
        var comp = CreateCompilationWithCSharp(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "d[0]");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionIndexerAccess_OnDynamicReceiver_NoInstanceIndexer()
    {
        var source = """
try
{
    C.M(new C());
}
catch (Microsoft.CSharp.RuntimeBinder.RuntimeBinderException)
{
    System.Console.Write("caught");
}

class C
{
    public static void M(dynamic d)
    {
        _ = d[0];
    }
}

implicit extension E for C
{
    public int this[int i] => throw null;
}
""";
        var comp = CreateCompilationWithCSharp(source);
        CompileAndVerify(comp, expectedOutput: "caught").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "d[0]");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionIndexerAccess_WithDynamicArgument()
    {
        var source = """
C.M(1);

class C
{
    public static void M(dynamic d)
    {
        System.Console.Write((new C())[d]);
    }

    public int this[int i] => 42;
}

implicit extension E for C
{
    public int this[int i] => throw null;
}
""";
        var comp = CreateCompilationWithCSharp(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "(new C())[d]");
        Assert.Equal("System.Int32 C.this[System.Int32 i] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["System.Int32 C.this[System.Int32 i] { get; }"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionIndexerAccess_WithDynamicArgument_NoInstanceIndexer()
    {
        var source = """
C.M(1);

class C
{
    public static void M(dynamic d)
    {
        System.Console.Write((new C())[d]);
    }
}

implicit extension E for C
{
    public int this[int i] => 42;
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE need to confirm what we want for element access with dynamic arguments (should likely be disallowed)
        comp.VerifyEmitDiagnostics(
            // (7,30): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            //         System.Console.Write((new C())[d]);
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "(new C())[d]").WithArguments("C").WithLocation(7, 30)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "(new C())[d]");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ExtensionIndexerAccess_GetVsSet()
    {
        var source = """
_ = new C()[1];
new C()[2] = 2;
new C()[3] += 3;

class C { }

implicit extension E for C
{
    public int this[int i]
    {
        get { System.Console.Write($"get({i}) "); return 42; }
        set { System.Console.Write($"set({i}) "); }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[1]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess1)); // PROTOTYPE need to fix the semantic model

        var memberAccess2 = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[2]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess2)); // PROTOTYPE need to fix the semantic model

        var memberAccess3 = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[3]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { get; set; }", model.GetSymbolInfo(memberAccess3).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess3)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_GetVsSet_InstanceGetterExists()
    {
        var source = """
_ = new C()[1];
new C()[2] = 2;
new C()[3] += 3;

class C
{
    public int this[int i]
    {
        get { throw null; }
    }
}

implicit extension E for C
{
    public int this[int i]
    {
        get { throw null; }
        set { throw null; }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,1): error CS0200: Property or indexer 'C.this[int]' cannot be assigned to -- it is read only
            // new C()[2] = 2;
            Diagnostic(ErrorCode.ERR_AssgReadonlyProp, "new C()[2]").WithArguments("C.this[int]").WithLocation(2, 1),
            // (3,1): error CS0200: Property or indexer 'C.this[int]' cannot be assigned to -- it is read only
            // new C()[3] += 3;
            Diagnostic(ErrorCode.ERR_AssgReadonlyProp, "new C()[3]").WithArguments("C.this[int]").WithLocation(3, 1)
            );
    }

    [Fact]
    public void ExtensionIndexerAccess_GetVsSet_InstanceSetterExists()
    {
        var source = """
_ = new C()[1];
new C()[2] = 2;
new C()[3] += 3;

class C
{
    public int this[int i]
    {
        set { throw null; }
    }
}

implicit extension E for C
{
    public int this[int i]
    {
        get { throw null; }
        set { throw null; }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0154: The property or indexer 'C.this[int]' cannot be used in this context because it lacks the get accessor
            // _ = new C()[1];
            Diagnostic(ErrorCode.ERR_PropertyLacksGet, "new C()[1]").WithArguments("C.this[int]").WithLocation(1, 5),
            // (3,1): error CS0154: The property or indexer 'C.this[int]' cannot be used in this context because it lacks the get accessor
            // new C()[3] += 3;
            Diagnostic(ErrorCode.ERR_PropertyLacksGet, "new C()[3]").WithArguments("C.this[int]").WithLocation(3, 1)
            );
    }

    [Fact]
    public void ExtensionIndexerAccess_Params()
    {
        var source = """
System.Console.Write(new C()[1, 2]);

class C { }

implicit extension E for C
{
    public int this[params int[] i] { get { System.Console.Write($"{i[0]} {i[1]} "); return 42; } }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[1, 2]");
        Assert.Equal("System.Int32 E.this[params System.Int32[] i] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionIndexerAccess_OptionalParameter()
    {
        var source = """
System.Console.Write(new C()[1]);

class C { }

implicit extension E for C
{
    public int this[int i, int j = 2] { get { System.Console.Write($"{i} {j} "); return 42; } }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[1]");
        Assert.Equal("System.Int32 E.this[System.Int32 i, [System.Int32 j = 2]] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ExtensionIndexerAccess_DictionaryInitializer()
    {
        var source = """
System.Console.Write(new C() { [1] = 42, [2] = 43 });

class C { }

implicit extension E for C
{
    public int this[int i] { set { System.Console.Write($"{i}={value} "); } }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
    }

    [Fact]
    public void ExtensionIndexerAccess_ComImportReceiver()
    {
        string source = """
using System;
using System.Runtime.InteropServices;

I i = new C();
System.Console.Write(i[1]);

[ComImport]
[Guid("1FC6664D-C61E-4131-81CD-A3EE0DD6098F")]
[CoClass(typeof(C))]
interface I { }

class C : I { }

implicit extension E for I
{
    public int this[ref int i] => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (16,21): error CS0631: ref and out are not valid in this context
            //     public int this[ref int i] => throw null;
            Diagnostic(ErrorCode.ERR_IllegalRefParam, "ref").WithLocation(16, 21)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "i[1]");
        Assert.Equal("System.Int32 E.this[ref System.Int32 i] { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ExtensionIndexerAccess_Instance_ExtensionOnUnderlying()
    {
        var src = """
class C
{
    public void M(E1 e)
    {
        System.Console.Write(e[42]);
    }
}

implicit extension E1 for C { }

implicit extension E2 for C
{
    public string this[int i] { get { return "ran"; } }
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        comp.VerifyDiagnostics(
            // (5,30): error CS0021: Cannot apply indexing with [] to an expression of type 'E1'
            //         System.Console.Write(e[42]);
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "e[42]").WithArguments("E1").WithLocation(5, 30));
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var elementAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "e[42]");
        Assert.Null(model.GetSymbolInfo(elementAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(elementAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ExtensionIndexerAccess_Instance_ExtensionOnUnderlying_WithApplicableInstanceIndexer()
    {
        var src = """
class C
{
    public void M(E1 e)
    {
        System.Console.Write(e[42]);
    }

    public string this[string s] { get { throw null; } }
}

implicit extension E1 for C { }

implicit extension E2 for C
{
    public string this[int i] { get { return "ran"; } }
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        comp.VerifyDiagnostics(
            // (5,30): error CS0021: Cannot apply indexing with [] to an expression of type 'E1'
            //         System.Console.Write(e[42]);
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "e[42]").WithArguments("E1").WithLocation(5, 30));
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var elementAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "e[42]");
        Assert.Null(model.GetSymbolInfo(elementAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(elementAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ExtensionMemberLookup_MissingNestedType()
    {
        var source = """
E.Missing.M();

public class C { }

static implicit extension E for C { }
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,3): error CS0117: 'E' does not contain a definition for 'Missing'
            // E.Missing.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Missing").WithArguments("E", "Missing").WithLocation(1, 3)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Missing");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);

        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.Missing.M()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
    }

    [Fact]
    public void ExtensionMemberLookup_InaccessibleNestedType()
    {
        var source = """
E.Inaccessible.M();

public class C { }

static implicit extension E for C
{
    static class Inaccessible
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,3): error CS0122: 'E.Inaccessible' is inaccessible due to its protection level
            // E.Inaccessible.M();
            Diagnostic(ErrorCode.ERR_BadAccess, "Inaccessible").WithArguments("E.Inaccessible").WithLocation(1, 3)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Inaccessible");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);

        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.Inaccessible.M()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Empty(model.GetMemberGroup(invocation));
    }

    [Fact]
    public void ExtensionMemberLookup_InaccessibleNestedMember()
    {
        var source = """
E.D.Inaccessible();

public class C { }

static implicit extension E for C
{
    public static class D
    {
        static void Inaccessible() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,5): error CS0122: 'E.D.Inaccessible()' is inaccessible due to its protection level
            // E.D.Inaccessible();
            Diagnostic(ErrorCode.ERR_BadAccess, "Inaccessible").WithArguments("E.D.Inaccessible()").WithLocation(1, 5)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.D");
        Assert.Equal("E.D", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.D.Inaccessible()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Empty(model.GetMemberGroup(invocation));
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation(bool isExplicit)
    {
        var source = $$"""
E.M();
E.M2();
E.M4();

static class C
{
    public static void M4() { System.Console.Write("M4 "); }
}

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static void M() { M2(); M4(); }
    public static void M2() { System.Console.Write("M2 "); }
}
""";
        var comp = CreateCompilation(source);
        var verifier = CompileAndVerify(comp, expectedOutput: "M2 M4 M2 M4").VerifyDiagnostics();
        verifier.VerifyIL("E.M", """
{
  // Code size       11 (0xb)
  .maxstack  0
  IL_0000:  call       "void E.M2()"
  IL_0005:  call       "void C.M4()"
  IL_000a:  ret
}
""");
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size       16 (0x10)
  .maxstack  0
  IL_0000:  call       "void E.M()"
  IL_0005:  call       "void E.M2()"
  IL_000a:  call       "void C.M4()"
  IL_000f:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var simpleM2Invocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(simpleM2Invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleM2Invocation)); // PROTOTYPE need to fix the semantic model

        var qualifiedM2Invocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(qualifiedM2Invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(qualifiedM2Invocation)); // PROTOTYPE need to fix the semantic model

        var simpleM4Invocation = GetSyntax<InvocationExpressionSyntax>(tree, "M4()");
        Assert.Equal("void C.M4()", model.GetSymbolInfo(simpleM4Invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleM4Invocation)); // PROTOTYPE need to fix the semantic model

        var qualifiedM4Invocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.M4()");
        Assert.Equal("void C.M4()", model.GetSymbolInfo(qualifiedM4Invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(qualifiedM4Invocation)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_FromUnderlyingTypeBase(bool isExplicit)
    {
        var source = $$"""
E.M();
E.M4();

class Base
{
    public static void M4() { System.Console.Write("M4 "); }
}

class C : Base { }

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static void M() { M4(); }
}
""";
        var comp = CreateCompilation(source);
        var verifier = CompileAndVerify(comp, expectedOutput: "M4 M4").VerifyDiagnostics();
        verifier.VerifyIL("E.M", """
{
  // Code size        6 (0x6)
  .maxstack  0
  IL_0000:  call       "void Base.M4()"
  IL_0005:  ret
}
""");
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size       11 (0xb)
  .maxstack  0
  IL_0000:  call       "void E.M()"
  IL_0005:  call       "void Base.M4()"
  IL_000a:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var simpleM4Invocation = GetSyntax<InvocationExpressionSyntax>(tree, "M4()");
        Assert.Equal("void Base.M4()", model.GetSymbolInfo(simpleM4Invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleM4Invocation)); // PROTOTYPE need to fix the semantic model

        var qualifiedM4Invocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.M4()");
        Assert.Equal("void Base.M4()", model.GetSymbolInfo(qualifiedM4Invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(qualifiedM4Invocation)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_WithTypeArguments(bool isExplicit)
    {
        var source = $$"""
E.M<int>();
E.M2<int>();
E.M4<int>();

static class C
{
    public static void M4<T>() { System.Console.Write("M4 "); }
}

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static void M<T>() { M2<T>(); M4<T>(); }
    public static void M2<T>() { System.Console.Write("M2 "); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "M2 M4 M2 M4").VerifyDiagnostics();
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_ZeroArityMatchesAny(bool isExplicit)
    {
        var source = $$"""
E.M();
E.Method("");
E.Method<string>("");

static class C
{
    public static void Method(int i) => throw null;
    public static void Method<T>(T t) { System.Console.Write("Method "); }
}

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static void M() { Method(""); Method<string>(""); }
}
""";
        var comp = CreateCompilation(source);
        var verifier = CompileAndVerify(comp, expectedOutput: "Method Method Method Method").VerifyDiagnostics();
        verifier.VerifyIL("E.M", """
{
  // Code size       21 (0x15)
  .maxstack  1
  IL_0000:  ldstr      ""
  IL_0005:  call       "void C.Method<string>(string)"
  IL_000a:  ldstr      ""
  IL_000f:  call       "void C.Method<string>(string)"
  IL_0014:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, """Method("")""");
        Assert.Equal("void C.Method<System.String>(System.String t)", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
E.M();
E.Method();

static class C
{
    public static void Method() => throw null;
}

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static void Method() { System.Console.Write("ran "); }
    public static void M() { Method(); }
}
""";
        // PROTOTYPE should warn about hiding
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "Method()");
        Assert.Equal("void E.Method()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(invocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(invocation)); // PROTOTYPE need to fix the semantic model

        var typeInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.Method()");
        Assert.Equal("void E.Method()", model.GetSymbolInfo(typeInvocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(typeInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(typeInvocation)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_Overloads(bool isExplicit)
    {
        var source = $$"""
E.M();
E.M2(42);
E.M2("");

static class C
{
    public static void M2(int i) { System.Console.Write("M2Int "); }
}

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static void M2(string s) { System.Console.Write("M2String "); }
    public static void M() { M2(42); M2(""); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "M2Int M2String M2Int M2String").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var simpleIntInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2(42)");
        Assert.Equal("void C.M2(System.Int32 i)", model.GetSymbolInfo(simpleIntInvocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(simpleIntInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(simpleIntInvocation)); // PROTOTYPE need to fix the semantic model

        var qualifiedIntInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.M2(42)");
        Assert.Equal("void C.M2(System.Int32 i)", model.GetSymbolInfo(qualifiedIntInvocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(qualifiedIntInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(qualifiedIntInvocation)); // PROTOTYPE need to fix the semantic model

        var simpleStringInvocation = GetSyntax<InvocationExpressionSyntax>(tree, """M2("")""");
        Assert.Equal("void E.M2(System.String s)", model.GetSymbolInfo(simpleStringInvocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(simpleStringInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(simpleStringInvocation)); // PROTOTYPE need to fix the semantic model

        var qualifiedStringInvocation = GetSyntax<InvocationExpressionSyntax>(tree, """E.M2("")""");
        Assert.Equal("void E.M2(System.String s)", model.GetSymbolInfo(qualifiedStringInvocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(qualifiedStringInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(qualifiedStringInvocation)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_MethodGroup(bool isExplicit)
    {
        var source = $$"""
System.Action<int> a1 = E.M2;
a1(42);

System.Action<string> a2 = E.M2;
a2("");

static class C
{
    public static void M2(int i) { System.Console.Write("C.M2 "); }
}

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{ 
    public static void M2(string s) { System.Console.Write("E.M2 "); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "C.M2 E.M2").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var intMethodGroup = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "E.M2").First();
        Assert.Equal("void C.M2(System.Int32 i)", model.GetSymbolInfo(intMethodGroup).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.M2(System.String s)", "void C.M2(System.Int32 i)"], model.GetMemberGroup(intMethodGroup).ToTestDisplayStrings());

        var stringMethodGroup = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "E.M2").Last();
        Assert.Equal("void E.M2(System.String s)", model.GetSymbolInfo(stringMethodGroup).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.M2(System.String s)", "void C.M2(System.Int32 i)"], model.GetMemberGroup(stringMethodGroup).ToTestDisplayStrings());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_MethodGroup_FromUnderlyingTypeBase(bool isExplicit)
    {
        var source = $$"""
System.Action<int> a1 = E.M2;
a1(42);

System.Action<string> a2 = E.M2;
a2("");

class Base
{
    public static void M2(int i) { System.Console.Write("Base.M2 "); }
}

class C : Base 
{ 
    public static void M2(string s) { System.Console.Write("C.M2 "); }
}

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C { }
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "Base.M2 C.M2").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var intMethodGroup = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "E.M2").First();
        Assert.Equal("void Base.M2(System.Int32 i)", model.GetSymbolInfo(intMethodGroup).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M2(System.String s)", "void Base.M2(System.Int32 i)"], model.GetMemberGroup(intMethodGroup).ToTestDisplayStrings());

        var stringMethodGroup = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "E.M2").Last();
        Assert.Equal("void C.M2(System.String s)", model.GetSymbolInfo(stringMethodGroup).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M2(System.String s)", "void Base.M2(System.Int32 i)"], model.GetMemberGroup(stringMethodGroup).ToTestDisplayStrings());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_MethodGroup_Var_FromUnderlyingType(bool isExplicit)
    {
        var source = $$"""
var a1 = E.M2;
a1(42);

static class C
{
    public static void M2(int i) { System.Console.Write("C.M2 "); }
}

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C { }
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "C.M2").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var intMethodGroup = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.M2");
        Assert.Equal("void C.M2(System.Int32 i)", model.GetSymbolInfo(intMethodGroup).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M2(System.Int32 i)"], model.GetMemberGroup(intMethodGroup).ToTestDisplayStrings());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_MethodGroup_Var_FromExtension(bool isExplicit)
    {
        var source = $$"""
var a1 = E.M2;
a1(42);

static class C { }

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{ 
    public static void M2(int i) { System.Console.Write("E.M2 "); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "E.M2").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var intMethodGroup = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.M2");
        Assert.Equal("void E.M2(System.Int32 i)", model.GetSymbolInfo(intMethodGroup).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.M2(System.Int32 i)"], model.GetMemberGroup(intMethodGroup).ToTestDisplayStrings());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_MethodGroup_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
E.M();

System.Action a = E.Method;
a();

static class C
{
    public static void Method() => throw null;
}

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static void Method() { System.Console.Write("ran "); }

    public static void M()
    {
        System.Action a = Method;
        a();
    }
}
""";
        // PROTOTYPE should warn about hiding
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var eAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Method");
        Assert.Equal("void E.Method()", model.GetSymbolInfo(eAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(eAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void E.Method()", "void C.Method()"], model.GetMemberGroup(eAccess).ToTestDisplayStrings());

        var identifier = GetSyntaxes<IdentifierNameSyntax>(tree, "Method").Last();
        Assert.Equal("void E.Method()", model.GetSymbolInfo(identifier).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(identifier).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void E.Method()", "void C.Method()"], model.GetMemberGroup(identifier).ToTestDisplayStrings());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_MethodGroup_PickOverloadFromUnderlyingType(bool isExplicit)
    {
        var source = $$"""
E.M();

System.Action a = E.Method;
a();

static class C
{
    public static void Method() { System.Console.Write("ran "); }
}

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static void Method(int i) => throw null;

    public static void M()
    {
        System.Action a = Method;
        a();
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var eAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Method");
        Assert.Equal("void C.Method()", model.GetSymbolInfo(eAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(eAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void E.Method(System.Int32 i)", "void C.Method()"], model.GetMemberGroup(eAccess).ToTestDisplayStrings());

        var identifier = GetSyntaxes<IdentifierNameSyntax>(tree, "Method").Last();
        Assert.Equal("void C.Method()", model.GetSymbolInfo(identifier).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(identifier).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void E.Method(System.Int32 i)", "void C.Method()"], model.GetMemberGroup(identifier).ToTestDisplayStrings());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_InaccessibleMember(bool isExplicit)
    {
        var source = $$"""
static class C
{
    protected static void MProtected() { } // 1
    private static void MPrivate() { }
}

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static void M()
    {
        MProtected(); // 2
        C.MProtected(); // 3
        MPrivate(); // 4
        C.MPrivate(); // 5
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (3,27): error CS1057: 'C.MProtected()': static classes cannot contain protected members
            //     protected static void MProtected() { } // 1
            Diagnostic(ErrorCode.ERR_ProtectedInStatic, "MProtected").WithArguments("C.MProtected()").WithLocation(3, 27),
            // (11,9): error CS0122: 'C.MProtected()' is inaccessible due to its protection level
            //         MProtected(); // 2
            Diagnostic(ErrorCode.ERR_BadAccess, "MProtected").WithArguments("C.MProtected()").WithLocation(11, 9),
            // (12,11): error CS0122: 'C.MProtected()' is inaccessible due to its protection level
            //         C.MProtected(); // 3
            Diagnostic(ErrorCode.ERR_BadAccess, "MProtected").WithArguments("C.MProtected()").WithLocation(12, 11),
            // (13,9): error CS0122: 'C.MPrivate()' is inaccessible due to its protection level
            //         MPrivate(); // 4
            Diagnostic(ErrorCode.ERR_BadAccess, "MPrivate").WithArguments("C.MPrivate()").WithLocation(13, 9),
            // (14,11): error CS0122: 'C.MPrivate()' is inaccessible due to its protection level
            //         C.MPrivate(); // 5
            Diagnostic(ErrorCode.ERR_BadAccess, "MPrivate").WithArguments("C.MPrivate()").WithLocation(14, 11)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        foreach (var invocationString in new[] { "MProtected()", "C.MProtected()", "MPrivate()", "C.MPrivate()" })
        {
            var invocation = GetSyntax<InvocationExpressionSyntax>(tree, invocationString);
            Assert.Null(model.GetSymbolInfo(invocation).Symbol);
            Assert.Equal(CandidateReason.Inaccessible, model.GetSymbolInfo(invocation).CandidateReason);
            Assert.Empty(model.GetMemberGroup(invocation));
        }
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_MissingMember(bool isExplicit)
    {
        var source = $$"""
static class C { }

static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static void M()
    {
        Missing(); // 1
        C.Missing(); // 2
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (7,9): error CS0103: The name 'Missing' does not exist in the current context
            //         Missing(); // 1
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Missing").WithArguments("Missing").WithLocation(7, 9),
            // (8,11): error CS0117: 'C' does not contain a definition for 'Missing'
            //         C.Missing(); // 2
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Missing").WithArguments("C", "Missing").WithLocation(8, 11)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        foreach (var invocationString in new[] { "Missing()", "C.Missing()" })
        {
            var invocation = GetSyntax<InvocationExpressionSyntax>(tree, invocationString);
            Assert.Null(model.GetSymbolInfo(invocation).Symbol);
            Assert.Empty(model.GetMemberGroup(invocation));
        }
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_FromOuterExtension_SimpleName(bool isExplicit)
    {
        var source = $$"""
EOuter.EInner.M();

static class C
{
    public static void M3() { System.Console.Write("M3 "); }
}

static {{(isExplicit ? "explicit" : "implicit")}} extension EOuter for C
{
    public static class D { }

    public static {{(isExplicit ? "explicit" : "implicit")}} extension EInner for D
    {
        public static void M() { M2(); M3(); }
    }

    public static void M2() { System.Console.Write("M2 "); }
}
""";
        var comp = CreateCompilation(source);
        var verifier = CompileAndVerify(comp, expectedOutput: "M2 M3").VerifyDiagnostics();
        verifier.VerifyIL("EOuter.EInner.M", """
{
  // Code size       11 (0xb)
  .maxstack  0
  IL_0000:  call       "void EOuter.M2()"
  IL_0005:  call       "void C.M3()"
  IL_000a:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var m2Invocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void EOuter.M2()", model.GetSymbolInfo(m2Invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(m2Invocation)); // PROTOTYPE need to fix the semantic model

        var m3Invocation = GetSyntax<InvocationExpressionSyntax>(tree, "M3()");
        Assert.Equal("void C.M3()", model.GetSymbolInfo(m3Invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(m3Invocation)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_FromOuterExtension_Qualified(bool isExplicit)
    {
        var source = $$"""
static class C
{
    public static void M3() => throw null;
}

static {{(isExplicit ? "explicit" : "implicit")}} extension EOuter for C
{
    public static class D { }

    public static {{(isExplicit ? "explicit" : "implicit")}} extension EInner for D
    {
        public static void M()
        {
            EInner.M2();
            EInner.M3();
        }
    }

    public static void M2() => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (14,20): error CS0117: 'EOuter.EInner' does not contain a definition for 'M2'
            //             EInner.M2();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M2").WithArguments("EOuter.EInner", "M2").WithLocation(14, 20),
            // (15,20): error CS0117: 'EOuter.EInner' does not contain a definition for 'M3'
            //             EInner.M3();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M3").WithArguments("EOuter.EInner", "M3").WithLocation(15, 20)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var m2Invocation = GetSyntax<InvocationExpressionSyntax>(tree, "EInner.M2()");
        Assert.Null(model.GetSymbolInfo(m2Invocation).Symbol);
        Assert.Empty(model.GetMemberGroup(m2Invocation));

        var m3Invocation = GetSyntax<InvocationExpressionSyntax>(tree, "EInner.M3()");
        Assert.Null(model.GetSymbolInfo(m3Invocation).Symbol);
        Assert.Empty(model.GetMemberGroup(m3Invocation));
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_InnerExtensionWins(bool isExplicit)
    {
        var source = $$"""
EOuter.EInner.M();

static class C
{
    public static void Method() => throw null;
}

static {{(isExplicit ? "explicit" : "implicit")}} extension EOuter for C
{
    public static class D
    {
        public static void Method() { System.Console.Write("Method "); }
    }

    public static {{(isExplicit ? "explicit" : "implicit")}} extension EInner for D
    {
        public static void M() { Method(); EInner.Method(); }
    }

    public static void Method() => throw null;
}
""";
        // PROTOTYPE should warn about hiding on EOuter.Method
        var comp = CreateCompilation(source);
        var verifier = CompileAndVerify(comp, expectedOutput: "Method Method").VerifyDiagnostics();
        verifier.VerifyIL("EOuter.EInner.M", """
{
  // Code size       11 (0xb)
  .maxstack  0
  IL_0000:  call       "void EOuter.D.Method()"
  IL_0005:  call       "void EOuter.D.Method()"
  IL_000a:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "Method()");
        Assert.Equal("void EOuter.D.Method()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation)); // PROTOTYPE need to fix the semantic model

        var typeReceiverInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "EInner.Method()");
        Assert.Equal("void EOuter.D.Method()", model.GetSymbolInfo(typeReceiverInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(typeReceiverInvocation)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_FromOuterExtension_InaccessibleMember(bool isExplicit)
    {
        var source = $$"""
static class C
{
    protected static void MProtected() { } // 1
    private static void MPrivate() { }
}

static {{(isExplicit ? "explicit" : "implicit")}} extension EOuter for C
{
    public static class D { }

    public static {{(isExplicit ? "explicit" : "implicit")}} extension EInner for D
    {
        public static void M()
        {
            MProtected(); // 2
            C.MProtected(); // 3
            MPrivate(); // 4
            C.MPrivate(); // 5
        }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (3,27): error CS1057: 'C.MProtected()': static classes cannot contain protected members
            //     protected static void MProtected() { } // 1
            Diagnostic(ErrorCode.ERR_ProtectedInStatic, "MProtected").WithArguments("C.MProtected()").WithLocation(3, 27),
            // (15,13): error CS0122: 'C.MProtected()' is inaccessible due to its protection level
            //             MProtected(); // 2
            Diagnostic(ErrorCode.ERR_BadAccess, "MProtected").WithArguments("C.MProtected()").WithLocation(15, 13),
            // (16,15): error CS0122: 'C.MProtected()' is inaccessible due to its protection level
            //             C.MProtected(); // 3
            Diagnostic(ErrorCode.ERR_BadAccess, "MProtected").WithArguments("C.MProtected()").WithLocation(16, 15),
            // (17,13): error CS0122: 'C.MPrivate()' is inaccessible due to its protection level
            //             MPrivate(); // 4
            Diagnostic(ErrorCode.ERR_BadAccess, "MPrivate").WithArguments("C.MPrivate()").WithLocation(17, 13),
            // (18,15): error CS0122: 'C.MPrivate()' is inaccessible due to its protection level
            //             C.MPrivate(); // 5
            Diagnostic(ErrorCode.ERR_BadAccess, "MPrivate").WithArguments("C.MPrivate()").WithLocation(18, 15)
            );
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_Interface_Nested(bool isExplicit)
    {
        var source = $$"""
EOuter.EInner.M();

interface I
{
    public static void Method() => throw null;
}

static {{(isExplicit ? "explicit" : "implicit")}} extension EOuter for I
{
    public interface I2
    {
        public static void Method() { System.Console.Write("Method "); }
    }

    public static {{(isExplicit ? "explicit" : "implicit")}} extension EInner for I2
    {
        public static void M() { Method(); EInner.Method(); }
    }

    public static void Method() => throw null;
}
""";
        // PROTOTYPE should warn about hiding on EOuter.Method
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("Method Method"), verify: Verification.FailsPEVerify).VerifyDiagnostics();
        verifier.VerifyIL("EOuter.EInner.M", """
{
  // Code size       11 (0xb)
  .maxstack  0
  IL_0000:  call       "void EOuter.I2.Method()"
  IL_0005:  call       "void EOuter.I2.Method()"
  IL_000a:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "Method()");
        Assert.Equal("void EOuter.I2.Method()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation)); // PROTOTYPE need to fix the semantic model

        var typeReceiverInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "EInner.Method()");
        Assert.Equal("void EOuter.I2.Method()", model.GetSymbolInfo(typeReceiverInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(typeReceiverInvocation)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_Interface_FromUnderlyingTypeBase(bool isExplicit)
    {
        var source = $$"""
E.M();
E.Method();

public interface IBase
{
    public static void Method() { System.Console.Write("Method "); }
}

public interface I : IBase { }

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for I
{
    public static void M() { Method(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("Method Method"), verify: Verification.FailsPEVerify).VerifyDiagnostics();
        verifier.VerifyIL("E.M", """
{
  // Code size        6 (0x6)
  .maxstack  0
  IL_0000:  call       "void IBase.Method()"
  IL_0005:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "Method()");
        Assert.Equal("void IBase.Method()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation)); // PROTOTYPE need to fix the semantic model

        var typeReceiverInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.Method()");
        Assert.Equal("void IBase.Method()", model.GetSymbolInfo(typeReceiverInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(typeReceiverInvocation)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Field_Interface(bool isExplicit)
    {
        var source = $$"""
System.Console.Write(E.Field);

public interface I
{
    public static int Field = 1;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for I { }
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("1"), verify: Verification.FailsPEVerify).VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var simpleInvocation = GetSyntax<IdentifierNameSyntax>(tree, "Field");
        Assert.Equal("System.Int32 I.Field", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Field_Interface_FromUnderlyingTypeBase(bool isExplicit)
    {
        var source = $$"""
System.Console.Write(E.Field);

public interface IBase
{
    public static int Field = 1;
}

public interface I : IBase { }

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for I { }
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("1"), verify: Verification.FailsPEVerify).VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var simpleInvocation = GetSyntax<IdentifierNameSyntax>(tree, "Field");
        Assert.Equal("System.Int32 IBase.Field", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Field_Interface_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
System.Console.Write(E.Field);

public interface I
{
    public static int Field = 0;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for I
{
    public static int Field = 1;
}
""";
        // PROTOTYPE should warn about hiding
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("1"), verify: Verification.FailsPEVerify).VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var simpleField = GetSyntax<IdentifierNameSyntax>(tree, "Field");
        Assert.Equal("System.Int32 E.Field", model.GetSymbolInfo(simpleField).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleField));
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Field_SimpleName(bool isExplicit)
    {
        var source = $$"""
E.M();

public static class C
{
    public static int Field1 = 1;
    public static int Field3 = 0;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static int Field3 = 3;
    public static void M()
    {
        System.Console.Write(Field1);
        System.Console.Write(Field3);
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        var verifier = CompileAndVerify(comp, expectedOutput: "13").VerifyDiagnostics();
        verifier.VerifyIL("E.M", """
{
  // Code size       21 (0x15)
  .maxstack  1
  IL_0000:  ldsfld     "int C.Field1"
  IL_0005:  call       "void System.Console.Write(int)"
  IL_000a:  ldsfld     "int E.Field3"
  IL_000f:  call       "void System.Console.Write(int)"
  IL_0014:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var field1 = GetSyntax<IdentifierNameSyntax>(tree, "Field1");
        Assert.Equal("System.Int32 C.Field1", model.GetSymbolInfo(field1).Symbol.ToTestDisplayString());

        var field3 = GetSyntax<IdentifierNameSyntax>(tree, "Field3");
        Assert.Equal("System.Int32 E.Field3", model.GetSymbolInfo(field3).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Field_SimpleName_FromUnderlyingTypeBase(bool isExplicit)
    {
        var source = $$"""
E.M();

public class Base
{
    public static int Field1 = 1;
    public static int Field2 = 0;
    public static int Field3 = 0;
}
public class C : Base
{
    public static int Field2 = 2;
    public static int Field3 = 0;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static int Field3 = 3;
    public static void M()
    {
        System.Console.Write(Field1);
        System.Console.Write(Field2);
        System.Console.Write(Field3);
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        var verifier = CompileAndVerify(comp, expectedOutput: "123").VerifyDiagnostics(
            // (11,23): warning CS0108: 'C.Field2' hides inherited member 'Base.Field2'. Use the new keyword if hiding was intended.
            //     public static int Field2 = 2;
            Diagnostic(ErrorCode.WRN_NewRequired, "Field2").WithArguments("C.Field2", "Base.Field2").WithLocation(11, 23),
            // (12,23): warning CS0108: 'C.Field3' hides inherited member 'Base.Field3'. Use the new keyword if hiding was intended.
            //     public static int Field3 = 0;
            Diagnostic(ErrorCode.WRN_NewRequired, "Field3").WithArguments("C.Field3", "Base.Field3").WithLocation(12, 23)
            );
        verifier.VerifyIL("E.M", """
{
  // Code size       31 (0x1f)
  .maxstack  1
  IL_0000:  ldsfld     "int Base.Field1"
  IL_0005:  call       "void System.Console.Write(int)"
  IL_000a:  ldsfld     "int C.Field2"
  IL_000f:  call       "void System.Console.Write(int)"
  IL_0014:  ldsfld     "int E.Field3"
  IL_0019:  call       "void System.Console.Write(int)"
  IL_001e:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var field1 = GetSyntax<IdentifierNameSyntax>(tree, "Field1");
        Assert.Equal("System.Int32 Base.Field1", model.GetSymbolInfo(field1).Symbol.ToTestDisplayString());

        var field2 = GetSyntax<IdentifierNameSyntax>(tree, "Field2");
        Assert.Equal("System.Int32 C.Field2", model.GetSymbolInfo(field2).Symbol.ToTestDisplayString());

        var field3 = GetSyntax<IdentifierNameSyntax>(tree, "Field3");
        Assert.Equal("System.Int32 E.Field3", model.GetSymbolInfo(field3).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Field(bool isExplicit)
    {
        var source = $$"""
System.Console.Write(E.Field1);
System.Console.Write(E.Field3);

public static class C
{
    public static int Field1 = 1;
    public static int Field3 = 0;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static int Field3 = 3;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "13").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var field1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Field1");
        Assert.Equal("System.Int32 C.Field1", model.GetSymbolInfo(field1).Symbol.ToTestDisplayString());

        var field3 = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Field3");
        Assert.Equal("System.Int32 E.Field3", model.GetSymbolInfo(field3).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Field_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
E.M();

public static class C
{
    public static int Field1 = 0;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static int Field1 = 1;
    public static void M()
    {
        System.Console.Write(Field1);
        System.Console.Write(E.Field1);
    }
}
""";
        // PROTOTYPE should warn about hiding
        var comp = CreateCompilation(source);
        var verifier = CompileAndVerify(comp, expectedOutput: "11").VerifyDiagnostics();
        verifier.VerifyIL("E.M", """
{
  // Code size       21 (0x15)
  .maxstack  1
  IL_0000:  ldsfld     "int E.Field1"
  IL_0005:  call       "void System.Console.Write(int)"
  IL_000a:  ldsfld     "int E.Field1"
  IL_000f:  call       "void System.Console.Write(int)"
  IL_0014:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var field1 = GetSyntaxes<IdentifierNameSyntax>(tree, "Field1").First();
        Assert.Equal("System.Int32 E.Field1", model.GetSymbolInfo(field1).Symbol.ToTestDisplayString());

        var typeField1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Field1");
        Assert.Equal("System.Int32 E.Field1", model.GetSymbolInfo(typeField1).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Const_SimpleName(bool isExplicit)
    {
        var source = $$"""
E.M();
System.Console.Write(E.Const1);
System.Console.Write(E.Const3);

public static class C
{
    public const int Const1 = 1;
    public const int Const3 = 0;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public const int Const3 = 3;
    public static void M()
    {
        System.Console.Write(Const1);
        System.Console.Write(Const3);
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        var verifier = CompileAndVerify(comp, expectedOutput: "1313").VerifyDiagnostics();
        verifier.VerifyIL("E.M", """
{
  // Code size       13 (0xd)
  .maxstack  1
  IL_0000:  ldc.i4.1
  IL_0001:  call       "void System.Console.Write(int)"
  IL_0006:  ldc.i4.3
  IL_0007:  call       "void System.Console.Write(int)"
  IL_000c:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var const1 = GetSyntaxes<IdentifierNameSyntax>(tree, "Const1").Last();
        Assert.Equal("System.Int32 C.Const1", model.GetSymbolInfo(const1).Symbol.ToTestDisplayString());

        var const3 = GetSyntaxes<IdentifierNameSyntax>(tree, "Const3").Last();
        Assert.Equal("System.Int32 E.Const3", model.GetSymbolInfo(const3).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Const(bool isExplicit)
    {
        var source = $$"""
System.Console.Write(E.Const1);
System.Console.Write(E.Const3);

public static class C
{
    public const int Const1 = 1;
    public const int Const3 = 0;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public const int Const3 = 3;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "13").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var const1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Const1");
        Assert.Equal("System.Int32 C.Const1", model.GetSymbolInfo(const1).Symbol.ToTestDisplayString());

        var const3 = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Const3");
        Assert.Equal("System.Int32 E.Const3", model.GetSymbolInfo(const3).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Property_SimpleName(bool isExplicit)
    {
        var source = $$"""
E.M();

public static class C
{
    public static int Property1 => 1;
    public static int Property3 => 0;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static int Property3 => 3;
    public static void M()
    {
        System.Console.Write(Property1);
        System.Console.Write(Property3);
    }
}
""";
        // PROTOTYPE should warn about hiding
        var comp = CreateCompilation(source);
        var verifier = CompileAndVerify(comp, expectedOutput: "13").VerifyDiagnostics();
        verifier.VerifyIL("E.M", """
{
  // Code size       21 (0x15)
  .maxstack  1
  IL_0000:  call       "int C.Property1.get"
  IL_0005:  call       "void System.Console.Write(int)"
  IL_000a:  call       "int E.Property3.get"
  IL_000f:  call       "void System.Console.Write(int)"
  IL_0014:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var property1 = GetSyntax<IdentifierNameSyntax>(tree, "Property1");
        Assert.Equal("System.Int32 C.Property1 { get; }", model.GetSymbolInfo(property1).Symbol.ToTestDisplayString());

        var property3 = GetSyntax<IdentifierNameSyntax>(tree, "Property3");
        Assert.Equal("System.Int32 E.Property3 { get; }", model.GetSymbolInfo(property3).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Property_SimpleName_FromUnderlyingTypeBase(bool isExplicit)
    {
        var source = $$"""
E.M();

public class Base
{
    public static int Property1 => 1;
    public static int Property2 => 0;
    public static int Property3 => 0;
}
public class C : Base
{
    public static int Property2 => 2;
    public static int Property3 => 0;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static int Property3 => 3;
    public static void M()
    {
        System.Console.Write(Property1);
        System.Console.Write(Property2);
        System.Console.Write(Property3);
    }
}
""";
        // PROTOTYPE should warn about hiding
        var comp = CreateCompilation(source);
        var verifier = CompileAndVerify(comp, expectedOutput: "123").VerifyDiagnostics(
            // (11,23): warning CS0108: 'C.Property2' hides inherited member 'Base.Property2'. Use the new keyword if hiding was intended.
            //     public static int Property2 => 2;
            Diagnostic(ErrorCode.WRN_NewRequired, "Property2").WithArguments("C.Property2", "Base.Property2").WithLocation(11, 23),
            // (12,23): warning CS0108: 'C.Property3' hides inherited member 'Base.Property3'. Use the new keyword if hiding was intended.
            //     public static int Property3 => 0;
            Diagnostic(ErrorCode.WRN_NewRequired, "Property3").WithArguments("C.Property3", "Base.Property3").WithLocation(12, 23)
            );
        verifier.VerifyIL("E.M", """
{
  // Code size       31 (0x1f)
  .maxstack  1
  IL_0000:  call       "int Base.Property1.get"
  IL_0005:  call       "void System.Console.Write(int)"
  IL_000a:  call       "int C.Property2.get"
  IL_000f:  call       "void System.Console.Write(int)"
  IL_0014:  call       "int E.Property3.get"
  IL_0019:  call       "void System.Console.Write(int)"
  IL_001e:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var property1 = GetSyntax<IdentifierNameSyntax>(tree, "Property1");
        Assert.Equal("System.Int32 Base.Property1 { get; }", model.GetSymbolInfo(property1).Symbol.ToTestDisplayString());

        var property2 = GetSyntax<IdentifierNameSyntax>(tree, "Property2");
        Assert.Equal("System.Int32 C.Property2 { get; }", model.GetSymbolInfo(property2).Symbol.ToTestDisplayString());

        var property3 = GetSyntax<IdentifierNameSyntax>(tree, "Property3");
        Assert.Equal("System.Int32 E.Property3 { get; }", model.GetSymbolInfo(property3).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Property(bool isExplicit)
    {
        var source = $$"""
E.M();

public static class C
{
    public static int Property1 => 1;
    public static int Property3 => 0;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static int Property3 => 3;
    public static void M()
    {
        System.Console.Write(E.Property1);
        System.Console.Write(E.Property3);
    }
}
""";
        var comp = CreateCompilation(source);
        var verifier = CompileAndVerify(comp, expectedOutput: "13").VerifyDiagnostics();
        verifier.VerifyIL("E.M", """
{
  // Code size       21 (0x15)
  .maxstack  1
  IL_0000:  call       "int C.Property1.get"
  IL_0005:  call       "void System.Console.Write(int)"
  IL_000a:  call       "int E.Property3.get"
  IL_000f:  call       "void System.Console.Write(int)"
  IL_0014:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var property1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Property1");
        Assert.Equal("System.Int32 C.Property1 { get; }", model.GetSymbolInfo(property1).Symbol.ToTestDisplayString());

        var property3 = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Property3");
        Assert.Equal("System.Int32 E.Property3 { get; }", model.GetSymbolInfo(property3).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Property_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
E.M();
System.Console.Write(E.Property1);

public static class C
{
    public static int Property1 => throw null;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static int Property1 => 1;
    public static void M()
    {
        System.Console.Write(Property1);
    }
}
""";
        var comp = CreateCompilation(source);
        var verifier = CompileAndVerify(comp, expectedOutput: "11").VerifyDiagnostics();
        verifier.VerifyIL("E.M", """
 {
  // Code size       11 (0xb)
  .maxstack  1
  IL_0000:  call       "int E.Property1.get"
  IL_0005:  call       "void System.Console.Write(int)"
  IL_000a:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var property1 = GetSyntaxes<IdentifierNameSyntax>(tree, "Property1").First();
        Assert.Equal("System.Int32 E.Property1 { get; }", model.GetSymbolInfo(property1).Symbol.ToTestDisplayString());

        var typeProperty1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Property1");
        Assert.Equal("System.Int32 E.Property1 { get; }", model.GetSymbolInfo(typeProperty1).Symbol.ToTestDisplayString());
    }

    [ConditionalTheory(typeof(NoBaseExtensions)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Property_InaccessibleMemberFromBase(bool isExplicit)
    {
        var source = $$"""
public static class C
{
    public static int Property1 => throw null;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension EBase for C
{
    private static int Property1 => throw null;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension EDerived for C : EBase
{
    public static void M()
    {
        System.Console.Write(Property1);
        System.Console.Write(EDerived.Property1);
    }
}
""";
        // PROTOTYPE should warn about hiding
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var property1 = GetSyntaxes<IdentifierNameSyntax>(tree, "Property1").First();
        Assert.Equal("System.Int32 C.Property1 { get; }", model.GetSymbolInfo(property1).Symbol.ToTestDisplayString());

        var typeProperty1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "EDerived.Property1");
        Assert.Equal("System.Int32 C.Property1 { get; }", model.GetSymbolInfo(typeProperty1).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Nameof_Field(bool isExplicit)
    {
        var source = $$"""
public static class C
{
    public static int nameof = 1;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static void M()
    {
        _ = nameof(M);
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var identifier = GetSyntax<IdentifierNameSyntax>(tree, "nameof");
        Assert.Null(model.GetSymbolInfo(identifier).Symbol);
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Nameof_Method(bool isExplicit)
    {
        var source = $$"""
E.M();

public static class C
{
    public static int nameof(System.Delegate d) => 42;
}

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public static void M()
    {
        System.Console.Write(nameof(M));
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var identifier = GetSyntax<IdentifierNameSyntax>(tree, "nameof");
        Assert.Equal("System.Int32 C.nameof(System.Delegate d)", model.GetSymbolInfo(identifier).Symbol.ToTestDisplayString());
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Field(bool isExplicit)
    {
        var source = $$"""
//E e = new C();
//e.M();
//System.Console.Write(e.Field);

public class C
{
    public int Field = 1;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public void M(E e)
    {
        System.Console.Write(this.Field);
        System.Console.Write(e.Field); // PROTOTYPE move to top-level statement once possible
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
        //var verifier = CompileAndVerify(comp, expectedOutput: "11").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisField = GetSyntax<MemberAccessExpressionSyntax>(tree, "this.Field");
        Assert.Equal("System.Int32 C.Field", model.GetSymbolInfo(thisField).Symbol.ToTestDisplayString());
        var eField = GetSyntax<MemberAccessExpressionSyntax>(tree, "e.Field");
        Assert.Equal("System.Int32 C.Field", model.GetSymbolInfo(eField).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Instance_Field_SimpleName(bool isExplicit)
    {
        var source = $$"""
//E e = new C();
//e.M();

public class C
{
    public int field = 1;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public void M()
    {
        System.Console.Write(field);
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE we should synthesize a receiver (in Binder.SynthesizeReceiver)
        comp.VerifyDiagnostics(
            // (13,30): error CS0120: An object reference is required for the non-static field, method, or property 'C.field'
            //         System.Console.Write(field);
            Diagnostic(ErrorCode.ERR_ObjectRequired, "field").WithArguments("C.field").WithLocation(13, 30)
            );
        // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
        //var verifier = CompileAndVerify(comp, expectedOutput: "1").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var field = GetSyntax<IdentifierNameSyntax>(tree, "field");
        Assert.Null(model.GetSymbolInfo(field).Symbol); // PROTOTYPE need to fix the semantic model
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Property(bool isExplicit)
    {
        var source = $$"""
//E e = new C();
//e.M();
//System.Console.Write(e.Property);

public class C
{
    public int Property => 1;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public void M(E e)
    {
        System.Console.Write(this.Property);
        System.Console.Write(e.Property); // PROTOTYPE move to top-level statement once possible
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
        //var verifier = CompileAndVerify(comp, expectedOutput: "11").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisProperty = GetSyntax<MemberAccessExpressionSyntax>(tree, "this.Property");
        Assert.Equal("System.Int32 C.Property { get; }", model.GetSymbolInfo(thisProperty).Symbol.ToTestDisplayString());
        var eProperty = GetSyntax<MemberAccessExpressionSyntax>(tree, "e.Property");
        Assert.Equal("System.Int32 C.Property { get; }", model.GetSymbolInfo(eProperty).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Instance_Property_SimpleName(bool isExplicit)
    {
        var source = $$"""
//E e = new C();
//e.M();

public class C
{
    public int Property => 1;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public void M()
    {
        System.Console.Write(Property);
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE we should synthesize a receiver (in Binder.SynthesizeReceiver)
        comp.VerifyDiagnostics(
            // (13,30): error CS0120: An object reference is required for the non-static field, method, or property 'C.Property'
            //         System.Console.Write(Property);
            Diagnostic(ErrorCode.ERR_ObjectRequired, "Property").WithArguments("C.Property").WithLocation(13, 30)
            );
        // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
        //var verifier = CompileAndVerify(comp, expectedOutput: "1").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var property = GetSyntax<IdentifierNameSyntax>(tree, "Property");
        Assert.Null(model.GetSymbolInfo(property).Symbol); // PROTOTYPE need to fix the semantic model
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Property_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
//E e = new C();
//e.M(e);

public class C
{
    public int Property => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public int Property => 1;

    public void M(E e)
    {
        System.Console.Write(this.Property);
        System.Console.Write(e.Property);
        System.Console.Write(Property);
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
        //var verifier = CompileAndVerify(comp, expectedOutput: "111").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisProperty = GetSyntax<MemberAccessExpressionSyntax>(tree, "this.Property");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(thisProperty).Symbol.ToTestDisplayString());

        var eProperty = GetSyntax<MemberAccessExpressionSyntax>(tree, "e.Property");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(eProperty).Symbol.ToTestDisplayString());

        var property = GetSyntaxes<IdentifierNameSyntax>(tree, "Property").Last();
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation(bool isExplicit,
        [CombinatorialValues("class", "struct", "interface")] string underlyingKind)
    {
        var source = $$"""
public {{underlyingKind}} Underlying
{
    public void M2() => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e) { this.M2(); e.M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void Underlying.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(thisInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void Underlying.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(instanceInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Instance_Invocation_SimpleName(bool isExplicit)
    {
        var source = $$"""
//E e = new C();
//e.M();

public class C
{
    public void M2() { System.Console.Write("M2"); }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public void M() { M2(); }
}
""";
        // PROTOTYPE we should synthesize a receiver (in Binder.SynthesizeReceiver)
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (11,23): error CS0120: An object reference is required for the non-static field, method, or property 'C.M2()'
            //     public void M() { M2(); }
            Diagnostic(ErrorCode.ERR_ObjectRequired, "M2").WithArguments("C.M2()").WithLocation(11, 23)
            );
        // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
        //CompileAndVerify(comp, expectedOutput: "M2").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(invocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(invocation)); // PROTOTYPE need to fix the semantic model
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_AfterMemberFromExtension(bool isExplicit,
        [CombinatorialValues("class", "struct", "interface")] string underlyingKind)
    {
        var source = $$"""
public {{underlyingKind}} Underlying
{
    public void M2() => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M2() { System.Console.Write("M2 "); }
    public void M(E e) { this.M2(); e.M2(); M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(thisInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(instanceInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(simpleInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Enum(bool isExplicit)
    {
        var source = $$"""
public enum Underlying { Zero = 0 }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e) { this.HasFlag(Underlying.Zero); e.HasFlag(Underlying.Zero); }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.HasFlag(Underlying.Zero)");
        Assert.Equal("System.Boolean System.Enum.HasFlag(System.Enum flag)", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.HasFlag(Underlying.Zero)");
        Assert.Equal("System.Boolean System.Enum.HasFlag(System.Enum flag)", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Enum_SimpleName(bool isExplicit)
    {
        var source = $$"""
public enum Underlying { Zero = 0 }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e) { HasFlag(Underlying.Zero); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE we should synthesize a receiver (in Binder.SynthesizeReceiver)
        comp.VerifyDiagnostics(
            // (5,26): error CS0120: An object reference is required for the non-static field, method, or property 'Enum.HasFlag(Enum)'
            //     public void M(E e) { HasFlag(Underlying.Zero); }
            Diagnostic(ErrorCode.ERR_ObjectRequired, "HasFlag").WithArguments("System.Enum.HasFlag(System.Enum)").WithLocation(5, 26)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "HasFlag(Underlying.Zero)");
        Assert.Equal("System.Boolean System.Enum.HasFlag(System.Enum flag)", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Enum_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
public enum Underlying { Zero = 0 }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public bool HasFlag(System.Enum flag) { System.Console.Write("E.HasFlag "); return true; }
    public void M(E e) { this.HasFlag(Underlying.Zero); e.HasFlag(Underlying.Zero); HasFlag(Underlying.Zero); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.HasFlag(Underlying.Zero)");
        Assert.Equal("System.Boolean E.HasFlag(System.Enum flag)", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.HasFlag(Underlying.Zero)");
        Assert.Equal("System.Boolean E.HasFlag(System.Enum flag)", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "HasFlag(Underlying.Zero)");
        Assert.Equal("System.Boolean E.HasFlag(System.Enum flag)", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Enum_AfterMemberFromExtension_FromObject(bool isExplicit)
    {
        var source = $$"""
public enum Underlying { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public string ToString() { System.Console.Write("E.ToString "); return ""; }
    public void M(E e) { this.ToString(); e.ToString(); ToString(); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.ToString()");
        Assert.Equal("System.String E.ToString()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.ToString()");
        Assert.Equal("System.String E.ToString()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "ToString()");
        Assert.Equal("System.String E.ToString()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Enum_FromEnumType(bool isExplicit)
    {
        var source = $$"""
namespace System
{
    public class Enum
    {
        public void M2() { }
    }
    public struct Int32 { }
    public class ValueType { }
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class String { }
    public struct Boolean { }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute() { }
        public ObsoleteAttribute(string message) { }
        public ObsoleteAttribute(string message, bool error) { }
    }
}

namespace System.Runtime.CompilerServices
{
    public sealed class CompilerFeatureRequiredAttribute : Attribute
    {
        public CompilerFeatureRequiredAttribute(string featureName) { }
    }
}

public enum Underlying { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e) { this.M2(); e.M2(); }
}
""";
        var comp = CreateEmptyCompilation(source);
        comp.VerifyDiagnostics(
            // (34,17): error CS0518: Predefined type 'System.Runtime.CompilerServices.ExtensionAttribute' is not defined or imported
            //     public void M(E e) { this.M2(); e.M2(); }
            Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "M").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(34, 17)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void System.Enum.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void System.Enum.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_Enum_AfterMemberFromExtension_FromEnumType(bool isExplicit)
    {
        var source = $$"""
E.M2();

namespace System
{
    public class Enum
    {
        public static void M2() { }
    }
    public struct Int32 { }
    public class ValueType { }
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class String { }
    public struct Boolean { }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute() { }
        public ObsoleteAttribute(string message) { }
        public ObsoleteAttribute(string message, bool error) { }
    }
}

namespace System.Runtime.CompilerServices
{
    public sealed class CompilerFeatureRequiredAttribute : Attribute
    {
        public CompilerFeatureRequiredAttribute(string featureName) { }
    }
}

public enum Underlying { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public static void M2() { }
    public static void M(E e) { M2(); }
}
""";
        var comp = CreateEmptyCompilation(source);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var eInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(eInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(eInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_Enum_FromInt32(bool isExplicit)
    {
        var source = $$"""
E.IsNegative(42);

public enum Underlying { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public static void M() { IsNegative(42); }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,3): error CS0117: 'E' does not contain a definition for 'IsNegative'
            // E.IsNegative(42);
            Diagnostic(ErrorCode.ERR_NoSuchMember, "IsNegative").WithArguments("E", "IsNegative").WithLocation(1, 3),
            // (7,30): error CS0103: The name 'IsNegative' does not exist in the current context
            //     public static void M() { IsNegative(42); }
            Diagnostic(ErrorCode.ERR_NameNotInContext, "IsNegative").WithArguments("IsNegative").WithLocation(7, 30));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.IsNegative(42)");
        Assert.Null(model.GetSymbolInfo(thisInvocation).Symbol);
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "IsNegative(42)");
        Assert.Null(model.GetSymbolInfo(instanceInvocation).Symbol);
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_TypeParameter_ReferenceTypeConstraint(bool isExplicit)
    {
        var source = $$"""
public class C
{
    public void M2() { System.Console.Write("C.M2 "); }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : C
{
    public void M(E<T> e) { this.M2(); e.M2(); }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_TypeParameter_ReferenceTypeConstraint_SimpleName(bool isExplicit)
    {
        var source = $$"""
public class C
{
    public void M2() { System.Console.Write("C.M2 "); }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : C
{
    public void M(E<T> e) { M2(); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE we should synthesize a receiver (in Binder.SynthesizeReceiver)
        comp.VerifyDiagnostics(
            // (8,29): error CS0120: An object reference is required for the non-static field, method, or property 'C.M2()'
            //     public void M(E<T> e) { M2(); }
            Diagnostic(ErrorCode.ERR_ObjectRequired, "M2").WithArguments("C.M2()").WithLocation(8, 29)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_TypeParameter_ReferenceTypeConstraint(bool isExplicit)
    {
        var source = $$"""
E<C>.M();
E<C>.M2();
E<Derived>.M2();

public class C
{
    public static void M2() { System.Console.Write("ran "); }
}

public class Derived : C { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : C
{
    public static void M() { M2(); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var ecInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<C>.M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(ecInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(ecInvocation));

        var eDerivedInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<Derived>.M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(eDerivedInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(eDerivedInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_TypeParameter_DerivedReferenceTypeConstraint(bool isExplicit)
    {
        var source = $$"""
E<Derived>.M();
E<Derived>.M2();

public class C
{
    public static void M2() { System.Console.Write("ran "); }
}

public class Derived : C { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : Derived
{
    public static void M() { M2(); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var eDerivedInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<Derived>.M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(eDerivedInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(eDerivedInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_TypeParameter_AfterMemberFromExtension_DerivedReferenceTypeConstraint(bool isExplicit)
    {
        var source = $$"""
E<Derived>.M();
E<Derived>.M2();

public class C
{
    public static void M2() => throw null;
}

public class Derived : C { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : Derived
{
    public static void M2() { System.Console.Write("ran "); }
    public static void M() { M2(); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var eDerivedInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<Derived>.M2()");
        Assert.Equal("void E<Derived>.M2()", model.GetSymbolInfo(eDerivedInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(eDerivedInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E<T>.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_TypeParameter_AfterMemberFromExtension_ReferenceTypeConstraint(bool isExplicit)
    {
        var source = $$"""
public class C
{
    public void M2() => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : C
{
    public void M2() { System.Console.Write("E.M2 "); }
    public void M(E<T> e) { this.M2(); e.M2(); M2(); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void E<T>.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void E<T>.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E<T>.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_TypeParameter_AfterMemberFromExtension_ReferenceTypeConstraint(bool isExplicit)
    {
        var source = $$"""
E<C>.M();
E<C>.M2();
E<Derived>.M2();

public class C
{
    public static void M2() => throw null;
}

public class Derived : C { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : C
{
    public static void M2() { System.Console.Write("ran "); }
    public static void M() { M2(); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var ecInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<C>.M2()");
        Assert.Equal("void E<C>.M2()", model.GetSymbolInfo(ecInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(ecInvocation));

        var eDerivedInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<Derived>.M2()");
        Assert.Equal("void E<Derived>.M2()", model.GetSymbolInfo(eDerivedInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(eDerivedInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E<T>.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_TypeParameter_IndirectReferenceTypeConstraint(bool isExplicit)
    {
        var source = $$"""
E<C, C>.M();
E<C, C>.M2();
E<Derived, Derived>.M2();

public class C
{
    public static void M2() { System.Console.Write("ran "); }
}

public class Derived : C { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T, T2> for T where T : T2 where T2 : C
{
    public static void M() { M2(); }
}
""";
        var comp = CreateCompilation(source);
        if (isExplicit)
        {
            CompileAndVerify(comp, expectedOutput: "ran ran ran").VerifyDiagnostics();
        }
        else
        {
            comp.VerifyDiagnostics(
                // (12,27): error CS9328: The underlying type 'T' of implicit extension 'E<T, T2>' must reference all the type parameters declared by the extension, but type parameter 'T2' is missing.
                // public implicit extension E<T, T2> for T where T : T2 where T2 : C
                Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E").WithArguments("T", "E<T, T2>", "T2").WithLocation(12, 27)
                );
        }

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var ecInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<C, C>.M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(ecInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(ecInvocation));

        var eDerivedInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<Derived, Derived>.M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(eDerivedInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(eDerivedInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_TypeParameter_AfterMemberFromExtension_IndirectReferenceTypeConstraint(bool isExplicit)
    {
        var source = $$"""
E<C, C>.M();
E<C, C>.M2();
E<Derived, Derived>.M2();

public class C
{
    public static void M2() => throw null;
}

public class Derived : C { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T, T2> for T where T : T2 where T2 : C
{
    public static void M2() { System.Console.Write("ran "); }
    public static void M() { M2(); }
}
""";
        var comp = CreateCompilation(source);
        if (isExplicit)
        {
            CompileAndVerify(comp, expectedOutput: "ran ran ran").VerifyDiagnostics();
        }
        else
        {
            comp.VerifyDiagnostics(
                // (12,27): error CS9328: The underlying type 'T' of implicit extension 'E<T, T2>' must reference all the type parameters declared by the extension, but type parameter 'T2' is missing.
                // public implicit extension E<T, T2> for T where T : T2 where T2 : C
                Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E").WithArguments("T", "E<T, T2>", "T2").WithLocation(12, 27)
                );
        }

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var ecInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<C, C>.M2()");
        Assert.Equal("void E<C, C>.M2()", model.GetSymbolInfo(ecInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(ecInvocation));

        var eDerivedInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<Derived, Derived>.M2()");
        Assert.Equal("void E<Derived, Derived>.M2()", model.GetSymbolInfo(eDerivedInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(eDerivedInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E<T, T2>.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_TypeParameter_IndirectIndirectReferenceTypeConstraint(bool isExplicit)
    {
        var source = $$"""
E<C, C, C>.M();
E<C, C, C>.M2();
E<Derived, Derived, Derived>.M2();

public class C
{
    public static void M2() { System.Console.Write("ran "); }
}

public class Derived : C { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T, T2, T3> for T where T : T2 where T2 : T3 where T3 : C
{
    public static void M() { M2(); }
}
""";
        var comp = CreateCompilation(source);
        if (isExplicit)
        {
            CompileAndVerify(comp, expectedOutput: "ran ran ran").VerifyDiagnostics();
        }
        else
        {
            comp.VerifyDiagnostics(
                // (12,27): error CS9328: The underlying type 'T' of implicit extension 'E<T, T2, T3>' must reference all the type parameters declared by the extension, but type parameter 'T2' is missing.
                // public implicit extension E<T, T2, T3> for T where T : T2 where T2 : T3 where T3 : C
                Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E").WithArguments("T", "E<T, T2, T3>", "T2").WithLocation(12, 27),
                // (12,27): error CS9328: The underlying type 'T' of implicit extension 'E<T, T2, T3>' must reference all the type parameters declared by the extension, but type parameter 'T3' is missing.
                // public implicit extension E<T, T2, T3> for T where T : T2 where T2 : T3 where T3 : C
                Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E").WithArguments("T", "E<T, T2, T3>", "T3").WithLocation(12, 27)
                );
        }

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var ecInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<C, C, C>.M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(ecInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(ecInvocation));

        var eDerivedInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<Derived, Derived, Derived>.M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(eDerivedInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(eDerivedInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void C.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_TypeParameter_AfterMemberFromExtension_IndirectIndirectReferenceTypeConstraint(bool isExplicit)
    {
        var source = $$"""
E<C, C, C>.M();
E<C, C, C>.M2();
E<Derived, Derived, Derived>.M2();

public class C
{
    public static void M2() => throw null;
}

public class Derived : C { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T, T2, T3> for T where T : T2 where T2 : T3 where T3 : C
{
    public static void M2() { System.Console.Write("ran "); }
    public static void M() { M2(); }
}
""";
        var comp = CreateCompilation(source);
        if (isExplicit)
        {
            CompileAndVerify(comp, expectedOutput: "ran ran ran").VerifyDiagnostics();
        }
        else
        {
            comp.VerifyDiagnostics(
                // (12,27): error CS9328: The underlying type 'T' of implicit extension 'E<T, T2, T3>' must reference all the type parameters declared by the extension, but type parameter 'T2' is missing.
                // public implicit extension E<T, T2, T3> for T where T : T2 where T2 : T3 where T3 : C
                Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E").WithArguments("T", "E<T, T2, T3>", "T2").WithLocation(12, 27),
                // (12,27): error CS9328: The underlying type 'T' of implicit extension 'E<T, T2, T3>' must reference all the type parameters declared by the extension, but type parameter 'T3' is missing.
                // public implicit extension E<T, T2, T3> for T where T : T2 where T2 : T3 where T3 : C
                Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E").WithArguments("T", "E<T, T2, T3>", "T3").WithLocation(12, 27)
                );
        }

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var ecInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<C, C, C>.M2()");
        Assert.Equal("void E<C, C, C>.M2()", model.GetSymbolInfo(ecInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(ecInvocation));

        var eDerivedInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E<Derived, Derived, Derived>.M2()");
        Assert.Equal("void E<Derived, Derived, Derived>.M2()", model.GetSymbolInfo(eDerivedInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(eDerivedInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E<T, T2, T3>.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_TypeParameter_AfterMemberFromExtension_SystemEnumConstraint(bool isExplicit)
    {
        var source = $$"""
public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : struct, System.Enum
{
    public bool HasFlag(System.Enum flag) { System.Console.Write("E.HasFlag "); return true; }
    public void M(E<T> e) { this.HasFlag(default(System.Enum)); e.HasFlag(default(System.Enum)); HasFlag(default(System.Enum)); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.HasFlag(default(System.Enum))");
        Assert.Equal("System.Boolean E<T>.HasFlag(System.Enum flag)", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.HasFlag(default(System.Enum))");
        Assert.Equal("System.Boolean E<T>.HasFlag(System.Enum flag)", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "HasFlag(default(System.Enum))");
        Assert.Equal("System.Boolean E<T>.HasFlag(System.Enum flag)", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_TypeParameter_AfterMemberFromExtension_SystemEnumConstraint_FromObject(bool isExplicit)
    {
        var source = $$"""
public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : struct, System.Enum
{
    public string ToString() { System.Console.Write("E.ToString "); return ""; }
    public void M(E<T> e) { this.ToString(); e.ToString(); ToString(); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.ToString()");
        Assert.Equal("System.String E<T>.ToString()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.ToString()");
        Assert.Equal("System.String E<T>.ToString()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "ToString()");
        Assert.Equal("System.String E<T>.ToString()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_TypeParameter_StructConstraint(bool isExplicit)
    {
        var source = $$"""
public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : struct
{
    public void M(E<T> e) { this.ToString(); e.ToString(); }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.ToString()");
        Assert.Equal("System.String System.ValueType.ToString()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.ToString()");
        Assert.Equal("System.String System.ValueType.ToString()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_TypeParameter_StructConstraint_FromValueType(bool isExplicit)
    {
        var source = $$"""
namespace System
{
    public class ValueType
    {
        public void M2() { }
    }
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class String { }
    public struct Boolean { }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute() { }
        public ObsoleteAttribute(string message) { }
        public ObsoleteAttribute(string message, bool error) { }
    }
}

namespace System.Runtime.CompilerServices
{
    public sealed class CompilerFeatureRequiredAttribute : Attribute
    {
        public CompilerFeatureRequiredAttribute(string featureName) { }
    }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : struct
{
    public void M(E<T> e) { this.M2(); e.M2(); }
}
""";
        var comp = CreateEmptyCompilation(source);
        comp.VerifyDiagnostics(
            // (30,17): error CS0518: Predefined type 'System.Runtime.CompilerServices.ExtensionAttribute' is not defined or imported
            //     public void M(E<T> e) { this.M2(); e.M2(); }
            Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "M").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(30, 17)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void System.ValueType.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void System.ValueType.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Instance_Invocation_TypeParameter_IndirectStructConstraint_FromValueType(bool isExplicit)
    {
        var source = $$"""
public {{(isExplicit ? "explicit" : "implicit")}} extension E<T, T2> for T where T : T2 where T2 : struct
{
}
""";
        var comp = CreateCompilation(source);
        if (isExplicit)
        {
            comp.VerifyDiagnostics(
                // (1,29): error CS0456: Type parameter 'T2' has the 'struct' constraint so 'T2' cannot be used as a constraint for 'T'
                // public explicit extension E<T, T2> for T where T : T2 where T2 : struct
                Diagnostic(ErrorCode.ERR_ConWithValCon, "T").WithArguments("T", "T2").WithLocation(1, 29));
        }
        else
        {
            comp.VerifyDiagnostics(
                // (1,27): error CS9328: The underlying type 'T' of implicit extension 'E<T, T2>' must reference all the type parameters declared by the extension, but type parameter 'T2' is missing.
                // public implicit extension E<T, T2> for T where T : T2 where T2 : struct
                Diagnostic(ErrorCode.ERR_UnderspecifiedImplicitExtension, "E").WithArguments("T", "E<T, T2>", "T2").WithLocation(1, 27),
                // (1,29): error CS0456: Type parameter 'T2' has the 'struct' constraint so 'T2' cannot be used as a constraint for 'T'
                // public implicit extension E<T, T2> for T where T : T2 where T2 : struct
                Diagnostic(ErrorCode.ERR_ConWithValCon, "T").WithArguments("T", "T2").WithLocation(1, 29));
        }
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_TypeParameter_AfterMemberFromExtension_StructConstraint(bool isExplicit)
    {
        var source = $$"""
namespace System
{
    public class ValueType
    {
        public void M2() { }
    }
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class String { }
    public struct Boolean { }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute() { }
        public ObsoleteAttribute(string message) { }
        public ObsoleteAttribute(string message, bool error) { }
    }
}

namespace System.Runtime.CompilerServices
{
    public sealed class CompilerFeatureRequiredAttribute : Attribute
    {
        public CompilerFeatureRequiredAttribute(string featureName) { }
    }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : struct
{
    public void M2() { }
    public void M(E<T> e) { this.M2(); e.M2(); }
}
""";
        var comp = CreateEmptyCompilation(source);
        comp.VerifyDiagnostics(
            // (30,17): error CS0518: Predefined type 'System.Runtime.CompilerServices.ExtensionAttribute' is not defined or imported
            //     public void M2() { }
            Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "M2").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(30, 17),
            // (31,17): error CS0518: Predefined type 'System.Runtime.CompilerServices.ExtensionAttribute' is not defined or imported
            //     public void M(E<T> e) { this.M2(); e.M2(); }
            Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "M").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(31, 17)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void E<T>.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void E<T>.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_TypeParameter_StructConstraint_SimpleName(bool isExplicit)
    {
        var source = $$"""
public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : struct
{
    public void M(E<T> e) { ToString(); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE we should synthesize a receiver (in Binder.SynthesizeReceiver)
        comp.VerifyDiagnostics(
            // (3,29): error CS0120: An object reference is required for the non-static field, method, or property 'ValueType.ToString()'
            //     public void M(E<T> e) { ToString(); }
            Diagnostic(ErrorCode.ERR_ObjectRequired, "ToString").WithArguments("System.ValueType.ToString()").WithLocation(3, 29)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "ToString()");
        Assert.Equal("System.String System.ValueType.ToString()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_TypeParameter_AfterMemberFromExtension_StructConstraint_FromObject(bool isExplicit)
    {
        var source = $$"""
public {{(isExplicit ? "explicit" : "implicit")}} extension E<T> for T where T : struct
{
    public string ToString() { System.Console.Write("E.ToString "); return ""; }
    public void M(E<T> e) { this.ToString(); e.ToString(); ToString(); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.ToString()");
        Assert.Equal("System.String E<T>.ToString()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.ToString()");
        Assert.Equal("System.String E<T>.ToString()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "ToString()");
        Assert.Equal("System.String E<T>.ToString()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Struct(bool isExplicit)
    {
        var source = $$"""
public struct Underlying
{
    public string ToString() { System.Console.Write("Underlying.ToString "); return ""; }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e) { this.ToString(); e.ToString(); }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (3,19): warning CS0114: 'Underlying.ToString()' hides inherited member 'ValueType.ToString()'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.
            //     public string ToString() { System.Console.Write("Underlying.ToString "); return ""; }
            Diagnostic(ErrorCode.WRN_NewOrOverrideExpected, "ToString").WithArguments("Underlying.ToString()", "System.ValueType.ToString()").WithLocation(3, 19)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.ToString()");
        Assert.Equal("System.String Underlying.ToString()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.ToString()");
        Assert.Equal("System.String Underlying.ToString()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Struct_SimpleName(bool isExplicit)
    {
        var source = $$"""
public struct Underlying
{
    public string ToString() { System.Console.Write("Underlying.ToString "); return ""; }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e) { ToString(); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE we should synthesize a receiver (in Binder.SynthesizeReceiver)
        comp.VerifyDiagnostics(
            // (3,19): warning CS0114: 'Underlying.ToString()' hides inherited member 'ValueType.ToString()'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.
            //     public string ToString() { System.Console.Write("Underlying.ToString "); return ""; }
            Diagnostic(ErrorCode.WRN_NewOrOverrideExpected, "ToString").WithArguments("Underlying.ToString()", "System.ValueType.ToString()").WithLocation(3, 19),
            // (8,26): error CS0120: An object reference is required for the non-static field, method, or property 'Underlying.ToString()'
            //     public void M(E e) { ToString(); }
            Diagnostic(ErrorCode.ERR_ObjectRequired, "ToString").WithArguments("Underlying.ToString()").WithLocation(8, 26)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "ToString()");
        Assert.Equal("System.String Underlying.ToString()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Struct_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
public struct Underlying
{
    public string ToString() => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public string ToString() { System.Console.Write("E.ToString "); return ""; }
    public void M(E e) { this.ToString(); e.ToString(); ToString(); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics(
            // (3,19): warning CS0114: 'Underlying.ToString()' hides inherited member 'ValueType.ToString()'. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword.
            //     public string ToString() => throw null;
            Diagnostic(ErrorCode.WRN_NewOrOverrideExpected, "ToString").WithArguments("Underlying.ToString()", "System.ValueType.ToString()").WithLocation(3, 19)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.ToString()");
        Assert.Equal("System.String E.ToString()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.ToString()");
        Assert.Equal("System.String E.ToString()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "ToString()");
        Assert.Equal("System.String E.ToString()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Struct_FromValueType(bool isExplicit)
    {
        var source = $$"""
namespace System
{
    public class ValueType
    {
        public void M2() { }
    }
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class String { }
    public struct Boolean { }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute() { }
        public ObsoleteAttribute(string message) { }
        public ObsoleteAttribute(string message, bool error) { }
    }
}

namespace System.Runtime.CompilerServices
{
    public sealed class CompilerFeatureRequiredAttribute : Attribute
    {
        public CompilerFeatureRequiredAttribute(string featureName) { }
    }
}

public struct Underlying { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e) { this.M2(); e.M2(); }
}
""";
        var comp = CreateEmptyCompilation(source);
        comp.VerifyDiagnostics(
            // (32,17): error CS0518: Predefined type 'System.Runtime.CompilerServices.ExtensionAttribute' is not defined or imported
            //     public void M(E e) { this.M2(); e.M2(); }
            Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "M").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(32, 17)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void System.ValueType.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void System.ValueType.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Struct_AfterMemberFromExtension_FromValueType(bool isExplicit)
    {
        var source = $$"""
namespace System
{
    public class ValueType
    {
        public void M2() { }
    }
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class String { }
    public struct Boolean { }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute() { }
        public ObsoleteAttribute(string message) { }
        public ObsoleteAttribute(string message, bool error) { }
    }
}

namespace System.Runtime.CompilerServices
{
    public sealed class CompilerFeatureRequiredAttribute : Attribute
    {
        public CompilerFeatureRequiredAttribute(string featureName) { }
    }
}

public struct Underlying { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M2() { }
    public void M(E e) { this.M2(); e.M2(); }
}
""";
        var comp = CreateEmptyCompilation(source);
        comp.VerifyDiagnostics(
            // (32,17): error CS0518: Predefined type 'System.Runtime.CompilerServices.ExtensionAttribute' is not defined or imported
            //     public void M2() { }
            Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "M2").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(32, 17),
            // (33,17): error CS0518: Predefined type 'System.Runtime.CompilerServices.ExtensionAttribute' is not defined or imported
            //     public void M(E e) { this.M2(); e.M2(); }
            Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "M").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(33, 17)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Delegate(bool isExplicit)
    {
        var source = $$"""
public delegate void Underlying();

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e) { this.Clone(); e.Clone(); }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.Clone()");
        Assert.Equal("System.Object System.Delegate.Clone()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.Clone()");
        Assert.Equal("System.Object System.Delegate.Clone()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Delegate_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
public delegate void Underlying();

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void Clone() { }
    public void M(E e) { this.Clone(); e.Clone(); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.Clone()");
        Assert.Equal("void E.Clone()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.Clone()");
        Assert.Equal("void E.Clone()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_PatternBased_DelegateInvocation(bool isExplicit)
    {
        var source = $$"""
public delegate void Underlying();

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e) { this(); e(); }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE delegate invocation is not supported yet
        comp.VerifyDiagnostics(
            // (5,26): error CS0149: Method name expected
            //     public void M(E e) { this(); e(); }
            Diagnostic(ErrorCode.ERR_MethodNameExpected, "this").WithLocation(5, 26),
            // (5,34): error CS0149: Method name expected
            //     public void M(E e) { this(); e(); }
            Diagnostic(ErrorCode.ERR_MethodNameExpected, "e").WithLocation(5, 34)
            );
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_PatternBased_Deconstruction(bool isExplicit)
    {
        var source = $$"""
public class Underlying
{
    public void Deconstruct(out int i, out int j) { (i, j) = (42, 43); }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e)
    {
        var (i, j) = this;
        System.Console.Write($"ran {i} {j} ");

        (i, j) = e;
        System.Console.Write($"ran {i} {j} ");
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisAssignment = GetSyntax<AssignmentExpressionSyntax>(tree, "var (i, j) = this");
        Assert.Equal("void Underlying.Deconstruct(out System.Int32 i, out System.Int32 j)",
            model.GetDeconstructionInfo(thisAssignment).Method.ToTestDisplayString());

        var eAssignment = GetSyntax<AssignmentExpressionSyntax>(tree, "(i, j) = e");
        Assert.Equal("void Underlying.Deconstruct(out System.Int32 i, out System.Int32 j)",
            model.GetDeconstructionInfo(eAssignment).Method.ToTestDisplayString());
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_PatternBased_Deconstruction_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
public class Underlying
{
    public void Deconstruct(out int i, out int j) => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void Deconstruct(out int i, out int j) { (i, j) = (42, 43); }

    public void M(E e)
    {
        var (i, j) = this;
        System.Console.Write($"ran {i} {j} ");

        (i, j) = e;
        System.Console.Write($"ran {i} {j} ");
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisAssignment = GetSyntax<AssignmentExpressionSyntax>(tree, "var (i, j) = this");
        Assert.Equal("void E.Deconstruct(out System.Int32 i, out System.Int32 j)",
            model.GetDeconstructionInfo(thisAssignment).Method.ToTestDisplayString());

        var eAssignment = GetSyntax<AssignmentExpressionSyntax>(tree, "(i, j) = e");
        Assert.Equal("void E.Deconstruct(out System.Int32 i, out System.Int32 j)",
            model.GetDeconstructionInfo(eAssignment).Method.ToTestDisplayString());
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_PatternBased_Foreach_GetEnumerator(bool isExplicit)
    {
        var source = $$"""
public class Underlying
{
    public System.Collections.Generic.IEnumerator<int> GetEnumerator() { yield return 42; }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e)
    {
        foreach (var i in this)
        {
            System.Console.Write($"ran {i} ");
        }

        foreach (var i in e)
        {
            System.Console.Write($"ran {e} ");
        }
    }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisForeach = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().First();
        Assert.Equal("System.Collections.Generic.IEnumerator<System.Int32> Underlying.GetEnumerator()",
            model.GetForEachStatementInfo(thisForeach).GetEnumeratorMethod.ToTestDisplayString());

        var eForeach = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().First();
        Assert.Equal("System.Collections.Generic.IEnumerator<System.Int32> Underlying.GetEnumerator()",
            model.GetForEachStatementInfo(eForeach).GetEnumeratorMethod.ToTestDisplayString());
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_PatternBased_Foreach_GetEnumerator_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
public class Underlying
{
    public System.Collections.Generic.IEnumerator<int> GetEnumerator() => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public System.Collections.Generic.IEnumerator<int> GetEnumerator() { yield return 42; }

    public void M(E e)
    {
        foreach (var i in this)
        {
            System.Console.Write($"ran {i} ");
        }

        foreach (var i in e)
        {
            System.Console.Write($"ran {e} ");
        }
    }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisForeach = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().First();
        Assert.Equal("System.Collections.Generic.IEnumerator<System.Int32> E.GetEnumerator()",
            model.GetForEachStatementInfo(thisForeach).GetEnumeratorMethod.ToTestDisplayString());

        var eForeach = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().First();
        Assert.Equal("System.Collections.Generic.IEnumerator<System.Int32> E.GetEnumerator()",
            model.GetForEachStatementInfo(eForeach).GetEnumeratorMethod.ToTestDisplayString());
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_PatternBased_Foreach_MoveNext(bool isExplicit)
    {
        var source = $$"""
public class Underlying
{
    public bool MoveNext() { System.Console.Write("ran "); return true; }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public E GetEnumerator() => this;
    public int Current => 42;

    public void M(E e)
    {
        foreach (var i in this)
        {
            System.Console.Write($"{i} ");
            break;
        }

        foreach (var i in e)
        {
            System.Console.Write($"{i} ");
            break;
        }
    }
}
""";
        // PROTOTYPE fix pattern-based foreach to recognize MoveNext() method from the underlying type
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (13,27): error CS0202: foreach requires that the return type 'E' of 'E.GetEnumerator()' must have a suitable public 'MoveNext' method and public 'Current' property
            //         foreach (var i in this)
            Diagnostic(ErrorCode.ERR_BadGetEnumerator, "this").WithArguments("E", "E.GetEnumerator()").WithLocation(13, 27),
            // (19,27): error CS0202: foreach requires that the return type 'E' of 'E.GetEnumerator()' must have a suitable public 'MoveNext' method and public 'Current' property
            //         foreach (var i in e)
            Diagnostic(ErrorCode.ERR_BadGetEnumerator, "e").WithArguments("E", "E.GetEnumerator()").WithLocation(19, 27));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisForeach = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().First();
        Assert.Null(model.GetForEachStatementInfo(thisForeach).CurrentProperty);

        var eForeach = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().First();
        Assert.Null(model.GetForEachStatementInfo(eForeach).CurrentProperty);
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_PatternBased_Foreach_Current(bool isExplicit)
    {
        var source = $$"""
public class Underlying
{
    public int Current { get { System.Console.Write("ran "); return 42; } }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public E GetEnumerator() => this;
    public bool MoveNext() { return true; }

    public void M(E e)
    {
        foreach (var i in this)
        {
            System.Console.Write($"{i} ");
            break;
        }

        foreach (var i in e)
        {
            System.Console.Write($"{i} ");
            break;
        }
    }
}
""";
        // PROTOTYPE fix pattern-based foreach to recognize Current property from the underlying type
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (13,27): error CS0202: foreach requires that the return type 'E' of 'E.GetEnumerator()' must have a suitable public 'MoveNext' method and public 'Current' property
            //         foreach (var i in this)
            Diagnostic(ErrorCode.ERR_BadGetEnumerator, "this").WithArguments("E", "E.GetEnumerator()").WithLocation(13, 27),
            // (19,27): error CS0202: foreach requires that the return type 'E' of 'E.GetEnumerator()' must have a suitable public 'MoveNext' method and public 'Current' property
            //         foreach (var i in e)
            Diagnostic(ErrorCode.ERR_BadGetEnumerator, "e").WithArguments("E", "E.GetEnumerator()").WithLocation(19, 27));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisForeach = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().First();
        Assert.Null(model.GetForEachStatementInfo(thisForeach).CurrentProperty);

        var eForeach = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().First();
        Assert.Null(model.GetForEachStatementInfo(eForeach).CurrentProperty);
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_PatternBased_Using(bool isExplicit)
    {
        var source = $$"""
public class Underlying
{
    public void Dispose() { System.Console.Write("ran "); }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e)
    {
        using (this) { }
        using (e) { }
    }
}
""";
        // PROTOTYPE fix pattern-based using to recognize Dispose method from the underlying type
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (10,16): error CS1674: 'E': type used in a using statement must be implicitly convertible to 'System.IDisposable'.
            //         using (this) { }
            Diagnostic(ErrorCode.ERR_NoConvToIDisp, "this").WithArguments("E").WithLocation(10, 16),
            // (11,16): error CS1674: 'E': type used in a using statement must be implicitly convertible to 'System.IDisposable'.
            //         using (e) { }
            Diagnostic(ErrorCode.ERR_NoConvToIDisp, "e").WithArguments("E").WithLocation(11, 16));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_PatternBased_Await(bool isExplicit)
    {
        var source = $$"""
public class Underlying
{
    public System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter GetAwaiter()
    {
        System.Console.Write("ran ");
        return System.Threading.Tasks.Task.Yield().GetAwaiter();
    }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public async System.Threading.Tasks.Task<int> M(E e)
    {
        await this;
        await e;
        return 0;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisAwait = GetSyntax<AwaitExpressionSyntax>(tree, "await this");
        Assert.Equal("System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter Underlying.GetAwaiter()",
            model.GetAwaitExpressionInfo(thisAwait).GetAwaiterMethod.ToTestDisplayString());

        var eAwait = GetSyntax<AwaitExpressionSyntax>(tree, "await e");
        Assert.Equal("System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter Underlying.GetAwaiter()",
            model.GetAwaitExpressionInfo(eAwait).GetAwaiterMethod.ToTestDisplayString());
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_PatternBased_Await_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
public class Underlying
{
    public System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter GetAwaiter() => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter GetAwaiter()
    {
        System.Console.Write("ran ");
        return System.Threading.Tasks.Task.Yield().GetAwaiter();
    }

    public async System.Threading.Tasks.Task<int> M(E e)
    {
        await this;
        await e;
        return 0;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisAwait = GetSyntax<AwaitExpressionSyntax>(tree, "await this");
        Assert.Equal("System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter E.GetAwaiter()",
            model.GetAwaitExpressionInfo(thisAwait).GetAwaiterMethod.ToTestDisplayString());

        var eAwait = GetSyntax<AwaitExpressionSyntax>(tree, "await e");
        Assert.Equal("System.Runtime.CompilerServices.YieldAwaitable.YieldAwaiter E.GetAwaiter()",
            model.GetAwaitExpressionInfo(eAwait).GetAwaiterMethod.ToTestDisplayString());
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_PatternBased_Fixed(bool isExplicit)
    {
        var source = $$"""
public class Underlying
{
    public ref int GetPinnableReference() => throw null;
}

public unsafe {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e)
    {
        fixed (int* p1 = this) { }
        fixed (int* p2 = e) { }
    }
}
""";
        var comp = CreateCompilation(source, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics();
        // PROTOTYPE execute and verify the symbols using semantic model and/or IOperation
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_PatternBased_Fixed_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
public class Underlying
{
    public ref int GetPinnableReference() => throw null;
}

public unsafe {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public ref int GetPinnableReference() => throw null;

    public void M(E e)
    {
        fixed (int* p1 = this) { }
        fixed (int* p2 = e) { }
    }
}
""";
        var comp = CreateCompilation(source, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics();
        // PROTOTYPE execute and verify the symbols using semantic model and/or IOperation
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_AfterMemberFromExtension_FromUnderlyingTypeBase(bool isExplicit,
        [CombinatorialValues("class", "interface")] string underlyingKind)
    {
        var source = $$"""
public {{underlyingKind}} Base
{
    public void M2() => throw null;
}

public {{underlyingKind}} Underlying : Base { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M2() { System.Console.Write("M2 "); }
    public void M(E e) { this.M2(); e.M2(); M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_ZeroArityMatchesAny(bool isExplicit)
    {
        var source = $$"""
//E e = new C();
//e.M(e);

public class C
{
    public void Method(int i) => throw null;
    public void Method<T>(T t) { System.Console.Write("Method "); }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public void M(E e) { this.Method(""); e.Method(""); this.Method<string>(""); e.Method<string>(""); }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
        //CompileAndVerify(comp, expectedOutput: "Method Method Method Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, """this.Method("")""");
        Assert.Equal("void C.Method<System.String>(System.String t)", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation)); // PROTOTYPE need to fix the semantic model

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, """e.Method("")""");
        Assert.Equal("void C.Method<System.String>(System.String t)", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Instance_Invocation_SimpleName_ZeroArityMatchesAny(bool isExplicit)
    {
        var source = $$"""
//E e = new C();
//e.M();

public class C
{
    public void Method(int i) => throw null;
    public void Method<T>(T t) { System.Console.Write("Method "); }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public void M() { Method(""); Method<string>(""); }
}
""";
        // PROTOTYPE we should synthesize a receiver (in Binder.SynthesizeReceiver)
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (12,23): error CS0120: An object reference is required for the non-static field, method, or property 'C.Method<string>(string)'
            //     public void M() { Method(""); Method<string>(""); }
            Diagnostic(ErrorCode.ERR_ObjectRequired, "Method").WithArguments("C.Method<string>(string)").WithLocation(12, 23),
            // (12,35): error CS0120: An object reference is required for the non-static field, method, or property 'C.Method<string>(string)'
            //     public void M() { Method(""); Method<string>(""); }
            Diagnostic(ErrorCode.ERR_ObjectRequired, "Method<string>").WithArguments("C.Method<string>(string)").WithLocation(12, 35)
            );
        // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
        //CompileAndVerify(comp, expectedOutput: "Method Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, """Method("")""");
        Assert.Equal("void C.Method<System.String>(System.String t)", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation)); // PROTOTYPE need to fix the semantic model
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Interface(bool isExplicit)
    {
        var source = $$"""
public interface Underlying
{
    public void M2() { System.Console.Write("Underlying.M2 "); }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e) { this.M2(); e.M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void Underlying.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void Underlying.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Interface_SimpleName(bool isExplicit)
    {
        var source = $$"""
public interface Underlying
{
    public void M2() { System.Console.Write("Underlying.M2 "); }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M() { M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        // PROTOTYPE we should synthesize a receiver (in Binder.SynthesizeReceiver)
        comp.VerifyDiagnostics(
            // (8,23): error CS0120: An object reference is required for the non-static field, method, or property 'Underlying.M2()'
            //     public void M() { M2(); }
            Diagnostic(ErrorCode.ERR_ObjectRequired, "M2").WithArguments("Underlying.M2()").WithLocation(8, 23)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void Underlying.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_Interface_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
E.M2();

public interface Underlying
{
    public static void M2() => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public static void M2() { System.Console.Write("ran "); }
    public static void M() { M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("ran"), verify: Verification.FailsPEVerify).VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var eInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(eInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(eInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Interface_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
public interface Underlying
{
    public void M2() => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M2() { System.Console.Write("E.M2 "); }
    public void M(E e) { this.M2(); e.M2(); M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Interface_AmbiguousBetweenTwoInterfaces(bool isExplicit)
    {
        var source = $$"""
public interface I1
{
    public void M2() => throw null;
}
public interface I2
{
    public void M2() => throw null;
}
public interface Underlying : I1, I2 { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M(E e) { this.M2(); e.M2(); M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (13,31): error CS0121: The call is ambiguous between the following methods or properties: 'I1.M2()' and 'I2.M2()'
            //     public void M(E e) { this.M2(); e.M2(); M2(); }
            Diagnostic(ErrorCode.ERR_AmbigCall, "M2").WithArguments("I1.M2()", "I2.M2()").WithLocation(13, 31),
            // (13,39): error CS0121: The call is ambiguous between the following methods or properties: 'I1.M2()' and 'I2.M2()'
            //     public void M(E e) { this.M2(); e.M2(); M2(); }
            Diagnostic(ErrorCode.ERR_AmbigCall, "M2").WithArguments("I1.M2()", "I2.M2()").WithLocation(13, 39),
            // (13,45): error CS0121: The call is ambiguous between the following methods or properties: 'I1.M2()' and 'I2.M2()'
            //     public void M(E e) { this.M2(); e.M2(); M2(); }
            Diagnostic(ErrorCode.ERR_AmbigCall, "M2").WithArguments("I1.M2()", "I2.M2()").WithLocation(13, 45)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Null(model.GetSymbolInfo(thisInvocation).Symbol);
        Assert.Equal(["void I1.M2()", "void I2.M2()"], model.GetSymbolInfo(thisInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Null(model.GetSymbolInfo(instanceInvocation).Symbol);
        Assert.Equal(["void I1.M2()", "void I2.M2()"], model.GetSymbolInfo(instanceInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Null(model.GetSymbolInfo(simpleInvocation).Symbol);
        Assert.Equal(["void I1.M2()", "void I2.M2()"], model.GetSymbolInfo(simpleInvocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Interface_TwoAfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
public interface I1
{
    public void M2() => throw null;
}
public interface I2
{
    public void M2() => throw null;
}
public interface Underlying : I1, I2 { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public void M2() { System.Console.Write("E.M2 "); }
    public void M(E e) { this.M2(); e.M2(); M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Interface_Generic(bool isExplicit)
    {
        var source = $$"""
public interface Underlying<T>
{
    public void M2() => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying<int>
{
    public void M(E e) { this.M2(); e.M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void Underlying<System.Int32>.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void Underlying<System.Int32>.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Interface_Generic_SimpleName(bool isExplicit)
    {
        var source = $$"""
public interface Underlying<T>
{
    public void M2() => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying<int>
{
    public void M(E e) { M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (8,26): error CS0120: An object reference is required for the non-static field, method, or property 'Underlying<int>.M2()'
            //     public void M(E e) { M2(); }
            Diagnostic(ErrorCode.ERR_ObjectRequired, "M2").WithArguments("Underlying<int>.M2()").WithLocation(8, 26)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void Underlying<System.Int32>.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Interface_Generic_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
public interface Underlying<T>
{
    public void M2() => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying<int>
{
    public void M2() { System.Console.Write("E.M2 "); }
    public void M(E e) { this.M2(); e.M2(); M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(thisInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisInvocation));

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(instanceInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [ConditionalTheory(typeof(NoUsedAssembliesValidation)), CombinatorialData]
    public void UnderlyingTypeMemberLookup_Static_Invocation_Interface(bool isExplicit)
    {
        var source = $$"""
E.M();
E.M2();

public interface Underlying
{
    public static void M2() { System.Console.Write("ran "); }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for Underlying
{
    public static void M() { M2(); }
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("ran ran"), verify: Verification.FailsPEVerify).VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var eInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "E.M2()");
        Assert.Equal("void Underlying.M2()", model.GetSymbolInfo(eInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(eInvocation));

        var simpleInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void Underlying.M2()", model.GetSymbolInfo(simpleInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleInvocation));
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Base(bool isExplicit)
    {
        var source = $$"""
public class C
{
    public void M2() => throw null;
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public void M() { base.M2(); }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (8,23): error CS0174: A base class is required for a 'base' reference
            //     public void M() { base.M2(); }
            Diagnostic(ErrorCode.ERR_NoBaseClass, "base").WithLocation(8, 23)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var baseInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "base.M2()");
        Assert.Null(model.GetSymbolInfo(baseInvocation).Symbol);
        Assert.Empty(model.GetMemberGroup(baseInvocation));
    }

    [Fact]
    public void UnderlyingTypeMemberLookup_Instance_Invocation_MissingMember()
    {
        var source = """
public class C
{
}

public implicit extension E for C
{
    public void M(E e)
    {
        this.Missing();
        e.Missing();
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (9,14): error CS1061: 'E' does not contain a definition for 'Missing' and no accessible extension method 'Missing' accepting a first argument of type 'E' could be found (are you missing a using directive or an assembly reference?)
            //         this.Missing();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Missing").WithArguments("E", "Missing").WithLocation(9, 14),
            // (10,11): error CS1061: 'E' does not contain a definition for 'Missing' and no accessible extension method 'Missing' accepting a first argument of type 'E' could be found (are you missing a using directive or an assembly reference?)
            //         e.Missing();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Missing").WithArguments("E", "Missing").WithLocation(10, 11)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.Missing()");
        Assert.Null(model.GetSymbolInfo(thisInvocation).Symbol);
        Assert.Empty(model.GetMemberGroup(thisInvocation)); // PROTOTYPE need to fix the semantic model

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.Missing()");
        Assert.Null(model.GetSymbolInfo(instanceInvocation).Symbol);
        Assert.Empty(model.GetMemberGroup(instanceInvocation)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void UnderlyingTypeMemberLookup_Instance_Invocation_InaccessibleMember()
    {
        var source = """
public class C
{
    protected void MProtected() { }
    private void MPrivate() { }
}

public implicit extension E for C
{
    public void M(E e)
    {
        MProtected(); // 1
        this.MProtected(); // 2
        e.MProtected(); // 3

        MPrivate(); // 4
        this.MPrivate(); // 5
        e.MPrivate(); // 6
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (11,9): error CS0122: 'C.MProtected()' is inaccessible due to its protection level
            //         MProtected(); // 1
            Diagnostic(ErrorCode.ERR_BadAccess, "MProtected").WithArguments("C.MProtected()").WithLocation(11, 9),
            // (12,14): error CS0122: 'C.MProtected()' is inaccessible due to its protection level
            //         this.MProtected(); // 2
            Diagnostic(ErrorCode.ERR_BadAccess, "MProtected").WithArguments("C.MProtected()").WithLocation(12, 14),
            // (13,11): error CS0122: 'C.MProtected()' is inaccessible due to its protection level
            //         e.MProtected(); // 3
            Diagnostic(ErrorCode.ERR_BadAccess, "MProtected").WithArguments("C.MProtected()").WithLocation(13, 11),
            // (15,9): error CS0122: 'C.MPrivate()' is inaccessible due to its protection level
            //         MPrivate(); // 4
            Diagnostic(ErrorCode.ERR_BadAccess, "MPrivate").WithArguments("C.MPrivate()").WithLocation(15, 9),
            // (16,14): error CS0122: 'C.MPrivate()' is inaccessible due to its protection level
            //         this.MPrivate(); // 5
            Diagnostic(ErrorCode.ERR_BadAccess, "MPrivate").WithArguments("C.MPrivate()").WithLocation(16, 14),
            // (17,11): error CS0122: 'C.MPrivate()' is inaccessible due to its protection level
            //         e.MPrivate(); // 6
            Diagnostic(ErrorCode.ERR_BadAccess, "MPrivate").WithArguments("C.MPrivate()").WithLocation(17, 11)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        foreach (var invocationString in new[] {
            "MProtected()", "this.MProtected()", "e.MProtected()",
            "MPrivate()", "this.MPrivate()", "e.MPrivate()" })
        {
            var invocation = GetSyntax<InvocationExpressionSyntax>(tree, invocationString);
            Assert.Null(model.GetSymbolInfo(invocation).Symbol);
            Assert.Empty(model.GetMemberGroup(invocation));
        }
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Instance_IndexerAccess(bool isExplicit)
    {
        var source = $$"""
//E e = new C();
//e.M(e);

public class C
{
    public int this[int i] { get { System.Console.Write($"[{i}] "); return 0; } }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public void M(E e)
    {
        _ = this[42];
        _ = e[43];

        _ = this["one"];
        _ = e["two"];
    }
    public int this[string s] { get { System.Console.Write($"[{s}] "); return 0; } }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        // PROTOTYPE move e[43] and e["two"] outside of E (to top-level statement)
        comp.VerifyEmitDiagnostics(
            // (13,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = this[42];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "this[42]").WithArguments("E").WithLocation(13, 13),
            // (14,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = e[43];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "e[43]").WithArguments("E").WithLocation(14, 13),
            // (16,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = this["one"];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, @"this[""one""]").WithArguments("E").WithLocation(16, 13),
            // (17,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = e["two"];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, @"e[""two""]").WithArguments("E").WithLocation(17, 13)
            );
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Instance_IndexerAccess_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
//E e = new C();
//e.M(e);

public class C
{
    public int this[int i] { get { throw null; } }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public int this[int i] { get { System.Console.Write($"[{i}] "); return 0; } }
    public void M(E e)
    {
        _ = this[42];
        _ = e[43];
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        // PROTOTYPE(instance) implement indexer access on receiver of extension type (overload resolution should already pick the extension member)
        comp.VerifyEmitDiagnostics(
            // (14,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = this[42];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "this[42]").WithArguments("E").WithLocation(14, 13),
            // (15,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = e[43];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "e[43]").WithArguments("E").WithLocation(15, 13)
            );
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Instance_IndexerAccess_AfterMemberFromExtension_FromUnderlyingTypeBase(bool isExplicit)
    {
        var source = $$"""
//E e = new C();
//e.M(e);

public class Base
{
    public int this[int i] { get { throw null; } }
}

public class C : Base { }

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    public int this[int i] { get { System.Console.Write($"[{i}] "); return 0; } }
    public void M(E e)
    {
        _ = this[42];
        _ = e[43];
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        // PROTOTYPE(instance) implement indexer access on receiver of extension type (overload resolution should already pick the extension member)
        comp.VerifyEmitDiagnostics(
            // (16,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = this[42];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "this[42]").WithArguments("E").WithLocation(16, 13),
            // (17,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = e[43];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "e[43]").WithArguments("E").WithLocation(17, 13)
            );
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Instance_IndexerAccess_Array(bool isExplicit)
    {
        var source = $$"""
public {{(isExplicit ? "explicit" : "implicit")}} extension E for int[]
{
    public void M(E e)
    {
        _ = this[42];
        _ = e[43];
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        comp.VerifyEmitDiagnostics(
            // (5,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = this[42];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "this[42]").WithArguments("E").WithLocation(5, 13),
            // (6,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = e[43];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "e[43]").WithArguments("E").WithLocation(6, 13));
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Instance_IndexerAccess_Array_AfterMemberFromExtension(bool isExplicit)
    {
        var source = $$"""
public {{(isExplicit ? "explicit" : "implicit")}} extension E for int[]
{
    public int this[int i] { get => throw null; }
    public void M(E e)
    {
        _ = this[42];
        _ = e[43];
    }
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        comp.VerifyEmitDiagnostics(
            // (6,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = this[42];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "this[42]").WithArguments("E").WithLocation(6, 13),
            // (7,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = e[43];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "e[43]").WithArguments("E").WithLocation(7, 13));
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Attribute(bool isExplicit)
    {
        var source = $$"""
public class C
{
    public class MyAttribute : System.Attribute { }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    [MyAttribute]
    public void M() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var myAttribute = GetSyntax<IdentifierNameSyntax>(tree, "MyAttribute");
        Assert.Equal("C.MyAttribute..ctor()", model.GetSymbolInfo(myAttribute).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Attribute_InaccessibleAttribute(bool isExplicit)
    {
        var source = $$"""
public class C
{
    private class PrivateAttribute : System.Attribute { }
}

public {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    [PrivateAttribute]
    public void M() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (8,6): error CS0122: 'C.PrivateAttribute' is inaccessible due to its protection level
            //     [PrivateAttribute]
            Diagnostic(ErrorCode.ERR_BadAccess, "PrivateAttribute").WithArguments("C.PrivateAttribute").WithLocation(8, 6)
            );
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Attribute_MissingAttribute(bool isExplicit)
    {
        var source = $$"""
public class C { }

public static {{(isExplicit ? "explicit" : "implicit")}} extension E for C
{
    [MissingAttribute]
    public static void M() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (5,6): error CS0246: The type or namespace name 'MissingAttributeAttribute' could not be found (are you missing a using directive or an assembly reference?)
            //     [MissingAttribute]
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "MissingAttribute").WithArguments("MissingAttributeAttribute").WithLocation(5, 6),
            // (5,6): error CS0246: The type or namespace name 'MissingAttribute' could not be found (are you missing a using directive or an assembly reference?)
            //     [MissingAttribute]
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "MissingAttribute").WithArguments("MissingAttribute").WithLocation(5, 6)
            );
    }

    [Fact]
    public void UnderlyingTypeMemberLookup_Instance_Invocation_InapplicableMember()
    {
        var source = """
public class C
{
    public void MInapplicable(int i) { }
}

public implicit extension E for C
{
    public void M(E e)
    {
        this.MInapplicable();
        e.MInapplicable();
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (10,14): error CS7036: There is no argument given that corresponds to the required parameter 'i' of 'C.MInapplicable(int)'
            //         this.MInapplicable();
            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "MInapplicable").WithArguments("i", "C.MInapplicable(int)").WithLocation(10, 14),
            // (11,11): error CS7036: There is no argument given that corresponds to the required parameter 'i' of 'C.MInapplicable(int)'
            //         e.MInapplicable();
            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "MInapplicable").WithArguments("i", "C.MInapplicable(int)").WithLocation(11, 11)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.MInapplicable()");
        Assert.Null(model.GetSymbolInfo(thisInvocation).Symbol);
        Assert.Empty(model.GetMemberGroup(thisInvocation)); // PROTOTYPE need to fix the semantic model

        var instanceInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.MInapplicable()");
        Assert.Null(model.GetSymbolInfo(instanceInvocation).Symbol);
        Assert.Empty(model.GetMemberGroup(instanceInvocation)); // PROTOTYPE need to fix the semantic model
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void UnderlyingTypeMemberLookup_Instance_Invocation_Overloads()
    {
        var source = """
//E e = new C();
//e.M(e);

public class C
{
    public void M2(int i) { System.Console.Write("C.M "); }
}

public implicit extension E for C
{
    public void M2(string s) { System.Console.Write("E.M "); }
    public void M(E e)
    {
        this.M2(42);
        e.M2(42);
        M2(42);

        this.M2("");
        e.M2("");
        M2("");
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
        //CompileAndVerify(comp, expectedOutput: "C.M C.M C.M E.M E.M E.M").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var thisIntInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2(42)");
        Assert.Equal("void C.M2(System.Int32 i)", model.GetSymbolInfo(thisIntInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisIntInvocation)); // PROTOTYPE need to fix the semantic model

        var instanceIntInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "e.M2(42)");
        Assert.Equal("void C.M2(System.Int32 i)", model.GetSymbolInfo(instanceIntInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceIntInvocation)); // PROTOTYPE need to fix the semantic model

        var simpleIntInvocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2(42)");
        Assert.Equal("void C.M2(System.Int32 i)", model.GetSymbolInfo(simpleIntInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleIntInvocation)); // PROTOTYPE need to fix the semantic model

        var thisStringInvocation = GetSyntax<InvocationExpressionSyntax>(tree, """this.M2("")""");
        Assert.Equal("void E.M2(System.String s)", model.GetSymbolInfo(thisStringInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(thisStringInvocation)); // PROTOTYPE need to fix the semantic model

        var instanceStringInvocation = GetSyntax<InvocationExpressionSyntax>(tree, """e.M2("")""");
        Assert.Equal("void E.M2(System.String s)", model.GetSymbolInfo(instanceStringInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(instanceStringInvocation)); // PROTOTYPE need to fix the semantic model

        var simpleStringInvocation = GetSyntax<InvocationExpressionSyntax>(tree, """M2("")""");
        Assert.Equal("void E.M2(System.String s)", model.GetSymbolInfo(simpleStringInvocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(simpleStringInvocation)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void UnderlyingTypeMemberLookup_Instance_IndexerAccess_Overloads()
    {
        var source = """
//E e = new C();
//e.M(e);

public class C
{
    public int this[int i] { get { return 42; } }
}

public implicit extension E for C
{
    public int this[string s] { get { return 43; } }
    public void M(E e)
    {
        _ = this[42];
        _ = this[""];
        _ = e[42];
        _ = e[""];
    }
}
""";
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (14,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = this[42];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "this[42]").WithArguments("E").WithLocation(14, 13),
            // (15,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = this[""];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, @"this[""""]").WithArguments("E").WithLocation(15, 13),
            // (16,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = e[42];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "e[42]").WithArguments("E").WithLocation(16, 13),
            // (17,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = e[""];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, @"e[""""]").WithArguments("E").WithLocation(17, 13)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        // PROTOTYPE need to fix the semantic model
        var thisIntIndexAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "this[42]");
        Assert.Null(model.GetSymbolInfo(thisIntIndexAccess).Symbol);

        var instanceIntIndexerAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "e[42]");
        Assert.Null(model.GetSymbolInfo(instanceIntIndexerAccess).Symbol);

        var thisStringIndexerAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, """this[""]""");
        Assert.Null(model.GetSymbolInfo(thisStringIndexerAccess).Symbol);

        var instanceStringIndexerAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, """e[""]""");
        Assert.Null(model.GetSymbolInfo(instanceStringIndexerAccess).Symbol);
    }

    [Theory, CombinatorialData]
    public void UnderlyingTypeMemberLookup_Attribute_FromOuterExtension(bool isExplicit)
    {
        var source = $$"""
static class C
{
    public class MyAttribute : System.Attribute { }
}

static {{(isExplicit ? "explicit" : "implicit")}} extension EOuter for C
{
    public static class D { }

    public static {{(isExplicit ? "explicit" : "implicit")}} extension EInner for D
    {
        [MyAttribute]
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void UnderlyingTypeMemberLookup_EnumerationGetEnumerator()
    {
        var source = """
using System.Collections.Generic;

public class C
{
    public IEnumerator<int> GetEnumerator() { yield return 42; }
}

public implicit extension E for C
{
    void M()
    {
        foreach (var x in this)
        {
            System.Console.Write(x);
            break;
        }
    }
}
""";
        try
        {
            Assert.True(new NoBaseExtensions().ShouldSkip);
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics();
            // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios

            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);
            var loop = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().Single();
            Assert.Equal("System.Collections.Generic.IEnumerator<System.Int32> C.GetEnumerator()",
                model.GetForEachStatementInfo(loop).GetEnumeratorMethod.ToTestDisplayString());
        }
        catch (System.InvalidOperationException) { }
    }

    [Fact]
    public void UnderlyingTypeMemberLookup_EnumerationMoveNext()
    {
        var source = """
public class C
{
    public bool MoveNext() => true;
}

public implicit extension E for C
{
    void M()
    {
        foreach (var x in this)
        {
            System.Console.Write(x);
            break;
        }
    }

    public E GetEnumerator() { return this; }
    public int Current => 42;
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE add support for iterating over collections of extension type
        comp.VerifyDiagnostics(
            // (10,27): error CS0202: foreach requires that the return type 'E' of 'E.GetEnumerator()' must have a suitable public 'MoveNext' method and public 'Current' property
            //         foreach (var x in this)
            Diagnostic(ErrorCode.ERR_BadGetEnumerator, "this").WithArguments("E", "E.GetEnumerator()").WithLocation(10, 27)
            );
    }

    [Fact]
    public void UnderlyingTypeMemberLookup_EnumerationCurrent()
    {
        var source = """
public class C
{
    public int Current => 42;
}

public implicit extension E for C
{
    void M()
    {
        foreach (var x in this)
        {
            System.Console.Write(x);
            break;
        }
    }

    public E GetEnumerator() { return this; }
    public bool MoveNext() => true;
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE add support for iterating over collections of extension type
        comp.VerifyDiagnostics(
            // (10,27): error CS0202: foreach requires that the return type 'E' of 'E.GetEnumerator()' must have a suitable public 'MoveNext' method and public 'Current' property
            //         foreach (var x in this)
            Diagnostic(ErrorCode.ERR_BadGetEnumerator, "this").WithArguments("E", "E.GetEnumerator()").WithLocation(10, 27)
            );
    }

    [Fact]
    public void UnderlyingTypeMemberLookup_ImplicitIndexIndexer()
    {
        var source = """
public class C
{
    public int this[int i] => 42;
}

public implicit extension E for C
{
    void M()
    {
        _ = this[^1];
    }

    public int Length => 2;
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        comp.VerifyDiagnostics(
            // (10,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = this[^1];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "this[^1]").WithArguments("E").WithLocation(10, 13)
            );
    }

    [Fact]
    public void UnderlyingTypeMemberLookup_ImplicitIndexIndexer_Length()
    {
        var source = """
public class C
{
    public int Length => 2;
}

public implicit extension E for C
{
    void M()
    {
        _ = this[^1];
    }

    public int this[int i] => 42;
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        comp.VerifyDiagnostics(
            // (10,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = this[^1];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "this[^1]").WithArguments("E").WithLocation(10, 13)
            );
    }

    [Fact]
    public void UnderlyingTypeMemberLookup_ImplicitIndexIndexer_Count()
    {
        var source = """
public class C
{
    public int Count => 2;
}

public implicit extension E for C
{
    void M()
    {
        _ = this[^1];
    }

    public int this[int i] => 42;
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        comp.VerifyDiagnostics(
            // (10,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = this[^1];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "this[^1]").WithArguments("E").WithLocation(10, 13)
            );
    }

    [Fact]
    public void UnderlyingTypeMemberLookup_ImplicitRangeIndexer_Slice()
    {
        var source = """
public class C
{
    public int Slice(int i, int j) => throw null;
}

public implicit extension E for C
{
    void M()
    {
        _ = this[1..^1];
    }

    public int Count => 2;
}
""";
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net70);
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        comp.VerifyDiagnostics(
            // (10,13): error CS0021: Cannot apply indexing with [] to an expression of type 'E'
            //         _ = this[1..^1];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "this[1..^1]").WithArguments("E").WithLocation(10, 13)
            );
    }

    [Fact]
    public void AttributeFromExtension()
    {
        var source = """
class C
{
    [MyAttribute] // 1, 2
    void M()
    {
        _ = Value; // 3
        _ = this.Value; // 4
        _ = C.Value;
    }

    [C.MyAttribute]
    void M2() { }
}

implicit extension E for C
{
    public static int Value = 42;
    public class MyAttribute : System.Attribute { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (3,6): error CS0246: The type or namespace name 'MyAttributeAttribute' could not be found (are you missing a using directive or an assembly reference?)
            //     [MyAttribute] // 1, 2
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "MyAttribute").WithArguments("MyAttributeAttribute").WithLocation(3, 6),
            // (3,6): error CS0246: The type or namespace name 'MyAttribute' could not be found (are you missing a using directive or an assembly reference?)
            //     [MyAttribute] // 1, 2
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "MyAttribute").WithArguments("MyAttribute").WithLocation(3, 6),
            // (6,13): error CS0103: The name 'Value' does not exist in the current context
            //         _ = Value; // 3
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Value").WithArguments("Value").WithLocation(6, 13),
            // (7,13): error CS0176: Member 'E.Value' cannot be accessed with an instance reference; qualify it with a type name instead
            //         _ = this.Value; // 4
            Diagnostic(ErrorCode.ERR_ObjectProhibited, "this.Value").WithArguments("E.Value").WithLocation(7, 13)
            );
    }

    [ConditionalTheory(typeof(NoBaseExtensions)), CombinatorialData]
    public void AttributeFromBaseExtension(bool isExplicit)
    {
        var source = $$"""
class C { }

{{(isExplicit ? "explicit" : "implicit")}} extension EBase for C
{
    public class MyAttribute : System.Attribute { }
}

{{(isExplicit ? "explicit" : "implicit")}} extension EDerived for C : EBase
{
    [MyAttribute]
    void M() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void NamedAttributeArgumentFromExtension()
    {
        var source = """
class C
{
    [MyAttribute(Property1 = 42, Property2 = 43)]
    void M() { }

    public int Property2 { get => throw null; set => throw null; }
}

public class MyAttribute : System.Attribute { }

public implicit extension E for MyAttribute
{
    public int Property1 { get => throw null; set => throw null; }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (3,18): error CS0246: The type or namespace name 'Property1' could not be found (are you missing a using directive or an assembly reference?)
            //     [MyAttribute(Property1 = 42, Property2 = 43)]
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Property1").WithArguments("Property1").WithLocation(3, 18),
            // (3,34): error CS0246: The type or namespace name 'Property2' could not be found (are you missing a using directive or an assembly reference?)
            //     [MyAttribute(Property1 = 42, Property2 = 43)]
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Property2").WithArguments("Property2").WithLocation(3, 34)
            );
    }

    [Fact]
    public void ExtensionForAttributeType()
    {
        var source = """
class C
{
    [E(Property1 = 42, Property2 = 43)]
    void M() { }
}

public class MyAttribute : System.Attribute
{
    public int Property2 { get => throw null; set => throw null; }
}

public implicit extension E for System.Attribute
{
    public int Property1 { get => throw null; set => throw null; }
}
""";
        // PROTOTYPE can an extension type be used in an attribute? if yes, we'll need to deal with erasure
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (3,6): error CS0616: 'E' is not an attribute class
            //     [E(Property1 = 42, Property2 = 43)]
            Diagnostic(ErrorCode.ERR_NotAnAttributeClass, "E").WithArguments("E").WithLocation(3, 6),
            // (3,24): error CS0246: The type or namespace name 'Property2' could not be found (are you missing a using directive or an assembly reference?)
            //     [E(Property1 = 42, Property2 = 43)]
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Property2").WithArguments("Property2").WithLocation(3, 24)
            );
    }

    [Fact]
    public void ExtensionAsAttributeType()
    {
        var source = """
class C
{
    [E(Property1 = 42)]
    void M() { }
}

public implicit extension E for System.Attribute
{
    public int Property1 { get => throw null; set => throw null; }
}
""";
        // PROTOTYPE can an extension type be used in an attribute?
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (3,6): error CS0616: 'E' is not an attribute class
            //     [E(Property1 = 42)]
            Diagnostic(ErrorCode.ERR_NotAnAttributeClass, "E").WithArguments("E").WithLocation(3, 6)
            );
    }

    [Fact]
    public void ParameterCapturing()
    {
        var source = """
public class C(int i)
{
    int M() => i;
    int M2() => j;
}

public implicit extension E for C
{
    public static int i;
    public static int j;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (4,17): error CS0103: The name 'j' does not exist in the current context
            //     int M2() => j;
            Diagnostic(ErrorCode.ERR_NameNotInContext, "j").WithArguments("j").WithLocation(4, 17)
            );
        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var i = GetSyntax<IdentifierNameSyntax>(tree, "i");
        Assert.Equal("System.Int32 i", model.GetSymbolInfo(i).Symbol.ToTestDisplayString());

        var j = GetSyntax<IdentifierNameSyntax>(tree, "j");
        Assert.Null(model.GetSymbolInfo(j).Symbol);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_EnumerationGetEnumerator()
    {
        var source = """
using System.Collections.Generic;

foreach (var x in new C())
{
    System.Console.Write(x);
}
public class C { }

public implicit extension E for C
{
    public IEnumerator<int> GetEnumerator()
    {
        yield return 42;
    }
}
""";
        // PROTOTYPE fix pattern-based lookup
        try
        {
            Assert.True(new NoBaseExtensions().ShouldSkip);
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics();
        }
        catch (System.IndexOutOfRangeException) { }
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_EnumerationCurrent()
    {
        var source = """
foreach (var x in new C())
{
    System.Console.Write(x);
    break;
}

public class C
{
    public class Enumerator
    {
        public bool MoveNext() => true;
    }

    public Enumerator GetEnumerator() => new Enumerator();
}

public implicit extension E for C.Enumerator
{
    public int Current => 42;
}
""";
        // PROTOTYPE fix pattern-based lookup
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,19): error CS0117: 'C.Enumerator' does not contain a definition for 'Current'
            // foreach (var x in new C())
            Diagnostic(ErrorCode.ERR_NoSuchMember, "new C()").WithArguments("C.Enumerator", "Current").WithLocation(1, 19),
            // (1,19): error CS0202: foreach requires that the return type 'C.Enumerator' of 'C.GetEnumerator()' must have a suitable public 'MoveNext' method and public 'Current' property
            // foreach (var x in new C())
            Diagnostic(ErrorCode.ERR_BadGetEnumerator, "new C()").WithArguments("C.Enumerator", "C.GetEnumerator()").WithLocation(1, 19)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_EnumerationMoveNext()
    {
        var source = """
foreach (var x in new C())
{
    System.Console.Write(x);
    break;
}

public class C
{
    public class Enumerator
    {
        public int Current => 42;
    }

    public Enumerator GetEnumerator() => new Enumerator();
}

public implicit extension E for C.Enumerator
{
    public bool MoveNext() => true;
}
""";
        // PROTOTYPE fix pattern-based lookup
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,19): error CS0117: 'C.Enumerator' does not contain a definition for 'MoveNext'
            // foreach (var x in new C())
            Diagnostic(ErrorCode.ERR_NoSuchMember, "new C()").WithArguments("C.Enumerator", "MoveNext").WithLocation(1, 19),
            // (1,19): error CS0202: foreach requires that the return type 'C.Enumerator' of 'C.GetEnumerator()' must have a suitable public 'MoveNext' method and public 'Current' property
            // foreach (var x in new C())
            Diagnostic(ErrorCode.ERR_BadGetEnumerator, "new C()").WithArguments("C.Enumerator", "C.GetEnumerator()").WithLocation(1, 19)
            );
    }

    [Fact]
    public void InferredVariable_Field_Static()
    {
        var src = """
var x = C.Field;
System.Console.Write(x);

class C { }

implicit extension E for C
{
    public static string Field = "hello";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hello").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Field");
        Assert.Equal("System.String x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void InferredVariable_Field_Static_BehindExtensionTypeMethod()
    {
        var src = """
implicit extension EOuter for object
{
    public static string M = null;
}

namespace Inner
{
    implicit extension EInner for object
    {
        public static void M() { System.Console.Write("ran"); }
    }

    class D
    {
        public static void Main()
        {
            var x = object.M;
            x();
        }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.M");
        Assert.Equal("System.Action x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("void Inner.EInner.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Property_Static()
    {
        var src = """
var x = C.Property;
System.Console.Write(x);

class C { }

implicit extension E for C
{
    public static string Property => "hello";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hello").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Property");
        Assert.Equal("System.String x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void InferredVariable_Method_Static()
    {
        var src = """
var x = C.Method;
System.Console.Write(x());

class C { }

implicit extension E for C
{
    public static string Method() => "ran";
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("ran"), verify: Verification.FailsPEVerify).VerifyDiagnostics();
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size       38 (0x26)
  .maxstack  2
  IL_0000:  ldsfld     "System.Func<string> Program.<>O.<0>__Method"
  IL_0005:  dup
  IL_0006:  brtrue.s   IL_001b
  IL_0008:  pop
  IL_0009:  ldnull
  IL_000a:  ldftn      "string E.Method()"
  IL_0010:  newobj     "System.Func<string>..ctor(object, nint)"
  IL_0015:  dup
  IL_0016:  stsfld     "System.Func<string> Program.<>O.<0>__Method"
  IL_001b:  callvirt   "string System.Func<string>.Invoke()"
  IL_0020:  call       "void System.Console.Write(string)"
  IL_0025:  ret
}
""");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Method");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Equal("System.String E.Method()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void InferredVariable_Method_Static_Generic()
    {
        var src = """
var x = C.Method<int>;
System.Console.Write(x());

class C { }

implicit extension E for C
{
    public static string Method<T>() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Method<int>");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method<int>");
        Assert.Equal("System.String E.Method<System.Int32>()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void InferredVariable_Method_Static_WrongArity()
    {
        var src = """
var x = C.Method<int>;

class C { }

implicit extension E for C
{
    public static string Method<T, U>() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,11): error CS0117: 'C' does not contain a definition for 'Method'
            // var x = C.Method<int>;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Method<int>").WithArguments("C", "Method").WithLocation(1, 11)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Method<int>");
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method<int>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Method_Static_WrongArity_FindExtensionTypeMethodFromOuterScope()
    {
        var src = """
implicit extension E2 for object
{
    public static string Method<T>() => "ran";
}

namespace Inner
{
    class C
    {
        public static void Main()
        {
            var x = C.Method<int>;
            System.Console.Write(x());
        }
    }

    implicit extension E1 for C
    {
        public static string Method<T, U>() => throw null;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Method<int>");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method<int>");
        Assert.Equal("System.String E2.Method<System.Int32>()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Method_Static_WrongArity_NoTypeArguments()
    {
        var src = """
var x = C.Method;

class C { }

implicit extension E for C
{
    public static string Method<T>() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS8917: The delegate type could not be inferred.
            // var x = C.Method;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "C.Method").WithLocation(1, 9)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Method");
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Method_Static_BrokenConstraint()
    {
        var src = """
var x = C.Method<object>;

class C { }

implicit extension E for C
{
    public static string Method<T>() where T : struct => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS8917: The delegate type could not be inferred.
            // var x = C.Method<object>;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "C.Method<object>").WithLocation(1, 9)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Method<object>");
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method<object>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Method_Static_TwoExtensionTypeMethods()
    {
        var src = """
var x = C.Method;

class C { }

implicit extension E1 for C
{
    public static string Method() => throw null;
}

implicit extension E2 for C
{
    public static string Method() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0121: The call is ambiguous between the following methods or properties: 'E1.Method()' and 'E2.Method()'
            // var x = C.Method;
            Diagnostic(ErrorCode.ERR_AmbigCall, "C.Method").WithArguments("E1.Method()", "E2.Method()").WithLocation(1, 9)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Method");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Static_WrongArityExtensionTypeMethodAndExtensionField_OuterField()
    {
        var src = """
implicit extension E2 for object
{
    public static string Member = null;
}

namespace Inner
{
    class C
    {
        public static void Main()
        {
            var x = object.Member;
            string s = object.Member;
        }
    }

    implicit extension E1 for object
    {
        public static string Member<T>() => throw null;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (12,21): error CS8917: The delegate type could not be inferred.
            //             var x = object.Member;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "object.Member").WithLocation(12, 21),
            // (13,31): error CS0428: Cannot convert method group 'Member' to non-delegate type 'string'. Did you intend to invoke the method?
            //             string s = object.Member;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "Member").WithArguments("Member", "string").WithLocation(13, 31)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member");
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.Member").First();
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess1));

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.Member").Last();
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess2));
    }

    [Fact]
    public void InferredVariable_Static_WrongArityExtensionTypeMethodAndExtensionField_OuterMethod()
    {
        var src = """
implicit extension E1 for object
{
    public static string Member<T>() => throw null;
}

namespace Inner
{
    class C
    {
        public static void Main()
        {
            var x = object.Member;
            System.Console.Write(x);
            string s = object.Member;
            System.Console.Write(s);
        }
    }

    implicit extension E2 for object
    {
        public static string Member = "ran ";
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member");
        Assert.Equal("System.String x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.Member").First();
        Assert.Equal("System.String Inner.E2.Member", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess1));

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.Member").Last();
        Assert.Equal("System.String Inner.E2.Member", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess2));
    }

    [Fact]
    public void InferredVariable_Static_WrongArityExtensionTypeMethodAndExtensionField_SameScope()
    {
        var src = """
var x = object.Member;

implicit extension E1 for object
{
    public static string Member<T>() => throw null;
}

implicit extension E2 for object
{
    public static string Member = null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,16): error CS0229: Ambiguity between 'E2.Member' and 'E1.Member<T>()'
            // var x = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E2.Member", "E1.Member<T>()").WithLocation(1, 16));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member");
        Assert.Equal("E2.Member x", model.GetDeclaredSymbol(x).ToTestDisplayString());
        Assert.True(((ILocalSymbol)model.GetDeclaredSymbol(x)).Type.IsErrorType());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Member");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Static_WrongArityInstanceMethodAndExtensionField()
    {
        var src = """
var x = C.Member;
string s = C.Member;

implicit extension E2 for object
{
    public static string Member = null;
}

class C
{
    public static string Member<T>() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,9): error CS8917: The delegate type could not be inferred.
            // var x = C.Member;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "C.Member").WithLocation(1, 9),
            // (2,14): error CS0428: Cannot convert method group 'Member' to non-delegate type 'string'. Did you intend to invoke the method?
            // string s = C.Member;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "Member").WithArguments("Member", "string").WithLocation(2, 14)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Member");
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.Member").First();
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Equal(["System.String C.Member<T>()"], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.Member").Last();
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Equal(["System.String C.Member<T>()"], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void InferredVariable_Static_WrongArityInstanceMethodAndBaseField()
    {
        var src = """
var x = C.Member;
string s = C.Member;

class Base
{
    public static string Member = null;
}

class C : Base
{
    public static new string Member<T>() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,9): error CS8917: The delegate type could not be inferred.
            // var x = C.Member;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "C.Member").WithLocation(1, 9),
            // (2,14): error CS0428: Cannot convert method group 'Member' to non-delegate type 'string'. Did you intend to invoke the method?
            // string s = C.Member;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "Member").WithArguments("Member", "string").WithLocation(2, 14));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Member");
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.Member").First();
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Equal(["System.String C.Member<T>()"], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.Member").Last();
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Equal(["System.String C.Member<T>()"], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void InferredVariable_Static_WrongArityInstanceMethodAndExtensionTypeMethod()
    {
        var src = """
implicit extension E2 for object
{
    public static string Member() { return "ran "; }
}

class C
{
    public static void Main()
    {
        var x = C.Member;
        System.Console.Write(x());
        System.Func<string> f = C.Member;
        System.Console.Write(f());
    }

    public static string Member<T>() => throw null;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Member");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.Member").First();
        Assert.Equal("System.String E2.Member()", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal(["System.String C.Member<T>()"], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.Member").Last();
        Assert.Equal("System.String E2.Member()", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal(["System.String C.Member<T>()"], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void InferredVariable_Instance_WrongArityInstanceMethodAndExtensionMethod()
    {
        var src = """
static class E
{
    public static string Member(this object o) => "ran ";
}

class C
{
    public static void Main()
    {
        var x = new C().Member;
        System.Console.Write(x());
        System.Func<string> f = new C().Member;
        System.Console.Write(f());
    }

    public string Member<T>() => throw null;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = new C().Member");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new C().Member").First();
        Assert.Equal("System.String System.Object.Member()", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal(["System.String C.Member<T>()", "System.String System.Object.Member()"],
            model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new C().Member").Last();
        Assert.Equal("System.String System.Object.Member()", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal(["System.String C.Member<T>()", "System.String System.Object.Member()"],
            model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void InferredVariable_Static_ExtensionTypeMethodAndExtensionField_SameScope()
    {
        var src = """
var x = object.Member;
System.Func<string> y = object.Member;

implicit extension E1 for object
{
    public static string Member() => throw null;
}

implicit extension E2 for object
{
    public static string Member = null;
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (1,16): error CS0229: Ambiguity between 'E2.Member' and 'E1.Member()'
            // var x = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E2.Member", "E1.Member()").WithLocation(1, 16),
            // (2,32): error CS0229: Ambiguity between 'E2.Member' and 'E1.Member()'
            // System.Func<string> y = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E2.Member", "E1.Member()").WithLocation(2, 32));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member");
        Assert.Equal("E2.Member x", model.GetDeclaredSymbol(x).ToTestDisplayString());
        Assert.True(((ILocalSymbol)model.GetDeclaredSymbol(x)).Type.IsErrorType());

        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.Member").First();
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(CandidateReason.Ambiguous, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Equal(["System.String E2.Member", "System.String E1.Member()"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));

        src = """
var x = I.M;

interface I1 { static string M() => null; }
interface I2 { static int M = 0;   }
interface I : I1, I2 { }
""";
        comp = CreateCompilation(src, targetFramework: TargetFramework.Net70).VerifyDiagnostics();

        tree = comp.SyntaxTrees.Single();
        model = comp.GetSemanticModel(tree);
        x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = I.M");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "I.M").First();
        Assert.Equal("System.String I1.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["System.String I1.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InferredVariable_Static_ExtensionTypeMethodAndExtensionField_SameScope_Discard()
    {
        var src = """
_ = object.Member;

implicit extension E1 for object
{
    public static string Member() => "ran ";
}

implicit extension E2 for object
{
    public static string Member = null;
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (1,12): error CS0229: Ambiguity between 'E2.Member' and 'E1.Member()'
            // _ = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E2.Member", "E1.Member()").WithLocation(1, 12));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Member");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));

        src = """
_ = I.M;

interface I1 { static string M() => null; }
interface I2 { static int M = 0;   }
interface I : I1, I2 { }
""";
        CreateCompilation(src, targetFramework: TargetFramework.Net70).VerifyDiagnostics(
            // (1,1): error CS8183: Cannot infer the type of implicitly-typed discard.
            // _ = I.M;
            Diagnostic(ErrorCode.ERR_DiscardTypeInferenceFailed, "_").WithLocation(1, 1));
    }

    [Fact]
    public void InferredVariable_Static_ExtensionTypeMethodAndExtensionField_SameScope_ReverseOrder()
    {
        var src = """
var x = object.Member;
System.Func<string> y = object.Member;

implicit extension E2 for object
{
    public static string Member = null;
}

implicit extension E1 for object
{
    public static string Member() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,16): error CS0229: Ambiguity between 'E2.Member' and 'E1.Member()'
            // var x = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E2.Member", "E1.Member()").WithLocation(1, 16),
            // (2,32): error CS0229: Ambiguity between 'E2.Member' and 'E1.Member()'
            // System.Func<string> y = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E2.Member", "E1.Member()").WithLocation(2, 32));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member");
        Assert.Equal("E2.Member x", model.GetDeclaredSymbol(x).ToTestDisplayString());
        Assert.True(((ILocalSymbol)model.GetDeclaredSymbol(x)).Type.IsErrorType());

        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.Member").First();
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Equal(CandidateReason.Ambiguous, model.GetSymbolInfo(memberAccess1).CandidateReason);
        Assert.Equal(["System.String E2.Member", "System.String E1.Member()"],
            model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess1));

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.Member").Last();
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Equal(CandidateReason.Ambiguous, model.GetSymbolInfo(memberAccess2).CandidateReason);
        Assert.Equal(["System.String E2.Member", "System.String E1.Member()"],
            model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess2));
    }

    [Fact]
    public void InferredVariable_Static_ExtensionTypeMethodAndBaseExtensionField_SameScope()
    {
        var src = """
var x = int.Member;
System.Console.Write(x());

System.Func<string> y = int.Member;
System.Console.Write(y());

implicit extension E1 for int
{
    public static string Member() => "ran ";
}

implicit extension E2 for object
{
    public static string Member = null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = int.Member");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "int.Member").First();
        Assert.Equal("System.String E1.Member()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void InferredVariable_Static_ExtensionTypePropertyAndExtensionField_SameScope()
    {
        var src = """
var x = object.Member;
string y = object.Member;

implicit extension E1 for object
{
    public static string Member => null;
}

implicit extension E2 for object
{
    public static string Member = null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,16): error CS0229: Ambiguity between 'E2.Member' and 'E1.Member'
            // var x = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E2.Member", "E1.Member").WithLocation(1, 16),
            // (2,19): error CS0229: Ambiguity between 'E2.Member' and 'E1.Member'
            // string y = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E2.Member", "E1.Member").WithLocation(2, 19));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member");
        Assert.Equal("E2.Member x", model.GetDeclaredSymbol(x).ToTestDisplayString());
        Assert.True(((ILocalSymbol)model.GetDeclaredSymbol(x)).Type.IsErrorType());

        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.Member").First();
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Static_ExtensionTypeMethodAndExtensionProperty_SameScope()
    {
        var src = """
var x = object.Member;
System.Func<string> y = object.Member;

implicit extension E1 for object
{
    public static string Member() => "ran ";
}

implicit extension E2 for object
{
    public static string Member => null;
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (1,16): error CS0229: Ambiguity between 'E1.Member()' and 'E2.Member'
            // var x = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E1.Member()", "E2.Member").WithLocation(1, 16),
            // (2,32): error CS0229: Ambiguity between 'E1.Member()' and 'E2.Member'
            // System.Func<string> y = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E1.Member()", "E2.Member").WithLocation(2, 32));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member");
        Assert.Equal("E1.Member x", model.GetDeclaredSymbol(x).ToTestDisplayString());
        Assert.True(((ILocalSymbol)model.GetDeclaredSymbol(x)).Type.IsErrorType());

        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.Member").First();
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(CandidateReason.Ambiguous, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Equal(["System.String E1.Member()", "System.String E2.Member { get; }"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));

        src = """
var x = I.P;
x();
System.Action y = I.P;

interface I1 { static void P() { } }
interface I2 { static int P => 0;   }
interface I : I1, I2 { }
""";
        CreateCompilation(src, targetFramework: TargetFramework.Net70).VerifyDiagnostics();
    }

    [Fact]
    public void InferredVariable_Static_ExtensionFieldAndExtensionField_SameScope()
    {
        var src = """
var x = object.Member;

implicit extension E1 for object
{
    public static string Member = null;
}

implicit extension E2 for object
{
    public static string Member = null;
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (1,16): error CS0229: Ambiguity between 'E1.Member' and 'E2.Member'
            // var x = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E1.Member", "E2.Member").WithLocation(1, 16)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member");
        Assert.Equal("E1.Member x", model.GetDeclaredSymbol(x).ToTestDisplayString());
        Assert.True(((ILocalSymbol)model.GetDeclaredSymbol(x)).Type.IsErrorType());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Member");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));

        src = """
var x = I.P;
_ = I.P;

interface I1 { static string P = null; }
interface I2 { static int P = 0;   }
interface I : I1, I2 { }
""";
        comp = CreateCompilation(src, targetFramework: TargetFramework.Net70).VerifyDiagnostics(
            // (1,11): error CS0229: Ambiguity between 'I1.P' and 'I2.P'
            // var x = I.P;
            Diagnostic(ErrorCode.ERR_AmbigMember, "P").WithArguments("I1.P", "I2.P").WithLocation(1, 11),
            // (2,7): error CS0229: Ambiguity between 'I1.P' and 'I2.P'
            // _ = I.P;
            Diagnostic(ErrorCode.ERR_AmbigMember, "P").WithArguments("I1.P", "I2.P").WithLocation(2, 7)
            );

        tree = comp.SyntaxTrees.Single();
        model = comp.GetSemanticModel(tree);
        x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = I.P");
        Assert.Equal("I1.P x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "I.P").First();
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Static_ExtensionPropertyAndExtensionField_SameScope()
    {
        var src = """
var x = object.Member;

implicit extension E1 for object
{
    public static string Member => null;
}

implicit extension E2 for object
{
    public static string Member = null;
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (1,16): error CS0229: Ambiguity between 'E2.Member' and 'E1.Member'
            // var x = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E2.Member", "E1.Member").WithLocation(1, 16));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member");
        Assert.Equal("E2.Member x", model.GetDeclaredSymbol(x).ToTestDisplayString());
        Assert.True(((ILocalSymbol)model.GetDeclaredSymbol(x)).Type.IsErrorType());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Member");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));

        src = """
var x = I.P;
_ = I.P;

interface I1 { static string P => null; }
interface I2 { static int P = 0;   }
interface I : I1, I2 { }
""";
        comp = CreateCompilation(src, targetFramework: TargetFramework.Net70).VerifyDiagnostics(
            // (1,11): error CS0229: Ambiguity between 'I2.P' and 'I1.P'
            // var x = I.P;
            Diagnostic(ErrorCode.ERR_AmbigMember, "P").WithArguments("I2.P", "I1.P").WithLocation(1, 11),
            // (2,7): error CS0229: Ambiguity between 'I2.P' and 'I1.P'
            // _ = I.P;
            Diagnostic(ErrorCode.ERR_AmbigMember, "P").WithArguments("I2.P", "I1.P").WithLocation(2, 7));

        tree = comp.SyntaxTrees.Single();
        model = comp.GetSemanticModel(tree);
        x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = I.P");
        Assert.Equal("I2.P x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "I.P").First();
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Static_ExtensionPropertyAndExtensionField_SameScope_DifferentFiles()
    {
        var src1 = """
var x = object.Member;
System.Console.Write("ran");

implicit extension E1 for object
{
    public static string Member => "ran";
}
""";

        var src2 = """
file implicit extension E2 for object
{
    public static string Member = null;
}
""";
        var comp = CreateCompilation([(src1, "1.cs"), (src2, "2.cs")]);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member");
        Assert.Equal("System.String x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Member");
        Assert.Equal("System.String E1.Member { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));

        comp = CreateCompilation(src1 + src2);
        comp.VerifyDiagnostics(
            // (1,16): error CS0229: Ambiguity between 'E2.Member' and 'E1.Member'
            // var x = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E2.Member", "E1.Member").WithLocation(1, 16)
            );
    }

    [Fact]
    public void InferredVariable_Static_ExtensionFieldAndExtensionField_SameScope_DifferentTypes()
    {
        var src = """
var x = object.Member;

implicit extension E1 for object
{
    public static int Member = 0;
}

implicit extension E2 for object
{
    public static string Member = null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,16): error CS0229: Ambiguity between 'E1.Member' and 'E2.Member'
            // var x = object.Member;
            Diagnostic(ErrorCode.ERR_AmbigMember, "Member").WithArguments("E1.Member", "E2.Member").WithLocation(1, 16)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member");
        Assert.Equal("E1.Member x", model.GetDeclaredSymbol(x).ToTestDisplayString());
        Assert.True(((ILocalSymbol)model.GetDeclaredSymbol(x)).Type.IsErrorType());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Member");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Static_WrongArityInstanceMethodHidesExtensionField()
    {
        var src = """
class C
{
    public static void Main()
    {
        var x = C.Member;
        System.Console.Write(x);
    }

    public static string Member<T>() => throw null;
}

implicit extension E for C
{
    public static string Member = "ran";
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics(
            // (5,17): error CS8917: The delegate type could not be inferred.
            //         var x = C.Member;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "C.Member").WithLocation(5, 17)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Member");
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Member");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String C.Member<T>()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InferredVariable_Static_WrongArityFieldSkippedForOuterExtensionTypeMethod()
    {
        var src = """
implicit extension E2 for object
{
    public static string Member<T>() => "ran";
}

namespace Inner
{
    class C
    {
        public static void Main()
        {
            var x = object.Member<int>;
            System.Console.Write(x());
        }
    }

    implicit extension E2 for object
    {
        public static string Member = "";
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member<int>");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Member<int>");
        Assert.Equal("System.String E2.Member<System.Int32>()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Static_WrongArityExtensionTypeMethodSkippedForOuterExtensionTypeMethod()
    {
        var src = """
implicit extension E2 for object
{
    public static string Member<T>() => "ran";
}

namespace Inner
{
    class C
    {
        public static void Main()
        {
            var x = object.Member<int>;
            System.Console.Write(x());
        }
    }

    implicit extension E2 for object
    {
        public static string Member() => throw null;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = object.Member<int>");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Member<int>");
        Assert.Equal("System.String E2.Member<System.Int32>()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InvalidMemberDeclaration()
    {
        var src = """
implicit extension E for object
{
    public static string Member() => throw null;;
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE consider updating error message
        comp.VerifyDiagnostics(
            // (3,49): error CS1519: Invalid token ';' in class, record, struct, or interface member declaration
            //     public static string Member() => throw null;;
            Diagnostic(ErrorCode.ERR_InvalidMemberDecl, ";").WithArguments(";").WithLocation(3, 49));
    }

    [Fact]
    public void ExtensionMemberLookup_Static_BrokenConstraintMethodHidesOuterExtensionType()
    {
        var src = """
implicit extension E2 for object
{
    public static class Member<T>
    {
        public static void M() => throw null;
    }
}

namespace Inner
{
    class C
    {
        public static void Main()
        {
            C.Member<object>.M();
        }
    }

    implicit extension E1 for C
    {
        public static string Member<T>() where T : struct => throw null;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (15,15): error CS0119: 'E1.Member<T>()' is a method, which is not valid in the given context
            //             C.Member<object>.M();
            Diagnostic(ErrorCode.ERR_BadSKunknown, "Member<object>").WithArguments("Inner.E1.Member<T>()", "method").WithLocation(15, 15)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Member<object>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void Nameof_Static_Method()
    {
        var src = """
System.Console.Write(nameof(C.Method));

class C { }

implicit extension E for C
{
    public static string Method() => throw null;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void Nameof_Static_WrongArityMethod()
    {
        var src = """
System.Console.Write(nameof(C.Method));

class C { }

implicit extension E for C
{
    public static string Method<T>() => throw null;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void Nameof_Static_GenericType()
    {
        var src = """
_ = nameof(object.Nested<string>);
_ = nameof(E.Nested<string>);

implicit extension E for object
{
    public static class Nested<U> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Nested<string>");
        Assert.Equal("E.Nested<System.String>", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InferredVariable_Static_InnerExtensionField()
    {
        var src = """
implicit extension E1 for object
{
    public static string Field() => throw null;
}

namespace Inner
{
    class C
    {
        public static void Main()
        {
            var x = C.Field;
            System.Console.Write(x);
        }
    }

    implicit extension E2 for C
    {
        public static string Field = "ran";
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.Field");
        Assert.Equal("System.String x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Field");
        Assert.Equal("System.String Inner.E2.Field", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Static_Field_Underlying()
    {
        var src = """
var x = E.Field;
System.Console.Write(x);

class C
{
    public static string Field = "ran";
}

implicit extension E for C { }
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = E.Field");
        Assert.Equal("System.String x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Field");
        Assert.Equal("System.String C.Field", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Static_Field_Underlying_AfterMemberFromExtension()
    {
        var src = """
var x = E.Field;
System.Console.Write(x);

class C { }

implicit extension E for C
{
    public static string Field = "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = E.Field");
        Assert.Equal("System.String x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.Field");
        Assert.Equal("System.String E.Field", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Static_Method_Underlying()
    {
        var src = """
var x = E.M;
System.Console.Write(x());

class C
{
    public static string M() => "ran";
}

implicit extension E for C { }
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = E.M");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.M");
        Assert.Equal("System.String C.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["System.String C.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InferredVariable_Static_ExtensionMethodOnUnderlying_WithInapplicableInstanceMethod()
    {
        var src = """
var x = E1.M;
System.Console.Write(x());

class C
{
    public static int M<T>() => throw null;
}

implicit extension E1 for C { }

implicit extension E2 for C
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = E1.M");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E1.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        // PROTOTYPE need to fix the semantic model
        Assert.Equal(["System.Int32 C.M<T>()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InferredVariable_Static_ExtensionFieldOnUnderlying()
    {
        var src = """
var x = E1.Member;
System.Console.Write(x);

class C { }

implicit extension E1 for C { }

implicit extension E2 for C
{
    public static string Member = "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = E1.Member");
        Assert.Equal("System.String x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E1.Member");
        Assert.Equal("System.String E2.Member", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InferredVariable_Static_ExtensionFieldOnUnderlying_SimpleName()
    {
        var src = """
class C { }

implicit extension E1 for C 
{ 
    void M()
    {
        var x = Member;
        var s = Member;
    }
}

implicit extension E2 for C
{
    public static string Member = "";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (7,17): error CS0103: The name 'Member' does not exist in the current context
            //         var x = Member;
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Member").WithArguments("Member").WithLocation(7, 17),
            // (8,17): error CS0103: The name 'Member' does not exist in the current context
            //         var s = Member;
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Member").WithArguments("Member").WithLocation(8, 17));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = Member");
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var s = GetSyntax<VariableDeclaratorSyntax>(tree, "s = Member");
        Assert.Equal("? s", model.GetDeclaredSymbol(s).ToTestDisplayString());
    }

    [Fact]
    public void InferredVariable_Static_FieldOnUnderlying_WithInapplicableInstanceMethod()
    {
        var src = """
var x = E1.Member;

class C
{
    public static int Member<T>() => throw null;
}

implicit extension E1 for C { }

implicit extension E2 for C
{
    public static string Member = "";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,9): error CS8917: The delegate type could not be inferred.
            // var x = E1.Member;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "E1.Member").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = E1.Member");
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E1.Member");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 C.Member<T>()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InferredVariable_Instance_ExtensionMethodOnUnderlying_WithInapplicableInstanceMethod()
    {
        var src = """
class C
{
    public void Method(E1 e)
    {
        var x = e.M;
        x();
    }

    public int M<T>() => throw null;
}

implicit extension E1 for C { }

implicit extension E2 for C
{
    public string M() => "ran";
}
""";
        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
        //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = e.M");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "e.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        // PROTOTYPE need to fix the semantic model
        Assert.Equal(["System.Int32 C.M<T>()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        var src2 = """
var x = new Derived().M;
System.Console.Write(x());

class Base
{
    public int M<T>() => throw null;
}

class Derived : Base { }

static class E2
{
    public static string M(this Base b) => "ran";
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2, expectedOutput: "ran").VerifyDiagnostics();

        var tree2 = comp2.SyntaxTrees.Single();
        var model2 = comp2.GetSemanticModel(tree2);
        var x2 = GetSyntax<VariableDeclaratorSyntax>(tree2, "x = new Derived().M");
        Assert.Equal("System.Func<System.String> x", model2.GetDeclaredSymbol(x2).ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree2, "new Derived().M");
        Assert.Equal("System.String Base.M()", model2.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal(["System.Int32 Base.M<T>()", "System.String Base.M()"],
            model2.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void InferredVariable_Instance_Method_ExtensionMethodOnUnderlying_WithInapplicableInstanceMethod()
    {
        var src = """
class C
{
    public void Method(E1 e)
    {
        var x = e.M;
    }

    public static int M<T>() => throw null;
}

implicit extension E1 for C { }

static class E2
{
    public static string M(this C c) => "ran";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,17): error CS0411: The type arguments for method 'C.M<T>()' cannot be inferred from the usage. Try specifying the type arguments explicitly.
            //         var x = e.M;
            Diagnostic(ErrorCode.ERR_CantInferMethTypeArgs, "e.M").WithArguments("C.M<T>()").WithLocation(5, 17));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = e.M");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "e.M");
        // PROTOTYPE need to bind and emit an extension method on a receiver of an extension type
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        // PROTOTYPE need to fix the semantic model
        Assert.Equal(["System.Int32 C.M<T>()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        var src2 = """
var x = new Derived().M;
System.Console.Write(x());

class Base
{
    public int M<T>() => throw null;
}

class Derived : Base { }

static class E2
{
    public static string M(this Base b) => "ran";
}
""";
        var comp2 = CreateCompilation(src2);
        comp2.VerifyDiagnostics();
        CompileAndVerify(comp2, expectedOutput: "ran").VerifyDiagnostics();

        var tree2 = comp2.SyntaxTrees.Single();
        var model2 = comp2.GetSemanticModel(tree2);
        var x2 = GetSyntax<VariableDeclaratorSyntax>(tree2, "x = new Derived().M");
        Assert.Equal("System.Func<System.String> x", model2.GetDeclaredSymbol(x2).ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree2, "new Derived().M");
        Assert.Equal("System.String Base.M()", model2.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal(["System.Int32 Base.M<T>()", "System.String Base.M()"],
            model2.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void InferredVariable_Instance_ExtensionMethodOnUnderlying()
    {
        var src = """
class C
{
    public void Method(E1 e)
    {
        var x = e.M;
        x();
    }
}

implicit extension E1 for C { }

static class E2
{
    public static string M(this C c) => "ran";
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE need to bind and emit an extension method on a receiver of an extension type
        comp.VerifyDiagnostics(
            // (5,19): error CS1061: 'E1' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'E1' could be found (are you missing a using directive or an assembly reference?)
            //         var x = e.M;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("E1", "M").WithLocation(5, 19));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = e.M");
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "e.M");
        // PROTOTYPE need to fix the semantic model
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        var src2 = """
var x = new Derived().M;
System.Console.Write(x());

class Base { }

class Derived : Base { }

static class E2
{
    public static string M(this Base b) => "ran";
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2, expectedOutput: "ran").VerifyDiagnostics();

        var tree2 = comp2.SyntaxTrees.Single();
        var model2 = comp2.GetSemanticModel(tree2);
        var x2 = GetSyntax<VariableDeclaratorSyntax>(tree2, "x = new Derived().M");
        Assert.Equal("System.Func<System.String> x", model2.GetDeclaredSymbol(x2).ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree2, "new Derived().M");
        Assert.Equal("System.String Base.M()", model2.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal(["System.String Base.M()"], model2.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void ExtensionMemberLookup_TypeOnlyContext_ExtensionTypeOnUnderlying_NonGeneric()
    {
        var src = """
public class C
{
    public void Method(E1.Nested e) { }
}

public explicit extension E1 for C { }

public implicit extension E2 for C
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var e1Nested = GetSyntax<QualifiedNameSyntax>(tree, "E1.Nested");
        Assert.Equal("E2.Nested", model.GetSymbolInfo(e1Nested).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_TypeOnlyContext_ExtensionTypeOnUnderlying_Generic()
    {
        var src = """
class C
{
    public void Method(E1.Nested<int> e) { }
}

explicit extension E1 for C { }

implicit extension E2 for C
{
    public class Nested<T> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var e1Nested = GetSyntax<QualifiedNameSyntax>(tree, "E1.Nested<int>");
        Assert.Equal("E2.Nested<System.Int32>", model.GetSymbolInfo(e1Nested).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InferredVariable_TypeReceiver_StaticMethod_Overloads()
    {
        var src = """
class C
{
    void M()
    {
        var x = C.Method;
    }
}

implicit extension E for C
{
    public static string Method() => throw null;
    public static string Method(int i) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,17): error CS8917: The delegate type could not be inferred.
            //         var x = C.Method;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "C.Method").WithLocation(5, 17)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();
        Assert.Equal("? x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void InferredVariable_Method_ValueReceiver_ExtensionMethodAndExtensionTypeMethod()
    {
        // Extension type members are considered first, and separately from extension methods
        // for purposes of determining the function type and converting to that inferred delegate type
        // PROTOTYPE we'll want to consider extension type members and extension methods together, within a given scope, instead.
        var src = """
var x = new C().Method;
System.Console.Write(x());

class C { }

implicit extension E1 for C
{
    public string Method() => "ran";
}

static class E2
{
    public static string Method(this C c) => throw null;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = new C().Method");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().Method");
        Assert.Equal("System.String E1.Method()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["System.String C.Method()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void InferredVariable_ValueReceiver_ExtensionMethodAndExtensionTypeMethod_DifferentSignatures()
    {
        var src = """
var x = new C().Method;
System.Console.Write(x());

class C { }

implicit extension E1 for C
{
    public string Method() => "ran";
}

static class E2
{
    public static string Method(this C c, int i) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = new C().Method");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().Method");
        Assert.Equal("System.String E1.Method()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["System.String C.Method(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void InferredVariable_ValueReceiver_GenericExtensionMethod()
    {
        var src = """

class C 
{ 
    void M(E e)
    {
        var x = e.Method;
        System.Console.Write(x());

        e.Method();
    }
}

implicit extension E for C { }

static class E2
{
    public static string Method<T>(this T t) => throw null;
}
""";
        // PROTOTYPE(instance) It should be possible to create this delegate as long as we can create it on the extended type
        // PROTOTYPE(instance) We should be binding to the underlying type, not the extension type
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (6,17): error CS1113: Extension method 'E2.Method<E>(E)' defined on value type 'E' cannot be used to create delegates
            //         var x = e.Method;
            Diagnostic(ErrorCode.ERR_ValueTypeExtDelegate, "e.Method").WithArguments("E2.Method<E>(E)", "E").WithLocation(6, 17));
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = e.Method");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "e.Method").First();
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Equal(["System.String E.Method<E>()"], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "e.Method").Last();
        Assert.Equal("System.String E.Method<E>()", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal(["System.String E.Method<E>()"], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void PreferMoreSpecific_Static_FieldAndField()
    {
        var src = """
System.Console.Write(object.M);

implicit extension E1 for object
{
    public static string M = null;
}

implicit extension E2 for object
{
    public static string M = null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,29): error CS0229: Ambiguity between 'E1.M' and 'E2.M'
            // System.Console.Write(object.M);
            Diagnostic(ErrorCode.ERR_AmbigMember, "M").WithArguments("E1.M", "E2.M").WithLocation(1, 29));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void PreferMoreSpecific_Static_FieldAndMoreSpecificField()
    {
        var src = """
System.Console.Write(C.M);

class C { }

implicit extension E1 for object
{
    public static string M = null;
}

implicit extension E2 for C
{
    public static string M = "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E2.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void PreferMoreSpecific_Static_PropertyAndProperty()
    {
        var src = """
System.Console.Write(object.M);

implicit extension E1 for object
{
    public static string M => null;
}

implicit extension E2 for object
{
    public static string M => null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,29): error CS0229: Ambiguity between 'E1.M' and 'E2.M'
            // System.Console.Write(object.M);
            Diagnostic(ErrorCode.ERR_AmbigMember, "M").WithArguments("E1.M", "E2.M").WithLocation(1, 29));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndProperty()
    {
        var src = """
System.Console.Write(object.M);

implicit extension E1 for object
{
    public static string M() => throw null;
}

implicit extension E2 for object
{
    public static string M => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,29): error CS0229: Ambiguity between 'E1.M()' and 'E2.M'
            // System.Console.Write(object.M);
            Diagnostic(ErrorCode.ERR_AmbigMember, "M").WithArguments("E1.M()", "E2.M").WithLocation(1, 29));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E1.M()", "System.String E2.M { get; }"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndProperty_Invocation()
    {
        var src = """
System.Console.Write(object.M());

implicit extension E1 for object
{
    public static string M() => "ran";
}

implicit extension E2 for object
{
    public static string M => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E1.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Instance_PropertyAndMoreSpecificProperty_OnArray()
    {
        var src = """
class C
{
    void M(int[] i)
    {
        System.Console.Write(i.M);
    }
}

implicit extension E1 for object
{
    public string M => null;
}

implicit extension E2 for int[]
{
    public string M => "ran";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once we can lower/emit for non-static scenarios

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "i.M");
        Assert.Equal("System.String E2.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificMethod_OnStruct()
    {
        var src = """
System.Console.Write(S.M());

struct S { }

implicit extension E1 for System.ValueType
{
    public static string M() => throw null;
}

implicit extension E2 for S
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "S.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificMethod_DifferentSignatures_OnStruct()
    {
        var src = """
System.Console.Write(S.M(42));

struct S { }

implicit extension E1 for System.ValueType
{
    public static string M(int i) => "ran";
}

implicit extension E2 for S
{
    public static string M() => throw null;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "S.M");
        Assert.Equal("System.String E1.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificMethod_OnEnum()
    {
        var src = """
System.Console.Write(E.M());

enum E { }

implicit extension E1 for System.Enum
{
    public static string M() => throw null;
}

implicit extension E2 for E
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificMethod_OnEnum_OnEnumUnderlying()
    {
        var src = """
System.Console.Write(E.M());

enum E { }

implicit extension E1 for int
{
    public static string M() => throw null;
}

implicit extension E2 for E
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE(static) we need a preference for more specific extension methods during overload resolution
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Instance_MethodAndMoreSpecificMethod_OnArray()
    {
        var src = """
int[] i = [1, 2];
System.Console.Write(i.M());

class C { }

implicit extension E1 for object
{
    public string M() => throw null;
}

implicit extension E2 for int[]
{
    public string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "i.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificMethod()
    {
        var src = """
System.Console.Write(C.M());

class C { }

implicit extension E1 for object
{
    public static string M() => throw null;
}

implicit extension E2 for C
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificMethod_OnInterface()
    {
        var src = """
System.Console.Write(I2.M());

interface I1 { }
interface I2 : I1 { }

implicit extension E1 for I1
{
    public static string M() => throw null;
}

implicit extension E2 for I2
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "I2.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_InterfaceMethodAndMoreSpecificMethod()
    {
        var src = """
System.Console.Write(C.M());

interface I { }
class C : I { }

implicit extension E1 for I
{
    public static string M() => throw null;
}

implicit extension E2 for C
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_ValueTypeMethodAndMoreSpecificMethod_OnStruct()
    {
        var src = """
System.Console.Write(S.M());

struct S { }

implicit extension E1 for System.ValueType
{
    public static string M() => throw null;
}

implicit extension E2 for S
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "S.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_ObjectMethodAndMoreSpecificMethod_OnStruct()
    {
        var src = """
System.Console.Write(S.M());

struct S { }

implicit extension E1 for object
{
    public static string M() => throw null;
}

implicit extension E2 for S
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "S.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_ObjectMethodAndValueTypeMethod_OnStruct()
    {
        var src = """
System.Console.Write(S.M());

struct S { }

implicit extension E1 for object
{
    public static string M() => throw null;
}

implicit extension E2 for System.ValueType
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "S.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_ObjectMethod_OnStruct()
    {
        var src = """
System.Console.Write(S.M());

struct S { }

implicit extension E1 for object
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "S.M");
        Assert.Equal("System.String E1.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_InterfaceFieldAndMoreSpecificField()
    {
        var src = """
System.Console.Write(C.M);

interface I { }
class C : I { }

implicit extension E1 for I
{
    public static string M = null;
}

implicit extension E2 for C
{
    public static string M = "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E2.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificInapplicableMethod()
    {
        var src = """
System.Console.Write(C.M());

class C { }

implicit extension E1 for object
{
    public static string M() => "ran";
}

implicit extension E2 for C
{
    public static string M(int i) => throw null;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E1.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void PreferMoreSpecific_Static_ExtensionOnExtension()
    {
        var src = """
object.M();

implicit extension E1 for object
{
    public static string M() => throw null;
}

implicit extension E2 for E1
{
    public static string M() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (8,27): error CS9305: The extended type may not be dynamic, a pointer, a ref struct, or an extension.
            // implicit extension E2 for E1
            Diagnostic(ErrorCode.ERR_BadExtensionUnderlyingType, "E1").WithLocation(8, 27));
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificMethod_OnInterface_TwoHierarchies()
    {
        var src = """
System.Console.Write(I3.M());

interface I1Base { }
interface I1 : I1Base { }

interface I2Base { }
interface I2 : I2Base { }

interface I3 : I1, I2 { }

implicit extension E1Base for I1Base
{
    public static string M() => throw null;
}
implicit extension E1 for I1
{
    public static string M() => throw null;
}

implicit extension E2Base for I2Base
{
    public static string M() => throw null;
}
implicit extension E2 for I2
{
    public static string M() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,25): error CS0121: The call is ambiguous between the following methods or properties: 'E1.M()' and 'E2.M()'
            // System.Console.Write(I3.M());
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E1.M()", "E2.M()").WithLocation(1, 25));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "I3.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E1.M()", "System.String E1Base.M()", "System.String E2.M()", "System.String E2Base.M()"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificMethod_OnInterface_DifferentHierarchies()
    {
        var src = """
System.Console.Write(I3.M());

interface I1Base { }
interface I1 : I1Base { }

interface I2Base { }
interface I2 : I2Base { }

interface I3 : I1, I2 { }

implicit extension E1Base for I1Base
{
    public static string M() => throw null;
}

implicit extension E2 for I2
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,25): error CS0121: The call is ambiguous between the following methods or properties: 'E1Base.M()' and 'E2.M()'
            // System.Console.Write(I3.M());
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E1Base.M()", "E2.M()").WithLocation(1, 25));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "I3.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);

        Assert.Equal(["System.String E1Base.M()", "System.String E2.M()"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());

        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificMethod_DifferentSignatures()
    {
        var src = """
System.Console.Write(C.M());

class C { }

implicit extension E1 for object
{
    public static string M() => "ran";
}

implicit extension E2 for C
{
    public static string M(int i) => throw null;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E1.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificMethod_InferredVariable()
    {
        var src = """
var x = C.M;
System.Console.Write(x());

class C { }

implicit extension E1 for object
{
    public static string M() => throw null;
}

implicit extension E2 for C
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var x = GetSyntax<VariableDeclaratorSyntax>(tree, "x = C.M");
        Assert.Equal("System.Func<System.String> x", model.GetDeclaredSymbol(x).ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Instance_IndexerAndMoreSpecificIndexer()
    {
        var src = """
System.Console.Write(new C()["ran"]);

class C { }

implicit extension E1 for object
{
    public string this[string s] => throw null;
}

implicit extension E2 for C
{
    public string this[string s] => s;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var elementAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, """new C()["ran"]""");
        Assert.Equal("System.String E2.this[System.String s] { get; }", model.GetSymbolInfo(elementAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(elementAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Instance_IndexerAndIndexer()
    {
        var src = """
System.Console.Write(new object()["ran"]);

implicit extension E1 for object
{
    public string this[string s] => throw null;
}

implicit extension E2 for object
{
    public string this[string s] => s;
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        comp.VerifyEmitDiagnostics(
            // (1,22): error CS0021: Cannot apply indexing with [] to an expression of type 'object'
            // System.Console.Write(new object()["ran"]);
            Diagnostic(ErrorCode.ERR_BadIndexLHS, @"new object()[""ran""]").WithArguments("object").WithLocation(1, 22));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var elementAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, """new object()["ran"]""");
        Assert.Null(model.GetSymbolInfo(elementAccess).Symbol);
    }

    [Fact]
    public void PreferMoreSpecific_Instance_IndexerAndMoreSpecificIndexer_OnArray()
    {
        var src = """
int[] i = [1, 2];
System.Console.Write(i["ran"]);

implicit extension E1 for object
{
    public string this[string s] => throw null;
}

implicit extension E2 for int[]
{
    public string this[string s] => s;
}
""";
        // PROTOTYPE(instance) extension indexers should come into play on array types
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (2,24): error CS0029: Cannot implicitly convert type 'string' to 'int'
            // System.Console.Write(i["ran"]);
            Diagnostic(ErrorCode.ERR_NoImplicitConv, @"""ran""").WithArguments("string", "int").WithLocation(2, 24));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var elementAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, """i["ran"]""");
        Assert.Null(model.GetSymbolInfo(elementAccess).Symbol);
    }

    [Fact]
    public void PreferMoreSpecific_Static_FieldAndMoreSpecificField_OnInterface()
    {
        var src = """
System.Console.Write(IDerived.M);

interface IBase { }
interface IDerived : IBase { }

implicit extension E1 for IBase
{
    public static string M = null;
}

implicit extension E2 for IDerived
{
    public static string M = "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "IDerived.M");
        Assert.Equal("System.String E2.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void PreferMoreSpecific_Static_FieldAndField_OnInterface()
    {
        var src = """
System.Console.Write(IDerived.M);

interface IBase1 { }
interface IBase2 { }
interface IDerived : IBase1, IBase2 { }

implicit extension E1 for IBase1
{
    public static string M = null;
}

implicit extension E2 for IBase2
{
    public static string M = null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,31): error CS0229: Ambiguity between 'E1.M' and 'E2.M'
            // System.Console.Write(IDerived.M);
            Diagnostic(ErrorCode.ERR_AmbigMember, "M").WithArguments("E1.M", "E2.M").WithLocation(1, 31));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "IDerived.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E1.M", "System.String E2.M"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void PreferMoreSpecific_Static_FieldAndField_OnInterface_TwoSubstitutions()
    {
        var src = """
System.Console.Write(C.M);

interface I<T> { }
class C : I<int>, I<string> { }

implicit extension E<T> for I<T>
{
    public static string M = null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,24): error CS0229: Ambiguity between 'E<int>.M' and 'E<string>.M'
            // System.Console.Write(C.M);
            Diagnostic(ErrorCode.ERR_AmbigMember, "M").WithArguments("E<int>.M", "E<string>.M").WithLocation(1, 24));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E<System.Int32>.M", "System.String E<System.String>.M"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");
        AssertSetStrictlyEqual(["System.String E<T>.M"], model.LookupSymbols(position: 0, e, name: "M").ToTestDisplayStrings());
        AssertSetStrictlyEqual(["System.String E<T>.M"], model.LookupSymbols(position: 0, e, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        var eInt = e.Construct(((Compilation)comp).GetSpecialType(SpecialType.System_Int32));
        AssertSetStrictlyEqual(["System.String E<System.Int32>.M"], model.LookupSymbols(position: 0, eInt, name: "M").ToTestDisplayStrings());
        AssertSetStrictlyEqual(["System.String E<System.Int32>.M"], model.LookupSymbols(position: 0, eInt, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, c, name: "M").ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, c, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMethod_OnInterface_TwoSubstitutions_InferredVariable()
    {
        var src = """
var x = C.M;

interface I<T> { }
class C : I<int>, I<string> { }

implicit extension E<T> for I<T>
{
    public static void M() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0121: The call is ambiguous between the following methods or properties: 'E<int>.M()' and 'E<string>.M()'
            // var x = C.M;
            Diagnostic(ErrorCode.ERR_AmbigCall, "C.M").WithArguments("E<int>.M()", "E<string>.M()").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        // PROTOTYPE need to fix the semantic model
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMethod_OnInterface_TwoSubstitutions_Invocation()
    {
        var src = """
C.M();

interface I<T> { }
class C : I<int>, I<string> { }

implicit extension E<T> for I<T>
{
    public static void M() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,3): error CS0121: The call is ambiguous between the following methods or properties: 'E<int>.M()' and 'E<string>.M()'
            // C.M();
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E<int>.M()", "E<string>.M()").WithLocation(1, 3));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);

        Assert.Equal(["void E<System.Int32>.M()", "void E<System.String>.M()"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());

        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMethod_OnInterface_TwoSubstitutions_Invocation_Generic()
    {
        var src = """
C.M<int>();

interface I<T> { }
class C : I<int>, I<string> { }

implicit extension E<T> for I<T>
{
    public static void M<U>() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,3): error CS0121: The call is ambiguous between the following methods or properties: 'E<int>.M<int>()' and 'E<string>.M<int>()'
            // C.M<int>();
            Diagnostic(ErrorCode.ERR_AmbigCall, "M<int>").WithArguments("E<int>.M<int>()", "E<string>.M<int>()").WithLocation(1, 3));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M<int>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);

        Assert.Equal(["void E<System.Int32>.M<System.Int32>()", "void E<System.String>.M<System.Int32>()"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());

        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void AmbiguousCallOnInterface()
    {
        var src = """
I2.M();

interface I<T>
{
    public static void M() { }
}

interface I2 : I<int>, I<string> { }
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (1,4): error CS0121: The call is ambiguous between the following methods or properties: 'I<T>.M()' and 'I<T>.M()'
            // I2.M();
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("I<T>.M()", "I<T>.M()").WithLocation(1, 4));
    }

    [Fact]
    public void AmbiguousCallOnInterface_Generic()
    {
        var src = """
I2.M<int>();

interface I<T>
{
    public static void M<U>() { }
}

interface I2 : I<int>, I<string> { }
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics(
            // (1,4): error CS0121: The call is ambiguous between the following methods or properties: 'I<T>.M<U>()' and 'I<T>.M<U>()'
            // I2.M<int>();
            Diagnostic(ErrorCode.ERR_AmbigCall, "M<int>").WithArguments("I<T>.M<U>()", "I<T>.M<U>()").WithLocation(1, 4));
    }

    [Fact]
    public void PreferMoreSpecific_Static_FieldAndField_OnInterface_TwoRelatedBases()
    {
        var src = """
System.Console.Write(IDerived.M);

interface IBase1 { }
interface IBase2 : IBase1 { }
interface IDerived : IBase1, IBase2 { }

implicit extension E1 for IBase1
{
    public static string M = null;
}

implicit extension E2 for IBase2
{
    public static string M = "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "IDerived.M");
        Assert.Equal("System.String E2.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void PreferMoreSpecific_Static_FieldAndField_OnInterface_TwoRelatedBases_ReverseOrder()
    {
        var src = """
System.Console.Write(IDerived.M);

interface IBase1 { }
interface IBase2 : IBase1 { }
interface IDerived : IBase2, IBase1 { }

implicit extension E1 for IBase1
{
    public static string M = null;
}

implicit extension E2 for IBase2
{
    public static string M = "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "IDerived.M");
        Assert.Equal("System.String E2.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void PreferMoreSpecific_Static_FieldAndFieldAndMoreSpecificField([CombinatorialValues(1, 2, 3)] int position)
    {
        var src = $$"""
System.Console.Write(C.M.ToString());

class C { }

implicit extension E1 for {{(position == 1 ? "C" : "object")}}
{
    public static int M = 1;
}

implicit extension E2 for {{(position == 2 ? "C" : "object")}}
{
    public static int M = 2;
}

implicit extension E3 for {{(position == 3 ? "C" : "object")}}
{
    public static int M = 3;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: position.ToString()).VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal($"""System.Int32 E{position}.M""", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Theory, CombinatorialData]
    public void PreferMoreSpecific_Static_FieldAndFieldAndLessSpecificField([CombinatorialValues(1, 2, 3)] int position)
    {
        var src = $$"""
System.Console.Write(C.M.ToString());

class C { }

implicit extension E1 for {{(position == 1 ? "object" : "C")}}
{
    public static int M = 1;
}

implicit extension E2 for {{(position == 2 ? "object" : "C")}}
{
    public static int M = 2;
}

implicit extension E3 for {{(position == 3 ? "object" : "C")}}
{
    public static int M = 3;
}
""";
        var first = new[] { 1, 2, 3 }.First(p => p != position);
        var last = new[] { 1, 2, 3 }.Last(p => p != position);
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,24): error CS0229: Ambiguity between 'Efirst.M' and 'Elast.M'
            // System.Console.Write(C.M.ToString());
            Diagnostic(ErrorCode.ERR_AmbigMember, "M").WithArguments($"E{first}.M", $"E{last}.M").WithLocation(1, 24)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([$"System.Int32 E{first}.M", $"System.Int32 E{last}.M"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Theory, CombinatorialData]
    public void PreferMoreSpecific_Static_MethodAndMethod(bool e1BeforeE2)
    {
        var e1 = """
implicit extension E1 for object
{
    public static string M() => throw null;
}

""";

        var e2 = """
implicit extension E2 for object
{
    public static string M() => throw null;
}
""";

        var src = $$"""
System.Console.Write(object.M());
{{(e1BeforeE2 ? e1 : e2)}}
{{(e1BeforeE2 ? e2 : e1)}}
""";
        var comp = CreateCompilation(src);
        if (!e1BeforeE2)
        {
            comp.VerifyEmitDiagnostics(
                // (1,29): error CS0121: The call is ambiguous between the following methods or properties: 'E2.M()' and 'E1.M()'
                // System.Console.Write(object.M());
                Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E2.M()", "E1.M()").WithLocation(1, 29));
        }
        else
        {
            comp.VerifyEmitDiagnostics(
                // (1,29): error CS0121: The call is ambiguous between the following methods or properties: 'E1.M()' and 'E2.M()'
                // System.Console.Write(object.M());
                Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E1.M()", "E2.M()").WithLocation(1, 29));
        }

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMethod_DifferentSignatures()
    {
        var src = """
System.Console.Write(object.M());

implicit extension E1 for object
{
    public static string M() => "ran";
}

implicit extension E2 for object
{
    public static string M(int i) => throw null;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E1.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    public class ThreePermutationGenerator : IEnumerable<object[]>
    {
        private readonly List<object[]> _data = [
            [0, 1, 2],
            [0, 2, 1],
            [1, 0, 2],
            [1, 2, 0],
            [2, 0, 1],
            [2, 1, 0]];

        public IEnumerator<object[]> GetEnumerator() => _data.GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_FieldAndMethodAndMoreSpecificMethod(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1 for object
            {
                public static string M = null;
            }
            """,
            """
            implicit extension E2 for object
            {
                public static string M() => throw null;
            }
            """,
            """
            implicit extension E3 for C
            {
                public static string M() => "ran";
            }
            """];

        var src = $$"""
System.Console.Write(C.M());

class C { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E3.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_FieldAndMethodAndMoreSpecificMethod_DifferentSignatures(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1 for object
            {
                public static string M = null;
            }
            """,
            """
            implicit extension E2 for object
            {
                public static string M(int i) => "ran";
            }
            """,
            """
            implicit extension E3 for C
            {
                public static string M() => throw null;
            }
            """];

        var src = $$"""
System.Console.Write(C.M(42));

class C { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E2.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_MethodsAndMoreSpecificFields(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1 for I1
            {
                public static string M = null;
            }
            """,
            """
            implicit extension E2 for I2
            {
                public static string M = null;
            }
            """,
            """
            implicit extension E3 for I1Base
            {
                public static string M() => throw null;
            }
            implicit extension E4 for I2Base
            {
                public static string M() => throw null;
            }
            """];

        var src = $$"""
System.Console.Write(C.M);

interface I1Base { }
interface I1 : I1Base { }
interface I2Base { }
interface I2 : I2Base { }

class C : I1, I2 { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,24): error CS0229: Ambiguity between 'E1.M' and 'E2.M'
            // System.Console.Write(C.M);
            Diagnostic(ErrorCode.ERR_AmbigMember, "M").WithArguments("E1.M", "E2.M").WithLocation(1, 24));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E1.M", "System.String E2.M"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_MethodsAndMoreSpecificFields_Invocation(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1 for I1
            {
                public static string M = null;
            }
            """,
            """
            implicit extension E4 for I2Base
            {
                public static string M() => throw null;
            }
            """,
            """
            implicit extension E3 for I1Base
            {
                public static string M() => throw null;
            }
            implicit extension E2 for I2
            {
                public static string M = null;
            }
            """];

        var src = $$"""
System.Console.Write(C.M());

interface I1Base { }
interface I1 : I1Base { }
interface I2Base { }
interface I2 : I2Base { }

class C : I1, I2 { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,24): error CS0121: The call is ambiguous between the following methods or properties: 'E3.M()' and 'E4.M()'
            // System.Console.Write(C.M());
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E3.M()", "E4.M()").WithLocation(1, 24));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E3.M()", "System.String E4.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());

        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_MethodsAndMoreSpecificFields_Invocation_DifferentSignatures(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1 for I1
            {
                public static string M = null;
            }
            """,
            """
            implicit extension E4 for I2Base
            {
                public static string M(int i) => "ran";
            }
            """,
            """
            implicit extension E3 for I1Base
            {
                public static string M() => throw null;
            }
            implicit extension E2 for I2
            {
                public static string M = null;
            }
            """];

        var src = $$"""
System.Console.Write(C.M(42));

interface I1Base { }
interface I1 : I1Base { }
interface I2Base { }
interface I2 : I2Base { }

class C : I1, I2 { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E4.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_MethodAndMethodAndMoreSpecificField(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1 for object
            {
                public static string M() => throw null;
            }
            """,
            """
            implicit extension E2 for object
            {
                public static string M() => throw null;
            }
            """,
            """
            implicit extension E3 for C
            {
                public static string M = null;
            }
            """];

        var src = $$"""
System.Console.Write(C.M());

class C { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        bool isE1beforeE2 = segmentIndex(0) < segmentIndex(1);
        if (!isE1beforeE2)
        {
            comp.VerifyEmitDiagnostics(
                // (1,24): error CS0121: The call is ambiguous between the following methods or properties: 'E2.M()' and 'E1.M()'
                // System.Console.Write(C.M());
                Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E2.M()", "E1.M()").WithLocation(1, 24));
        }
        else
        {
            comp.VerifyEmitDiagnostics(
                // (1,24): error CS0121: The call is ambiguous between the following methods or properties: 'E1.M()' and 'E2.M()'
                // System.Console.Write(C.M());
                Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E1.M()", "E2.M()").WithLocation(1, 24));
        }

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        if (!isE1beforeE2)
        {
            Assert.Equal(["System.String E2.M()", "System.String E1.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        }
        else
        {
            Assert.Equal(["System.String E1.M()", "System.String E2.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        }

        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model

        int segmentIndex(int segment) => first == segment ? 0 : (second == segment ? 1 : 2);
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_InvocableFieldAndMethodAndMoreSpecificMethod(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1 for object
            {
                public static System.Func<string> M = null;
            }
            """,
            """
            implicit extension E2 for object
            {
                public static string M() => throw null;
            }
            """,
            """
            implicit extension E3 for C
            {
                public static string M() => "ran";
            }
            """];

        var src = $$"""
System.Console.Write(C.M());

class C { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E3.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_MethodAndMethodAndMoreSpecificInvocableField(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1 for object
            {
                public static string M() => throw null;
            }
            """,
            """
            implicit extension E2 for object
            {
                public static string M() => throw null;
            }
            """,
            """
            implicit extension E3 for C
            {
                public static System.Func<string> M = () => "ran";
            }
            """];

        var src = $$"""
System.Console.Write(C.M());

class C { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.Func<System.String> E3.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificInvocableFieldAndYetMoreSpecificMethod(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1 for object
            {
                public static string M() => throw null;
            }
            """,
            """
            implicit extension E2 for Base
            {
                public static System.Func<string> M = null;
            }
            """,
            """
            implicit extension E3 for Derived
            {
                public static string M() => "ran";
            }
            """];

        var src = $$"""
System.Console.Write(Derived.M());

class Base { }
class Derived : Base { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Derived.M");
        Assert.Equal("System.String E3.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificInvocableFieldAndMoreSpecificMethod(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1 for object
            {
                public static string M() => throw null;
            }
            """,
            """
            implicit extension E2 for C
            {
                public static System.Func<string> M = null;
            }
            """,
            """
            implicit extension E3 for C
            {
                public static string M() => throw null;
            }
            """];

        var src = $$"""
System.Console.Write(C.M());

class C { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics(
            // (1,24): error CS0229: Ambiguity between 'E2.M' and 'E3.M()'
            // System.Console.Write(C.M());
            Diagnostic(ErrorCode.ERR_AmbigMember, "M").WithArguments("E2.M", "E3.M()").WithLocation(1, 24));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);

        Assert.Equal(["System.Func<System.String> E2.M", "System.String E3.M()"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());

        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_InvocableFieldAndMoreSpecificMethodAndNotViable(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1 for object
            {
                public static System.Func<string> M = null;
            }
            """,
            """
            implicit extension E2 for C
            {
                public static string M() => "ran";
            }
            """,
            """
            implicit extension E3 for C
            {
            }
            """];

        var src = $$"""
System.Console.Write(C.M());

class C { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, CombinatorialData]
    public void PreferMoreSpecific_Static_InvocableFieldAndMoreSpecificMethod_InInterface(bool order)
    {
        var e1 = """
implicit extension E1 for I1
{
    public static System.Func<string> M = null;
}
""";
        var e2 = """
implicit extension E2 for I2
{
    public static string M() => "ran";
}
""";

        var src = $$"""
System.Console.Write(I3.M());

interface I1 { }
interface I2 : I1 { }
interface I3 : I2, I1 { }

{{(order ? e1 : e2)}}

{{(order ? e2 : e1)}}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "I3.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Theory, CombinatorialData]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificInvocableField_InInterface(bool order)
    {
        var e1 = """
implicit extension E1 for I1
{
    public static string M() => throw null;
}
""";
        var e2 = """
implicit extension E2 for I2
{
    public static System.Func<string> M = () => "ran";
}
""";

        var src = $$"""
System.Console.Write(I3.M());

interface I1 { }
interface I2 : I1 { }
interface I3 : I2, I1 { }

{{(order ? e1 : e2)}}

{{(order ? e2 : e1)}}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "I3.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificInvocableField()
    {
        var src = $$"""
System.Console.Write(C.M());

class C { }

implicit extension E1 for object
{
    public static string M() => throw null;
}

implicit extension E2 for C
{
    public static System.Func<string> M = () => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void PreferMoreSpecific_Static_InvocableFieldAndMoreSpecificMethod()
    {
        var src = $$"""
System.Console.Write(C.M());

class C { }

implicit extension E1 for object
{
    public static System.Func<string> M = null;
}

implicit extension E2 for C
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E2.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Theory, CombinatorialData]
    public void PreferMoreSpecific_Static_IndexerAndMoreSpecificIndexer(bool order)
    {
        var src = $$"""
System.Console.Write(new C()[42]);

class C { }

implicit extension E1 for {{(order ? "object" : "C")}}
{
    public int this[int i] => i + 1;
}

implicit extension E2 for {{(order ? "C" : "object")}}
{
    public int this[int i] => i + 2;
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE(instance) implement indexer access on receiver of extension type
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var elementAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[42]");
        Assert.Equal(order ? "System.Int32 E2.this[System.Int32 i] { get; }" : "System.Int32 E1.this[System.Int32 i] { get; }",
            model.GetSymbolInfo(elementAccess).Symbol.ToTestDisplayString());

        Assert.Equal([], model.GetSymbolInfo(elementAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(elementAccess));
    }

    [Fact]
    public void PreferMoreSpecific_Static_NullabilityDifferences_InBaseType()
    {
        var src = $$"""
#nullable enable

System.Console.Write(Derived<string?>.M());
System.Console.Write(Derived<string>.M());

class Base<T> { }
class Derived<T> : Base<T>  { }

implicit extension E1 for Base<string>
{
    public static System.Func<string>? M = null;
}

implicit extension E2 for Derived<string?>
{
    public static System.Func<string> M = () => "ran ";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "Derived<string?>.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess1));

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "Derived<string>.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess2));
    }

    [Fact]
    public void PreferMoreSpecific_Static_NullabilityDifferences_InBaseType_ReverseNullability()
    {
        var src = $$"""
#nullable enable

System.Console.Write(Derived<string?>.M());
System.Console.Write(Derived<string>.M());

class Base<T> { }
class Derived<T> : Base<T>  { }

implicit extension E1 for Base<string?>
{
    public static System.Func<string>? M = null;
}

implicit extension E2 for Derived<string>
{
    public static System.Func<string> M = () => "ran ";
}
""";
        var comp = CreateCompilation(src);
        // PROTOTYPE(static) consider warning for certain nullability differences
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "Derived<string?>.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess1));

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "Derived<string>.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess2));
    }

    [Fact]
    public void PreferMoreSpecific_Static_DynamicDifferences_InBaseType()
    {
        var src = $$"""
System.Console.Write(Derived<dynamic>.M());

class Base<T> { }
class Derived<T> : Base<T>  { }

implicit extension E1 for Base<dynamic>
{
    public static System.Func<string> M = null;
}

implicit extension E2 for Derived<object>
{
    public static System.Func<string> M = () => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Derived<dynamic>.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void PreferMoreSpecific_Static_NullabilityDifferences_InTypeContext()
    {
        var src = $$"""
#nullable enable
C.Method();

class C : Derived<string?>.M { }

class Base<T> { }
class Derived<T> : Base<T>  { }

implicit extension E1 for Base<string>
{
    public class M { public static void Method() => throw null!; }
}

implicit extension E2 for Derived<string?>
{
    public class M { public static void Method() { System.Console.Write("ran"); } }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "Derived<string?>.M");
        Assert.Equal("E2.M", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(qualifiedName).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(qualifiedName));
    }

    [Fact]
    public void PreferMoreSpecific_Static_DynamicDifferences_InTypeContext()
    {
        var src = $$"""
C.Method();
class C : Derived<dynamic>.M { }

class Base<T> { }
class Derived<T> : Base<T>  { }

implicit extension E1 for Base<dynamic>
{
    public class M { public static void Method() => throw null; }
}

implicit extension E2 for Derived<object>
{
    public class M { public static void Method() { System.Console.Write("ran"); } }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "Derived<dynamic>.M");
        Assert.Equal("E2.M", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(qualifiedName).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(qualifiedName));
    }

    [Fact]
    public void PreferMoreSpecific_Static_NullabilityDifferences_InInterfaces()
    {
        var src = $$"""
#nullable enable

System.Console.Write(IDerived<string?>.M());
System.Console.Write(IDerived<string>.M());

interface IBase<T> { }
interface IDerived<T> : IBase<T>  { }

implicit extension E1 for IBase<string>
{
    public static System.Func<string>? M = null;
}

implicit extension E2 for IDerived<string?>
{
    public static System.Func<string> M = () => "ran ";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "IDerived<string?>.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess1));

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "IDerived<string>.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess2));
    }

    [Fact]
    public void PreferMoreSpecific_Static_NullabilityDifferences_InInterfaces_ReverseNullability()
    {
        var src = $$"""
#nullable enable

System.Console.Write(IDerived<string?>.M());
System.Console.Write(IDerived<string>.M());

interface IBase<T> { }
interface IDerived<T> : IBase<T>  { }

implicit extension E1 for IBase<string?>
{
    public static System.Func<string>? M = null;
}

implicit extension E2 for IDerived<string>
{
    public static System.Func<string> M = () => "ran ";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "IDerived<string?>.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess1));

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "IDerived<string>.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess2));
    }

    [Fact]
    public void PreferMoreSpecific_Static_DynamicDifferences_InInterfaces()
    {
        var src = $$"""
System.Console.Write(IDerived<dynamic>.M());

interface IBase<T> { }
interface IDerived<T> : IBase<T>  { }

implicit extension E1 for IBase<dynamic>
{
    public static System.Func<string> M = null;
}

implicit extension E2 for IDerived<object>
{
    public static System.Func<string> M = () => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "IDerived<dynamic>.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void PreferMoreSpecific_Static_TupleDifferences_InInterfaces()
    {
        var src = $$"""
System.Console.Write(IDerived<(int a, int b)>.M());

interface IBase<T> { }
interface IDerived<T> : IBase<T>  { }

implicit extension E1 for IBase<(int a, int b)>
{
    public static System.Func<string> M = null;
}

implicit extension E2 for IDerived<(int c, int d)>
{
    public static System.Func<string> M = () => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "IDerived<(int a, int b)>.M");
        Assert.Equal("System.Func<System.String> E2.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void DuplicateSourceSymbol_Instance_Indexer()
    {
        var src = """
System.Console.Write(new C()[42]);

class C { }

implicit extension E for C
{
    public int this[int i] => throw null;
    public int this[int i] => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,22): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            // System.Console.Write(new C()[42]);
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "new C()[42]").WithArguments("C").WithLocation(1, 22),
            // (8,16): error CS0111: Type 'E' already defines a member called 'this' with the same parameter types
            //     public int this[int i] => throw null;
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "this").WithArguments("this", "E").WithLocation(8, 16));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var elementAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "new C()[42]");
        Assert.Null(model.GetSymbolInfo(elementAccess).Symbol);
        Assert.Equal([], model.GetSymbolInfo(elementAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(elementAccess));
    }

    [Fact]
    public void DuplicateSourceSymbol_Static_Field()
    {
        var src = """
System.Console.Write(C.Field);

class C { }

implicit extension E for C
{
    public static int Field = 0;
    public static int Field = 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,24): error CS0229: Ambiguity between 'E.Field' and 'E.Field'
            // System.Console.Write(C.Field);
            Diagnostic(ErrorCode.ERR_AmbigMember, "Field").WithArguments("E.Field", "E.Field").WithLocation(1, 24),
            // (8,23): error CS0102: The type 'E' already contains a definition for 'Field'
            //     public static int Field = 0;
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "Field").WithArguments("E", "Field").WithLocation(8, 23));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Field");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 E.Field", "System.Int32 E.Field"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.Ambiguous, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void DuplicateSourceSymbol_Static_Property()
    {
        var src = """
System.Console.Write(C.Property);

class C { }

implicit extension E for C
{
    public static int Property => 0;
    public static int Property => 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,24): error CS0229: Ambiguity between 'E.Property' and 'E.Property'
            // System.Console.Write(C.Property);
            Diagnostic(ErrorCode.ERR_AmbigMember, "Property").WithArguments("E.Property", "E.Property").WithLocation(1, 24),
            // (8,23): error CS0102: The type 'E' already contains a definition for 'Property'
            //     public static int Property = 0;
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "Property").WithArguments("E", "Property").WithLocation(8, 23));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 E.Property { get; }", "System.Int32 E.Property { get; }"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.Ambiguous, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void DuplicateSourceSymbol_Static_Type()
    {
        var src = """
C.D.M(); // 1
public class C2<T> where T : C.D { } // 2

class C { }

implicit extension E for C
{
    public static class D { public static void M() { } }
    public static class D { public static void M() { } } // 3, 4
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0121: The call is ambiguous between the following methods or properties: 'E.D.M()' and 'E.D.M()'
            // C.D.M(); // 1
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E.D.M()", "E.D.M()").WithLocation(1, 5),
            // (2,30): error CS0717: 'E.D': static classes cannot be used as constraints
            // public class C2<T> where T : C.D { } // 2
            Diagnostic(ErrorCode.ERR_ConstraintIsStaticClass, "C.D").WithArguments("E.D").WithLocation(2, 30),
            // (9,25): error CS0102: The type 'E' already contains a definition for 'D'
            //     public static class D { public static void M() { } } // 3, 4
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "D").WithArguments("E", "D").WithLocation(9, 25),
            // (9,48): error CS0111: Type 'E.D' already defines a member called 'M' with the same parameter types
            //     public static class D { public static void M() { } } // 3, 4
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M").WithArguments("M", "E.D").WithLocation(9, 48));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.D");
        Assert.Equal("E.D", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var type = GetSyntax<QualifiedNameSyntax>(tree, "C.D");
        Assert.Equal("E.D", model.GetSymbolInfo(type).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void OverloadResolutionWithUseSiteErrors_LessDerived()
    {
        var missingSource = @"
public class Missing { }
";

        var libSource = @"
public class Base { }

public implicit extension EBase for Base
{
    public int M(int x) { return 0; }
    public int M(Missing x) { return 0; }

    public int this[int x] { get { return 0; } }
    public int this[Missing x] { get { return 0; } }
}
";

        var testSource = @"
public class Derived : Base
{
    static void Main()
    {
        var d = new Derived();
        int i;

        i = d.M(1);
        i = d.M(""A"");

        i = d[1];
        i = d[""A""];
    }
}

public implicit extension EDerived for Derived
{
    public int M(string x) { return 0; }
    public int this[string x] { get { return 0; } }
}
";
        var missingRef = CreateCompilation(missingSource, assemblyName: "Missing").EmitToImageReference();
        var libRef = CreateCompilation(libSource, new[] { missingRef }).EmitToImageReference();
        CreateCompilation(testSource, new[] { libRef, missingRef }).VerifyDiagnostics();

        // NOTE: No errors reported when the EDerived member wins.
        CreateCompilation(testSource, new[] { libRef /* and not missingRef */ }).VerifyDiagnostics(
            // (9,13): error CS0012: The type 'Missing' is defined in an assembly that is not referenced. You must add a reference to assembly 'Missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            //         i = d.M(1);
            Diagnostic(ErrorCode.ERR_NoTypeDef, "d.M").WithArguments("Missing", "Missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(9, 13),
            // (12,13): error CS0012: The type 'Missing' is defined in an assembly that is not referenced. You must add a reference to assembly 'Missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            //         i = d[1];
            Diagnostic(ErrorCode.ERR_NoTypeDef, "d[1]").WithArguments("Missing", "Missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(12, 13));
    }

    [Fact]
    public void Obsolete_Property_Static()
    {
        var src = """
object.Property1 = 1;
_ = object.Property1;
new object().Property2 = 1;
_ = new object().Property2;

implicit extension E for object
{
    [System.Obsolete("error", true)]
    public static int Property1 { get => throw null; set => throw null; }

    [System.Obsolete("error", true)]
    public int Property2 { get => throw null; set => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0619: 'E.Property1' is obsolete: 'error'
            // object.Property1 = 1;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Property1").WithArguments("E.Property1", "error").WithLocation(1, 1),
            // (2,5): error CS0619: 'E.Property1' is obsolete: 'error'
            // _ = object.Property1;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Property1").WithArguments("E.Property1", "error").WithLocation(2, 5),
            // (3,1): error CS0619: 'E.Property2' is obsolete: 'error'
            // new object().Property2 = 1;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Property2").WithArguments("E.Property2", "error").WithLocation(3, 1),
            // (4,5): error CS0619: 'E.Property2' is obsolete: 'error'
            // _ = new object().Property2;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Property2").WithArguments("E.Property2", "error").WithLocation(4, 5));
    }

    [Fact]
    public void ExtensionMemberLookup_Property_OnBase()
    {
        var src = """
class C
{
    public void M()
    {
        base.Property1 = 1;
        _ = base.Property1;
        base.Property2 = 1;
        _ = base.Property2;
    }
}

implicit extension E for object
{
    public static int Property1 { get => throw null; set => throw null; }
    public int Property2 { get => throw null; set => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,14): error CS0117: 'object' does not contain a definition for 'Property1'
            //         base.Property1 = 1;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property1").WithArguments("object", "Property1").WithLocation(5, 14),
            // (6,18): error CS0117: 'object' does not contain a definition for 'Property1'
            //         _ = base.Property1;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property1").WithArguments("object", "Property1").WithLocation(6, 18),
            // (7,14): error CS0117: 'object' does not contain a definition for 'Property2'
            //         base.Property2 = 1;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property2").WithArguments("object", "Property2").WithLocation(7, 14),
            // (8,18): error CS0117: 'object' does not contain a definition for 'Property2'
            //         _ = base.Property2;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property2").WithArguments("object", "Property2").WithLocation(8, 18));
    }

    [Fact]
    public void ExtensionMemberLookup_Property_OnBase_DerivedType()
    {
        var src = """
class Base { }

class Derived : Base
{
    public void M()
    {
        base.Property1 = 1;
        _ = base.Property1;
        base.Property2 = 1;
        _ = base.Property2;
    }
}

implicit extension E for Base
{
    public static int Property1 { get => throw null; set => throw null; }
    public int Property2 { get => throw null; set => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (7,14): error CS0117: 'Base' does not contain a definition for 'Property1'
            //         base.Property1 = 1;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property1").WithArguments("Base", "Property1").WithLocation(7, 14),
            // (8,18): error CS0117: 'Base' does not contain a definition for 'Property1'
            //         _ = base.Property1;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property1").WithArguments("Base", "Property1").WithLocation(8, 18),
            // (9,14): error CS0117: 'Base' does not contain a definition for 'Property2'
            //         base.Property2 = 1;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property2").WithArguments("Base", "Property2").WithLocation(9, 14),
            // (10,18): error CS0117: 'Base' does not contain a definition for 'Property2'
            //         _ = base.Property2;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property2").WithArguments("Base", "Property2").WithLocation(10, 18));
    }

    [Fact]
    public void Obsolete_Field_Static()
    {
        var src = """
object.Field = 1;
_ = object.Field;

C.Field = 1;
_ = C.Field;

implicit extension E for object
{
    [System.Obsolete("error", true)]
    public static int Field = 0;
}

static class C
{
    [System.Obsolete("error", true)]
    public static int Field = 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0619: 'E.Field' is obsolete: 'error'
            // object.Field = 1;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Field").WithArguments("E.Field", "error").WithLocation(1, 1),
            // (2,5): error CS0619: 'E.Field' is obsolete: 'error'
            // _ = object.Field;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Field").WithArguments("E.Field", "error").WithLocation(2, 5),
            // (4,1): error CS0619: 'C.Field' is obsolete: 'error'
            // C.Field = 1;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "C.Field").WithArguments("C.Field", "error").WithLocation(4, 1),
            // (5,5): error CS0619: 'C.Field' is obsolete: 'error'
            // _ = C.Field;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "C.Field").WithArguments("C.Field", "error").WithLocation(5, 5));
    }

    [Fact]
    public void Obsolete_Event_Static()
    {
        var src = """
object.Event += null;
object.Event -= null;

implicit extension E for object
{
    [System.Obsolete("error", true)]
    public static event System.Action Event { add { throw null; } remove { throw null; } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0619: 'E.Event' is obsolete: 'error'
            // object.Event += null;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Event").WithArguments("E.Event", "error").WithLocation(1, 1),
            // (2,1): error CS0619: 'E.Event' is obsolete: 'error'
            // object.Event -= null;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Event").WithArguments("E.Event", "error").WithLocation(2, 1));
    }

    [Fact]
    public void Obsolete_Event_Instance()
    {
        var src = """
new object().Event += null;
new object().Event -= null;

implicit extension E for object
{
    [System.Obsolete("error", true)]
    public event System.Action Event { add { throw null; } remove { throw null; } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0619: 'E.Event' is obsolete: 'error'
            // new object().Event += null;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Event").WithArguments("E.Event", "error").WithLocation(1, 1),
            // (2,1): error CS0619: 'E.Event' is obsolete: 'error'
            // new object().Event -= null;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Event").WithArguments("E.Event", "error").WithLocation(2, 1));
    }

    [Fact]
    public void TypeOrInstanceReceiver_Property_Static()
    {
        var src = """
C.M(null);

public class C
{
    public static void M(C C)
    {
        C.Property = 1;
        _ = C.Property;
    }
}

implicit extension E for object
{
    public static int Property { get { System.Console.Write("get "); return 42; } set { System.Console.Write("set "); } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "set get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.Property").First();
        Assert.Equal("System.Int32 E.Property { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal("C", model.GetSymbolInfo(memberAccess1.Expression).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.Property").Last();
        Assert.Equal("System.Int32 E.Property { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal("C", model.GetSymbolInfo(memberAccess2.Expression).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void TypeOrInstanceReceiver_Property_Instance()
    {
        var src = """
C.M(new C());

public class C
{
    public static void M(C C)
    {
        C.Property = 1;
        _ = C.Property;
    }
}

implicit extension E for object
{
    public int Property { get { System.Console.Write("get "); return 42; } set { System.Console.Write("set "); } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once instance scenarios are implemented
        //CompileAndVerify(comp, expectedOutput: "set get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.Property").First();
        Assert.Equal("System.Int32 E.Property { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal("C C", model.GetSymbolInfo(memberAccess1.Expression).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.Property").Last();
        Assert.Equal("System.Int32 E.Property { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal("C C", model.GetSymbolInfo(memberAccess2.Expression).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void TypeOrInstanceReceiver_Indexer_Instance()
    {
        var src = """
C.M(new C());

public class C
{
    public static void M(C C)
    {
        C[42] = 1;
        _ = C[43];
    }
}

implicit extension E for object
{
    public int this[int i] { get { System.Console.Write("get "); return 42; } set { System.Console.Write("set "); } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once instance scenarios are implemented
        //CompileAndVerify(comp, expectedOutput: "set get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<ElementAccessExpressionSyntax>(tree, "C[42]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal("C C", model.GetSymbolInfo(memberAccess1.Expression).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<ElementAccessExpressionSyntax>(tree, "C[43]");
        Assert.Equal("System.Int32 E.this[System.Int32 i] { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal("C C", model.GetSymbolInfo(memberAccess2.Expression).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_MemberAccessOnNestedType()
    {
        var src = """
object.Nested.M();

implicit extension E for object
{
    public class Nested { public static void M() { System.Console.Write("ran"); } }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Nested");
        Assert.Equal("E.Nested", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void LiteralReceiver_Property_Integer_Get()
    {
        var src = """
_ = 1.Property;

implicit extension E for int
{
    public int Property { get { System.Console.Write("get"); return 42; } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once instance scenarios are implemented
        //CompileAndVerify(comp, expectedOutput: "get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "1.Property");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void LiteralReceiver_Property_Integer_Set()
    {
        var src = """
1.Property = 1;

implicit extension E for int
{
    public int Property { set => throw null; }
}
""";
        var comp = CreateCompilation(src);
        // Consider improving the error message
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
            // 1.Property = 1;
            Diagnostic(ErrorCode.ERR_AssgLvalueExpected, "1.Property").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "1.Property");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 E.Property { set; }"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Field_Integer_Set()
    {
        var src = """
1.field = 1;

implicit extension E for int
{
    public int field;
}
""";
        var comp = CreateCompilation(src);
        // Consider improving the error message
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
            // 1.field = 1;
            Diagnostic(ErrorCode.ERR_AssgLvalueExpected, "1.field").WithLocation(1, 1),
            // (5,16): error CS9313: 'E.field': cannot declare instance members with state in extension types.
            //     public int field;
            Diagnostic(ErrorCode.ERR_StateInExtension, "field").WithArguments("E.field").WithLocation(5, 16));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "1.field");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 E.field"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Property_Enum_Set()
    {
        var src = """
Enum.Zero.Property = 1;

enum Enum
{
    Zero
}

implicit extension E for Enum
{
    public int Property { set => throw null; }
}
""";
        var comp = CreateCompilation(src);
        // Consider improving the error message
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
            // Enum.Zero.Property = 1;
            Diagnostic(ErrorCode.ERR_AssgLvalueExpected, "Enum.Zero.Property").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Enum.Zero.Property");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 E.Property { set; }"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Indexer_Integer_Set()
    {
        var src = """
1[42] = 1;

implicit extension E for int
{
    public int this[int i] { set => throw null; }
}
""";
        var comp = CreateCompilation(src);
        // Consider improving the error message
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
            // 1[42] = 1;
            Diagnostic(ErrorCode.ERR_AssgLvalueExpected, "1[42]").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var elementAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "1[42]");
        Assert.Null(model.GetSymbolInfo(elementAccess).Symbol);
        Assert.Equal(["System.Int32 E.this[System.Int32 i] { set; }"], model.GetSymbolInfo(elementAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(elementAccess).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Indexer_Enum_Set()
    {
        var src = """
Enum.Zero[42] = 1;

enum Enum
{
    Zero
}

implicit extension E for Enum
{
    public int this[int i] { set => throw null; }
}
""";
        // PROTOTYPE(instance) extension indexers should probably be allowed on enums
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0021: Cannot apply indexing with [] to an expression of type 'Enum'
            // Enum.Zero[42] = 1;
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "Enum.Zero[42]").WithArguments("Enum").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var elementAccess = GetSyntax<ElementAccessExpressionSyntax>(tree, "Enum.Zero[42]");
        Assert.Null(model.GetSymbolInfo(elementAccess).Symbol);
        Assert.Equal([], model.GetSymbolInfo(elementAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void LiteralReceiver_Property_Integer_ForLong()
    {
        var src = """
1.Property = 42;
_ = 2.Property;

implicit extension E for long
{
    public int Property { get { System.Console.Write("get "); return 42; } set { System.Console.Write("set "); }  }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,3): error CS1061: 'int' does not contain a definition for 'Property' and no accessible extension method 'Property' accepting a first argument of type 'int' could be found (are you missing a using directive or an assembly reference?)
            // 1.Property = 42;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Property").WithArguments("int", "Property").WithLocation(1, 3),
            // (2,7): error CS1061: 'int' does not contain a definition for 'Property' and no accessible extension method 'Property' accepting a first argument of type 'int' could be found (are you missing a using directive or an assembly reference?)
            // _ = 2.Property;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Property").WithArguments("int", "Property").WithLocation(2, 7));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "1.Property");
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess1).CandidateReason);

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "2.Property");
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess2).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Property_String()
    {
        var src = """
"".Property = 42;
_ = "".Property;

implicit extension E for string
{
    public int Property { get { System.Console.Write("get "); return 42; } set { System.Console.Write("set "); }  }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once instance scenarios are implemented
        //CompileAndVerify(comp, expectedOutput: "set get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "\"\".Property").First();
        Assert.Equal("System.Int32 E.Property { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "\"\".Property").Last();
        Assert.Equal("System.Int32 E.Property { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void SwitchReceiver_Property_String()
    {
        var src = """
bool b = true;
(b switch { true => "", _ => "" }).Property = 42;
_ = (b switch { true => "", _ => "" }).Property;

implicit extension E for string
{
    public int Property { get { System.Console.Write("get "); return 42; } set { System.Console.Write("set "); }  }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once instance scenarios are implemented
        //CompileAndVerify(comp, expectedOutput: "set get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, """(b switch { true => "", _ => "" }).Property""").First();
        Assert.Equal("System.Int32 E.Property { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, """(b switch { true => "", _ => "" }).Property""").Last();
        Assert.Equal("System.Int32 E.Property { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void SwitchReceiver_Index_String()
    {
        var src = """
bool b = true;
(b switch { true => "", _ => "" })[""] = 42;
_ = (b switch { true => "", _ => "" })[""];

implicit extension E for string
{
    public int this[string s] { get { System.Console.Write("get "); return 42; } set { System.Console.Write("set "); }  }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once instance scenarios are implemented
        //CompileAndVerify(comp, expectedOutput: "set get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<ElementAccessExpressionSyntax>(tree, """(b switch { true => "", _ => "" })[""]""").First();
        Assert.Equal("System.Int32 E.this[System.String s] { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<ElementAccessExpressionSyntax>(tree, """(b switch { true => "", _ => "" })[""]""").Last();
        Assert.Equal("System.Int32 E.this[System.String s] { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ConditionalReceiver_Property_String()
    {
        var src = """
bool b = true;
(b ? "" : null).Property = 42;
_ = (b ? "" : null).Property;

implicit extension E for string
{
    public int Property { get { System.Console.Write("get "); return 42; } set { System.Console.Write("set "); }  }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once instance scenarios are implemented
        //CompileAndVerify(comp, expectedOutput: "set get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, """(b ? "" : null).Property""").First();
        Assert.Equal("System.Int32 E.Property { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, """(b ? "" : null).Property""").Last();
        Assert.Equal("System.Int32 E.Property { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void LiteralReceiver_Property_Null()
    {
        var src = """
null.Property = 1;
_ = null.Property;

implicit extension E for object
{
    public int Property { get => throw null; set => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0023: Operator '.' cannot be applied to operand of type '<null>'
            // null.Property = 1;
            Diagnostic(ErrorCode.ERR_BadUnaryOp, "null.Property").WithArguments(".", "<null>").WithLocation(1, 1),
            // (2,5): error CS0023: Operator '.' cannot be applied to operand of type '<null>'
            // _ = null.Property;
            Diagnostic(ErrorCode.ERR_BadUnaryOp, "null.Property").WithArguments(".", "<null>").WithLocation(2, 5));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "null.Property").First();
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess1).CandidateReason);

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "null.Property").Last();
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess2).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Property_Default()
    {
        var src = """
default.Property = 1;
_ = default.Property;

implicit extension E for object
{
    public int Property { get => throw null; set => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS8716: There is no target type for the default literal.
            // default.Property = 1;
            Diagnostic(ErrorCode.ERR_DefaultLiteralNoTargetType, "default").WithLocation(1, 1),
            // (2,5): error CS8716: There is no target type for the default literal.
            // _ = default.Property;
            Diagnostic(ErrorCode.ERR_DefaultLiteralNoTargetType, "default").WithLocation(2, 5));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "default.Property").First();
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess1).CandidateReason);

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "default.Property").Last();
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess2).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Property_Tuple_Get()
    {
        var src = """
_ = (1, 2).Property;

implicit extension E for (int, int)
{
    public int Property { get { System.Console.Write("get "); return 42; } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once instance scenarios are implemented
        //CompileAndVerify(comp, expectedOutput: "get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "(1, 2).Property");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void LiteralReceiver_Property_Tuple_Set()
    {
        var src = """
(1, 2).Property = 1;

implicit extension E for (int, int)
{
    public int Property { set { System.Console.Write($"set(value)"); }}
}
""";
        var comp = CreateCompilation(src);
        // Consider improving the error message
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
            // (1, 2).Property = 1;
            Diagnostic(ErrorCode.ERR_AssgLvalueExpected, "(1, 2).Property").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "(1, 2).Property");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 E.Property { set; }"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Property_Tuple_Default()
    {
        var src = """
(default, default).Property = 1;
_ = (default, default).Property;

implicit extension E for (object, object)
{
    public int Property { get => throw null; set => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,2): error CS8716: There is no target type for the default literal.
            // (default, default).Property = 1;
            Diagnostic(ErrorCode.ERR_DefaultLiteralNoTargetType, "default").WithLocation(1, 2),
            // (1,11): error CS8716: There is no target type for the default literal.
            // (default, default).Property = 1;
            Diagnostic(ErrorCode.ERR_DefaultLiteralNoTargetType, "default").WithLocation(1, 11),
            // (2,6): error CS8716: There is no target type for the default literal.
            // _ = (default, default).Property;
            Diagnostic(ErrorCode.ERR_DefaultLiteralNoTargetType, "default").WithLocation(2, 6),
            // (2,15): error CS8716: There is no target type for the default literal.
            // _ = (default, default).Property;
            Diagnostic(ErrorCode.ERR_DefaultLiteralNoTargetType, "default").WithLocation(2, 15));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "(default, default).Property").First();
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess1).CandidateReason);

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "(default, default).Property").Last();
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess2).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Property_Tuple_Integer_ForLong()
    {
        var src = """
(1, 1).Property = 1;
_ = (2, 2).Property;

implicit extension E for (long, long)
{
    public int Property { get => throw null; set => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS1061: '(int, int)' does not contain a definition for 'Property' and no accessible extension method 'Property' accepting a first argument of type '(int, int)' could be found (are you missing a using directive or an assembly reference?)
            // (1, 1).Property = 1;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Property").WithArguments("(int, int)", "Property").WithLocation(1, 8),
            // (2,12): error CS1061: '(int, int)' does not contain a definition for 'Property' and no accessible extension method 'Property' accepting a first argument of type '(int, int)' could be found (are you missing a using directive or an assembly reference?)
            // _ = (2, 2).Property;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Property").WithArguments("(int, int)", "Property").WithLocation(2, 12));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "(1, 1).Property");
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess1).CandidateReason);

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "(2, 2).Property");
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess2).CandidateReason);
    }

    [Fact]
    public void ConditionalReceiver_MethodGroup_InferredVariable()
    {
        var src = """
bool b = true;
var x = (b ? "" : null).Member;
x();

implicit extension E for string
{
    public void Member() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once instance scenarios are implemented
        //CompileAndVerify(comp, expectedOutput: "set get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, """(b ? "" : null).Member""");
        Assert.Equal("void E.Member()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var x = GetSyntax<VariableDeclaratorSyntax>(tree, """x = (b ? "" : null).Member""");
        Assert.Equal("System.Action x", model.GetDeclaredSymbol(x).ToTestDisplayString());
    }

    [Fact]
    public void ConditionalReceiver_Type_MemberAccess()
    {
        var src = """
bool b = true;
(b ? "" : null).Nested.M();

implicit extension E for string
{
    class Nested
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,17): error CS1061: 'string' does not contain a definition for 'Nested' and no accessible extension method 'Nested' accepting a first argument of type 'string' could be found (are you missing a using directive or an assembly reference?)
            // (b ? "" : null).Nested.M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Nested").WithArguments("string", "Nested").WithLocation(2, 17));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, """(b ? "" : null).Nested""");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void ConditionalReceiver_Property_MemberAccess()
    {
        var src = """
bool b = true;
System.Console.Write((b ? "" : null).Property.ToString());

implicit extension E for string
{
    public int Property => 42;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once instance scenarios are implemented
        //CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, """(b ? "" : null).Property""");
        Assert.Equal("System.Int32 E.Property { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void PropertyAccess_ReturnNotLValue()
    {
        var src = """
object.Property.field = 1;

public struct S
{
    public int field;
}
implicit extension E for object
{
    public static S Property { get => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS1612: Cannot modify the return value of 'E.Property' because it is not a variable
            // object.Property.field = 1;
            Diagnostic(ErrorCode.ERR_ReturnNotLValue, "object.Property").WithArguments("E.Property").WithLocation(1, 1));
    }

    [Fact]
    public void PropertyAccess_RefProperty()
    {
        var src = """
localFuncRef(ref object.Property);
localFuncOut(out object.Property);

void localFuncRef(ref int i) => throw null;
void localFuncOut(out int i) => throw null;

implicit extension E for object
{
    public static int Property { get => throw null; set => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,18): error CS0206: A non ref-returning property or indexer may not be used as an out or ref value
            // localFuncRef(ref object.Property);
            Diagnostic(ErrorCode.ERR_RefProperty, "object.Property").WithLocation(1, 18),
            // (2,18): error CS0206: A non ref-returning property or indexer may not be used as an out or ref value
            // localFuncOut(out object.Property);
            Diagnostic(ErrorCode.ERR_RefProperty, "object.Property").WithLocation(2, 18));
    }

    [Fact]
    public void PropertyAccess_AssignReadonlyNotField()
    {
        var src = """
object.Property = 1;

implicit extension E for object
{
    public static ref readonly int Property { get => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS8331: Cannot assign to property 'Property' or use it as the right hand side of a ref assignment because it is a readonly variable
            // object.Property = 1;
            Diagnostic(ErrorCode.ERR_AssignReadonlyNotField, "object.Property").WithArguments("property", "Property").WithLocation(1, 1));
    }

    [Fact]
    public void PropertyAccess_AssgReadonlyProp()
    {
        var src = """
object.Property = 1;

implicit extension E for object
{
    public static int Property { get => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0200: Property or indexer 'E.Property' cannot be assigned to -- it is read only
            // object.Property = 1;
            Diagnostic(ErrorCode.ERR_AssgReadonlyProp, "object.Property").WithArguments("E.Property").WithLocation(1, 1));
    }

    [Fact]
    public void PropertyAccess_InitOnlyProperty_Static()
    {
        var src = """
object.Property = 1;

implicit extension E for object
{
    public static int Property { init => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,34): error CS8856: The 'init' accessor is not valid on static members
            //     public static int Property { init => throw null; }
            Diagnostic(ErrorCode.ERR_BadInitAccessor, "init").WithLocation(5, 34));
    }

    [Fact]
    public void PropertyAccess_InitOnlyProperty_Instance()
    {
        var src = """
new object().Property = 1;

implicit extension E for object
{
    public int Property { init => throw null; }
}
""";
        // PROTOTYPE(instance) confirm whether init-only accessors should be allowed in extensions
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS8852: Init-only property or indexer 'E.Property' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.
            // new object().Property = 1;
            Diagnostic(ErrorCode.ERR_AssignmentInitOnly, "new object().Property").WithArguments("E.Property").WithLocation(1, 1));
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void PropertyAccess_InitOnlyProperty_Instance_ObjectInitializer()
    {
        var src = """
_ = new object() { Property = 1 };

implicit extension E for object
{
    public int Property { init => throw null; }
}
""";
        // PROTOTYPE(instance) confirm whether init-only accessors should be allowed in extensions
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var assignment = GetSyntax<AssignmentExpressionSyntax>(tree, "Property = 1");
        Assert.Equal("System.Int32 E.Property { init; }", model.GetSymbolInfo(assignment.Left).Symbol.ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void PropertyAccess_InitOnlyProperty_Instance_InConstructor()
    {
        var src = """
implicit extension E for object
{
    E()
    {
        this.Property = 1;
        Property = 2;
    }
    public int Property { init => throw null; }
}
""";
        // PROTOTYPE(instance) confirm whether init-only accessors should be allowed in extensions
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void PropertyAccess_InitOnlyProperty_Instance_InInitAccessor()
    {
        var src = """
implicit extension E for object
{
    public int InitializingProperty
    {
        init
        {
            this.Property = 1;
            Property = 2;
        }
    }

    public int Property { init => throw null; }
}
""";
        // PROTOTYPE(instance) confirm whether init-only accessors should be allowed in extensions
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void PropertyAccess_Static_InaccessibleSetter()
    {
        var src = """
object.Property = 1;

implicit extension E for object
{
    public static int Property { get => throw null; private set => throw null; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0272: The property or indexer 'E.Property' cannot be used in this context because the set accessor is inaccessible
            // object.Property = 1;
            Diagnostic(ErrorCode.ERR_InaccessibleSetter, "object.Property").WithArguments("E.Property").WithLocation(1, 1));
    }

    [Fact]
    public void PropertyAccess_Static_FromExtensionType()
    {
        var src = """
object.M();

implicit extension E for object
{
    public static void M()
    {
        Property = 1;
        Property += 2;
        E.Property = 3;
        E.Property += 4;
        object.Property = 5;
        object.Property += 6;
    }

    public static int Property { get { System.Console.Write("get "); return 10; } set { System.Console.Write($"set({value}) "); } }
}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp, expectedOutput: "set(1) get set(12) set(3) get set(14) set(5) get set(16)")
            .VerifyDiagnostics();
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void PropertyAccess_Instance_FromExtensionType()
    {
        var src = """
new object().M();

implicit extension E for object
{
    public void M()
    {
        Property = 1;
        Property += 2;
        this.Property = 3;
        this.Property += 4;
    }

    public int Property { get { System.Console.Write("get "); return 10; } set { System.Console.Write($"set({value}) "); } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();

        // PROTOTYPE(instance) execute once instance scenarios are implemented
        //CompileAndVerify(comp, expectedOutput: "set(1) get set(12) set(3) get set(14)").VerifyDiagnostics();
    }

    [Fact]
    public void EventAccess_Static()
    {
        var src = """
object.Event += () => { System.Console.Write("ran"); };
object.M();

implicit extension E for object
{
    public static void M()
    {
        _event();
    }
    private static System.Action _event;
    public static event System.Action Event
    {
        add { _event += value; }
        remove { _event -= value; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Event");
        Assert.Equal("event System.Action E.Event", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void EventAccess_Static_Struct()
    {
        var src = """
int.Event += () => { System.Console.Write("ran"); };
int.M();

implicit extension E for int
{
    public static void M()
    {
        _event();
    }
    private static System.Action _event;
    public static event System.Action Event
    {
        add { _event += value; }
        remove { _event -= value; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.Event");
        Assert.Equal("event System.Action E.Event", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void EventAccess_Instance_Struct()
    {
        var src = """
1.Event += () => { };

implicit extension E for int
{
    public event System.Action Event { add { } remove { } }
}
""";
        var comp = CreateCompilation(src);
        // Consider improving the error message
        comp.VerifyEmitDiagnostics(
            // (1,3): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
            // 1.Event += () => { };
            Diagnostic(ErrorCode.ERR_AssgLvalueExpected, "Event").WithLocation(1, 3));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "1.Event");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["event System.Action E.Event"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void EventAccess_Instance_Struct_FieldEvent_Assign()
    {
        var src = """
implicit extension E for int
{
    void M()
    {
        1.Event = null;
    }

    public event System.Action Event;
}
""";
        var comp = CreateCompilation(src);
        // Consider improving the error message
        comp.VerifyEmitDiagnostics(
            // (5,11): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
            //         1.Event = null;
            Diagnostic(ErrorCode.ERR_AssgLvalueExpected, "Event").WithLocation(5, 11),
            // (8,32): error CS9313: 'E.Event': cannot declare instance members with state in extension types.
            //     public event System.Action Event;
            Diagnostic(ErrorCode.ERR_StateInExtension, "Event").WithArguments("E.Event").WithLocation(8, 32));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "1.Event");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["event System.Action E.Event"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void EventAccess_Static_Struct_FieldEvent_AssignOutsideExtensionType()
    {
        var src = """
int.Event = null;

implicit extension E for int
{
    public static event System.Action Event;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0070: The event 'E.Event' can only appear on the left hand side of += or -= (except when used from within the type 'E')
            // int.Event = null;
            Diagnostic(ErrorCode.ERR_BadEventUsage, "Event").WithArguments("E.Event", "E").WithLocation(1, 5));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.Event");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol); // PROTOTYPE need to fix the semantic model
        Assert.Equal(["event System.Action E.Event"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void EventAccess_Static_Struct_FieldEvent_AssignInsideExtensionType()
    {
        var src = """
int.M();

implicit extension E for int
{
    public static void M()
    {
        Event = () => { System.Console.Write("ran"); };
        Event();
    }

    public static event System.Action Event;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var eventAccess = GetSyntax<AssignmentExpressionSyntax>(tree, """Event = () => { System.Console.Write("ran"); }""").Left;
        Assert.Equal("event System.Action E.Event", model.GetSymbolInfo(eventAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void EventAccess_Instance_Struct_StaticFieldEventOnProperty()
    {
        var src = """
C.Property.Event = null;

class C
{
    public static int Property { get; set; }
}

implicit extension E for int
{
    public static event System.Action Event;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0176: Member 'E.Event' cannot be accessed with an instance reference; qualify it with a type name instead
            // C.Property.Event = null;
            Diagnostic(ErrorCode.ERR_ObjectProhibited, "C.Property.Event").WithArguments("E.Event").WithLocation(1, 1),
            // (10,39): warning CS0414: The field 'E.Event' is assigned but its value is never used
            //     public static event System.Action Event;
            Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "Event").WithArguments("E.Event").WithLocation(10, 39));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property.Event");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["event System.Action E.Event"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.StaticInstanceMismatch, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void EventAccess_Instance_Struct_InstanceFieldEventOnProperty()
    {
        var src = """
class C
{
    public static int Property { get; set; }
}

implicit extension E for int
{
    void M()
    {
        C.Property.Event = null;
    }

    public event System.Action Event;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (10,9): error CS1612: Cannot modify the return value of 'C.Property' because it is not a variable
            //         C.Property.Event = null;
            Diagnostic(ErrorCode.ERR_ReturnNotLValue, "C.Property").WithArguments("C.Property").WithLocation(10, 9),
            // (13,32): error CS9313: 'E.Event': cannot declare instance members with state in extension types.
            //     public event System.Action Event;
            Diagnostic(ErrorCode.ERR_StateInExtension, "Event").WithArguments("E.Event").WithLocation(13, 32));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property.Event");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["event System.Action E.Event"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void EventAccess_Instance_Struct_InstanceFieldEventOnProperty_CompoundAssignment()
    {
        var src = """
class C
{
    public static int Property { get; set; }
}

implicit extension E for int
{
    void M()
    {
        C.Property.Event += null;
    }

    public event System.Action Event;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (10,9): error CS1612: Cannot modify the return value of 'C.Property' because it is not a variable
            //         C.Property.Event = null;
            Diagnostic(ErrorCode.ERR_ReturnNotLValue, "C.Property").WithArguments("C.Property").WithLocation(10, 9),
            // (13,32): error CS9313: 'E.Event': cannot declare instance members with state in extension types.
            //     public event System.Action Event;
            Diagnostic(ErrorCode.ERR_StateInExtension, "Event").WithArguments("E.Event").WithLocation(13, 32));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property.Event");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["event System.Action E.Event"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void CheckValueKind_AssignmentToType()
    {
        var src = """
object.Nested = 1;

implicit extension E for object
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0118: 'E.Nested' is a type but is used like a variable
            // object.Nested = 1;
            Diagnostic(ErrorCode.ERR_BadSKknown, "object.Nested").WithArguments("E.Nested", "type", "variable").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Nested");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["E.Nested"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void InvocationOnType()
    {
        var src = """
object.Nested();

implicit extension E for object
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'Nested'
            // object.Nested();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Nested").WithArguments("object", "Nested").WithLocation(1, 8));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Nested");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void AccessOnVoid()
    {
        var src = """
local().Nested = 1;
void local() { }

implicit extension E for object
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0023: Operator '.' cannot be applied to operand of type 'void'
            // local().Nested = 1;
            Diagnostic(ErrorCode.ERR_BadUnaryOp, ".").WithArguments(".", "void").WithLocation(1, 8));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "local().Nested");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void AccessOnVoid_Invocation()
    {
        var src = """
object.M().ToString();

implicit extension E for object
{
    public static void M() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,11): error CS0023: Operator '.' cannot be applied to operand of type 'void'
            // object.M().ToString();
            Diagnostic(ErrorCode.ERR_BadUnaryOp, ".").WithArguments(".", "void").WithLocation(1, 11));
    }

    [Fact]
    public void CheckValueKind_AssignToMethodGroup()
    {
        var src = """
object.M = null;

implicit extension E for object
{
    public static void M() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS1656: Cannot assign to 'M' because it is a 'method group'
            // object.M = null;
            Diagnostic(ErrorCode.ERR_AssgReadonlyLocalCause, "object.M").WithArguments("M", "method group").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void CheckValueKind_AssignToReadonlyField()
    {
        var src = """
object.field = null;

implicit extension E for object
{
    public static readonly int field = 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0198: A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)
            // object.field = null;
            Diagnostic(ErrorCode.ERR_AssgReadonlyStatic, "object.field").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.field");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 E.field"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void CheckFieldValueKind_AssignToReadonlyRefField()
    {
        var src = """
int i = 0;
object.field = ref i;

implicit extension E for object
{
    public static readonly ref int field;
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (2,1): error CS0198: A static readonly field cannot be assigned to (except in a static constructor or a variable initializer)
            // object.field = ref i;
            Diagnostic(ErrorCode.ERR_AssgReadonlyStatic, "object.field").WithLocation(2, 1),
            // (6,36): error CS0106: The modifier 'static' is not valid for this item
            //     public static readonly ref int field;
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "field").WithArguments("static").WithLocation(6, 36),
            // (6,36): error CS9059: A ref field can only be declared in a ref struct.
            //     public static readonly ref int field;
            Diagnostic(ErrorCode.ERR_RefFieldInNonRefStruct, "field").WithLocation(6, 36));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.field");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["ref System.Int32 E.field"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void CheckFieldValueKind_AssignToRefReadonlyField()
    {
        var src = """
object.field = 0;

implicit extension E for object
{
    public static ref readonly int field;
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS8331: Cannot assign to field 'field' or use it as the right hand side of a ref assignment because it is a readonly variable
            // object.field = 0;
            Diagnostic(ErrorCode.ERR_AssignReadonlyNotField, "object.field").WithArguments("field", "field").WithLocation(1, 1),
            // (5,36): error CS0106: The modifier 'static' is not valid for this item
            //     public static ref readonly int field;
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "field").WithArguments("static").WithLocation(5, 36),
            // (5,36): error CS9059: A ref field can only be declared in a ref struct.
            //     public static ref readonly int field;
            Diagnostic(ErrorCode.ERR_RefFieldInNonRefStruct, "field").WithLocation(5, 36));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.field");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["ref readonly System.Int32 E.field"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void CheckFieldValueKind_AddressOfField()
    {
        var src = """
unsafe class C
{
    public static void Main()
    {
        fixed (int* i = &object.field)
        {
            *i = 42;
        }
        System.Console.Write(object.field.ToString());
    }
}

implicit extension E for object
{
    public static int field;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugExe);
        comp.VerifyEmitDiagnostics();
        var verifier = CompileAndVerify(comp, expectedOutput: "42", verify: Verification.Fails).VerifyDiagnostics();
        verifier.VerifyIL("C.Main", """
{
  // Code size       36 (0x24)
  .maxstack  2
  .locals init (int* V_0, //i
                pinned int& V_1)
  IL_0000:  nop
  IL_0001:  ldsflda    "int E.field"
  IL_0006:  stloc.1
  IL_0007:  ldloc.1
  IL_0008:  conv.u
  IL_0009:  stloc.0
  IL_000a:  nop
  IL_000b:  ldloc.0
  IL_000c:  ldc.i4.s   42
  IL_000e:  stind.i4
  IL_000f:  nop
  IL_0010:  ldc.i4.0
  IL_0011:  conv.u
  IL_0012:  stloc.1
  IL_0013:  ldsflda    "int E.field"
  IL_0018:  call       "string int.ToString()"
  IL_001d:  call       "void System.Console.Write(string)"
  IL_0022:  nop
  IL_0023:  ret
}
""");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.field").First();
        Assert.Equal("System.Int32 E.field", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        src = """
unsafe class C
{
    public static void Main()
    {
        fixed (int* i = &D.field)
        {
            *i = 42;
        }
        System.Console.Write(D.field.ToString());
    }
}

static class D
{
    public static int field;
}
""";
        comp = CreateCompilation(src, options: TestOptions.UnsafeDebugExe);
        comp.VerifyEmitDiagnostics();
        verifier = CompileAndVerify(comp, expectedOutput: "42", verify: Verification.Fails).VerifyDiagnostics();
        verifier.VerifyIL("C.Main", """
{
  // Code size       36 (0x24)
  .maxstack  2
  .locals init (int* V_0, //i
                pinned int& V_1)
  IL_0000:  nop
  IL_0001:  ldsflda    "int D.field"
  IL_0006:  stloc.1
  IL_0007:  ldloc.1
  IL_0008:  conv.u
  IL_0009:  stloc.0
  IL_000a:  nop
  IL_000b:  ldloc.0
  IL_000c:  ldc.i4.s   42
  IL_000e:  stind.i4
  IL_000f:  nop
  IL_0010:  ldc.i4.0
  IL_0011:  conv.u
  IL_0012:  stloc.1
  IL_0013:  ldsflda    "int D.field"
  IL_0018:  call       "string int.ToString()"
  IL_001d:  call       "void System.Console.Write(string)"
  IL_0022:  nop
  IL_0023:  ret
}
""");
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void PropertyAccess_Instance_CanModifyStructReceiver()
    {
        var src = """
S s = default;
s.Property = 42;
System.Console.Write(s.field.ToString());

struct S
{
    public int field;
}

implicit extension E for S
{
    public int Property { set => this.field = value; }
}
""";
        if (!CompilationExtensions.EnableVerifyIOperation)
        {
            var comp = CreateCompilation(src);
            // PROTOTYPE(instance) update CheckValue logic
        }
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable once we can lower/emit for non-static scenarios
    public void PropertyAccess_Instance_CanModifyStructReceiver_StructTypeParameterReceiver()
    {
        var src = """
S s = default;
local<S>(s);
System.Console.Write(s.field.ToString());

void local<T>(T t) where T : struct, I
{
    t.Property = 42; // PROTOTYPE(instance) should we produce ERR_AssgLvalueExpected here once we resolve extension members on type parameters?
}

struct S : I
{
    public void SetValue(int value)
    {
        field = value;
    }

    public int field;
}

interface I
{
    void SetValue(int value);
}

implicit extension E for I
{
    public int Property { set => this.SetValue(value); }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (7,7): error CS1061: 'T' does not contain a definition for 'Property' and no accessible extension method 'Property' accepting a first argument of type 'T' could be found (are you missing a using directive or an assembly reference?)
            //     t.Property = 42; // PROTOTYPE(instance) should we produce ERR_AssgLvalueExpected here once we resolve extension members on type parameters?
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Property").WithArguments("T", "Property").WithLocation(7, 7));
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable once we can lower/emit for non-static scenarios
    public void PropertyAccess_Instance_CanModifyStructReceiver_UnconstrainedTypeParameterReceiver()
    {
        var src = """
S s = default;
local<S>(s);
System.Console.Write(s.field.ToString());

void local<T>(T t) where T : I
{
    t.Property = 42; // PROTOTYPE(instance) should we produce ERR_AssgLvalueExpected here once we resolve extension members on type parameters?
}

struct S : I
{
    public void SetValue(int value)
    {
        field = value;
    }

    public int field;
}

interface I
{
    void SetValue(int value);
}

implicit extension E for I
{
    public int Property { set => this.SetValue(value); }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (7,7): error CS1061: 'T' does not contain a definition for 'Property' and no accessible extension method 'Property' accepting a first argument of type 'T' could be found (are you missing a using directive or an assembly reference?)
            //     t.Property = 42; // PROTOTYPE(instance) should we produce ERR_AssgLvalueExpected here once we resolve extension members on type parameters?
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Property").WithArguments("T", "Property").WithLocation(7, 7));
    }

    [Fact]
    public void Lookup_ExtensionNotInScope_Static()
    {
        var src = """
// we'll lookup here
N.E.M();
_ = N.E.Property;

namespace N
{
    public implicit extension E for object
    {
        public static void M()
        {
            System.Console.Write("Method ");
        }

        public static int Property
        {
            get
            {
                System.Console.Write("Property");
                return 0;
            }
        }
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, expectedOutput: "Method Property");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "N.E.M()");
        Assert.Equal("void N.E.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "N.E.Property");
        Assert.Equal("System.Int32 N.E.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());

        var n = ((Compilation)comp).GlobalNamespace.GetNestedNamespace("N");

        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, name: "N.E").ToTestDisplayStrings());
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, name: "E").ToTestDisplayStrings());
        AssertSetStrictlyEqual(["N.E"], model.LookupSymbols(position: 0, n, name: "E").ToTestDisplayStrings());

        var e = n.GetTypeMember("E");
        AssertSetStrictlyEqual(["void N.E.M()"], model.LookupSymbols(position: 0, e, name: "M").ToTestDisplayStrings());
        AssertSetStrictlyEqual(["void N.E.M()"], model.LookupSymbols(position: 0, e, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["System.Int32 N.E.Property { get; }"], model.LookupSymbols(position: 0, e, name: "Property").ToTestDisplayStrings());

        AssertSetStrictlyEqual(["System.Int32 N.E.Property { get; }"],
            model.LookupSymbols(position: 0, e, name: "Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["System.String System.Object.ToString()"], model.LookupSymbols(position: 0, e, name: "ToString").ToTestDisplayStrings());

        AssertSetStrictlyEqual(["System.String System.Object.ToString()"],
            model.LookupSymbols(position: 0, e, name: "ToString", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, o, name: "M").ToTestDisplayStrings());
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, o, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, o, name: "Property").ToTestDisplayStrings());
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, o, name: "Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_Static()
    {
        var src = """
// we'll lookup here
class C { }

implicit extension E for C
{
    public static int StaticField = 0;
    public static int StaticProperty => 0;
    public static void StaticMethod() { }
    public class Nested { }
    public static event System.Action StaticEvent { add { } remove { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        string[] eSymbols = [
            "System.Int32 E.StaticProperty { get; }",
            "void E.StaticMethod()",
            "E.Nested",
            "event System.Action E.StaticEvent",
            "System.Int32 E.StaticField",
            .. objectSymbols];

        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.Nested"], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        string[] eStaticSymbols = [
            "System.Int32 E.StaticProperty { get; }",
            "void E.StaticMethod()",
            "E.Nested",
            "event System.Action E.StaticEvent",
            "System.Int32 E.StaticField",
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

        AssertSetStrictlyEqual(eStaticSymbols, model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.Nested"], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(eStaticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_Instance()
    {
        var src = """
// we'll lookup here
class C { }

implicit extension E for C
{
    public int Property => 0;
    public void Method() { }
    public event System.Action Event { add { } remove { } }
    public int this[int i] => throw null; // We'll look up base members here
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        string[] eSymbols = [
            "System.Int32 E.Property { get; }",
            "void E.Method()",
            "event System.Action E.Event",
            .. objectSymbols];

        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        // Not a valid position for a call to LookupBaseMembers (must be in a type with a base type)
        Assert.Throws<ArgumentException>(() => model.LookupBaseMembers(position: GetSyntax<ThrowExpressionSyntax>(tree, "throw null").SpanStart));
        Assert.Null(e.BaseType);

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        string[] objectStaticSymbols = [
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

        AssertSetStrictlyEqual(objectStaticSymbols,
            model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_ExplicitExtension()
    {
        var src = """
// we'll lookup here
class C { }

explicit extension E for C
{
    public static int StaticField = 0;
    public static int StaticProperty => 0;
    public static void StaticMethod() { }
    public class Nested { }
    public static event System.Action StaticEvent { add { } remove { } }

    public int Property => 0;
    public void Method() { }
    public event System.Action Event { add { } remove { } }
    public int this[int i] => throw null; // We'll look up base members here
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        string[] eSymbols = [
            "System.Int32 E.StaticProperty { get; }",
            "void E.StaticMethod()",
            "E.Nested",
            "event System.Action E.StaticEvent",
            "System.Int32 E.Property { get; }",
            "void E.Method()",
            "event System.Action E.Event",
            "System.Int32 E.StaticField",
            .. objectSymbols];

        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.Nested"], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        string[] objectStaticSymbols = [
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

        string[] eStaticSymbols = [
            "System.Int32 E.StaticProperty { get; }",
            "void E.StaticMethod()",
            "E.Nested",
            "event System.Action E.StaticEvent",
            "System.Int32 E.StaticField",
            .. objectStaticSymbols];

        AssertSetStrictlyEqual(eStaticSymbols, model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_GenericNestedType()
    {
        var src = """
// we'll lookup here
int x = object.StaticType<string>;

implicit extension E for object
{
    void M2() => throw null; // We'll look up base members here

    public static class StaticType<U>
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,9): error CS0119: 'E.StaticType<string>' is a type, which is not valid in the given context
            // int x = object.StaticType<string>;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "object.StaticType<string>").WithArguments("E.StaticType<string>", "type").WithLocation(2, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticType<string>");
        Assert.Equal("E.StaticType<System.String>", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");
        AssertSetStrictlyEqual(["E.StaticType<U>"], model.LookupSymbols(position: 0, e, name: "StaticType").ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.StaticType<U>"],
            model.LookupSymbols(position: 0, e, name: "StaticType", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.StaticType<U>"], model.LookupStaticMembers(position: 0, e, name: "StaticType").ToTestDisplayStrings());

        // Not a valid position for a call to LookupBaseMembers (must be in a type with a base type)
        Assert.Throws<ArgumentException>(() => model.LookupBaseMembers(position: GetSyntax<ThrowExpressionSyntax>(tree, "throw null").SpanStart));
        Assert.Null(e.BaseType);

        AssertSetStrictlyEqual(["E.StaticType<U>"], model.LookupNamespacesAndTypes(position: 0, e, name: "StaticType").ToTestDisplayStrings());
        AssertSetStrictlyEqual(["E.StaticType<U>"], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.StaticType<U>"], model.LookupStaticMembers(position: 0, e, name: "StaticType").ToTestDisplayStrings());

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, o, name: "StaticType").ToTestDisplayStrings());

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([],
            model.LookupSymbols(position: 0, o, name: "StaticType", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, o, name: "StaticType").ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.StaticType<U>"], model.LookupNamespacesAndTypes(position: 0, o, name: "StaticType").ToTestDisplayStrings());
        AssertSetStrictlyEqual(["E.StaticType<U>"], model.LookupNamespacesAndTypes(position: 0, o).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.StaticType<U>"], model.LookupStaticMembers(position: 0, o, name: "StaticType").ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_FromAnotherExtension_Static()
    {
        var src = """
// we'll lookup here
class C { }

implicit extension E for C { }

implicit extension E2 for C
{
    public static int StaticField = 0;
    public static int StaticProperty => 0;
    public static void StaticMethod() { }
    public class Nested { }
    public static event System.Action StaticEvent { add { } remove { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, e, name: "Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E2.Nested"], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        string[] e2StaticSymbols = [
            .. objectStaticSymbols,
            "System.Int32 E2.StaticProperty { get; }",
            "void E2.StaticMethod()",
            "E2.Nested",
            "event System.Action E2.StaticEvent",
            "System.Int32 E2.StaticField"];

        AssertSetStrictlyEqual(e2StaticSymbols, model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_FromAnotherExtension_Instance()
    {
        var src = """
// we'll lookup here
class C { }

implicit extension E for C { }

implicit extension E2 for C
{
    public int Property => 0;
    public void Method() { }
    public event System.Action Event { add { } remove { } }
    public int this[int i] => throw null; // We'll look up base members here
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, e, name: "Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        // Not a valid position for a call to LookupBaseMembers (must be in a type with a base type)
        Assert.Throws<ArgumentException>(() => model.LookupBaseMembers(position: GetSyntax<ThrowExpressionSyntax>(tree, "throw null").SpanStart));
        Assert.Null(e.BaseType);

        // PROTOTYPE(static) should LookupNamespacesAndTypes and LookupStaticMembers include extension members?
        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        AssertSetStrictlyEqual([
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"],
            model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_FromAnotherExtension_FromAnotherFile()
    {
        var src1 = """
// we'll lookup here
class C { }

implicit extension E for C { }
""";
        var src2 = """
file implicit extension E2 for C
{
    public static int StaticField = 0;
}
""";
        var comp = CreateCompilation([(src1, "src1"), (src2, "src2")]);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupSymbols(position: 0, e, name: "StaticField", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        AssertSetStrictlyEqual([
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"],
            model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_UnderlyingTypeMembers_Public()
    {
        var src = """
// we'll lookup here
class C
{
    public static int Field = 0;
    public static int Property => 0;
    public static void Method() { }
    public class Nested { }
    public static event System.Action Event { add { } remove { } }
}

implicit extension E for C
{
    private void M() => throw null; // We'll look up base members here
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");
        string[] cSymbols = [
            "System.Int32 C.Property { get; }",
            "void C.Method()",
            "C.Nested",
            "event System.Action C.Event",
            "System.Int32 C.Field",
            .. objectSymbols];

        AssertSetStrictlyEqual(cSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(cSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        // Not a valid position for a call to LookupBaseMembers (must be in a type with a base type)
        Assert.Throws<ArgumentException>(() => model.LookupBaseMembers(position: GetSyntax<ThrowExpressionSyntax>(tree, "throw null").SpanStart));
        Assert.Null(e.BaseType);

        AssertSetStrictlyEqual(["C.Nested"], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        string[] staticSymbols = [
            "System.Int32 C.Property { get; }",
            "void C.Method()",
            "C.Nested",
            "event System.Action C.Event",
            "System.Int32 C.Field",
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

        AssertSetStrictlyEqual(staticSymbols, model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(cSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(cSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["C.Nested"], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());

        AssertSetStrictlyEqual(staticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_UnderlyingTypeMembers_Protected()
    {
        var src = """
// we'll lookup here
class C
{
    // we'll also lookup here
    protected static int Field = 0;
    protected static int Property => 0;
    protected static void Method() { }
    protected class Nested { }
    protected static event System.Action Event { add { } remove { } }
}

implicit extension E for C
{
    // we'll also lookup here
    private void M() => throw null; // We'll look up base members here
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");
        string[] objectPublicSymbols = [
            "System.String System.Object.ToString()",
            "System.Boolean System.Object.Equals(System.Object obj)",
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Int32 System.Object.GetHashCode()",
            "System.Type System.Object.GetType()",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

        AssertSetStrictlyEqual(objectPublicSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectPublicSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        // Not a valid position for a call to LookupBaseMembers (must be in a type with a base type)
        Assert.Throws<ArgumentException>(() => model.LookupBaseMembers(position: GetSyntax<ThrowExpressionSyntax>(tree, "throw null").SpanStart));
        Assert.Null(e.BaseType);

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        string[] staticSymbols = [
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];
        AssertSetStrictlyEqual(staticSymbols, model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectPublicSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());

        AssertSetStrictlyEqual(objectPublicSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        string[] symbolsWithinCFromC = [
            "System.Int32 C.Property { get; }",
            "void C.Method()",
            "C.Nested",
            "event System.Action C.Event",
            "System.Int32 C.Field",
            "System.String System.Object.ToString()",
            "System.Boolean System.Object.Equals(System.Object obj)",
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "void System.Object.Finalize()",
            "System.Int32 System.Object.GetHashCode()",
            "System.Type System.Object.GetType()",
            "System.Object System.Object.MemberwiseClone()",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

        int positionInC = src.IndexOf("protected");
        AssertSetStrictlyEqual(symbolsWithinCFromC, model.LookupSymbols(position: positionInC, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(symbolsWithinCFromC, model.LookupSymbols(position: positionInC, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        string[] symbolsWithinEFromC = [
            "System.Int32 C.Property { get; }",
            "void C.Method()",
            "C.Nested",
            "event System.Action C.Event",
            "System.Int32 C.Field",
            .. objectPublicSymbols];

        AssertSetStrictlyEqual(symbolsWithinEFromC, model.LookupSymbols(position: positionInC, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(symbolsWithinEFromC, model.LookupSymbols(position: positionInC, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        string[] symbolsWithinEFromE = [
            "void E.M()",
            .. objectPublicSymbols];

        int positionInE = src.IndexOf("private");
        AssertSetStrictlyEqual(symbolsWithinEFromE, model.LookupSymbols(position: positionInE, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(symbolsWithinEFromE, model.LookupSymbols(position: positionInE, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());

        AssertSetStrictlyEqual(staticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_UnderlyingTypeMembers_Private()
    {
        var src = """
// we'll lookup here
class C
{
    // we'll also lookup here
    private static int Field = 0;
    private static int Property => 0;
    private static void Method() { }
    private class Nested { }
    private static event System.Action Event { add { } remove { } }
}

implicit extension E for C
{
    private void M() => throw null; // We'll look up base members here
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,24): warning CS0414: The field 'C.Field' is assigned but its value is never used
            //     private static int Field = 0;
            Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "Field").WithArguments("C.Field").WithLocation(5, 24));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        // Not a valid position for a call to LookupBaseMembers (must be in a type with a base type)
        int positionInE = GetSyntax<ThrowExpressionSyntax>(tree, "throw null").SpanStart;
        Assert.Throws<ArgumentException>(() => { return model.LookupBaseMembers(position: positionInE); });
        Assert.Null(e.BaseType);

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        string[] staticSymbols = [
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];
        AssertSetStrictlyEqual(staticSymbols, model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        string[] symbolsWithinCFromC = [
            "System.Int32 C.Property { get; }",
            "void C.Method()",
            "C.Nested",
            "event System.Action C.Event",
            "System.Int32 C.Field",
            "System.String System.Object.ToString()",
            "System.Boolean System.Object.Equals(System.Object obj)",
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "void System.Object.Finalize()",
            "System.Int32 System.Object.GetHashCode()",
            "System.Type System.Object.GetType()",
            "System.Object System.Object.MemberwiseClone()",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

        int positionInC = src.IndexOf("private");
        AssertSetStrictlyEqual(symbolsWithinCFromC, model.LookupSymbols(position: positionInC, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(symbolsWithinCFromC, model.LookupSymbols(position: positionInC, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        string[] symbolsWithinEFromC = [
            "System.Int32 C.Property { get; }",
            "void C.Method()",
            "C.Nested",
            "event System.Action C.Event",
            "System.Int32 C.Field",
            .. objectSymbols];

        AssertSetStrictlyEqual(symbolsWithinEFromC, model.LookupSymbols(position: positionInC, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(symbolsWithinEFromC, model.LookupSymbols(position: positionInC, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        string[] symbolsWithinEFromE = [
            "void E.M()",
            .. objectSymbols];

        AssertSetStrictlyEqual(symbolsWithinEFromE, model.LookupSymbols(position: positionInE, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(symbolsWithinEFromE, model.LookupSymbols(position: positionInE, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());

        AssertSetStrictlyEqual(staticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_TypeParameter()
    {
        var src = """
class Container<T>
{
    void M() => throw null; // we'll lookup here

    void M2()
    {
        _ = T.Field;
        T.Nested x = default;
    }

    implicit extension E for T
    {
        public static int Field = 0;
        public class Nested { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (7,13): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         _ = T.Field;
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(7, 13),
            // (8,9): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         T.Nested x = default;
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T.Nested").WithArguments("T").WithLocation(8, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var position = GetSyntax<ThrowExpressionSyntax>(tree, "throw null").SpanStart;

        var t = ((Compilation)comp).GlobalNamespace.GetTypeMember("Container").TypeParameters[0];

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position, t).ToTestDisplayStrings());
        // PROTOTYPE(static) need to confirm what we want for extension members on type parameters or values of type parameters
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position, t, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position, t).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_Interface_Static()
    {
        var src = """
// we'll lookup here
interface I { }

implicit extension E for I
{
    public static int StaticField = 0;
    public static int StaticProperty => 0;
    public static void StaticMethod() { }
    public class Nested { }
    public static event System.Action StaticEvent { add { } remove { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var i = ((Compilation)comp).GlobalNamespace.GetTypeMember("I");

        string[] objectStaticSymbols = [
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, i).ToTestDisplayStrings());

        string[] eStaticSymbols = [
            .. objectStaticSymbols,
            "System.Int32 E.StaticProperty { get; }",
            "void E.StaticMethod()",
            "E.Nested",
            "event System.Action E.StaticEvent",
            "System.Int32 E.StaticField"];

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, i, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.Nested"], model.LookupNamespacesAndTypes(position: 0, i).ToTestDisplayStrings());
        AssertSetStrictlyEqual(eStaticSymbols, model.LookupStaticMembers(position: 0, i).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_Interface_Instance()
    {
        var src = """
// we'll lookup here
interface I { }

implicit extension E for I
{
    public int Property => 0;
    public void Method() { }
    public event System.Action Event { add { } remove { } }
    public int this[int i] => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var i = ((Compilation)comp).GlobalNamespace.GetTypeMember("I");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, i).ToTestDisplayStrings());

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, i, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, i).ToTestDisplayStrings());
        AssertSetStrictlyEqual([
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"],
            model.LookupStaticMembers(position: 0, i).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_Interface_FromBaseInterface_Static()
    {
        var src = """
// we'll lookup here
interface IBase { }
interface I : IBase { }

implicit extension E for IBase
{
    public static int StaticField = 0;
    public static int StaticProperty => 0;
    public static void StaticMethod() { }
    public class Nested { }
    public static event System.Action StaticEvent { add { } remove { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var i = ((Compilation)comp).GlobalNamespace.GetTypeMember("I");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, i).ToTestDisplayStrings());

        string[] eStaticSymbols = [
            .. objectStaticSymbols,
            "System.Int32 E.StaticProperty { get; }",
            "void E.StaticMethod()",
            "E.Nested",
            "event System.Action E.StaticEvent",
            "System.Int32 E.StaticField"];

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, i, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.Nested"], model.LookupNamespacesAndTypes(position: 0, i).ToTestDisplayStrings());
        AssertSetStrictlyEqual(eStaticSymbols, model.LookupStaticMembers(position: 0, i).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_Interface_FromBaseInterface_Instance()
    {
        var src = """
// we'll lookup here
interface IBase { }
interface I : IBase { }

implicit extension E for IBase
{
    public int Property => 0;
    public void Method() { }
    public event System.Action Event { add { } remove { } }
    public int this[int i] => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var i = ((Compilation)comp).GlobalNamespace.GetTypeMember("I");
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, i).ToTestDisplayStrings());

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, i, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, i).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, i).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_Interface_FromBaseInterface_Inaccessible_Static()
    {
        var src = """
// we'll lookup here
interface IBase { }

/// <summary>
/// <see cref=" we'll also lookup here "/>.
/// </summary>
interface I : IBase { }

implicit extension E for IBase
{
    private static int StaticField = 0;
    private static int StaticProperty => 0;
    private static void StaticMethod() { }
    private class Nested { }
    private static event System.Action StaticEvent { add { } remove { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (11,24): warning CS0414: The field 'E.StaticField' is assigned but its value is never used
            //     private static int StaticField = 0;
            Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "StaticField").WithArguments("E.StaticField").WithLocation(11, 24));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var i = ((Compilation)comp).GlobalNamespace.GetTypeMember("I");
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, i).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, i, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        string[] eStaticSymbols = [
            .. objectStaticSymbols,
            "System.Int32 E.StaticProperty { get; }",
            "void E.StaticMethod()",
            "E.Nested",
            "event System.Action E.StaticEvent",
            "System.Int32 E.StaticField"];

        int crefPosition = src.IndexOf("we'll also lookup here", StringComparison.Ordinal);
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([], model.LookupSymbols(position: crefPosition, i, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, i).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, i).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_Interface_FromBaseInterface_Inaccessible_Instance()
    {
        var src = """
// we'll lookup here
interface IBase { }

/// <summary>
/// <see cref=" we'll also lookup here "/>.
/// </summary>
interface I : IBase { }

implicit extension E for IBase
{
    private int Property => 0;
    private void Method() { }
    private event System.Action Event { add { } remove { } }
    private int this[int i] => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var i = ((Compilation)comp).GlobalNamespace.GetTypeMember("I");
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, i).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, i, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        string[] eSymbols = [
            "System.Int32 E.Property { get; }",
            "void E.Method()",
            "event System.Action E.Event"];

        int crefPosition = src.IndexOf("we'll also lookup here", StringComparison.Ordinal);
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual([], model.LookupSymbols(position: crefPosition, i, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, i).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, i).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_ForT_Static()
    {
        var source = """
// we'll lookup here
int.StaticMethod();

public implicit extension E<T> for T where T : struct
{
    public static int StaticField = 0;
    public static int StaticProperty => 0;
    public static void StaticMethod() { System.Console.Write("ran"); }
    public class Nested { }
    public static event System.Action StaticEvent { add { } remove { } }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, o).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, o, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, o).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, o).ToTestDisplayStrings());

        var n = ((Compilation)comp).GetSpecialType(SpecialType.System_Nullable_T);
        string[] nullableInstanceSymbols = [
            "T System.Nullable<T>.Value { get; }",
            "System.Boolean System.Nullable<T>.Equals(System.Object other)",
            "System.Boolean System.ValueType.Equals(System.Object obj)",
            "System.Boolean System.Object.Equals(System.Object obj)",
            "System.Int32 System.Nullable<T>.GetHashCode()",
            "System.Int32 System.ValueType.GetHashCode()",
            "System.Int32 System.Object.GetHashCode()",
            "T System.Nullable<T>.GetValueOrDefault()",
            "T System.Nullable<T>.GetValueOrDefault(T defaultValue)",
            "System.String System.Nullable<T>.ToString()",
            "System.String System.ValueType.ToString()",
            "System.String System.Object.ToString()",
            "System.Boolean System.Nullable<T>.HasValue { get; }",
            "System.Type System.Object.GetType()"];

        string[] nullableStaticSymbols = [
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

        AssertSetStrictlyEqual([.. nullableInstanceSymbols, .. nullableStaticSymbols], model.LookupSymbols(position: 0, n).ToTestDisplayStrings());

        AssertSetStrictlyEqual([.. nullableInstanceSymbols, .. nullableStaticSymbols],
            model.LookupSymbols(position: 0, n, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, n).ToTestDisplayStrings());
        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, n).ToTestDisplayStrings());

        var int32 = ((Compilation)comp).GetSpecialType(SpecialType.System_Int32);
        AssertSetStrictlyEqual([
            .. objectStaticSymbols,
            "System.Int32 E<System.Int32>.StaticProperty { get; }",
            "void E<System.Int32>.StaticMethod()",
            "E<System.Int32>.Nested",
            "event System.Action E<System.Int32>.StaticEvent",
            "System.Int32 E<System.Int32>.StaticField"],
            model.LookupStaticMembers(position: 0, int32).Where(m => m.ContainingType.Name != "Int32").ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_ForT_Instance()
    {
        var source = """
// we'll lookup here
public implicit extension E<T> for T where T : struct
{
    public int Property => 0;
    public void Method() { }
    public event System.Action Event { add { } remove { } }
    public int this[int i] => throw null;
}
""";
        var comp = CreateCompilation(source);
        // PROTOTYPE should warn about hiding
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, o).ToTestDisplayStrings());

        string[] eSymbols = [
            .. objectSymbols,
            "System.Int32 E<System.Object>.Property { get; }",
            "void E<System.Object>.Method()",
            "event System.Action E<System.Object>.Event"];
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, o, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, o).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, o).ToTestDisplayStrings());

        var n = ((Compilation)comp).GetSpecialType(SpecialType.System_Nullable_T);
        string[] nullableSymbols = [
            "T System.Nullable<T>.Value { get; }",
            "System.Boolean System.Nullable<T>.Equals(System.Object other)",
            "System.Boolean System.ValueType.Equals(System.Object obj)",
            "System.Boolean System.Object.Equals(System.Object obj)",
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Int32 System.Nullable<T>.GetHashCode()",
            "System.Int32 System.ValueType.GetHashCode()",
            "System.Int32 System.Object.GetHashCode()",
            "T System.Nullable<T>.GetValueOrDefault()",
            "T System.Nullable<T>.GetValueOrDefault(T defaultValue)",
            "System.String System.Nullable<T>.ToString()",
            "System.String System.ValueType.ToString()",
            "System.String System.Object.ToString()",
            "System.Boolean System.Nullable<T>.HasValue { get; }",
            "System.Type System.Object.GetType()",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

        AssertSetStrictlyEqual(nullableSymbols, model.LookupSymbols(position: 0, n).ToTestDisplayStrings());

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(nullableSymbols,
            model.LookupSymbols(position: 0, n, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, n).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, n).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_MustCallMethodsDirectly()
    {
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit R1
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: false)}}'(object '') cil managed
    {
        IL_0000: ret
    }

    .method public hidebysig specialname newslot static int32 get_Item ( int32 x ) cil managed
    {
        IL_0000: ldnull
        IL_0001: throw
    }

    .method public hidebysig specialname newslot static void set_Item ( int32 x, int32 'value' ) cil managed
    {
        IL_0000: ldnull
        IL_0001: throw
    }

    .property int32 Item( int32 x )
    {
        .get int32 R1::get_Item(int32)
        .set void R1::set_Item(int32, int32)
    }
}
""";
        var src = """
// We'll lookup here
_ = new object().Item[42];
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyEmitDiagnostics(
            // (2,18): error CS1061: 'object' does not contain a definition for 'Item' and no accessible extension method 'Item' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // _ = new object().Item[42];
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Item").WithArguments("object", "Item").WithLocation(2, 18));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, o, includeReducedExtensionMethods: true).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_HidingLessSpecific_Static_Field()
    {
        var src = """
// we'll lookup here
public class Base { }
public class C : Base { }

public implicit extension EBase for Base
{
    public static int StaticField = 0;
}

public implicit extension E for C
{
    public static int StaticField = 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual([
            .. objectStaticSymbols,
            "System.Int32 E.StaticField"],
            model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_HidingLessSpecific_Static_ExtensionNestedType()
    {
        var src = """
// we'll lookup here
public class Base { }
public class C : Base { }

public implicit extension EBase for Base
{
    public class Nested { }
}

public implicit extension E for C
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.Nested"], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());

        AssertSetStrictlyEqual([
            .. objectStaticSymbols,
            "E.Nested"],
            model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_HidingLessSpecific_Static_Property()
    {
        var src = """
// we'll lookup here
public class Base { }
public class C : Base { }

public implicit extension EBase for Base
{
    public static int Property { get => 0; }
}

public implicit extension E for C
{
    public static int Property { set { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());

        AssertSetStrictlyEqual([
            .. objectStaticSymbols,
            "System.Int32 E.Property { set; }"],
            model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_HidingLessSpecific_Instance_Property()
    {
        var src = """
// we'll lookup here
public class Base { }
public class C : Base { }

public implicit extension EBase for Base
{
    public int Property { get => 0; }
}

public implicit extension E for C
{
    public int Property { set { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());

        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());

        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_Ambiguous_Static()
    {
        var src = """
// we'll lookup here
class C { }

implicit extension E for C
{
    public static int StaticField = 0;
    public static int StaticProperty => 0;
    public static void StaticMethod() { }
    public class Nested { }
    public static event System.Action StaticEvent { add { } remove { } }
}

implicit extension E2 for C
{
    public static int StaticField = 0;
    public static int StaticProperty => 0;
    public static void StaticMethod() { }
    public class Nested { }
    public static event System.Action StaticEvent { add { } remove { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        string[] eSymbols = [
            "System.Int32 E.StaticProperty { get; }",
            "void E.StaticMethod()",
            "E.Nested",
            "event System.Action E.StaticEvent",
            "System.Int32 E.StaticField",
            .. objectSymbols];

        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        string[] allStaticSymbols = [
            "System.Int32 E.StaticProperty { get; }",
            "void E.StaticMethod()",
            "E.Nested",
            "event System.Action E.StaticEvent",
            "System.Int32 E.StaticField",
            .. objectStaticSymbols,
            "System.Int32 E2.StaticProperty { get; }",
            "void E2.StaticMethod()",
            "E2.Nested",
            "event System.Action E2.StaticEvent",
            "System.Int32 E2.StaticField"];

        AssertSetStrictlyEqual(allStaticSymbols, model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.Nested", "E2.Nested"], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        AssertSetStrictlyEqual(allStaticSymbols,
            model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.Nested", "E2.Nested"], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(allStaticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_Ambiguous_Instance()
    {
        var src = """
// we'll lookup here
class C { }

implicit extension E for C
{
    public int Property => 0;
    public void Method() { }
    public event System.Action Event { add { } remove { } }
    public int this[int i] => throw null;
}

implicit extension E2 for C
{
    public int Property => 0;
    public void Method() { }
    public event System.Action Event { add { } remove { } }
    public int this[int i] => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        string[] eSymbols = [
            "System.Int32 E.Property { get; }",
            "void E.Method()",
            "event System.Action E.Event",
            .. objectSymbols];

        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_MatchNonZeroArity_Static()
    {
        var src = """
// we'll lookup here
class C { }

implicit extension E for C
{
    public static void StaticMethod() { }
    public static void StaticMethod<T>() { }
    public class Nested { }
    public class Nested<T> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        string[] eSymbols = [
            "void E.StaticMethod()",
            "void E.StaticMethod<T>()",
            "E.Nested",
            "E.Nested<T>",
            .. objectSymbols];

        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.Nested", "E.Nested<T>"], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        string[] eStaticSymbols = [
            "void E.StaticMethod()",
            "void E.StaticMethod<T>()",
            "E.Nested",
            "E.Nested<T>",
            .. objectStaticSymbols];
        AssertSetStrictlyEqual(eStaticSymbols,
            model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["E.Nested", "E.Nested<T>"], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(eStaticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_MatchNonZeroArity_Instance()
    {
        var src = """
// we'll lookup here
class C { }

implicit extension E for C
{
    public void Method() { }
    public void Method<T>() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        string[] eSymbols = [
            "void E.Method()",
            "void E.Method<T>()",
            .. objectSymbols];

        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_Private()
    {
        var src = """
// we'll lookup here
class C { }

implicit extension E for C
{
    private void StaticMethod() { }
    private class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_FileAccess()
    {
        var src = """
// we'll lookup here
class C { }
""";
        var src2 = """
file implicit extension E for C
{
    private void StaticMethod() { }
    private class Nested { }
}
file implicit extension E2 for C
{
    private void StaticMethod2() { }
    private class Nested2 { }
}
""";
        var comp = CreateCompilation([(src, "src"), (src2, "src2")]);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, e).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, e).ToTestDisplayStrings());

        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, e).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_MultipleScopes_ExtensionNestedTypes()
    {
        var src = """
class C { }

namespace Outer
{
    namespace Inner
    {
        class D
        {
            void M() => throw null; // we'll lookup here
        }

        implicit extension E for C
        {
            public class Nested { }
        }
    }

    implicit extension E2 for C
    {
        public class Nested { }
        public class Nested2 { }
    }
}

implicit extension E3 for C
{
    public class Nested { }
    public class Nested2 { }
    public class Nested3 { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var position = GetSyntax<ThrowExpressionSyntax>(tree, "throw null").SpanStart;

        var e = ((Compilation)comp).GlobalNamespace.GetNestedNamespace("Outer").GetNestedNamespace("Inner").GetTypeMember("E");

        string[] eSymbols = ["Outer.Inner.E.Nested", .. objectSymbols];

        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position, e).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual(["Outer.Inner.E.Nested", "Outer.E2.Nested2", "E3.Nested3"],
            model.LookupNamespacesAndTypes(position, e).ToTestDisplayStrings());

        string[] cStaticSymbols = [
            "Outer.Inner.E.Nested",
            "Outer.E2.Nested2",
            "E3.Nested3",
            .. objectStaticSymbols];

        AssertSetStrictlyEqual(cStaticSymbols, model.LookupStaticMembers(position, e).ToTestDisplayStrings());

        var e2 = ((Compilation)comp).GlobalNamespace.GetNestedNamespace("Outer").GetTypeMember("E2");

        string[] e2Symbols = [
            "Outer.E2.Nested",
            "Outer.E2.Nested2",
            .. objectSymbols];

        AssertSetStrictlyEqual(e2Symbols, model.LookupSymbols(position, e2).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(e2Symbols, model.LookupSymbols(position, e2, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        // Note: we include extension member E.Nested despite having already found an instance member E2.Nested
        string[] e2TypeSymbols = [
            "Outer.E2.Nested",
            "Outer.E2.Nested2",
            "Outer.Inner.E.Nested",
            "E3.Nested3"];

        AssertSetStrictlyEqual(e2TypeSymbols, model.LookupNamespacesAndTypes(position, e2).ToTestDisplayStrings());
        AssertSetStrictlyEqual([.. e2TypeSymbols, .. objectStaticSymbols], model.LookupStaticMembers(position, e2).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        string[] cTypeSymbols = [
            "Outer.Inner.E.Nested",
            "Outer.E2.Nested2",
            "E3.Nested3"];

        AssertSetStrictlyEqual(cTypeSymbols, model.LookupNamespacesAndTypes(position, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual([.. cTypeSymbols, .. objectStaticSymbols], model.LookupStaticMembers(position, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_MultipleScopes_Methods_Static()
    {
        var src = """
class C { }

namespace Outer
{
    namespace Inner
    {
        class D
        {
            void M() => throw null; // we'll lookup here
        }

        implicit extension E for C
        {
            public static void StaticMethod() { }
        }
    }

    implicit extension E2 for C
    {
        public static void StaticMethod() { }
        public static void StaticMethod2() { }
    }
}

implicit extension E3 for C
{
    public static void StaticMethod() { }
    public static void StaticMethod2() { }
    public static void StaticMethod3() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var position = GetSyntax<ThrowExpressionSyntax>(tree, "throw null").SpanStart;

        var e = ((Compilation)comp).GlobalNamespace.GetNestedNamespace("Outer").GetNestedNamespace("Inner").GetTypeMember("E");

        string[] eSymbols = [
            "void Outer.Inner.E.StaticMethod()",
            .. objectSymbols];

        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position, e).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(eSymbols, model.LookupSymbols(position, e, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position, e).ToTestDisplayStrings());

        string[] eStaticSymbols = [
            "void Outer.Inner.E.StaticMethod()",
            "void Outer.E2.StaticMethod2()",
            "void E3.StaticMethod3()",
            .. objectStaticSymbols];

        AssertSetStrictlyEqual(eStaticSymbols, model.LookupStaticMembers(position, e).ToTestDisplayStrings());

        var e2 = ((Compilation)comp).GlobalNamespace.GetNestedNamespace("Outer").GetTypeMember("E2");

        string[] e2Symbols = [
            "void Outer.E2.StaticMethod2()",
            "void Outer.E2.StaticMethod()",
            .. objectSymbols];
        AssertSetStrictlyEqual(e2Symbols, model.LookupSymbols(position, e2).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(e2Symbols, model.LookupSymbols(position, e2, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position, e2).ToTestDisplayStrings());
        string[] e2StaticSymbols = [
            "void Outer.E2.StaticMethod2()",
            "void Outer.E2.StaticMethod()",
            "void Outer.Inner.E.StaticMethod()",
            "void E3.StaticMethod3()",
            .. objectStaticSymbols];

        AssertSetStrictlyEqual(e2StaticSymbols, model.LookupStaticMembers(position, e2).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position, c).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position, c).ToTestDisplayStrings());
        string[] cStaticSymbols = [
            "void Outer.Inner.E.StaticMethod()",
            "void Outer.E2.StaticMethod2()",
            "void E3.StaticMethod3()",
            .. objectStaticSymbols];

        AssertSetStrictlyEqual(cStaticSymbols, model.LookupStaticMembers(position, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_MultipleScopes_FieldsAndProperties_Static()
    {
        var src = """
class C { }

namespace Outer
{
    namespace Inner
    {
        class D
        {
            void M() => throw null; // we'll lookup here
        }

        implicit extension EInner1 for C
        {
            public static int M = 0;
        }

        implicit extension EInner2 for C
        {
            public static int M => 0;
        }
    }

    implicit extension EOuter1 for C
    {
        public static int M = 0;
        public static int M2 = 0;
    }

    implicit extension EOuter2 for C
    {
        public static int M => 0;
        public static int M2 => 0;
    }
}

implicit extension ETop1 for C
{
    public static int M = 0;
    public static int M2 = 0;
    public static int M3 = 0;
}

implicit extension ETop2 for C
{
    public static int M => 0;
    public static int M2 => 0;
    public static int M3 => 0;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var position = GetSyntax<ThrowExpressionSyntax>(tree, "throw null").SpanStart;

        var eInner1 = ((Compilation)comp).GlobalNamespace.GetNestedNamespace("Outer").GetNestedNamespace("Inner").GetTypeMember("EInner1");

        string[] eInner1Symbols = [
            "System.Int32 Outer.Inner.EInner1.M",
            .. objectSymbols];

        AssertSetStrictlyEqual(eInner1Symbols, model.LookupSymbols(position, eInner1).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(eInner1Symbols, model.LookupSymbols(position, eInner1, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position, eInner1).ToTestDisplayStrings());

        string[] eInner1StaticSymbols = [
            "System.Int32 Outer.Inner.EInner1.M",
            "System.Int32 Outer.Inner.EInner2.M { get; }",
            "System.Int32 Outer.EOuter2.M2 { get; }",
            "System.Int32 Outer.EOuter1.M2",
            "System.Int32 ETop2.M3 { get; }",
            "System.Int32 ETop1.M3",
            .. objectStaticSymbols];

        AssertSetStrictlyEqual(eInner1StaticSymbols, model.LookupStaticMembers(position, eInner1).ToTestDisplayStrings());

        var eOuter1 = ((Compilation)comp).GlobalNamespace.GetNestedNamespace("Outer").GetTypeMember("EOuter1");

        string[] eOuter1Symbols = [
            "System.Int32 Outer.EOuter1.M2",
            "System.Int32 Outer.EOuter1.M",
            .. objectSymbols];

        AssertSetStrictlyEqual(eOuter1Symbols, model.LookupSymbols(position, eOuter1).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(eOuter1Symbols, model.LookupSymbols(position, eOuter1, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position, eOuter1).ToTestDisplayStrings());

        // Note: we include extension members EInner1.M and EInner2.M despite having already found an instance member EOuter1.M
        string[] eOuter1StaticSymbols = [
            "System.Int32 Outer.Inner.EInner1.M",
            "System.Int32 Outer.Inner.EInner2.M { get; }",
            "System.Int32 Outer.EOuter1.M",
            "System.Int32 Outer.EOuter1.M2",
            "System.Int32 Outer.EOuter2.M2 { get; }",
            "System.Int32 ETop2.M3 { get; }",
            "System.Int32 ETop1.M3",
            .. objectStaticSymbols];

        AssertSetStrictlyEqual(eOuter1StaticSymbols, model.LookupStaticMembers(position, eOuter1).ToTestDisplayStrings());

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position, c).ToTestDisplayStrings());
        // PROTOTYPE(instance) We'll want LookupSymbols to return extension type members too
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position, c).ToTestDisplayStrings());

        string[] cStaticSymbols = [
            "System.Int32 Outer.Inner.EInner1.M",
            "System.Int32 Outer.Inner.EInner2.M { get; }",
            "System.Int32 Outer.EOuter1.M2",
            "System.Int32 Outer.EOuter2.M2 { get; }",
            "System.Int32 ETop1.M3",
            "System.Int32 ETop2.M3 { get; }",
            .. objectStaticSymbols];

        AssertSetStrictlyEqual(cStaticSymbols, model.LookupStaticMembers(position, c).ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_Protected()
    {
        var src = """
// we'll lookup here
_ = C.M;

class C
{
    int P => throw null; // we'll also lookup here
}

implicit extension E for C
{
    protected static int M = 0;
    protected class Nested { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,7): error CS0117: 'C' does not contain a definition for 'M'
            // _ = C.M;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("C", "M").WithLocation(2, 7));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var c = ((Compilation)comp).GlobalNamespace.GetTypeMember("C");

        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectSymbols, model.LookupSymbols(position: 0, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(position: 0, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(position: 0, c).ToTestDisplayStrings());

        int positionInC = GetSyntax<ThrowExpressionSyntax>(tree, "throw null").SpanStart;

        string[] cSymbols = [
            "System.Int32 C.P { get; }",
            "System.Object System.Object.MemberwiseClone()",
            "void System.Object.Finalize()",
            .. objectSymbols];

        AssertSetStrictlyEqual(cSymbols, model.LookupSymbols(positionInC, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(cSymbols, model.LookupSymbols(positionInC, c, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertSetStrictlyEqual([], model.LookupNamespacesAndTypes(positionInC, c).ToTestDisplayStrings());
        AssertSetStrictlyEqual(objectStaticSymbols, model.LookupStaticMembers(positionInC, c).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_ExtensionField()
    {
        var source = """
bool b = true;
var x = b ? object.StaticField : object.StaticField;
System.Console.Write(x.ToString());

public implicit extension E for object
{
    public static int StaticField = 42;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.StaticField").ToArray();
        Assert.Equal("System.Int32 E.StaticField", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("System.Int32 E.StaticField", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_ExtensionField_Condition()
    {
        var source = """
var x = object.StaticField ? "ran" : null;
System.Console.Write(x);

public implicit extension E for object
{
    public static bool StaticField = true;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticField");
        Assert.Equal("System.Boolean E.StaticField", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_TwoAsGoodExtensions_ExtensionField()
    {
        var source = """
bool b = true;
var x = b ? object.StaticField : object.StaticField;

public implicit extension E1 for object
{
    public static int StaticField = 42;
}
public implicit extension E2 for object
{
    public static int StaticField = 42;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,20): error CS0229: Ambiguity between 'E1.StaticField' and 'E2.StaticField'
            // var x = b ? object.StaticField : object.StaticField;
            Diagnostic(ErrorCode.ERR_AmbigMember, "StaticField").WithArguments("E1.StaticField", "E2.StaticField").WithLocation(2, 20),
            // (2,41): error CS0229: Ambiguity between 'E1.StaticField' and 'E2.StaticField'
            // var x = b ? object.StaticField : object.StaticField;
            Diagnostic(ErrorCode.ERR_AmbigMember, "StaticField").WithArguments("E1.StaticField", "E2.StaticField").WithLocation(2, 41));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.StaticField").ToArray();
        Assert.Null(model.GetSymbolInfo(memberAccess[0]).Symbol);
        Assert.Null(model.GetSymbolInfo(memberAccess[1]).Symbol);
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_ExtensionMethod()
    {
        var source = """
bool b = true;
var x = b ? object.M : object.M;

public implicit extension E for object
{
    public static void M() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,9): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'method group' and 'method group'
            // var x = b ? object.M : object.M;
            Diagnostic(ErrorCode.ERR_InvalidQM, "b ? object.M : object.M").WithArguments("method group", "method group").WithLocation(2, 9)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").ToArray();
        Assert.Null(model.GetSymbolInfo(memberAccess[0]).Symbol);
        Assert.Null(model.GetSymbolInfo(memberAccess[1]).Symbol);

        // PROTOTYPE need to fix the semantic model
        Assert.Empty(model.GetMemberGroup(memberAccess[0]));
        Assert.Empty(model.GetMemberGroup(memberAccess[1]));
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_ExtensionProperty()
    {
        var source = """
bool b = true;
var x = b ? object.StaticProperty : object.StaticProperty;
System.Console.Write(x);

public implicit extension E for object
{
    public static int StaticProperty => 42;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.StaticProperty").ToArray();
        Assert.Equal("System.Int32 E.StaticProperty { get; }", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("System.Int32 E.StaticProperty { get; }", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_ExtensionEvent()
    {
        var source = """
bool b = true;
var x = b ? object.StaticEvent : object.StaticEvent;

public implicit extension E for object
{
    public static event System.Action StaticEvent { add { } remove { } }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,20): error CS0079: The event 'E.StaticEvent' can only appear on the left hand side of += or -=
            // var x = b ? object.StaticEvent : object.StaticEvent;
            Diagnostic(ErrorCode.ERR_BadEventUsageNoField, "StaticEvent").WithArguments("E.StaticEvent").WithLocation(2, 20),
            // (2,41): error CS0079: The event 'E.StaticEvent' can only appear on the left hand side of += or -=
            // var x = b ? object.StaticEvent : object.StaticEvent;
            Diagnostic(ErrorCode.ERR_BadEventUsageNoField, "StaticEvent").WithArguments("E.StaticEvent").WithLocation(2, 41));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.StaticEvent").ToArray();
        Assert.Null(model.GetSymbolInfo(memberAccess[0]).Symbol);
        Assert.Null(model.GetSymbolInfo(memberAccess[1]).Symbol);
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_ExtensionEvent_FieldEvent()
    {
        var source = """
bool b = true;
var x = b ? object.StaticEvent : object.StaticEvent;

public implicit extension E for object
{
    public static event System.Action StaticEvent;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,20): error CS0070: The event 'E.StaticEvent' can only appear on the left hand side of += or -= (except when used from within the type 'E')
            // var x = b ? object.StaticEvent : object.StaticEvent;
            Diagnostic(ErrorCode.ERR_BadEventUsage, "StaticEvent").WithArguments("E.StaticEvent", "E").WithLocation(2, 20),
            // (2,41): error CS0070: The event 'E.StaticEvent' can only appear on the left hand side of += or -= (except when used from within the type 'E')
            // var x = b ? object.StaticEvent : object.StaticEvent;
            Diagnostic(ErrorCode.ERR_BadEventUsage, "StaticEvent").WithArguments("E.StaticEvent", "E").WithLocation(2, 41));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.StaticEvent").ToArray();
        Assert.Null(model.GetSymbolInfo(memberAccess[0]).Symbol);
        Assert.Null(model.GetSymbolInfo(memberAccess[1]).Symbol);
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_ExtensionNestedType()
    {
        var source = """
bool b = true;
var x = b ? object.Nested : object.Nested;

public implicit extension E for object
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,13): error CS0119: 'E.Nested' is a type, which is not valid in the given context
            // var x = b ? object.Nested : object.Nested;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "object.Nested").WithArguments("E.Nested", "type").WithLocation(2, 13),
            // (2,29): error CS0119: 'E.Nested' is a type, which is not valid in the given context
            // var x = b ? object.Nested : object.Nested;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "object.Nested").WithArguments("E.Nested", "type").WithLocation(2, 29));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.Nested").ToArray();
        Assert.Null(model.GetSymbolInfo(memberAccess[0]).Symbol);
        Assert.Null(model.GetSymbolInfo(memberAccess[1]).Symbol);
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_DifferentTypes()
    {
        var source = """
bool b = true;
var x = b ? object.StaticField : object.StaticField2;
System.Console.Write(x.ToString());

public implicit extension E for object
{
    public static int StaticField = 42;
    public static long StaticField2 = 43;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticField");
        Assert.Equal("System.Int32 E.StaticField", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess).Type.ToTestDisplayString());
        Assert.Equal("System.Int64", model.GetTypeInfo(memberAccess).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_WithTargetType()
    {
        var source = """
bool b = true;
long x = b ? object.StaticField : object.StaticField;
System.Console.Write(x.ToString());

public implicit extension E for object
{
    public static int StaticField = 42;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.StaticField").ToArray();
        Assert.Equal("System.Int32 E.StaticField", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("System.Int32 E.StaticField", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());

        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess[0]).Type.ToTestDisplayString());
        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess[0]).ConvertedType.ToTestDisplayString());

        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess[1]).Type.ToTestDisplayString());
        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess[1]).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_TwoExtensions_WithTargetType()
    {
        var source = """
bool b = true;
string x = b ? D.f : D.f;
System.Console.Write(x);

class D { }

implicit extension E1 for D
{
    public static string f = "ran";
}

implicit extension E2 for object
{
    public static void f() { }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "D.f").ToArray();
        Assert.Equal("System.String E1.f", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("System.String E1.f", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());

        Assert.Equal("System.String", model.GetTypeInfo(memberAccess[0]).Type.ToTestDisplayString());
        Assert.Equal("System.String", model.GetTypeInfo(memberAccess[0]).ConvertedType.ToTestDisplayString());

        Assert.Equal("System.String", model.GetTypeInfo(memberAccess[1]).Type.ToTestDisplayString());
        Assert.Equal("System.String", model.GetTypeInfo(memberAccess[1]).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_TwoExtensions_WithTargetDelegateType()
    {
        var source = """
bool b = true;
System.Action x = b ? D.f : D.f;
System.Console.Write(x);

class D { }

implicit extension E1 for D
{
    public static string f = null;
}

implicit extension E2 for object
{
    public static void f() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,19): error CS0029: Cannot implicitly convert type 'string' to 'System.Action'
            // System.Action x = b ? D.f : D.f;
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "b ? D.f : D.f").WithArguments("string", "System.Action").WithLocation(2, 19));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "D.f").ToArray();
        Assert.Equal("System.String E1.f", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("System.String E1.f", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());

        Assert.Equal("System.String", model.GetTypeInfo(memberAccess[0]).Type.ToTestDisplayString());
        Assert.Equal("System.String", model.GetTypeInfo(memberAccess[0]).ConvertedType.ToTestDisplayString());

        Assert.Equal("System.String", model.GetTypeInfo(memberAccess[1]).Type.ToTestDisplayString());
        Assert.Equal("System.String", model.GetTypeInfo(memberAccess[1]).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Cast_Static_Operand()
    {
        var source = """
var x = (long)object.StaticField;
System.Console.Write(x.ToString());

public implicit extension E for object
{
    public static int StaticField = 42;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticField");
        Assert.Equal("System.Int32 E.StaticField", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess).Type.ToTestDisplayString());
        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Cast_Static_Operand_TwoExtensions()
    {
        var source = """
var x = (string)D.f;
System.Console.Write(x);

class D { }

implicit extension E1 for D
{
    public static string f = "ran";
}

implicit extension E2 for object
{
    public static void f() { }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "D.f");
        Assert.Equal("System.String E1.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Cast_Static_Operand_TwoExtensions_DelegateType()
    {
        var source = """
var x = (System.Action)D.f;
System.Action a = D.f;

class D { }

implicit extension E1 for D
{
    public static string f = null;
}

implicit extension E2 for object
{
    public static void f() => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0030: Cannot convert type 'string' to 'System.Action'
            // var x = (System.Action)D.f;
            Diagnostic(ErrorCode.ERR_NoExplicitConv, "(System.Action)D.f").WithArguments("string", "System.Action").WithLocation(1, 9),
            // (2,19): error CS0029: Cannot implicitly convert type 'string' to 'System.Action'
            // System.Action a = D.f;
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "D.f").WithArguments("string", "System.Action").WithLocation(2, 19));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "D.f").ToArray();
        Assert.Equal("System.String E1.f", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("System.String E1.f", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());

        // Note: a conversion to a delegate type does not provide invocation context for resolving the member access
        source = """
var x = (System.Action)D.f;
System.Action a = D.f;

class C
{
    public static void f() { }
}

class D : C
{
    public static new string f = null!;
}
""";
        comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0030: Cannot convert type 'string' to 'System.Action'
            // var x = (System.Action)D.f;
            Diagnostic(ErrorCode.ERR_NoExplicitConv, "(System.Action)D.f").WithArguments("string", "System.Action").WithLocation(1, 9),
            // (2,19): error CS0029: Cannot implicitly convert type 'string' to 'System.Action'
            // System.Action a = D.f;
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "D.f").WithArguments("string", "System.Action").WithLocation(2, 19));
    }

    [Fact]
    public void ResolveAll_Cast_Static_Type()
    {
        var source = """
var x = (System.Object.M)0;

public implicit extension E for object
{
    public class M { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0030: Cannot convert type 'int' to 'E.M'
            // var x = (System.Object.M)0;
            Diagnostic(ErrorCode.ERR_NoExplicitConv, "(System.Object.M)0").WithArguments("int", "E.M").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "System.Object.M");
        Assert.Equal("E.M", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ResolveAll_Cast_WithUserDefinedConversionOperator()
    {
        var source = """
var x = (System.Object.M)0;

public implicit extension E for object
{
    public class M
    {
        public static implicit operator M(int i) { System.Console.Write("ran"); return new M(); }
    }
}
""";
        if (!CompilationExtensions.EnableVerifyIOperation)
        {
            // PROTOTYPE update SymbolDisplayVisitor.AddNameAndTypeARgumentsOrParameters logic
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics();
            //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);
            var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "System.Object.M");
            Assert.Equal("E.M", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
        }
    }

    [Fact]
    public void ResolveAll_MethodTypeInference()
    {
        var source = """
write(object.M);
void write<T>(T t) { System.Console.Write(t.ToString()); }

public implicit extension E for object
{
    public static int M = 42;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess).Type.ToTestDisplayString());
        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ArrayCreation_Type_Static()
    {
        var source = """
_ = new System.Object.M[] { };

public implicit extension E for object
{
    public class M { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var qualifiedNamed = GetSyntax<QualifiedNameSyntax>(tree, "System.Object.M");
        Assert.Equal("E.M", model.GetSymbolInfo(qualifiedNamed).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ArrayCreation_WithUserDefinedConversionOperator()
    {
        var source = """
_ = new System.Object.M[] { 0 };

public implicit extension E for object
{
    public class M
    {
        public static implicit operator M(int i) { System.Console.Write("ran"); return new M(); }
    }
}
""";
        if (!CompilationExtensions.EnableVerifyIOperation)
        {
            // PROTOTYPE update SymbolDisplayVisitor.AddNameAndTypeARgumentsOrParameters logic
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics();
            // PROTOTYPE(instance) execute once we can lower/emit for non-static scenarios
            //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);
            var qualifiedNamed = GetSyntax<QualifiedNameSyntax>(tree, "System.Object.M");
            Assert.Equal("E.M", model.GetSymbolInfo(qualifiedNamed).Symbol.ToTestDisplayString());
        }
    }

    [Fact]
    public void ResolveAll_ArrayCreation_Initializer_Static()
    {
        var source = """
var x = new[] { object.StaticField, object.StaticField };
System.Console.Write((x[0], x[1]));

public implicit extension E for object
{
    public static int StaticField = 42;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "(42, 42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.StaticField").ToArray();
        Assert.Equal("System.Int32 E.StaticField", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("System.Int32 E.StaticField", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ArrayCreation_Rank()
    {
        var source = """
var x = new object[object.StaticField];
System.Console.Write(x.Length.ToString());

public implicit extension E for object
{
    public static int StaticField = 42;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticField");
        Assert.Equal("System.Int32 E.StaticField", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ArrayCreation_ExtensionNestedType()
    {
        var source = """
var x = new System.Object.Nested[1];
System.Console.Write((x.Length.ToString(), x is E.Nested[]));

public implicit extension E for object
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "(1, True)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "System.Object.Nested");
        Assert.Equal("E.Nested", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ObjectCreation_ExtensionNestedType_Keyword()
    {
        var source = """
var x = new object.Nested();

public implicit extension E for object
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,19): error CS1526: A new expression requires an argument list or (), [], or {} after type
            // var x = new object.Nested[1];
            Diagnostic(ErrorCode.ERR_BadNewExpr, ".").WithLocation(1, 19));
        // PROTOTYPE(static) We should be able to parse this object creation syntax
    }

    [Fact]
    public void ResolveAll_ArrayCreation_ExtensionNestedType_Keyword()
    {
        var source = """
var x = new object.Nested[1];

public implicit extension E for object
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,9): error CS0572: 'Nested': cannot reference a type through an expression; try 'E.Nested' instead
            // var x = new object.Nested[1];
            Diagnostic(ErrorCode.ERR_BadTypeReference, "new object.Nested").WithArguments("Nested", "E.Nested").WithLocation(1, 9),
            // (1,19): error CS1526: A new expression requires an argument list or (), [], or {} after type
            // var x = new object.Nested[1];
            Diagnostic(ErrorCode.ERR_BadNewExpr, ".").WithLocation(1, 19));
        // PROTOTYPE(static) We should be able to parse this array creation syntax
    }

    [Fact]
    public void ResolveAll_Deconstruction_Declaration()
    {
        var source = """
var (x, y) = object.M;
System.Console.Write((x, y));

public implicit extension E for object
{
    public static (int, int) M = (42, 43);
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "(42, 43)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("(System.Int32, System.Int32) E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Deconstruction_Assignment()
    {
        var source = """
int x, y;
(x, y) = object.M;
System.Console.Write((x, y));

public implicit extension E for object
{
    public static (int, int) M = (42, 43);
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "(42, 43)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("(System.Int32, System.Int32) E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_TupleExpression()
    {
        var source = """
System.Console.Write((object.M, object.M));

public implicit extension E for object
{
    public static int M = 42;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "(42, 42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").ToArray();
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_CollectionExpression()
    {
        var source = """
int[] x = [object.M];
System.Console.Write(x[0].ToString());

public implicit extension E for object
{
    public static int M = 42;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_CollectionExpression_ExtensionAddMethod()
    {
        var source = """
using System.Collections;
using System.Collections.Generic;

MyCollection c = [42];

public implicit extension E for MyCollection
{
    public void Add(int i) { System.Console.Write("ran"); }
}

public class MyCollection : IEnumerable<int>
{
    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once we can lower/emit for non-static scenarios
        //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();
    }

    [Fact]
    public void ResolveAll_CollectionExpression_ExtensionAddDelegateTypeProperty()
    {
        var source = """
using System.Collections;
using System.Collections.Generic;

MyCollection c = [42];

public implicit extension E for MyCollection
{
    public System.Action<int> Add => (int i) => { };
}

public class MyCollection : IEnumerable<int>
{
    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (4,18): error CS0118: 'Add' is a property but is used like a method
            // MyCollection c = [42];
            Diagnostic(ErrorCode.ERR_BadSKknown, "[42]").WithArguments("Add", "property", "method").WithLocation(4, 18));
    }

    [Fact]
    public void ResolveAll_Initializer()
    {
        var source = """
var x = new System.Collections.Generic.List<int>() { object.M };
System.Console.Write(x[0]);

public implicit extension E for object
{
    public static int M = 42;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Initializer_ExtensionMethod()
    {
        var source = """
var x = new System.Collections.Generic.List<int>() { object.M };

public implicit extension E for object
{
    public static void M() => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,54): error CS1950: The best overloaded Add method 'List<int>.Add(int)' for the collection initializer has some invalid arguments
            // var x = new System.Collections.Generic.List<int>() { object.M };
            Diagnostic(ErrorCode.ERR_BadArgTypesForCollectionAdd, "object.M").WithArguments("System.Collections.Generic.List<int>.Add(int)").WithLocation(1, 54),
            // (1,54): error CS1503: Argument 1: cannot convert from 'method group' to 'int'
            // var x = new System.Collections.Generic.List<int>() { object.M };
            Diagnostic(ErrorCode.ERR_BadArgType, "object.M").WithArguments("1", "method group", "int").WithLocation(1, 54));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void ResolveAll_Initializer_ObjectInitializer()
    {
        var source = """
var x = new C() { f = object.M };
System.Console.Write(x.f.ToString());

class C
{
    public int f;
}

public implicit extension E for object
{
    public static int M = 42;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalAccess_Receiver()
    {
        var source = """
System.Console.Write(object.M?.ToString());

public implicit extension E for object
{
    public static string M = "ran";
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalAccess_WhenNotNull()
    {
        var source = """
var x = new object()?.M;
System.Console.Write(x.ToString());

public implicit extension E for object
{
    public string M => "ran";
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once we can lower/emit for non-static scenarios
        // CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberBinding = GetSyntax<MemberBindingExpressionSyntax>(tree, ".M");
        Assert.Equal("System.String E.M { get; }", model.GetSymbolInfo(memberBinding).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalAccess_WhenNotNull_Invocation()
    {
        var source = """
var x = new object()?.M();
System.Console.Write(x.ToString());

public implicit extension E for object
{
    public string M() => "ran";
    public string M(int i) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once we can lower/emit for non-static scenarios
        // CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberBinding = GetSyntax<MemberBindingExpressionSyntax>(tree, ".M");
        Assert.Equal("System.String E.M()", model.GetSymbolInfo(memberBinding).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_CompoundAssignment_Left()
    {
        var source = """
object.M += 41;
System.Console.Write(E.M.ToString());

public implicit extension E for object
{
    public static int M = 1;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_CompoundAssignment_Right()
    {
        var source = """
int x = 1;
x += object.M;
System.Console.Write(x.ToString());

public implicit extension E for object
{
    public static int M = 41;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_CompoundAssignment_Left_EventAccess()
    {
        var source = """
object.M += () => {};

public implicit extension E for object
{
    public static event System.Action M { add { System.Console.Write("ran"); } remove { } }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("event System.Action E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_BinaryOperator_UserDefinedOperator()
    {
        var source = """
var x = object.M + object.M;
System.Console.Write(x.ToString());

public class C
{
    public static int operator+(C c1, C c2) => 42;
}

public implicit extension E for object
{
    public static C M = new C();
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").ToArray();
        Assert.Equal("C E.M", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("C E.M", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());

        var binaryOp = GetSyntax<BinaryExpressionSyntax>(tree, "object.M + object.M");
        Assert.Equal("System.Int32 C.op_Addition(C c1, C c2)", model.GetSymbolInfo(binaryOp).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_BinaryOperator_NoUserDefinedOperator()
    {
        var source = """
var x = object.M + object.M;
System.Console.Write(x.ToString());

public class C { }

public implicit extension E for object
{
    public static C M = new C();
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0019: Operator '+' cannot be applied to operands of type 'C' and 'C'
            // var x = object.M + object.M;
            Diagnostic(ErrorCode.ERR_BadBinaryOps, "object.M + object.M").WithArguments("+", "C", "C").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").ToArray();
        Assert.Equal("C E.M", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("C E.M", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());

        var binaryOp = GetSyntax<BinaryExpressionSyntax>(tree, "object.M + object.M");
        Assert.Null(model.GetSymbolInfo(binaryOp).Symbol);
    }

    [Fact]
    public void ResolveAll_IncrementOperator()
    {
        var source = """
object.M++;
System.Console.Write(E.M.ToString());

public class C { }

public implicit extension E for object
{
    public static int M = 41;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var unaryOp = GetSyntax<PostfixUnaryExpressionSyntax>(tree, "object.M++");
        Assert.Equal("System.Int32 System.Int32.op_Increment(System.Int32 value)", model.GetSymbolInfo(unaryOp).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_UnaryOperator()
    {
        var source = """
_ = !object.M;

public class C { }

public implicit extension E for object
{
    public static bool M { get { System.Console.Write("ran"); return true; } }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Boolean E.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var unaryOp = GetSyntax<PrefixUnaryExpressionSyntax>(tree, "!object.M");
        Assert.Equal("System.Boolean System.Boolean.op_LogicalNot(System.Boolean value)",
            model.GetSymbolInfo(unaryOp).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_NullCoalescingOperator()
    {
        var source = """
var x = object.M ?? object.M2;
System.Console.Write(x);

public implicit extension E for object
{
    public static string M = null;
    public static string M2 = "ran";
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal("System.String E.M2", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_NullCoalescingAssignmentOperator()
    {
        var source = """
object.M ??= object.M2;
System.Console.Write(E.M);

public implicit extension E for object
{
    public static string M = null;
    public static string M2 = "ran";
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal("System.String E.M2", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Query_Select()
    {
        var source = """
using System.Linq;

int[] array = [1];
var r = from int i in array select object.M;
foreach (var x in r)
{
    System.Console.Write(x.ToString());
}

public implicit extension E for object
{
    public static string M = "ran";
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Query_Cast()
    {
        var source = """
using System.Linq;

var r = from string s in object.M from string s2 in object.M2 select s.ToString();
foreach (var x in r)
{
    System.Console.Write(x.ToString());
}

public implicit extension E for object
{
    public static object[] M = ["ran"];
    public static object[] M2 = [""];
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Object[] E.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal("System.Object[] E.M2", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Return_Lambda()
    {
        var source = """
var x = () =>
    {
        bool b = true;
        if (b)
            return object.M;
        else
            return object.M2;
    };
System.Console.Write(x().ToString());

public implicit extension E for object
{
    public static int M = 42;
    public static int M2 = 0;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal("System.Int32 E.M2", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ExpressionBodiedLambda()
    {
        var source = """
var x = () => object.M;
System.Console.Write(x().ToString());

public implicit extension E for object
{
    public static int M = 42;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_YieldReturn()
    {
        var source = """
foreach (var y in local())
{
    System.Console.Write(y.ToString());
}

System.Collections.Generic.IEnumerable<int> local()
{
    bool b = true;
    if (b)
        yield return object.M;
    else
        yield return object.M2;
}

public implicit extension E for object
{
    public static int M = 42;
    public static int M2 = 0;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal("System.Int32 E.M2", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_YieldReturn_Lambda()
    {
        var source = """
var x = System.Collections.Generic.IEnumerable<int> () =>
    {
        bool b = true;
        if (b)
            yield return object.M;
        else
            yield return object.M2;
    };

foreach (var y in x())
{
    System.Console.Write(y.ToString());
}

public implicit extension E for object
{
    public static int M = 42;
    public static int M2 = 0;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,56): error CS1643: Not all code paths return a value in lambda expression of type 'Func<IEnumerable<int>>'
            // var x = System.Collections.Generic.IEnumerable<int> () =>
            Diagnostic(ErrorCode.ERR_AnonymousReturnExpected, "=>").WithArguments("lambda expression", "System.Func<System.Collections.Generic.IEnumerable<int>>").WithLocation(1, 56),
            // (5,13): error CS1621: The yield statement cannot be used inside an anonymous method or lambda expression
            //             yield return object.M;
            Diagnostic(ErrorCode.ERR_YieldInAnonMeth, "yield").WithLocation(5, 13),
            // (7,13): error CS1621: The yield statement cannot be used inside an anonymous method or lambda expression
            //             yield return object.M2;
            Diagnostic(ErrorCode.ERR_YieldInAnonMeth, "yield").WithLocation(7, 13));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal("System.Int32 E.M2", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Throw()
    {
        var source = """
try
{
    throw object.M;
}
catch (System.Exception e)
{
    System.Console.Write(e.Message);
}

public implicit extension E for object
{
    public static System.Exception M = new System.Exception("ran");
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Exception E.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_FieldInitializer()
    {
        var source = """
System.Console.Write(C.field.ToString());

class C
{
    public static string field = object.M;
}

public implicit extension E for object
{
    public static string M = "ran";
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static()
    {
        var src = """
local(object.M);

void local(string s)
{
    System.Console.Write(s);
}

implicit extension E for object
{
    public static string M = "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").First();
        Assert.Equal("System.String E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static_DelegateTypeParameter()
    {
        var src = """
local(object.M);

void local(System.Func<string> d)
{
    System.Console.Write(d());
}

implicit extension E for object
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").First();
        Assert.Equal("System.String E.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static_Inferred()
    {
        var src = """
System.Console.Write(local(object.M));

T local<T>(T t)
{
    return t;
}

implicit extension E for object
{
    public static string M => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").First();
        Assert.Equal("System.String E.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static_Inferred_FunctionTypeFromExtension()
    {
        var src = """
System.Console.Write(local(object.M)());

T local<T>(T t)
{
    return t;
}

implicit extension E for object
{
    public static string M() => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").First();
        Assert.Equal("System.String E.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static_DelegateTypeParameter_InapplicableInstanceMember()
    {
        var src = """
local(object.ToString);

void local(System.Func<int, string> d)
{
    System.Console.Write(d(42));
}

implicit extension E for object
{
    public static string ToString(int i) => "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.ToString").First();
        Assert.Equal("System.String E.ToString(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static_DelegateTypeParameter_PropertyAndMethod()
    {
        var src = """
var o = new object();
C.M(o.Member);

class C
{
    public static void M(System.Action a) { a(); }
}

public implicit extension E1 for object
{
    public string Member => throw null;
}

public static class E2
{
    public static void Member(this object o)
    {
        System.Console.Write("ran");
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,5): error CS1503: Argument 1: cannot convert from 'string' to 'System.Action'
            // C.M(o.Member);
            Diagnostic(ErrorCode.ERR_BadArgType, "o.Member").WithArguments("1", "string", "System.Action").WithLocation(2, 5));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.Member");
        Assert.Equal("System.String E1.Member { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_ObjectCreation_Static()
    {
        var source = """
new C(object.M);

class C
{
    public C(string s) { System.Console.Write(s); }
}

public implicit extension E for object
{
    public static string M = "ran";
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_BinaryOperator_Static_TwoExtensions()
    {
        var src = """
bool b = D.f + D.f;

class C
{
    public static bool operator +(C c, System.Action a) => true;
}

class D { }

implicit extension E1 for D
{
    public static C f = null;
}

implicit extension E2 for object
{
    public static void f() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,10): error CS0019: Operator '+' cannot be applied to operands of type 'C' and 'C'
            // bool b = D.f + D.f;
            Diagnostic(ErrorCode.ERR_BadBinaryOps, "D.f + D.f").WithArguments("+", "C", "C").WithLocation(1, 10));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "D.f").ToArray();
        Assert.Equal("C E1.f", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("C E1.f", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Lambda_Static_TwoAsGoodExtensions_Inferred()
    {
        var src = """
var l = () => object.f;
System.Console.Write(l());

implicit extension E1 for object
{
    public static string f = "hi";
}

implicit extension E2 for object
{
    public static void f() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,22): error CS0229: Ambiguity between 'E1.f' and 'E2.f()'
            // var l = () => object.f;
            Diagnostic(ErrorCode.ERR_AmbigMember, "f").WithArguments("E1.f", "E2.f()").WithLocation(1, 22)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void ResolveAll_Lambda_Static_TwoAsGoodExtensions_LambdaConverted()
    {
        var src = """
System.Func<System.Action> l = () => object.f;
l()();

implicit extension E1 for object
{
    public static string f = null;
}

implicit extension E2 for object
{
    public static void f() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,45): error CS0229: Ambiguity between 'E1.f' and 'E2.f()'
            // System.Func<System.Action> l = () => object.f;
            Diagnostic(ErrorCode.ERR_AmbigMember, "f").WithArguments("E1.f", "E2.f()").WithLocation(1, 45));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void ResolveAll_Lambda_Instance_ExtensionMethodVsExtensionMember()
    {
        var src = """
System.Func<System.Action> lambda = () => new object().Member;

public implicit extension E1 for object
{
    public string Member => throw null;
}

public static class E2
{
    public static void Member(this object o)
    {
        System.Console.Write("ran");
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,43): error CS0029: Cannot implicitly convert type 'string' to 'System.Action'
            // System.Func<System.Action> lambda = () => new object().Member;
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "new object().Member").WithArguments("string", "System.Action").WithLocation(1, 43),
            // (1,43): error CS1662: Cannot convert lambda expression to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type
            // System.Func<System.Action> lambda = () => new object().Member;
            Diagnostic(ErrorCode.ERR_CantConvAnonMethReturns, "new object().Member").WithArguments("lambda expression").WithLocation(1, 43));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().Member");
        Assert.Equal("System.String E1.Member { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // PROTOTYPE(instance) enable and execute once we can lower/emit for non-static scenarios
    public void ResolveAll_Lambda_Instance_MethodGroupWithMultipleOverloads()
    {
        var src = """
System.Func<System.Action> lambda = () => new object().Member;
lambda()();

public implicit extension E for object
{
    public void Member() { System.Console.Write("ran"); }
    public void Member(int i) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members
        //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().Member");
        Assert.Equal("void E.Member()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Lambda_Static_TwoExtensions_ConversionToDelegateType_ExplicitReturnType()
    {
        var src = """
var l = System.Action () => D.f;

class D { }

implicit extension E1 for D
{
    public static string f = null;
}

implicit extension E2 for object
{
    public static void f() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,29): error CS0029: Cannot implicitly convert type 'string' to 'System.Action'
            // var l = System.Action () => D.f;
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "D.f").WithArguments("string", "System.Action").WithLocation(1, 29),
            // (1,29): error CS1662: Cannot convert lambda expression to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type
            // var l = System.Action () => D.f;
            Diagnostic(ErrorCode.ERR_CantConvAnonMethReturns, "D.f").WithArguments("lambda expression").WithLocation(1, 29));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "D.f");
        Assert.Equal("System.String E1.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Lambda_Static_TwoExtensions_ConversionToDelegateType()
    {
        var src = """
System.Func<System.Action> l = () => D.f;

class D { }

implicit extension E1 for D
{
    public static string f = null;
}

implicit extension E2 for object
{
    public static void f() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,38): error CS0029: Cannot implicitly convert type 'string' to 'System.Action'
            // System.Func<System.Action> l = () => D.f;
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "D.f").WithArguments("string", "System.Action").WithLocation(1, 38),
            // (1,38): error CS1662: Cannot convert lambda expression to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type
            // System.Func<System.Action> l = () => D.f;
            Diagnostic(ErrorCode.ERR_CantConvAnonMethReturns, "D.f").WithArguments("lambda expression").WithLocation(1, 38));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "D.f");
        Assert.Equal("System.String E1.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Lambda_Static_TwoExtensions_Inferred_ReverseSpecificity()
    {
        var src = """
var l = () => D.f;
l()();

class D { }

implicit extension E1 for object
{
    public static string f = "";
}

implicit extension E2 for D
{
    public static void f() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "D.f");
        Assert.Equal("void E2.f()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static_TwoExtensions_Inferred()
    {
        var src = """
var s = local(D.f);
System.Console.Write(s);

T local<T>(T t) => t;

class D { }

implicit extension E1 for D
{
    public static string f = "ran";
}

implicit extension E2 for object
{
    public static void f() => throw null;
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "D.f");
        Assert.Equal("System.String E1.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static_TwoExtensions_Inferred_TwoArguments()
    {
        var src = """
var s = local(D.f, new System.Action(() => { }));
System.Console.Write(s);

T local<T>(T t1, T t2) => t1;

class D { }

implicit extension E1 for D
{
    public static string f = "ran";
}

implicit extension E2 for object
{
    public static void f() => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0411: The type arguments for method 'local<T>(T, T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
            // var s = local(D.f, new System.Action(() => { }));
            Diagnostic(ErrorCode.ERR_CantInferMethTypeArgs, "local").WithArguments("local<T>(T, T)").WithLocation(1, 9),
            // (4,3): warning CS8321: The local function 'local' is declared but never used
            // T local<T>(T t1, T t2) => t1;
            Diagnostic(ErrorCode.WRN_UnreferencedLocalFunction, "local").WithArguments("local").WithLocation(4, 3));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "D.f");
        Assert.Equal("System.String E1.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_SwitchExpression_Static_Default()
    {
        var src = """
bool b = true;
var s = b switch { true => object.f, false => default };
System.Console.Write(s);

implicit extension E for object
{
    public static string f = "hi";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.String E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var defaultExpr = GetSyntax<LiteralExpressionSyntax>(tree, "default");
        Assert.Equal("System.String", model.GetTypeInfo(defaultExpr).Type.ToTestDisplayString());
        Assert.Equal("System.String", model.GetTypeInfo(defaultExpr).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_RefTernary()
    {
        var src = """
bool b = true;
var x = b ? ref object.f : ref object.f;
System.Console.Write(x);

implicit extension E for object
{
    public static string f = "ran";
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.String E.f", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Query_Static_InstanceMethodGroup()
    {
        var src = """
string query = from x in object.ToString select x;

implicit extension E for object
{
    public static string ToString() => null;
}
""";
        // PROTOTYPE should warn about hiding
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,33): error CS0119: 'object.ToString()' is a method, which is not valid in the given context
            // string query = from x in object.ToString select x;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "ToString").WithArguments("object.ToString()", "method").WithLocation(1, 33));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.ToString");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String System.Object.ToString()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Query_Static_ExtensionMethodGroup()
    {
        var src = """
string query = from x in object.M select x;

implicit extension E for object
{
    public static string M() => null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,33): error CS0119: 'E.M()' is a method, which is not valid in the given context
            // string query = from x in object.M select x;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "M").WithArguments("E.M()", "method").WithLocation(1, 33));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ResolveAll_Query_Static_ExtensionField()
    {
        var src = """
string query = from x in object.M select x;

implicit extension E for object
{
    public static string M = null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,26): error CS1935: Could not find an implementation of the query pattern for source type 'string'.  'Select' not found.  Are you missing required assembly references or a using directive for 'System.Linq'?
            // string query = from x in object.M select x;
            Diagnostic(ErrorCode.ERR_QueryNoProviderStandard, "object.M").WithArguments("string", "Select").WithLocation(1, 26));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ResolveAll_Instance_Invocation_InnerInapplicableExtensionMethodVsOuterInvocableExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            new object().M();
        }
    }

    public static class Extension
    {
        public static void M(this object o, int i) { } // not applicable because of second parameter
    }
}

implicit extension E for object
{
    public System.Action M => () => { System.Console.Write("ran"); };
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once we can lower/emit for non-static scenarios
        //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("System.Action E.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Instance_Invocation_InnerIrrelevantExtensionMethodVsOuterInvocableExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            new object().M();
        }
    }

    public static class Extension
    {
        public static void M(this string o, int i) { } // not eligible because of `this` parameter
    }
}

implicit extension E for object
{
    public System.Action M => () => { System.Console.Write("ran"); };
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once we can lower/emit for non-static scenarios
        //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("System.Action E.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Instance_InferredVariable_InnerExtensionMethodVsOuterInvocableExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            var x = new object().M;
            x(42);
        }
    }

    public static class Extension
    {
        public static void M(this object o, int i) { System.Console.Write("ran"); }
    }
}

implicit extension E for object
{
    public System.Action M => () => throw null;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("void System.Object.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void System.Object.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Instance_InferredVariable_InnerIrrelevantExtensionMethodVsOuterInvocableExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            var x = new object().M;
            x();
        }
    }

    public static class Extension
    {
        public static void M(this string o, int i) { } // not eligible because of `this` parameter
    }
}

implicit extension E for object
{
    public System.Action M => () => { System.Console.Write("ran"); };
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once we can lower/emit for non-static scenarios
        //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("System.Action E.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Instance_LocalDeclaration_InnerExtensionMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            int x = new object().M;
        }
    }

    public static class Extension
    {
        public static void M(this object o, int i) { }
    }
}

implicit extension E for object
{
    public int M => 42;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics(
            // (7,34): error CS0428: Cannot convert method group 'M' to non-delegate type 'int'. Did you intend to invoke the method?
            //             int x = new object().M;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "M").WithArguments("M", "int").WithLocation(7, 34));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void System.Object.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Static_LocalDeclaration_InnerExtensionMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            int x = object.M;
        }
    }

    public static class Extension
    {
        public static void M(this object o, int i) { }
    }
}

implicit extension E for object
{
    public static int M => 42;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics(
            // (7,28): error CS0428: Cannot convert method group 'M' to non-delegate type 'int'. Did you intend to invoke the method?
            //             int x = object.M;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "M").WithArguments("M", "int").WithLocation(7, 28));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void System.Object.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Static_LocalDeclaration_InstanceInnerExtensionTypeMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            int x = object.M;
        }
    }

    implicit extension E1 for object
    {
        public void M(int i) { }
    }
}

implicit extension E2 for object
{
    public static int M => 42;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics(
            // (7,28): error CS0428: Cannot convert method group 'M' to non-delegate type 'int'. Did you intend to invoke the method?
            //             int x = object.M;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "M").WithArguments("M", "int").WithLocation(7, 28));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ResolveAll_Instance_LocalDeclaration_StaticInnerExtensionTypeMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            int x = new object().M;
        }
    }

    implicit extension E1 for object
    {
        public static void M(int i) => throw null;
    }
}

implicit extension E2 for object
{
    public int M => 42;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics(
            // (7,34): error CS0428: Cannot convert method group 'M' to non-delegate type 'int'. Did you intend to invoke the method?
            //             int x = new object().M;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "M").WithArguments("M", "int").WithLocation(7, 34));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ResolveAll_Instance_LocalDeclaration_InnerIrrelevantExtensionMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            int x = new object().M;
            System.Console.Write(x);
        }
    }

    public static class Extension
    {
        public static void M(this string o, int i) { } // not eligible because of `this` parameter
    }
}

implicit extension E for object
{
    public int M => 42;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once we can lower/emit for non-static scenarios
        //CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("System.Int32 E.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Instance_LocalDeclaration_DelegateType_InnerInapplicableExtensionMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            System.Action x = new object().M;
        }
    }

    public static class Extension
    {
        public static void M(this object o, int i) { }
    }
}

implicit extension E for object
{
    public void M() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once we can lower/emit for non-static scenarios
        //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("void E.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void System.Object.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Fact]
    public void ResolveAll_Instance_LocalDeclaration_DelegateType_InnerIrrelevantExtensionMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            System.Action x = new object().M;
        }
    }

    public static class Extension
    {
        public static void M(this string o, int i) { } // not eligible because of `this` parameter
    }
}

implicit extension E for object
{
    public void M() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics();
        // PROTOTYPE(instance) execute once we can lower/emit for non-static scenarios
        //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("void E.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // PROTOTYPE need to fix the semantic model
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_FieldAndLessSpecificFieldAndEmpty(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1 for I1
            {
                public static string M = "ran";
            }
            """,
            """
            implicit extension E2 for I2 { }
            """,
            """
            implicit extension E3 for I1Base
            {
                public static string M = null;
            }
            implicit extension E4 for I2Base { }
            """];

        var src = $$"""
System.Console.Write(C.M);

interface I1Base { }
interface I1 : I1Base { }
interface I2Base { }
interface I2 : I2Base { }

class C : I1, I2 { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E1.M", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_InterfaceAppearsTwice(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1<T> for I1<T>
            {
                public static string M => null;
            }
            """,
            """
            implicit extension E2 for I2 { }
            """,
            """
            implicit extension E3 for C { }
            """];

        var src = $$"""
System.Console.Write(C.M);

interface I1<T> { }
interface I2 : I1<string> { }

class C : I1<int>, I2 { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,24): error CS0229: Ambiguity between 'E1<int>.M' and 'E1<string>.M'
            // System.Console.Write(C.M);
            Diagnostic(ErrorCode.ERR_AmbigMember, "M").WithArguments("E1<int>.M", "E1<string>.M").WithLocation(1, 24));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E1<System.Int32>.M { get; }", "System.String E1<System.String>.M { get; }"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_InterfaceAppearsTwice_02(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1<T> for I1<T>
            {
                public static string M => null;
            }
            """,
            """
            implicit extension E2 for Base { }
            """,
            """
            implicit extension E3 for C { }
            """];

        var src = $$"""
System.Console.Write(C.M);

interface I1<T> { }
class Base : I1<string> { }
class C : Base, I1<int> { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,24): error CS0229: Ambiguity between 'E1<string>.M' and 'E1<int>.M'
            // System.Console.Write(C.M);
            Diagnostic(ErrorCode.ERR_AmbigMember, "M").WithArguments("E1<string>.M", "E1<int>.M").WithLocation(1, 24));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E1<System.String>.M { get; }", "System.String E1<System.Int32>.M { get; }"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_InterfaceAppearsTwice_03(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1<T> for I1<T>
            {
                public static string M => null;
            }
            """,
            """
            implicit extension E2 for Base
            {
                public static string M => null;
            }
            """,
            """
            implicit extension E3 for C { }
            """];

        var src = $$"""
System.Console.Write(C.M);

interface I1<T> { }
class Base : I1<string> { }
class C : Base, I1<int> { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,24): error CS0229: Ambiguity between 'E1<int>.M' and 'E2.M'
            // System.Console.Write(C.M);
            Diagnostic(ErrorCode.ERR_AmbigMember, "M").WithArguments("E1<int>.M", "E2.M").WithLocation(1, 24));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E1<System.Int32>.M { get; }", "System.String E2.M { get; }"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_InterfaceAppearsTwice_04(int first, int second, int third)
    {
        string[] segments = [
            """
            implicit extension E1<T> for I1<T>
            {
                public static string M => "ran";
            }
            """,
            """
            implicit extension E2 for I2 { }
            """,
            """
            implicit extension E3 for C { }
            """];

        var src = $$"""
System.Console.Write(C.M);

interface I1<T> { }
interface I2 : I1<int> { }

class C : I1<int>, I2 { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("System.String E1<System.Int32>.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_ForT_Static_Unconstrained()
    {
        var source = """
// we'll lookup here
int.StaticMethod();

public implicit extension E<T> for T
{
    public static void StaticMethod() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var int32 = ((Compilation)comp).GetSpecialType(SpecialType.System_Int32);
        AssertSetStrictlyEqual([
            .. objectStaticSymbols,
            "void E<System.Int32>.StaticMethod()",
            "void E<System.ValueType>.StaticMethod()",
            "void E<System.Object>.StaticMethod()",
            "void E<System.IConvertible>.StaticMethod()",
            "void E<System.IComparable>.StaticMethod()",
            "void E<System.IComparable<System.Int32>>.StaticMethod()",
            "void E<System.IEquatable<System.Int32>>.StaticMethod()",
            "void E<System.IFormattable>.StaticMethod()"],
            model.LookupStaticMembers(position: 0, int32).Where(m => m.ContainingType.Name != "Int32").ToTestDisplayStrings());
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_ForT_Static_BrokenConstraint()
    {
        var source = """
object.StaticMethod();

public implicit extension E<T> for T where T : struct
{
    public static void StaticMethod() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'StaticMethod'
            // object.StaticMethod();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "StaticMethod").WithArguments("object", "StaticMethod").WithLocation(1, 8));
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_ForT_Instance_BrokenConstraint_Nullability()
    {
        var source = """
#nullable enable
bool b = true;
var o = b ? null : new object();
o.Method();

public implicit extension E<T> for T where T : notnull
{
    public void Method() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (4,1): warning CS8602: Dereference of a possibly null reference.
            // o.Method();
            Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(4, 1));
        // PROTOTYPE(instance) Execute when adding support for emitting non-static members

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.Method");
        // PROTOTYPE(static) Updated nullability information should be reflected in the symbol
        Assert.Equal("void E<System.Object>.Method()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString(includeNonNullable: true));
    }

    [Fact(Skip = "PROTOTYPE(static) hit assertion in NullableWalker")]
    public void Lookup_ExtensionTypeMembers_Static_BrokenConstraint_Nullability()
    {
        var source = """
#nullable enable
C<object?>.StaticMethod();

class C<T> { }

public implicit extension E<T> for C<T> where T : notnull
{
    public static void StaticMethod() { System.Console.Write("ran"); }
}
""";
        // PROTOTYPE(static) we should warn for nullability issues
        var comp = CreateCompilation(source);
        //comp.VerifyDiagnostics();
        //CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_ForT_Static_NullableReferenceType()
    {
        var source = """
#nullable enable
object?.StaticMethod();

public implicit extension E<T> for T
{
    public static void StaticMethod() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,8): error CS1001: Identifier expected
            // object?.StaticMethod();
            Diagnostic(ErrorCode.ERR_IdentifierExpected, ".").WithLocation(2, 8),
            // (2,8): error CS1003: Syntax error, ',' expected
            // object?.StaticMethod();
            Diagnostic(ErrorCode.ERR_SyntaxError, ".").WithArguments(",").WithLocation(2, 8));
    }

    [Fact]
    public void Lookup_ExtensionTypeMembers_ForT_Static_NullableReferenceTypeParenthesized()
    {
        var source = """
#nullable enable
(object?).StaticMethod();

public implicit extension E<T> for T
{
    public static void StaticMethod() { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,10): error CS1525: Invalid expression term '.'
            // (object?).StaticMethod();
            Diagnostic(ErrorCode.ERR_InvalidExprTerm, ".").WithArguments(".").WithLocation(2, 10));
    }

    [Fact]
    public void UsingStatic_07()
    {
        var source = """
using static MyNamespace.AnyClass.AnyEnum.Val;

namespace MyNamespace;

internal class AnyClass : AnyBaseClass
{
    internal interface AnyEnum { }
}
""";
        // In `GetInterfaceInfo` we call `SourceNamedTypeSymbol.BaseTypeNoUseSiteDiagnostics` which forces resolution on `ContainingType.BaseTypeNoUseSiteDiagnostics`
        // This means that any lookup on `AnyEnum` causes the `using` directives to be resolved
        var comp = CreateCompilationWithMscorlib45(source);
        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using static MyNamespace.AnyClass.AnyEnum.Val;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using static MyNamespace.AnyClass.AnyEnum.Val;").WithLocation(1, 1),
            // (1,43): error CS0426: The type name 'Val' does not exist in the type 'AnyClass.AnyEnum'
            // using static MyNamespace.AnyClass.AnyEnum.Val;
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Val").WithArguments("Val", "MyNamespace.AnyClass.AnyEnum").WithLocation(1, 43),
            // (5,27): error CS0246: The type or namespace name 'AnyBaseClass' could not be found (are you missing a using directive or an assembly reference?)
            // internal class AnyClass : AnyBaseClass
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "AnyBaseClass").WithArguments("AnyBaseClass").WithLocation(5, 27));
    }

    [Fact]
    public void UsingStatic_WithExtension_NoNestedType()
    {
        var source = """
using static MyNamespace.AnyClass.AnyEnum.Val;

namespace MyNamespace;

internal class AnyClass : AnyBaseClass
{
    internal interface AnyEnum { }
}

implicit extension E for AnyClass.AnyEnum { }
""";
        var comp = CreateCompilation(source);

        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using static MyNamespace.AnyClass.AnyEnum.Val;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using static MyNamespace.AnyClass.AnyEnum.Val;").WithLocation(1, 1),
            // (1,43): error CS0426: The type name 'Val' does not exist in the type 'AnyClass.AnyEnum'
            // using static MyNamespace.AnyClass.AnyEnum.Val;
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Val").WithArguments("Val", "MyNamespace.AnyClass.AnyEnum").WithLocation(1, 43),
            // (5,27): error CS0246: The type or namespace name 'AnyBaseClass' could not be found (are you missing a using directive or an assembly reference?)
            // internal class AnyClass : AnyBaseClass
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "AnyBaseClass").WithArguments("AnyBaseClass").WithLocation(5, 27));
    }

    [Fact]
    public void UsingStatic()
    {
        var source = """
using static AnyClass.AnyEnum.Val;

internal class AnyClass : AnyBaseClass
{
    internal interface AnyEnum { }
}

implicit extension E for AnyClass.AnyEnum
{
    public class Val { }
}
""";
        var comp = CreateCompilation(source);

        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using static AnyClass.AnyEnum.Val;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using static AnyClass.AnyEnum.Val;").WithLocation(1, 1),
            // (1,31): error CS0426: The type name 'Val' does not exist in the type 'AnyClass.AnyEnum'
            // using static AnyClass.AnyEnum.Val;
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Val").WithArguments("Val", "AnyClass.AnyEnum").WithLocation(1, 31),
            // (3,27): error CS0246: The type or namespace name 'AnyBaseClass' could not be found (are you missing a using directive or an assembly reference?)
            // internal class AnyClass : AnyBaseClass
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "AnyBaseClass").WithArguments("AnyBaseClass").WithLocation(3, 27));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "AnyClass.AnyEnum.Val");
        // PROTOTYPE(static) consider blocking extension resolution in semantic model correspondingly with source
        Assert.Equal("E.Val", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void UsingStatic_WithoutErrorBaseType()
    {
        var source = """
using static C.Interface.Nested;

internal class C
{
    internal interface Interface { }
}

implicit extension E for C.Interface
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(source);

        comp.VerifyDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using static C.Interface.Nested;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using static C.Interface.Nested;").WithLocation(1, 1),
            // (1,26): error CS0426: The type name 'Nested' does not exist in the type 'C.Interface'
            // using static C.Interface.Nested;
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Nested").WithArguments("Nested", "C.Interface").WithLocation(1, 26));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "C.Interface.Nested");
        // PROTOTYPE(static) consider blocking extension resolution in semantic model correspondingly with source
        Assert.Equal("E.Nested", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void AliasDirective()
    {
        var source = """
using MyNested = C.Interface.Nested;

MyNested.M();

internal class C
{
    internal interface Interface { }
}

implicit extension E for C.Interface
{
    public class Nested { public static void M() { System.Console.Write("ran"); } }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,30): error CS0426: The type name 'Nested' does not exist in the type 'C.Interface'
            // using MyNested = C.Interface.Nested;
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Nested").WithArguments("Nested", "C.Interface").WithLocation(1, 30));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "C.Interface.Nested");
        // PROTOTYPE(static) consider blocking extension resolution in semantic model correspondingly with source
        Assert.Equal("E.Nested", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void Circularity_ForType_NestedType()
    {
        var source = """
implicit extension E for E.Nested
{
    public class Nested { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,20): error CS0146: Circular base type dependency involving 'E.Nested' and 'E'
            // implicit extension E for E.Nested
            Diagnostic(ErrorCode.ERR_CircularBase, "E").WithArguments("E.Nested", "E").WithLocation(1, 20));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "E.Nested");
        Assert.Equal("E.Nested", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void AliasDirective_UsedInForType()
    {
        var source = """
using InterfaceAlias = C.Interface;

InterfaceAlias.M();

internal class C
{
    internal interface Interface { }
}

implicit extension E for InterfaceAlias
{
    public static void M() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "InterfaceAlias.M");
        Assert.Equal("void E.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void AliasDirective_UsedInForType_GenericCycle()
    {
        var source = """
using MyInterface = C<E.Interface>.Interface;

class C<T> { }
implicit extension E for C<MyInterface>
{
    public interface Interface { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,36): error CS0426: The type name 'Interface' does not exist in the type 'C<E.Interface>'
            // using MyInterface = C<E.Interface>.Interface;
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Interface").WithArguments("Interface", "C<E.Interface>").WithLocation(1, 36));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "C<E.Interface>.Interface");
        Assert.Null(model.GetSymbolInfo(qualifiedName).Symbol);
    }

    [Fact]
    public void AliasDirective_Keyword()
    {
        var source = """
using MyInterface = object.Interface;
MyInterface.M();

implicit extension E for object
{
    public interface Interface
    {
        public static void M() { System.Console.Write("ran "); }
    }
}
""";
        var comp = CreateCompilation(source, options: TestOptions.DebugExe, targetFramework: TargetFramework.Net70);
        // PROTOTYPE(static) We should be able to parse this using/alias directive
        comp.VerifyEmitDiagnostics(
            // (1,27): error CS1002: ; expected
            // using MyInterface = object.Interface;
            Diagnostic(ErrorCode.ERR_SemicolonExpected, ".").WithLocation(1, 27),
            // (1,27): error CS1022: Type or namespace definition, or end-of-file expected
            // using MyInterface = object.Interface;
            Diagnostic(ErrorCode.ERR_EOFExpected, ".").WithLocation(1, 27),
            // (1,28): error CS0103: The name 'Interface' does not exist in the current context
            // using MyInterface = object.Interface;
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Interface").WithArguments("Interface").WithLocation(1, 28),
            // (1,28): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
            // using MyInterface = object.Interface;
            Diagnostic(ErrorCode.ERR_IllegalStatement, "Interface").WithLocation(1, 28),
            // (2,13): error CS0117: 'object' does not contain a definition for 'M'
            // MyInterface.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(2, 13));
    }

    [Fact]
    public void ForAlias()
    {
        var source = """
using Alias = C;

Alias.M();

class C { }

implicit extension E for Alias
{
    public static void M() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Alias.M");
        Assert.Equal("void E.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void UsingStatic_FromOuterScope()
    {
        var source = """
internal class C
{
    internal interface Interface { }
}

implicit extension E for C.Interface
{
    public class Nested { }
}

namespace N
{
    using static C.Interface.Nested;
}
""";
        var comp = CreateCompilation(source);

        comp.VerifyDiagnostics(
            // (13,5): hidden CS8019: Unnecessary using directive.
            //     using static C.Interface.Nested;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using static C.Interface.Nested;").WithLocation(13, 5),
            // (13,30): error CS0426: The type name 'Nested' does not exist in the type 'C.Interface'
            //     using static C.Interface.Nested;
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Nested").WithArguments("Nested", "C.Interface").WithLocation(13, 30));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "C.Interface.Nested");
        // PROTOTYPE(static) consider blocking extension resolution in semantic model correspondingly with source
        Assert.Equal("E.Nested", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void AliasDirective_FromOuterScope()
    {
        var source = """
internal class C
{
    internal interface Interface { }
}

implicit extension E for C.Interface
{
    public class Nested { public static void M() { System.Console.Write("ran"); } }
}

namespace N
{
    using MyNested = C.Interface.Nested;

    class D
    {
        public static void Main()
        {
            MyNested.M();
        }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (13,34): error CS0426: The type name 'Nested' does not exist in the type 'C.Interface'
            //     using MyNested = C.Interface.Nested;
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Nested").WithArguments("Nested", "C.Interface").WithLocation(13, 34));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntax<QualifiedNameSyntax>(tree, "C.Interface.Nested");
        // PROTOTYPE(static) consider blocking extension resolution in semantic model correspondingly with source
        Assert.Equal("E.Nested", model.GetSymbolInfo(qualifiedName).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void UsingStatic_ExistingInterfacesScenario()
    {
        var source = """
interface IBase
{
    class Val { }
}

namespace N
{
    using static Interface.INested.Val; // error

    internal interface Interface : IBase
    {
        internal interface INested : Interface
        {
            void M(Interface.INested.Val x); // okay
        }
    }
}
""";
        var comp = CreateCompilationWithMscorlib45(source);

        comp.VerifyDiagnostics(
            // (8,5): hidden CS8019: Unnecessary using directive.
            //     using static Interface.INested.Val; // error
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using static Interface.INested.Val;").WithLocation(8, 5),
            // (8,36): error CS0426: The type name 'Val' does not exist in the type 'Interface.INested'
            //     using static Interface.INested.Val; // error
            Diagnostic(ErrorCode.ERR_DottedTypeNameNotFoundInAgg, "Val").WithArguments("Val", "N.Interface.INested").WithLocation(8, 36));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var qualifiedName = GetSyntaxes<QualifiedNameSyntax>(tree, "Interface.INested.Val").ToArray();
        Assert.Equal("IBase.Val", model.GetSymbolInfo(qualifiedName[0]).Symbol.ToTestDisplayString());
        Assert.Equal("IBase.Val", model.GetSymbolInfo(qualifiedName[1]).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void StaticInvocationOnDynamic()
    {
        var source = """
object.M();
dynamic.M();

static implicit extension E for object
{
    public static void M() => throw null;
}
""";
        // PROTOTYPE this should probably bind "dynamic" identifier to `dynamic` type and fail in a better way
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (2,1): error CS0103: The name 'dynamic' does not exist in the current context
            // dynamic.M();
            Diagnostic(ErrorCode.ERR_NameNotInContext, "dynamic").WithArguments("dynamic").WithLocation(2, 1));
    }

    [Fact]
    public void InstanceMethod_Metadata_01()
    {
        var src1 = """
public implicit extension E for C
{
    public void Method()
    {
        this.Increment();
        this.EIncrement();
    }

    public void EIncrement()
    {
        this.Increment();
    }
}

public class C
{
    public int F;

    public void Increment()
    {
        F++;
    }
}
""";
        var src2 = """
class Program
{
    static void Main()
    {
        Test1();
        Test2();
    }

    static void Test1()
    {
        var c = new C();
        c.Method();
        System.Console.WriteLine(c.F);
    }

    static void Test2()
    {
        GetC().Method();
    }

    static C GetC() => new C();
}
""";
        var comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var test1IL =
"""
{
  // Code size       22 (0x16)
  .maxstack  2
  IL_0000:  newobj     "C..ctor()"
  IL_0005:  dup
  IL_0006:  call       "void E.Method(C)"
  IL_000b:  ldfld      "int C.F"
  IL_0010:  call       "void System.Console.WriteLine(int)"
  IL_0015:  ret
}
""";
        verifier.VerifyIL("Program.Test1", test1IL);

        var test2IL =
"""
{
  // Code size       11 (0xb)
  .maxstack  1
  IL_0000:  call       "C Program.GetC()"
  IL_0005:  call       "void E.Method(C)"
  IL_000a:  ret
}
""";
        verifier.VerifyIL("Program.Test2", test2IL);

        verifier.VerifyIL("E.Method(C)",
"""
{
  // Code size       13 (0xd)
  .maxstack  1
  IL_0000:  ldarg.0
  IL_0001:  callvirt   "void C.Increment()"
  IL_0006:  ldarg.0
  IL_0007:  call       "void E.EIncrement(C)"
  IL_000c:  ret
}
""");

        verifier.VerifyTypeIL("E",
"""
.class public sequential ansi sealed beforefieldinit E
	extends [System.Runtime]System.ValueType
{
    .pack 0
    .size 1
	// Methods
	.method public hidebysig static 
		void Method (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 13 (0xd)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: callvirt instance void C::Increment()
		IL_0006: ldarg.0
		IL_0007: call void E::EIncrement(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute))
		IL_000c: ret
	} // end of method E::Method
	.method public hidebysig static 
		void EIncrement (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x205e
		// Code size 7 (0x7)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: callvirt instance void C::Increment()
		IL_0006: ret
	} // end of method E::EIncrement
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			class C ''
		) cil managed 
	{
		// Method begins at RVA 0x2066
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E::'<ImplicitExtension>$'
} // end of class E
""");

        comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var comp1 = CreateCompilation(src1, targetFramework: TargetFramework.NetStandard20, options: TestOptions.ReleaseDll);

        var comp2 = CreateCompilation(src2, references: [comp1.ToMetadataReference()], targetFramework: TargetFramework.Net80,
            options: TestOptions.ReleaseExe.WithSpecificDiagnosticOptions("CS1701", ReportDiagnostic.Suppress)); // warning CS1701: Assuming assembly reference 'System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' used by '512c7a1c-7c4e-4467-84af-5b75683f75fb' matches identity 'System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' of 'System.Runtime', you may need to supply runtime policy
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("2"), verify: Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
        verifier.VerifyIL("Program.Test2", test2IL);

        comp2 = CreateCompilation(src2, references: [comp1.EmitToImageReference()], targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
        verifier.VerifyIL("Program.Test2", test2IL);
    }

    [Fact]
    public void InstanceMethod_Metadata_02()
    {
        var src1 = """
public implicit extension E for C
{
    public void Method()
    {
        this.Increment();
        this.EIncrement();
    }

    public void EIncrement()
    {
        this.Increment();
    }
}

public struct C
{
    public int F;

    public void Increment()
    {
        F++;
    }
}
""";
        var src2 = """
class Program
{
    static void Main()
    {
        Test1();
        Test2();
    }

    static void Test1()
    {
        var c = new C();
        c.Method();
        System.Console.WriteLine(c.F);
    }

    static void Test2()
    {
        GetC().Method();
    }

    static C GetC() => new C();
}
""";
        var comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var test1IL =
"""
{
  // Code size       27 (0x1b)
  .maxstack  1
  .locals init (C V_0) //c
  IL_0000:  ldloca.s   V_0
  IL_0002:  initobj    "C"
  IL_0008:  ldloca.s   V_0
  IL_000a:  call       "void E.Method(ref C)"
  IL_000f:  ldloc.0
  IL_0010:  ldfld      "int C.F"
  IL_0015:  call       "void System.Console.WriteLine(int)"
  IL_001a:  ret
}
""";
        verifier.VerifyIL("Program.Test1", test1IL);

        var test2IL =
"""
{
  // Code size       14 (0xe)
  .maxstack  1
  .locals init (C V_0)
  IL_0000:  call       "C Program.GetC()"
  IL_0005:  stloc.0
  IL_0006:  ldloca.s   V_0
  IL_0008:  call       "void E.Method(ref C)"
  IL_000d:  ret
}
""";
        verifier.VerifyIL("Program.Test2", test2IL);

        verifier.VerifyIL("E.Method(ref C)",
"""
{
  // Code size       13 (0xd)
  .maxstack  1
  IL_0000:  ldarg.0
  IL_0001:  call       "void C.Increment()"
  IL_0006:  ldarg.0
  IL_0007:  call       "void E.EIncrement(ref C)"
  IL_000c:  ret
}
""");

        verifier.VerifyTypeIL("E",
"""
.class public sequential ansi sealed beforefieldinit E
	extends [System.Runtime]System.ValueType
{
    .pack 0
    .size 1
	// Methods
	.method public hidebysig static 
		void Method (
			valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 13 (0xd)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: call instance void C::Increment()
		IL_0006: ldarg.0
		IL_0007: call void E::EIncrement(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&)
		IL_000c: ret
	} // end of method E::Method
	.method public hidebysig static 
		void EIncrement (
			valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x205e
		// Code size 7 (0x7)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: call instance void C::Increment()
		IL_0006: ret
	} // end of method E::EIncrement
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			valuetype C ''
		) cil managed 
	{
		// Method begins at RVA 0x2066
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E::'<ImplicitExtension>$'
} // end of class E
""");

        comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var comp1 = CreateCompilation(src1, targetFramework: TargetFramework.NetStandard20, options: TestOptions.ReleaseDll);

        var comp2 = CreateCompilation(src2, references: [comp1.ToMetadataReference()], targetFramework: TargetFramework.Net80,
            options: TestOptions.ReleaseExe.WithSpecificDiagnosticOptions("CS1701", ReportDiagnostic.Suppress)); // warning CS1701: Assuming assembly reference 'System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' used by '512c7a1c-7c4e-4467-84af-5b75683f75fb' matches identity 'System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' of 'System.Runtime', you may need to supply runtime policy
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("2"), verify: Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
        verifier.VerifyIL("Program.Test2", test2IL);

        comp2 = CreateCompilation(src2, references: [comp1.EmitToImageReference()], targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
        verifier.VerifyIL("Program.Test2", test2IL);
    }

    [Fact]
    public void InstanceMethod_Metadata_03()
    {
        var src = """
implicit extension E<T> for C<T>
{
    public void Method(T x)
    {
        this.Increment(x);
        this.EIncrement(x);
    }

    public void EIncrement(T x)
    {
        this.Increment(x);
    }
}

class Program
{
    static void Main()
    {
        Test1();
        Test2();
    }

    static void Test1()
    {
        var c = new C<int>();
        c.Method(100);
        System.Console.WriteLine(c.F);
    }

    static void Test2()
    {
        GetC().Method(200);
    }

    static C<uint> GetC() => new C<uint>();
}

class C<T>
{
    public int F;

    public void Increment(T x)
    {
        F++;
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1",
"""
{
  // Code size       24 (0x18)
  .maxstack  3
  IL_0000:  newobj     "C<int>..ctor()"
  IL_0005:  dup
  IL_0006:  ldc.i4.s   100
  IL_0008:  call       "void E<int>.Method(C<int>, int)"
  IL_000d:  ldfld      "int C<int>.F"
  IL_0012:  call       "void System.Console.WriteLine(int)"
  IL_0017:  ret
}
""");

        verifier.VerifyIL("Program.Test2",
"""
{
  // Code size       16 (0x10)
  .maxstack  2
  IL_0000:  call       "C<uint> Program.GetC()"
  IL_0005:  ldc.i4     0xc8
  IL_000a:  call       "void E<uint>.Method(C<uint>, uint)"
  IL_000f:  ret
}
""");

        verifier.VerifyIL("E<T>.Method(C<T>, T)",
"""
{
  // Code size       15 (0xf)
  .maxstack  2
  IL_0000:  ldarg.0
  IL_0001:  ldarg.1
  IL_0002:  callvirt   "void C<T>.Increment(T)"
  IL_0007:  ldarg.0
  IL_0008:  ldarg.1
  IL_0009:  call       "void E<T>.EIncrement(C<T>, T)"
  IL_000e:  ret
}
""");

        verifier.VerifyTypeIL("E`1",
"""
.class private sequential ansi sealed beforefieldinit E`1<T>
	extends [System.Runtime]System.ValueType
{
    .pack 0
    .size 1
	// Methods
	.method public hidebysig static 
		void Method (
			class C`1<!T> modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			!T x
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 15 (0xf)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: callvirt instance void class C`1<!T>::Increment(!0)
		IL_0007: ldarg.0
		IL_0008: ldarg.1
		IL_0009: call void valuetype E`1<!T>::EIncrement(class C`1<!0> modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), !0)
		IL_000e: ret
	} // end of method E`1::Method
	.method public hidebysig static 
		void EIncrement (
			class C`1<!T> modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			!T x
		) cil managed 
	{
		// Method begins at RVA 0x2060
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: callvirt instance void class C`1<!T>::Increment(!0)
		IL_0007: ret
	} // end of method E`1::EIncrement
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			class C`1<!T> ''
		) cil managed 
	{
		// Method begins at RVA 0x2069
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E`1::'<ImplicitExtension>$'
} // end of class E`1
""");

        comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_04()
    {
        var src = """
implicit extension E for C
{
    public void Method<S>(S x)
    {
        this.Increment<S>(x);
        this.EIncrement<S>(x);
    }

    public void EIncrement<S>(S x)
    {
        this.Increment<S>(x);
    }
}

class Program
{
    static void Main()
    {
        Test1();
        Test2();
    }

    static void Test1()
    {
        var c = new C();
        c.Method<int>(100);
        System.Console.WriteLine(c.F);
    }

    static void Test2()
    {
        GetC().Method<uint>(200);
    }

    static C GetC() => new C();
}

class C
{
    public int F;

    public void Increment<S>(S x)
    {
        F++;
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1",
"""
{
  // Code size       24 (0x18)
  .maxstack  3
  IL_0000:  newobj     "C..ctor()"
  IL_0005:  dup
  IL_0006:  ldc.i4.s   100
  IL_0008:  call       "void E.Method<int>(C, int)"
  IL_000d:  ldfld      "int C.F"
  IL_0012:  call       "void System.Console.WriteLine(int)"
  IL_0017:  ret
}
""");

        verifier.VerifyIL("Program.Test2",
"""
{
  // Code size       16 (0x10)
  .maxstack  2
  IL_0000:  call       "C Program.GetC()"
  IL_0005:  ldc.i4     0xc8
  IL_000a:  call       "void E.Method<uint>(C, uint)"
  IL_000f:  ret
}
""");

        verifier.VerifyIL("E.Method<S>(C, S)",
"""
{
  // Code size       15 (0xf)
  .maxstack  2
  IL_0000:  ldarg.0
  IL_0001:  ldarg.1
  IL_0002:  callvirt   "void C.Increment<S>(S)"
  IL_0007:  ldarg.0
  IL_0008:  ldarg.1
  IL_0009:  call       "void E.EIncrement<S>(C, S)"
  IL_000e:  ret
}
""");

        verifier.VerifyTypeIL("E",
"""
.class private sequential ansi sealed beforefieldinit E
	extends [System.Runtime]System.ValueType
{
    .pack 0
    .size 1
	// Methods
	.method public hidebysig static 
		void Method<S> (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			!!S x
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 15 (0xf)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: callvirt instance void C::Increment<!!S>(!!0)
		IL_0007: ldarg.0
		IL_0008: ldarg.1
		IL_0009: call void E::EIncrement<!!S>(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), !!0)
		IL_000e: ret
	} // end of method E::Method
	.method public hidebysig static 
		void EIncrement<S> (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			!!S x
		) cil managed 
	{
		// Method begins at RVA 0x2060
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: callvirt instance void C::Increment<!!S>(!!0)
		IL_0007: ret
	} // end of method E::EIncrement
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			class C ''
		) cil managed 
	{
		// Method begins at RVA 0x2069
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E::'<ImplicitExtension>$'
} // end of class E
""");

        comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_05()
    {
        var src = """
implicit extension E<T> for T where T : class, I1
{
    public void Method()
    {
        this.Increment();
        this.EIncrement();
    }

    public void EIncrement()
    {
        this.Increment();
    }
}

interface I1
{
    void Increment();
}

class Program
{
    static void Main()
    {
        Test1();
        Test2();
    }

    static void Test1()
    {
        var c = new C();
        c.Method();
        System.Console.WriteLine(c.F);
    }

    static void Test2()
    {
        GetC().Method();
    }

    static C GetC() => new C();
}

class C : I1
{
    public int F;

    public void Increment()
    {
        F++;
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1",
"""
{
  // Code size       22 (0x16)
  .maxstack  2
  IL_0000:  newobj     "C..ctor()"
  IL_0005:  dup
  IL_0006:  call       "void E<C>.Method(C)"
  IL_000b:  ldfld      "int C.F"
  IL_0010:  call       "void System.Console.WriteLine(int)"
  IL_0015:  ret
}
""");

        verifier.VerifyIL("Program.Test2",
"""
{
  // Code size       11 (0xb)
  .maxstack  1
  IL_0000:  call       "C Program.GetC()"
  IL_0005:  call       "void E<C>.Method(C)"
  IL_000a:  ret
}
""");

        verifier.VerifyIL("E<T>.Method(T)",
"""
{
  // Code size       18 (0x12)
  .maxstack  1
  IL_0000:  ldarg.0
  IL_0001:  box        "T"
  IL_0006:  callvirt   "void I1.Increment()"
  IL_000b:  ldarg.0
  IL_000c:  call       "void E<T>.EIncrement(T)"
  IL_0011:  ret
}
""");

        verifier.VerifyTypeIL("E`1",
"""
.class private sequential ansi sealed beforefieldinit E`1<class (I1) T>
	extends [System.Runtime]System.ValueType
{
    .pack 0
    .size 1
	// Methods
	.method public hidebysig static 
		void Method (
			!T modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 18 (0x12)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: box !T
		IL_0006: callvirt instance void I1::Increment()
		IL_000b: ldarg.0
		IL_000c: call void valuetype E`1<!T>::EIncrement(!0 modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute))
		IL_0011: ret
	} // end of method E`1::Method
	.method public hidebysig static 
		void EIncrement (
			!T modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x2063
		// Code size 12 (0xc)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: box !T
		IL_0006: callvirt instance void I1::Increment()
		IL_000b: ret
	} // end of method E`1::EIncrement
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			!T ''
		) cil managed 
	{
		// Method begins at RVA 0x2070
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E`1::'<ImplicitExtension>$'
} // end of class E`1
""");

        comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_06()
    {
        var src = """
implicit extension E<T> for T where T : I1
{
    public void Method()
    {
        this.Increment();
        this.EIncrement();
    }

    public void EIncrement()
    {
        this.Increment();
    }
}

interface I1
{
    void Increment();
}

class Program
{
    static void Main()
    {
        Test1();
        Test2();
        Test3();
        Test4();
    }

    static void Test1()
    {
        var c = new C();
        c.Method();
        System.Console.Write(c.F);
    }

    static void Test2()
    {
        GetC().Method();
    }

    static C GetC() => new C();

    static void Test3()
    {
        var s = new S();
        s.Method();
        System.Console.Write(s.F);
    }

    static void Test4()
    {
        GetS().Method();
    }

    static S GetS() => new S();
}

class C : I1
{
    public int F;

    public void Increment()
    {
        F++;
    }
}

struct S : I1
{
    public int F;

    public void Increment()
    {
        F++;
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("22"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1",
"""
{
  // Code size       25 (0x19)
  .maxstack  1
  .locals init (C V_0) //c
  IL_0000:  newobj     "C..ctor()"
  IL_0005:  stloc.0
  IL_0006:  ldloca.s   V_0
  IL_0008:  call       "void E<C>.Method(ref C)"
  IL_000d:  ldloc.0
  IL_000e:  ldfld      "int C.F"
  IL_0013:  call       "void System.Console.Write(int)"
  IL_0018:  ret
}
""");

        verifier.VerifyIL("Program.Test2",
"""
{
  // Code size       14 (0xe)
  .maxstack  1
  .locals init (C V_0)
  IL_0000:  call       "C Program.GetC()"
  IL_0005:  stloc.0
  IL_0006:  ldloca.s   V_0
  IL_0008:  call       "void E<C>.Method(ref C)"
  IL_000d:  ret
}
""");

        verifier.VerifyIL("Program.Test3",
"""
{
  // Code size       27 (0x1b)
  .maxstack  1
  .locals init (S V_0) //s
  IL_0000:  ldloca.s   V_0
  IL_0002:  initobj    "S"
  IL_0008:  ldloca.s   V_0
  IL_000a:  call       "void E<S>.Method(ref S)"
  IL_000f:  ldloc.0
  IL_0010:  ldfld      "int S.F"
  IL_0015:  call       "void System.Console.Write(int)"
  IL_001a:  ret
}
""");

        verifier.VerifyIL("Program.Test4",
"""
{
  // Code size       14 (0xe)
  .maxstack  1
  .locals init (S V_0)
  IL_0000:  call       "S Program.GetS()"
  IL_0005:  stloc.0
  IL_0006:  ldloca.s   V_0
  IL_0008:  call       "void E<S>.Method(ref S)"
  IL_000d:  ret
}
""");

        // PROTOTYPE(roles): The constraint call is probably a subject to a receiver overwrite during argument evaluation. 
        verifier.VerifyIL("E<T>.Method(ref T)",
"""
{
  // Code size       19 (0x13)
  .maxstack  1
  IL_0000:  ldarg.0
  IL_0001:  constrained. "T"
  IL_0007:  callvirt   "void I1.Increment()"
  IL_000c:  ldarg.0
  IL_000d:  call       "void E<T>.EIncrement(ref T)"
  IL_0012:  ret
}
""");

        verifier.VerifyTypeIL("E`1",
"""
.class private sequential ansi sealed beforefieldinit E`1<(I1) T>
	extends [System.Runtime]System.ValueType
{
    .pack 0
    .size 1
	// Methods
	.method public hidebysig static 
		void Method (
			!T modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 19 (0x13)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: constrained. !T
		IL_0007: callvirt instance void I1::Increment()
		IL_000c: ldarg.0
		IL_000d: call void valuetype E`1<!T>::EIncrement(!0 modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&)
		IL_0012: ret
	} // end of method E`1::Method
	.method public hidebysig static 
		void EIncrement (
			!T modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x2064
		// Code size 13 (0xd)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: constrained. !T
		IL_0007: callvirt instance void I1::Increment()
		IL_000c: ret
	} // end of method E`1::EIncrement
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			!T ''
		) cil managed 
	{
		// Method begins at RVA 0x2072
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E`1::'<ImplicitExtension>$'
} // end of class E`1
""");

        comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("22"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_07()
    {
        var src = """
implicit extension E<T> for T where T : struct, I1
{
    public void Method()
    {
        this.Increment();
        this.EIncrement();
    }

    public void EIncrement()
    {
        this.Increment();
    }
}

interface I1
{
    void Increment();
}

class Program
{
    static void Main()
    {
        Test3();
        Test4();
    }

    static void Test3()
    {
        var s = new S();
        s.Method();
        System.Console.Write(s.F);
    }

    static void Test4()
    {
        GetS().Method();
    }

    static S GetS() => new S();
}

struct S : I1
{
    public int F;

    public void Increment()
    {
        F++;
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test3",
"""
{
  // Code size       27 (0x1b)
  .maxstack  1
  .locals init (S V_0) //s
  IL_0000:  ldloca.s   V_0
  IL_0002:  initobj    "S"
  IL_0008:  ldloca.s   V_0
  IL_000a:  call       "void E<S>.Method(ref S)"
  IL_000f:  ldloc.0
  IL_0010:  ldfld      "int S.F"
  IL_0015:  call       "void System.Console.Write(int)"
  IL_001a:  ret
}
""");

        verifier.VerifyIL("Program.Test4",
"""
{
  // Code size       14 (0xe)
  .maxstack  1
  .locals init (S V_0)
  IL_0000:  call       "S Program.GetS()"
  IL_0005:  stloc.0
  IL_0006:  ldloca.s   V_0
  IL_0008:  call       "void E<S>.Method(ref S)"
  IL_000d:  ret
}
""");

        verifier.VerifyIL("E<T>.Method(ref T)",
"""
{
  // Code size       19 (0x13)
  .maxstack  1
  IL_0000:  ldarg.0
  IL_0001:  constrained. "T"
  IL_0007:  callvirt   "void I1.Increment()"
  IL_000c:  ldarg.0
  IL_000d:  call       "void E<T>.EIncrement(ref T)"
  IL_0012:  ret
}
""");

        verifier.VerifyTypeIL("E`1",
"""
.class private sequential ansi sealed beforefieldinit E`1<valuetype .ctor (I1, [System.Runtime]System.ValueType) T>
	extends [System.Runtime]System.ValueType
{
    .pack 0
    .size 1
	// Methods
	.method public hidebysig static 
		void Method (
			!T modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 19 (0x13)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: constrained. !T
		IL_0007: callvirt instance void I1::Increment()
		IL_000c: ldarg.0
		IL_000d: call void valuetype E`1<!T>::EIncrement(!0 modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&)
		IL_0012: ret
	} // end of method E`1::Method
	.method public hidebysig static 
		void EIncrement (
			!T modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x2064
		// Code size 13 (0xd)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: constrained. !T
		IL_0007: callvirt instance void I1::Increment()
		IL_000c: ret
	} // end of method E`1::EIncrement
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			!T ''
		) cil managed 
	{
		// Method begins at RVA 0x2072
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E`1::'<ImplicitExtension>$'
} // end of class E`1
""");

        comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_08()
    {
        var src = """
implicit extension E for C
{
    public int Method(int x)
    {
        return x;
    }
}

class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        System.Console.WriteLine(c.Method(123));
    }
}

class C
{
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("E.Method(C, int)",
"""
{
  // Code size        2 (0x2)
  .maxstack  1
  IL_0000:  ldarg.1
  IL_0001:  ret
}
""");

        comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_09()
    {
        var src = """
implicit extension E for C
{
    public T Method<T>(T x)
    {
        return x;
    }
}

class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        System.Console.WriteLine(c.Method(123));
    }
}

class C
{
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("E.Method<T>(C, T)",
"""
{
  // Code size        2 (0x2)
  .maxstack  1
  IL_0000:  ldarg.1
  IL_0001:  ret
}
""");

        comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_10()
    {
        var src = """
implicit extension E for C
{
    public T Method<T>(T x)
    {

        T local(T y) => Method2(x);
        return local(x);
    }

    public T Method2<T>(T x)
    {
        return x;
    }
}

class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        System.Console.WriteLine(c.Method(123));
    }
}

class C
{
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("E.Method<T>(C, T)",
"""
{
  // Code size       30 (0x1e)
  .maxstack  2
  .locals init (E.<>c__DisplayClass0_0<T> V_0) //CS$<>8__locals0
  IL_0000:  ldloca.s   V_0
  IL_0002:  ldarg.0
  IL_0003:  stfld      "C E.<>c__DisplayClass0_0<T>.<>4__this"
  IL_0008:  ldloca.s   V_0
  IL_000a:  ldarg.1
  IL_000b:  stfld      "T E.<>c__DisplayClass0_0<T>.x"
  IL_0010:  ldloc.0
  IL_0011:  ldfld      "T E.<>c__DisplayClass0_0<T>.x"
  IL_0016:  ldloca.s   V_0
  IL_0018:  call       "T E.<Method>b__0_0<T>(T, ref E.<>c__DisplayClass0_0<T>)"
  IL_001d:  ret
}
""");

        comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_11()
    {
        var src = """
implicit extension E for C
{
    public T Method<T>(T x)
    {

        var d = (T y) => Method2(x);
        return d(x);
    }

    public T Method2<T>(T x)
    {
        return x;
    }
}

class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        System.Console.WriteLine(c.Method(123));
    }
}

class C
{
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("E.Method<T>(C, T)",
"""
{
  // Code size       44 (0x2c)
  .maxstack  2
  .locals init (E.<>c__DisplayClass0_0<T> V_0) //CS$<>8__locals0
  IL_0000:  newobj     "E.<>c__DisplayClass0_0<T>..ctor()"
  IL_0005:  stloc.0
  IL_0006:  ldloc.0
  IL_0007:  ldarg.0
  IL_0008:  stfld      "C E.<>c__DisplayClass0_0<T>.<>4__this"
  IL_000d:  ldloc.0
  IL_000e:  ldarg.1
  IL_000f:  stfld      "T E.<>c__DisplayClass0_0<T>.x"
  IL_0014:  ldloc.0
  IL_0015:  ldftn      "T E.<>c__DisplayClass0_0<T>.<Method>b__0(T)"
  IL_001b:  newobj     "System.Func<T, T>..ctor(object, nint)"
  IL_0020:  ldloc.0
  IL_0021:  ldfld      "T E.<>c__DisplayClass0_0<T>.x"
  IL_0026:  callvirt   "T System.Func<T, T>.Invoke(T)"
  IL_002b:  ret
}
""");

        comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_12()
    {
        var src = """
implicit extension E for C
{
    public T Method<T>(T x)
    {

        T local(T y) => Method2(y);
        return local(x);
    }

    public T Method2<T>(T x)
    {
        return x;
    }
}

class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        System.Console.WriteLine(c.Method(123));
    }
}

class C
{
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("E.Method<T>(C, T)",
"""
{
  // Code size       17 (0x11)
  .maxstack  2
  .locals init (E.<>c__DisplayClass0_0<T> V_0) //CS$<>8__locals0
  IL_0000:  ldloca.s   V_0
  IL_0002:  ldarg.0
  IL_0003:  stfld      "C E.<>c__DisplayClass0_0<T>.<>4__this"
  IL_0008:  ldarg.1
  IL_0009:  ldloca.s   V_0
  IL_000b:  call       "T E.<Method>b__0_0<T>(T, ref E.<>c__DisplayClass0_0<T>)"
  IL_0010:  ret
}
""");

        comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_13()
    {
        var src = """
implicit extension E for C
{
    public T Method<T>(T x)
    {

        var d = (T y) => Method2(y);
        return d(x);
    }

    public T Method2<T>(T x)
    {
        return x;
    }
}

class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        System.Console.WriteLine(c.Method(123));
    }
}

class C
{
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("E.Method<T>(C, T)",
"""
{
  // Code size       30 (0x1e)
  .maxstack  3
  IL_0000:  newobj     "E.<>c__DisplayClass0_0<T>..ctor()"
  IL_0005:  dup
  IL_0006:  ldarg.0
  IL_0007:  stfld      "C E.<>c__DisplayClass0_0<T>.<>4__this"
  IL_000c:  ldftn      "T E.<>c__DisplayClass0_0<T>.<Method>b__0(T)"
  IL_0012:  newobj     "System.Func<T, T>..ctor(object, nint)"
  IL_0017:  ldarg.1
  IL_0018:  callvirt   "T System.Func<T, T>.Invoke(T)"
  IL_001d:  ret
}
""");

        comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_14()
    {
        var src = """
implicit extension E for C
{
    public T Method<T>(T x)
    {

        T local()
        {
            T y = x;
            return Method2(y);
        }

        return local();
    }

    public T Method2<T>(T x)
    {
        return x;
    }
}

class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        System.Console.WriteLine(c.Method(123));
    }
}

class C
{
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        comp = CreateCompilation(src, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("123"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_15()
    {
        var src1 = """
public implicit extension E for C
{
    public void Method()
    {
        System.Action d = this.Method2;
        d();
    }

    public void Method2()
    {
        System.Action d = this.Increment;
        d();
    }
}

public class C
{
    public int F;

    public void Increment()
    {
        F++;
    }
}
""";
        var src2 = """
class Program
{
    static void Main()
    {
        Test1();
        Test2();
    }

    static void Test1()
    {
        var c = new C();
        System.Action d = c.Method;
        d();
        System.Console.Write(c.F);
    }

    static void Test2()
    {
        var c = new C();
        var d = new System.Action(c.Method);
        d();
        System.Console.Write(c.F);
    }
}
""";
        var comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("11"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var test1IL =
"""
{
  // Code size       33 (0x21)
  .maxstack  3
  IL_0000:  newobj     "C..ctor()"
  IL_0005:  dup
  IL_0006:  ldftn      "void E.Method(C)"
  IL_000c:  newobj     "System.Action..ctor(object, nint)"
  IL_0011:  callvirt   "void System.Action.Invoke()"
  IL_0016:  ldfld      "int C.F"
  IL_001b:  call       "void System.Console.Write(int)"
  IL_0020:  ret
}
""";
        verifier.VerifyIL("Program.Test1", test1IL);
        verifier.VerifyIL("Program.Test2", test1IL);

        verifier.VerifyIL("E.Method(C)", """
{
  // Code size       18 (0x12)
  .maxstack  2
  IL_0000:  ldarg.0
  IL_0001:  ldftn      "void E.Method2(C)"
  IL_0007:  newobj     "System.Action..ctor(object, nint)"
  IL_000c:  callvirt   "void System.Action.Invoke()"
  IL_0011:  ret
}
""");

        verifier.VerifyIL("E.Method2(C)", """
{
  // Code size       18 (0x12)
  .maxstack  2
  IL_0000:  ldarg.0
  IL_0001:  ldftn      "void C.Increment()"
  IL_0007:  newobj     "System.Action..ctor(object, nint)"
  IL_000c:  callvirt   "void System.Action.Invoke()"
  IL_0011:  ret
}
""");

        comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("11"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var comp1 = CreateCompilation(src1, targetFramework: TargetFramework.NetStandard20, options: TestOptions.ReleaseDll);

        var comp2 = CreateCompilation(src2, references: [comp1.ToMetadataReference()], targetFramework: TargetFramework.Net80,
            options: TestOptions.ReleaseExe.WithSpecificDiagnosticOptions("CS1701", ReportDiagnostic.Suppress)); // warning CS1701: Assuming assembly reference 'System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' used by '512c7a1c-7c4e-4467-84af-5b75683f75fb' matches identity 'System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' of 'System.Runtime', you may need to supply runtime policy
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("11"), verify: Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
        verifier.VerifyIL("Program.Test2", test1IL);

        comp2 = CreateCompilation(src2, references: [comp1.EmitToImageReference()], targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("11"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
        verifier.VerifyIL("Program.Test2", test1IL);
    }

    [Fact]
    public void InstanceMethod_Metadata_16()
    {
        var src1 = """
public implicit extension E for C
{
    public void Method()
    {
        System.Action d = this.Method2;
        d();
    }

    public void Method2()
    {
        System.Action d = this.Increment;
        d();
    }
}

public struct C
{
    public int F;

    public void Increment()
    {
        F++;
    }
}
""";
        var src2 = """
class Program
{
    static void Main()
    {
        Test1();
        Test2();
    }

    static void Test1()
    {
        var c = new C();
        System.Action d = c.Method;
        d();
        System.Console.Write(c.F);
    }

    static void Test2()
    {
        var c = new C();
        var d = new System.Action(c.Method);
        d();
        System.Console.Write(c.F);
    }
}
""";
        var comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);

        // PROTOTYPE(roles): Probably should report ErrorCode.ERR_ValueTypeExtDelegate instead, like we do for a legacy extension method 
        Verification verify = Verification.Fails.WithILVerifyMessage(
"""
[Method]: Unrecognized arguments for delegate .ctor. { Offset = 0x11 }
[Test1]: Unrecognized arguments for delegate .ctor. { Offset = 0x15 }
[Test2]: Unrecognized arguments for delegate .ctor. { Offset = 0x15 }
""");
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("00"), verify: verify).VerifyDiagnostics();

        var test1IL =
"""
{
  // Code size       42 (0x2a)
  .maxstack  3
  .locals init (C V_0)
  IL_0000:  ldloca.s   V_0
  IL_0002:  initobj    "C"
  IL_0008:  ldloc.0
  IL_0009:  dup
  IL_000a:  box        "C"
  IL_000f:  ldftn      "void E.Method(ref C)"
  IL_0015:  newobj     "System.Action..ctor(object, nint)"
  IL_001a:  callvirt   "void System.Action.Invoke()"
  IL_001f:  ldfld      "int C.F"
  IL_0024:  call       "void System.Console.Write(int)"
  IL_0029:  ret
}
""";
        verifier.VerifyIL("Program.Test1", test1IL);
        verifier.VerifyIL("Program.Test2", test1IL);

        verifier.VerifyIL("E.Method(ref C)", """
{
  // Code size       28 (0x1c)
  .maxstack  2
  IL_0000:  ldarg.0
  IL_0001:  ldobj      "C"
  IL_0006:  box        "C"
  IL_000b:  ldftn      "void E.Method2(ref C)"
  IL_0011:  newobj     "System.Action..ctor(object, nint)"
  IL_0016:  callvirt   "void System.Action.Invoke()"
  IL_001b:  ret
}
""");

        verifier.VerifyIL("E.Method2(ref C)", """
{
  // Code size       28 (0x1c)
  .maxstack  2
  IL_0000:  ldarg.0
  IL_0001:  ldobj      "C"
  IL_0006:  box        "C"
  IL_000b:  ldftn      "void C.Increment()"
  IL_0011:  newobj     "System.Action..ctor(object, nint)"
  IL_0016:  callvirt   "void System.Action.Invoke()"
  IL_001b:  ret
}
""");

        comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);

        // PROTOTYPE(roles): Probably should report ErrorCode.ERR_ValueTypeExtDelegate instead, like we do for a legacy extension method 
        Verification debugVerify = Verification.Fails.WithILVerifyMessage(
"""
[Method]: Unrecognized arguments for delegate .ctor. { Offset = 0x12 }
[Test1]: Unrecognized arguments for delegate .ctor. { Offset = 0x15 }
[Test2]: Unrecognized arguments for delegate .ctor. { Offset = 0x15 }
""");

        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("00"), verify: debugVerify).VerifyDiagnostics();

        var comp1 = CreateCompilation(src1, targetFramework: TargetFramework.NetStandard20, options: TestOptions.ReleaseDll);

        var comp2 = CreateCompilation(src2, references: [comp1.ToMetadataReference()], targetFramework: TargetFramework.Net80,
            options: TestOptions.ReleaseExe.WithSpecificDiagnosticOptions("CS1701", ReportDiagnostic.Suppress)); // warning CS1701: Assuming assembly reference 'System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' used by '512c7a1c-7c4e-4467-84af-5b75683f75fb' matches identity 'System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' of 'System.Runtime', you may need to supply runtime policy
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("00"), verify: Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
        verifier.VerifyIL("Program.Test2", test1IL);

        comp2 = CreateCompilation(src2, references: [comp1.EmitToImageReference()], targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);

        // PROTOTYPE(roles): Probably should report ErrorCode.ERR_ValueTypeExtDelegate instead, like we do for a legacy extension method 
        verify = Verification.Fails.WithILVerifyMessage(
"""
[Test1]: Unrecognized arguments for delegate .ctor. { Offset = 0x15 }
[Test2]: Unrecognized arguments for delegate .ctor. { Offset = 0x15 }
""");

        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("00"), verify: verify).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
        verifier.VerifyIL("Program.Test2", test1IL);
    }

    [Fact]
    public void InstanceMethod_Metadata_17()
    {
        var src1 = """
public implicit extension E for C
{
    public void Method()
    {
        System.Console.Write(1);
    }

    public static void Method(C c)
    {
        System.Console.Write(2);
    }
}

public class C
{
}
""";
        var src2 = """
class Program
{
    static void Main()
    {
        var c = new C();
        c.Method();
        C.Method(c);
    }
}
""";
        var comp = CreateCompilation(src1 + src2, options: TestOptions.ReleaseExe);
        CompileAndVerify(comp, expectedOutput: "12", verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var comp1 = CreateCompilation(src1, targetFramework: TargetFramework.NetStandard20, options: TestOptions.ReleaseDll);

        var comp2 = CreateCompilation(src2, references: [comp1.ToMetadataReference()], targetFramework: TargetFramework.Net80,
            options: TestOptions.ReleaseExe.WithSpecificDiagnosticOptions("CS1701", ReportDiagnostic.Suppress)); // warning CS1701: Assuming assembly reference 'System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' used by '512c7a1c-7c4e-4467-84af-5b75683f75fb' matches identity 'System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' of 'System.Runtime', you may need to supply runtime policy
        CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("12"), verify: Verification.Skipped).VerifyDiagnostics();

        comp1 = CreateCompilation(src1, options: TestOptions.ReleaseDll);
        comp2 = CreateCompilation(src2, references: [comp1.EmitToImageReference()], options: TestOptions.ReleaseExe);
        CompileAndVerify(comp2, expectedOutput: "12", verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethod_Metadata_18_modopt_instead_of_modreq()
    {
        // public implicit extension E for C
        // {
        //     public void Method() // But use modopt here instead
        //     {
        //     }
        // }
        // 
        // public class C
        // {
        // }
        var ilSource = """
.class public sequential ansi sealed beforefieldinit E
	extends [mscorlib]System.ValueType
{
	.method public hidebysig static 
		void Method (
			class C modopt([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this'
		) cil managed 
	{
		.maxstack 8
		IL_0006: ret
	}

	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			class C ''
		) cil managed 
	{
		.maxstack 8
		IL_0000: ret
	}
}

.class public auto ansi beforefieldinit C
    extends [mscorlib]System.Object
{
    .method public hidebysig specialname rtspecialname 
    	instance void .ctor () cil managed 
    {
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: call instance void [mscorlib]System.Object::.ctor()
    	IL_0006: ret
    }
}
""";

        var src2 = """
class Program
{
    static void Main()
    {
        var c = new C();
        c.Method();
        E.Method(c);
    }
}
""";
        var comp = CreateCompilationWithIL(src2, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (6,11): error CS7036: There is no argument given that corresponds to the required parameter '<>4__this' of 'E.Method(C)'
            //         c.Method();
            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "Method").WithArguments("<>4__this", "E.Method(C)").WithLocation(6, 11)
            );
    }

    [Fact]
    public void InstanceProperty_Metadata_01()
    {
        var src1 = """
public implicit extension E for C
{
    public int P1
    {
        get => this.P2;
        set => this.P2 = value; 
    }

    public int P2
    {
        get => this.P;
        set => this.P = value; 
    }
}

public class C
{
    public int P { get; set; }
}
""";
        var src2 = """
class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        c.P1 = 2;
        System.Console.WriteLine(c.P1);
    }
}
""";
        var comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var test1IL =
"""
{
  // Code size       23 (0x17)
  .maxstack  3
  IL_0000:  newobj     "C..ctor()"
  IL_0005:  dup
  IL_0006:  ldc.i4.2
  IL_0007:  call       "void E.P1[C].set"
  IL_000c:  call       "int E.P1[C].get"
  IL_0011:  call       "void System.Console.WriteLine(int)"
  IL_0016:  ret
}
""";
        verifier.VerifyIL("Program.Test1", test1IL);

        verifier.VerifyTypeIL("E",
"""
.class public sequential ansi sealed beforefieldinit E
	extends [System.Runtime]System.ValueType
{
    .pack 0
    .size 1
	// Methods
	.method public hidebysig specialname static 
		int32 get_P1 (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 7 (0x7)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: call int32 E::get_P2(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute))
		IL_0006: ret
	} // end of method E::get_P1
	.method public hidebysig specialname static 
		void set_P1 (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			int32 'value'
		) cil managed 
	{
		// Method begins at RVA 0x2058
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: call void E::set_P2(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), int32)
		IL_0007: ret
	} // end of method E::set_P1
	.method public hidebysig specialname static 
		int32 get_P2 (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x2061
		// Code size 7 (0x7)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: callvirt instance int32 C::get_P()
		IL_0006: ret
	} // end of method E::get_P2
	.method public hidebysig specialname static 
		void set_P2 (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			int32 'value'
		) cil managed 
	{
		// Method begins at RVA 0x2069
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: callvirt instance void C::set_P(int32)
		IL_0007: ret
	} // end of method E::set_P2
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			class C ''
		) cil managed 
	{
		// Method begins at RVA 0x2072
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E::'<ImplicitExtension>$'
	// Properties
	.property int32 P1(
		class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this'
	)
	{
		.get int32 E::get_P1(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute))
		.set void E::set_P1(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), int32)
	}
	.property int32 P2(
		class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this'
	)
	{
		.get int32 E::get_P2(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute))
		.set void E::set_P2(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), int32)
	}
} // end of class E
""");

        comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var comp1 = CreateCompilation(src1, targetFramework: TargetFramework.NetStandard20, options: TestOptions.ReleaseDll);

        var comp2 = CreateCompilation(src2, references: [comp1.ToMetadataReference()], targetFramework: TargetFramework.Net80,
            options: TestOptions.ReleaseExe.WithSpecificDiagnosticOptions("CS1701", ReportDiagnostic.Suppress)); // warning CS1701: Assuming assembly reference 'System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' used by '512c7a1c-7c4e-4467-84af-5b75683f75fb' matches identity 'System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' of 'System.Runtime', you may need to supply runtime policy
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("2"), verify: Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);

        comp2 = CreateCompilation(src2, references: [comp1.EmitToImageReference()], targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
    }

    [Fact]
    public void InstanceProperty_Metadata_02()
    {
        var src1 = """
public implicit extension E for C
{
    public int P1
    {
        get => this.P2;
        set => this.P2 = value; 
    }

    public int P2
    {
        get => this.P;
        set => this.P = value; 
    }
}

public struct C
{
    public int P { get; set; }
}
""";
        var src2 = """
class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        c.P1 = 2;
        System.Console.WriteLine(c.P1);
    }
}
""";
        var comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var test1IL =
"""
{
  // Code size       29 (0x1d)
  .maxstack  2
  .locals init (C V_0) //c
  IL_0000:  ldloca.s   V_0
  IL_0002:  initobj    "C"
  IL_0008:  ldloca.s   V_0
  IL_000a:  ldc.i4.2
  IL_000b:  call       "void E.P1[ref C].set"
  IL_0010:  ldloca.s   V_0
  IL_0012:  call       "int E.P1[ref C].get"
  IL_0017:  call       "void System.Console.WriteLine(int)"
  IL_001c:  ret
}
""";
        verifier.VerifyIL("Program.Test1", test1IL);

        verifier.VerifyTypeIL("E",
"""
.class public sequential ansi sealed beforefieldinit E
	extends [System.Runtime]System.ValueType
{
    .pack 0
    .size 1
	// Methods
	.method public hidebysig specialname static 
		int32 get_P1 (
			valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 7 (0x7)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: call int32 E::get_P2(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&)
		IL_0006: ret
	} // end of method E::get_P1
	.method public hidebysig specialname static 
		void set_P1 (
			valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
			int32 'value'
		) cil managed 
	{
		// Method begins at RVA 0x2058
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: call void E::set_P2(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&, int32)
		IL_0007: ret
	} // end of method E::set_P1
	.method public hidebysig specialname static 
		int32 get_P2 (
			valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
		) cil managed 
	{
		// Method begins at RVA 0x2061
		// Code size 7 (0x7)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: call instance int32 C::get_P()
		IL_0006: ret
	} // end of method E::get_P2
	.method public hidebysig specialname static 
		void set_P2 (
			valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
			int32 'value'
		) cil managed 
	{
		// Method begins at RVA 0x2069
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: call instance void C::set_P(int32)
		IL_0007: ret
	} // end of method E::set_P2
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			valuetype C ''
		) cil managed 
	{
		// Method begins at RVA 0x2072
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E::'<ImplicitExtension>$'
	// Properties
	.property int32 P1(
		valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
	)
	{
		.get int32 E::get_P1(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&)
		.set void E::set_P1(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&, int32)
	}
	.property int32 P2(
		valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
	)
	{
		.get int32 E::get_P2(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&)
		.set void E::set_P2(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&, int32)
	}
} // end of class E
""");

        comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var comp1 = CreateCompilation(src1, targetFramework: TargetFramework.NetStandard20, options: TestOptions.ReleaseDll);

        var comp2 = CreateCompilation(src2, references: [comp1.ToMetadataReference()], targetFramework: TargetFramework.Net80,
            options: TestOptions.ReleaseExe.WithSpecificDiagnosticOptions("CS1701", ReportDiagnostic.Suppress)); // warning CS1701: Assuming assembly reference 'System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' used by '512c7a1c-7c4e-4467-84af-5b75683f75fb' matches identity 'System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' of 'System.Runtime', you may need to supply runtime policy
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("2"), verify: Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);

        comp2 = CreateCompilation(src2, references: [comp1.EmitToImageReference()], targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
    }

    [Fact]
    public void InstanceIndexer_Metadata_01()
    {
        var src1 = """
public implicit extension E for C
{
    public int this[int x]
    {
        get => this.P;
        set => this.P = value; 
    }
}

public class C
{
    public int P { get; set; }
}
""";
        var src2 = """
class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        c[1] = 2;
        System.Console.WriteLine(c[1]);
    }
}
""";
        var comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);

        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var test1IL =
"""
{
  // Code size       25 (0x19)
  .maxstack  4
  IL_0000:  newobj     "C..ctor()"
  IL_0005:  dup
  IL_0006:  ldc.i4.1
  IL_0007:  ldc.i4.2
  IL_0008:  call       "void E.this[C, int].set"
  IL_000d:  ldc.i4.1
  IL_000e:  call       "int E.this[C, int].get"
  IL_0013:  call       "void System.Console.WriteLine(int)"
  IL_0018:  ret
}
""";
        verifier.VerifyIL("Program.Test1", test1IL);

        verifier.VerifyTypeIL("E",
"""
.class public sequential ansi sealed beforefieldinit E
	extends [System.Runtime]System.ValueType
{
	.custom instance void [System.Runtime]System.Reflection.DefaultMemberAttribute::.ctor(string) = (
		01 00 04 49 74 65 6d 00 00
	)
    .pack 0
    .size 1
	// Methods
	.method public hidebysig specialname static 
		int32 get_Item (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			int32 x
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 7 (0x7)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: callvirt instance int32 C::get_P()
		IL_0006: ret
	} // end of method E::get_Item
	.method public hidebysig specialname static 
		void set_Item (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			int32 x,
			int32 'value'
		) cil managed 
	{
		// Method begins at RVA 0x2058
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.2
		IL_0002: callvirt instance void C::set_P(int32)
		IL_0007: ret
	} // end of method E::set_Item
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			class C ''
		) cil managed 
	{
		// Method begins at RVA 0x2061
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E::'<ImplicitExtension>$'
	// Properties
	.property int32 Item(
		class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
		int32 x
	)
	{
		.get int32 E::get_Item(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), int32)
		.set void E::set_Item(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), int32, int32)
	}
} // end of class E
""");

        comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var comp1 = CreateCompilation(src1, targetFramework: TargetFramework.NetStandard20, options: TestOptions.ReleaseDll);

        var comp2 = CreateCompilation(src2, references: [comp1.ToMetadataReference()], targetFramework: TargetFramework.Net80,
            options: TestOptions.ReleaseExe.WithSpecificDiagnosticOptions("CS1701", ReportDiagnostic.Suppress)); // warning CS1701: Assuming assembly reference 'System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' used by '512c7a1c-7c4e-4467-84af-5b75683f75fb' matches identity 'System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' of 'System.Runtime', you may need to supply runtime policy
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("2"), verify: Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);

        comp2 = CreateCompilation(src2, references: [comp1.EmitToImageReference()], targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
    }

    [Fact]
    public void InstanceIndexer_Metadata_02()
    {
        var src1 = """
public implicit extension E for C
{
    public int this[int x]
    {
        get => this.P;
        set => this.P = value; 
    }
}

public struct C
{
    public int P { get; set; }
}
""";
        var src2 = """
class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        c[1] = 2;
        System.Console.WriteLine(c[1]);
    }
}
""";
        var comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);

        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var test1IL =
"""
{
  // Code size       31 (0x1f)
  .maxstack  3
  .locals init (C V_0) //c
  IL_0000:  ldloca.s   V_0
  IL_0002:  initobj    "C"
  IL_0008:  ldloca.s   V_0
  IL_000a:  ldc.i4.1
  IL_000b:  ldc.i4.2
  IL_000c:  call       "void E.this[ref C, int].set"
  IL_0011:  ldloca.s   V_0
  IL_0013:  ldc.i4.1
  IL_0014:  call       "int E.this[ref C, int].get"
  IL_0019:  call       "void System.Console.WriteLine(int)"
  IL_001e:  ret
}
""";
        verifier.VerifyIL("Program.Test1", test1IL);

        verifier.VerifyTypeIL("E",
"""
.class public sequential ansi sealed beforefieldinit E
	extends [System.Runtime]System.ValueType
{
	.custom instance void [System.Runtime]System.Reflection.DefaultMemberAttribute::.ctor(string) = (
		01 00 04 49 74 65 6d 00 00
	)
    .pack 0
    .size 1
	// Methods
	.method public hidebysig specialname static 
		int32 get_Item (
			valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
			int32 x
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 7 (0x7)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: call instance int32 C::get_P()
		IL_0006: ret
	} // end of method E::get_Item
	.method public hidebysig specialname static 
		void set_Item (
			valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
			int32 x,
			int32 'value'
		) cil managed 
	{
		// Method begins at RVA 0x2058
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.2
		IL_0002: call instance void C::set_P(int32)
		IL_0007: ret
	} // end of method E::set_Item
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			valuetype C ''
		) cil managed 
	{
		// Method begins at RVA 0x2061
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E::'<ImplicitExtension>$'
	// Properties
	.property int32 Item(
		valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
		int32 x
	)
	{
		.get int32 E::get_Item(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&, int32)
		.set void E::set_Item(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&, int32, int32)
	}
} // end of class E
""");

        comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var comp1 = CreateCompilation(src1, targetFramework: TargetFramework.NetStandard20, options: TestOptions.ReleaseDll);

        var comp2 = CreateCompilation(src2, references: [comp1.ToMetadataReference()], targetFramework: TargetFramework.Net80,
            options: TestOptions.ReleaseExe.WithSpecificDiagnosticOptions("CS1701", ReportDiagnostic.Suppress)); // warning CS1701: Assuming assembly reference 'System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' used by '512c7a1c-7c4e-4467-84af-5b75683f75fb' matches identity 'System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' of 'System.Runtime', you may need to supply runtime policy
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("2"), verify: Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);

        comp2 = CreateCompilation(src2, references: [comp1.EmitToImageReference()], targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("2"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
    }

    [Fact]
    public void InstanceEvent_Metadata_01()
    {
        var src1 = """
public implicit extension E for C
{
    public event System.Action E1
    {
        add => this.E2 += value ;
        remove => this.E2 -= value; 
    }

    public event System.Action E2
    {
        add => this.E += value;
        remove => this.E -= value; 
    }
}

public class C
{
    public event System.Action E;

    public void Fire() => E();
}
""";
        var src2 = """
class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        c.E1 += M2();
        c.Fire();
        c.E1 += M3();
        c.E1 -= M2();
        c.Fire();
    }

    static System.Action M2() => (() => System.Console.Write(2));
    static System.Action M3() => (() => System.Console.Write(3));
}
""";
        var comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("23"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var test1IL =
"""
{
  // Code size       50 (0x32)
  .maxstack  3
  IL_0000:  newobj     "C..ctor()"
  IL_0005:  dup
  IL_0006:  call       "System.Action Program.M2()"
  IL_000b:  call       "void E.E1.add"
  IL_0010:  dup
  IL_0011:  callvirt   "void C.Fire()"
  IL_0016:  dup
  IL_0017:  call       "System.Action Program.M3()"
  IL_001c:  call       "void E.E1.add"
  IL_0021:  dup
  IL_0022:  call       "System.Action Program.M2()"
  IL_0027:  call       "void E.E1.remove"
  IL_002c:  callvirt   "void C.Fire()"
  IL_0031:  ret
}
""";
        verifier.VerifyIL("Program.Test1", test1IL);

        verifier.VerifyTypeIL("E",
"""
.class public sequential ansi sealed beforefieldinit E
	extends [System.Runtime]System.ValueType
{
    .pack 0
    .size 1
	// Methods
	.method public hidebysig specialname static 
		void add_E1 (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			class [System.Runtime]System.Action 'value'
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: call void E::add_E2(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), class [System.Runtime]System.Action)
		IL_0007: ret
	} // end of method E::add_E1
	.method public hidebysig specialname static 
		void remove_E1 (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			class [System.Runtime]System.Action 'value'
		) cil managed 
	{
		// Method begins at RVA 0x2059
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: call void E::remove_E2(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), class [System.Runtime]System.Action)
		IL_0007: ret
	} // end of method E::remove_E1
	.method public hidebysig specialname static 
		void add_E2 (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			class [System.Runtime]System.Action 'value'
		) cil managed 
	{
		// Method begins at RVA 0x2062
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: callvirt instance void C::add_E(class [System.Runtime]System.Action)
		IL_0007: ret
	} // end of method E::add_E2
	.method public hidebysig specialname static 
		void remove_E2 (
			class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			class [System.Runtime]System.Action 'value'
		) cil managed 
	{
		// Method begins at RVA 0x206b
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: callvirt instance void C::remove_E(class [System.Runtime]System.Action)
		IL_0007: ret
	} // end of method E::remove_E2
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			class C ''
		) cil managed 
	{
		// Method begins at RVA 0x2074
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E::'<ImplicitExtension>$'
	// Events
	.event [System.Runtime]System.Action E1
	{
		.addon void E::add_E1(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), class [System.Runtime]System.Action)
		.removeon void E::remove_E1(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), class [System.Runtime]System.Action)
	}
	.event [System.Runtime]System.Action E2
	{
		.addon void E::add_E2(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), class [System.Runtime]System.Action)
		.removeon void E::remove_E2(class C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute), class [System.Runtime]System.Action)
	}
} // end of class E
""");

        comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("23"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var comp1 = CreateCompilation(src1, targetFramework: TargetFramework.NetStandard20, options: TestOptions.ReleaseDll);

        var comp2 = CreateCompilation(src2, references: [comp1.ToMetadataReference()], targetFramework: TargetFramework.Net80,
            options: TestOptions.ReleaseExe.WithSpecificDiagnosticOptions("CS1701", ReportDiagnostic.Suppress)); // warning CS1701: Assuming assembly reference 'System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' used by '512c7a1c-7c4e-4467-84af-5b75683f75fb' matches identity 'System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' of 'System.Runtime', you may need to supply runtime policy
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("23"), verify: Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);

        comp2 = CreateCompilation(src2, references: [comp1.EmitToImageReference()], targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("23"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
    }

    [Fact]
    public void InstanceEvent_Metadata_02()
    {
        var src1 = """
public implicit extension E for C
{
    public event System.Action E1
    {
        add => this.E2 += value ;
        remove => this.E2 -= value; 
    }

    public event System.Action E2
    {
        add => this.E += value;
        remove => this.E -= value; 
    }
}

public struct C
{
    public event System.Action E;

    public void Fire() => E();
}
""";
        var src2 = """
class Program
{
    static void Main()
    {
        Test1();
    }

    static void Test1()
    {
        var c = new C();
        c.E1 += M2();
        c.Fire();
        c.E1 += M3();
        c.E1 -= M2();
        c.Fire();
    }

    static System.Action M2() => (() => System.Console.Write(2));
    static System.Action M3() => (() => System.Console.Write(3));
}
""";
        var comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        var verifier = CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("23"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var test1IL =
"""
{
  // Code size       59 (0x3b)
  .maxstack  2
  .locals init (C V_0) //c
  IL_0000:  ldloca.s   V_0
  IL_0002:  initobj    "C"
  IL_0008:  ldloca.s   V_0
  IL_000a:  call       "System.Action Program.M2()"
  IL_000f:  call       "void E.E1.add"
  IL_0014:  ldloca.s   V_0
  IL_0016:  call       "void C.Fire()"
  IL_001b:  ldloca.s   V_0
  IL_001d:  call       "System.Action Program.M3()"
  IL_0022:  call       "void E.E1.add"
  IL_0027:  ldloca.s   V_0
  IL_0029:  call       "System.Action Program.M2()"
  IL_002e:  call       "void E.E1.remove"
  IL_0033:  ldloca.s   V_0
  IL_0035:  call       "void C.Fire()"
  IL_003a:  ret
}
""";
        verifier.VerifyIL("Program.Test1", test1IL);

        verifier.VerifyTypeIL("E",
"""
.class public sequential ansi sealed beforefieldinit E
	extends [System.Runtime]System.ValueType
{
    .pack 0
    .size 1
	// Methods
	.method public hidebysig specialname static 
		void add_E1 (
			valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
			class [System.Runtime]System.Action 'value'
		) cil managed 
	{
		// Method begins at RVA 0x2050
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: call void E::add_E2(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&, class [System.Runtime]System.Action)
		IL_0007: ret
	} // end of method E::add_E1
	.method public hidebysig specialname static 
		void remove_E1 (
			valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
			class [System.Runtime]System.Action 'value'
		) cil managed 
	{
		// Method begins at RVA 0x2059
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: call void E::remove_E2(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&, class [System.Runtime]System.Action)
		IL_0007: ret
	} // end of method E::remove_E1
	.method public hidebysig specialname static 
		void add_E2 (
			valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
			class [System.Runtime]System.Action 'value'
		) cil managed 
	{
		// Method begins at RVA 0x2062
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: call instance void C::add_E(class [System.Runtime]System.Action)
		IL_0007: ret
	} // end of method E::add_E2
	.method public hidebysig specialname static 
		void remove_E2 (
			valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
			class [System.Runtime]System.Action 'value'
		) cil managed 
	{
		// Method begins at RVA 0x206b
		// Code size 8 (0x8)
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: call instance void C::remove_E(class [System.Runtime]System.Action)
		IL_0007: ret
	} // end of method E::remove_E2
	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			valuetype C ''
		) cil managed 
	{
		// Method begins at RVA 0x2074
		// Code size 1 (0x1)
		.maxstack 8
		IL_0000: ret
	} // end of method E::'<ImplicitExtension>$'
	// Events
	.event [System.Runtime]System.Action E1
	{
		.addon void E::add_E1(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&, class [System.Runtime]System.Action)
		.removeon void E::remove_E1(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&, class [System.Runtime]System.Action)
	}
	.event [System.Runtime]System.Action E2
	{
		.addon void E::add_E2(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&, class [System.Runtime]System.Action)
		.removeon void E::remove_E2(valuetype C modreq([System.Runtime]System.Runtime.CompilerServices.ExtensionAttribute)&, class [System.Runtime]System.Action)
	}
} // end of class E
""");

        comp = CreateCompilation(src1 + src2, targetFramework: TargetFramework.Net80, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: IncludeExpectedOutput("23"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        var comp1 = CreateCompilation(src1, targetFramework: TargetFramework.NetStandard20, options: TestOptions.ReleaseDll);

        var comp2 = CreateCompilation(src2, references: [comp1.ToMetadataReference()], targetFramework: TargetFramework.Net80,
            options: TestOptions.ReleaseExe.WithSpecificDiagnosticOptions("CS1701", ReportDiagnostic.Suppress)); // warning CS1701: Assuming assembly reference 'System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' used by '512c7a1c-7c4e-4467-84af-5b75683f75fb' matches identity 'System.Runtime, Version=8.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a' of 'System.Runtime', you may need to supply runtime policy
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("23"), verify: Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);

        comp2 = CreateCompilation(src2, references: [comp1.EmitToImageReference()], targetFramework: TargetFramework.Net80, options: TestOptions.ReleaseExe);
        verifier = CompileAndVerify(comp2, expectedOutput: IncludeExpectedOutput("23"), verify: ExecutionConditionUtil.IsMonoOrCoreClr ? Verification.Passes : Verification.Skipped).VerifyDiagnostics();

        verifier.VerifyIL("Program.Test1", test1IL);
    }

    // PROTOTYPE(roles): Add flavors of "_Metadata" tests for an underlying type a type parameter known/unknown to be a reference type

    // PROTOTYPE(roles): Test capturing of struct underlying type into a closure in an instance extension member.  
    //                   Probably should be an error.

    // PROTOTYPE(roles): Test expression trees with instance members.

    // PROTOTYPE(roles): Ensure instance events are never treated as WINRT events.

    [Fact]
    public void InstanceMethod_Metadata_ConsumptionFromPreviousVersion_01()
    {
        // public implicit extension E for C
        // {
        //     public void Method()
        //     {
        //         this.Increment();
        //     }
        // }
        // 
        // public class C
        // {
        //     public int F;
        // 
        //     public void Increment()
        //     {
        //         F++;
        //     }
        // }
        var ilSource = """
.class public sequential ansi sealed beforefieldinit E
	extends [mscorlib]System.ValueType
{
	.method public hidebysig static 
		void Method (
			class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this'
		) cil managed 
	{
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: callvirt instance void C::Increment()
		IL_0006: ret
	}

	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			class C ''
		) cil managed 
	{
		.maxstack 8
		IL_0000: ret
	}
}

.class public auto ansi beforefieldinit C
    extends [mscorlib]System.Object
{
    .field public int32 F

    .method public hidebysig 
    	instance void Increment () cil managed 
    {
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: ldarg.0
    	IL_0002: ldfld int32 C::F
    	IL_0007: ldc.i4.1
    	IL_0008: add
    	IL_0009: stfld int32 C::F
    	IL_000e: ret
    }

    .method public hidebysig specialname rtspecialname 
    	instance void .ctor () cil managed 
    {
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: call instance void [mscorlib]System.Object::.ctor()
    	IL_0006: ret
    }
}
""";

        // The conditional compilation symbol PREVIOUSVERSIONOFCOMPILER is intentionally not defined.
        // The branch that is not taken reflects behavior of the compiler in main.
        // The test can be run manually in 'main' by copy/pasting it into a file and defining the conditional compilation symbol.
#if !PREVIOUSVERSIONOFCOMPILER
        var src2 = """
class Program
{
    static void Main()
    {
        var c = new C();
        System.Console.Write(c.F);
        c.Method();
        System.Console.Write(c.F);
        c.Method();
        System.Console.Write(c.F);
    }
}
""";
        var comp = CreateCompilationWithIL(src2, ilSource, options: TestOptions.ReleaseExe);
        CompileAndVerify(comp, expectedOutput: "012").VerifyDiagnostics();
#else
        var src2 = """
class Program
{
    static void Main()
    {
        var c = new C();
        System.Console.Write(c.F);
        E.Method(c);
        System.Console.Write(c.F);
        E.Method(c);
        System.Console.Write(c.F);
        c.Method();
    }
}
""";
        var comp = CreateCompilationWithIL(src2, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (7,11): error CS0570: 'E.Method(C)' is not supported by the language
            //         E.Method(c);
            Diagnostic(ErrorCode.ERR_BindToBogus, "Method").WithArguments("E.Method(C)").WithLocation(7, 11),
            // (9,11): error CS0570: 'E.Method(C)' is not supported by the language
            //         E.Method(c);
            Diagnostic(ErrorCode.ERR_BindToBogus, "Method").WithArguments("E.Method(C)").WithLocation(9, 11),
            // (11,11): error CS1061: 'C' does not contain a definition for 'Method' and no accessible extension method 'Method' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            //         c.Method();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Method").WithArguments("C", "Method").WithLocation(11, 11)
            );
#endif
    }

    [Fact]
    public void InstanceMethod_Metadata_ConsumptionFromPreviousVersion_02()
    {
        // public implicit extension E for C
        // {
        //     public void Method()
        //     {
        //         this.Increment();
        //     }
        // }
        // 
        // public struct C
        // {
        //     public int F;
        // 
        //     public void Increment()
        //     {
        //         F++;
        //     }
        // }
        var ilSource = """
.class public sequential ansi sealed beforefieldinit E
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static 
    	void Method (
    		valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
    	) cil managed 
    {
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: call instance void C::Increment()
    	IL_0006: ret
    }

    .method public hidebysig static 
    	void '<ImplicitExtension>$' (
    		valuetype C ''
    	) cil managed 
    {
    	.maxstack 8
    	IL_0000: ret
    }
}

.class public sequential ansi sealed beforefieldinit C
    extends [mscorlib]System.ValueType
{
    .field public int32 F

    .method public hidebysig 
    	instance void Increment () cil managed 
    {
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: ldarg.0
    	IL_0002: ldfld int32 C::F
    	IL_0007: ldc.i4.1
    	IL_0008: add
    	IL_0009: stfld int32 C::F
    	IL_000e: ret
    }
}
""";

        // The conditional compilation symbol PREVIOUSVERSIONOFCOMPILER is intentionally not defined.
        // The branch that is not taken reflects behavior of the compiler in main.
        // The test can be run manually in 'main' by copy/pasting it into a file and defining the conditional compilation symbol.
#if !PREVIOUSVERSIONOFCOMPILER
        var src2 = """
class Program
{
    static void Main()
    {
        var c = new C();
        System.Console.Write(c.F);
        c.Method();
        System.Console.Write(c.F);
        c.Method();
        System.Console.Write(c.F);
    }
}
""";
        var comp = CreateCompilationWithIL(src2, ilSource, options: TestOptions.ReleaseExe);
        CompileAndVerify(comp, expectedOutput: "012").VerifyDiagnostics();
#else
        var src2 = """
class Program
{
    static void Main()
    {
        var c = new C();
        System.Console.Write(c.F);
        E.Method(ref c);
        System.Console.Write(c.F);
        E.Method(ref c);
        System.Console.Write(c.F);
        c.Method();
    }
}
""";
        var comp = CreateCompilationWithIL(src2, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (7,11): error CS0570: 'E.Method(ref C)' is not supported by the language
            //         E.Method(ref c);
            Diagnostic(ErrorCode.ERR_BindToBogus, "Method").WithArguments("E.Method(ref C)").WithLocation(7, 11),
            // (9,11): error CS0570: 'E.Method(ref C)' is not supported by the language
            //         E.Method(ref c);
            Diagnostic(ErrorCode.ERR_BindToBogus, "Method").WithArguments("E.Method(ref C)").WithLocation(9, 11),
            // (11,11): error CS1061: 'C' does not contain a definition for 'Method' and no accessible extension method 'Method' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            //         c.Method();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Method").WithArguments("C", "Method").WithLocation(11, 11)
            );
#endif
    }

    [Fact]
    public void InstanceProperty_Metadata_ConsumptionFromPreviousVersion_01()
    {
        // public implicit extension E for C
        // {
        //     public int P1
        //     {
        //         get => this.P;
        //         set => this.P = value; 
        //     }
        // }
        // 
        // public class C
        // {
        //     public int P { get; set; }
        // }
        var ilSource = """
.class public sequential ansi sealed beforefieldinit E
	extends [mscorlib]System.ValueType
{
	.method public hidebysig specialname static 
		int32 get_P1 (
			class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this'
		) cil managed 
	{
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: callvirt instance int32 C::get_P()
		IL_0006: ret
	}

	.method public hidebysig specialname static 
		void set_P1 (
			class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			int32 'value'
		) cil managed 
	{
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: callvirt instance void C::set_P(int32)
		IL_0007: ret
	}

	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			class C ''
		) cil managed 
	{
		.maxstack 8
		IL_0000: ret
	}

	.property int32 P1(
		class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this'
	)
	{
		.get int32 E::get_P1(class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute))
		.set void E::set_P1(class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute), int32)
	}
}

.class public auto ansi beforefieldinit C
    extends [mscorlib]System.Object
{
    .field private int32 '<P>k__BackingField'
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
    	01 00 00 00
    )

    .method public hidebysig specialname 
    	instance int32 get_P () cil managed 
    {
    	.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
    		01 00 00 00
    	)
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: ldfld int32 C::'<P>k__BackingField'
    	IL_0006: ret
    }

    .method public hidebysig specialname 
    	instance void set_P (
    		int32 'value'
    	) cil managed 
    {
    	.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
    		01 00 00 00
    	)
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: ldarg.1
    	IL_0002: stfld int32 C::'<P>k__BackingField'
    	IL_0007: ret
    }

    .method public hidebysig specialname rtspecialname 
    	instance void .ctor () cil managed 
    {
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: call instance void [mscorlib]System.Object::.ctor()
    	IL_0006: ret
    }

    .property instance int32 P()
    {
    	.get instance int32 C::get_P()
    	.set instance void C::set_P(int32)
    }
}
""";

        var src2 = """
class Program
{
    static void Main()
    {
        var c = new C();
        c.P1 = 2;
        System.Console.WriteLine(c.P1);
    }
}
""";

        var comp = CreateCompilationWithIL(src2, ilSource, options: TestOptions.ReleaseExe);

        // The conditional compilation symbol PREVIOUSVERSIONOFCOMPILER is intentionally not defined.
        // The branch that is not taken reflects behavior of the compiler in main.
        // The test can be run manually in 'main' by copy/pasting it into a file and defining the conditional compilation symbol.
#if !PREVIOUSVERSIONOFCOMPILER
        CompileAndVerify(comp, expectedOutput: "2").VerifyDiagnostics();
#else
        comp.VerifyDiagnostics(
            // (6,11): error CS1061: 'C' does not contain a definition for 'P1' and no accessible extension method 'P1' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            //         c.P1 = 2;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "P1").WithArguments("C", "P1").WithLocation(6, 11),
            // (7,36): error CS1061: 'C' does not contain a definition for 'P1' and no accessible extension method 'P1' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            //         System.Console.WriteLine(c.P1);
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "P1").WithArguments("C", "P1").WithLocation(7, 36)
            );

        var src3 = """
class Program
{
    static void Main()
    {
        var c = new C();
        E.P1[c] = 2;
        System.Console.WriteLine(E.P1[c]);
    }
}
""";
        comp = CreateCompilationWithIL(src3, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (6,11): error CS1545: Property, indexer, or event 'E.P1[C]' is not supported by the language; try directly calling accessor methods 'E.get_P1(C)' or 'E.set_P1(C, int)'
            //         E.P1[c] = 2;
            Diagnostic(ErrorCode.ERR_BindToBogusProp2, "P1").WithArguments("E.P1[C]", "E.get_P1(C)", "E.set_P1(C, int)").WithLocation(6, 11),
            // (7,36): error CS1545: Property, indexer, or event 'E.P1[C]' is not supported by the language; try directly calling accessor methods 'E.get_P1(C)' or 'E.set_P1(C, int)'
            //         System.Console.WriteLine(E.P1[c]);
            Diagnostic(ErrorCode.ERR_BindToBogusProp2, "P1").WithArguments("E.P1[C]", "E.get_P1(C)", "E.set_P1(C, int)").WithLocation(7, 36)
            );

        var src4 = """
class Program
{
    static void Main()
    {
        var c = new C();
        E.set_P1(c, 2);
        System.Console.WriteLine(E.get_P1(c));
    }
}
""";
        comp = CreateCompilationWithIL(src4, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (6,11): error CS0570: 'E.set_P1(C, int)' is not supported by the language
            //         E.set_P1(c, 2);
            Diagnostic(ErrorCode.ERR_BindToBogus, "set_P1").WithArguments("E.set_P1(C, int)").WithLocation(6, 11),
            // (7,36): error CS0570: 'E.get_P1(C)' is not supported by the language
            //         System.Console.WriteLine(E.get_P1(c));
            Diagnostic(ErrorCode.ERR_BindToBogus, "get_P1").WithArguments("E.get_P1(C)").WithLocation(7, 36)
            );
#endif
    }

    [Fact]
    public void InstanceProperty_Metadata_ConsumptionFromPreviousVersion_02()
    {
        // public implicit extension E for C
        // {
        //     public int P1
        //     {
        //         get => this.P;
        //         set => this.P = value; 
        //     }
        // }
        // 
        // public struct C
        // {
        //     public int P { get; set; }
        // }
        var ilSource = """
.class public sequential ansi sealed beforefieldinit E
	extends [mscorlib]System.ValueType
{
	.method public hidebysig specialname static 
		int32 get_P1 (
			valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
		) cil managed 
	{
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: call instance int32 C::get_P()
		IL_0006: ret
	}

	.method public hidebysig specialname static 
		void set_P1 (
			valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
			int32 'value'
		) cil managed 
	{
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: call instance void C::set_P(int32)
		IL_0007: ret
	}

	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			valuetype C ''
		) cil managed 
	{
		.maxstack 8
		IL_0000: ret
	}

	.property int32 P1(
		valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this'
	)
	{
		.get int32 E::get_P1(valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)&)
		.set void E::set_P1(valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)&, int32)
	}
}

.class public sequential ansi sealed beforefieldinit C
    extends [mscorlib]System.ValueType
{
    .field private int32 '<P>k__BackingField'
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
    	01 00 00 00
    )

    .method public hidebysig specialname 
    	instance int32 get_P () cil managed 
    {
    	.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
    		01 00 00 00
    	)

    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: ldfld int32 C::'<P>k__BackingField'
    	IL_0006: ret
    }

    .method public hidebysig specialname 
    	instance void set_P (
    		int32 'value'
    	) cil managed 
    {
    	.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
    		01 00 00 00
    	)
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: ldarg.1
    	IL_0002: stfld int32 C::'<P>k__BackingField'
    	IL_0007: ret
    }

    .property instance int32 P()
    {
    	.get instance int32 C::get_P()
    	.set instance void C::set_P(int32)
    }
}
""";
        var src2 = """
class Program
{
    static void Main()
    {
        var c = new C();
        c.P1 = 2;
        System.Console.WriteLine(c.P1);
    }
}
""";
        var comp = CreateCompilationWithIL(src2, ilSource, options: TestOptions.ReleaseExe);

        // The conditional compilation symbol PREVIOUSVERSIONOFCOMPILER is intentionally not defined.
        // The branch that is not taken reflects behavior of the compiler in main.
        // The test can be run manually in 'main' by copy/pasting it into a file and defining the conditional compilation symbol.
#if !PREVIOUSVERSIONOFCOMPILER
        CompileAndVerify(comp, expectedOutput: "2").VerifyDiagnostics();
#else
        comp.VerifyDiagnostics(
            // (6,11): error CS1061: 'C' does not contain a definition for 'P1' and no accessible extension method 'P1' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            //         c.P1 = 2;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "P1").WithArguments("C", "P1").WithLocation(6, 11),
            // (7,36): error CS1061: 'C' does not contain a definition for 'P1' and no accessible extension method 'P1' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            //         System.Console.WriteLine(c.P1);
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "P1").WithArguments("C", "P1").WithLocation(7, 36)
            );

        var src3 = """
class Program
{
    static void Main()
    {
        var c = new C();
        E.P1[c] = 2;
        System.Console.WriteLine(E.P1[c]);
    }
}
""";
        comp = CreateCompilationWithIL(src3, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (6,11): error CS1545: Property, indexer, or event 'E.P1[ref C]' is not supported by the language; try directly calling accessor methods 'E.get_P1(ref C)' or 'E.set_P1(ref C, int)'
            //         E.P1[c] = 2;
            Diagnostic(ErrorCode.ERR_BindToBogusProp2, "P1").WithArguments("E.P1[ref C]", "E.get_P1(ref C)", "E.set_P1(ref C, int)").WithLocation(6, 11),
            // (7,36): error CS1545: Property, indexer, or event 'E.P1[ref C]' is not supported by the language; try directly calling accessor methods 'E.get_P1(ref C)' or 'E.set_P1(ref C, int)'
            //         System.Console.WriteLine(E.P1[c]);
            Diagnostic(ErrorCode.ERR_BindToBogusProp2, "P1").WithArguments("E.P1[ref C]", "E.get_P1(ref C)", "E.set_P1(ref C, int)").WithLocation(7, 36)
            );

        var src4 = """
class Program
{
    static void Main()
    {
        var c = new C();
        E.set_P1(ref c, 2);
        System.Console.WriteLine(E.get_P1(ref c));
    }
}
""";
        comp = CreateCompilationWithIL(src4, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (6,11): error CS0570: 'E.set_P1(ref C, int)' is not supported by the language
            //         E.set_P1(ref c, 2);
            Diagnostic(ErrorCode.ERR_BindToBogus, "set_P1").WithArguments("E.set_P1(ref C, int)").WithLocation(6, 11),
            // (7,36): error CS0570: 'E.get_P1(ref C)' is not supported by the language
            //         System.Console.WriteLine(E.get_P1(ref c));
            Diagnostic(ErrorCode.ERR_BindToBogus, "get_P1").WithArguments("E.get_P1(ref C)").WithLocation(7, 36)
            );
#endif
    }

    [Fact]
    public void InstanceIndexer_Metadata_ConsumptionFromPreviousVersion_01()
    {
        // public implicit extension E for C
        // {
        //     public int this[int i]
        //     {
        //         get => this.P;
        //         set => this.P = value; 
        //     }
        // }
        // 
        // public class C
        // {
        //     public int P { get; set; }
        // }
        var ilSource = """
.class public sequential ansi sealed beforefieldinit E
    extends [mscorlib]System.ValueType
{
    .custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) = (
    	01 00 04 49 74 65 6d 00 00
    )

    .method public hidebysig specialname static 
    	int32 get_Item (
    		class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
    		int32 i
    	) cil managed 
    {
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: callvirt instance int32 C::get_P()
    	IL_0006: ret
    }

    .method public hidebysig specialname static 
    	void set_Item (
    		class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
    		int32 i,
    		int32 'value'
    	) cil managed 
    {
    	// Method begins at RVA 0x206f
    	// Code size 8 (0x8)
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: ldarg.2
    	IL_0002: callvirt instance void C::set_P(int32)
    	IL_0007: ret
    }

    .method public hidebysig static 
    	void '<ImplicitExtension>$' (
    		class C ''
    	) cil managed 
    {
    	.maxstack 8
    	IL_0000: ret
    }

    .property int32 Item(
    	class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
    	int32 i
    )
    {
    	.get int32 E::get_Item(class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute), int32)
    	.set void E::set_Item(class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute), int32, int32)
    }
}

.class public auto ansi beforefieldinit C
    extends [mscorlib]System.Object
{
    .field private int32 '<P>k__BackingField'
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
    	01 00 00 00
    )

    .method public hidebysig specialname 
    	instance int32 get_P () cil managed 
    {
    	.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
    		01 00 00 00
    	)
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: ldfld int32 C::'<P>k__BackingField'
    	IL_0006: ret
    }

    .method public hidebysig specialname 
    	instance void set_P (
    		int32 'value'
    	) cil managed 
    {
    	.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
    		01 00 00 00
    	)
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: ldarg.1
    	IL_0002: stfld int32 C::'<P>k__BackingField'
    	IL_0007: ret
    }

    .method public hidebysig specialname rtspecialname 
    	instance void .ctor () cil managed 
    {
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: call instance void [mscorlib]System.Object::.ctor()
    	IL_0006: ret
    }

    .property instance int32 P()
    {
    	.get instance int32 C::get_P()
    	.set instance void C::set_P(int32)
    }
}
""";

        var src2 = """
class Program
{
    static void Main()
    {
        var c = new C();
        c[1] = 2;
        System.Console.WriteLine(c[1]);
    }
}
""";
        var comp = CreateCompilationWithIL(src2, ilSource, options: TestOptions.ReleaseExe);

        // The conditional compilation symbol PREVIOUSVERSIONOFCOMPILER is intentionally not defined.
        // The branch that is not taken reflects behavior of the compiler in main.
        // The test can be run manually in 'main' by copy/pasting it into a file and defining the conditional compilation symbol.
#if !PREVIOUSVERSIONOFCOMPILER
        CompileAndVerify(comp, expectedOutput: "2").VerifyDiagnostics();
#else
        comp.VerifyDiagnostics(
            // (6,9): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            //         c[1] = 2;
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "c[1]").WithArguments("C").WithLocation(6, 9),
            // (7,34): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            //         System.Console.WriteLine(c[1]);
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "c[1]").WithArguments("C").WithLocation(7, 34)
            );

        var src3 = """
class Program
{
    static void Main()
    {
        var c = new C();
        E.Item[c, 1] = 2;
        System.Console.WriteLine(E.Item[c, 1]);
    }
}
""";

        comp = CreateCompilationWithIL(src3, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (6,11): error CS0117: 'E' does not contain a definition for 'Item'
            //         E.Item[c, 1] = 2;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Item").WithArguments("E", "Item").WithLocation(6, 11),
            // (7,36): error CS0117: 'E' does not contain a definition for 'Item'
            //         System.Console.WriteLine(E.Item[c, 1]);
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Item").WithArguments("E", "Item").WithLocation(7, 36)
            );

        var src4 = """
class Program
{
    static void Main()
    {
        var c = new C();
        E.set_Item(c, 1, 2);
        System.Console.WriteLine(E.get_Item(c, 1));
    }
}
""";

        comp = CreateCompilationWithIL(src4, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (6,11): error CS0570: 'E.set_Item(C, int, int)' is not supported by the language
            //         E.set_Item(c, 1, 2);
            Diagnostic(ErrorCode.ERR_BindToBogus, "set_Item").WithArguments("E.set_Item(C, int, int)").WithLocation(6, 11),
            // (7,36): error CS0570: 'E.get_Item(C, int)' is not supported by the language
            //         System.Console.WriteLine(E.get_Item(c, 1));
            Diagnostic(ErrorCode.ERR_BindToBogus, "get_Item").WithArguments("E.get_Item(C, int)").WithLocation(7, 36)
            );
#endif
    }

    [Fact]
    public void InstanceIndexer_Metadata_ConsumptionFromPreviousVersion_02()
    {
        // public implicit extension E for C
        // {
        //     public int this[int i]
        //     {
        //         get => this.P;
        //         set => this.P = value; 
        //     }
        // }
        // 
        // public struct C
        // {
        //     public int P { get; set; }
        // }
        var ilSource = """
.class public sequential ansi sealed beforefieldinit E
    extends [mscorlib]System.ValueType
{
    .custom instance void [mscorlib]System.Reflection.DefaultMemberAttribute::.ctor(string) = (
    	01 00 04 49 74 65 6d 00 00
    )

    .method public hidebysig specialname static 
    	int32 get_Item (
    		valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
    		int32 i
    	) cil managed 
    {
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: call instance int32 C::get_P()
    	IL_0006: ret
    }

    .method public hidebysig specialname static 
    	void set_Item (
    		valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
    		int32 i,
    		int32 'value'
    	) cil managed 
    {
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: ldarg.2
    	IL_0002: call instance void C::set_P(int32)
    	IL_0007: ret
    }

    .method public hidebysig static 
    	void '<ImplicitExtension>$' (
    		valuetype C ''
    	) cil managed 
    {
    	.maxstack 8
    	IL_0000: ret
    }

    .property int32 Item(
    	valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
    	int32 i
    )
    {
    	.get int32 E::get_Item(valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)&, int32)
    	.set void E::set_Item(valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)&, int32, int32)
    }
}

.class public sequential ansi sealed beforefieldinit C
    extends [mscorlib]System.ValueType
{
    .field private int32 '<P>k__BackingField'
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
    	01 00 00 00
    )

    .method public hidebysig specialname 
    	instance int32 get_P () cil managed 
    {
    	.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
    		01 00 00 00
    	)

    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: ldfld int32 C::'<P>k__BackingField'
    	IL_0006: ret
    }

    .method public hidebysig specialname 
    	instance void set_P (
    		int32 'value'
    	) cil managed 
    {
    	.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
    		01 00 00 00
    	)
    	.maxstack 8
    	IL_0000: ldarg.0
    	IL_0001: ldarg.1
    	IL_0002: stfld int32 C::'<P>k__BackingField'
    	IL_0007: ret
    }

    .property instance int32 P()
    {
    	.get instance int32 C::get_P()
    	.set instance void C::set_P(int32)
    }
}
""";

        var src2 = """
class Program
{
    static void Main()
    {
        var c = new C();
        c[1] = 2;
        System.Console.WriteLine(c[1]);
    }
}
""";
        var comp = CreateCompilationWithIL(src2, ilSource, options: TestOptions.ReleaseExe);

        // The conditional compilation symbol PREVIOUSVERSIONOFCOMPILER is intentionally not defined.
        // The branch that is not taken reflects behavior of the compiler in main.
        // The test can be run manually in 'main' by copy/pasting it into a file and defining the conditional compilation symbol.
#if !PREVIOUSVERSIONOFCOMPILER
        CompileAndVerify(comp, expectedOutput: "2").VerifyDiagnostics();
#else
        comp.VerifyDiagnostics(
            // (6,9): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            //         c[1] = 2;
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "c[1]").WithArguments("C").WithLocation(6, 9),
            // (7,34): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            //         System.Console.WriteLine(c[1]);
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "c[1]").WithArguments("C").WithLocation(7, 34)
            );

        var src3 = """
class Program
{
    static void Main()
    {
        var c = new C();
        E.Item[c, 1] = 2;
        System.Console.WriteLine(E.Item[c, 1]);
    }
}
""";

        comp = CreateCompilationWithIL(src3, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (6,11): error CS0117: 'E' does not contain a definition for 'Item'
            //         E.Item[c, 1] = 2;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Item").WithArguments("E", "Item").WithLocation(6, 11),
            // (7,36): error CS0117: 'E' does not contain a definition for 'Item'
            //         System.Console.WriteLine(E.Item[c, 1]);
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Item").WithArguments("E", "Item").WithLocation(7, 36)
            );

        var src4 = """
class Program
{
    static void Main()
    {
        var c = new C();
        E.set_Item(ref c, 1, 2);
        System.Console.WriteLine(E.get_Item(ref c, 1));
    }
}
""";

        comp = CreateCompilationWithIL(src4, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (6,11): error CS0570: 'E.set_Item(ref C, int, int)' is not supported by the language
            //         E.set_Item(ref c, 1, 2);
            Diagnostic(ErrorCode.ERR_BindToBogus, "set_Item").WithArguments("E.set_Item(ref C, int, int)").WithLocation(6, 11),
            // (7,36): error CS0570: 'E.get_Item(ref C, int)' is not supported by the language
            //         System.Console.WriteLine(E.get_Item(ref c, 1));
            Diagnostic(ErrorCode.ERR_BindToBogus, "get_Item").WithArguments("E.get_Item(ref C, int)").WithLocation(7, 36)
            );
#endif
    }

    [Fact]
    public void InstanceEvent_Metadata_ConsumptionFromPreviousVersion_01()
    {
        // public implicit extension E for C
        // {
        //     public event System.Action E1
        //     {
        //         add => this.E += value;
        //         remove => this.E -= value; 
        //     }
        // }
        // 
        // public class C
        // {
        //     public event System.Action E;
        // 
        //     public void Fire() => E();
        // }
        var ilSource = """
.class public sequential ansi sealed beforefieldinit E
	extends [mscorlib]System.ValueType
{
	.method public hidebysig specialname static 
		void add_E1 (
			class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			class [mscorlib]System.Action 'value'
		) cil managed 
	{
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: callvirt instance void C::add_E(class [mscorlib]System.Action)
		IL_0007: ret
	}

	.method public hidebysig specialname static 
		void remove_E1 (
			class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute) '<>4__this',
			class [mscorlib]System.Action 'value'
		) cil managed 
	{
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: callvirt instance void C::remove_E(class [mscorlib]System.Action)
		IL_0007: ret
	}

	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			class C ''
		) cil managed 
	{
		.maxstack 8
		IL_0000: ret
	}

	.event [mscorlib]System.Action E1
	{
		.addon void E::add_E1(class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute), class [mscorlib]System.Action)
		.removeon void E::remove_E1(class C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute), class [mscorlib]System.Action)
	}
}

.class public auto ansi beforefieldinit C
	extends [mscorlib]System.Object
{
	.field private class [mscorlib]System.Action E
	.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
		01 00 00 00
	)

	.method public hidebysig specialname 
		instance void add_E (
			class [mscorlib]System.Action 'value'
		) cil managed 
	{
		.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
			01 00 00 00
		)
		.maxstack 3
		.locals init (
			[0] class [mscorlib]System.Action,
			[1] class [mscorlib]System.Action,
			[2] class [mscorlib]System.Action
		)
		IL_0000: ldarg.0
		IL_0001: ldfld class [mscorlib]System.Action C::E
		IL_0006: stloc.0
		IL_0007: ldloc.0
		IL_0008: stloc.1
		IL_0009: ldloc.1
		IL_000a: ldarg.1
		IL_000b: call class [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(class [mscorlib]System.Delegate, class [mscorlib]System.Delegate)
		IL_0010: castclass [mscorlib]System.Action
		IL_0015: stloc.2
		IL_0016: ldarg.0
		IL_0017: ldflda class [mscorlib]System.Action C::E
		IL_001c: ldloc.2
		IL_001d: ldloc.1
		IL_001e: call !!0 [mscorlib]System.Threading.Interlocked::CompareExchange<class [mscorlib]System.Action>(!!0&, !!0, !!0)
		IL_0023: stloc.0
		IL_0024: ldloc.0
		IL_0025: ldloc.1
		IL_0026: bne.un.s IL_0007
		IL_0028: ret
	}

	.method public hidebysig specialname 
		instance void remove_E (
			class [mscorlib]System.Action 'value'
		) cil managed 
	{
		.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
			01 00 00 00
		)
		.maxstack 3
		.locals init (
			[0] class [mscorlib]System.Action,
			[1] class [mscorlib]System.Action,
			[2] class [mscorlib]System.Action
		)
		IL_0000: ldarg.0
		IL_0001: ldfld class [mscorlib]System.Action C::E
		IL_0006: stloc.0
		IL_0007: ldloc.0
		IL_0008: stloc.1
		IL_0009: ldloc.1
		IL_000a: ldarg.1
		IL_000b: call class [mscorlib]System.Delegate [mscorlib]System.Delegate::Remove(class [mscorlib]System.Delegate, class [mscorlib]System.Delegate)
		IL_0010: castclass [mscorlib]System.Action
		IL_0015: stloc.2
		IL_0016: ldarg.0
		IL_0017: ldflda class [mscorlib]System.Action C::E
		IL_001c: ldloc.2
		IL_001d: ldloc.1
		IL_001e: call !!0 [mscorlib]System.Threading.Interlocked::CompareExchange<class [mscorlib]System.Action>(!!0&, !!0, !!0)
		IL_0023: stloc.0
		IL_0024: ldloc.0
		IL_0025: ldloc.1
		IL_0026: bne.un.s IL_0007
		IL_0028: ret
	}

	.method public hidebysig 
		instance void Fire () cil managed 
	{
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldfld class [mscorlib]System.Action C::E
		IL_0006: callvirt instance void [mscorlib]System.Action::Invoke()
		IL_000b: ret
	}

	.method public hidebysig specialname rtspecialname 
		instance void .ctor () cil managed 
	{
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: call instance void [mscorlib]System.Object::.ctor()
		IL_0006: ret
	}

	.event [mscorlib]System.Action E
	{
		.addon instance void C::add_E(class [mscorlib]System.Action)
		.removeon instance void C::remove_E(class [mscorlib]System.Action)
	}
}
""";

        var src2 = """
class Program
{
    static void Main()
    {
        var c = new C();
        c.E1 += M2();
        c.Fire();
        c.E1 += M3();
        c.E1 -= M2();
        c.Fire();
    }

    static System.Action M2() => (() => System.Console.Write(2));
    static System.Action M3() => (() => System.Console.Write(3));
}
""";
        var comp = CreateCompilationWithIL(src2, ilSource, options: TestOptions.ReleaseExe);

        // The conditional compilation symbol PREVIOUSVERSIONOFCOMPILER is intentionally not defined.
        // The branch that is not taken reflects behavior of the compiler in main.
        // The test can be run manually in 'main' by copy/pasting it into a file and defining the conditional compilation symbol.
#if !PREVIOUSVERSIONOFCOMPILER
        CompileAndVerify(comp, expectedOutput: "23").VerifyDiagnostics();
#else
        comp.VerifyDiagnostics(
            // (6,11): error CS1061: 'C' does not contain a definition for 'E1' and no accessible extension method 'E1' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            //         c.E1 += M2();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "E1").WithArguments("C", "E1").WithLocation(6, 11),
            // (8,11): error CS1061: 'C' does not contain a definition for 'E1' and no accessible extension method 'E1' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            //         c.E1 += M3();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "E1").WithArguments("C", "E1").WithLocation(8, 11),
            // (9,11): error CS1061: 'C' does not contain a definition for 'E1' and no accessible extension method 'E1' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            //         c.E1 -= M2();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "E1").WithArguments("C", "E1").WithLocation(9, 11)
            );

        var src3 = """
class Program
{
    static void Main()
    {
        var c = new C();
        E.add_E1(c, M2());
        c.Fire();
        E.add_E1(c, M3());
        E.remove_E1(c, M2());
        c.Fire();
    }

    static System.Action M2() => (() => System.Console.Write(2));
    static System.Action M3() => (() => System.Console.Write(3));
}
""";
        comp = CreateCompilationWithIL(src3, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (6,11): error CS0570: 'E.add_E1(C, Action)' is not supported by the language
            //         E.add_E1(c, M2());
            Diagnostic(ErrorCode.ERR_BindToBogus, "add_E1").WithArguments("E.add_E1(C, System.Action)").WithLocation(6, 11),
            // (8,11): error CS0570: 'E.add_E1(C, Action)' is not supported by the language
            //         E.add_E1(c, M3());
            Diagnostic(ErrorCode.ERR_BindToBogus, "add_E1").WithArguments("E.add_E1(C, System.Action)").WithLocation(8, 11),
            // (9,11): error CS0570: 'E.remove_E1(C, Action)' is not supported by the language
            //         E.remove_E1(c, M2());
            Diagnostic(ErrorCode.ERR_BindToBogus, "remove_E1").WithArguments("E.remove_E1(C, System.Action)").WithLocation(9, 11)
            );
#endif
    }

    [Fact]
    public void InstanceEvent_Metadata_ConsumptionFromPreviousVersion_02()
    {
        // public implicit extension E for C
        // {
        //     public event System.Action E1
        //     {
        //         add => this.E += value;
        //         remove => this.E -= value; 
        //     }
        // }
        // 
        // public struct C
        // {
        //     public event System.Action E;
        // 
        //     public void Fire() => E();
        // }
        var ilSource = """
.class public sequential ansi sealed beforefieldinit E
	extends [mscorlib]System.ValueType
{
	.method public hidebysig specialname static 
		void add_E1 (
			valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
			class [mscorlib]System.Action 'value'
		) cil managed 
	{
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: call instance void C::add_E(class [mscorlib]System.Action)
		IL_0007: ret
	}

	.method public hidebysig specialname static 
		void remove_E1 (
			valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)& '<>4__this',
			class [mscorlib]System.Action 'value'
		) cil managed 
	{
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldarg.1
		IL_0002: call instance void C::remove_E(class [mscorlib]System.Action)
		IL_0007: ret
	}

	.method public hidebysig static 
		void '<ImplicitExtension>$' (
			valuetype C ''
		) cil managed 
	{
		.maxstack 8
		IL_0000: ret
	}

	.event [mscorlib]System.Action E1
	{
		.addon void E::add_E1(valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)&, class [mscorlib]System.Action)
		.removeon void E::remove_E1(valuetype C modreq([mscorlib]System.Runtime.CompilerServices.ExtensionAttribute)&, class [mscorlib]System.Action)
	}
}

.class public sequential ansi sealed beforefieldinit C
	extends [mscorlib]System.ValueType
{
	.field private class [mscorlib]System.Action E
	.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
		01 00 00 00
	)

	.method public hidebysig specialname 
		instance void add_E (
			class [mscorlib]System.Action 'value'
		) cil managed 
	{
		.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
			01 00 00 00
		)
		.maxstack 3
		.locals init (
			[0] class [mscorlib]System.Action,
			[1] class [mscorlib]System.Action,
			[2] class [mscorlib]System.Action
		)
		IL_0000: ldarg.0
		IL_0001: ldfld class [mscorlib]System.Action C::E
		IL_0006: stloc.0
		IL_0007: ldloc.0
		IL_0008: stloc.1
		IL_0009: ldloc.1
		IL_000a: ldarg.1
		IL_000b: call class [mscorlib]System.Delegate [mscorlib]System.Delegate::Combine(class [mscorlib]System.Delegate, class [mscorlib]System.Delegate)
		IL_0010: castclass [mscorlib]System.Action
		IL_0015: stloc.2
		IL_0016: ldarg.0
		IL_0017: ldflda class [mscorlib]System.Action C::E
		IL_001c: ldloc.2
		IL_001d: ldloc.1
		IL_001e: call !!0 [mscorlib]System.Threading.Interlocked::CompareExchange<class [mscorlib]System.Action>(!!0&, !!0, !!0)
		IL_0023: stloc.0
		IL_0024: ldloc.0
		IL_0025: ldloc.1
		IL_0026: bne.un.s IL_0007
		IL_0028: ret
	}

	.method public hidebysig specialname 
		instance void remove_E (
			class [mscorlib]System.Action 'value'
		) cil managed 
	{
		.custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
			01 00 00 00
		)
		.maxstack 3
		.locals init (
			[0] class [mscorlib]System.Action,
			[1] class [mscorlib]System.Action,
			[2] class [mscorlib]System.Action
		)
		IL_0000: ldarg.0
		IL_0001: ldfld class [mscorlib]System.Action C::E
		IL_0006: stloc.0
		IL_0007: ldloc.0
		IL_0008: stloc.1
		IL_0009: ldloc.1
		IL_000a: ldarg.1
		IL_000b: call class [mscorlib]System.Delegate [mscorlib]System.Delegate::Remove(class [mscorlib]System.Delegate, class [mscorlib]System.Delegate)
		IL_0010: castclass [mscorlib]System.Action
		IL_0015: stloc.2
		IL_0016: ldarg.0
		IL_0017: ldflda class [mscorlib]System.Action C::E
		IL_001c: ldloc.2
		IL_001d: ldloc.1
		IL_001e: call !!0 [mscorlib]System.Threading.Interlocked::CompareExchange<class [mscorlib]System.Action>(!!0&, !!0, !!0)
		IL_0023: stloc.0
		IL_0024: ldloc.0
		IL_0025: ldloc.1
		IL_0026: bne.un.s IL_0007
		IL_0028: ret
	}

	.method public hidebysig 
		instance void Fire () cil managed 
	{
		.maxstack 8
		IL_0000: ldarg.0
		IL_0001: ldfld class [mscorlib]System.Action C::E
		IL_0006: callvirt instance void [mscorlib]System.Action::Invoke()
		IL_000b: ret
	}

	.event [mscorlib]System.Action E
	{
		.addon instance void C::add_E(class [mscorlib]System.Action)
		.removeon instance void C::remove_E(class [mscorlib]System.Action)
	}
}
""";

        var src2 = """
class Program
{
    static void Main()
    {
        var c = new C();
        c.E1 += M2();
        c.Fire();
        c.E1 += M3();
        c.E1 -= M2();
        c.Fire();
    }

    static System.Action M2() => (() => System.Console.Write(2));
    static System.Action M3() => (() => System.Console.Write(3));
}
""";
        var comp = CreateCompilationWithIL(src2, ilSource, options: TestOptions.ReleaseExe);

        // The conditional compilation symbol PREVIOUSVERSIONOFCOMPILER is intentionally not defined.
        // The branch that is not taken reflects behavior of the compiler in main.
        // The test can be run manually in 'main' by copy/pasting it into a file and defining the conditional compilation symbol.
#if !PREVIOUSVERSIONOFCOMPILER
        CompileAndVerify(comp, expectedOutput: "23").VerifyDiagnostics();
#else
        comp.VerifyDiagnostics(
            // (6,11): error CS1061: 'C' does not contain a definition for 'E1' and no accessible extension method 'E1' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            //         c.E1 += M2();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "E1").WithArguments("C", "E1").WithLocation(6, 11),
            // (8,11): error CS1061: 'C' does not contain a definition for 'E1' and no accessible extension method 'E1' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            //         c.E1 += M3();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "E1").WithArguments("C", "E1").WithLocation(8, 11),
            // (9,11): error CS1061: 'C' does not contain a definition for 'E1' and no accessible extension method 'E1' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            //         c.E1 -= M2();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "E1").WithArguments("C", "E1").WithLocation(9, 11)
            );

        var src3 = """
class Program
{
    static void Main()
    {
        var c = new C();
        E.add_E1(ref c, M2());
        c.Fire();
        E.add_E1(ref c, M3());
        E.remove_E1(ref c, M2());
        c.Fire();
    }

    static System.Action M2() => (() => System.Console.Write(2));
    static System.Action M3() => (() => System.Console.Write(3));
}
""";
        comp = CreateCompilationWithIL(src3, ilSource, options: TestOptions.ReleaseExe);
        comp.VerifyDiagnostics(
            // (6,11): error CS0570: 'E.add_E1(ref C, Action)' is not supported by the language
            //         E.add_E1(ref c, M2());
            Diagnostic(ErrorCode.ERR_BindToBogus, "add_E1").WithArguments("E.add_E1(ref C, System.Action)").WithLocation(6, 11),
            // (8,11): error CS0570: 'E.add_E1(ref C, Action)' is not supported by the language
            //         E.add_E1(ref c, M3());
            Diagnostic(ErrorCode.ERR_BindToBogus, "add_E1").WithArguments("E.add_E1(ref C, System.Action)").WithLocation(8, 11),
            // (9,11): error CS0570: 'E.remove_E1(ref C, Action)' is not supported by the language
            //         E.remove_E1(ref c, M2());
            Diagnostic(ErrorCode.ERR_BindToBogus, "remove_E1").WithArguments("E.remove_E1(ref C, System.Action)").WithLocation(9, 11)
            );
#endif
    }

    const string ExtensionErasureAttributeDefinition = """
namespace System.Runtime.CompilerServices
{
    public class ExtensionErasureAttribute : System.Attribute
    {
        public ExtensionErasureAttribute(string encodedType) { }
    }
}
""";

    [Fact]
    public void TypeReference_MethodReturn_Simple()
    {
        var src = """
public explicit extension E for object { }

public class C
{
    public E M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        Assert.Equal("System.Runtime.CompilerServices.ExtensionErasureAttribute",
            comp.GetWellKnownType(WellKnownType.System_Runtime_CompilerServices_ExtensionErasureAttribute).ToDisplayString());

        Assert.Equal("System.Runtime.CompilerServices.ExtensionErasureAttribute..ctor(System.String encodedType)",
            comp.GetWellKnownTypeMember(WellKnownMember.System_Runtime_CompilerServices_ExtensionErasureAttribute__ctorEncodedType).ToTestDisplayString());

        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("C").GetMember<MethodSymbol>("M");
            Assert.Equal("E C.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Object C.M()", peMethod.Handle, peModule);
            }
        }
    }

    private static void VerifyMethodInPE(string expected, MethodDefinitionHandle handle, PEModuleSymbol peModule)
    {
        Assert.Equal(expected, peModule.Module.MetadataReader.Dump(handle));
    }

    private static void VerifyExtensionErasureAttribute(string expected, PEModuleSymbol module, EntityHandle handle)
    {
        var allAttributes = module.GetCustomAttributesForToken(handle);
        var attribute = allAttributes.Where(a => a.AttributeClass.ToTestDisplayString() == "System.Runtime.CompilerServices.ExtensionErasureAttribute").Single();
        var arg = attribute.CommonConstructorArguments[0];
        Assert.Equal(TypedConstantKind.Primitive, arg.Kind);
        AssertEx.Equal(expected, (string)arg.ValueInternal);
    }

    private static void VerifyNoExtensionErasureAttribute(PEModuleSymbol module, EntityHandle handle)
    {
        var allAttributes = module.GetCustomAttributesForToken(handle);
        Assert.Empty(allAttributes.Where(a => a.AttributeClass.ToTestDisplayString() == "System.Runtime.CompilerServices.ExtensionErasureAttribute"));
    }

    [Fact]
    public void TypeReference_MethodReturn_WrongTypeInMetadata()
    {
        // public explicit extension E for object { }
        // public class C
        // {
        //     public /*E*/ int M() { } // note: mismatch of underlying type
        // }
        var ilSrc = $$"""
.class public sequential ansi sealed beforefieldinit E
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: true)}}'(object '') cil managed
    {
        IL_0000: ret
    }
}

.class public auto ansi beforefieldinit System.Runtime.CompilerServices.ExtensionErasureAttribute
    extends [mscorlib]System.Attribute
{
    .method public hidebysig specialname rtspecialname instance void .ctor( string encodedType ) cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Attribute::.ctor()
        IL_0006: ret
    }
}

.class public auto ansi beforefieldinit C
	extends [mscorlib]System.Object
{
	.method public hidebysig instance int32 M() cil managed
	{
		.param [0]
			.custom instance void System.Runtime.CompilerServices.ExtensionErasureAttribute::.ctor(string) = ( 01 00 01 45 00 00 )
		IL_0000: ldnull
		IL_0001: throw
	}
	.method public hidebysig specialname rtspecialname instance void .ctor() cil managed
	{
		IL_0000: ldarg.0
		IL_0001: call instance void [mscorlib]System.Object::.ctor()
		IL_0006: ret
	}
}
""";
        var src = """
public class D
{
    public C M2() => throw null;
}
""";

        // PROTOTYPE consider checking that the type is the erased version of the decoded type
        var comp = CreateCompilationWithIL([src, ExtensionErasureAttributeDefinition], ilSrc);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M2").ReturnType.GetMember<MethodSymbol>("M");
            Assert.Equal("E C.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Int32 C.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact(Skip = "PROTOTYPE need to generate the attribute when it is missing")]
    public void TypeReference_MethodReturn_Simple_MissingAttribute()
    {
        var src = """
public explicit extension E for object { }

public class C
{
    public E M() => throw null;
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void TypeReference_MethodReturn_ExplicitAttributeUsage()
    {
        var src = """
public explicit extension E for object { }

public class C
{
    [return: System.Runtime.CompilerServices.ExtensionErasureAttribute("E")]
    public object M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        comp.VerifyEmitDiagnostics(
            // (5,14): error CS9329: Do not use 'System.Runtime.CompilerServices.ExtensionErasureAttribute'. This is reserved for compiler usage.
            //     [return: System.Runtime.CompilerServices.ExtensionErasureAttribute("E")]
            Diagnostic(ErrorCode.ERR_ExplicitExtensionErasureAttr, @"System.Runtime.CompilerServices.ExtensionErasureAttribute(""E"")").WithLocation(5, 14));
    }

    [Fact]
    public void TypeReference_MethodReturn_Generic()
    {
        var libSrc = """public class A { }""";
        var libRef = CreateCompilation(libSrc, assemblyName: "AssemblyA").EmitToImageReference();
        var src = """
public explicit extension E<T> for C<int> { }

public class C<T> { }
public class D
{
    public E<A> M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [libRef]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("E<A> D.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E`1[[A, AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]]",
                    peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:C`1{Int32} D.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_ExtensionAsTypeArgument()
    {
        var src = """
public explicit extension E for int { }

public class C<T> { }
public class D
{
    public C<E> M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("C<E> D.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("C`1[E]", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:C`1{Int32} D.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_ExtensionNestedTypeAsTypeArgument()
    {
        var src = """
public explicit extension E for int { public class Nested { } }

public class C<T> { }
public class D
{
    public C<E.Nested> M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("C<E.Nested> D.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                VerifyNoExtensionErasureAttribute((PEModuleSymbol)peMethod.ContainingModule, peMethod.ReturnTypeParameter.Handle);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_ExtensionAsTypeArgumentOfExtension()
    {
        var src = """
public explicit extension E<T> for object { }
public explicit extension E2 for int { }

public class C
{
    public E<E2> M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("C").GetMember<MethodSymbol>("M");
            Assert.Equal("E<E2> C.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E`1[E2]", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Object C.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_ExtensionNestedType()
    {
        var src = """
public explicit extension E<T1> for int 
{
    public explicit extension E2 for object { }
}

public class C1 { }
public class C2 { }

public class D
{
    public E<C1>.E2 M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("E<C1>.E2 D.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E`1+E2[C1]", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Object D.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_ExtensionNestedType_Generic()
    {
        var src = """
public explicit extension E<T1> for int 
{
    public explicit extension E2<T2> for object { }
}

public class C1 { }
public class C2 { }

public class D
{
    public E<C1>.E2<C2> M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("E<C1>.E2<C2> D.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E`1+E2`1[C1,C2]", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Object D.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_Array()
    {
        var src = """
public explicit extension E for object { }

public class C
{
    public E[] M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("C").GetMember<MethodSymbol>("M");
            Assert.Equal("E[] C.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E[]", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Object[] C.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_Pointer()
    {
        var src = """
public explicit extension E for object { }

public class C
{
    public unsafe E* M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], options: TestOptions.UnsafeDebugDll);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("C").GetMember<MethodSymbol>("M");
            Assert.Equal("E* C.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E*", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Object* C.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_OnArray()
    {
        var src = """
public explicit extension E for object[] { }

public class C
{
    public E M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("C").GetMember<MethodSymbol>("M");
            Assert.Equal("E C.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Object[] C.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_ExtensionTypeMethod_TypeParameter()
    {
        var src = """
public explicit extension E<T> for object
{ 
    public E<T> M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("E").GetMember<MethodSymbol>("M");
            Assert.Equal("E<T> E<T>.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)((PEExtensionInstanceMethodSymbol)m).UnderlyingMethod;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E`1[!0]", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Object E`1.M(modreq(System.Runtime.CompilerServices.ExtensionAttribute) Object)", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_SpecializedNestedTypeReference()
    {
        var src = """
public explicit extension E<T> for object
{
    public class Nested { }
    public Nested M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("E").GetMember<MethodSymbol>("M");
            Assert.Equal("E<T>.Nested E<T>.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEExtensionInstanceMethodSymbol)m;
                VerifyNoExtensionErasureAttribute((PEModuleSymbol)peMethod.ContainingModule, ((PEMethodSymbol)peMethod.UnderlyingMethod).ReturnTypeParameter.Handle);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_SpecializedNestedTypeReference_NestedExtension()
    {
        var src = """
public explicit extension E<T> for object
{
    public explicit extension NestedE for int { }
    public NestedE M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("E").GetMember<MethodSymbol>("M");
            Assert.Equal("E<T>.NestedE E<T>.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)((PEExtensionInstanceMethodSymbol)m).UnderlyingMethod;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E`1+NestedE[!0]",
                    (PEModuleSymbol)peMethod.ContainingModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Int32 E`1.M(modreq(System.Runtime.CompilerServices.ExtensionAttribute) Object)", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_SpecializedGenericNestedTypeInstanceReference_NestedExtension()
    {
        var src = """
public explicit extension E<T> for object
{
    public explicit extension NestedE for int { }
    public NestedE M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("E").GetMember<MethodSymbol>("M");
            Assert.Equal("E<T>.NestedE E<T>.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)((PEExtensionInstanceMethodSymbol)m).UnderlyingMethod;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E`1+NestedE[!0]", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Int32 E`1.M(modreq(System.Runtime.CompilerServices.ExtensionAttribute) Object)", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_SpecializedGenericNestedTypeInstanceReference_NestedExtension_Generic()
    {
        var src = """
public explicit extension E<T> for object
{
    public explicit extension Nested<U> for int { }
    public Nested<T> M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("E").GetMember<MethodSymbol>("M");
            Assert.Equal("E<T>.Nested<T> E<T>.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)((PEExtensionInstanceMethodSymbol)m).UnderlyingMethod;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E`1+Nested`1[!0,!0]", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Int32 E`1.M(modreq(System.Runtime.CompilerServices.ExtensionAttribute) Object)", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_SpecializedGenericNestedTypeInstanceReference_NestedExtension_Generic_SpecificTypeArgument()
    {
        var src = """
public class C { }
public explicit extension E<T> for object
{
    public explicit extension Nested<U> for int { }
    public Nested<C> M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("E").GetMember<MethodSymbol>("M");
            Assert.Equal("E<T>.Nested<C> E<T>.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)((PEExtensionInstanceMethodSymbol)m).UnderlyingMethod;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E`1+Nested`1[!0,C]", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Int32 E`1.M(modreq(System.Runtime.CompilerServices.ExtensionAttribute) Object)", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_SpecializedGenericNestedTypeInstanceReference_NestedExtension_Generic_Nested()
    {
        var src = """
class C<T0>
{
    public explicit extension E<T> for object
    {
        public explicit extension Nested<U> for int { }
        public Nested<T> M() => throw null;
    }
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("C").GetMember<NamedTypeSymbol>("E").GetMember<MethodSymbol>("M");
            Assert.Equal("C<T0>.E<T>.Nested<T> C<T0>.E<T>.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)((PEExtensionInstanceMethodSymbol)m).UnderlyingMethod;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("C`1+E`1+Nested`1[!0,!1,!1]", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Int32 E`1.M(modreq(System.Runtime.CompilerServices.ExtensionAttribute) Object)", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_ThirteenTypeParameters()
    {
        var src = """
class C<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>
{
    public explicit extension E<T12> for object
    {
        public explicit extension Nested<U, V> for int { }
        public Nested<T11, T12> M() => throw null;
    }
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("C").GetMember<NamedTypeSymbol>("E").GetMember<MethodSymbol>("M");
            Assert.Equal("C<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.E<T12>.Nested<T11, T12> C<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11>.E<T12>.M()",
                m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)((PEExtensionInstanceMethodSymbol)m).UnderlyingMethod;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("C`12+E`1+Nested`2[!0,!1,!2,!3,!4,!5,!6,!7,!8,!9,!10,!11,!12,!11,!12]", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:Int32 E`1.M(modreq(System.Runtime.CompilerServices.ExtensionAttribute) Object)", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_MethodTypeParameter()
    {
        var src = """
public explicit extension E<T> for object
{
    public explicit extension NestedE<U> for int { }
    public NestedE<V> M<V>() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("E").GetMember<MethodSymbol>("M");
            Assert.Equal("E<T>.NestedE<V> E<T>.M<V>()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)((PEExtensionInstanceMethodSymbol)m).UnderlyingMethod;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E`1+NestedE`1[!0,!!0]", peModule, peMethod.ReturnTypeParameter.Handle);
                // Note: we don't need to emit the erasure attribute on the `this` parameter of emitted static method
                VerifyNoExtensionErasureAttribute(peModule, ((PEParameterSymbol)peMethod.Parameters[0]).Handle);
                VerifyMethodInPE("MethodDefinition:Int32 E`1.M(modreq(System.Runtime.CompilerServices.ExtensionAttribute) Object)", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MetadataDependencies_MethodReturn()
    {
        var aRef = CreateCompilation("public class A { }", assemblyName: "AssemblyA").EmitToImageReference();
        var bRef = CreateCompilation("public class B { }", assemblyName: "AssemblyB").EmitToImageReference();
        var cRef = CreateCompilation("public class C<T> { }", assemblyName: "AssemblyC").EmitToImageReference();
        var eRef = CreateCompilation("public explicit extension E<T> for C<A> { }", references: [aRef, cRef], assemblyName: "AssemblyE").EmitToImageReference();

        var src = """
public class D
{
    public E<B> M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, bRef, cRef, eRef]);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        // Missing references
        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [bRef, cRef, eRef]).VerifyEmitDiagnostics(
            // (3,30): error CS0012: The type 'A' is defined in an assembly that is not referenced. You must add a reference to assembly 'AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            //     public E<B> M() => throw null;
            Diagnostic(ErrorCode.ERR_NoTypeDef, "null").WithArguments("A", "AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(3, 30));

        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, cRef, eRef]).VerifyEmitDiagnostics(
            // (3,14): error CS0246: The type or namespace name 'B' could not be found (are you missing a using directive or an assembly reference?)
            //     public E<B> M() => throw null;
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "B").WithArguments("B").WithLocation(3, 14));

        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, bRef, eRef]).VerifyEmitDiagnostics(
            // (3,30): error CS0012: The type 'C<>' is defined in an assembly that is not referenced. You must add a reference to assembly 'AssemblyC, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            //     public E<B> M() => throw null;
            Diagnostic(ErrorCode.ERR_NoTypeDef, "null").WithArguments("C<>", "AssemblyC, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(3, 30));

        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, bRef, cRef]).VerifyEmitDiagnostics(
            // (3,12): error CS0246: The type or namespace name 'E<>' could not be found (are you missing a using directive or an assembly reference?)
            //     public E<B> M() => throw null;
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "E<B>").WithArguments("E<>").WithLocation(3, 12));

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("E<B> D.M()", m.ToTestDisplayString());

            if (module is not SourceModuleSymbol)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E`1[[B, AssemblyB, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]], AssemblyE, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
                    peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:C`1{A} D.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MetadataDependencies_MethodReturn_UnderlyingHasExtension()
    {
        var aRef = CreateCompilation("public class A { }", assemblyName: "AssemblyA").EmitToImageReference();
        var bRef = CreateCompilation("public class B { }", assemblyName: "AssemblyB").EmitToImageReference();
        var c1Ref = CreateCompilation("public class C1<T> { }", assemblyName: "AssemblyC1").EmitToImageReference();
        var c2Ref = CreateCompilation("public class C2<T> { }", assemblyName: "AssemblyC2").EmitToImageReference();

        var e1Src = "public explicit extension E1 for C2<A> { }";
        var e1Ref = CreateCompilation(e1Src, assemblyName: "AssemblyE1", references: [aRef, c2Ref]).EmitToImageReference();

        var e2Src = "public explicit extension E2<T> for C1<E1> { }";
        var e2Ref = CreateCompilation(e2Src, references: [aRef, c1Ref, c2Ref, e1Ref], assemblyName: "AssemblyE2").EmitToImageReference();

        var src = """
public class D
{
    public E2<B> M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, bRef, c1Ref, c2Ref, e1Ref, e2Ref]);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        // Missing references when compiling E1
        CreateCompilation(e1Src, references: [c2Ref]).VerifyEmitDiagnostics(
            // (1,37): error CS0246: The type or namespace name 'A' could not be found (are you missing a using directive or an assembly reference?)
            // public explicit extension E1 for C2<A> { }
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "A").WithArguments("A").WithLocation(1, 37));

        CreateCompilation(e1Src, references: [aRef]).VerifyEmitDiagnostics(
            // (1,34): error CS0246: The type or namespace name 'C2<>' could not be found (are you missing a using directive or an assembly reference?)
            // public explicit extension E1 for C2<A> { }
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "C2<A>").WithArguments("C2<>").WithLocation(1, 34));

        // Missing references when compiling E2
        CreateCompilation(e2Src, references: [c1Ref, c2Ref, e1Ref]).VerifyEmitDiagnostics(
            // error CS0012: The type 'A' is defined in an assembly that is not referenced. You must add a reference to assembly 'AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            Diagnostic(ErrorCode.ERR_NoTypeDef).WithArguments("A", "AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 1));

        CreateCompilation(e2Src, references: [aRef, c2Ref, e1Ref]).VerifyEmitDiagnostics(
            // (1,37): error CS0246: The type or namespace name 'C1<>' could not be found (are you missing a using directive or an assembly reference?)
            // public explicit extension E2<T> for C1<E1> { }
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "C1<E1>").WithArguments("C1<>").WithLocation(1, 37));

        CreateCompilation(e2Src, references: [aRef, c1Ref, e1Ref]).VerifyEmitDiagnostics(
            // error CS0012: The type 'C2<>' is defined in an assembly that is not referenced. You must add a reference to assembly 'AssemblyC2, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            Diagnostic(ErrorCode.ERR_NoTypeDef).WithArguments("C2<>", "AssemblyC2, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 1));

        CreateCompilation(e2Src, references: [aRef, c1Ref, c2Ref]).VerifyEmitDiagnostics(
            // (1,40): error CS0246: The type or namespace name 'E1' could not be found (are you missing a using directive or an assembly reference?)
            // public explicit extension E2<T> for C1<E1> { }
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "E1").WithArguments("E1").WithLocation(1, 40));

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("E2<B> D.M()", m.ToTestDisplayString());

            if (module is not SourceModuleSymbol)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E2`1[[B, AssemblyB, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]], AssemblyE2, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
                    peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:C1`1{C2`1{A}} D.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MetadataDependencies_MethodReturn_ExtensionAsTypeArgument()
    {
        var aRef = CreateCompilation("public class A { }", assemblyName: "AssemblyA").EmitToImageReference();
        var bRef = CreateCompilation("public class B<T> { }", assemblyName: "AssemblyB").EmitToImageReference();
        var cRef = CreateCompilation("public class C<T> { }", assemblyName: "AssemblyC").EmitToImageReference();
        var eRef = CreateCompilation("public explicit extension E for C<A> { }", references: [aRef, cRef], assemblyName: "AssemblyE").EmitToImageReference();

        var src = """
public class D
{
    public B<E> M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, bRef, cRef, eRef]);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        // Missing references
        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [bRef, cRef, eRef]).VerifyEmitDiagnostics(
            // error CS0012: The type 'A' is defined in an assembly that is not referenced. You must add a reference to assembly 'AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            Diagnostic(ErrorCode.ERR_NoTypeDef).WithArguments("A", "AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 1));

        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, cRef, eRef]).VerifyEmitDiagnostics(
            // (3,12): error CS0246: The type or namespace name 'B<>' could not be found (are you missing a using directive or an assembly reference?)
            //     public B<E> M() => throw null;
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "B<E>").WithArguments("B<>").WithLocation(3, 12));

        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, bRef, eRef]).VerifyEmitDiagnostics(
            // error CS0012: The type 'C<>' is defined in an assembly that is not referenced. You must add a reference to assembly 'AssemblyC, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            Diagnostic(ErrorCode.ERR_NoTypeDef).WithArguments("C<>", "AssemblyC, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 1));

        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, bRef, cRef]).VerifyEmitDiagnostics(
            // (3,14): error CS0246: The type or namespace name 'E' could not be found (are you missing a using directive or an assembly reference?)
            //     public B<E> M() => throw null;
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "E").WithArguments("E").WithLocation(3, 14));

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("B<E> D.M()", m.ToTestDisplayString());

            if (module is not SourceModuleSymbol)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("B`1[[E, AssemblyE, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]], AssemblyB, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
                    peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:B`1{C`1{A}} D.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MetadataDependencies_MethodReturn_NestedType()
    {
        var aRef = CreateCompilation("public class A { }", assemblyName: "AssemblyA").EmitToImageReference();
        var eRef = CreateCompilation("public explicit extension E for A { public class Nested { } }", references: [aRef], assemblyName: "AssemblyE").EmitToImageReference();

        var src = """
public class D
{
    public E.Nested M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, eRef]);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        // Missing references
        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [eRef]).VerifyEmitDiagnostics(
            //// error CS0012: The type 'A' is defined in an assembly that is not referenced. You must add a reference to assembly 'AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            //Diagnostic(ErrorCode.ERR_NoTypeDef).WithArguments("A", "AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 1)
            );

        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef]).VerifyEmitDiagnostics(
            // (3,12): error CS0246: The type or namespace name 'E' could not be found (are you missing a using directive or an assembly reference?)
            //     public E.Nested M() => throw null;
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "E").WithArguments("E").WithLocation(3, 12));

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("E.Nested D.M()", m.ToTestDisplayString());

            if (module is not SourceModuleSymbol)
            {
                var peMethod = (PEMethodSymbol)m;
                VerifyNoExtensionErasureAttribute((PEModuleSymbol)peMethod.ContainingModule, peMethod.ReturnTypeParameter.Handle);
            }
        }
    }

    [Fact]
    public void TypeReference_MetadataDependencies_MethodReturn_PointerType()
    {
        var aRef = CreateCompilation("public class A { }", assemblyName: "AssemblyA").EmitToImageReference();
        var eRef = CreateCompilation("public explicit extension E for A { }", references: [aRef], assemblyName: "AssemblyE").EmitToImageReference();

        var src = """
public unsafe class D
{
    public E* M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, eRef], options: TestOptions.UnsafeDebugDll);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        // Missing references
        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [eRef], options: TestOptions.UnsafeDebugDll).VerifyEmitDiagnostics(
            // error CS0012: The type 'A' is defined in an assembly that is not referenced. You must add a reference to assembly 'AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            Diagnostic(ErrorCode.ERR_NoTypeDef).WithArguments("A", "AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 1));

        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef], options: TestOptions.UnsafeDebugDll).VerifyEmitDiagnostics(
            // (3,12): error CS0246: The type or namespace name 'E' could not be found (are you missing a using directive or an assembly reference?)
            //     public E* M() => throw null;
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "E").WithArguments("E").WithLocation(3, 12),
            // (3,15): warning CS8500: This takes the address of, gets the size of, or declares a pointer to a managed type ('E')
            //     public E* M() => throw null;
            Diagnostic(ErrorCode.WRN_ManagedAddr, "M").WithArguments("E").WithLocation(3, 15));

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("E* D.M()", m.ToTestDisplayString());

            if (module is not SourceModuleSymbol)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E*, AssemblyE, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
                    peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:A* D.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MetadataDependencies_MethodReturn_PointerPointerType()
    {
        var aRef = CreateCompilation("public class A { }", assemblyName: "AssemblyA").EmitToImageReference();
        var eRef = CreateCompilation("public explicit extension E for A { }", references: [aRef], assemblyName: "AssemblyE").EmitToImageReference();

        var src = """
public unsafe class D
{
    public E** M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, eRef], options: TestOptions.UnsafeDebugDll);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        // Missing references
        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [eRef], options: TestOptions.UnsafeDebugDll).VerifyEmitDiagnostics(
            // error CS0012: The type 'A' is defined in an assembly that is not referenced. You must add a reference to assembly 'AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            Diagnostic(ErrorCode.ERR_NoTypeDef).WithArguments("A", "AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 1));

        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef], options: TestOptions.UnsafeDebugDll).VerifyEmitDiagnostics(
            // (3,12): error CS0246: The type or namespace name 'E' could not be found (are you missing a using directive or an assembly reference?)
            //     public E** M() => throw null;
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "E").WithArguments("E").WithLocation(3, 12),
            // (3,16): warning CS8500: This takes the address of, gets the size of, or declares a pointer to a managed type ('E')
            //     public E** M() => throw null;
            Diagnostic(ErrorCode.WRN_ManagedAddr, "M").WithArguments("E").WithLocation(3, 16));

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("E** D.M()", m.ToTestDisplayString());

            if (module is not SourceModuleSymbol)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E**, AssemblyE, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
                    peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:A** D.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MetadataDependencies_MethodReturn_ArrayType()
    {
        var aRef = CreateCompilation("public class A { }", assemblyName: "AssemblyA").EmitToImageReference();
        var eRef = CreateCompilation("public explicit extension E for A { }", references: [aRef], assemblyName: "AssemblyE").EmitToImageReference();

        var src = """
public unsafe class D
{
    public E[] M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, eRef], options: TestOptions.UnsafeDebugDll);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        // Missing references
        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [eRef], options: TestOptions.UnsafeDebugDll).VerifyEmitDiagnostics(
            // error CS0012: The type 'A' is defined in an assembly that is not referenced. You must add a reference to assembly 'AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            Diagnostic(ErrorCode.ERR_NoTypeDef).WithArguments("A", "AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 1));

        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef], options: TestOptions.UnsafeDebugDll).VerifyEmitDiagnostics(
            // (3,12): error CS0246: The type or namespace name 'E' could not be found (are you missing a using directive or an assembly reference?)
            //     public E[] M() => throw null;
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "E").WithArguments("E").WithLocation(3, 12));

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("E[] D.M()", m.ToTestDisplayString());

            if (module is not SourceModuleSymbol)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E[], AssemblyE, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
                    peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:A[] D.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MetadataDependencies_MethodReturn_ArrayArrayType()
    {
        var aRef = CreateCompilation("public class A { }", assemblyName: "AssemblyA").EmitToImageReference();
        var eRef = CreateCompilation("public explicit extension E for A { }", references: [aRef], assemblyName: "AssemblyE").EmitToImageReference();

        var src = """
public unsafe class D
{
    public E[][] M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef, eRef], options: TestOptions.UnsafeDebugDll);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        // Missing references
        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [eRef], options: TestOptions.UnsafeDebugDll).VerifyEmitDiagnostics(
            // error CS0012: The type 'A' is defined in an assembly that is not referenced. You must add a reference to assembly 'AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            Diagnostic(ErrorCode.ERR_NoTypeDef).WithArguments("A", "AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 1));

        CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [aRef], options: TestOptions.UnsafeDebugDll).VerifyEmitDiagnostics(
            // (3,12): error CS0246: The type or namespace name 'E' could not be found (are you missing a using directive or an assembly reference?)
            //     public E[][] M() => throw null;
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "E").WithArguments("E").WithLocation(3, 12));

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("E[][] D.M()", m.ToTestDisplayString());

            if (module is not SourceModuleSymbol)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E[][], AssemblyE, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null",
                    peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyMethodInPE("MethodDefinition:A[][] D.M()", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void MethodReference_Simple()
    {
        var src = """
E.M();

public explicit extension E for object
{
    public static void M() { System.Console.Write("ran"); }
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics();
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size        6 (0x6)
  .maxstack  0
  IL_0000:  call       "void E.M()"
  IL_0005:  ret
}
""");
    }

    [Fact]
    public void MethodReference_ExtensionTypeArgument()
    {
        var src = """
E<E2>.M();

public explicit extension E<T> for object
{
    public static void M() { System.Console.Write("ran"); }
}

public explicit extension E2 for int { }
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics();
        // PROTOTYPE VerifyIL should erase extensions when we use SymbolDisplayFormat.ILVisualizationFormat
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size        6 (0x6)
  .maxstack  0
  IL_0000:  call       "void E<E2>.M()"
  IL_0005:  ret
}
""");
    }

    [Fact]
    public void MethodReference_ExtensionTypeArgumentInTypeArgument()
    {
        var src = """
E<E<E2>>.M();

public explicit extension E<T> for object
{
    public static void M() { System.Console.Write("ran"); }
}

public explicit extension E2 for int { }
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics();
        // PROTOTYPE VerifyIL should erase extensions when we use SymbolDisplayFormat.ILVisualizationFormat
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size        6 (0x6)
  .maxstack  0
  IL_0000:  call       "void E<E<E2>>.M()"
  IL_0005:  ret
}
""");
    }

    [Fact]
    public void MethodReference_NestedExtensionTypeInTypeArgument()
    {
        var src = """
E<E2.Nested>.M();

public explicit extension E<T> for object
{
    public static void M() { System.Console.Write("ran"); }
}

public explicit extension E2 for int
{
    public class Nested { }
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics();
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size        6 (0x6)
  .maxstack  0
  IL_0000:  call       "void E<E2.Nested>.M()"
  IL_0005:  ret
}
""");
    }

    [Fact]
    public void MethodReference_ArrayInTypeArgument()
    {
        var src = """
E<E2[]>.M();

public explicit extension E<T> for object
{
    public static void M() { System.Console.Write("ran"); }
}

public explicit extension E2 for int { }
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics();
        // PROTOTYPE VerifyIL should erase extensions when we use SymbolDisplayFormat.ILVisualizationFormat
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size        6 (0x6)
  .maxstack  0
  IL_0000:  call       "void E<E2[]>.M()"
  IL_0005:  ret
}
""");
    }

    [Fact]
    public void MethodReference_NestedExtensionType()
    {
        var src = """
E1<C1>.E2<C2>.M();

class C1 { }
class C2 { }

public explicit extension E1<T> for object
{
    public explicit extension E2<T2> for int
    {
        public static void M() { System.Console.Write("ran"); }
    }
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics();
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size        6 (0x6)
  .maxstack  0
  IL_0000:  call       "void E1<C1>.E2<C2>.M()"
  IL_0005:  ret
}
""");
    }

    [Fact]
    public void MethodReference_NestedExtensionType_WithExtensionTypeAsTypeArgument()
    {
        var src = """
E1<E3>.E2<E3>.M();

class C1 { }
class C2 { }

public explicit extension E1<T> for object
{
    public explicit extension E2<T2> for int
    {
        public static void M() { System.Console.Write("ran"); }
    }
}

public explicit extension E3 for string { }
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics();
        // PROTOTYPE VerifyIL should erase extensions when we use SymbolDisplayFormat.ILVisualizationFormat
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size        6 (0x6)
  .maxstack  0
  IL_0000:  call       "void E1<E3>.E2<E3>.M()"
  IL_0005:  ret
}
""");
    }

    [Fact]
    public void MethodReference_Generic_Simple()
    {
        var src = """
class C
{
    public static void Main()
    {
        M<E>();
    }
    public static void M<T>() { }
}

public explicit extension E for object
{
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics();
        // PROTOTYPE VerifyIL should erase extensions when we use SymbolDisplayFormat.ILVisualizationFormat
        verifier.VerifyIL("C.Main", """
{
  // Code size        6 (0x6)
  .maxstack  0
  IL_0000:  call       "void C.M<E>()"
  IL_0005:  ret
}
""");
    }

    [Fact]
    public void TypeReference_MethodReturn_RefType()
    {
        var src = """
public explicit extension E for object { }

public class C
{
    public ref E M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);

        void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("C").GetMember<MethodSymbol>("M");
            Assert.Equal("ref E C.M()", m.ToTestDisplayString());
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_Generic_TupleName()
    {
        var src = """
public explicit extension E<T> for C<T> { }

public class C<T> { }

public class D
{
    public static E<(int a, int b)> M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate);

        void validate(ModuleSymbol module)
        {
            bool inSource = module is SourceModuleSymbol;
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            if (inSource)
            {
                Assert.Equal("E<(System.Int32 a, System.Int32 b)> D.M()", m.ToTestDisplayString());
            }
            else
            {
                // PROTOTYPE need to encode and rountrip tuple names, dynamic, nullability, etc too
                Assert.Equal("E<(System.Int32, System.Int32)> D.M()", m.ToTestDisplayString());
            }
        }
    }

    [Fact]
    public void TypeReference_MethodBody_AnonymousType()
    {
        var src = """
public explicit extension E<T> for T
{
    public void Method() { System.Console.Write("ran"); }
}

public class D
{
    public static void Main()
    {
        var x = new { A = 1, B = 2 };
        var y = Extend(x);
        y.Method();
    }

    public static E<T> Extend<T>(T t) => throw null; // => (E<T>)t;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], options: TestOptions.DebugExe);
        // PROTOTYPE verify execution once conversion support is added
        var verifier = CompileAndVerify(comp/*, expectedOutput: "ran"*/).VerifyDiagnostics();
        verifier.VerifyIL("D.Main", """
{
  // Code size       25 (0x19)
  .maxstack  2
  .locals init (<>f__AnonymousType0<int, int> V_0, //x
                <>f__AnonymousType0<int, int> V_1) //y
  IL_0000:  nop
  IL_0001:  ldc.i4.1
  IL_0002:  ldc.i4.2
  IL_0003:  newobj     "<>f__AnonymousType0<int, int>..ctor(int, int)"
  IL_0008:  stloc.0
  IL_0009:  ldloc.0
  IL_000a:  call       "E<<anonymous type: int A, int B>> D.Extend<<anonymous type: int A, int B>>(<anonymous type: int A, int B>)"
  IL_000f:  stloc.1
  IL_0010:  ldloca.s   V_1
  IL_0012:  call       "void E<<anonymous type: int A, int B>>.Method(ref <anonymous type: int A, int B>)"
  IL_0017:  nop
  IL_0018:  ret
}
""");
    }

    [Fact(Skip = "PROTOTYPE assertion in NullableWalker when accessing anonymous type property from underlying type")]
    public void TypeReference_MethodBody_AnonymousType_AccessAnonymousTypeMembers()
    {
        var src = """
public explicit extension E<T> for T { }

public class D
{
    public static void Main()
    {
        var x = new { A = 1, B = 2 };
        var y = Extend(x);
        System.Console.Write(y.A);
    }

    public static E<T> Extend<T>(T t) => (E<T>)t;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], options: TestOptions.DebugExe);
        // PROTOTYPE verify execution once conversion support is added
        var verifier = CompileAndVerify(comp/*, expectedOutput: "ran"*/).VerifyDiagnostics();
        verifier.VerifyIL("D.Main", """
{
  // Code size       25 (0x19)
  .maxstack  2
  .locals init (<>f__AnonymousType0<int, int> V_0, //x
                <>f__AnonymousType0<int, int> V_1) //y
  IL_0000:  nop
  IL_0001:  ldc.i4.1
  IL_0002:  ldc.i4.2
  IL_0003:  newobj     "<>f__AnonymousType0<int, int>..ctor(int, int)"
  IL_0008:  stloc.0
  IL_0009:  ldloc.0
  IL_000a:  call       "E<<anonymous type: int A, int B>> D.Extend<<anonymous type: int A, int B>>(<anonymous type: int A, int B>)"
  IL_000f:  stloc.1
  IL_0010:  ldloca.s   V_1
  IL_0012:  call       "void E<<anonymous type: int A, int B>>.Method(ref <anonymous type: int A, int B>)"
  IL_0017:  nop
  IL_0018:  ret
}
""");
    }

    [Fact]
    public void TypeReference_Typeof_Simple()
    {
        var src = """
System.Console.Write(D.M().ToString());

public explicit extension E for U { }

public class U { }
public class D
{
    public static System.Type M()
    {
        return typeof(E);
    }
}
""";

        var comp = CreateCompilation(src);
        var verifier = CompileAndVerify(comp, expectedOutput: "U").VerifyDiagnostics();
        verifier.VerifyIL("D.M", """
{
  // Code size       11 (0xb)
  .maxstack  1
  IL_0000:  ldtoken    "U"
  IL_0005:  call       "System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)"
  IL_000a:  ret
}
""");
    }

    [Fact]
    public void TypeReference_Typeof_Generic()
    {
        var src = """
System.Console.Write(D.M().ToString());

public explicit extension E for U { }

public class U { }
public class C<T> { }
public class D
{
    public static System.Type M()
    {
        return typeof(C<E>);
    }
}
""";

        var comp = CreateCompilation(src);
        var verifier = CompileAndVerify(comp, expectedOutput: "C`1[U]").VerifyDiagnostics();
        // PROTOTYPE VerifyIL should erase extensions when we use SymbolDisplayFormat.ILVisualizationFormat
        verifier.VerifyIL("D.M", """
{
  // Code size       11 (0xb)
  .maxstack  1
  IL_0000:  ldtoken    "C<E>"
  IL_0005:  call       "System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)"
  IL_000a:  ret
}
""");
    }

    [Fact]
    public void TypeReference_Typeof_Container()
    {
        var src = """
System.Console.Write(D.M().ToString());

public explicit extension E for U 
{
    public explicit extension NestedE for U { }
    public class Nested { }
    public class C<T1, T2> { }
}

public class U { }
public class D
{
    public static System.Type M()
    {
        return typeof(E.C<E.NestedE, E.Nested>);
    }
}
""";

        var comp = CreateCompilation(src);
        var verifier = CompileAndVerify(comp, expectedOutput: "E+C`2[U,E+Nested]").VerifyDiagnostics();
        // PROTOTYPE VerifyIL should erase extensions when we use SymbolDisplayFormat.ILVisualizationFormat
        verifier.VerifyIL("D.M", """
{
  // Code size       11 (0xb)
  .maxstack  1
  IL_0000:  ldtoken    "E.C<E.NestedE, E.Nested>"
  IL_0005:  call       "System.Type System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)"
  IL_000a:  ret
}
""");
    }

    [Fact]
    public void TypeReference_Modopt_Simple()
    {
        // public explicit extension E for object { }
        // public class Base
        // {
        //     public virtual object /*modopt(E)*/ M()
        //     {
        //         throw null;
        //     }
        // }
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit E
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: true)}}'(object '') cil managed
    {
        IL_0000: ret
    }
}

.class public auto ansi beforefieldinit Base
    extends [mscorlib]System.Object
{
    .method public hidebysig newslot virtual instance class [mscorlib]System.Object modopt(E) M() cil managed
    {
        IL_0000: ldnull
        IL_0001: throw
    }

    .method public hidebysig specialname rtspecialname instance void .ctor() cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Object::.ctor()
        IL_0006: ret
    }
}
""";

        var src = """
new Derived().M();

public class Derived : Base
{
    public override object /*modopt(E)*/ M()
    {
        System.Console.Write("ran");
        return null;
    }
}
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics();
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate, expectedOutput: "ran");

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("Derived").GetMember<MethodSymbol>("M");
            Assert.Equal("System.Object modopt(E) Derived.M()", m.ToTestDisplayString());

            if (module is not SourceModuleSymbol)
            {
                var peMethod = (PEMethodSymbol)m;
                VerifyNoExtensionErasureAttribute((PEModuleSymbol)peMethod.ContainingModule, peMethod.ReturnTypeParameter.Handle);
            }
        }
    }

    [Fact(Skip = "PROTOTYPE need to keep un-erased extension types in modifiers")]
    public void TypeReference_Modopt_ExtensionAsTypeArgument()
    {
        // public explicit extension E for object { }
        // public class C<T> { }
        // public class Base
        // {
        //     public virtual object /*modopt(C<E>)*/ M()
        //     {
        //         throw null;
        //     }
        // }
        var ilSource = $$"""
.class public sequential ansi sealed beforefieldinit E
    extends [mscorlib]System.ValueType
{
    .method public hidebysig static void '{{ExtensionMarkerName(isExplicit: true)}}'(object '') cil managed
    {
        IL_0000: ret
    }
}

.class public auto ansi beforefieldinit C`1<T>
    extends [mscorlib]System.Object
{
    .method public hidebysig specialname rtspecialname instance void .ctor() cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Object::.ctor()
        IL_0006: ret
    }
}

.class public auto ansi beforefieldinit Base
    extends [mscorlib]System.Object
{
    .method public hidebysig newslot virtual instance class [mscorlib]System.Object modopt(class C`1<class E>) M() cil managed
    {
        IL_0000: ldnull
        IL_0001: throw
    }

    .method public hidebysig specialname rtspecialname instance void .ctor() cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Object::.ctor()
        IL_0006: ret
    }
}
""";

        var src = """
new Derived().M();

public class Derived : Base
{
    public override object /*modopt(C<E>)*/ M()
    {
        System.Console.Write("ran");
        return null;
    }
}
""";

        var comp = CreateCompilationWithIL(src, ilSource);
        comp.VerifyDiagnostics();
        // PROTOTYPE need to keep un-erased extension types in modifiers
        // The problem is that the infrastructure that assigns tokens for type references (GetOrAddTypeSpecificationHandle)
        // is given a type reference for `C<E>` but doesn't know if it's meant to be erased (to `C<object>`) or kept as-is.
        // By default we erase extension types, so the token for `C<E>` is really for `C<object>`, which is incorrect in custom modifiers.
        // Instead of pushing an additional flag (keepExtensions) in that API, we discussed a possible design where the type reference
        // itself would keep track of whether it is meant to be erased of not.
        //
        // The Translate API would still be given a keepExtensions flag, then:
        // - for a non-generic type, it would either erase or not
        // - for a generic type that includes an extension type that should not be erased, it would return an adapter that records that fact
        //   Such adapter, when prompted for its type arguments would repeat that process.
        //
        // This design would be pay-for-play. Aside from a check to decide whether this extra allocation is needed,
        // type references would incur no overhead unless they involve some erasable extension type that needs to be kept as-is.
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate/*, expectedOutput: "ran"*/, verify: Verification.Fails);

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("Derived").GetMember<MethodSymbol>("M");
            //Assert.Equal("System.Object modopt(C<E>) Derived.M()", m.ToTestDisplayString());

            if (module is not SourceModuleSymbol)
            {
                var peMethod = (PEMethodSymbol)m;
                VerifyNoExtensionErasureAttribute((PEModuleSymbol)peMethod.ContainingModule, peMethod.ReturnTypeParameter.Handle);
            }
        }
    }

    [Fact]
    public void TypeReference_Parameter_Simple()
    {
        var src = """
public explicit extension E for object { }

public class C
{
    public void M(E e) => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("C").GetMember<MethodSymbol>("M");
            Assert.Equal("void C.M(E e)", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E", peModule, ((PEParameterSymbol)peMethod.Parameters[0]).Handle);
                VerifyMethodInPE("MethodDefinition:Void C.M(Object)", peMethod.Handle, peModule);
            }
        }
    }

    [Fact(Skip = "PROTOTYPE need to generate the attribute when it is missing")]
    public void TypeReference_Parameter_Simple_MissingAttribute()
    {
        var src = """
public explicit extension E for object { }

public class C
{
    public void M(E e) { }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void TypeReference_Parameter_ExplicitAttributeUsage()
    {
        var src = """
public explicit extension E for object { }

public class C
{
    public void M([System.Runtime.CompilerServices.ExtensionErasureAttribute("E")] object o) { }
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        comp.VerifyEmitDiagnostics(
            // (5,20): error CS9329: Do not use 'System.Runtime.CompilerServices.ExtensionErasureAttribute'. This is reserved for compiler usage.
            //     public void M([System.Runtime.CompilerServices.ExtensionErasureAttribute("E")] object o) { }
            Diagnostic(ErrorCode.ERR_ExplicitExtensionErasureAttr, @"System.Runtime.CompilerServices.ExtensionErasureAttribute(""E"")").WithLocation(5, 20));
    }

    [Fact]
    public void TypeReference_Parameter_Generic()
    {
        var libSrc = """public class A { }""";
        var libRef = CreateCompilation(libSrc, assemblyName: "AssemblyA").EmitToImageReference();
        var src = """
public explicit extension E<T> for C<int> { }

public class C<T> { }
public class D
{
    public void M(E<A> e) => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition], references: [libRef]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("void D.M(E<A> e)", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E`1[[A, AssemblyA, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null]]",
                    peModule, ((PEParameterSymbol)peMethod.Parameters[0]).Handle);
                VerifyMethodInPE("MethodDefinition:Void D.M(C`1{Int32})", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_Parameter_ExtensionAsTypeArgument()
    {
        var src = """
public explicit extension E for int { }

public class C<T> { }
public class D
{
    public void M(C<E> c) { }
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("D").GetMember<MethodSymbol>("M");
            Assert.Equal("void D.M(C<E> c)", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)m;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("C`1[E]", peModule, ((PEParameterSymbol)peMethod.Parameters[0]).Handle);
                VerifyMethodInPE("MethodDefinition:Void D.M(C`1{Int32})", peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_MethodReturn_ExtensionTypeMethod()
    {
        var src = """
public explicit extension E for int
{
    public E M() => throw null;
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        var verifier = CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("E").GetMember<MethodSymbol>("M");
            Assert.Equal("E E.M()", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)((PEExtensionInstanceMethodSymbol)m).UnderlyingMethod;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyExtensionErasureAttribute("E", peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyNoExtensionErasureAttribute(peModule, ((PEParameterSymbol)peMethod.Parameters[0]).Handle);
                VerifyMethodInPE("MethodDefinition:Int32 E.M(modreq(System.Runtime.CompilerServices.ExtensionAttribute) Int32&)",
                    peMethod.Handle, peModule);
            }
        }
    }

    [Fact]
    public void TypeReference_Parameter_ExtensionTypeMethod()
    {
        var src = """
public explicit extension E for int
{
    public void M(E e) { }
}
""";

        var comp = CreateCompilation([src, ExtensionErasureAttributeDefinition]);
        var verifier = CompileAndVerify(comp, symbolValidator: validate, sourceSymbolValidator: validate).VerifyDiagnostics();

        static void validate(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<NamedTypeSymbol>("E").GetMember<MethodSymbol>("M");
            Assert.Equal("void E.M(E e)", m.ToTestDisplayString());

            bool inSource = module is SourceModuleSymbol;
            if (!inSource)
            {
                var peMethod = (PEMethodSymbol)((PEExtensionInstanceMethodSymbol)m).UnderlyingMethod;
                var peModule = (PEModuleSymbol)peMethod.ContainingModule;
                VerifyNoExtensionErasureAttribute(peModule, peMethod.ReturnTypeParameter.Handle);
                VerifyNoExtensionErasureAttribute(peModule, ((PEParameterSymbol)peMethod.Parameters[0]).Handle);
                VerifyExtensionErasureAttribute("E", peModule, ((PEParameterSymbol)peMethod.Parameters[1]).Handle);
                VerifyMethodInPE("MethodDefinition:Void E.M(modreq(System.Runtime.CompilerServices.ExtensionAttribute) Int32&, Int32)",
                    peMethod.Handle, peModule);
            }
        }
    }
}
