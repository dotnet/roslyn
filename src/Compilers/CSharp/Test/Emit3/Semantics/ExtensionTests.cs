// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.
#nullable disable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp.Symbols;
using Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp.Test.Utilities;
using Microsoft.CodeAnalysis.Emit;
using Microsoft.CodeAnalysis.Test.Utilities;
using Microsoft.CodeAnalysis.VisualBasic;
using Roslyn.Test.Utilities;
using Xunit;
using Xunit.Sdk;

namespace Microsoft.CodeAnalysis.CSharp.UnitTests.Semantics;

[CompilerTrait(CompilerFeature.Extensions)]
public class ExtensionTests : CompilingTestBase
{
    private static string ExpectedOutput(string output)
    {
        return ExecutionConditionUtil.IsMonoOrCoreClr ? output : null;
    }

    private static void VerifyTypeIL(CompilationVerifier compilation, string typeName, string expected)
    {
        // .Net Core has different assemblies for the same standard library types as .Net Framework, meaning that that the emitted output will be different to the expected if we run them .Net Core
        // Since we do not expect there to be any meaningful differences between output for .Net Core and .Net Framework, we will skip these tests on .Net Framework
        if (ExecutionConditionUtil.IsCoreClr)
        {
            compilation.VerifyTypeIL(typeName, expected);
        }
    }

    private static void AssertEqualAndNoDuplicates(string[] expected, string[] actual)
    {
        Assert.True(expected.All(new HashSet<string>().Add), $"Duplicates were found in '{nameof(expected)}'");
        Assert.True(actual.All(new HashSet<string>().Add), $"Duplicates were found in '{nameof(actual)}'");
        AssertEx.SetEqual(expected, actual);
    }

    private static void AssertExtensionDeclaration(INamedTypeSymbol symbol)
    {
        // Verify things that are common for all extension types
        Assert.Equal(TypeKind.Extension, symbol.TypeKind);
        Assert.True(symbol.IsExtension);
        Assert.Null(symbol.BaseType);
        Assert.Empty(symbol.Interfaces);
        Assert.Empty(symbol.AllInterfaces);
        Assert.True(symbol.IsReferenceType);
        Assert.False(symbol.IsValueType);
        Assert.False(symbol.IsAnonymousType);
        Assert.False(symbol.IsTupleType);
        Assert.False(symbol.IsNativeIntegerType);
        Assert.Equal(SpecialType.None, symbol.SpecialType);
        Assert.False(symbol.IsRefLikeType);
        Assert.False(symbol.IsUnmanagedType);
        Assert.False(symbol.IsReadOnly);
        Assert.False(symbol.IsRecord);
        Assert.Equal(CodeAnalysis.NullableAnnotation.None, symbol.NullableAnnotation);
        Assert.Throws<NotSupportedException>(() => { symbol.WithNullableAnnotation(CodeAnalysis.NullableAnnotation.Annotated); });

        Assert.False(symbol.IsScriptClass);
        Assert.False(symbol.IsImplicitClass);
        Assert.False(symbol.IsComImport);
        Assert.False(symbol.IsFileLocal);
        Assert.Null(symbol.DelegateInvokeMethod);
        Assert.Null(symbol.EnumUnderlyingType);
        Assert.Null(symbol.AssociatedSymbol);
        Assert.False(symbol.MightContainExtensionMethods);
        Assert.Null(symbol.TupleUnderlyingType);
        Assert.True(symbol.TupleElements.IsDefault);
        Assert.False(symbol.IsSerializable);
        Assert.Null(symbol.NativeIntegerUnderlyingType);

        Assert.Equal(SymbolKind.NamedType, symbol.Kind);
        Assert.Equal("", symbol.Name);
        Assert.Equal(SpecialType.None, symbol.SpecialType);
        Assert.True(symbol.IsDefinition);
        Assert.False(symbol.IsStatic);
        Assert.False(symbol.IsVirtual);
        Assert.False(symbol.IsOverride);
        Assert.False(symbol.IsAbstract);
        Assert.True(symbol.IsSealed);
        Assert.False(symbol.IsExtern);
        Assert.False(symbol.IsImplicitlyDeclared);
        Assert.False(symbol.CanBeReferencedByName);
        Assert.Equal(Accessibility.Public, symbol.DeclaredAccessibility);

        var namedTypeSymbol = symbol.GetSymbol<NamedTypeSymbol>();
        Assert.False(namedTypeSymbol.HasSpecialName);
        Assert.False(namedTypeSymbol.IsImplicitlyDeclared);
    }

    [Fact]
    public void EmptyExtension()
    {
        var src = """
public static class Extensions
{
    extension(object) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var verifier = CompileAndVerify(comp);
        VerifyTypeIL(verifier, "Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [netstandard]System.Object
{
    .custom instance void [netstandard]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [netstandard]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object ''
            ) cil managed 
        {
            .custom instance void [netstandard]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2067
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
    } // end of class <>E__0
} // end of class Extensions
""");

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        AssertExtensionDeclaration(symbol);

        Assert.Empty(symbol.MemberNames);
        Assert.Empty(symbol.InstanceConstructors);
        Assert.Empty(symbol.StaticConstructors);
        Assert.Empty(symbol.Constructors);

        Assert.Equal(0, symbol.Arity);
        Assert.False(symbol.IsGenericType);
        Assert.False(symbol.IsUnboundGenericType);
        Assert.Empty(symbol.TypeParameters);
        Assert.Empty(symbol.TypeArguments);
        Assert.Same(symbol, symbol.OriginalDefinition);
        Assert.Same(symbol, symbol.ConstructedFrom);
        Assert.Equal("Extensions", symbol.ContainingSymbol.Name);
        Assert.Equal("Extensions", symbol.ContainingType.Name);
        Assert.Equal("<>E__0", symbol.MetadataName);

        var member = symbol.ContainingType.GetMembers().Single();
        Assert.Equal("Extensions.<>E__0", member.ToTestDisplayString());

        var format = new SymbolDisplayFormat(typeQualificationStyle: SymbolDisplayTypeQualificationStyle.NameAndContainingTypesAndNamespaces);
        Assert.Equal("Extensions.extension(System.Object)", symbol.ToDisplayString(format));

        format = new SymbolDisplayFormat(kindOptions: SymbolDisplayKindOptions.IncludeTypeKeyword);
        Assert.Equal("extension(Object)", symbol.ToDisplayString(format));

        format = new SymbolDisplayFormat();
        Assert.Equal("extension(Object)", symbol.ToDisplayString(format));

        format = new SymbolDisplayFormat(compilerInternalOptions: SymbolDisplayCompilerInternalOptions.UseMetadataMemberNames);
        Assert.Equal("<>E__0", symbol.ToDisplayString(format));

        var comp5 = CreateCompilation(src);
        comp5.MakeMemberMissing(WellKnownMember.System_Runtime_CompilerServices_ExtensionAttribute__ctor);
        comp5.VerifyEmitDiagnostics(
            // (3,5): error CS1110: Cannot define a new extension because the compiler required type 'System.Runtime.CompilerServices.ExtensionAttribute' cannot be found. Are you missing a reference to System.Core.dll?
            //     extension(object) { }
            Diagnostic(ErrorCode.ERR_ExtensionAttrNotFound, "extension").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(3, 5)
            );
    }

    [Fact]
    public void TypeParameters_01()
    {
        // Unconstrained type parameter
        var src = """
public static class Extensions
{
    extension<T>(T) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var verifier = CompileAndVerify(comp);
        VerifyTypeIL(verifier, "Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [netstandard]System.Object
{
    .custom instance void [netstandard]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<T>
        extends [netstandard]System.Object
    {
        // Methods
        .method private hidebysig specialname static
            void '<Extension>$' (
                !T ''
            ) cil managed
        {
            .custom instance void [netstandard]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2067
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
    } // end of class <>E__0`1
} // end of class Extensions
""");

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        AssertExtensionDeclaration(symbol);

        Assert.Equal(1, symbol.Arity);
        Assert.True(symbol.IsGenericType);
        Assert.False(symbol.IsUnboundGenericType);
        Assert.Equal(["T"], symbol.TypeParameters.ToTestDisplayStrings());
        Assert.Equal(["T"], symbol.TypeArguments.ToTestDisplayStrings());
        Assert.Same(symbol, symbol.OriginalDefinition);
        Assert.Same(symbol, symbol.ConstructedFrom);
        Assert.Equal("Extensions", symbol.ContainingSymbol.Name);
        Assert.Equal("Extensions", symbol.ContainingType.Name);
        Assert.Equal("<>E__0`1", symbol.MetadataName);

        var member = symbol.ContainingType.GetMembers().Single();
        Assert.Equal("Extensions.<>E__0<T>", member.ToTestDisplayString());

        var constructed = symbol.Construct(comp.GetSpecialType(SpecialType.System_Int32));
        Assert.True(constructed.IsExtension);
        Assert.Equal("Extensions.<>E__0<System.Int32>", constructed.ToTestDisplayString());
        Assert.Equal("<>E__0`1", constructed.MetadataName);
        Assert.NotSame(symbol, constructed);
        Assert.Same(symbol, constructed.OriginalDefinition);
        Assert.Same(symbol, constructed.ConstructedFrom);

        var unbound = symbol.ConstructUnboundGenericType();
        Assert.Equal("Extensions.<>E__0<>", unbound.ToTestDisplayString());
        Assert.True(unbound.IsUnboundGenericType);
        Assert.NotSame(symbol, unbound);
        Assert.Same(symbol, unbound.OriginalDefinition);
        Assert.Same(symbol, unbound.ConstructedFrom);
    }

    [Fact]
    public void TypeParameters_02()
    {
        // Constrained type parameter
        var src = """
public static class Extensions
{
    extension<T>(T) where T : struct { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var verifier = CompileAndVerify(comp);
        VerifyTypeIL(verifier, "Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [netstandard]System.Object
{
    .custom instance void [netstandard]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<valuetype .ctor ([netstandard]System.ValueType) T>
        extends [netstandard]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                !T ''
            ) cil managed 
        {
            .custom instance void [netstandard]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2067
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
    } // end of class <>E__0`1
} // end of class Extensions
""");

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);

        Assert.Equal(1, symbol.Arity);
        Assert.True(symbol.IsGenericType);
        Assert.Equal(["T"], symbol.TypeParameters.ToTestDisplayStrings());
        Assert.Equal(["T"], symbol.TypeArguments.ToTestDisplayStrings());
        Assert.True(symbol.TypeParameters.Single().IsValueType);
        Assert.False(symbol.TypeParameters.Single().IsReferenceType);
        Assert.Empty(symbol.TypeParameters.Single().ConstraintTypes);

        var format = new SymbolDisplayFormat(genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters | SymbolDisplayGenericsOptions.IncludeTypeConstraints);
        Assert.Equal("extension<T>(T) where T : struct", symbol.ToDisplayString(format));
    }

    [Fact]
    public void TypeParameters_03()
    {
        // Constraint on undefined type parameter
        var src = """
public static class Extensions
{
    extension(object) where T : struct { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,23): error CS0080: Constraints are not allowed on non-generic declarations
            //     extension(object) where T : struct { }
            Diagnostic(ErrorCode.ERR_ConstraintOnlyAllowedOnGenericDecl, "where").WithLocation(3, 23));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(0, symbol.Arity);
        Assert.False(symbol.IsGenericType);
        Assert.Empty(symbol.TypeParameters.ToTestDisplayStrings());
        Assert.Empty(symbol.TypeArguments.ToTestDisplayStrings());
    }

    [Fact]
    public void TypeParameters_04()
    {
        // Type parameter variance
        var src = """
public static class Extensions
{
    extension<out T>(T) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS1960: Invalid variance modifier. Only interface and delegate type parameters can be specified as variant.
            //     extension<out T>(object) { }
            Diagnostic(ErrorCode.ERR_IllegalVarianceSyntax, "out").WithLocation(3, 15));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(1, symbol.Arity);
        Assert.True(symbol.IsGenericType);
        Assert.Equal(["out T"], symbol.TypeParameters.ToTestDisplayStrings());
        Assert.Equal(["out T"], symbol.TypeArguments.ToTestDisplayStrings());
    }

    [Fact]
    public void TypeParameters_05()
    {
        // Duplicate type parameter
        var src = """
public static class Extensions
{
    extension<T, T>(T) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,18): error CS0692: Duplicate type parameter 'T'
            //     extension<T, T>(T) { }
            Diagnostic(ErrorCode.ERR_DuplicateTypeParameter, "T").WithArguments("T").WithLocation(3, 18),
            // (3,21): error CS0229: Ambiguity between 'T' and 'T'
            //     extension<T, T>(T) { }
            Diagnostic(ErrorCode.ERR_AmbigMember, "T").WithArguments("T", "T").WithLocation(3, 21),
            // (3,21): error CS9295: The extended type 'T' must reference all the type parameters declared by the extension, but type parameter 'T' is not referenced.
            //     extension<T, T>(T) { }
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "T").WithArguments("T", "T").WithLocation(3, 21),
            // (3,21): error CS9295: The extended type 'T' must reference all the type parameters declared by the extension, but type parameter 'T' is not referenced.
            //     extension<T, T>(T) { }
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "T").WithArguments("T", "T").WithLocation(3, 21));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(2, symbol.Arity);
        Assert.Equal(["T", "T"], symbol.TypeParameters.ToTestDisplayStrings());
        Assert.Equal(["T", "T"], symbol.TypeArguments.ToTestDisplayStrings());
    }

    [Fact]
    public void TypeParameters_05_Nested()
    {
        // Duplicate type parameter
        var src = """
public static class Extensions
{
    extension<T, T>(C<T>) { }
}
class C<T> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,18): error CS0692: Duplicate type parameter 'T'
            //     extension<T, T>(C<T>) { }
            Diagnostic(ErrorCode.ERR_DuplicateTypeParameter, "T").WithArguments("T").WithLocation(3, 18),
            // (3,21): error CS9295: The extended type 'C<T>' must reference all the type parameters declared by the extension, but type parameter 'T' is not referenced.
            //     extension<T, T>(C<T>) { }
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "C<T>").WithArguments("C<T>", "T").WithLocation(3, 21),
            // (3,21): error CS9295: The extended type 'C<T>' must reference all the type parameters declared by the extension, but type parameter 'T' is not referenced.
            //     extension<T, T>(C<T>) { }
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "C<T>").WithArguments("C<T>", "T").WithLocation(3, 21),
            // (3,23): error CS0229: Ambiguity between 'T' and 'T'
            //     extension<T, T>(C<T>) { }
            Diagnostic(ErrorCode.ERR_AmbigMember, "T").WithArguments("T", "T").WithLocation(3, 23));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(2, symbol.Arity);
        Assert.Equal(["T", "T"], symbol.TypeParameters.ToTestDisplayStrings());
        Assert.Equal(["T", "T"], symbol.TypeArguments.ToTestDisplayStrings());
    }

    [Fact]
    public void TypeParameters_06()
    {
        // Type parameter same as outer type parameter
        var src = """
public static class Extensions<T>
{
    extension<T>(T) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,5): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            //     extension<T>(object) { }
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(3, 5),
            // (3,15): warning CS0693: Type parameter 'T' has the same name as the type parameter from outer type 'Extensions<T>'
            //     extension<T>(object) { }
            Diagnostic(ErrorCode.WRN_TypeParameterSameAsOuterTypeParameter, "T").WithArguments("T", "Extensions<T>").WithLocation(3, 15));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(1, symbol.Arity);
        Assert.Equal(["T"], symbol.TypeParameters.ToTestDisplayStrings());
        Assert.Equal(["T"], symbol.TypeArguments.ToTestDisplayStrings());

        var container = symbol.ContainingType;
        var substitutedExtension = (INamedTypeSymbol)container.Construct(comp.GetSpecialType(SpecialType.System_Int32)).GetMembers().Single();
        Assert.Equal("Extensions<System.Int32>.<>E__0<T>", substitutedExtension.ToTestDisplayString());
        Assert.True(substitutedExtension.IsExtension);
    }

    [Fact]
    public void TypeParameters_07()
    {
        // Reserved type name for type parameter
        var src = $$"""
public static class Extensions
{
    extension<record>(record) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): warning CS8860: Types and aliases should not be named 'record'.
            //     extension<record>(object) { }
            Diagnostic(ErrorCode.WRN_RecordNamedDisallowed, "record").WithLocation(3, 15));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(["record"], symbol.TypeParameters.ToTestDisplayStrings());
    }

    [Fact]
    public void TypeParameters_08()
    {
        // Reserved type name for type parameter
        var src = $$"""
public static class Extensions
{
    extension<file>(file) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS9056: Types and aliases cannot be named 'file'.
            //     extension<file>(object) { }
            Diagnostic(ErrorCode.ERR_FileTypeNameDisallowed, "file").WithLocation(3, 15));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(["file"], symbol.TypeParameters.ToTestDisplayStrings());
    }

    [Fact]
    public void TypeParameters_09()
    {
        // Member name same as type parameter
        var src = $$"""
public static class Extensions
{
    extension<T>(T)
    {
        void T() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void TypeParameters_10()
    {
        var src = $$"""
#nullable enable
public static class Extensions
{
    extension<T>(T) where T : notnull
    {
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        var verifier = CompileAndVerify(comp);
        VerifyTypeIL(verifier, "Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [netstandard]System.Object
{
    .custom instance void [netstandard]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<T>
        extends [netstandard]System.Object
    {
        .custom instance void System.Runtime.CompilerServices.NullableContextAttribute::.ctor(uint8) = (
            01 00 01 00 00
        )
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                !T ''
            ) cil managed 
        {
            .custom instance void [netstandard]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x209d
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
    } // end of class <>E__0`1
} // end of class Extensions
""");
    }

    [Fact]
    public void BadContainer_Generic()
    {
        var src = """
object.M();

public static class Extensions<T>
{
    extension(object) { public static void M() { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'M'
            // object.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(1, 8),
            // (5,5): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            //     extension(object) { public static void M() { } }
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(5, 5));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        AssertExtensionDeclaration(symbol);
        Assert.True(symbol.IsGenericType);
        var members = symbol.ContainingType.GetMembers();
        Assert.Equal(["Extensions<T>.<>E__0", "void Extensions<T>.M()"], members.ToTestDisplayStrings());
    }

    [Fact]
    public void BadContainer_TopLevel()
    {
        var src = """
object.M();

extension(object) { public static void M() { } }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'M'
            // object.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(1, 8),
            // (3,1): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            // extension(object) { public static void M() { } }
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(3, 1));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        AssertExtensionDeclaration(symbol);
        Assert.Null(symbol.ContainingType);
        Assert.Equal("<>E__0", symbol.ToTestDisplayString());
    }

    [Fact]
    public void BadContainer_Nested()
    {
        var src = """
object.M();

public static class Extensions
{
    static void Method()
    {
        object.M();
    }

    public static class Extensions2
    {
        extension(object) { public static void M() { } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'M'
            // object.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(1, 8),
            // (7,16): error CS0117: 'object' does not contain a definition for 'M'
            //         object.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(7, 16),
            // (12,9): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            //         extension(object) { public static void M() { } }
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(12, 9));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var nestedExtension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Last();

        var nestedExtensionSymbol = model.GetDeclaredSymbol(nestedExtension);
        AssertExtensionDeclaration(nestedExtensionSymbol);
        Assert.Equal("Extensions.Extensions2", nestedExtensionSymbol.ContainingType.ToTestDisplayString());
        var members = nestedExtensionSymbol.ContainingType.GetMembers();
        Assert.Equal(["Extensions.Extensions2.<>E__0", "void Extensions.Extensions2.M()"], members.ToTestDisplayStrings());
    }

    [Fact]
    public void BadContainer_NestedInExtension()
    {
        var src = """
string.M();

public static class Extensions
{
    static void Method2()
    {
        string.M();
    }

    extension(object)
    {
        static void Method()
        {
            string.M();
        }

        extension(string) { public static void M() { } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0117: 'string' does not contain a definition for 'M'
            // string.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("string", "M").WithLocation(1, 8),
            // (7,16): error CS0117: 'string' does not contain a definition for 'M'
            //         string.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("string", "M").WithLocation(7, 16),
            // (14,20): error CS0117: 'string' does not contain a definition for 'M'
            //             string.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("string", "M").WithLocation(14, 20),
            // (17,9): error CS9282: Extension declarations can include only methods or properties
            //         extension(string) { public static void M() { } }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "extension").WithLocation(17, 9));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var nestedExtension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Last();

        var nestedExtensionSymbol = model.GetDeclaredSymbol(nestedExtension);
        AssertExtensionDeclaration(nestedExtensionSymbol);
        Assert.Equal("Extensions.<>E__0", nestedExtensionSymbol.ContainingType.ToTestDisplayString());
        Assert.Equal(["void Extensions.<>E__0.<Extension>$(System.Object)", "void Extensions.<>E__0.Method()", "Extensions.<>E__0.<>E__0"], nestedExtensionSymbol.ContainingType.GetMembers().ToTestDisplayStrings());
    }

    [Fact]
    public void BadContainer_TypeKind()
    {
        var src = """
object.M();

public static struct Extensions
{
    extension(object) { public static void M() { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'M'
            // object.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(1, 8),
            // (3,22): error CS0106: The modifier 'static' is not valid for this item
            // public static struct Extensions
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "Extensions").WithArguments("static").WithLocation(3, 22),
            // (5,5): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            //     extension(object) { public static void M() { } }
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(5, 5));
    }

    [Fact]
    public void BadContainer_NotStatic()
    {
        var src = """
object.M();

public class Extensions
{
    extension(object) { public static void M() { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'M'
            // object.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(1, 8),
            // (5,5): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            //     extension(object) { public static void M() { } }
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(5, 5));
    }

    [Theory, CombinatorialData]
    public void ExtensionIndex_InPartial(bool reverseOrder)
    {
        var src1 = """
public static partial class Extensions
{
    extension(object) { }
}
""";
        var src2 = """
public static partial class Extensions
{
}
""";

        var src = reverseOrder ? new[] { src2, src1 } : new[] { src1, src2 };
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var verifier = CompileAndVerify(comp);
        VerifyTypeIL(verifier, "Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [netstandard]System.Object
{
    .custom instance void [netstandard]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [netstandard]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object ''
            ) cil managed 
        {
            .custom instance void [netstandard]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2067
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
    } // end of class <>E__0
} // end of class Extensions
""");

        var tree = comp.SyntaxTrees[reverseOrder ? 1 : 0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        AssertExtensionDeclaration(symbol);
        Assert.Equal("<>E__0", symbol.MetadataName);
    }

    [Fact]
    public void ExtensionIndex_InPartial_TwoExtension()
    {
        var src1 = """
public static partial class Extensions
{
    extension<T>(T t) { }
}
""";
        var src2 = """
public static partial class Extensions
{
    extension<T1, T2>((T1, T2) t) { }
}
""";

        var comp = CreateCompilation([src1, src2]);
        comp.VerifyEmitDiagnostics();

        var tree1 = comp.SyntaxTrees[0];
        var model1 = comp.GetSemanticModel(tree1);
        var extension1 = tree1.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var symbol1 = model1.GetDeclaredSymbol(extension1);
        var sourceExtension1 = symbol1.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__0`1", symbol1.MetadataName);
        Assert.Equal("Extensions.<>E__0<T>", sourceExtension1.ToTestDisplayString());

        var tree2 = comp.SyntaxTrees[1];
        var extension2 = tree2.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var model2 = comp.GetSemanticModel(tree2);
        var symbol2 = model2.GetDeclaredSymbol(extension2);
        var sourceExtension2 = symbol2.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__1`2", symbol2.MetadataName);
        Assert.Equal("Extensions.<>E__1<T1, T2>", sourceExtension2.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionIndex_InPartial_TwoExtensions()
    {
        var src = """
public static partial class Extensions
{
    extension<T>(T) { }
}
public static partial class Extensions
{
    extension<T1, T2>((T1, T2)) { }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension1 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().First();
        var symbol1 = model.GetDeclaredSymbol(extension1);
        Assert.Equal("<>E__0`1", symbol1.MetadataName);
        Assert.Equal("Extensions.<>E__0<T>", symbol1.ToTestDisplayString());

        var extension2 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Last();
        var symbol2 = model.GetDeclaredSymbol(extension2);
        Assert.Equal("<>E__1`2", symbol2.MetadataName);
        Assert.Equal("Extensions.<>E__1<T1, T2>", symbol2.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionIndex_TwoExtensions_SameSignatures_01()
    {
        var src = """
public static class Extensions
{
    extension<T>(T) { }
    extension<T>(T) { }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension1 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().First();
        var symbol1 = model.GetDeclaredSymbol(extension1);
        var sourceExtension1 = symbol1.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__0`1", symbol1.MetadataName);
        Assert.Equal("Extensions.<>E__0<T>", symbol1.ToTestDisplayString());

        var extension2 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Last();
        var symbol2 = model.GetDeclaredSymbol(extension2);
        var sourceExtension2 = symbol2.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__1`1", symbol2.MetadataName);
        Assert.Equal("Extensions.<>E__1<T>", symbol2.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionIndex_TwoExtensions_SameSignatures_02()
    {
        var src = """
public static class Extensions
{
    extension<T>(T) { }
    class C { }
    extension<T>(T) { }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension1 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().First();
        var symbol1 = model.GetDeclaredSymbol(extension1);
        var sourceExtension1 = symbol1.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__0`1", symbol1.MetadataName);
        Assert.Equal("Extensions.<>E__0<T>", symbol1.ToTestDisplayString());

        var extension2 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Last();
        var symbol2 = model.GetDeclaredSymbol(extension2);
        var sourceExtension2 = symbol2.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__2`1", symbol2.MetadataName);
        Assert.Equal("Extensions.<>E__2<T>", symbol2.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionIndex_TwoExtensions_SameSignatures_03()
    {
        var src = """
extension<T>(T) { }
class C { }
extension<T>(T) { }
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            // extension<T>(object) { }
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(1, 1),
            // (3,1): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            // extension<T>(object) { }
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(3, 1));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension1 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().First();
        var symbol1 = model.GetDeclaredSymbol(extension1);
        var sourceExtension1 = symbol1.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__0`1", symbol1.MetadataName);
        Assert.Equal("<>E__0<T>", symbol1.ToTestDisplayString());

        var extension2 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Last();
        var symbol2 = model.GetDeclaredSymbol(extension2);
        var sourceExtension2 = symbol2.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__2`1", symbol2.MetadataName);
        Assert.Equal("<>E__2<T>", symbol2.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionIndex_TwoExtensions_DifferentSignatures_01()
    {
        var src = """
public static class Extensions
{
    extension<T>(T) { }
    extension<T1, T2>((T1, T2) t) { }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension1 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().First();
        var symbol1 = model.GetDeclaredSymbol(extension1);
        var sourceExtension1 = symbol1.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__0`1", symbol1.MetadataName);
        Assert.Equal("Extensions.<>E__0<T>", symbol1.ToTestDisplayString());

        var extension2 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Last();
        var symbol2 = model.GetDeclaredSymbol(extension2);
        var sourceExtension2 = symbol2.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__1`2", symbol2.MetadataName);
        Assert.Equal("Extensions.<>E__1<T1, T2>", symbol2.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionIndex_TwoExtensions_DifferentSignatures_02()
    {
        var src = """
public static class Extensions
{
    extension<T>(T) { }
    extension<T1>(T1) where T1 : struct { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension1 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().First();
        var symbol1 = model.GetDeclaredSymbol(extension1);
        var sourceExtension1 = symbol1.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__0`1", symbol1.MetadataName);
        Assert.Equal("Extensions.<>E__0<T>", symbol1.ToTestDisplayString());

        var extension2 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Last();
        var symbol2 = model.GetDeclaredSymbol(extension2);
        var sourceExtension2 = symbol2.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__1`1", symbol2.MetadataName);
        Assert.Equal("Extensions.<>E__1<T1>", symbol2.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionIndex_ElevenExtensions()
    {
        var src = """
public static class Extensions
{
    extension<T1>(T1 o1) { }
    extension<T2>(T2 o2) { }
    extension<T3>(T3 o3) { }
    extension<T4>(T4 o4) { }
    extension<T5>(T5 o5) { }
    extension<T6>(T6 o6) { }
    extension<T7>(T7 o7) { }
    extension<T8>(T8 o8) { }
    extension<T9>(T9 o9) { }
    extension<T10>(T10 o10) { }
    extension<T11>(T11 o11) { }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Last();
        var symbol = model.GetDeclaredSymbol(extension);
        var sourceExtension = symbol.GetSymbol<SourceNamedTypeSymbol>();
        Assert.Equal("<>E__10`1", symbol.MetadataName);
        Assert.Equal("Extensions.<>E__10<T11>", symbol.ToTestDisplayString());
    }

    [Fact]
    public void Member_InstanceMethod()
    {
        var src = """
public static class Extensions
{
    extension(object o)
    {
        void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var verifier = CompileAndVerify(comp);

        VerifyTypeIL(verifier, "Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [netstandard]System.Object
{
    .custom instance void [netstandard]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [netstandard]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [netstandard]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2067
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method private hidebysig 
            instance void M () cil managed 
        {
            // Method begins at RVA 0x2069
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    // Methods
    .method private hidebysig specialname static 
        void M (
            object o
        ) cil managed 
    {
        .custom instance void [netstandard]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 1 (0x1)
        .maxstack 8
        IL_0000: ret
    } // end of method Extensions::M
} // end of class Extensions
""");

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(["M"], symbol.MemberNames);
        Assert.Equal(["", "M"], symbol.ContainingType.MemberNames);
        Assert.Equal("void Extensions.<>E__0.M()", symbol.GetMember("M").ToTestDisplayString());
    }

    [Fact]
    public void Member_ExtensionMethod()
    {
        var src = """
public static class Extensions
{
    extension(object o)
    {
        void M(this int i) { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,14): error CS1109: Extension methods must be defined in a top level static class;  is a nested class
            //         void M(this int i) { }
            Diagnostic(ErrorCode.ERR_ExtensionMethodsDecl, "M").WithArguments("").WithLocation(5, 14));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var method = tree.GetRoot().DescendantNodes().OfType<MethodDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(method);
        Assert.Equal("void Extensions.<>E__0.M(this System.Int32 i)", symbol.ToTestDisplayString());
        Assert.True(symbol.IsExtensionMethod);
    }

    [Fact]
    public void Member_StaticMethod()
    {
        var src = """
public static class Extensions
{
    extension(object)
    {
        static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var verifier = CompileAndVerify(comp);

        VerifyTypeIL(verifier, "Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [netstandard]System.Object
{
    .custom instance void [netstandard]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [netstandard]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object ''
            ) cil managed 
        {
            .custom instance void [netstandard]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2067
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method private hidebysig static 
            void M () cil managed 
        {
            // Method begins at RVA 0x2069
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    // Methods
    .method private hidebysig specialname static 
        void M () cil managed 
    {
        // Method begins at RVA 0x2067
        // Code size 1 (0x1)
        .maxstack 8
        IL_0000: ret
    } // end of method Extensions::M
} // end of class Extensions
""");

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(["M"], symbol.MemberNames);
        Assert.Equal("void Extensions.<>E__0.M()", symbol.GetMember("M").ToTestDisplayString());
    }

    [Fact]
    public void Member_InstanceMethod_ExplicitInterfaceImplementation()
    {
        var src = """
public interface I
{
    void M();
}

public static class Extensions
{
    extension(object o)
    {
        void I.M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (10,16): error CS0541: 'Extensions.extension(object).M()': explicit interface declaration can only be declared in a class, record, struct or interface
            //         void I.M() { }
            Diagnostic(ErrorCode.ERR_ExplicitInterfaceImplementationInNonClassOrStruct, "M").WithArguments("Extensions.extension(object).M()").WithLocation(10, 16));
    }

    [Fact]
    public void Member_InstanceMethod_ShadowingTypeParameter()
    {
        var src = """
public static class Extensions
{
    extension<T>(T o)
    {
        void M<T>() { }
        void M2(int T) { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,16): error CS9289: Type parameter 'T' has the same name as an extension container type parameter
            //         void M<T>() { }
            Diagnostic(ErrorCode.ERR_TypeParameterSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(5, 16),
            // (6,21): error CS9288: 'T': a parameter, local variable, or local function cannot have the same name as an extension container type parameter
            //         void M2(int T) { }
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(6, 21)
            );
    }

    [Fact]
    public void Member_InstanceProperty()
    {
        var src = """
public static class Extensions
{
    extension(object o)
    {
        int Property { get => 42; set { } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var verifier = CompileAndVerify(comp);

        VerifyTypeIL(verifier, "Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [netstandard]System.Object
{
    .custom instance void [netstandard]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [netstandard]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [netstandard]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x206b
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method private hidebysig specialname 
            instance int32 get_Property () cil managed 
        {
            // Method begins at RVA 0x206d
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::get_Property
        .method private hidebysig specialname 
            instance void set_Property (
                int32 'value'
            ) cil managed 
        {
            // Method begins at RVA 0x206d
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::set_Property
        // Properties
        .property instance int32 Property()
        {
            .get instance int32 Extensions/'<>E__0'::get_Property()
            .set instance void Extensions/'<>E__0'::set_Property(int32)
        }
    } // end of class <>E__0
    // Methods
    .method private hidebysig specialname static 
        int32 get_Property (
            object o
        ) cil managed 
    {
        // Method begins at RVA 0x2067
        // Code size 3 (0x3)
        .maxstack 8
        IL_0000: ldc.i4.s 42
        IL_0002: ret
    } // end of method Extensions::get_Property
    .method private hidebysig specialname static 
        void set_Property (
            object o,
            int32 'value'
        ) cil managed 
    {
        // Method begins at RVA 0x206b
        // Code size 1 (0x1)
        .maxstack 8
        IL_0000: ret
    } // end of method Extensions::set_Property
} // end of class Extensions
""");

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(["Property"], symbol.MemberNames);
        Assert.Equal("System.Int32 Extensions.<>E__0.Property { get; set; }", symbol.GetMember("Property").ToTestDisplayString());

        AssertEx.Equal([
            "void Extensions.<>E__0.<Extension>$(System.Object o)",
            "System.Int32 Extensions.<>E__0.Property { get; set; }",
            "System.Int32 Extensions.<>E__0.Property.get",
            "void Extensions.<>E__0.Property.set"],
            symbol.GetMembers().ToTestDisplayStrings());
    }

    [Fact]
    public void Member_InstanceProperty_Auto()
    {
        var src = """
public static class Extensions
{
    extension(object o)
    {
        int Property { get; set; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,13): error CS9282: Extension declarations can include only methods or properties
            //         int Property { get; set; }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "Property").WithLocation(5, 13));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(["Property"], symbol.MemberNames);
        Assert.Equal("System.Int32 Extensions.<>E__0.Property { get; set; }", symbol.GetMember("Property").ToTestDisplayString());

        AssertEx.Equal([
            "void Extensions.<>E__0.<Extension>$(System.Object o)",
            "System.Int32 Extensions.<>E__0.<Property>k__BackingField",
            "System.Int32 Extensions.<>E__0.Property { get; set; }",
            "System.Int32 Extensions.<>E__0.Property.get",
            "void Extensions.<>E__0.Property.set"],
            symbol.GetMembers().ToTestDisplayStrings());
    }

    [Fact]
    public void Member_InstanceProperty_ExplicitInterfaceImplementation()
    {
        var src = """
public interface I
{
    int Property { get; set; }
}
public static class Extensions
{
    extension(object o)
    {
        int I.Property { get => 42; set { } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (9,15): error CS0541: 'Extensions.extension(object).Property': explicit interface declaration can only be declared in a class, record, struct or interface
            //         int I.Property { get => 42; set { } }
            Diagnostic(ErrorCode.ERR_ExplicitInterfaceImplementationInNonClassOrStruct, "Property").WithArguments("Extensions.extension(object).Property").WithLocation(9, 15));
    }

    [Fact]
    public void Member_StaticProperty()
    {
        var src = """
public static class Extensions
{
    extension(object)
    {
        static int Property { get => 42; set { } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var verifier = CompileAndVerify(comp);

        VerifyTypeIL(verifier, "Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
extends [netstandard]System.Object
{
    .custom instance void [netstandard]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [netstandard]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object ''
            ) cil managed 
        {
            .custom instance void [netstandard]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x206b
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method private hidebysig specialname static 
            int32 get_Property () cil managed 
        {
            // Method begins at RVA 0x206d
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::get_Property
        .method private hidebysig specialname static 
            void set_Property (
                int32 'value'
            ) cil managed 
        {
            // Method begins at RVA 0x206d
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::set_Property
        // Properties
        .property int32 Property()
        {
            .get int32 Extensions/'<>E__0'::get_Property()
            .set void Extensions/'<>E__0'::set_Property(int32)
        }
    } // end of class <>E__0
    // Methods
    .method private hidebysig specialname static 
        int32 get_Property () cil managed 
    {
        // Method begins at RVA 0x2067
        // Code size 3 (0x3)
        .maxstack 8
        IL_0000: ldc.i4.s 42
        IL_0002: ret
    } // end of method Extensions::get_Property
    .method private hidebysig specialname static 
        void set_Property (
            int32 'value'
        ) cil managed 
    {
        // Method begins at RVA 0x206b
        // Code size 1 (0x1)
        .maxstack 8
        IL_0000: ret
    } // end of method Extensions::set_Property
} // end of class Extensions
""");

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(["Property"], symbol.MemberNames);
        Assert.Equal("System.Int32 Extensions.<>E__0.Property { get; set; }", symbol.GetMember("Property").ToTestDisplayString());
    }

    [Fact]
    public void Member_StaticProperty_Auto()
    {
        var src = """
public static class Extensions
{
    extension(object)
    {
        static int Property { get; set; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,20): error CS9282: Extension declarations can include only methods or properties
            //         static int Property { get; set; }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "Property").WithLocation(5, 20));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(["Property"], symbol.MemberNames);
        AssertEx.Equal([
            "void Extensions.<>E__0.<Extension>$(System.Object)",
            "System.Int32 Extensions.<>E__0.<Property>k__BackingField",
            "System.Int32 Extensions.<>E__0.Property { get; set; }",
            "System.Int32 Extensions.<>E__0.Property.get",
            "void Extensions.<>E__0.Property.set"],
            symbol.GetMembers().ToTestDisplayStrings());

        Assert.Equal("System.Int32 Extensions.<>E__0.Property { get; set; }", symbol.GetMember("Property").ToTestDisplayString());
    }

    [Fact]
    public void Member_InstanceIndexer()
    {
        var src = """
public static class Extensions
{
    extension(object o)
    {
        int this[int i] { get => 42; set { } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var verifier = CompileAndVerify(comp);

        VerifyTypeIL(verifier, "Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [netstandard]System.Object
{
    .custom instance void [netstandard]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [netstandard]System.Object
    {
        .custom instance void [netstandard]System.Reflection.DefaultMemberAttribute::.ctor(string) = (
            01 00 04 49 74 65 6d 00 00
        )
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [netstandard]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x206b
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method private hidebysig specialname 
            instance int32 get_Item (
                int32 i
            ) cil managed 
        {
            // Method begins at RVA 0x206d
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::get_Item
        .method private hidebysig specialname 
            instance void set_Item (
                int32 i,
                int32 'value'
            ) cil managed 
        {
            // Method begins at RVA 0x206d
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::set_Item
        // Properties
        .property instance int32 Item(
            int32 i
        )
        {
            .get instance int32 Extensions/'<>E__0'::get_Item(int32)
            .set instance void Extensions/'<>E__0'::set_Item(int32, int32)
        }
    } // end of class <>E__0
    // Methods
    .method private hidebysig specialname static 
        int32 get_Item (
            object o,
            int32 i
        ) cil managed 
    {
        // Method begins at RVA 0x2067
        // Code size 3 (0x3)
        .maxstack 8
        IL_0000: ldc.i4.s 42
        IL_0002: ret
    } // end of method Extensions::get_Item
    .method private hidebysig specialname static 
        void set_Item (
            object o,
            int32 i,
            int32 'value'
        ) cil managed 
    {
        // Method begins at RVA 0x206b
        // Code size 1 (0x1)
        .maxstack 8
        IL_0000: ret
    } // end of method Extensions::set_Item
} // end of class Extensions
""");

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Equal(["this[]"], symbol.MemberNames);
        Assert.Equal("System.Int32 Extensions.<>E__0.this[System.Int32 i] { get; set; }", symbol.GetMember("this[]").ToTestDisplayString());

        AssertEx.Equal([
            "void Extensions.<>E__0.<Extension>$(System.Object o)",
            "System.Int32 Extensions.<>E__0.this[System.Int32 i] { get; set; }",
            "System.Int32 Extensions.<>E__0.this[System.Int32 i].get",
            "void Extensions.<>E__0.this[System.Int32 i].set"],
            symbol.GetMembers().ToTestDisplayStrings());

        var comp5 = CreateCompilation(src);
        comp5.MakeMemberMissing(WellKnownMember.System_Runtime_CompilerServices_ExtensionAttribute__ctor);
        comp5.VerifyEmitDiagnostics(
            // (3,5): error CS1110: Cannot define a new extension because the compiler required type 'System.Runtime.CompilerServices.ExtensionAttribute' cannot be found. Are you missing a reference to System.Core.dll?
            //     extension(object o)
            Diagnostic(ErrorCode.ERR_ExtensionAttrNotFound, "extension").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(3, 5)
            );
    }

    [Fact]
    public void Member_StaticIndexer()
    {
        var src = """
public static class Extensions
{
    extension(object o)
    {
        static int this[int i] { get => 42; set { } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.MakeMemberMissing(WellKnownMember.System_Runtime_CompilerServices_ExtensionAttribute__ctor);
        comp.VerifyEmitDiagnostics(
            // (3,5): error CS1110: Cannot define a new extension because the compiler required type 'System.Runtime.CompilerServices.ExtensionAttribute' cannot be found. Are you missing a reference to System.Core.dll?
            //     extension(object o)
            Diagnostic(ErrorCode.ERR_ExtensionAttrNotFound, "extension").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(3, 5),
            // (5,20): error CS0106: The modifier 'static' is not valid for this item
            //         static int this[int i] { get => 42; set { } }
            Diagnostic(ErrorCode.ERR_BadMemberFlag, "this").WithArguments("static").WithLocation(5, 20)
            );
    }

    [Fact]
    public void Member_Type()
    {
        var src = """
public static class Extensions
{
    extension(object)
    {
        class Nested { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,15): error CS9282: Extension declarations can include only methods or properties
            //         class Nested { }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "Nested").WithLocation(5, 15));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        Assert.Empty(symbol.MemberNames);
        Assert.Equal(["void Extensions.<>E__0.<Extension>$(System.Object)", "Extensions.<>E__0.Nested"], symbol.GetMembers().ToTestDisplayStrings());
        Assert.Equal(["Extensions.<>E__0.Nested"], symbol.GetTypeMembers().ToTestDisplayStrings());
        Assert.Equal("Extensions.<>E__0.Nested", symbol.GetTypeMember("Nested").ToTestDisplayString());
    }

    [Fact]
    public void Member_Constructor()
    {
        var src = """
public static class Extensions
{
    extension(object) { Extensions() { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,25): error CS1520: Method must have a return type
            //     extension(object) { Extensions() { } }
            Diagnostic(ErrorCode.ERR_MemberNeedsType, "Extensions").WithLocation(3, 25),
            // (3,25): error CS9282: Extension declarations can include only methods or properties
            //     extension(object) { Extensions() { } }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "Extensions").WithLocation(3, 25));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        AssertExtensionDeclaration(symbol);

        Assert.Equal([".ctor"], symbol.MemberNames);
        Assert.Equal(["Extensions.<>E__0..ctor()"], symbol.InstanceConstructors.ToTestDisplayStrings());
        Assert.Empty(symbol.StaticConstructors);
        Assert.Equal(["Extensions.<>E__0..ctor()"], symbol.Constructors.ToTestDisplayStrings());
    }

    [Fact]
    public void Member_Finalizer()
    {
        var src = """
public static class Extensions
{
    extension(object) { ~Extensions() { } }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,26): error CS9282: Extension declarations can include only methods or properties
            //     extension(object) { ~Extensions() { } }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "Extensions").WithLocation(3, 26));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        AssertExtensionDeclaration(symbol);

        Assert.Equal(["Finalize"], symbol.MemberNames);
        Assert.Equal(["void Extensions.<>E__0.<Extension>$(System.Object)", "void Extensions.<>E__0.Finalize()"], symbol.GetMembers().ToTestDisplayStrings());
    }

    [Fact]
    public void Member_Field()
    {
        var src = """
_ = new object().field;

public static class Extensions
{
    extension(object o) { int field = 0; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,18): error CS1061: 'object' does not contain a definition for 'field' and no accessible extension method 'field' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // _ = new object().field;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "field").WithArguments("object", "field").WithLocation(1, 18),
            // (5,31): error CS9282: Extension declarations can include only methods or properties
            //     extension(object o) { int field = 0; }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "field").WithLocation(5, 31),
            // (5,31): warning CS0169: The field 'Extensions.extension(object).field' is never used
            //     extension(object o) { int field = 0; }
            Diagnostic(ErrorCode.WRN_UnreferencedField, "field").WithArguments("Extensions.extension(object).field").WithLocation(5, 31));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        AssertExtensionDeclaration(symbol);

        Assert.Equal(["field"], symbol.MemberNames);
        Assert.Equal(["void Extensions.<>E__0.<Extension>$(System.Object o)", "System.Int32 Extensions.<>E__0.field"], symbol.GetMembers().ToTestDisplayStrings());
    }

    [Fact]
    public void Member_Const()
    {
        var src = """
public static class Extensions
{
    extension(object) { const int i = 0; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,35): error CS9282: Extension declarations can include only methods or properties
            //     extension(object) { const int i = 0; }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "i").WithLocation(3, 35));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extension);
        AssertExtensionDeclaration(symbol);

        Assert.Equal(["i"], symbol.MemberNames);
        Assert.Equal(["void Extensions.<>E__0.<Extension>$(System.Object)", "System.Int32 Extensions.<>E__0.i"], symbol.GetMembers().ToTestDisplayStrings());
    }

    [Fact]
    public void Member_InstanceEvent_ExplicitInterfaceImplementation()
    {
        var src = """
public interface I
{
    event System.Action E;
}
public static class Extensions
{
    extension(object o)
    {
        event System.Action I.E { add { } remove { } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (9,31): error CS0541: 'Extensions.extension(object).E': explicit interface declaration can only be declared in a class, record, struct or interface
            //         event System.Action I.E { add { } remove { } }
            Diagnostic(ErrorCode.ERR_ExplicitInterfaceImplementationInNonClassOrStruct, "E").WithArguments("Extensions.extension(object).E").WithLocation(9, 31),
            // (9,31): error CS9282: Extension declarations can include only methods or properties
            //         event System.Action I.E { add { } remove { } }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "E").WithLocation(9, 31),
            // (9,35): error CS9282: Extension declarations can include only methods or properties
            //         event System.Action I.E { add { } remove { } }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "add").WithLocation(9, 35),
            // (9,43): error CS9282: Extension declarations can include only methods or properties
            //         event System.Action I.E { add { } remove { } }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "remove").WithLocation(9, 43));
    }

    [Theory]
    [InlineData("class")]
    [InlineData("struct")]
    [InlineData("interface")]
    [InlineData("record")]
    [InlineData("record struct")]
    public void IsExtension_MiscTypeKinds(string typeKind)
    {
        var src = $$"""
{{typeKind}} C { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type = tree.GetRoot().DescendantNodes().OfType<TypeDeclarationSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(type);
        Assert.False(symbol.IsExtension);
    }

    [Fact]
    public void IsExtension_Delegate()
    {
        var src = $$"""
delegate void C();
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type = tree.GetRoot().DescendantNodes().OfType<DelegateDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(type);
        Assert.False(symbol.IsExtension);
    }

    [Fact]
    public void IsExtension_Enum()
    {
        var src = $$"""
enum E { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type = tree.GetRoot().DescendantNodes().OfType<EnumDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(type);
        Assert.False(symbol.IsExtension);
    }

    [Fact]
    public void Attributes_01()
    {
        var src = """
public static class Extensions
{
    [System.Obsolete]
    extension(object) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,6): error CS0592: Attribute 'System.Obsolete' is not valid on this declaration type. It is only valid on 'class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate' declarations.
            //     [System.Obsolete]
            Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "System.Obsolete").WithArguments("System.Obsolete", "class, struct, enum, constructor, method, property, indexer, field, event, interface, delegate").WithLocation(3, 6));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(type);
        AssertEx.SetEqual(["System.ObsoleteAttribute"], symbol.GetAttributes().Select(a => a.ToString()));
    }

    [Fact]
    public void Attributes_02()
    {
        var src = """
public static class Extensions
{
    [My(nameof(o)), My(nameof(Extensions))]
    extension(object o) { }
}

public class MyAttribute : System.Attribute
{
    public MyAttribute(string s) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,6): error CS0592: Attribute 'My' is not valid on this declaration type. It is only valid on 'assembly, module, class, struct, enum, constructor, method, property, indexer, field, event, interface, parameter, delegate, return, type parameter' declarations.
            //     [My(nameof(o)), My(nameof(Extensions))]
            Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "My").WithArguments("My", "assembly, module, class, struct, enum, constructor, method, property, indexer, field, event, interface, parameter, delegate, return, type parameter").WithLocation(3, 6),
            // (3,21): error CS0579: Duplicate 'My' attribute
            //     [My(nameof(o)), My(nameof(Extensions))]
            Diagnostic(ErrorCode.ERR_DuplicateAttribute, "My").WithArguments("My").WithLocation(3, 21)
            );
    }

    [Fact]
    public void ReceiverParameter()
    {
        var src = """
public static class Extensions
{
    extension(object) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(type);
        Assert.Equal("System.Object", symbol.ExtensionParameter.ToTestDisplayString());
    }

    [Fact]
    public void ReceiverParameter_WithIdentifier()
    {
        var src = """
public static class Extensions
{
    extension(object o) 
    {
        public object M() { return o; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(type);
        Assert.Equal("System.Object o", symbol.ExtensionParameter.ToTestDisplayString());

        var returnStatement = GetSyntax<ReturnStatementSyntax>(tree, "return o;");
        Assert.Equal("System.Object o", model.GetSymbolInfo(returnStatement.Expression).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ReceiverParameter_Multiple()
    {
        var src = """
public static class Extensions
{
    extension(int i, int j, C c) { }
}
class C { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,22): error CS9285: An extension container can have only one receiver parameter
            //     extension(int i, int j, C c) { }
            Diagnostic(ErrorCode.ERR_ReceiverParameterOnlyOne, "int j").WithLocation(3, 22),
            // (3,29): error CS9285: An extension container can have only one receiver parameter
            //     extension(int i, int j, C c) { }
            Diagnostic(ErrorCode.ERR_ReceiverParameterOnlyOne, "C c").WithLocation(3, 29));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(type);
        var extensionParameter = symbol.ExtensionParameter;

        Assert.Equal("System.Int32 i", extensionParameter.ToTestDisplayString());
        Assert.True(extensionParameter.Equals(extensionParameter));

        var parameterSyntaxes = tree.GetRoot().DescendantNodes().OfType<ParameterSyntax>().ToArray();
        Assert.Equal("System.Int32 i", model.GetDeclaredSymbol(parameterSyntaxes[0]).ToTestDisplayString());
        Assert.Same(extensionParameter, model.GetDeclaredSymbol(parameterSyntaxes[0]));

        Assert.Equal("System.Int32", model.GetTypeInfo(parameterSyntaxes[1].Type).Type.ToTestDisplayString());
        Assert.Null(model.GetDeclaredSymbol(parameterSyntaxes[1]));

        Assert.Equal("C", model.GetTypeInfo(parameterSyntaxes[2].Type).Type.ToTestDisplayString());
        Assert.Null(model.GetDeclaredSymbol(parameterSyntaxes[2]));
    }

    [Fact]
    public void ReceiverParameter_Multiple_MissingType()
    {
        var src = """
public static class Extensions
{
    extension(int i, Type) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,22): error CS9285: An extension container can have only one receiver parameter
            //     extension(int i, Type) { }
            Diagnostic(ErrorCode.ERR_ReceiverParameterOnlyOne, "Type").WithLocation(3, 22));
    }

    [Fact]
    public void ReceiverParameter_TypeParameter_Found()
    {
        var src = """
public static class Extensions
{
    extension<T>(T) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(type);
        var extensionParameter = symbol.ExtensionParameter;
        Assert.Equal("T", extensionParameter.ToTestDisplayString());
        Assert.Same(extensionParameter.Type, symbol.TypeParameters[0]);
    }

    [Fact]
    public void ReceiverParameter_TypeParameter_Found_FromContainingType()
    {
        var src = """
public static class Extensions<T>
{
    extension(T) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,5): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            //     extension(T) { }
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(3, 5));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(type);
        var extensionParameter = symbol.ExtensionParameter;
        Assert.Equal("T", extensionParameter.ToTestDisplayString());
        Assert.Same(extensionParameter.Type, symbol.ContainingType.TypeParameters[0]);
    }

    [Fact]
    public void ReceiverParameter_TypeParameter_Missing()
    {
        var src = """
public static class Extensions
{
    extension(T)
    {
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS0246: The type or namespace name 'T' could not be found (are you missing a using directive or an assembly reference?)
            //     extension(T)
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "T").WithArguments("T").WithLocation(3, 15));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(type);
        var parameter = symbol.ExtensionParameter;
        Assert.Equal("T", parameter.ToTestDisplayString());
        Assert.True(parameter.Type.IsErrorType());
    }

    [Fact]
    public void ReceiverParameter_TypeParameter_Unreferenced_01()
    {
        var src = """
int.M();

public static class Extensions
{
    extension<T>(int) 
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS1061: 'int' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'int' could be found (are you missing a using directive or an assembly reference?)
            // int.M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("int", "M").WithLocation(1, 5),
            // (5,18): error CS9295: The extended type 'int' must reference all the type parameters declared by the extension, but type parameter 'T' is not referenced.
            //     extension<T>(int) 
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "int").WithArguments("int", "T").WithLocation(5, 18));
    }

    [Fact]
    public void ReceiverParameter_TypeParameter_Unreferenced_02()
    {
        var src = """
int.M();

public static class Extensions
{
    extension<T1, T2>(T1) 
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS1061: 'int' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'int' could be found (are you missing a using directive or an assembly reference?)
            // int.M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("int", "M").WithLocation(1, 5),
            // (5,23): error CS9295: The extended type 'T1' must reference all the type parameters declared by the extension, but type parameter 'T2' is not referenced.
            //     extension<T1, T2>(T1) 
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "T1").WithArguments("T1", "T2").WithLocation(5, 23));
    }

    [Fact]
    public void ReceiverParameter_TypeParameter_Unreferenced_03()
    {
        var src = """
int.M();

public static class Extensions
{
    extension<T1, T2>(T1) where T1 : class
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS1061: 'int' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'int' could be found (are you missing a using directive or an assembly reference?)
            // int.M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("int", "M").WithLocation(1, 5),
            // (5,23): error CS9295: The extended type 'T1' must reference all the type parameters declared by the extension, but type parameter 'T2' is not referenced.
            //     extension<T1, T2>(T1) where T1 : class
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "T1").WithArguments("T1", "T2").WithLocation(5, 23));
    }

    [Fact]
    public void ReceiverParameter_TypeParameter_Missing_Local()
    {
        var src = """
public static class Extensions
{
    extension(T)
    {
        void T() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS0246: The type or namespace name 'T' could not be found (are you missing a using directive or an assembly reference?)
            //     extension(T)
            Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "T").WithArguments("T").WithLocation(3, 15));
    }

    [Fact]
    public void ReceiverParameter_Params()
    {
        var src = """
public static class Extensions
{
    extension(params int[] i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS1670: params is not valid in this context
            //     extension(params int[] i) { }
            Diagnostic(ErrorCode.ERR_IllegalParams, "params").WithLocation(3, 15));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type1 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().First();
        var symbol1 = model.GetDeclaredSymbol(type1);
        var parameter = symbol1.ExtensionParameter;
        Assert.Equal("System.Int32[] i", parameter.ToTestDisplayString());
        Assert.False(parameter.IsParams);
    }

    [Fact]
    public void ReceiverParameter_Params_BadType()
    {
        var src = """
public static class Extensions
{
    extension(params int i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS1670: params is not valid in this context
            //     extension(params int i) { }
            Diagnostic(ErrorCode.ERR_IllegalParams, "params").WithLocation(3, 15));
    }

    [Fact]
    public void ReceiverParameter_Params_NotLast()
    {
        var src = """
public static class Extensions
{
    extension(params int[] i, int j) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS1670: params is not valid in this context
            //     extension(params int[] i, int j) { }
            Diagnostic(ErrorCode.ERR_IllegalParams, "params").WithLocation(3, 15),
            // (3,31): error CS9285: An extension container can have only one receiver parameter
            //     extension(params int[] i, int j) { }
            Diagnostic(ErrorCode.ERR_ReceiverParameterOnlyOne, "int j").WithLocation(3, 31));
    }

    [Fact]
    public void ReceiverParameter_ParameterTypeViolatesConstraint()
    {
        var src = """
public static class Extensions
{
    extension<T>(C<T>) { }
    extension<T2>(C<T2>) where T2 : struct { }
}

public class C<T> where T : struct { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,18): error CS0453: The type 'T' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'C<T>'
            //     extension<T>(C<T>) { }
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "C<T>").WithArguments("C<T>", "T", "T").WithLocation(3, 18));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type1 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().First();
        var symbol1 = model.GetDeclaredSymbol(type1);
        Assert.Equal("C<T>", symbol1.ExtensionParameter.ToTestDisplayString());
    }

    [Fact]
    public void ReceiverParameter_DefaultValue()
    {
        var src = """
public static class Extensions
{
    extension(int i = 0) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS9284: The receiver parameter of an extension cannot have a default value
            //     extension(int i = 0) { }
            Diagnostic(ErrorCode.ERR_ExtensionParameterDisallowsDefaultValue, "int i = 0").WithLocation(3, 15));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(type);
        Assert.True(symbol.ExtensionParameter.HasExplicitDefaultValue); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : consider not recognizing the default value entirely
    }

    [Fact]
    public void ReceiverParameter_DefaultValue_BeforeAnotherParameter()
    {
        var src = """
public static class Extensions
{
    extension(int i = 0, object) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS9284: The receiver parameter of an extension cannot have a default value
            //     extension(int i = 0, object) { }
            Diagnostic(ErrorCode.ERR_ExtensionParameterDisallowsDefaultValue, "int i = 0").WithLocation(3, 15),
            // (3,26): error CS9285: An extension container can have only one receiver parameter
            //     extension(int i = 0, object) { }
            Diagnostic(ErrorCode.ERR_ReceiverParameterOnlyOne, "object").WithLocation(3, 26));
    }

    [Fact]
    public void ReceiverParameter_DefaultValue_BadValue()
    {
        var src = """
public static class Extensions
{
    extension(int i = null) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS9284: The receiver parameter of an extension cannot have a default value
            //     extension(int i = null) { }
            Diagnostic(ErrorCode.ERR_ExtensionParameterDisallowsDefaultValue, "int i = null").WithLocation(3, 15));
    }

    [Fact]
    public void ReceiverParameter_DefaultValue_RefReadonly()
    {
        var src = """
public static class Extensions
{
    extension(ref readonly int x = 2) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS9284: The receiver parameter of an extension cannot have a default value
            //     extension(ref readonly int x = 2) { }
            Diagnostic(ErrorCode.ERR_ExtensionParameterDisallowsDefaultValue, "ref readonly int x = 2").WithLocation(3, 15));
    }

    [Fact]
    public void ReceiverParameter_Attributes_01()
    {
        var src = """
public static class Extensions
{
    extension([System.Runtime.InteropServices.DefaultParameterValue(1)] int o = 2) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS9284: The receiver parameter of an extension cannot have a default value
            //     extension([System.Runtime.InteropServices.DefaultParameterValue(1)] int o = 2) { }
            Diagnostic(ErrorCode.ERR_ExtensionParameterDisallowsDefaultValue, "[System.Runtime.InteropServices.DefaultParameterValue(1)] int o = 2").WithLocation(3, 15),
            // (3,16): error CS1745: Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute
            //     extension([System.Runtime.InteropServices.DefaultParameterValue(1)] int o = 2) { }
            Diagnostic(ErrorCode.ERR_DefaultValueUsedWithAttributes, "System.Runtime.InteropServices.DefaultParameterValue").WithLocation(3, 16));
    }

    [Fact]
    public void ReceiverParameter_Attributes_02()
    {
        var src = """
public static class Extensions
{
    extension([System.Runtime.InteropServices.Optional, System.Runtime.InteropServices.DefaultParameterValue(1)] ref readonly int i) { }
    extension([System.Runtime.InteropServices.Optional, System.Runtime.InteropServices.DefaultParameterValue(2)] ref readonly int) { }
}
""";
        var comp = CreateCompilation(src);
        // Note: we use "" name in the diagnostic for the second parameter
        // Note: these attributes are allowed on the receiver parameter of an extension method
        comp.VerifyEmitDiagnostics(
            // (3,57): warning CS9200: A default value is specified for 'ref readonly' parameter 'i', but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.
            //     extension([System.Runtime.InteropServices.Optional, System.Runtime.InteropServices.DefaultParameterValue(1)] ref readonly int i) { }
            Diagnostic(ErrorCode.WRN_RefReadonlyParameterDefaultValue, "System.Runtime.InteropServices.DefaultParameterValue(1)").WithArguments("i").WithLocation(3, 57),
            // (4,57): warning CS9200: A default value is specified for 'ref readonly' parameter '', but 'ref readonly' should be used only for references. Consider declaring the parameter as 'in'.
            //     extension([System.Runtime.InteropServices.Optional, System.Runtime.InteropServices.DefaultParameterValue(2)] ref readonly int) { }
            Diagnostic(ErrorCode.WRN_RefReadonlyParameterDefaultValue, "System.Runtime.InteropServices.DefaultParameterValue(2)").WithArguments("").WithLocation(4, 57));
    }

    [Fact]
    public void ReceiverParameter_Attributes_03()
    {
        var src = """
public static class Extensions
{
    extension([System.Runtime.CompilerServices.ParamCollectionAttribute] int[] xs) { }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net90);
        comp.VerifyEmitDiagnostics(
            // (3,16): error CS0674: Do not use 'System.ParamArrayAttribute'/'System.Runtime.CompilerServices.ParamCollectionAttribute'. Use the 'params' keyword instead.
            //     extension([System.Runtime.CompilerServices.ParamCollectionAttribute] int[] xs) { }
            Diagnostic(ErrorCode.ERR_ExplicitParamArrayOrCollection, "System.Runtime.CompilerServices.ParamCollectionAttribute").WithLocation(3, 16));
    }

    [Fact]
    public void ReceiverParameter_Attributes_04()
    {
        var src = """
public static class Extensions
{
    extension([System.Runtime.CompilerServices.CallerLineNumber] int x = 2) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS9284: The receiver parameter of an extension cannot have a default value
            //     extension([System.Runtime.CompilerServices.CallerLineNumber] int x = 2) { }
            Diagnostic(ErrorCode.ERR_ExtensionParameterDisallowsDefaultValue, "[System.Runtime.CompilerServices.CallerLineNumber] int x = 2").WithLocation(3, 15));
    }

    [Fact]
    public void ReceiverParameter_Attributes_54()
    {
        var src = """
public static class Extensions
{
    extension([System.Runtime.CompilerServices.CallerLineNumber] int x) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,16): error CS4020: The CallerLineNumberAttribute may only be applied to parameters with default values
            //     extension([System.Runtime.CompilerServices.CallerLineNumber] int x) { }
            Diagnostic(ErrorCode.ERR_BadCallerLineNumberParamWithoutDefaultValue, "System.Runtime.CompilerServices.CallerLineNumber").WithLocation(3, 16));
    }

    [Fact]
    public void ReceiverParameter_Attributes_06()
    {
        var src = """
public static class Extensions
{
    extension([My] int x) { }
}
public class MyAttribute : System.Attribute { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var parameter = tree.GetRoot().DescendantNodes().OfType<ParameterSyntax>().Single();
        var parameterSymbol = model.GetDeclaredSymbol(parameter);
        Assert.Equal("System.Int32 x", parameterSymbol.ToTestDisplayString());
        AssertEx.SetEqual(["MyAttribute"], parameterSymbol.GetAttributes().Select(a => a.ToString()));

        var type = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var extensionSymbol = model.GetDeclaredSymbol(type);
        AssertEx.SetEqual(["MyAttribute"], extensionSymbol.ExtensionParameter.GetAttributes().Select(a => a.ToString()));
    }

    [Fact]
    public void ReceiverParameter_This_01()
    {
        var src = """
public static class Extensions
{
    extension(this int i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS0027: Keyword 'this' is not available in the current context
            //     extension(this int i) { }
            Diagnostic(ErrorCode.ERR_ThisInBadContext, "this").WithLocation(3, 15));
    }

    [Fact]
    public void ReceiverParameter_This_02()
    {
        var src = """
public static class Extensions
{
    extension(int i, this int j) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,22): error CS9285: An extension container can have only one receiver parameter
            //     extension(int i, this int j) { }
            Diagnostic(ErrorCode.ERR_ReceiverParameterOnlyOne, "this int j").WithLocation(3, 22));
    }

    [Fact]
    public void ReceiverParameter_This_03()
    {
        var src = """
public static class Extensions
{
    extension(this this int i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,20): error CS1107: A parameter can only have one 'this' modifier
            //     extension(this this int i) { }
            Diagnostic(ErrorCode.ERR_DupParamMod, "this").WithArguments("this").WithLocation(3, 20),
            // (3,20): error CS0027: Keyword 'this' is not available in the current context
            //     extension(this this int i) { }
            Diagnostic(ErrorCode.ERR_ThisInBadContext, "this").WithLocation(3, 20));
    }

    [Fact]
    public void ReceiverParameter_Ref_01()
    {
        var src = """
int i = 42;
i.M();
System.Console.Write(i);

public static class Extensions
{
    extension(ref int i) 
    {
        public void M() { System.Console.Write(i); i = 43; }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "4243").VerifyDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_Ref_02()
    {
        var src = """
public static class Extensions
{
    extension(ref ref int i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,19): error CS1107: A parameter can only have one 'ref' modifier
            //     extension(ref ref int i) { }
            Diagnostic(ErrorCode.ERR_DupParamMod, "ref").WithArguments("ref").WithLocation(3, 19));
    }

    [Fact]
    public void ReceiverParameter_Out_01()
    {
        var src = """
public static class Extensions
{
    extension(out int i)
    {
        void M2() { }
        static void M3() { }
    }
    static void M(this out int i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS8328:  The parameter modifier 'out' cannot be used with 'extension'
            //     extension(out int i)
            Diagnostic(ErrorCode.ERR_BadParameterModifiers, "out").WithArguments("out", "extension").WithLocation(3, 15),
            // (5,14): error CS0177: The out parameter 'i' must be assigned to before control leaves the current method
            //         void M2() { }
            Diagnostic(ErrorCode.ERR_ParamUnassigned, "M2").WithArguments("i").WithLocation(5, 14),
            // (8,17): error CS0177: The out parameter 'i' must be assigned to before control leaves the current method
            //     static void M(this out int i) { }
            Diagnostic(ErrorCode.ERR_ParamUnassigned, "M").WithArguments("i").WithLocation(8, 17),
            // (8,24): error CS8328:  The parameter modifier 'out' cannot be used with 'this'
            //     static void M(this out int i) { }
            Diagnostic(ErrorCode.ERR_BadParameterModifiers, "out").WithArguments("out", "this").WithLocation(8, 24));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type1 = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().First();
        var symbol1 = model.GetDeclaredSymbol(type1);
        var parameter = symbol1.ExtensionParameter;
        Assert.Equal("out System.Int32 i", parameter.ToTestDisplayString());
        Assert.Equal(RefKind.Out, parameter.RefKind);
    }

    [Fact]
    public void ReceiverParameter_Out_02()
    {
        var src = """
public static class Extensions
{
    extension(int i, out int j) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,22): error CS9285: An extension container can have only one receiver parameter
            //     extension(int i, out int j) { }
            Diagnostic(ErrorCode.ERR_ReceiverParameterOnlyOne, "out int j").WithLocation(3, 22));
    }

    [Fact]
    public void ReceiverParameter_Out_03()
    {
        var src = """
public static class Extensions
{
    extension(out out int i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS8328:  The parameter modifier 'out' cannot be used with 'extension'
            //     extension(out out int i) { }
            Diagnostic(ErrorCode.ERR_BadParameterModifiers, "out").WithArguments("out", "extension").WithLocation(3, 15),
            // (3,19): error CS8328:  The parameter modifier 'out' cannot be used with 'extension'
            //     extension(out out int i) { }
            Diagnostic(ErrorCode.ERR_BadParameterModifiers, "out").WithArguments("out", "extension").WithLocation(3, 19));
    }

    [Fact]
    public void ReceiverParameter_Out_04()
    {
        var src = """
public static class Extensions
{
    extension(out int i)
    {
        void M2(bool b) { if (b) return; else return; }
    }
    static void M(this out int i, bool b) { if (b) return; else return; }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS8328:  The parameter modifier 'out' cannot be used with 'extension'
            //     extension(out int i)
            Diagnostic(ErrorCode.ERR_BadParameterModifiers, "out").WithArguments("out", "extension").WithLocation(3, 15),
            // (5,34): error CS0177: The out parameter 'i' must be assigned to before control leaves the current method
            //         void M2(bool b) { if (b) return; else return; }
            Diagnostic(ErrorCode.ERR_ParamUnassigned, "return;").WithArguments("i").WithLocation(5, 34),
            // (5,47): error CS0177: The out parameter 'i' must be assigned to before control leaves the current method
            //         void M2(bool b) { if (b) return; else return; }
            Diagnostic(ErrorCode.ERR_ParamUnassigned, "return;").WithArguments("i").WithLocation(5, 47),
            // (7,24): error CS8328:  The parameter modifier 'out' cannot be used with 'this'
            //     static void M(this out int i, bool b) { if (b) return; else return; }
            Diagnostic(ErrorCode.ERR_BadParameterModifiers, "out").WithArguments("out", "this").WithLocation(7, 24),
            // (7,52): error CS0177: The out parameter 'i' must be assigned to before control leaves the current method
            //     static void M(this out int i, bool b) { if (b) return; else return; }
            Diagnostic(ErrorCode.ERR_ParamUnassigned, "return;").WithArguments("i").WithLocation(7, 52),
            // (7,65): error CS0177: The out parameter 'i' must be assigned to before control leaves the current method
            //     static void M(this out int i, bool b) { if (b) return; else return; }
            Diagnostic(ErrorCode.ERR_ParamUnassigned, "return;").WithArguments("i").WithLocation(7, 65));
    }

    [Fact]
    public void ReceiverParameter_Out_05()
    {
        var src = """
public static class Extensions
{
    extension(out int i)
    {
        void M2(bool b) { i = 0; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS8328:  The parameter modifier 'out' cannot be used with 'extension'
            //     extension(out int i)
            Diagnostic(ErrorCode.ERR_BadParameterModifiers, "out").WithArguments("out", "extension").WithLocation(3, 15));
    }

    [Fact]
    public void ReceiverParameter_In_01()
    {
        var src = """
public static class Extensions
{
    extension(in int i) { }
    static void M(this in int i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_In_02()
    {
        var src = """
public static class Extensions
{
    extension(in in int i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,18): error CS1107: A parameter can only have one 'in' modifier
            //     extension(in in int i) { }
            Diagnostic(ErrorCode.ERR_DupParamMod, "in").WithArguments("in").WithLocation(3, 18));
    }

    [Fact]
    public void ReceiverParameter_RefReadonly()
    {
        var src = """
int i = 42;
i.M();

public static class Extensions
{
    extension(ref readonly int i) 
    {
        public void M() { System.Console.Write(i); }
    }
    extension(ref readonly int) { }
    static void M2(this ref readonly int i) { }
}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp, symbolValidator: (m) =>
        {
            Assert.Equal(RefKind.RefReadOnlyParameter, m.GlobalNamespace.GetMember<MethodSymbol>("Extensions.<>E__0.<Extension>$").Parameters[0].RefKind);
            Assert.Equal(RefKind.RefReadOnlyParameter, m.GlobalNamespace.GetMember<MethodSymbol>("Extensions.<>E__1.<Extension>$").Parameters[0].RefKind);
        }, expectedOutput: "42").VerifyDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_ReadonlyRef()
    {
        var src = """
public static class Extensions
{
    extension(readonly ref int i) { }
    static void M(this readonly ref int i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS9190: 'readonly' modifier must be specified after 'ref'.
            //     extension(readonly ref int i) { }
            Diagnostic(ErrorCode.ERR_RefReadOnlyWrongOrdering, "readonly").WithLocation(3, 15),
            // (4,24): error CS9190: 'readonly' modifier must be specified after 'ref'.
            //     static void M(this readonly ref int i) { }
            Diagnostic(ErrorCode.ERR_RefReadOnlyWrongOrdering, "readonly").WithLocation(4, 24));
    }

    [Fact]
    public void ReceiverParameter_ArgList_01()
    {
        var src = """
_ = object.M();

public static class Extensions
{
    extension(__arglist)
    {
        void M(){}
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,12): error CS0117: 'object' does not contain a definition for 'M'
            // _ = object.M();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(1, 12),
            // (5,15): error CS1669: __arglist is not valid in this context
            //     extension(__arglist)
            Diagnostic(ErrorCode.ERR_IllegalVarArgs, "__arglist").WithLocation(5, 15));

        Assert.Empty(comp.GetTypeByMetadataName("Extensions").GetMembers().OfType<MethodSymbol>());

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertEqualAndNoDuplicates(_objectMembers, model.LookupSymbols(position: 0, o, name: null, includeReducedExtensionMethods: true).ToTestDisplayStrings());
    }

    [Fact]
    public void ReceiverParameter_ArgList_02()
    {
        var src = """
public static class Extensions
{
    extension(__arglist, int i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS1669: __arglist is not valid in this context
            //     extension(__arglist, int i) { }
            Diagnostic(ErrorCode.ERR_IllegalVarArgs, "__arglist").WithLocation(3, 15),
            // (3,26): error CS9285: An extension container can have only one receiver parameter
            //     extension(__arglist, int i) { }
            Diagnostic(ErrorCode.ERR_ReceiverParameterOnlyOne, "int i").WithLocation(3, 26));
    }

    [Fact]
    public void ReceiverParameter_StaticType_01()
    {
        var src = """
public static class Extensions
{
    extension(Extensions) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_StaticType_02()
    {
        var src = """
public static class Extensions
{
    extension(object o, Extensions e) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,25): error CS9285: An extension container can have only one receiver parameter
            //     extension(object o, Extensions e) { }
            Diagnostic(ErrorCode.ERR_ReceiverParameterOnlyOne, "Extensions e").WithLocation(3, 25));
    }

    [Fact]
    public void ReceiverParameter_StaticType_03()
    {
        var src = """
public static class Extensions
{
    extension(Extensions e) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS0721: 'Extensions': static types cannot be used as parameters
            //     extension(Extensions) { }
            Diagnostic(ErrorCode.ERR_ParameterIsStaticClass, "Extensions").WithArguments("Extensions").WithLocation(3, 15));
    }

    [Fact]
    public void ReceiverParameter_StaticType_04()
    {
        var src = """
extension(C) { }
extension(C c) { }
public static class C { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            // extension(C) { }
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(1, 1),
            // (2,1): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            // extension(C c) { }
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(2, 1),
            // (2,11): error CS0721: 'C': static types cannot be used as parameters
            // extension(C c) { }
            Diagnostic(ErrorCode.ERR_ParameterIsStaticClass, "C").WithArguments("C").WithLocation(2, 11));
    }

    [Fact]
    public void ReceiverParameter_StaticType_05()
    {
        var src = """
static class Extensions
{
    extension(C)
    {
    }
}

static class C {}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp).VerifyDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_InstanceType_01()
    {
        var src = """
public static class Extensions
{
    extension(C c) { }
    extension(C) { }
}
public class C { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_ShadowingTypeParameter()
    {
        var src = """
public static class Extensions<T>
{
    extension(object T) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,5): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            //     extension(object T) { }
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(3, 5));
    }

    [Fact]
    public void ReceiverParameter_Ref()
    {
        var src = """
int i = 42;
i.M(43);

public static class Extensions
{
    extension(ref int i)
    {
        public void M(int j) { System.Console.Write((i, j)); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "(42, 43)").VerifyDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_Scoped_01()
    {
        var src = """
public static class Extensions
{
    extension(scoped int i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS9048: The 'scoped' modifier can be used for refs and ref struct values only.
            //     extension(scoped int i) { }
            Diagnostic(ErrorCode.ERR_ScopedRefAndRefStructOnly, "scoped int i").WithLocation(3, 15));
    }

    [Fact]
    public void ReceiverParameter_Scoped_02()
    {
        var src = """
public static class Extensions
{
    extension(int i, scoped int j) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,22): error CS9285: An extension container can have only one receiver parameter
            //     extension(int i, scoped int j) { }
            Diagnostic(ErrorCode.ERR_ReceiverParameterOnlyOne, "scoped int j").WithLocation(3, 22));
    }

    [Fact]
    public void ReceiverParameter_Scoped_03()
    {
        var src = """
public static class Extensions
{
    extension(scoped System.Span<int> i) { }
    public static void M(this scoped System.Span<int> i) { }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net90);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_Nullable_01()
    {
        var src = """
public static class Extensions
{
    extension(string?) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,21): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' annotations context.
            //     extension(string?) { }
            Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(3, 21));
    }

    [Fact]
    public void ReceiverParameter_Nullable_02()
    {
        var src = """
#nullable enable
public static class Extensions
{
    extension(string?) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_RestrictedType()
    {
        var src = """
public static class Extensions
{
    extension(ref System.ArgIterator) { }
    extension(ref System.Span<int>) { }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net90);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS1601: Cannot make reference to variable of type 'ArgIterator'
            //     extension(ref System.ArgIterator) { }
            Diagnostic(ErrorCode.ERR_MethodArgCantBeRefAny, "ref System.ArgIterator").WithArguments("System.ArgIterator").WithLocation(3, 15));
    }

    [Fact]
    public void ReceiverParameter_Empty()
    {
        var src = """
public static class Extensions
{
    extension() { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,15): error CS1031: Type expected
            //     extension() { }
            Diagnostic(ErrorCode.ERR_TypeExpected, ")").WithLocation(3, 15));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var type = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(type);
        Assert.Equal("?", symbol.ExtensionParameter.ToTestDisplayString());
    }

    [Fact]
    public void ReceiverParameter_ConstraintsCheck()
    {
        var src = """
static class Extensions
{
    extension(System.Nullable<string> receiver)
    {
    }

    extension(System.Nullable<string>)
    {
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (3,39): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
            //     extension(System.Nullable<string> receiver)
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "receiver").WithArguments("System.Nullable<T>", "T", "string").WithLocation(3, 39),
            // (7,15): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
            //     extension(System.Nullable<string>)
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "System.Nullable<string>").WithArguments("System.Nullable<T>", "T", "string").WithLocation(7, 15)
            );
    }

    [Fact]
    public void ReceiverParameter_RefScope()
    {
        var src = """
static class Extensions
{
    extension(scoped ref int receiver)
    {
    }

    extension(scoped ref int)
    {
    }
}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp, symbolValidator: (m) =>
        {
            AssertEx.Equal(ScopedKind.ScopedRef, m.GlobalNamespace.GetMember<MethodSymbol>("Extensions.<>E__0.<Extension>$").Parameters[0].EffectiveScope);
            AssertEx.Equal(ScopedKind.ScopedRef, m.GlobalNamespace.GetMember<MethodSymbol>("Extensions.<>E__1.<Extension>$").Parameters[0].EffectiveScope);
        }).VerifyDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_Nullability()
    {
        var src = """
#nullable enable

static class Extensions
{
    extension(string? receiver)
    {
    }

    extension(string?)
    {
    }
}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp, symbolValidator: (m) =>
        {
            AssertEx.Equal("System.String?", m.GlobalNamespace.GetMember<MethodSymbol>("Extensions.<>E__0.<Extension>$").Parameters[0].TypeWithAnnotations.ToTestDisplayString());
            AssertEx.Equal("System.String?", m.GlobalNamespace.GetMember<MethodSymbol>("Extensions.<>E__1.<Extension>$").Parameters[0].TypeWithAnnotations.ToTestDisplayString());
        }).VerifyDiagnostics();

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : verify nullability in GetDeclaredSymbol and GetSymbolInfo
    }

    [Fact]
    public void ReceiverParameter_NativeInteger()
    {
        var src = """
#nullable enable

static class Extensions
{
    extension(nint receiver)
    {
    }

    extension(nint)
    {
    }
}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp, symbolValidator: (m) =>
        {
            Assert.True(m.GlobalNamespace.GetMember<MethodSymbol>("Extensions.<>E__0.<Extension>$").Parameters[0].Type.IsNativeIntegerType);
            Assert.True(m.GlobalNamespace.GetMember<MethodSymbol>("Extensions.<>E__1.<Extension>$").Parameters[0].Type.IsNativeIntegerType);
        }).VerifyDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_InconsistentTypeAccessibility_01()
    {
        var src = """
public static class Extensions
{
    extension(C x)
    {
        public void M() {}
        public int P { get => 0; set {}}
        public int this[int i] { get => 0; set {}}

        private void M1() {}
        private int P1 { get => 0; set {}}
        private int this[long i] { get => 0; set {}}

        internal void M2() {}
        internal int P2 { get => 0; set {}}
        internal int this[byte i] { get => 0; set {}}
    }
}

class C {}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,21): error CS0051: Inconsistent accessibility: parameter type 'C' is less accessible than method 'Extensions.extension(C).M()'
            //         public void M() {}
            Diagnostic(ErrorCode.ERR_BadVisParamType, "M").WithArguments("Extensions.extension(C).M()", "C").WithLocation(5, 21),

            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Error wording, this isn't an indexer
            // (6,20): error CS0055: Inconsistent accessibility: parameter type 'C' is less accessible than indexer 'Extensions.extension(C).P'
            //         public int P { get => 0; set {}}
            Diagnostic(ErrorCode.ERR_BadVisIndexerParam, "P").WithArguments("Extensions.extension(C).P", "C").WithLocation(6, 20),
            // (7,20): error CS0055: Inconsistent accessibility: parameter type 'C' is less accessible than indexer 'Extensions.extension(C).this[int]'
            //         public int this[int i] { get => 0; set {}}
            Diagnostic(ErrorCode.ERR_BadVisIndexerParam, "this").WithArguments("Extensions.extension(C).this[int]", "C").WithLocation(7, 20)
            );
    }

    [Fact]
    public void ReceiverParameter_InconsistentTypeAccessibility_02()
    {
        var src = """
public static class Extensions
{
    extension(C x)
    {
    }

    private class C {}
}
""";
        var comp = CreateCompilation(src);

        CompileAndVerify(comp).VerifyDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_InconsistentTypeAccessibility_03()
    {
        var src = """
public static class Extensions
{
    extension(C x)
    {
        public void M() {}
        public int P { get => 0; set {}}
        public int this[int i] { get => 0; set {}}

        private void M1() {}
        private int P1 { get => 0; set {}}
        private int this[long i] { get => 0; set {}}

        internal void M2() {}
        internal int P2 { get => 0; set {}}
        internal int this[byte i] { get => 0; set {}}
    }

    private class C {}
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,21): error CS0051: Inconsistent accessibility: parameter type 'Extensions.C' is less accessible than method 'Extensions.extension(Extensions.C).M()'
            //         public void M() {}
            Diagnostic(ErrorCode.ERR_BadVisParamType, "M").WithArguments("Extensions.extension(Extensions.C).M()", "Extensions.C").WithLocation(5, 21),

            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Error wording, this isn't an indexer

            // (6,20): error CS0055: Inconsistent accessibility: parameter type 'Extensions.C' is less accessible than indexer 'Extensions.extension(Extensions.C).P'
            //         public int P { get => 0; set {}}
            Diagnostic(ErrorCode.ERR_BadVisIndexerParam, "P").WithArguments("Extensions.extension(Extensions.C).P", "Extensions.C").WithLocation(6, 20),
            // (7,20): error CS0055: Inconsistent accessibility: parameter type 'Extensions.C' is less accessible than indexer 'Extensions.extension(Extensions.C).this[int]'
            //         public int this[int i] { get => 0; set {}}
            Diagnostic(ErrorCode.ERR_BadVisIndexerParam, "this").WithArguments("Extensions.extension(Extensions.C).this[int]", "Extensions.C").WithLocation(7, 20),
            // (13,23): error CS0051: Inconsistent accessibility: parameter type 'Extensions.C' is less accessible than method 'Extensions.extension(Extensions.C).M2()'
            //         internal void M2() {}
            Diagnostic(ErrorCode.ERR_BadVisParamType, "M2").WithArguments("Extensions.extension(Extensions.C).M2()", "Extensions.C").WithLocation(13, 23),
            // (14,22): error CS0055: Inconsistent accessibility: parameter type 'Extensions.C' is less accessible than indexer 'Extensions.extension(Extensions.C).P2'
            //         internal int P2 { get => 0; set {}}
            Diagnostic(ErrorCode.ERR_BadVisIndexerParam, "P2").WithArguments("Extensions.extension(Extensions.C).P2", "Extensions.C").WithLocation(14, 22),
            // (15,22): error CS0055: Inconsistent accessibility: parameter type 'Extensions.C' is less accessible than indexer 'Extensions.extension(Extensions.C).this[byte]'
            //         internal int this[byte i] { get => 0; set {}}
            Diagnostic(ErrorCode.ERR_BadVisIndexerParam, "this").WithArguments("Extensions.extension(Extensions.C).this[byte]", "Extensions.C").WithLocation(15, 22)
            );
    }

    [Fact]
    public void InconsistentTypeAccessibility_01()
    {
        var src = """
public static class Extensions
{
    extension(int x)
    {
        public void M1(C c) {}
        private void M2(C c) {}
    }

    extension(long x)
    {
        public static void M3(int y)
        {
            y.M2(new C());
        }
    }

    public static void M4(int x)
    {
        x.M2(new C());
    }

    private class C {}
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,21): error CS0051: Inconsistent accessibility: parameter type 'Extensions.C' is less accessible than method 'Extensions.extension(int).M1(Extensions.C)'
            //         public void M1(C c) {}
            Diagnostic(ErrorCode.ERR_BadVisParamType, "M1").WithArguments("Extensions.extension(int).M1(Extensions.C)", "Extensions.C").WithLocation(5, 21)
            );
    }

    [Fact]
    public void InconsistentTypeAccessibility_02()
    {
        var src = """
public static class Extensions
{
    extension(int x)
    {
        public C M1 => null;
        private C M2 => null;
    }

    extension(long x)
    {
        public static void M3(int y)
        {
            _ = y.M2;
        }
    }

    public static void M4(int x)
    {
        _ = x.M2;
    }

    private class C {}
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,18): error CS0053: Inconsistent accessibility: property type 'Extensions.C' is less accessible than property 'Extensions.extension(int).M1'
            //         public C M1 => null;
            Diagnostic(ErrorCode.ERR_BadVisPropertyType, "M1").WithArguments("Extensions.extension(int).M1", "Extensions.C").WithLocation(5, 18)
            );
    }

    [Fact]
    public void Inaccessible_01()
    {
        var src = """
static class Extensions
{
    extension(int x)
    {
        private void M2() {}
    }

    private static void M3(this int x) {}
}

class C
{
    void Test(int x)
    {
        x.M2();
        x.M3();
        Extensions.M2(x);
        Extensions.M3(x);
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (15,11): error CS1061: 'int' does not contain a definition for 'M2' and no accessible extension method 'M2' accepting a first argument of type 'int' could be found (are you missing a using directive or an assembly reference?)
            //         x.M2();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M2").WithArguments("int", "M2").WithLocation(15, 11),
            // (16,11): error CS1061: 'int' does not contain a definition for 'M3' and no accessible extension method 'M3' accepting a first argument of type 'int' could be found (are you missing a using directive or an assembly reference?)
            //         x.M3();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M3").WithArguments("int", "M3").WithLocation(16, 11),
            // (17,20): error CS0122: 'Extensions.M2(int)' is inaccessible due to its protection level
            //         Extensions.M2(x);
            Diagnostic(ErrorCode.ERR_BadAccess, "M2").WithArguments("Extensions.M2(int)").WithLocation(17, 20),
            // (18,20): error CS0122: 'Extensions.M3(int)' is inaccessible due to its protection level
            //         Extensions.M3(x);
            Diagnostic(ErrorCode.ERR_BadAccess, "M3").WithArguments("Extensions.M3(int)").WithLocation(18, 20)
            );
    }

    [Fact]
    public void ReceiverParameter_FileType_01()
    {
        var src = """
file class C {}

static class Extensions
{
    extension(C x)
    {
    }

    private static void M3(this C x) {}
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,14): error CS9051: File-local type 'C' cannot be used in a member signature in non-file-local type 'Extensions'.
            //     extension(C x)
            Diagnostic(ErrorCode.ERR_FileTypeDisallowedInSignature, "(").WithArguments("C", "Extensions").WithLocation(5, 14),
            // (9,25): error CS9051: File-local type 'C' cannot be used in a member signature in non-file-local type 'Extensions'.
            //     private static void M3(this C x) {}
            Diagnostic(ErrorCode.ERR_FileTypeDisallowedInSignature, "M3").WithArguments("C", "Extensions").WithLocation(9, 25)
            );
    }

    [Fact]
    public void ReceiverParameter_FileType_02()
    {
        var src = """
file class C {}

file static class Extensions
{
    extension(C x)
    {
        public void M1() {}
        public int P => 0;
        public int this[int i] => 0;
    }

    public static void M2(this C x) {}

    private static void M3(this C x) {}
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void FileType_01()
    {
        var src = """
file class C {}

file static class Extensions
{
    extension(int x)
    {
        public void M1(C c) {}
        public C P => null;
        public C this[int y]  => null;
        public int this[C y]  => 0;
    }

    public static void M2(this int x, C c) {}
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_PointerType()
    {
        string source = """
unsafe static class E
{
    extension(int* i)
    {
        public static void M() { }
    }
    public static void M2(this int* i) { }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : missing validation
        var comp = CreateCompilation(source, options: TestOptions.UnsafeDebugDll);
        comp.VerifyEmitDiagnostics(
            // (7,32): error CS1103: The first parameter of an extension method cannot be of type 'int*'
            //     public static void M2(this int* i) { }
            Diagnostic(ErrorCode.ERR_BadTypeforThis, "int*").WithArguments("int*").WithLocation(7, 32));
    }

    [Fact]
    public void Skeleton()
    {
        var src = """
public static class Extensions
{
    extension(object)
    {
        void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var verifier = CompileAndVerify(comp);
        verifier.VerifyIL("Extensions.<>E__0.M()", """
{
  // Code size        2 (0x2)
  .maxstack  1
  IL_0000:  ldnull
  IL_0001:  throw
}
""");

        verifier.VerifyIL("Extensions.M", """
{
  // Code size       11 (0xb)
  .maxstack  1
  IL_0000:  ldstr      "ran"
  IL_0005:  call       "void System.Console.Write(string)"
  IL_000a:  ret
}
""");
    }

    [Fact]
    public void GetDiagnosticsForSpan_NoReceiverParameter()
    {
        var src = """
public static class Extensions
{
    extension(__arglist)
    {
        public int M()
        {
            return "";
        }
    }
}
""";
        var comp = CreateCompilation(src);

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var ext = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var m = ext.DescendantNodes().OfType<MethodDeclarationSyntax>().Single();

        model.GetDiagnostics(ext.ParameterList.Span).Verify(
            // (3,15): error CS1669: __arglist is not valid in this context
            //     extension(__arglist)
            Diagnostic(ErrorCode.ERR_IllegalVarArgs, "__arglist").WithLocation(3, 15)
            );

        model.GetDiagnostics(m.Body.Span).Verify(
            // (7,20): error CS0029: Cannot implicitly convert type 'string' to 'int'
            //             return "";
            Diagnostic(ErrorCode.ERR_NoImplicitConv, @"""""").WithArguments("string", "int").WithLocation(7, 20)
            );

        comp.VerifyDiagnostics(
            // (7,20): error CS0029: Cannot implicitly convert type 'string' to 'int'
            //             return "";
            Diagnostic(ErrorCode.ERR_NoImplicitConv, @"""""").WithArguments("string", "int").WithLocation(7, 20),
            // (3,15): error CS1669: __arglist is not valid in this context
            //     extension(__arglist)
            Diagnostic(ErrorCode.ERR_IllegalVarArgs, "__arglist").WithLocation(3, 15)
            );
    }

    [Fact]
    public void GetDiagnosticsForSpan_WithReceiverParameter()
    {
        var src = """
public static class Extensions
{
    extension(object o = null)
    {
        public int M()
        {
            return "";
        }
    }
}
""";
        var comp = CreateCompilation(src);

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var ext = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var m = ext.DescendantNodes().OfType<MethodDeclarationSyntax>().Single();

        model.GetDiagnostics(ext.ParameterList.Span).Verify(
            // (3,15): error CS9284: The receiver parameter of an extension cannot have a default value
            //     extension(object o = null)
            Diagnostic(ErrorCode.ERR_ExtensionParameterDisallowsDefaultValue, "object o = null").WithLocation(3, 15)
            );

        model.GetDiagnostics(m.Body.Span).Verify(
            // (7,20): error CS0029: Cannot implicitly convert type 'string' to 'int'
            //             return "";
            Diagnostic(ErrorCode.ERR_NoImplicitConv, @"""""").WithArguments("string", "int").WithLocation(7, 20)
            );

        comp.VerifyDiagnostics(
            // (3,15): error CS9284: The receiver parameter of an extension cannot have a default value
            //     extension(object o = null)
            Diagnostic(ErrorCode.ERR_ExtensionParameterDisallowsDefaultValue, "object o = null").WithLocation(3, 15),
            // (7,20): error CS0029: Cannot implicitly convert type 'string' to 'int'
            //             return "";
            Diagnostic(ErrorCode.ERR_NoImplicitConv, @"""""").WithArguments("string", "int").WithLocation(7, 20)
            );

        Assert.Equal("[System.Object o = null]", model.GetDeclaredSymbol(ext.ParameterList.Parameters[0]).ToTestDisplayString());
    }

    [Fact]
    public void ReceiverInScopeButIllegalInStaticMember()
    {
        var src = """
public static class Extensions
{
    extension(object o)
    {
        static object M1() => o;
        static object M2() { return o; }
        static object P1 => o;
        static object P2 { get { return o; } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,31): error CS9293: Cannot use extension parameter 'object o' in this context.
            //         static object M1() => o;
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "o").WithArguments("object o").WithLocation(5, 31),
            // (6,37): error CS9293: Cannot use extension parameter 'object o' in this context.
            //         static object M2() { return o; }
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "o").WithArguments("object o").WithLocation(6, 37),
            // (7,29): error CS9293: Cannot use extension parameter 'object o' in this context.
            //         static object P1 => o;
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "o").WithArguments("object o").WithLocation(7, 29),
            // (8,41): error CS9293: Cannot use extension parameter 'object o' in this context.
            //         static object P2 { get { return o; } }
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "o").WithArguments("object o").WithLocation(8, 41)
            );
    }

    [Fact]
    public void PassingValueForARefReceiver_01()
    {
        var src = """
public class C
{
    static void Main()
    {
        GetInt().M1();
        GetInt().M2();
        _ = GetInt().P;
    }

    static int GetInt() => 0; 
}

static class Extensions
{
    extension(ref int receiver)
    {
        public void M1() {}
        public int P => 0;
    }

    public static void M2 (this ref int receiver)
    {
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,9): error CS1510: A ref or out value must be an assignable variable
            //         GetInt().M1();
            Diagnostic(ErrorCode.ERR_RefLvalueExpected, "GetInt()").WithLocation(5, 9),
            // (6,9): error CS1510: A ref or out value must be an assignable variable
            //         GetInt().M2();
            Diagnostic(ErrorCode.ERR_RefLvalueExpected, "GetInt()").WithLocation(6, 9),
            // (7,13): error CS1510: A ref or out value must be an assignable variable
            //         _ = GetInt().P;
            Diagnostic(ErrorCode.ERR_RefLvalueExpected, "GetInt()").WithLocation(7, 13)
            );
    }

    [Fact]
    public void PassingValueForARefReceiver_02()
    {
        var src = """
public class C
{
    static void Main()
    {
        GetInt().M1();
        GetInt().M2();
        _ = GetInt().P;
    }

    static int GetInt() => 0; 
}

static class Extensions
{
    extension(ref readonly int receiver)
    {
        public void M1() {}
        public int P => 0;
    }

    public static void M2 (this ref readonly int receiver)
    {
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics(
            // (5,9): warning CS9193: Argument 0 should be a variable because it is passed to a 'ref readonly' parameter
            //         GetInt().M1();
            Diagnostic(ErrorCode.WRN_RefReadonlyNotVariable, "GetInt()").WithArguments("0").WithLocation(5, 9),
            // (6,9): warning CS9193: Argument 0 should be a variable because it is passed to a 'ref readonly' parameter
            //         GetInt().M2();
            Diagnostic(ErrorCode.WRN_RefReadonlyNotVariable, "GetInt()").WithArguments("0").WithLocation(6, 9),
            // (7,13): warning CS9193: Argument 0 should be a variable because it is passed to a 'ref readonly' parameter
            //         _ = GetInt().P;
            Diagnostic(ErrorCode.WRN_RefReadonlyNotVariable, "GetInt()").WithArguments("0").WithLocation(7, 13)
            );

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Test emit and execution for a scenario like this
    }

    [Fact]
    public void PassingValueForARefReceiver_03()
    {
        var src = """
public class C
{
    static void Main()
    {
        GetInt().M1();
        GetInt().M2();
        _ = GetInt().P;
    }

    static int GetInt() => 0; 
}

static class Extensions
{
    extension(in int receiver)
    {
        public void M1() {}
        public int P => 0;
    }

    public static void M2 (this in int receiver)
    {
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics(); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Test emit and execution for a scenario like this
    }

    [Fact]
    public void Implementation_InstanceMethod_01()
    {
        var src = """
public static class Extensions
{
    extension(object o)
    {
        void M(string s)
        {
            o.ToString();
            _ = s.Length;
        }
    }
}
""";
        var comp = CreateCompilation(src);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics();

        verifier.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2077
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method private hidebysig 
            instance void M (
                string s
            ) cil managed 
        {
            // Method begins at RVA 0x2079
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    // Methods
    .method private hidebysig specialname static 
        void M (
            object o,
            string s
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 15 (0xf)
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: callvirt instance string [mscorlib]System.Object::ToString()
        IL_0006: pop
        IL_0007: ldarg.1
        IL_0008: callvirt instance int32 [mscorlib]System.String::get_Length()
        IL_000d: pop
        IL_000e: ret
    } // end of method Extensions::M
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        CompileAndVerify(
            comp,
            emitOptions: EmitOptions.Default.WithEmitMetadataOnly(true).WithIncludePrivateMembers(false),
            symbolValidator: (m) =>
            {
                AssertEx.Equal("void Extensions.<>E__0.<Extension>$(System.Object o)", m.GlobalNamespace.GetMember("Extensions.<>E__0.<Extension>$").ToTestDisplayString());
            }
            ).VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_InstanceMethod_02()
    {
        var src1 = """
public static class Extensions
{
    extension(object o)
    {
        public string M(string s) => o + s;
    }
}
""";
        var comp1 = CreateCompilation(src1);

        var verifier1 = CompileAndVerify(comp1, sourceSymbolValidator: verifySymbols, symbolValidator: verifySymbols).VerifyDiagnostics();

        static void verifySymbols(ModuleSymbol m)
        {
            NamedTypeSymbol extensions = m.ContainingAssembly.GetTypeByMetadataName("Extensions");
            MethodSymbol implementation = extensions.GetMembers().OfType<MethodSymbol>().Single();
            Assert.True(implementation.IsStatic);
            Assert.Equal(MethodKind.Ordinary, implementation.MethodKind);
            Assert.Equal(2, implementation.ParameterCount);
            AssertEx.Equal("System.String Extensions.M(this System.Object o, System.String s)", implementation.ToTestDisplayString());
            Assert.Equal(m is not PEModuleSymbol, implementation.IsImplicitlyDeclared);
            Assert.True(implementation.IsExtensionMethod);
            Assert.True(implementation.HasSpecialName);
            Assert.False(implementation.HasRuntimeSpecialName);

            Assert.True(implementation.ContainingType.MightContainExtensionMethods);

            Assert.Contains("M", extensions.MemberNames);
            Assert.NotEmpty(extensions.GetSimpleNonTypeMembers("M"));

            if (m is PEModuleSymbol peModuleSymbol)
            {
                Assert.True(peModuleSymbol.Module.HasExtensionAttribute(((PEAssemblySymbol)peModuleSymbol.ContainingAssembly).Assembly.Handle, ignoreCase: false));
            }
        }

        comp1 = CreateCompilation(src1);
        NamedTypeSymbol extensions = comp1.GetTypeByMetadataName("Extensions");
        Assert.Contains("M", extensions.MemberNames);

        comp1 = CreateCompilation(src1);
        extensions = comp1.GetTypeByMetadataName("Extensions");
        Assert.NotEmpty(extensions.GetSimpleNonTypeMembers("M"));

        var expectedTypeIL = """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x207b
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig 
            instance string M (
                string s
            ) cil managed 
        {
            // Method begins at RVA 0x207d
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    // Methods
    .method public hidebysig specialname static 
        string M (
            object o,
            string s
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 19 (0x13)
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: brtrue.s IL_0006
        IL_0003: ldnull
        IL_0004: br.s IL_000c
        IL_0006: ldarg.0
        IL_0007: callvirt instance string [mscorlib]System.Object::ToString()
        IL_000c: ldarg.1
        IL_000d: call string [mscorlib]System.String::Concat(string, string)
        IL_0012: ret
    } // end of method Extensions::M
} // end of class Extensions
""";

        verifier1.VerifyTypeIL("Extensions", expectedTypeIL.Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write("3".M2("4"));
    }

    static string Test(object o)
    {
        return o.M("2");
    }
}

static class Extensions
{
    extension(object o)
    {
        public string M2(string s) => o.M(s);
    }
}
""";

        var comp1MetadataReference = comp1.ToMetadataReference();
        var comp2 = CreateCompilation(src2, references: [comp1MetadataReference], options: TestOptions.DebugExe);
        var verifier2 = CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

        var testIL =
@"
{
  // Code size       17 (0x11)
  .maxstack  2
  .locals init (string V_0)
  IL_0000:  nop
  IL_0001:  ldarg.0
  IL_0002:  ldstr      ""2""
  IL_0007:  call       ""string Extensions.M(object, string)""
  IL_000c:  stloc.0
  IL_000d:  br.s       IL_000f
  IL_000f:  ldloc.0
  IL_0010:  ret
}
";
        verifier2.VerifyIL("Program.Test", testIL);

        var m2IL =
@"
{
  // Code size        8 (0x8)
  .maxstack  2
  IL_0000:  ldarg.0
  IL_0001:  ldarg.1
  IL_0002:  call       ""string Extensions.M(object, string)""
  IL_0007:  ret
}
";
        verifier2.VerifyIL("Extensions.M2", m2IL);

        var comp1ImageReference = comp1.EmitToImageReference();
        comp2 = CreateCompilation(src2, references: [comp1ImageReference], options: TestOptions.DebugExe);
        verifier2 = CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

        verifier2.VerifyIL("Program.Test", testIL);
        verifier2.VerifyIL("Extensions.M2", m2IL);

        comp2 = CreateCompilationWithIL(src2, expectedTypeIL, options: TestOptions.DebugExe);
        CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

        var remove = """
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
""";

        comp2 = CreateCompilationWithIL(src2, expectedTypeIL.Remove(expectedTypeIL.IndexOf(remove), remove.Length));
        comp2.VerifyDiagnostics(
            // (11,18): error CS1061: 'object' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            //         return o.M("2");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("object", "M").WithLocation(11, 18),
            // (19,41): error CS1061: 'object' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            //         public string M2(string s) => o.M(s);
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("object", "M").WithLocation(19, 41)
            );

        src2 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write("3".M2("4"));
    }

    static string Test(object o)
    {
        return Extensions.M(o, "2");
    }
}

static class Extensions_
{
    extension(object o)
    {
        public string M2(string s) => Extensions.M(o, s);
    }

    public static void NotUsed(this object o) {}
}
""";

        comp2 = CreateCompilation(src2, references: [comp1MetadataReference], options: TestOptions.DebugExe);
        verifier2 = CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

        verifier2.VerifyIL("Program.Test", testIL);
        verifier2.VerifyIL("Extensions_.M2", m2IL);

        comp2 = CreateCompilation(src2, references: [comp1ImageReference], options: TestOptions.DebugExe);
        verifier2 = CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

        verifier2.VerifyIL("Program.Test", testIL);
        verifier2.VerifyIL("Extensions_.M2", m2IL);

        var vbComp = CreateVisualBasicCompilation("""
Class Program
    Shared Sub Main()
        System.Console.Write(Test1("1"))
        System.Console.Write(Test2("3"))
    End Sub

    Shared Function Test1(o As String) As String
        return o.M("2")
    End Function
    Shared Function Test2(o As String) As String
        return Extensions.M(o, "4")
    End Function
End Class
""",
            referencedAssemblies: comp2.References, compilationOptions: new VisualBasicCompilationOptions(OutputKind.ConsoleApplication));

        CompileAndVerify(vbComp, expectedOutput: "1234").VerifyDiagnostics();

        if (!CompilationExtensions.EnableVerifyUsedAssemblies) // Tracked by https://github.com/dotnet/roslyn/issues/77542
        {
            var src4 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write("3".M2("4"));
    }

    static string Test(object o)
    {
        System.Func<string, string> d = o.M;
        return d("2");
    }
}

static class Extensions
{
    extension(object o)
    {
        public string M2(string s) => new System.Func<string, string>(o.M)(s);
    }
}
""";

            var comp4 = CreateCompilation(src4, references: [comp1MetadataReference], options: TestOptions.DebugExe);
            var verifier4 = CompileAndVerify(comp4, expectedOutput: "1234").VerifyDiagnostics();

            testIL =
    @"
{
  // Code size       30 (0x1e)
  .maxstack  2
  .locals init (System.Func<string, string> V_0, //d
            string V_1)
  IL_0000:  nop
  IL_0001:  ldarg.0
  IL_0002:  ldftn      ""string Extensions.M(object, string)""
  IL_0008:  newobj     ""System.Func<string, string>..ctor(object, System.IntPtr)""
  IL_000d:  stloc.0
  IL_000e:  ldloc.0
  IL_000f:  ldstr      ""2""
  IL_0014:  callvirt   ""string System.Func<string, string>.Invoke(string)""
  IL_0019:  stloc.1
  IL_001a:  br.s       IL_001c
  IL_001c:  ldloc.1
  IL_001d:  ret
}
";
            verifier4.VerifyIL("Program.Test", testIL);

            m2IL =
    @"
{
  // Code size       19 (0x13)
  .maxstack  2
  IL_0000:  ldarg.0
  IL_0001:  ldftn      ""string Extensions.M(object, string)""
  IL_0007:  newobj     ""System.Func<string, string>..ctor(object, System.IntPtr)""
  IL_000c:  ldarg.1
  IL_000d:  callvirt   ""string System.Func<string, string>.Invoke(string)""
  IL_0012:  ret
}
";
            verifier4.VerifyIL("Extensions.M2", m2IL);

            comp4 = CreateCompilation(src4, references: [comp1ImageReference], options: TestOptions.DebugExe);
            verifier4 = CompileAndVerify(comp4, expectedOutput: "1234").VerifyDiagnostics();

            verifier4.VerifyIL("Program.Test", testIL);
            verifier4.VerifyIL("Extensions.M2", m2IL);
        }

        var comp5 = CreateCompilation(src1);
        comp5.MakeMemberMissing(WellKnownMember.System_Runtime_CompilerServices_ExtensionAttribute__ctor);
        comp5.VerifyDiagnostics(
            // (3,5): error CS1110: Cannot define a new extension because the compiler required type 'System.Runtime.CompilerServices.ExtensionAttribute' cannot be found. Are you missing a reference to System.Core.dll?
            //     extension(object o)
            Diagnostic(ErrorCode.ERR_ExtensionAttrNotFound, "extension").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(3, 5)
            );
    }

    [Fact(Skip = "https://github.com/dotnet/roslyn/issues/77542")]
    public void UseSiteInfoTracking_01()
    {
        var src1 = """
public static class Extensions
{
    public static string M(this object o, string s) => o + s;
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1).VerifyDiagnostics();

        var src4 = """
class Program
{
    static string Test(object o)
    {
        System.Func<string, string> d = o.M;
        return d("2");
    }
}
""";

        var comp1MetadataReference = comp1.ToMetadataReference();
        var comp4 = CreateCompilation(src4, references: [comp1MetadataReference]);
        comp4.VerifyEmitDiagnostics();
        var refs = comp4.GetUsedAssemblyReferences();
        Assert.Contains(comp1MetadataReference, refs);
    }

    [Fact]
    public void UseSiteInfoTracking_02()
    {
        var src1 = """
public static class Extensions
{
    public static string M(this object o, string s) => o + s;
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1).VerifyDiagnostics();

        var src4 = """
class Program
{
    static string Test(object o)
    {
        return o.M("2");
    }
}
""";

        var comp1MetadataReference = comp1.ToMetadataReference();
        var comp4 = CreateCompilation(src4, references: [comp1MetadataReference]);
        comp4.VerifyEmitDiagnostics();
        var refs = comp4.GetUsedAssemblyReferences();
        Assert.Contains(comp1MetadataReference, refs);
    }

    [Fact]
    public void Implementation_InstanceMethod_03_WithLocalFunction()
    {
        var src1 = """
public static class Extensions
{
    extension(object o)
    {
        public string M(string s)
        {
            string local() => o + s;
            return local();
        }
    }
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x20ab
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig 
            instance string M (
                string s
            ) cil managed 
        {
            // Method begins at RVA 0x20ad
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    .class nested private auto ansi sealed beforefieldinit '<>c__DisplayClass1_0'
        extends [mscorlib]System.ValueType
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public object o
        .field public string s
    } // end of class <>c__DisplayClass1_0
    // Methods
    .method public hidebysig specialname static 
        string M (
            object o,
            string s
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2068
        // Code size 24 (0x18)
        .maxstack 2
        .locals init (
            [0] valuetype Extensions/'<>c__DisplayClass1_0'
        )
        IL_0000: ldloca.s 0
        IL_0002: ldarg.0
        IL_0003: stfld object Extensions/'<>c__DisplayClass1_0'::o
        IL_0008: ldloca.s 0
        IL_000a: ldarg.1
        IL_000b: stfld string Extensions/'<>c__DisplayClass1_0'::s
        IL_0010: ldloca.s 0
        IL_0012: call string Extensions::'<M>b__1_0'(valuetype Extensions/'<>c__DisplayClass1_0'&)
        IL_0017: ret
    } // end of method Extensions::M
    .method assembly hidebysig static 
        string '<M>b__1_0' (
            valuetype Extensions/'<>c__DisplayClass1_0'& ''
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x208c
        // Code size 30 (0x1e)
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: ldfld object Extensions/'<>c__DisplayClass1_0'::o
        IL_0006: dup
        IL_0007: brtrue.s IL_000d
        IL_0009: pop
        IL_000a: ldnull
        IL_000b: br.s IL_0012
        IL_000d: callvirt instance string [mscorlib]System.Object::ToString()
        IL_0012: ldarg.0
        IL_0013: ldfld string Extensions/'<>c__DisplayClass1_0'::s
        IL_0018: call string [mscorlib]System.String::Concat(string, string)
        IL_001d: ret
    } // end of method Extensions::'<M>b__1_0'
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension(object o)
    {
        string M(string s)
        {
            string local() => o + s;
            return local();
        }
    }

    extension(object o)
    {
        string M(string s, int x)
        {
            string local() => o + s;
            return local();
        }
    }
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write("3".M2("4"));
    }

    static string Test(object o)
    {
        string local() => o.M("2");
        return local();
    }
}

static class Extensions
{
    extension(object o)
    {
        public string M2(string s)
        {
            string local() => o.M(s);
            return local();
        }
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_InstanceMethod_04_WithLambda()
    {
        var src1 = """
public static class Extensions
{
    extension(object o)
    {
        public string M(string s)
        {
            System.Func<string> local = () => o + s;
            return local();
        }
    }
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x208c
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig 
            instance string M (
                string s
            ) cil managed 
        {
            // Method begins at RVA 0x208e
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    .class nested private auto ansi sealed beforefieldinit '<>c__DisplayClass1_0'
        extends [mscorlib]System.Object
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public object o
        .field public string s
        // Methods
        .method public hidebysig specialname rtspecialname 
            instance void .ctor () cil managed 
        {
            // Method begins at RVA 0x2091
            // Code size 7 (0x7)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: call instance void [mscorlib]System.Object::.ctor()
            IL_0006: ret
        } // end of method '<>c__DisplayClass1_0'::.ctor
        .method assembly hidebysig 
            instance string '<M>b__0' () cil managed 
        {
            // Method begins at RVA 0x2099
            // Code size 30 (0x1e)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldfld object Extensions/'<>c__DisplayClass1_0'::o
            IL_0006: dup
            IL_0007: brtrue.s IL_000d
            IL_0009: pop
            IL_000a: ldnull
            IL_000b: br.s IL_0012
            IL_000d: callvirt instance string [mscorlib]System.Object::ToString()
            IL_0012: ldarg.0
            IL_0013: ldfld string Extensions/'<>c__DisplayClass1_0'::s
            IL_0018: call string [mscorlib]System.String::Concat(string, string)
            IL_001d: ret
        } // end of method '<>c__DisplayClass1_0'::'<M>b__0'
    } // end of class <>c__DisplayClass1_0
    // Methods
    .method public hidebysig specialname static 
        string M (
            object o,
            string s
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 36 (0x24)
        .maxstack 8
        IL_0000: newobj instance void Extensions/'<>c__DisplayClass1_0'::.ctor()
        IL_0005: dup
        IL_0006: ldarg.0
        IL_0007: stfld object Extensions/'<>c__DisplayClass1_0'::o
        IL_000c: dup
        IL_000d: ldarg.1
        IL_000e: stfld string Extensions/'<>c__DisplayClass1_0'::s
        IL_0013: ldftn instance string Extensions/'<>c__DisplayClass1_0'::'<M>b__0'()
        IL_0019: newobj instance void class [mscorlib]System.Func`1<string>::.ctor(object, native int)
        IL_001e: callvirt instance !0 class [mscorlib]System.Func`1<string>::Invoke()
        IL_0023: ret
    } // end of method Extensions::M
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension(object o)
    {
        string M(string s)
        {
            System.Func<string> local = () => o + s;
            return local();
        }
    }

    extension(object o)
    {
        string M(string s, int x)
        {
            System.Func<string> local = () => o + s;
            return local();
        }
    }
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write("3".M2("4"));
    }

    static string Test(object o)
    {
        System.Func<string> local = () => o.M("2");
        return local();
    }
}

static class Extensions
{
    extension(object o)
    {
        public string M2(string s)
        {
            System.Func<string> local = () => o.M(s);
            return local();
        }
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_InstanceMethod_05_Iterator()
    {
        var src1 = """
public static class Extensions
{
    extension(object o)
    {
        public System.Collections.Generic.IEnumerable<string> M(string s)
        {
            yield return o + s;
        }
    }
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1, symbolValidator: (m) =>
        {
            MethodSymbol implementation = m.ContainingAssembly.GetTypeByMetadataName("Extensions").GetMembers().OfType<MethodSymbol>().Single();
            AssertEx.Equal("System.Runtime.CompilerServices.IteratorStateMachineAttribute(typeof(Extensions.<M>d__1))", implementation.GetAttributes().Single().ToString());
        }).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", ("""
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x207e
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig 
            instance class [mscorlib]System.Collections.Generic.IEnumerable`1<string> M (
                string s
            ) cil managed 
        {
            // Method begins at RVA 0x2080
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    .class nested private auto ansi sealed beforefieldinit '<M>d__1'
        extends [mscorlib]System.Object
        implements class [mscorlib]System.Collections.Generic.IEnumerable`1<string>,
                   [mscorlib]System.Collections.IEnumerable,
                   class [mscorlib]System.Collections.Generic.IEnumerator`1<string>,

""" +
        (ExecutionConditionUtil.IsMonoOrCoreClr ?
"""
                   [mscorlib]System.Collections.IEnumerator,
                   [mscorlib]System.IDisposable

""" :
"""
                   [mscorlib]System.IDisposable,
                   [mscorlib]System.Collections.IEnumerator

""") +
"""
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field private int32 '<>1__state'
        .field private string '<>2__current'
        .field private int32 '<>l__initialThreadId'
        .field private object o
        .field public object '<>3__o'
        .field private string s
        .field public string '<>3__s'
        // Methods
        .method public hidebysig specialname rtspecialname 
            instance void .ctor (
                int32 '<>1__state'
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2083
            // Code size 25 (0x19)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: call instance void [mscorlib]System.Object::.ctor()
            IL_0006: ldarg.0
            IL_0007: ldarg.1
            IL_0008: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_000d: ldarg.0
            IL_000e: call int32 [mscorlib]System.Environment::get_CurrentManagedThreadId()
            IL_0013: stfld int32 Extensions/'<M>d__1'::'<>l__initialThreadId'
            IL_0018: ret
        } // end of method '<M>d__1'::.ctor
        .method private final hidebysig newslot virtual 
            instance void System.IDisposable.Dispose () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance void [mscorlib]System.IDisposable::Dispose()
            // Method begins at RVA 0x209d
            // Code size 9 (0x9)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldc.i4.s -2
            IL_0003: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_0008: ret
        } // end of method '<M>d__1'::System.IDisposable.Dispose
        .method private final hidebysig newslot virtual 
            instance bool MoveNext () cil managed 
        {
            .override method instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
            // Method begins at RVA 0x20a8
            // Code size 76 (0x4c)
            .maxstack 3
            .locals init (
                [0] int32
            )
            IL_0000: ldarg.0
            IL_0001: ldfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_0006: stloc.0
            IL_0007: ldloc.0
            IL_0008: brfalse.s IL_0010
            IL_000a: ldloc.0
            IL_000b: ldc.i4.1
            IL_000c: beq.s IL_0043
            IL_000e: ldc.i4.0
            IL_000f: ret
            IL_0010: ldarg.0
            IL_0011: ldc.i4.m1
            IL_0012: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_0017: ldarg.0
            IL_0018: ldarg.0
            IL_0019: ldfld object Extensions/'<M>d__1'::o
            IL_001e: dup
            IL_001f: brtrue.s IL_0025
            IL_0021: pop
            IL_0022: ldnull
            IL_0023: br.s IL_002a
            IL_0025: callvirt instance string [mscorlib]System.Object::ToString()
            IL_002a: ldarg.0
            IL_002b: ldfld string Extensions/'<M>d__1'::s
            IL_0030: call string [mscorlib]System.String::Concat(string, string)
            IL_0035: stfld string Extensions/'<M>d__1'::'<>2__current'
            IL_003a: ldarg.0
            IL_003b: ldc.i4.1
            IL_003c: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_0041: ldc.i4.1
            IL_0042: ret
            IL_0043: ldarg.0
            IL_0044: ldc.i4.m1
            IL_0045: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_004a: ldc.i4.0
            IL_004b: ret
        } // end of method '<M>d__1'::MoveNext
        .method private final hidebysig specialname newslot virtual 
            instance string 'System.Collections.Generic.IEnumerator<System.String>.get_Current' () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<string>::get_Current()
            // Method begins at RVA 0x2100
            // Code size 7 (0x7)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldfld string Extensions/'<M>d__1'::'<>2__current'
            IL_0006: ret
        } // end of method '<M>d__1'::'System.Collections.Generic.IEnumerator<System.String>.get_Current'
        .method private final hidebysig newslot virtual 
            instance void System.Collections.IEnumerator.Reset () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance void [mscorlib]System.Collections.IEnumerator::Reset()
            // Method begins at RVA 0x2108
            // Code size 6 (0x6)
            .maxstack 8
            IL_0000: newobj instance void [mscorlib]System.NotSupportedException::.ctor()
            IL_0005: throw
        } // end of method '<M>d__1'::System.Collections.IEnumerator.Reset
        .method private final hidebysig specialname newslot virtual 
            instance object System.Collections.IEnumerator.get_Current () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance object [mscorlib]System.Collections.IEnumerator::get_Current()
            // Method begins at RVA 0x2100
            // Code size 7 (0x7)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldfld string Extensions/'<M>d__1'::'<>2__current'
            IL_0006: ret
        } // end of method '<M>d__1'::System.Collections.IEnumerator.get_Current
        .method private final hidebysig newslot virtual 
            instance class [mscorlib]System.Collections.Generic.IEnumerator`1<string> 'System.Collections.Generic.IEnumerable<System.String>.GetEnumerator' () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<string>::GetEnumerator()
            // Method begins at RVA 0x2110
            // Code size 67 (0x43)
            .maxstack 2
            .locals init (
                [0] class Extensions/'<M>d__1'
            )
            IL_0000: ldarg.0
            IL_0001: ldfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_0006: ldc.i4.s -2
            IL_0008: bne.un.s IL_0022
            IL_000a: ldarg.0
            IL_000b: ldfld int32 Extensions/'<M>d__1'::'<>l__initialThreadId'
            IL_0010: call int32 [mscorlib]System.Environment::get_CurrentManagedThreadId()
            IL_0015: bne.un.s IL_0022
            IL_0017: ldarg.0
            IL_0018: ldc.i4.0
            IL_0019: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_001e: ldarg.0
            IL_001f: stloc.0
            IL_0020: br.s IL_0029
            IL_0022: ldc.i4.0
            IL_0023: newobj instance void Extensions/'<M>d__1'::.ctor(int32)
            IL_0028: stloc.0
            IL_0029: ldloc.0
            IL_002a: ldarg.0
            IL_002b: ldfld object Extensions/'<M>d__1'::'<>3__o'
            IL_0030: stfld object Extensions/'<M>d__1'::o
            IL_0035: ldloc.0
            IL_0036: ldarg.0
            IL_0037: ldfld string Extensions/'<M>d__1'::'<>3__s'
            IL_003c: stfld string Extensions/'<M>d__1'::s
            IL_0041: ldloc.0
            IL_0042: ret
        } // end of method '<M>d__1'::'System.Collections.Generic.IEnumerable<System.String>.GetEnumerator'
        .method private final hidebysig newslot virtual 
            instance class [mscorlib]System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance class [mscorlib]System.Collections.IEnumerator [mscorlib]System.Collections.IEnumerable::GetEnumerator()
            // Method begins at RVA 0x215f
            // Code size 7 (0x7)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: call instance class [mscorlib]System.Collections.Generic.IEnumerator`1<string> Extensions/'<M>d__1'::'System.Collections.Generic.IEnumerable<System.String>.GetEnumerator'()
            IL_0006: ret
        } // end of method '<M>d__1'::System.Collections.IEnumerable.GetEnumerator
        // Properties
        .property instance string 'System.Collections.Generic.IEnumerator<System.String>.Current'()
        {
            .get instance string Extensions/'<M>d__1'::'System.Collections.Generic.IEnumerator<System.String>.get_Current'()
        }
        .property instance object System.Collections.IEnumerator.Current()
        {
            .get instance object Extensions/'<M>d__1'::System.Collections.IEnumerator.get_Current()
        }
    } // end of class <M>d__1
    // Methods
    .method public hidebysig specialname static 
        class [mscorlib]System.Collections.Generic.IEnumerable`1<string> M (
            object o,
            string s
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.IteratorStateMachineAttribute::.ctor(class [mscorlib]System.Type) = (
            01 00 12 45 78 74 65 6e 73 69 6f 6e 73 2b 3c 4d
            3e 64 5f 5f 31 00 00
        )
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 22 (0x16)
        .maxstack 8
        IL_0000: ldc.i4.s -2
        IL_0002: newobj instance void Extensions/'<M>d__1'::.ctor(int32)
        IL_0007: dup
        IL_0008: ldarg.0
        IL_0009: stfld object Extensions/'<M>d__1'::'<>3__o'
        IL_000e: dup
        IL_000f: ldarg.1
        IL_0010: stfld string Extensions/'<M>d__1'::'<>3__s'
        IL_0015: ret
    } // end of method Extensions::M
} // end of class Extensions
""").Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension(object o)
    {
        System.Collections.Generic.IEnumerable<string> M(string s)
        {
            yield return o + s;
        }
    }

    extension(object o)
    {
        System.Collections.Generic.IEnumerable<string> M(string s, int x)
        {
            yield return o + s;
        }
    }
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();

        var src3 = """
class Program
{
    static void Main()
    {
        foreach (var s in Test("1"))
            System.Console.Write(s);
        foreach (var s in "3".M2("4"))
            System.Console.Write(s);
    }

    static System.Collections.Generic.IEnumerable<string> Test(object o)
    {
        return o.M("2");
    }
}

static class Extensions
{
    extension(object o)
    {
        public System.Collections.Generic.IEnumerable<string> M2(string s) => o.M(s);
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        var verifier3 = CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();

        var testIL =
@"
{
  // Code size       17 (0x11)
  .maxstack  2
  .locals init (System.Collections.Generic.IEnumerable<string> V_0)
  IL_0000:  nop
  IL_0001:  ldarg.0
  IL_0002:  ldstr      ""2""
  IL_0007:  call       ""System.Collections.Generic.IEnumerable<string> Extensions.M(object, string)""
  IL_000c:  stloc.0
  IL_000d:  br.s       IL_000f
  IL_000f:  ldloc.0
  IL_0010:  ret
}
";
        verifier3.VerifyIL("Program.Test", testIL);

        var m2IL =
@"
{
  // Code size        8 (0x8)
  .maxstack  2
  IL_0000:  ldarg.0
  IL_0001:  ldarg.1
  IL_0002:  call       ""System.Collections.Generic.IEnumerable<string> Extensions.M(object, string)""
  IL_0007:  ret
}
";
        verifier3.VerifyIL("Extensions.M2", m2IL);

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        verifier3 = CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();

        verifier3.VerifyIL("Program.Test", testIL);
        verifier3.VerifyIL("Extensions.M2", m2IL);
    }

    [Fact]
    public void Implementation_InstanceMethod_06_Async()
    {
        var src1 = """
public static class Extensions
{
    extension(object o)
    {
        public async System.Threading.Tasks.Task<string> M(string s)
        {
            await System.Threading.Tasks.Task.Yield();
            return o + s;
        }
    }
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1, symbolValidator: (m) =>
        {
            MethodSymbol implementation = m.ContainingAssembly.GetTypeByMetadataName("Extensions").GetMembers().OfType<MethodSymbol>().Single();
            AssertEx.Equal("System.Runtime.CompilerServices.AsyncStateMachineAttribute(typeof(Extensions.<M>d__1))", implementation.GetAttributes().Single().ToString());
        }).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x20b3
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig 
            instance class [mscorlib]System.Threading.Tasks.Task`1<string> M (
                string s
            ) cil managed 
        {
            // Method begins at RVA 0x20b5
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    .class nested private auto ansi sealed beforefieldinit '<M>d__1'
        extends [mscorlib]System.ValueType
        implements [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public int32 '<>1__state'
        .field public valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> '<>t__builder'
        .field public object o
        .field public string s
        .field private valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter '<>u__1'
        // Methods
        .method private final hidebysig newslot virtual 
            instance void MoveNext () cil managed 
        {
            .override method instance void [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine::MoveNext()
            // Method begins at RVA 0x20b8
            // Code size 178 (0xb2)
            .maxstack 3
            .locals init (
                [0] int32,
                [1] string,
                [2] valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter,
                [3] valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable,
                [4] class [mscorlib]System.Exception
            )
            IL_0000: ldarg.0
            IL_0001: ldfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_0006: stloc.0
            .try
            {
                IL_0007: ldloc.0
                IL_0008: brfalse.s IL_0041
                IL_000a: call valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable [mscorlib]System.Threading.Tasks.Task::Yield()
                IL_000f: stloc.3
                IL_0010: ldloca.s 3
                IL_0012: call instance valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter [mscorlib]System.Runtime.CompilerServices.YieldAwaitable::GetAwaiter()
                IL_0017: stloc.2
                IL_0018: ldloca.s 2
                IL_001a: call instance bool [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter::get_IsCompleted()
                IL_001f: brtrue.s IL_005d
                IL_0021: ldarg.0
                IL_0022: ldc.i4.0
                IL_0023: dup
                IL_0024: stloc.0
                IL_0025: stfld int32 Extensions/'<M>d__1'::'<>1__state'
                IL_002a: ldarg.0
                IL_002b: ldloc.2
                IL_002c: stfld valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter Extensions/'<M>d__1'::'<>u__1'
                IL_0031: ldarg.0
                IL_0032: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
                IL_0037: ldloca.s 2
                IL_0039: ldarg.0
                IL_003a: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::AwaitUnsafeOnCompleted<valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter, valuetype Extensions/'<M>d__1'>(!!0&, !!1&)
                IL_003f: leave.s IL_00b1
                IL_0041: ldarg.0
                IL_0042: ldfld valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter Extensions/'<M>d__1'::'<>u__1'
                IL_0047: stloc.2
                IL_0048: ldarg.0
                IL_0049: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter Extensions/'<M>d__1'::'<>u__1'
                IL_004e: initobj [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter
                IL_0054: ldarg.0
                IL_0055: ldc.i4.m1
                IL_0056: dup
                IL_0057: stloc.0
                IL_0058: stfld int32 Extensions/'<M>d__1'::'<>1__state'
                IL_005d: ldloca.s 2
                IL_005f: call instance void [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter::GetResult()
                IL_0064: ldarg.0
                IL_0065: ldfld object Extensions/'<M>d__1'::o
                IL_006a: dup
                IL_006b: brtrue.s IL_0071
                IL_006d: pop
                IL_006e: ldnull
                IL_006f: br.s IL_0076
                IL_0071: callvirt instance string [mscorlib]System.Object::ToString()
                IL_0076: ldarg.0
                IL_0077: ldfld string Extensions/'<M>d__1'::s
                IL_007c: call string [mscorlib]System.String::Concat(string, string)
                IL_0081: stloc.1
                IL_0082: leave.s IL_009d
            } // end .try
            catch [mscorlib]System.Exception
            {
                IL_0084: stloc.s 4
                IL_0086: ldarg.0
                IL_0087: ldc.i4.s -2
                IL_0089: stfld int32 Extensions/'<M>d__1'::'<>1__state'
                IL_008e: ldarg.0
                IL_008f: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
                IL_0094: ldloc.s 4
                IL_0096: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::SetException(class [mscorlib]System.Exception)
                IL_009b: leave.s IL_00b1
            } // end handler
            IL_009d: ldarg.0
            IL_009e: ldc.i4.s -2
            IL_00a0: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_00a5: ldarg.0
            IL_00a6: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
            IL_00ab: ldloc.1
            IL_00ac: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::SetResult(!0)
            IL_00b1: ret
        } // end of method '<M>d__1'::MoveNext
        .method private final hidebysig newslot virtual 
            instance void SetStateMachine (
                class [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine stateMachine
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance void [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine::SetStateMachine(class [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine)
            // Method begins at RVA 0x2188
            // Code size 13 (0xd)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
            IL_0006: ldarg.1
            IL_0007: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::SetStateMachine(class [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine)
            IL_000c: ret
        } // end of method '<M>d__1'::SetStateMachine
    } // end of class <M>d__1
    // Methods
    .method public hidebysig specialname static 
        class [mscorlib]System.Threading.Tasks.Task`1<string> M (
            object o,
            string s
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.AsyncStateMachineAttribute::.ctor(class [mscorlib]System.Type) = (
            01 00 12 45 78 74 65 6e 73 69 6f 6e 73 2b 3c 4d
            3e 64 5f 5f 31 00 00
        )
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2068
        // Code size 63 (0x3f)
        .maxstack 2
        .locals init (
            [0] valuetype Extensions/'<M>d__1'
        )
        IL_0000: ldloca.s 0
        IL_0002: call valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<!0> valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::Create()
        IL_0007: stfld valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
        IL_000c: ldloca.s 0
        IL_000e: ldarg.0
        IL_000f: stfld object Extensions/'<M>d__1'::o
        IL_0014: ldloca.s 0
        IL_0016: ldarg.1
        IL_0017: stfld string Extensions/'<M>d__1'::s
        IL_001c: ldloca.s 0
        IL_001e: ldc.i4.m1
        IL_001f: stfld int32 Extensions/'<M>d__1'::'<>1__state'
        IL_0024: ldloca.s 0
        IL_0026: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
        IL_002b: ldloca.s 0
        IL_002d: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::Start<valuetype Extensions/'<M>d__1'>(!!0&)
        IL_0032: ldloca.s 0
        IL_0034: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
        IL_0039: call instance class [mscorlib]System.Threading.Tasks.Task`1<!0> valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::get_Task()
        IL_003e: ret
    } // end of method Extensions::M
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension(object o)
    {
        async System.Threading.Tasks.Task<string> M(string s)
        {
            await System.Threading.Tasks.Task.Yield();
            return o + s;
        }
    }

    extension(object o)
    {
        async System.Threading.Tasks.Task<string> M(string s, int x)
        {
            await System.Threading.Tasks.Task.Yield();
            return o + s;
        }
    }
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1").Result);
        System.Console.Write("3".M2("4").Result);
    }

    async static System.Threading.Tasks.Task<string> Test(object o)
    {
        await System.Threading.Tasks.Task.Yield();
        return await o.M("2");
    }
}

static class Extensions
{
    extension(object o)
    {
        async public System.Threading.Tasks.Task<string> M2(string s)
        {
            await System.Threading.Tasks.Task.Yield();
            return await o.M(s);
        }
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_InstanceMethod_07_Generic()
    {
        var src1 = """
public static class Extensions
{
    extension<T>(C<T> o)
    {
        public string M<U>(T t, U u)
        {
            return o.GetString() + u.ToString() + t.ToString();
        }
    }
}

public class C<T>(string v)
{
    public string GetString() => v;
}
""";
        var comp1 = CreateCompilation(src1);

        MethodSymbol implementation = comp1.GetTypeByMetadataName("Extensions").GetMembers().OfType<MethodSymbol>().Single();
        Assert.True(implementation.IsStatic);
        Assert.Equal(MethodKind.Ordinary, implementation.MethodKind);
        Assert.Equal(3, implementation.ParameterCount);
        AssertEx.Equal("System.String Extensions.M<T, U>(this C<T> o, T t, U u)", implementation.ToTestDisplayString());
        Assert.True(implementation.IsImplicitlyDeclared);
        Assert.True(implementation.IsExtensionMethod);
        Assert.True(implementation.HasSpecialName);
        Assert.False(implementation.HasRuntimeSpecialName);

        var verifier1 = CompileAndVerify(comp1).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<T>
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                class C`1<!T> o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x20a5
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
        .method public hidebysig 
            instance string M<U> (
                !T t,
                !!U u
            ) cil managed 
        {
            // Method begins at RVA 0x20a7
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0`1'::M
    } // end of class <>E__0`1
    // Methods
    .method public hidebysig specialname static 
        string M<T, U> (
            class C`1<!!T> o,
            !!T t,
            !!U u
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 38 (0x26)
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: callvirt instance string class C`1<!!T>::GetString()
        IL_0006: ldarga.s u
        IL_0008: constrained. !!U
        IL_000e: callvirt instance string [mscorlib]System.Object::ToString()
        IL_0013: ldarga.s t
        IL_0015: constrained. !!T
        IL_001b: callvirt instance string [mscorlib]System.Object::ToString()
        IL_0020: call string [mscorlib]System.String::Concat(string, string, string)
        IL_0025: ret
    } // end of method Extensions::M
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test(new C<string>("1"), "2", 3));
        System.Console.Write(new C<string>("4").M2("5", 6));
    }

    static string Test<T, U>(C<T> o, T t, U u)
    {
        return o.M(t, u);
    }
}

static class Extensions
{
    extension<T>(C<T> o)
    {
        public string M2<U>(T t, U u) => o.M(t, u);
    }
}
""";

        var comp1MetadataReference = comp1.ToMetadataReference();
        var comp3 = CreateCompilation(src3, references: [comp1MetadataReference], options: TestOptions.DebugExe);
        var verifier3 = CompileAndVerify(comp3, expectedOutput: "132465").VerifyDiagnostics();

        var testIL =
@"
{
  // Code size       14 (0xe)
  .maxstack  3
  .locals init (string V_0)
  IL_0000:  nop
  IL_0001:  ldarg.0
  IL_0002:  ldarg.1
  IL_0003:  ldarg.2
  IL_0004:  call       ""string Extensions.M<T, U>(C<T>, T, U)""
  IL_0009:  stloc.0
  IL_000a:  br.s       IL_000c
  IL_000c:  ldloc.0
  IL_000d:  ret
}
";
        verifier3.VerifyIL("Program.Test<T, U>(C<T>, T, U)", testIL);

        var m2IL =
@"
{
  // Code size        9 (0x9)
  .maxstack  3
  IL_0000:  ldarg.0
  IL_0001:  ldarg.1
  IL_0002:  ldarg.2
  IL_0003:  call       ""string Extensions.M<T, U>(C<T>, T, U)""
  IL_0008:  ret
}
";
        verifier3.VerifyIL("Extensions.M2<T, U>(this C<T>, T, U)", m2IL);

        var comp1ImageReference = comp1.EmitToImageReference();
        comp3 = CreateCompilation(src3, references: [comp1ImageReference], options: TestOptions.DebugExe);
        verifier3 = CompileAndVerify(comp3, expectedOutput: "132465").VerifyDiagnostics();

        verifier3.VerifyIL("Program.Test<T, U>(C<T>, T, U)", testIL);
        verifier3.VerifyIL("Extensions.M2<T, U>(this C<T>, T, U)", m2IL);

        if (!CompilationExtensions.EnableVerifyUsedAssemblies) // Tracked by https://github.com/dotnet/roslyn/issues/77542
        {
            src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test(new C<string>("1"), "2", 3));
        System.Console.Write(new C<string>("4").M2("5", 6));
    }

    static string Test<T, U>(C<T> o, T t, U u)
    {
        System.Func<T, U, string> d = o.M;
        return d(t, u);
    }
}

static class Extensions
{
    extension<T>(C<T> o)
    {
        public string M2<U>(T t, U u) => new System.Func<T, U, string>(o.M)(t, u);
    }
}
""";

            comp3 = CreateCompilation(src3, references: [comp1MetadataReference], options: TestOptions.DebugExe);
            verifier3 = CompileAndVerify(comp3, expectedOutput: "132465").VerifyDiagnostics();

            testIL =
@"
{
  // Code size       27 (0x1b)
  .maxstack  3
  .locals init (System.Func<T, U, string> V_0, //d
            string V_1)
  IL_0000:  nop
  IL_0001:  ldarg.0
  IL_0002:  ldftn      ""string Extensions.M<T, U>(C<T>, T, U)""
  IL_0008:  newobj     ""System.Func<T, U, string>..ctor(object, System.IntPtr)""
  IL_000d:  stloc.0
  IL_000e:  ldloc.0
  IL_000f:  ldarg.1
  IL_0010:  ldarg.2
  IL_0011:  callvirt   ""string System.Func<T, U, string>.Invoke(T, U)""
  IL_0016:  stloc.1
  IL_0017:  br.s       IL_0019
  IL_0019:  ldloc.1
  IL_001a:  ret
}
";
            verifier3.VerifyIL("Program.Test<T, U>(C<T>, T, U)", testIL);

            m2IL =
@"
{
  // Code size       20 (0x14)
  .maxstack  3
  IL_0000:  ldarg.0
  IL_0001:  ldftn      ""string Extensions.M<T, U>(C<T>, T, U)""
  IL_0007:  newobj     ""System.Func<T, U, string>..ctor(object, System.IntPtr)""
  IL_000c:  ldarg.1
  IL_000d:  ldarg.2
  IL_000e:  callvirt   ""string System.Func<T, U, string>.Invoke(T, U)""
  IL_0013:  ret
}
";
            verifier3.VerifyIL("Extensions.M2<T, U>(this C<T>, T, U)", m2IL);

            comp3 = CreateCompilation(src3, references: [comp1ImageReference], options: TestOptions.DebugExe);

            verifier3 = CompileAndVerify(comp3, expectedOutput: "132465").VerifyDiagnostics();

            verifier3.VerifyIL("Program.Test<T, U>(C<T>, T, U)", testIL);
            verifier3.VerifyIL("Extensions.M2<T, U>(this C<T>, T, U)", m2IL);
        }
    }

    [Fact]
    public void Implementation_InstanceMethod_08_WithLocalFunction_Generic()
    {
        var src1 = """
public static class Extensions
{
    extension<T>(C<T> o)
    {
        public C<U> M<U>(T t1, U u1)
        {
            C<U> local<X, Y, Z>(T t2, U u2, X x2, Y y2, Z z2)
            {
                return new C<U>(o.GetString() + u1.ToString() + t1.ToString() + u2.ToString() + t2.ToString() + x2.ToString() + y2.ToString() + z2.ToString());
            };

            return local(t1, u1, 0, t1, u1);
        }
    }
}

public class C<T>(string val)
{
    public string GetString() => val;
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<T>
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                class C`1<!T> o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x216d
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
        .method public hidebysig 
            instance class C`1<!!U> M<U> (
                !T t1,
                !!U u1
            ) cil managed 
        {
            // Method begins at RVA 0x216f
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0`1'::M
    } // end of class <>E__0`1
    .class nested private auto ansi sealed beforefieldinit '<>c__DisplayClass1_0`2'<T, U>
        extends [mscorlib]System.ValueType
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public class C`1<!T> o
        .field public !U u1
        .field public !T t1
    } // end of class <>c__DisplayClass1_0`2
    // Methods
    .method public hidebysig specialname static 
        class C`1<!!U> M<T, U> (
            class C`1<!!T> o,
            !!T t1,
            !!U u1
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2068
        // Code size 57 (0x39)
        .maxstack 6
        .locals init (
            [0] valuetype Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>
        )
        IL_0000: ldloca.s 0
        IL_0002: ldarg.0
        IL_0003: stfld class C`1<!0> valuetype Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::o
        IL_0008: ldloca.s 0
        IL_000a: ldarg.2
        IL_000b: stfld !1 valuetype Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::u1
        IL_0010: ldloca.s 0
        IL_0012: ldarg.1
        IL_0013: stfld !0 valuetype Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::t1
        IL_0018: ldloc.0
        IL_0019: ldfld !0 valuetype Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::t1
        IL_001e: ldloc.0
        IL_001f: ldfld !1 valuetype Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::u1
        IL_0024: ldc.i4.0
        IL_0025: ldloc.0
        IL_0026: ldfld !0 valuetype Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::t1
        IL_002b: ldloc.0
        IL_002c: ldfld !1 valuetype Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::u1
        IL_0031: ldloca.s 0
        IL_0033: call class C`1<!!1> Extensions::'<M>b__1_0'<!!T, !!U, int32, !!T, !!U>(!!0, !!1, !!2, !!3, !!4, valuetype Extensions/'<>c__DisplayClass1_0`2'<!!0, !!1>&)
        IL_0038: ret
    } // end of method Extensions::M
    .method assembly hidebysig static 
        class C`1<!!U> '<M>b__1_0'<T, U, X, Y, Z> (
            !!T t2,
            !!U u2,
            !!X x2,
            !!Y y2,
            !!Z z2,
            valuetype Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>& ''
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x20b0
        // Code size 154 (0x9a)
        .maxstack 4
        IL_0000: ldc.i4.8
        IL_0001: newarr [mscorlib]System.String
        IL_0006: dup
        IL_0007: ldc.i4.0
        IL_0008: ldarg.s 5
        IL_000a: ldfld class C`1<!0> valuetype Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::o
        IL_000f: callvirt instance string class C`1<!!T>::GetString()
        IL_0014: stelem.ref
        IL_0015: dup
        IL_0016: ldc.i4.1
        IL_0017: ldarg.s 5
        IL_0019: ldflda !1 valuetype Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::u1
        IL_001e: constrained. !!U
        IL_0024: callvirt instance string [mscorlib]System.Object::ToString()
        IL_0029: stelem.ref
        IL_002a: dup
        IL_002b: ldc.i4.2
        IL_002c: ldarg.s 5
        IL_002e: ldflda !0 valuetype Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::t1
        IL_0033: constrained. !!T
        IL_0039: callvirt instance string [mscorlib]System.Object::ToString()
        IL_003e: stelem.ref
        IL_003f: dup
        IL_0040: ldc.i4.3
        IL_0041: ldarga.s u2
        IL_0043: constrained. !!U
        IL_0049: callvirt instance string [mscorlib]System.Object::ToString()
        IL_004e: stelem.ref
        IL_004f: dup
        IL_0050: ldc.i4.4
        IL_0051: ldarga.s t2
        IL_0053: constrained. !!T
        IL_0059: callvirt instance string [mscorlib]System.Object::ToString()
        IL_005e: stelem.ref
        IL_005f: dup
        IL_0060: ldc.i4.5
        IL_0061: ldarga.s x2
        IL_0063: constrained. !!X
        IL_0069: callvirt instance string [mscorlib]System.Object::ToString()
        IL_006e: stelem.ref
        IL_006f: dup
        IL_0070: ldc.i4.6
        IL_0071: ldarga.s y2
        IL_0073: constrained. !!Y
        IL_0079: callvirt instance string [mscorlib]System.Object::ToString()
        IL_007e: stelem.ref
        IL_007f: dup
        IL_0080: ldc.i4.7
        IL_0081: ldarga.s z2
        IL_0083: constrained. !!Z
        IL_0089: callvirt instance string [mscorlib]System.Object::ToString()
        IL_008e: stelem.ref
        IL_008f: call string [mscorlib]System.String::Concat(string[])
        IL_0094: newobj instance void class C`1<!!U>::.ctor(string)
        IL_0099: ret
    } // end of method Extensions::'<M>b__1_0'
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension<T>(C<T> o)
    {
        string M<U>(T t1, U u1)
        {
            U local<X, Y, Z>(T t2, U u2, X x2, Y y2, Z z2)
            {
                _ = o.GetString() + u1.ToString() + t1.ToString() + u2.ToString() + t2.ToString() + x2.ToString() + y2.ToString() + z2.ToString();
                return u2;
            };

            return local(t1, u1, 0, t1, u1).ToString();
        }
    }

    extension<T>(C<T> o)
    {
        string M<U>(T t1, U u1, int x)
        {
            U local<X, Y, Z>(T t2, U u2, X x2, Y y2, Z z2)
            {
                _ = o.GetString() + u1.ToString() + t1.ToString() + u2.ToString() + t2.ToString() + x2.ToString() + y2.ToString() + z2.ToString();
                return u2;
            };

            return local(t1, u1, 0, t1, u1).ToString();
        }
    }
}

public class C<T>
{
    public string GetString() => null;
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test(new C<long>("1"), 2, "3").GetString());
        System.Console.Write(new C<long>("4").M2(5, "6").GetString());
    }

    static C<U> Test<T, U>(C<T> o, T t1, U u1)
    {
        C<X> local<X>(T t2, X x2)
        {
            return o.M(t2, x2);
        };

        return local(t1, u1);
    }
}

static class Extensions
{
    extension<T>(C<T> o)
    {
        public C<U> M2<U>(T t1, U u1)
        {
            C<X> local<X>(T t2, X x2)
            {
                return o.M(t2, x2);
            };

            return local(t1, u1);
        }
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1323202346565056").VerifyDiagnostics();

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1323202346565056").VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_InstanceMethod_09_WithLambda_Generic()
    {
        var src1 = """
public static class Extensions
{
    extension<T>(C<T> o)
    {
        public C<U> M<U>(T t1, U u1)
        {
            System.Func<T, U, C<U>> local = (T t2, U u2) =>
            {
                return new C<U>(o.GetString() + u1.ToString() + t1.ToString() + u2.ToString() + t2.ToString());
            };

            return local(t1, u1);
        }
    }
}

public class C<T>(string val)
{
    public string GetString() => val;
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<T>
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                class C`1<!T> o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x20c4
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
        .method public hidebysig 
            instance class C`1<!!U> M<U> (
                !T t1,
                !!U u1
            ) cil managed 
        {
            // Method begins at RVA 0x20c6
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0`1'::M
    } // end of class <>E__0`1
    .class nested private auto ansi sealed beforefieldinit '<>c__DisplayClass1_0`2'<T, U>
        extends [mscorlib]System.Object
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public class C`1<!T> o
        .field public !U u1
        .field public !T t1
        // Methods
        .method public hidebysig specialname rtspecialname 
            instance void .ctor () cil managed 
        {
            // Method begins at RVA 0x20c9
            // Code size 7 (0x7)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: call instance void [mscorlib]System.Object::.ctor()
            IL_0006: ret
        } // end of method '<>c__DisplayClass1_0`2'::.ctor
        .method assembly hidebysig 
            instance class C`1<!U> '<M>b__0' (
                !T t2,
                !U u2
            ) cil managed 
        {
            // Method begins at RVA 0x20d4
            // Code size 103 (0x67)
            .maxstack 4
            IL_0000: ldc.i4.5
            IL_0001: newarr [mscorlib]System.String
            IL_0006: dup
            IL_0007: ldc.i4.0
            IL_0008: ldarg.0
            IL_0009: ldfld class C`1<!0> class Extensions/'<>c__DisplayClass1_0`2'<!T, !U>::o
            IL_000e: callvirt instance string class C`1<!T>::GetString()
            IL_0013: stelem.ref
            IL_0014: dup
            IL_0015: ldc.i4.1
            IL_0016: ldarg.0
            IL_0017: ldflda !1 class Extensions/'<>c__DisplayClass1_0`2'<!T, !U>::u1
            IL_001c: constrained. !U
            IL_0022: callvirt instance string [mscorlib]System.Object::ToString()
            IL_0027: stelem.ref
            IL_0028: dup
            IL_0029: ldc.i4.2
            IL_002a: ldarg.0
            IL_002b: ldflda !0 class Extensions/'<>c__DisplayClass1_0`2'<!T, !U>::t1
            IL_0030: constrained. !T
            IL_0036: callvirt instance string [mscorlib]System.Object::ToString()
            IL_003b: stelem.ref
            IL_003c: dup
            IL_003d: ldc.i4.3
            IL_003e: ldarga.s u2
            IL_0040: constrained. !U
            IL_0046: callvirt instance string [mscorlib]System.Object::ToString()
            IL_004b: stelem.ref
            IL_004c: dup
            IL_004d: ldc.i4.4
            IL_004e: ldarga.s t2
            IL_0050: constrained. !T
            IL_0056: callvirt instance string [mscorlib]System.Object::ToString()
            IL_005b: stelem.ref
            IL_005c: call string [mscorlib]System.String::Concat(string[])
            IL_0061: newobj instance void class C`1<!U>::.ctor(string)
            IL_0066: ret
        } // end of method '<>c__DisplayClass1_0`2'::'<M>b__0'
    } // end of class <>c__DisplayClass1_0`2
    // Methods
    .method public hidebysig specialname static 
        class C`1<!!U> M<T, U> (
            class C`1<!!T> o,
            !!T t1,
            !!U u1
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2068
        // Code size 57 (0x39)
        .maxstack 3
        .locals init (
            [0] class Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>
        )
        IL_0000: newobj instance void class Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::.ctor()
        IL_0005: stloc.0
        IL_0006: ldloc.0
        IL_0007: ldarg.0
        IL_0008: stfld class C`1<!0> class Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::o
        IL_000d: ldloc.0
        IL_000e: ldarg.2
        IL_000f: stfld !1 class Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::u1
        IL_0014: ldloc.0
        IL_0015: ldarg.1
        IL_0016: stfld !0 class Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::t1
        IL_001b: ldloc.0
        IL_001c: ldftn instance class C`1<!1> class Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::'<M>b__0'(!0, !1)
        IL_0022: newobj instance void class [mscorlib]System.Func`3<!!T, !!U, class C`1<!!U>>::.ctor(object, native int)
        IL_0027: ldloc.0
        IL_0028: ldfld !0 class Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::t1
        IL_002d: ldloc.0
        IL_002e: ldfld !1 class Extensions/'<>c__DisplayClass1_0`2'<!!T, !!U>::u1
        IL_0033: callvirt instance !2 class [mscorlib]System.Func`3<!!T, !!U, class C`1<!!U>>::Invoke(!0, !1)
        IL_0038: ret
    } // end of method Extensions::M
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension<T>(C<T> o)
    {
        string M<U>(T t1, U u1)
        {
            System.Func<T, U, U> local = (T t2, U u2) =>
            {
                _ = o.GetString() + u1.ToString() + t1.ToString() + u2.ToString() + t2.ToString();
                return u2;
            };

            return local(t1, u1).ToString();
        }
    }

    extension<T>(C<T> o)
    {
        string M<U>(T t1, U u1, int x)
        {
            System.Func<T, U, U> local = (T t2, U u2) =>
            {
                _ = o.GetString() + u1.ToString() + t1.ToString() + u2.ToString() + t2.ToString();
                return u2;
            };

            return local(t1, u1).ToString();
        }
    }
}

public class C<T>
{
    public string GetString() => null;
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test(new C<long>("1"), 2, "3").GetString());
        System.Console.Write(new C<long>("4").M2(5, "6").GetString());
    }

    static C<U> Test<T, U>(C<T> o, T t1, U u1)
    {
        System.Func<T, U, C<U>> local = (T t2, U u2) =>
        {
            return o.M(t2, u2);
        };

        return local(t1, u1);
    }
}

static class Extensions
{
    extension<T>(C<T> o)
    {
        public C<U> M2<U>(T t1, U u1)
        {
            System.Func<T, U, C<U>> local = (T t2, U u2) =>
            {
                return o.M(t2, u2);
            };

            return local(t1, u1);
        }
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1323246565").VerifyDiagnostics();

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1323246565").VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_InstanceMethod_10_Iterator_Generic()
    {
        var src1 = """
public static class Extensions
{
    extension<T>(C<T> o)
    {
        public System.Collections.Generic.IEnumerable<string> M<U>(T t1, U u1)
        {
            yield return o.GetString() + u1.ToString() + t1.ToString();
        }
    }
}

public class C<T>(string val)
{
    public string GetString() => val;
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1, symbolValidator: (m) =>
        {
            MethodSymbol implementation = m.ContainingAssembly.GetTypeByMetadataName("Extensions").GetMembers().OfType<MethodSymbol>().Single();
            AssertEx.Equal("System.Runtime.CompilerServices.IteratorStateMachineAttribute(typeof(Extensions.<M>d__1<,>))", implementation.GetAttributes().Single().ToString());
        }).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", ("""
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<T>
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                class C`1<!T> o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x209c
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
        .method public hidebysig 
            instance class [mscorlib]System.Collections.Generic.IEnumerable`1<string> M<U> (
                !T t1,
                !!U u1
            ) cil managed 
        {
            // Method begins at RVA 0x209e
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0`1'::M
    } // end of class <>E__0`1
    .class nested private auto ansi sealed beforefieldinit '<M>d__1`2'<T, U>
        extends [mscorlib]System.Object
        implements class [mscorlib]System.Collections.Generic.IEnumerable`1<string>,
                   [mscorlib]System.Collections.IEnumerable,
                   class [mscorlib]System.Collections.Generic.IEnumerator`1<string>,

""" +
        (ExecutionConditionUtil.IsMonoOrCoreClr ?
"""
                   [mscorlib]System.Collections.IEnumerator,
                   [mscorlib]System.IDisposable

""" :
"""
                   [mscorlib]System.IDisposable,
                   [mscorlib]System.Collections.IEnumerator

""") +
"""
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field private int32 '<>1__state'
        .field private string '<>2__current'
        .field private int32 '<>l__initialThreadId'
        .field private class C`1<!T> o
        .field public class C`1<!T> '<>3__o'
        .field private !U u1
        .field public !U '<>3__u1'
        .field private !T t1
        .field public !T '<>3__t1'
        // Methods
        .method public hidebysig specialname rtspecialname 
            instance void .ctor (
                int32 '<>1__state'
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x20a1
            // Code size 25 (0x19)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: call instance void [mscorlib]System.Object::.ctor()
            IL_0006: ldarg.0
            IL_0007: ldarg.1
            IL_0008: stfld int32 class Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
            IL_000d: ldarg.0
            IL_000e: call int32 [mscorlib]System.Environment::get_CurrentManagedThreadId()
            IL_0013: stfld int32 class Extensions/'<M>d__1`2'<!T, !U>::'<>l__initialThreadId'
            IL_0018: ret
        } // end of method '<M>d__1`2'::.ctor
        .method private final hidebysig newslot virtual 
            instance void System.IDisposable.Dispose () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance void [mscorlib]System.IDisposable::Dispose()
            // Method begins at RVA 0x20bb
            // Code size 9 (0x9)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldc.i4.s -2
            IL_0003: stfld int32 class Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
            IL_0008: ret
        } // end of method '<M>d__1`2'::System.IDisposable.Dispose
        .method private final hidebysig newslot virtual 
            instance bool MoveNext () cil managed 
        {
            .override method instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
            // Method begins at RVA 0x20c8
            // Code size 97 (0x61)
            .maxstack 4
            .locals init (
                [0] int32
            )
            IL_0000: ldarg.0
            IL_0001: ldfld int32 class Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
            IL_0006: stloc.0
            IL_0007: ldloc.0
            IL_0008: brfalse.s IL_0010
            IL_000a: ldloc.0
            IL_000b: ldc.i4.1
            IL_000c: beq.s IL_0058
            IL_000e: ldc.i4.0
            IL_000f: ret
            IL_0010: ldarg.0
            IL_0011: ldc.i4.m1
            IL_0012: stfld int32 class Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
            IL_0017: ldarg.0
            IL_0018: ldarg.0
            IL_0019: ldfld class C`1<!0> class Extensions/'<M>d__1`2'<!T, !U>::o
            IL_001e: callvirt instance string class C`1<!T>::GetString()
            IL_0023: ldarg.0
            IL_0024: ldflda !1 class Extensions/'<M>d__1`2'<!T, !U>::u1
            IL_0029: constrained. !U
            IL_002f: callvirt instance string [mscorlib]System.Object::ToString()
            IL_0034: ldarg.0
            IL_0035: ldflda !0 class Extensions/'<M>d__1`2'<!T, !U>::t1
            IL_003a: constrained. !T
            IL_0040: callvirt instance string [mscorlib]System.Object::ToString()
            IL_0045: call string [mscorlib]System.String::Concat(string, string, string)
            IL_004a: stfld string class Extensions/'<M>d__1`2'<!T, !U>::'<>2__current'
            IL_004f: ldarg.0
            IL_0050: ldc.i4.1
            IL_0051: stfld int32 class Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
            IL_0056: ldc.i4.1
            IL_0057: ret
            IL_0058: ldarg.0
            IL_0059: ldc.i4.m1
            IL_005a: stfld int32 class Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
            IL_005f: ldc.i4.0
            IL_0060: ret
        } // end of method '<M>d__1`2'::MoveNext
        .method private final hidebysig specialname newslot virtual 
            instance string 'System.Collections.Generic.IEnumerator<System.String>.get_Current' () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<string>::get_Current()
            // Method begins at RVA 0x2135
            // Code size 7 (0x7)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldfld string class Extensions/'<M>d__1`2'<!T, !U>::'<>2__current'
            IL_0006: ret
        } // end of method '<M>d__1`2'::'System.Collections.Generic.IEnumerator<System.String>.get_Current'
        .method private final hidebysig newslot virtual 
            instance void System.Collections.IEnumerator.Reset () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance void [mscorlib]System.Collections.IEnumerator::Reset()
            // Method begins at RVA 0x213d
            // Code size 6 (0x6)
            .maxstack 8
            IL_0000: newobj instance void [mscorlib]System.NotSupportedException::.ctor()
            IL_0005: throw
        } // end of method '<M>d__1`2'::System.Collections.IEnumerator.Reset
        .method private final hidebysig specialname newslot virtual 
            instance object System.Collections.IEnumerator.get_Current () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance object [mscorlib]System.Collections.IEnumerator::get_Current()
            // Method begins at RVA 0x2135
            // Code size 7 (0x7)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldfld string class Extensions/'<M>d__1`2'<!T, !U>::'<>2__current'
            IL_0006: ret
        } // end of method '<M>d__1`2'::System.Collections.IEnumerator.get_Current
        .method private final hidebysig newslot virtual 
            instance class [mscorlib]System.Collections.Generic.IEnumerator`1<string> 'System.Collections.Generic.IEnumerable<System.String>.GetEnumerator' () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<string>::GetEnumerator()
            // Method begins at RVA 0x2144
            // Code size 79 (0x4f)
            .maxstack 2
            .locals init (
                [0] class Extensions/'<M>d__1`2'<!T, !U>
            )
            IL_0000: ldarg.0
            IL_0001: ldfld int32 class Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
            IL_0006: ldc.i4.s -2
            IL_0008: bne.un.s IL_0022
            IL_000a: ldarg.0
            IL_000b: ldfld int32 class Extensions/'<M>d__1`2'<!T, !U>::'<>l__initialThreadId'
            IL_0010: call int32 [mscorlib]System.Environment::get_CurrentManagedThreadId()
            IL_0015: bne.un.s IL_0022
            IL_0017: ldarg.0
            IL_0018: ldc.i4.0
            IL_0019: stfld int32 class Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
            IL_001e: ldarg.0
            IL_001f: stloc.0
            IL_0020: br.s IL_0029
            IL_0022: ldc.i4.0
            IL_0023: newobj instance void class Extensions/'<M>d__1`2'<!T, !U>::.ctor(int32)
            IL_0028: stloc.0
            IL_0029: ldloc.0
            IL_002a: ldarg.0
            IL_002b: ldfld class C`1<!0> class Extensions/'<M>d__1`2'<!T, !U>::'<>3__o'
            IL_0030: stfld class C`1<!0> class Extensions/'<M>d__1`2'<!T, !U>::o
            IL_0035: ldloc.0
            IL_0036: ldarg.0
            IL_0037: ldfld !0 class Extensions/'<M>d__1`2'<!T, !U>::'<>3__t1'
            IL_003c: stfld !0 class Extensions/'<M>d__1`2'<!T, !U>::t1
            IL_0041: ldloc.0
            IL_0042: ldarg.0
            IL_0043: ldfld !1 class Extensions/'<M>d__1`2'<!T, !U>::'<>3__u1'
            IL_0048: stfld !1 class Extensions/'<M>d__1`2'<!T, !U>::u1
            IL_004d: ldloc.0
            IL_004e: ret
        } // end of method '<M>d__1`2'::'System.Collections.Generic.IEnumerable<System.String>.GetEnumerator'
        .method private final hidebysig newslot virtual 
            instance class [mscorlib]System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance class [mscorlib]System.Collections.IEnumerator [mscorlib]System.Collections.IEnumerable::GetEnumerator()
            // Method begins at RVA 0x219f
            // Code size 7 (0x7)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: call instance class [mscorlib]System.Collections.Generic.IEnumerator`1<string> class Extensions/'<M>d__1`2'<!T, !U>::'System.Collections.Generic.IEnumerable<System.String>.GetEnumerator'()
            IL_0006: ret
        } // end of method '<M>d__1`2'::System.Collections.IEnumerable.GetEnumerator
        // Properties
        .property instance string 'System.Collections.Generic.IEnumerator<System.String>.Current'()
        {
            .get instance string Extensions/'<M>d__1`2'::'System.Collections.Generic.IEnumerator<System.String>.get_Current'()
        }
        .property instance object System.Collections.IEnumerator.Current()
        {
            .get instance object Extensions/'<M>d__1`2'::System.Collections.IEnumerator.get_Current()
        }
    } // end of class <M>d__1`2
    // Methods
    .method public hidebysig specialname static 
        class [mscorlib]System.Collections.Generic.IEnumerable`1<string> M<T, U> (
            class C`1<!!T> o,
            !!T t1,
            !!U u1
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.IteratorStateMachineAttribute::.ctor(class [mscorlib]System.Type) = (
            01 00 14 45 78 74 65 6e 73 69 6f 6e 73 2b 3c 4d
            3e 64 5f 5f 31 60 32 00 00
        )
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 29 (0x1d)
        .maxstack 8
        IL_0000: ldc.i4.s -2
        IL_0002: newobj instance void class Extensions/'<M>d__1`2'<!!T, !!U>::.ctor(int32)
        IL_0007: dup
        IL_0008: ldarg.0
        IL_0009: stfld class C`1<!0> class Extensions/'<M>d__1`2'<!!T, !!U>::'<>3__o'
        IL_000e: dup
        IL_000f: ldarg.1
        IL_0010: stfld !0 class Extensions/'<M>d__1`2'<!!T, !!U>::'<>3__t1'
        IL_0015: dup
        IL_0016: ldarg.2
        IL_0017: stfld !1 class Extensions/'<M>d__1`2'<!!T, !!U>::'<>3__u1'
        IL_001c: ret
    } // end of method Extensions::M
} // end of class Extensions
""").Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension<T>(C<T> o)
    {
        System.Collections.Generic.IEnumerable<string> M<U>(T t1, U u1)
        {
            yield return o.GetString() + u1.ToString() + t1.ToString();
        }
    }

    extension<T>(C<T> o)
    {
        System.Collections.Generic.IEnumerable<string> M<U>(T t1, U u1, int x)
        {
            yield return o.GetString() + u1.ToString() + t1.ToString();
        }
    }
}

public class C<T>
{
    public string GetString() => null;
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();

        var src3 = """
class Program
{
    static void Main()
    {
        foreach (var s in Test(new C<long>("1"), 2, "3"))
            System.Console.Write(s);
        foreach (var s in new C<long>("4").M2(5, "6"))
            System.Console.Write(s);
    }

    static System.Collections.Generic.IEnumerable<string> Test<T, U>(C<T> o, T t1, U u1)
    {
        return o.M(t1, u1);
    }
}

static class Extensions
{
    extension<T>(C<T> o)
    {
        public System.Collections.Generic.IEnumerable<string> M2<U>(T t1, U u1) => o.M(t1, u1);
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "132465").VerifyDiagnostics();

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "132465").VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_InstanceMethod_11_Async_Generic()
    {
        var src1 = """
public static class Extensions
{
    extension<T>(C<T> o)
    {
        public async System.Threading.Tasks.Task<string> M<U>(T t1, U u1)
        {
            await System.Threading.Tasks.Task.Yield();
            return o.GetString() + u1.ToString() + t1.ToString();
        }
    }
}

public class C<T>(string val)
{
    public string GetString() => val;
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1, symbolValidator: (m) =>
        {
            MethodSymbol implementation = m.ContainingAssembly.GetTypeByMetadataName("Extensions").GetMembers().OfType<MethodSymbol>().Single();
            AssertEx.Equal("System.Runtime.CompilerServices.AsyncStateMachineAttribute(typeof(Extensions.<M>d__1<,>))", implementation.GetAttributes().Single().ToString());
        }).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<T>
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                class C`1<!T> o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x20d2
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
        .method public hidebysig 
            instance class [mscorlib]System.Threading.Tasks.Task`1<string> M<U> (
                !T t1,
                !!U u1
            ) cil managed 
        {
            // Method begins at RVA 0x20d4
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0`1'::M
    } // end of class <>E__0`1
    .class nested private auto ansi sealed beforefieldinit '<M>d__1`2'<T, U>
        extends [mscorlib]System.ValueType
        implements [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public int32 '<>1__state'
        .field public valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> '<>t__builder'
        .field public class C`1<!T> o
        .field public !U u1
        .field public !T t1
        .field private valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter '<>u__1'
        // Methods
        .method private final hidebysig newslot virtual 
            instance void MoveNext () cil managed 
        {
            .override method instance void [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine::MoveNext()
            // Method begins at RVA 0x20d8
            // Code size 202 (0xca)
            .maxstack 3
            .locals init (
                [0] int32,
                [1] string,
                [2] valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter,
                [3] valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable,
                [4] class [mscorlib]System.Exception
            )
            IL_0000: ldarg.0
            IL_0001: ldfld int32 valuetype Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
            IL_0006: stloc.0
            .try
            {
                IL_0007: ldloc.0
                IL_0008: brfalse.s IL_0044
                IL_000a: call valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable [mscorlib]System.Threading.Tasks.Task::Yield()
                IL_000f: stloc.3
                IL_0010: ldloca.s 3
                IL_0012: call instance valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter [mscorlib]System.Runtime.CompilerServices.YieldAwaitable::GetAwaiter()
                IL_0017: stloc.2
                IL_0018: ldloca.s 2
                IL_001a: call instance bool [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter::get_IsCompleted()
                IL_001f: brtrue.s IL_0060
                IL_0021: ldarg.0
                IL_0022: ldc.i4.0
                IL_0023: dup
                IL_0024: stloc.0
                IL_0025: stfld int32 valuetype Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
                IL_002a: ldarg.0
                IL_002b: ldloc.2
                IL_002c: stfld valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter valuetype Extensions/'<M>d__1`2'<!T, !U>::'<>u__1'
                IL_0031: ldarg.0
                IL_0032: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> valuetype Extensions/'<M>d__1`2'<!T, !U>::'<>t__builder'
                IL_0037: ldloca.s 2
                IL_0039: ldarg.0
                IL_003a: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::AwaitUnsafeOnCompleted<valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter, valuetype Extensions/'<M>d__1`2'<!T, !U>>(!!0&, !!1&)
                IL_003f: leave IL_00c9
                IL_0044: ldarg.0
                IL_0045: ldfld valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter valuetype Extensions/'<M>d__1`2'<!T, !U>::'<>u__1'
                IL_004a: stloc.2
                IL_004b: ldarg.0
                IL_004c: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter valuetype Extensions/'<M>d__1`2'<!T, !U>::'<>u__1'
                IL_0051: initobj [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter
                IL_0057: ldarg.0
                IL_0058: ldc.i4.m1
                IL_0059: dup
                IL_005a: stloc.0
                IL_005b: stfld int32 valuetype Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
                IL_0060: ldloca.s 2
                IL_0062: call instance void [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter::GetResult()
                IL_0067: ldarg.0
                IL_0068: ldfld class C`1<!0> valuetype Extensions/'<M>d__1`2'<!T, !U>::o
                IL_006d: callvirt instance string class C`1<!T>::GetString()
                IL_0072: ldarg.0
                IL_0073: ldflda !1 valuetype Extensions/'<M>d__1`2'<!T, !U>::u1
                IL_0078: constrained. !U
                IL_007e: callvirt instance string [mscorlib]System.Object::ToString()
                IL_0083: ldarg.0
                IL_0084: ldflda !0 valuetype Extensions/'<M>d__1`2'<!T, !U>::t1
                IL_0089: constrained. !T
                IL_008f: callvirt instance string [mscorlib]System.Object::ToString()
                IL_0094: call string [mscorlib]System.String::Concat(string, string, string)
                IL_0099: stloc.1
                IL_009a: leave.s IL_00b5
            } // end .try
            catch [mscorlib]System.Exception
            {
                IL_009c: stloc.s 4
                IL_009e: ldarg.0
                IL_009f: ldc.i4.s -2
                IL_00a1: stfld int32 valuetype Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
                IL_00a6: ldarg.0
                IL_00a7: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> valuetype Extensions/'<M>d__1`2'<!T, !U>::'<>t__builder'
                IL_00ac: ldloc.s 4
                IL_00ae: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::SetException(class [mscorlib]System.Exception)
                IL_00b3: leave.s IL_00c9
            } // end handler
            IL_00b5: ldarg.0
            IL_00b6: ldc.i4.s -2
            IL_00b8: stfld int32 valuetype Extensions/'<M>d__1`2'<!T, !U>::'<>1__state'
            IL_00bd: ldarg.0
            IL_00be: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> valuetype Extensions/'<M>d__1`2'<!T, !U>::'<>t__builder'
            IL_00c3: ldloc.1
            IL_00c4: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::SetResult(!0)
            IL_00c9: ret
        } // end of method '<M>d__1`2'::MoveNext
        .method private final hidebysig newslot virtual 
            instance void SetStateMachine (
                class [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine stateMachine
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance void [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine::SetStateMachine(class [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine)
            // Method begins at RVA 0x21c0
            // Code size 13 (0xd)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> valuetype Extensions/'<M>d__1`2'<!T, !U>::'<>t__builder'
            IL_0006: ldarg.1
            IL_0007: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::SetStateMachine(class [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine)
            IL_000c: ret
        } // end of method '<M>d__1`2'::SetStateMachine
    } // end of class <M>d__1`2
    // Methods
    .method public hidebysig specialname static 
        class [mscorlib]System.Threading.Tasks.Task`1<string> M<T, U> (
            class C`1<!!T> o,
            !!T t1,
            !!U u1
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.AsyncStateMachineAttribute::.ctor(class [mscorlib]System.Type) = (
            01 00 14 45 78 74 65 6e 73 69 6f 6e 73 2b 3c 4d
            3e 64 5f 5f 31 60 32 00 00
        )
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2068
        // Code size 71 (0x47)
        .maxstack 2
        .locals init (
            [0] valuetype Extensions/'<M>d__1`2'<!!T, !!U>
        )
        IL_0000: ldloca.s 0
        IL_0002: call valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<!0> valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::Create()
        IL_0007: stfld valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> valuetype Extensions/'<M>d__1`2'<!!T, !!U>::'<>t__builder'
        IL_000c: ldloca.s 0
        IL_000e: ldarg.0
        IL_000f: stfld class C`1<!0> valuetype Extensions/'<M>d__1`2'<!!T, !!U>::o
        IL_0014: ldloca.s 0
        IL_0016: ldarg.1
        IL_0017: stfld !0 valuetype Extensions/'<M>d__1`2'<!!T, !!U>::t1
        IL_001c: ldloca.s 0
        IL_001e: ldarg.2
        IL_001f: stfld !1 valuetype Extensions/'<M>d__1`2'<!!T, !!U>::u1
        IL_0024: ldloca.s 0
        IL_0026: ldc.i4.m1
        IL_0027: stfld int32 valuetype Extensions/'<M>d__1`2'<!!T, !!U>::'<>1__state'
        IL_002c: ldloca.s 0
        IL_002e: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> valuetype Extensions/'<M>d__1`2'<!!T, !!U>::'<>t__builder'
        IL_0033: ldloca.s 0
        IL_0035: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::Start<valuetype Extensions/'<M>d__1`2'<!!T, !!U>>(!!0&)
        IL_003a: ldloca.s 0
        IL_003c: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> valuetype Extensions/'<M>d__1`2'<!!T, !!U>::'<>t__builder'
        IL_0041: call instance class [mscorlib]System.Threading.Tasks.Task`1<!0> valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::get_Task()
        IL_0046: ret
    } // end of method Extensions::M
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension<T>(C<T> o)
    {
        async System.Threading.Tasks.Task<string> M<U>(T t1, U u1)
        {
            await System.Threading.Tasks.Task.Yield();
            return o.GetString() + u1.ToString() + t1.ToString();
        }
    }

    extension<T>(C<T> o)
    {
        async System.Threading.Tasks.Task<string> M<U>(T t1, U u1, int x)
        {
            await System.Threading.Tasks.Task.Yield();
            return o.GetString() + u1.ToString() + t1.ToString();
        }
    }
}

public class C<T>
{
    public string GetString() => null;
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test(new C<long>("1"), 2, "3").Result);
        System.Console.Write(new C<long>("4").M2(5, "6").Result);
    }

    async static System.Threading.Tasks.Task<string> Test<T, U>(C<T> o, T t1, U u1)
    {
        await System.Threading.Tasks.Task.Yield();
        return await o.M(t1, u1);
    }
}

static class Extensions
{
    extension<T>(C<T> o)
    {
        async public System.Threading.Tasks.Task<string> M2<U>(T t1, U u1)
        {
            await System.Threading.Tasks.Task.Yield();
            return await o.M(t1, u1);
        }
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "132465").VerifyDiagnostics();

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "132465").VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_StaticMethod_01()
    {
        var src1 = """
public static class Extensions
{
    extension(object _)
    {
        public static string M(object o, string s)
        {
            return o + s;
        }
    }
}
""";
        var comp1 = CreateCompilation(src1);

        var verifier1 = CompileAndVerify(comp1, sourceSymbolValidator: verifySymbols, symbolValidator: verifySymbols).VerifyDiagnostics();

        static void verifySymbols(ModuleSymbol m)
        {
            MethodSymbol implementation = m.ContainingAssembly.GetTypeByMetadataName("Extensions").GetMembers().OfType<MethodSymbol>().Single();
            Assert.True(implementation.IsStatic);
            Assert.Equal(MethodKind.Ordinary, implementation.MethodKind);
            Assert.Equal(2, implementation.ParameterCount);
            AssertEx.Equal("System.String Extensions.M(System.Object o, System.String s)", implementation.ToTestDisplayString());
            Assert.Equal(m is not PEModuleSymbol, implementation.IsImplicitlyDeclared);
            Assert.False(implementation.IsExtensionMethod);
            Assert.True(implementation.HasSpecialName);
            Assert.False(implementation.HasRuntimeSpecialName);

            Assert.True(implementation.ContainingType.MightContainExtensionMethods);

            if (m is PEModuleSymbol peModuleSymbol)
            {
                Assert.True(peModuleSymbol.Module.HasExtensionAttribute(((PEAssemblySymbol)peModuleSymbol.ContainingAssembly).Assembly.Handle, ignoreCase: false));
            }
        }

        var expectedTypeIL = """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object _
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x207b
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig static 
            string M (
                object o,
                string s
            ) cil managed 
        {
            // Method begins at RVA 0x207d
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    // Methods
    .method public hidebysig specialname static 
        string M (
            object o,
            string s
        ) cil managed 
    {
        // Method begins at RVA 0x2067
        // Code size 19 (0x13)
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: brtrue.s IL_0006
        IL_0003: ldnull
        IL_0004: br.s IL_000c
        IL_0006: ldarg.0
        IL_0007: callvirt instance string [mscorlib]System.Object::ToString()
        IL_000c: ldarg.1
        IL_000d: call string [mscorlib]System.String::Concat(string, string)
        IL_0012: ret
    } // end of method Extensions::M
} // end of class Extensions
""";

        verifier1.VerifyTypeIL("Extensions", expectedTypeIL.Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write(object.M2("3", "4"));
    }

    static string Test(object o)
    {
        return object.M(o, "2");
    }
}

static class Extensions
{
    extension(object o)
    {
        public static string M2(object o1, string s)
        {
            return object.M(o1, s);
        }
    }
}
""";

        var comp1MetadataReference = comp1.ToMetadataReference();
        var comp2 = CreateCompilation(src2, references: [comp1MetadataReference], options: TestOptions.DebugExe);
        var verifier2 = CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

        var testIL =
@"
{
  // Code size       17 (0x11)
  .maxstack  2
  .locals init (string V_0)
  IL_0000:  nop
  IL_0001:  ldarg.0
  IL_0002:  ldstr      ""2""
  IL_0007:  call       ""string Extensions.M(object, string)""
  IL_000c:  stloc.0
  IL_000d:  br.s       IL_000f
  IL_000f:  ldloc.0
  IL_0010:  ret
}
";
        verifier2.VerifyIL("Program.Test", testIL);

        var m2IL =
@"
{
  // Code size        9 (0x9)
  .maxstack  2
  IL_0000:  nop
  IL_0001:  ldarg.0
  IL_0002:  ldarg.1
  IL_0003:  call       ""string Extensions.M(object, string)""
  IL_0008:  ret
}
";
        verifier2.VerifyIL("Extensions.M2", m2IL);

        var comp1ImageReference = comp1.EmitToImageReference();
        comp2 = CreateCompilation(src2, references: [comp1ImageReference], options: TestOptions.DebugExe);
        verifier2 = CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

        verifier2.VerifyIL("Program.Test", testIL);
        verifier2.VerifyIL("Extensions.M2", m2IL);

        comp2 = CreateCompilationWithIL(src2, expectedTypeIL, options: TestOptions.DebugExe);
        CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

        var remove = """
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
""";

        comp2 = CreateCompilationWithIL(src2, expectedTypeIL.Remove(expectedTypeIL.IndexOf(remove), remove.Length));
        comp2.VerifyDiagnostics(
            // (11,23): error CS0117: 'object' does not contain a definition for 'M'
            //         return object.M(o, "2");
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(11, 23),
            // (21,27): error CS0117: 'object' does not contain a definition for 'M'
            //             return object.M(o, s);
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(21, 27)
            );

        src2 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write(object.M2("3", "4"));
    }

    static string Test(object o)
    {
        return Extensions.M(o, "2");
    }
}

static class Extensions_
{
    extension(object o)
    {
        public static string M2(object o1, string s)
        {
            return Extensions.M(o1, s);
        }
    }
}
""";

        comp2 = CreateCompilation(src2, references: [comp1MetadataReference], options: TestOptions.DebugExe);
        verifier2 = CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

        verifier2.VerifyIL("Program.Test", testIL);
        verifier2.VerifyIL("Extensions_.M2", m2IL);

        comp2 = CreateCompilation(src2, references: [comp1ImageReference], options: TestOptions.DebugExe);
        verifier2 = CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

        verifier2.VerifyIL("Program.Test", testIL);
        verifier2.VerifyIL("Extensions_.M2", m2IL);

        var vbComp = CreateVisualBasicCompilation("""
Class Program
    Shared Sub Main()
        System.Console.Write(Test2("3"))
    End Sub

    Shared Function Test2(o As String) As String
        return Extensions.M(o, "4")
    End Function
End Class
""",
            referencedAssemblies: comp2.References, compilationOptions: new VisualBasicCompilationOptions(OutputKind.ConsoleApplication));

        CompileAndVerify(vbComp, expectedOutput: "34").VerifyDiagnostics();

        if (!CompilationExtensions.EnableVerifyUsedAssemblies) // Tracked by https://github.com/dotnet/roslyn/issues/77542
        {
            src2 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write(object.M2("3", "4"));
    }

    static string Test(object o)
    {
        System.Func<object, string, string> d = object.M;
        return d(o, "2");
    }
}

static class Extensions
{
    extension(object o)
    {
        public static string M2(object o1, string s)
        {
            return new System.Func<object, string, string>(object.M)(o1, s);
        }
    }
}
""";

            comp2 = CreateCompilation(src2, references: [comp1MetadataReference], options: TestOptions.DebugExe);
            verifier2 = CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

            testIL =
    @"
{
  // Code size       46 (0x2e)
  .maxstack  3
  .locals init (System.Func<object, string, string> V_0, //d
                string V_1)
  IL_0000:  nop
  IL_0001:  ldsfld     ""System.Func<object, string, string> Program.<>O.<0>__M""
  IL_0006:  dup
  IL_0007:  brtrue.s   IL_001c
  IL_0009:  pop
  IL_000a:  ldnull
  IL_000b:  ldftn      ""string Extensions.M(object, string)""
  IL_0011:  newobj     ""System.Func<object, string, string>..ctor(object, System.IntPtr)""
  IL_0016:  dup
  IL_0017:  stsfld     ""System.Func<object, string, string> Program.<>O.<0>__M""
  IL_001c:  stloc.0
  IL_001d:  ldloc.0
  IL_001e:  ldarg.0
  IL_001f:  ldstr      ""2""
  IL_0024:  callvirt   ""string System.Func<object, string, string>.Invoke(object, string)""
  IL_0029:  stloc.1
  IL_002a:  br.s       IL_002c
  IL_002c:  ldloc.1
  IL_002d:  ret
}
";
            verifier2.VerifyIL("Program.Test", testIL);

            m2IL =
    @"
{
  // Code size       21 (0x15)
  .maxstack  3
  IL_0000:  nop
  IL_0001:  ldnull
  IL_0002:  ldftn      ""string Extensions.M(object, string)""
  IL_0008:  newobj     ""System.Func<object, string, string>..ctor(object, System.IntPtr)""
  IL_000d:  ldarg.0
  IL_000e:  ldarg.1
  IL_000f:  callvirt   ""string System.Func<object, string, string>.Invoke(object, string)""
  IL_0014:  ret
}
";
            verifier2.VerifyIL("Extensions.M2", m2IL);

            comp2 = CreateCompilation(src2, references: [comp1ImageReference], options: TestOptions.DebugExe);
            verifier2 = CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

            verifier2.VerifyIL("Program.Test", testIL);
            verifier2.VerifyIL("Extensions.M2", m2IL);

            src2 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write(object.M2("3", "4"));
    }

    static string Test(object o)
    {
        System.Func<object, string, string> d = Extensions.M;
        return d(o, "2");
    }
}

static class Extensions_
{
    extension(object o)
    {
        public static string M2(object o1, string s)
        {
            return new System.Func<object, string, string>(Extensions.M)(o1, s);
        }
    }
}
""";

            comp2 = CreateCompilation(src2, references: [comp1MetadataReference], options: TestOptions.DebugExe);
            verifier2 = CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

            verifier2.VerifyIL("Program.Test", testIL);
            verifier2.VerifyIL("Extensions_.M2", m2IL);

            comp2 = CreateCompilation(src2, references: [comp1ImageReference], options: TestOptions.DebugExe);
            verifier2 = CompileAndVerify(comp2, expectedOutput: "1234").VerifyDiagnostics();

            verifier2.VerifyIL("Program.Test", testIL);
            verifier2.VerifyIL("Extensions_.M2", m2IL);

            src2 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write(object.M2("3", "4"));
    }

    unsafe static string Test(object o)
    {
        delegate*<object, string, string> d = &object.M;
        return d(o, "2");
    }
}

static class Extensions
{
    extension(object o)
    {
        unsafe public static string M2(object o1, string s)
        {
            return ((delegate*<object, string, string>)&object.M)(o1, s);
        }
    }
}
""";

            comp2 = CreateCompilation(src2, references: [comp1MetadataReference], options: TestOptions.DebugExe.WithAllowUnsafe(true));
            verifier2 = CompileAndVerify(comp2, expectedOutput: "1234", verify: Verification.Skipped).VerifyDiagnostics();

            testIL =
@"
{
  // Code size       27 (0x1b)
  .maxstack  3
  .locals init (delegate*<object, string, string> V_0, //d
                delegate*<object, string, string> V_1,
                string V_2)
  IL_0000:  nop
  IL_0001:  ldftn      ""string Extensions.M(object, string)""
  IL_0007:  stloc.0
  IL_0008:  ldloc.0
  IL_0009:  stloc.1
  IL_000a:  ldarg.0
  IL_000b:  ldstr      ""2""
  IL_0010:  ldloc.1
  IL_0011:  calli      ""delegate*<object, string, string>""
  IL_0016:  stloc.2
  IL_0017:  br.s       IL_0019
  IL_0019:  ldloc.2
  IL_001a:  ret
}
";
            verifier2.VerifyIL("Program.Test", testIL);

            m2IL =
@"
{
  // Code size       17 (0x11)
  .maxstack  3
  .locals init (delegate*<object, string, string> V_0)
  IL_0000:  nop
  IL_0001:  ldftn      ""string Extensions.M(object, string)""
  IL_0007:  stloc.0
  IL_0008:  ldarg.0
  IL_0009:  ldarg.1
  IL_000a:  ldloc.0
  IL_000b:  calli      ""delegate*<object, string, string>""
  IL_0010:  ret
}
";
            verifier2.VerifyIL("Extensions.M2", m2IL);

            comp2 = CreateCompilation(src2, references: [comp1ImageReference], options: TestOptions.DebugExe.WithAllowUnsafe(true));
            verifier2 = CompileAndVerify(comp2, expectedOutput: "1234", verify: Verification.Skipped).VerifyDiagnostics();

            verifier2.VerifyIL("Program.Test", testIL);
            verifier2.VerifyIL("Extensions.M2", m2IL);

            src2 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write(object.M2("3", "4"));
    }

    unsafe static string Test(object o)
    {
        delegate*<object, string, string> d = &Extensions.M;
        return d(o, "2");
    }
}

static class Extensions_
{
    extension(object o)
    {
        unsafe public static string M2(object o1, string s)
        {
            return ((delegate*<object, string, string>)&Extensions.M)(o1, s);
        }
    }
}
""";

            comp2 = CreateCompilation(src2, references: [comp1MetadataReference], options: TestOptions.DebugExe.WithAllowUnsafe(true));
            verifier2 = CompileAndVerify(comp2, expectedOutput: "1234", verify: Verification.Skipped).VerifyDiagnostics();

            verifier2.VerifyIL("Program.Test", testIL);
            verifier2.VerifyIL("Extensions_.M2", m2IL);

            comp2 = CreateCompilation(src2, references: [comp1ImageReference], options: TestOptions.DebugExe.WithAllowUnsafe(true));
            verifier2 = CompileAndVerify(comp2, expectedOutput: "1234", verify: Verification.Skipped).VerifyDiagnostics();

            verifier2.VerifyIL("Program.Test", testIL);
            verifier2.VerifyIL("Extensions_.M2", m2IL);
        }

        var comp5 = CreateCompilation(src1);
        comp5.MakeMemberMissing(WellKnownMember.System_Runtime_CompilerServices_ExtensionAttribute__ctor);
        comp5.VerifyEmitDiagnostics(
            // (3,5): error CS1110: Cannot define a new extension because the compiler required type 'System.Runtime.CompilerServices.ExtensionAttribute' cannot be found. Are you missing a reference to System.Core.dll?
            //     extension(object _)
            Diagnostic(ErrorCode.ERR_ExtensionAttrNotFound, "extension").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(3, 5)
            );
    }

    [Fact]
    public void Implementation_StaticMethod_02_WithLocalFunction()
    {
        var src1 = """
public static class Extensions
{
    extension(object _)
    {
        public static string M(object o, string s)
        {
            string local() => o + s;
            return local();
        }
    }
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object _
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x20ab
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig static 
            string M (
                object o,
                string s
            ) cil managed 
        {
            // Method begins at RVA 0x20ad
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    .class nested private auto ansi sealed beforefieldinit '<>c__DisplayClass1_0'
        extends [mscorlib]System.ValueType
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public object o
        .field public string s
    } // end of class <>c__DisplayClass1_0
    // Methods
    .method public hidebysig specialname static 
        string M (
            object o,
            string s
        ) cil managed 
    {
        // Method begins at RVA 0x2068
        // Code size 24 (0x18)
        .maxstack 2
        .locals init (
            [0] valuetype Extensions/'<>c__DisplayClass1_0'
        )
        IL_0000: ldloca.s 0
        IL_0002: ldarg.0
        IL_0003: stfld object Extensions/'<>c__DisplayClass1_0'::o
        IL_0008: ldloca.s 0
        IL_000a: ldarg.1
        IL_000b: stfld string Extensions/'<>c__DisplayClass1_0'::s
        IL_0010: ldloca.s 0
        IL_0012: call string Extensions::'<M>b__1_0'(valuetype Extensions/'<>c__DisplayClass1_0'&)
        IL_0017: ret
    } // end of method Extensions::M
    .method assembly hidebysig static 
        string '<M>b__1_0' (
            valuetype Extensions/'<>c__DisplayClass1_0'& ''
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x208c
        // Code size 30 (0x1e)
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: ldfld object Extensions/'<>c__DisplayClass1_0'::o
        IL_0006: dup
        IL_0007: brtrue.s IL_000d
        IL_0009: pop
        IL_000a: ldnull
        IL_000b: br.s IL_0012
        IL_000d: callvirt instance string [mscorlib]System.Object::ToString()
        IL_0012: ldarg.0
        IL_0013: ldfld string Extensions/'<>c__DisplayClass1_0'::s
        IL_0018: call string [mscorlib]System.String::Concat(string, string)
        IL_001d: ret
    } // end of method Extensions::'<M>b__1_0'
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension(object _)
    {
        static string M(object o, string s)
        {
            string local() => o + s;
            return local();
        }
    }

    extension(object)
    {
        static string M(object o, string s, int x)
        {
            string local() => o + s;
            return local();
        }
    }
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write(object.M2("3","4"));
    }

    static string Test(object o)
    {
        string local() => object.M(o, "2");
        return local();
    }
}

static class Extensions
{
    extension(object _)
    {
        public static string M2(object o, string s)
        {
            string local() => object.M(o, s);
            return local();
        }
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_StaticMethod_03_WithLambda()
    {
        var src1 = """
public static class Extensions
{
    extension(object _)
    {
        public static string M(object o, string s)
        {
            System.Func<string> local = () => o + s;
            return local();
        }
    }
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object _
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x208c
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig static 
            string M (
                object o,
                string s
            ) cil managed 
        {
            // Method begins at RVA 0x208e
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    .class nested private auto ansi sealed beforefieldinit '<>c__DisplayClass1_0'
        extends [mscorlib]System.Object
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public object o
        .field public string s
        // Methods
        .method public hidebysig specialname rtspecialname 
            instance void .ctor () cil managed 
        {
            // Method begins at RVA 0x2091
            // Code size 7 (0x7)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: call instance void [mscorlib]System.Object::.ctor()
            IL_0006: ret
        } // end of method '<>c__DisplayClass1_0'::.ctor
        .method assembly hidebysig 
            instance string '<M>b__0' () cil managed 
        {
            // Method begins at RVA 0x2099
            // Code size 30 (0x1e)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldfld object Extensions/'<>c__DisplayClass1_0'::o
            IL_0006: dup
            IL_0007: brtrue.s IL_000d
            IL_0009: pop
            IL_000a: ldnull
            IL_000b: br.s IL_0012
            IL_000d: callvirt instance string [mscorlib]System.Object::ToString()
            IL_0012: ldarg.0
            IL_0013: ldfld string Extensions/'<>c__DisplayClass1_0'::s
            IL_0018: call string [mscorlib]System.String::Concat(string, string)
            IL_001d: ret
        } // end of method '<>c__DisplayClass1_0'::'<M>b__0'
    } // end of class <>c__DisplayClass1_0
    // Methods
    .method public hidebysig specialname static 
        string M (
            object o,
            string s
        ) cil managed 
    {
        // Method begins at RVA 0x2067
        // Code size 36 (0x24)
        .maxstack 8
        IL_0000: newobj instance void Extensions/'<>c__DisplayClass1_0'::.ctor()
        IL_0005: dup
        IL_0006: ldarg.0
        IL_0007: stfld object Extensions/'<>c__DisplayClass1_0'::o
        IL_000c: dup
        IL_000d: ldarg.1
        IL_000e: stfld string Extensions/'<>c__DisplayClass1_0'::s
        IL_0013: ldftn instance string Extensions/'<>c__DisplayClass1_0'::'<M>b__0'()
        IL_0019: newobj instance void class [mscorlib]System.Func`1<string>::.ctor(object, native int)
        IL_001e: callvirt instance !0 class [mscorlib]System.Func`1<string>::Invoke()
        IL_0023: ret
    } // end of method Extensions::M
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension(object _)
    {
        static string M(object o, string s)
        {
            System.Func<string> local = () => o + s;
            return local();
        }
    }

    extension(object)
    {
        static string M(object o, string s, int x)
        {
            System.Func<string> local = () => o + s;
            return local();
        }
    }
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write(object.M2("3","4"));
    }

    static string Test(object o)
    {
        System.Func<string> local = () => object.M(o, "2");
        return local();
    }
}

static class Extensions
{
    extension(object _)
    {
        public static string M2(object o, string s)
        {
            System.Func<string> local = () => object.M(o, s);
            return local();
        }
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_StaticMethod_04_Iterator()
    {
        var src1 = """
public static class Extensions
{
    extension(object _)
    {
        public static System.Collections.Generic.IEnumerable<string> M(object o, string s)
        {
            yield return o + s;
        }
    }
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1, symbolValidator: (m) =>
        {
            MethodSymbol implementation = m.ContainingAssembly.GetTypeByMetadataName("Extensions").GetMembers().OfType<MethodSymbol>().Single();
            AssertEx.Equal("System.Runtime.CompilerServices.IteratorStateMachineAttribute(typeof(Extensions.<M>d__1))", implementation.GetAttributes().Single().ToString());
        }).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", ("""
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object _
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x207e
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig static 
            class [mscorlib]System.Collections.Generic.IEnumerable`1<string> M (
                object o,
                string s
            ) cil managed 
        {
            // Method begins at RVA 0x2080
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    .class nested private auto ansi sealed beforefieldinit '<M>d__1'
        extends [mscorlib]System.Object
        implements class [mscorlib]System.Collections.Generic.IEnumerable`1<string>,
                   [mscorlib]System.Collections.IEnumerable,
                   class [mscorlib]System.Collections.Generic.IEnumerator`1<string>,

""" +
        (ExecutionConditionUtil.IsMonoOrCoreClr ?
"""
                   [mscorlib]System.Collections.IEnumerator,
                   [mscorlib]System.IDisposable

""" :
"""
                   [mscorlib]System.IDisposable,
                   [mscorlib]System.Collections.IEnumerator

""") +
"""
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field private int32 '<>1__state'
        .field private string '<>2__current'
        .field private int32 '<>l__initialThreadId'
        .field private object o
        .field public object '<>3__o'
        .field private string s
        .field public string '<>3__s'
        // Methods
        .method public hidebysig specialname rtspecialname 
            instance void .ctor (
                int32 '<>1__state'
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2083
            // Code size 25 (0x19)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: call instance void [mscorlib]System.Object::.ctor()
            IL_0006: ldarg.0
            IL_0007: ldarg.1
            IL_0008: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_000d: ldarg.0
            IL_000e: call int32 [mscorlib]System.Environment::get_CurrentManagedThreadId()
            IL_0013: stfld int32 Extensions/'<M>d__1'::'<>l__initialThreadId'
            IL_0018: ret
        } // end of method '<M>d__1'::.ctor
        .method private final hidebysig newslot virtual 
            instance void System.IDisposable.Dispose () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance void [mscorlib]System.IDisposable::Dispose()
            // Method begins at RVA 0x209d
            // Code size 9 (0x9)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldc.i4.s -2
            IL_0003: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_0008: ret
        } // end of method '<M>d__1'::System.IDisposable.Dispose
        .method private final hidebysig newslot virtual 
            instance bool MoveNext () cil managed 
        {
            .override method instance bool [mscorlib]System.Collections.IEnumerator::MoveNext()
            // Method begins at RVA 0x20a8
            // Code size 76 (0x4c)
            .maxstack 3
            .locals init (
                [0] int32
            )
            IL_0000: ldarg.0
            IL_0001: ldfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_0006: stloc.0
            IL_0007: ldloc.0
            IL_0008: brfalse.s IL_0010
            IL_000a: ldloc.0
            IL_000b: ldc.i4.1
            IL_000c: beq.s IL_0043
            IL_000e: ldc.i4.0
            IL_000f: ret
            IL_0010: ldarg.0
            IL_0011: ldc.i4.m1
            IL_0012: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_0017: ldarg.0
            IL_0018: ldarg.0
            IL_0019: ldfld object Extensions/'<M>d__1'::o
            IL_001e: dup
            IL_001f: brtrue.s IL_0025
            IL_0021: pop
            IL_0022: ldnull
            IL_0023: br.s IL_002a
            IL_0025: callvirt instance string [mscorlib]System.Object::ToString()
            IL_002a: ldarg.0
            IL_002b: ldfld string Extensions/'<M>d__1'::s
            IL_0030: call string [mscorlib]System.String::Concat(string, string)
            IL_0035: stfld string Extensions/'<M>d__1'::'<>2__current'
            IL_003a: ldarg.0
            IL_003b: ldc.i4.1
            IL_003c: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_0041: ldc.i4.1
            IL_0042: ret
            IL_0043: ldarg.0
            IL_0044: ldc.i4.m1
            IL_0045: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_004a: ldc.i4.0
            IL_004b: ret
        } // end of method '<M>d__1'::MoveNext
        .method private final hidebysig specialname newslot virtual 
            instance string 'System.Collections.Generic.IEnumerator<System.String>.get_Current' () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance !0 class [mscorlib]System.Collections.Generic.IEnumerator`1<string>::get_Current()
            // Method begins at RVA 0x2100
            // Code size 7 (0x7)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldfld string Extensions/'<M>d__1'::'<>2__current'
            IL_0006: ret
        } // end of method '<M>d__1'::'System.Collections.Generic.IEnumerator<System.String>.get_Current'
        .method private final hidebysig newslot virtual 
            instance void System.Collections.IEnumerator.Reset () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance void [mscorlib]System.Collections.IEnumerator::Reset()
            // Method begins at RVA 0x2108
            // Code size 6 (0x6)
            .maxstack 8
            IL_0000: newobj instance void [mscorlib]System.NotSupportedException::.ctor()
            IL_0005: throw
        } // end of method '<M>d__1'::System.Collections.IEnumerator.Reset
        .method private final hidebysig specialname newslot virtual 
            instance object System.Collections.IEnumerator.get_Current () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance object [mscorlib]System.Collections.IEnumerator::get_Current()
            // Method begins at RVA 0x2100
            // Code size 7 (0x7)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldfld string Extensions/'<M>d__1'::'<>2__current'
            IL_0006: ret
        } // end of method '<M>d__1'::System.Collections.IEnumerator.get_Current
        .method private final hidebysig newslot virtual 
            instance class [mscorlib]System.Collections.Generic.IEnumerator`1<string> 'System.Collections.Generic.IEnumerable<System.String>.GetEnumerator' () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance class [mscorlib]System.Collections.Generic.IEnumerator`1<!0> class [mscorlib]System.Collections.Generic.IEnumerable`1<string>::GetEnumerator()
            // Method begins at RVA 0x2110
            // Code size 67 (0x43)
            .maxstack 2
            .locals init (
                [0] class Extensions/'<M>d__1'
            )
            IL_0000: ldarg.0
            IL_0001: ldfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_0006: ldc.i4.s -2
            IL_0008: bne.un.s IL_0022
            IL_000a: ldarg.0
            IL_000b: ldfld int32 Extensions/'<M>d__1'::'<>l__initialThreadId'
            IL_0010: call int32 [mscorlib]System.Environment::get_CurrentManagedThreadId()
            IL_0015: bne.un.s IL_0022
            IL_0017: ldarg.0
            IL_0018: ldc.i4.0
            IL_0019: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_001e: ldarg.0
            IL_001f: stloc.0
            IL_0020: br.s IL_0029
            IL_0022: ldc.i4.0
            IL_0023: newobj instance void Extensions/'<M>d__1'::.ctor(int32)
            IL_0028: stloc.0
            IL_0029: ldloc.0
            IL_002a: ldarg.0
            IL_002b: ldfld object Extensions/'<M>d__1'::'<>3__o'
            IL_0030: stfld object Extensions/'<M>d__1'::o
            IL_0035: ldloc.0
            IL_0036: ldarg.0
            IL_0037: ldfld string Extensions/'<M>d__1'::'<>3__s'
            IL_003c: stfld string Extensions/'<M>d__1'::s
            IL_0041: ldloc.0
            IL_0042: ret
        } // end of method '<M>d__1'::'System.Collections.Generic.IEnumerable<System.String>.GetEnumerator'
        .method private final hidebysig newslot virtual 
            instance class [mscorlib]System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator () cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance class [mscorlib]System.Collections.IEnumerator [mscorlib]System.Collections.IEnumerable::GetEnumerator()
            // Method begins at RVA 0x215f
            // Code size 7 (0x7)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: call instance class [mscorlib]System.Collections.Generic.IEnumerator`1<string> Extensions/'<M>d__1'::'System.Collections.Generic.IEnumerable<System.String>.GetEnumerator'()
            IL_0006: ret
        } // end of method '<M>d__1'::System.Collections.IEnumerable.GetEnumerator
        // Properties
        .property instance string 'System.Collections.Generic.IEnumerator<System.String>.Current'()
        {
            .get instance string Extensions/'<M>d__1'::'System.Collections.Generic.IEnumerator<System.String>.get_Current'()
        }
        .property instance object System.Collections.IEnumerator.Current()
        {
            .get instance object Extensions/'<M>d__1'::System.Collections.IEnumerator.get_Current()
        }
    } // end of class <M>d__1
    // Methods
    .method public hidebysig specialname static 
        class [mscorlib]System.Collections.Generic.IEnumerable`1<string> M (
            object o,
            string s
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.IteratorStateMachineAttribute::.ctor(class [mscorlib]System.Type) = (
            01 00 12 45 78 74 65 6e 73 69 6f 6e 73 2b 3c 4d
            3e 64 5f 5f 31 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 22 (0x16)
        .maxstack 8
        IL_0000: ldc.i4.s -2
        IL_0002: newobj instance void Extensions/'<M>d__1'::.ctor(int32)
        IL_0007: dup
        IL_0008: ldarg.0
        IL_0009: stfld object Extensions/'<M>d__1'::'<>3__o'
        IL_000e: dup
        IL_000f: ldarg.1
        IL_0010: stfld string Extensions/'<M>d__1'::'<>3__s'
        IL_0015: ret
    } // end of method Extensions::M
} // end of class Extensions
""").Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension(object _)
    {
        static System.Collections.Generic.IEnumerable<string> M(object o, string s)
        {
            yield return o + s;
        }
    }

    extension(object)
    {
        static System.Collections.Generic.IEnumerable<string> M(object o, string s, int x)
        {
            yield return o + s;
        }
    }
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();

        var src3 = """
class Program
{
    static void Main()
    {
        foreach (var s in Test("1"))
            System.Console.Write(s);
        foreach (var s in object.M2("3", "4"))
            System.Console.Write(s);
    }

    static System.Collections.Generic.IEnumerable<string> Test(object o)
    {
        return object.M(o, "2");
    }
}

static class Extensions
{
    extension(object _)
    {
        public static System.Collections.Generic.IEnumerable<string> M2(object o, string s) => object.M(o, s);
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_StaticMethod_05_Async()
    {
        var src1 = """
public static class Extensions
{
    extension(object _)
    {
        public static async System.Threading.Tasks.Task<string> M(object o, string s)
        {
            await System.Threading.Tasks.Task.Yield();
            return o + s;
        }
    }
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1, symbolValidator: (m) =>
        {
            MethodSymbol implementation = m.ContainingAssembly.GetTypeByMetadataName("Extensions").GetMembers().OfType<MethodSymbol>().Single();
            AssertEx.Equal("System.Runtime.CompilerServices.AsyncStateMachineAttribute(typeof(Extensions.<M>d__1))", implementation.GetAttributes().Single().ToString());
        }).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object _
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x20b3
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig static 
            class [mscorlib]System.Threading.Tasks.Task`1<string> M (
                object o,
                string s
            ) cil managed 
        {
            // Method begins at RVA 0x20b5
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M
    } // end of class <>E__0
    .class nested private auto ansi sealed beforefieldinit '<M>d__1'
        extends [mscorlib]System.ValueType
        implements [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public int32 '<>1__state'
        .field public valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> '<>t__builder'
        .field public object o
        .field public string s
        .field private valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter '<>u__1'
        // Methods
        .method private final hidebysig newslot virtual 
            instance void MoveNext () cil managed 
        {
            .override method instance void [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine::MoveNext()
            // Method begins at RVA 0x20b8
            // Code size 178 (0xb2)
            .maxstack 3
            .locals init (
                [0] int32,
                [1] string,
                [2] valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter,
                [3] valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable,
                [4] class [mscorlib]System.Exception
            )
            IL_0000: ldarg.0
            IL_0001: ldfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_0006: stloc.0
            .try
            {
                IL_0007: ldloc.0
                IL_0008: brfalse.s IL_0041
                IL_000a: call valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable [mscorlib]System.Threading.Tasks.Task::Yield()
                IL_000f: stloc.3
                IL_0010: ldloca.s 3
                IL_0012: call instance valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter [mscorlib]System.Runtime.CompilerServices.YieldAwaitable::GetAwaiter()
                IL_0017: stloc.2
                IL_0018: ldloca.s 2
                IL_001a: call instance bool [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter::get_IsCompleted()
                IL_001f: brtrue.s IL_005d
                IL_0021: ldarg.0
                IL_0022: ldc.i4.0
                IL_0023: dup
                IL_0024: stloc.0
                IL_0025: stfld int32 Extensions/'<M>d__1'::'<>1__state'
                IL_002a: ldarg.0
                IL_002b: ldloc.2
                IL_002c: stfld valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter Extensions/'<M>d__1'::'<>u__1'
                IL_0031: ldarg.0
                IL_0032: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
                IL_0037: ldloca.s 2
                IL_0039: ldarg.0
                IL_003a: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::AwaitUnsafeOnCompleted<valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter, valuetype Extensions/'<M>d__1'>(!!0&, !!1&)
                IL_003f: leave.s IL_00b1
                IL_0041: ldarg.0
                IL_0042: ldfld valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter Extensions/'<M>d__1'::'<>u__1'
                IL_0047: stloc.2
                IL_0048: ldarg.0
                IL_0049: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter Extensions/'<M>d__1'::'<>u__1'
                IL_004e: initobj [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter
                IL_0054: ldarg.0
                IL_0055: ldc.i4.m1
                IL_0056: dup
                IL_0057: stloc.0
                IL_0058: stfld int32 Extensions/'<M>d__1'::'<>1__state'
                IL_005d: ldloca.s 2
                IL_005f: call instance void [mscorlib]System.Runtime.CompilerServices.YieldAwaitable/YieldAwaiter::GetResult()
                IL_0064: ldarg.0
                IL_0065: ldfld object Extensions/'<M>d__1'::o
                IL_006a: dup
                IL_006b: brtrue.s IL_0071
                IL_006d: pop
                IL_006e: ldnull
                IL_006f: br.s IL_0076
                IL_0071: callvirt instance string [mscorlib]System.Object::ToString()
                IL_0076: ldarg.0
                IL_0077: ldfld string Extensions/'<M>d__1'::s
                IL_007c: call string [mscorlib]System.String::Concat(string, string)
                IL_0081: stloc.1
                IL_0082: leave.s IL_009d
            } // end .try
            catch [mscorlib]System.Exception
            {
                IL_0084: stloc.s 4
                IL_0086: ldarg.0
                IL_0087: ldc.i4.s -2
                IL_0089: stfld int32 Extensions/'<M>d__1'::'<>1__state'
                IL_008e: ldarg.0
                IL_008f: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
                IL_0094: ldloc.s 4
                IL_0096: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::SetException(class [mscorlib]System.Exception)
                IL_009b: leave.s IL_00b1
            } // end handler
            IL_009d: ldarg.0
            IL_009e: ldc.i4.s -2
            IL_00a0: stfld int32 Extensions/'<M>d__1'::'<>1__state'
            IL_00a5: ldarg.0
            IL_00a6: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
            IL_00ab: ldloc.1
            IL_00ac: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::SetResult(!0)
            IL_00b1: ret
        } // end of method '<M>d__1'::MoveNext
        .method private final hidebysig newslot virtual 
            instance void SetStateMachine (
                class [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine stateMachine
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Diagnostics.DebuggerHiddenAttribute::.ctor() = (
                01 00 00 00
            )
            .override method instance void [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine::SetStateMachine(class [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine)
            // Method begins at RVA 0x2188
            // Code size 13 (0xd)
            .maxstack 8
            IL_0000: ldarg.0
            IL_0001: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
            IL_0006: ldarg.1
            IL_0007: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::SetStateMachine(class [mscorlib]System.Runtime.CompilerServices.IAsyncStateMachine)
            IL_000c: ret
        } // end of method '<M>d__1'::SetStateMachine
    } // end of class <M>d__1
    // Methods
    .method public hidebysig specialname static 
        class [mscorlib]System.Threading.Tasks.Task`1<string> M (
            object o,
            string s
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.AsyncStateMachineAttribute::.ctor(class [mscorlib]System.Type) = (
            01 00 12 45 78 74 65 6e 73 69 6f 6e 73 2b 3c 4d
            3e 64 5f 5f 31 00 00
        )
        // Method begins at RVA 0x2068
        // Code size 63 (0x3f)
        .maxstack 2
        .locals init (
            [0] valuetype Extensions/'<M>d__1'
        )
        IL_0000: ldloca.s 0
        IL_0002: call valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<!0> valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::Create()
        IL_0007: stfld valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
        IL_000c: ldloca.s 0
        IL_000e: ldarg.0
        IL_000f: stfld object Extensions/'<M>d__1'::o
        IL_0014: ldloca.s 0
        IL_0016: ldarg.1
        IL_0017: stfld string Extensions/'<M>d__1'::s
        IL_001c: ldloca.s 0
        IL_001e: ldc.i4.m1
        IL_001f: stfld int32 Extensions/'<M>d__1'::'<>1__state'
        IL_0024: ldloca.s 0
        IL_0026: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
        IL_002b: ldloca.s 0
        IL_002d: call instance void valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::Start<valuetype Extensions/'<M>d__1'>(!!0&)
        IL_0032: ldloca.s 0
        IL_0034: ldflda valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string> Extensions/'<M>d__1'::'<>t__builder'
        IL_0039: call instance class [mscorlib]System.Threading.Tasks.Task`1<!0> valuetype [mscorlib]System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1<string>::get_Task()
        IL_003e: ret
    } // end of method Extensions::M
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension(object _)
    {
        static async System.Threading.Tasks.Task<string> M(object o, string s)
        {
            await System.Threading.Tasks.Task.Yield();
            return o + s;
        }
    }

    extension(object)
    {
        static async System.Threading.Tasks.Task<string> M(object o, string s, int x)
        {
            await System.Threading.Tasks.Task.Yield();
            return o + s;
        }
    }
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1").Result);
        System.Console.Write(object.M2("3", "4").Result);
    }

    async static System.Threading.Tasks.Task<string> Test(object o)
    {
        await System.Threading.Tasks.Task.Yield();
        return await object.M(o, "2");
    }
}

static class Extensions
{
    extension(object _)
    {
        async public static System.Threading.Tasks.Task<string> M2(object o, string s)
        {
            await System.Threading.Tasks.Task.Yield();
            return await object.M(o, s);
        }
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "1234").VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_InstanceProperty_01()
    {
        var src1 = """
public static class Extensions
{
    extension(object o)
    {
        public string P => o.ToString();
    }
}
""";
        var comp1 = CreateCompilation(src1);

        MethodSymbol implementation = comp1.GetTypeByMetadataName("Extensions").GetMembers().OfType<MethodSymbol>().Single();
        Assert.True(implementation.IsStatic);
        Assert.Equal(MethodKind.Ordinary, implementation.MethodKind);
        Assert.Equal(1, implementation.ParameterCount);
        AssertEx.Equal("System.String Extensions.get_P(System.Object o)", implementation.ToTestDisplayString());
        Assert.True(implementation.IsImplicitlyDeclared);
        Assert.False(implementation.IsExtensionMethod);
        Assert.True(implementation.HasSpecialName);
        Assert.False(implementation.HasRuntimeSpecialName);

        var verifier1 = CompileAndVerify(comp1).VerifyDiagnostics();

        var expectedTypeIL = """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x206f
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig specialname 
            instance string get_P () cil managed 
        {
            // Method begins at RVA 0x2071
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::get_P
        // Properties
        .property instance string P()
        {
            .get instance string Extensions/'<>E__0'::get_P()
        }
    } // end of class <>E__0
    // Methods
    .method public hidebysig specialname static 
        string get_P (
            object o
        ) cil managed 
    {
        // Method begins at RVA 0x2067
        // Code size 7 (0x7)
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: callvirt instance string [mscorlib]System.Object::ToString()
        IL_0006: ret
    } // end of method Extensions::get_P
} // end of class Extensions
""";

        verifier1.VerifyTypeIL("Extensions", expectedTypeIL.Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write("2".P2);
    }

    static string Test(object o)
    {
        return o.P;
    }
}

static class Extensions
{
    extension(object o)
    {
        public string P2 => o.P;
    }
}
""";

        var comp1MetadataReference = comp1.ToMetadataReference();
        var comp3 = CreateCompilation(src3, references: [comp1MetadataReference], options: TestOptions.DebugExe);
        var verifier3 = CompileAndVerify(comp3, expectedOutput: "12").VerifyDiagnostics();

        var testIL =
@"
{
  // Code size       12 (0xc)
  .maxstack  1
  .locals init (string V_0)
  IL_0000:  nop
  IL_0001:  ldarg.0
  IL_0002:  call       ""string Extensions.get_P(object)""
  IL_0007:  stloc.0
  IL_0008:  br.s       IL_000a
  IL_000a:  ldloc.0
  IL_000b:  ret
}
";
        verifier3.VerifyIL("Program.Test", testIL);

        var m2IL =
@"
{
  // Code size        7 (0x7)
  .maxstack  1
  IL_0000:  ldarg.0
  IL_0001:  call       ""string Extensions.get_P(object)""
  IL_0006:  ret
}
";
        verifier3.VerifyIL("Extensions.get_P2(object)", m2IL);

        var comp1ImageReference = comp1.EmitToImageReference();
        comp3 = CreateCompilation(src3, references: [comp1ImageReference], options: TestOptions.DebugExe);
        verifier3 = CompileAndVerify(comp3, expectedOutput: "12").VerifyDiagnostics();

        verifier3.VerifyIL("Program.Test", testIL);
        verifier3.VerifyIL("Extensions.get_P2(object)", m2IL);

        comp3 = CreateCompilationWithIL(src3, expectedTypeIL, options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "12").VerifyDiagnostics();

        var remove = """
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
""";

        comp3 = CreateCompilationWithIL(src3, expectedTypeIL.Remove(expectedTypeIL.IndexOf(remove), remove.Length));
        comp3.VerifyDiagnostics(
            // (11,18): error CS1061: 'object' does not contain a definition for 'P' and no accessible extension method 'P' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            //         return o.P;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "P").WithArguments("object", "P").WithLocation(11, 18),
            // (19,31): error CS1061: 'object' does not contain a definition for 'P' and no accessible extension method 'P' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            //         public string P2 => o.P;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "P").WithArguments("object", "P").WithLocation(19, 31)
            );

        src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write("2".P2);
    }

    static string Test(object o)
    {
        return o.get_P();
    }
}

static class Extensions
{
    extension(object o)
    {
        public string P2 => o.get_P();
    }
}
""";

        comp3 = CreateCompilation(src3, references: [comp1MetadataReference], options: TestOptions.DebugExe);
        comp3.VerifyDiagnostics(
            // (11,18): error CS1061: 'object' does not contain a definition for 'get_P' and no accessible extension method 'get_P' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            //         return o.get_P();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "get_P").WithArguments("object", "get_P").WithLocation(11, 18),
            // (19,31): error CS1061: 'object' does not contain a definition for 'get_P' and no accessible extension method 'get_P' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            //         public string P2 => o.get_P();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "get_P").WithArguments("object", "get_P").WithLocation(19, 31)
            );

        comp3 = CreateCompilation(src3, references: [comp1ImageReference], options: TestOptions.DebugExe);
        comp3.VerifyDiagnostics(
            // (11,18): error CS1061: 'object' does not contain a definition for 'get_P' and no accessible extension method 'get_P' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            //         return o.get_P();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "get_P").WithArguments("object", "get_P").WithLocation(11, 18),
            // (19,31): error CS1061: 'object' does not contain a definition for 'get_P' and no accessible extension method 'get_P' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            //         public string P2 => o.get_P();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "get_P").WithArguments("object", "get_P").WithLocation(19, 31)
            );

        src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write("2".P2);
    }

    static string Test(object o)
    {
        return Extensions.get_P(o);
    }
}

static class Extensions_
{
    extension(object o)
    {
        public string P2 => Extensions.get_P(o);
    }
}
""";

        comp3 = CreateCompilation(src3, references: [comp1MetadataReference], options: TestOptions.DebugExe);
        verifier3 = CompileAndVerify(comp3, expectedOutput: "12").VerifyDiagnostics();

        verifier3.VerifyIL("Program.Test", testIL);
        verifier3.VerifyIL("Extensions_.get_P2(object)", m2IL);

        comp3 = CreateCompilation(src3, references: [comp1ImageReference], options: TestOptions.DebugExe);
        verifier3 = CompileAndVerify(comp3, expectedOutput: "12").VerifyDiagnostics();

        verifier3.VerifyIL("Program.Test", testIL);
        verifier3.VerifyIL("Extensions_.get_P2(object)", m2IL);

        var vbComp = CreateVisualBasicCompilation("""
Class Program
    Shared Sub Main()
        System.Console.Write(Test2("3"))
    End Sub

    Shared Function Test2(o As String) As String
        return Extensions.get_P(o)
    End Function
End Class
""",
            referencedAssemblies: comp3.References, compilationOptions: new VisualBasicCompilationOptions(OutputKind.ConsoleApplication));

        CompileAndVerify(vbComp, expectedOutput: "3").VerifyDiagnostics();

        vbComp = CreateVisualBasicCompilation("""
Class Program
    Shared Sub Main()
        System.Console.Write(Test1("1"))
    End Sub

    Shared Function Test1(o As String) As String
        return o.get_P()
    End Function
End Class
""",
            referencedAssemblies: comp3.References, compilationOptions: new VisualBasicCompilationOptions(OutputKind.ConsoleApplication));

        vbComp.VerifyDiagnostics(
            // error BC30456: 'get_P' is not a member of 'String'.
            Diagnostic(30456 /*ERRID.ERR_NameNotMember2*/, "o.get_P").WithArguments("get_P", "String").WithLocation(7, 16)
            );

        var comp5 = CreateCompilation(src1);
        comp5.MakeMemberMissing(WellKnownMember.System_Runtime_CompilerServices_ExtensionAttribute__ctor);
        comp5.VerifyEmitDiagnostics(
            // (3,5): error CS1110: Cannot define a new extension because the compiler required type 'System.Runtime.CompilerServices.ExtensionAttribute' cannot be found. Are you missing a reference to System.Core.dll?
            //     extension(object o)
            Diagnostic(ErrorCode.ERR_ExtensionAttrNotFound, "extension").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(3, 5)
            );
    }

    [Fact]
    public void Implementation_StaticProperty_01()
    {
        var src1 = """
public static class Extensions
{
    extension(object)
    {
        public static string P => "P";
    }
}
""";
        var comp1 = CreateCompilation(src1);

        MethodSymbol implementation = comp1.GetTypeByMetadataName("Extensions").GetMembers().OfType<MethodSymbol>().Single();
        Assert.True(implementation.IsStatic);
        Assert.Equal(MethodKind.Ordinary, implementation.MethodKind);
        Assert.Equal(0, implementation.ParameterCount);
        AssertEx.Equal("System.String Extensions.get_P()", implementation.ToTestDisplayString());
        Assert.True(implementation.IsImplicitlyDeclared);
        Assert.False(implementation.IsExtensionMethod);
        Assert.True(implementation.HasSpecialName);
        Assert.False(implementation.HasRuntimeSpecialName);

        var verifier1 = CompileAndVerify(comp1).VerifyDiagnostics();

        var expectedTypeIL = """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object ''
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x206e
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig specialname static 
            string get_P () cil managed 
        {
            // Method begins at RVA 0x2070
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::get_P
        // Properties
        .property string P()
        {
            .get string Extensions/'<>E__0'::get_P()
        }
    } // end of class <>E__0
    // Methods
    .method public hidebysig specialname static 
        string get_P () cil managed 
    {
        // Method begins at RVA 0x2067
        // Code size 6 (0x6)
        .maxstack 8
        IL_0000: ldstr "P"
        IL_0005: ret
    } // end of method Extensions::get_P
} // end of class Extensions
""";

        verifier1.VerifyTypeIL("Extensions", expectedTypeIL.Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test());
        System.Console.Write(object.P2);
    }

    static string Test()
    {
        return object.P;
    }
}

static class Extensions
{
    extension(object o)
    {
        public static string P2 => object.P;
    }
}
""";

        var comp1MetadataReference = comp1.ToMetadataReference();
        var comp3 = CreateCompilation(src3, references: [comp1MetadataReference], options: TestOptions.DebugExe);
        var verifier3 = CompileAndVerify(comp3, expectedOutput: "PP").VerifyDiagnostics();

        var testIL =
@"
{
  // Code size       11 (0xb)
  .maxstack  1
  .locals init (string V_0)
  IL_0000:  nop
  IL_0001:  call       ""string Extensions.get_P()""
  IL_0006:  stloc.0
  IL_0007:  br.s       IL_0009
  IL_0009:  ldloc.0
  IL_000a:  ret
}
";
        verifier3.VerifyIL("Program.Test", testIL);

        var m2IL =
@"
{
  // Code size        6 (0x6)
  .maxstack  1
  IL_0000:  call       ""string Extensions.get_P()""
  IL_0005:  ret
}
";
        verifier3.VerifyIL("Extensions.get_P2()", m2IL);

        var comp1ImageReference = comp1.EmitToImageReference();
        comp3 = CreateCompilation(src3, references: [comp1ImageReference], options: TestOptions.DebugExe);
        verifier3 = CompileAndVerify(comp3, expectedOutput: "PP").VerifyDiagnostics();

        verifier3.VerifyIL("Program.Test", testIL);
        verifier3.VerifyIL("Extensions.get_P2()", m2IL);

        comp3 = CreateCompilationWithIL(src3, expectedTypeIL, options: TestOptions.DebugExe);
        CompileAndVerify(comp3, expectedOutput: "PP").VerifyDiagnostics();

        var remove = """
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
""";

        comp3 = CreateCompilationWithIL(src3, expectedTypeIL.Remove(expectedTypeIL.IndexOf(remove), remove.Length));
        comp3.VerifyDiagnostics(
            // (11,23): error CS0117: 'object' does not contain a definition for 'P'
            //         return object.P;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "P").WithArguments("object", "P").WithLocation(11, 23),
            // (19,43): error CS0117: 'object' does not contain a definition for 'P'
            //         public static string P2 => object.P;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "P").WithArguments("object", "P").WithLocation(19, 43)
            );

        src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test());
        System.Console.Write(object.P2);
    }

    static string Test()
    {
        return Extensions.get_P();
    }
}

static class Extensions_
{
    extension(object o)
    {
        public static string P2 => Extensions.get_P();
    }
}
""";

        comp3 = CreateCompilation(src3, references: [comp1MetadataReference], options: TestOptions.DebugExe);
        verifier3 = CompileAndVerify(comp3, expectedOutput: "PP").VerifyDiagnostics();

        verifier3.VerifyIL("Program.Test", testIL);
        verifier3.VerifyIL("Extensions_.get_P2()", m2IL);

        comp3 = CreateCompilation(src3, references: [comp1ImageReference], options: TestOptions.DebugExe);
        verifier3 = CompileAndVerify(comp3, expectedOutput: "PP").VerifyDiagnostics();

        verifier3.VerifyIL("Program.Test", testIL);
        verifier3.VerifyIL("Extensions_.get_P2()", m2IL);

        var vbComp = CreateVisualBasicCompilation("""
Class Program
    Shared Sub Main()
        System.Console.Write(Test2())
    End Sub

    Shared Function Test2() As String
        return Extensions.get_P()
    End Function
End Class
""",
            referencedAssemblies: comp3.References, compilationOptions: new VisualBasicCompilationOptions(OutputKind.ConsoleApplication));

        CompileAndVerify(vbComp, expectedOutput: "P").VerifyDiagnostics();

        var comp5 = CreateCompilation(src1);
        comp5.MakeMemberMissing(WellKnownMember.System_Runtime_CompilerServices_ExtensionAttribute__ctor);
        comp5.VerifyEmitDiagnostics(
            // (3,5): error CS1110: Cannot define a new extension because the compiler required type 'System.Runtime.CompilerServices.ExtensionAttribute' cannot be found. Are you missing a reference to System.Core.dll?
            //     extension(object)
            Diagnostic(ErrorCode.ERR_ExtensionAttrNotFound, "extension").WithArguments("System.Runtime.CompilerServices.ExtensionAttribute").WithLocation(3, 5)
            );
    }

    [Fact]
    public void Implementation_InstanceProperty_02()
    {
        var src1 = """
public static class Extensions
{
    extension(object o)
    {
        public string P { get { return o.ToString(); } }
    }
}
""";
        var comp1 = CreateCompilation(src1);
        var verifier1 = CompileAndVerify(comp1).VerifyDiagnostics();

        verifier1.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x206f
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method public hidebysig specialname 
            instance string get_P () cil managed 
        {
            // Method begins at RVA 0x2071
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::get_P
        // Properties
        .property instance string P()
        {
            .get instance string Extensions/'<>E__0'::get_P()
        }
    } // end of class <>E__0
    // Methods
    .method public hidebysig specialname static 
        string get_P (
            object o
        ) cil managed 
    {
        // Method begins at RVA 0x2067
        // Code size 7 (0x7)
        .maxstack 8
        IL_0000: ldarg.0
        IL_0001: callvirt instance string [mscorlib]System.Object::ToString()
        IL_0006: ret
    } // end of method Extensions::get_P
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src3 = """
class Program
{
    static void Main()
    {
        System.Console.Write(Test("1"));
        System.Console.Write("2".P2);
    }

    static string Test(object o)
    {
        return o.P;
    }
}

static class Extensions
{
    extension(object o)
    {
        public string P2 => o.P;
    }
}
""";

        var comp3 = CreateCompilation(src3, references: [comp1.ToMetadataReference()], options: TestOptions.DebugExe);
        var verifier3 = CompileAndVerify(comp3, expectedOutput: "12").VerifyDiagnostics();

        var testIL =
@"
{
  // Code size       12 (0xc)
  .maxstack  1
  .locals init (string V_0)
  IL_0000:  nop
  IL_0001:  ldarg.0
  IL_0002:  call       ""string Extensions.get_P(object)""
  IL_0007:  stloc.0
  IL_0008:  br.s       IL_000a
  IL_000a:  ldloc.0
  IL_000b:  ret
}
";
        verifier3.VerifyIL("Program.Test", testIL);

        var m2IL =
@"
{
  // Code size        7 (0x7)
  .maxstack  1
  IL_0000:  ldarg.0
  IL_0001:  call       ""string Extensions.get_P(object)""
  IL_0006:  ret
}
";
        verifier3.VerifyIL("Extensions.get_P2(object)", m2IL);

        comp3 = CreateCompilation(src3, references: [comp1.EmitToImageReference()], options: TestOptions.DebugExe);
        verifier3 = CompileAndVerify(comp3, expectedOutput: "12").VerifyDiagnostics();

        verifier3.VerifyIL("Program.Test", testIL);
        verifier3.VerifyIL("Extensions.get_P2(object)", m2IL);
    }

    [Fact]
    public void Implementation_DelegateCaching_01()
    {
        var src = """
public static class Extensions
{
    extension<T>(T o)
    {
        void M2<U>()
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            System.Func<V> local<V>()
            {
                return C1.M1<T, U, V>;
            }
        }
    }
}

class C1
{
    static public V M1<T, U, V>() => default;
}
""";
        var comp = CreateCompilation(src);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics(); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Consider executing and verifying behavior

        verifier.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<T>
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                !T o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2067
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
        .method private hidebysig 
            instance void M2<U> () cil managed 
        {
            // Method begins at RVA 0x20a6
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0`1'::M2
    } // end of class <>E__0`1
    .class nested private auto ansi abstract sealed beforefieldinit '<local>O__1_0`3'<T, U, V>
        extends [mscorlib]System.Object
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public static class [mscorlib]System.Func`1<!V> '<0>__M1'
    } // end of class <local>O__1_0`3
    // Methods
    .method private hidebysig specialname static 
        void M2<T, U> (
            !!T o
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 1 (0x1)
        .maxstack 8
        IL_0000: ret
    } // end of method Extensions::M2
    .method assembly hidebysig static 
        class [mscorlib]System.Func`1<!!V> '<M2>b__1_0'<T, U, V> () cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2069
        // Code size 28 (0x1c)
        .maxstack 8
        IL_0000: ldsfld class [mscorlib]System.Func`1<!2> class Extensions/'<local>O__1_0`3'<!!T, !!U, !!V>::'<0>__M1'
        IL_0005: dup
        IL_0006: brtrue.s IL_001b
        IL_0008: pop
        IL_0009: ldnull
        IL_000a: ldftn !!2 C1::M1<!!T, !!U, !!V>()
        IL_0010: newobj instance void class [mscorlib]System.Func`1<!!V>::.ctor(object, native int)
        IL_0015: dup
        IL_0016: stsfld class [mscorlib]System.Func`1<!2> class Extensions/'<local>O__1_0`3'<!!T, !!U, !!V>::'<0>__M1'
        IL_001b: ret
    } // end of method Extensions::'<M2>b__1_0'
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension<T>(T o)
    {
        void M2<U>()
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            System.Func<V> local<V>()
            {
                return C1.M1<T, U, V>;
            }
        }
    }

    extension<T>(T o)
    {
        void M2<U>(int x)
        {
            System.Func<V> local<V>()
            {
                return C1.M1<T, U, V>;
            }
        }
    }
}

class C1
{
    static public V M1<T, U, V>() => default;
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_DelegateCaching_02()
    {
        var src = """
public static class Extensions
{
    extension<T>(T o)
    {
        void M2()
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            System.Action local()
            {
                return C1.M1<T>;
            }
        }
    }
}

class C1
{
    static public void M1<T>() {}
}
""";
        var comp = CreateCompilation(src);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics(); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Consider executing and verifying behavior

        verifier.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<T>
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                !T o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2067
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
        .method private hidebysig 
            instance void M2 () cil managed 
        {
            // Method begins at RVA 0x208e
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0`1'::M2
    } // end of class <>E__0`1
    .class nested private auto ansi abstract sealed beforefieldinit '<>O__1_0`1'<T>
        extends [mscorlib]System.Object
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public static class [mscorlib]System.Action '<0>__M1'
    } // end of class <>O__1_0`1
    // Methods
    .method private hidebysig specialname static 
        void M2<T> (
            !!T o
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 1 (0x1)
        .maxstack 8
        IL_0000: ret
    } // end of method Extensions::M2
    .method assembly hidebysig static 
        class [mscorlib]System.Action '<M2>b__1_0'<T> () cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2069
        // Code size 28 (0x1c)
        .maxstack 8
        IL_0000: ldsfld class [mscorlib]System.Action class Extensions/'<>O__1_0`1'<!!T>::'<0>__M1'
        IL_0005: dup
        IL_0006: brtrue.s IL_001b
        IL_0008: pop
        IL_0009: ldnull
        IL_000a: ldftn void C1::M1<!!T>()
        IL_0010: newobj instance void [mscorlib]System.Action::.ctor(object, native int)
        IL_0015: dup
        IL_0016: stsfld class [mscorlib]System.Action class Extensions/'<>O__1_0`1'<!!T>::'<0>__M1'
        IL_001b: ret
    } // end of method Extensions::'<M2>b__1_0'
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension<T>(T o)
    {
        void M2()
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            System.Action local()
            {
                return C1.M1<T>;
            }
        }
    }

    extension<T>(T o)
    {
        void M2(int x)
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            System.Action local()
            {
                return C1.M1<T>;
            }
        }
    }
}

class C1
{
    static public void M1<T>() {}
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_DelegateCaching_03()
    {
        var src = """
public static class Extensions
{
    extension(object o)
    {
        void M2()
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            System.Action local()
            {
                return C1.M1;
            }
        }
    }
}

class C1
{
    static public void M1() {}
}
""";
        var comp = CreateCompilation(src);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics(); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Consider executing and verifying behavior

        verifier.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2067
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method private hidebysig 
            instance void M2 () cil managed 
        {
            // Method begins at RVA 0x208e
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M2
    } // end of class <>E__0
    .class nested private auto ansi abstract sealed beforefieldinit '<>O'
        extends [mscorlib]System.Object
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public static class [mscorlib]System.Action '<0>__M1'
    } // end of class <>O
    // Methods
    .method private hidebysig specialname static 
        void M2 (
            object o
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 1 (0x1)
        .maxstack 8
        IL_0000: ret
    } // end of method Extensions::M2
    .method assembly hidebysig static 
        class [mscorlib]System.Action '<M2>b__1_0' () cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2069
        // Code size 28 (0x1c)
        .maxstack 8
        IL_0000: ldsfld class [mscorlib]System.Action Extensions/'<>O'::'<0>__M1'
        IL_0005: dup
        IL_0006: brtrue.s IL_001b
        IL_0008: pop
        IL_0009: ldnull
        IL_000a: ldftn void C1::M1()
        IL_0010: newobj instance void [mscorlib]System.Action::.ctor(object, native int)
        IL_0015: dup
        IL_0016: stsfld class [mscorlib]System.Action Extensions/'<>O'::'<0>__M1'
        IL_001b: ret
    } // end of method Extensions::'<M2>b__1_0'
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension(object o)
    {
        void M2()
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            System.Action local()
            {
                return C1.M1;
            }
        }
    }

    extension(object o)
    {
        void M2(int x)
        {
            System.Action local()
            {
                return C1.M1;
            }
        }
    }
}

class C1
{
    static public void M1() {}
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_DelegateCaching_04()
    {
        var src = """
public static class Extensions
{
    extension<T>(T o)
    {
        System.Action M2()
        {
            return local;

            static void local()
            {
                typeof(T).ToString();
            }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics(); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Consider executing and verifying behavior

        verifier.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<T>
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                !T o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2096
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
        .method private hidebysig 
            instance class [mscorlib]System.Action M2 () cil managed 
        {
            // Method begins at RVA 0x2098
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0`1'::M2
    } // end of class <>E__0`1
    .class nested private auto ansi abstract sealed beforefieldinit '<>O__1_0`1'<T>
        extends [mscorlib]System.Object
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public static class [mscorlib]System.Action '<0>__local'
    } // end of class <>O__1_0`1
    // Methods
    .method private hidebysig specialname static 
        class [mscorlib]System.Action M2<T> (
            !!T o
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 28 (0x1c)
        .maxstack 8
        IL_0000: ldsfld class [mscorlib]System.Action class Extensions/'<>O__1_0`1'<!!T>::'<0>__local'
        IL_0005: dup
        IL_0006: brtrue.s IL_001b
        IL_0008: pop
        IL_0009: ldnull
        IL_000a: ldftn void Extensions::'<M2>b__1_0'<!!T>()
        IL_0010: newobj instance void [mscorlib]System.Action::.ctor(object, native int)
        IL_0015: dup
        IL_0016: stsfld class [mscorlib]System.Action class Extensions/'<>O__1_0`1'<!!T>::'<0>__local'
        IL_001b: ret
    } // end of method Extensions::M2
    .method assembly hidebysig static 
        void '<M2>b__1_0'<T> () cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2084
        // Code size 17 (0x11)
        .maxstack 8
        IL_0000: ldtoken !!T
        IL_0005: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
        IL_000a: callvirt instance string [mscorlib]System.Object::ToString()
        IL_000f: pop
        IL_0010: ret
    } // end of method Extensions::'<M2>b__1_0'
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension<T>(T o)
    {
        System.Action M2()
        {
            return local;

            static void local()
            {
                typeof(T).ToString();
            }
        }
    }

    extension<T>(T o)
    {
        System.Action M2(int x)
        {
            return local;

            static void local()
            {
                typeof(T).ToString();
            }
        }
    }
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_DelegateCaching_05()
    {
        var src = """
public static class Extensions
{
    extension(object o)
    {
        System.Action M2()
        {
            return local;

            static void local()
            {
                typeof(object).ToString();
            }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics(); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Consider executing and verifying behavior

        verifier.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2096
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method private hidebysig 
            instance class [mscorlib]System.Action M2 () cil managed 
        {
            // Method begins at RVA 0x2098
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M2
    } // end of class <>E__0
    .class nested private auto ansi abstract sealed beforefieldinit '<>O'
        extends [mscorlib]System.Object
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public static class [mscorlib]System.Action '<0>__local'
    } // end of class <>O
    // Methods
    .method private hidebysig specialname static 
        class [mscorlib]System.Action M2 (
            object o
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 28 (0x1c)
        .maxstack 8
        IL_0000: ldsfld class [mscorlib]System.Action Extensions/'<>O'::'<0>__local'
        IL_0005: dup
        IL_0006: brtrue.s IL_001b
        IL_0008: pop
        IL_0009: ldnull
        IL_000a: ldftn void Extensions::'<M2>b__1_0'()
        IL_0010: newobj instance void [mscorlib]System.Action::.ctor(object, native int)
        IL_0015: dup
        IL_0016: stsfld class [mscorlib]System.Action Extensions/'<>O'::'<0>__local'
        IL_001b: ret
    } // end of method Extensions::M2
    .method assembly hidebysig static 
        void '<M2>b__1_0' () cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2084
        // Code size 17 (0x11)
        .maxstack 8
        IL_0000: ldtoken [mscorlib]System.Object
        IL_0005: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
        IL_000a: callvirt instance string [mscorlib]System.Object::ToString()
        IL_000f: pop
        IL_0010: ret
    } // end of method Extensions::'<M2>b__1_0'
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]"));

        var src2 = """
public static class Extensions
{
    extension(object o)
    {
        System.Action M2()
        {
            return local;

            static void local()
            {
                typeof(object).ToString();
            }
        }
    }

    extension(object o)
    {
        System.Action M2(int x)
        {
            return local;

            static void local()
            {
                typeof(object).ToString();
            }
        }
    }
}
""";
        var comp2 = CreateCompilation(src2);
        CompileAndVerify(comp2).VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_DynamicCallSite_01()
    {
        var src = """
public static class Extensions
{
    extension<T>(T o)
    {
        void M2<U>()
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            void local<V>(dynamic d, T t, U u, V v)
            {
                d.M1(t, u, v);
            }
        }
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.StandardAndCSharp);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics(); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Consider executing and verifying behavior

        verifier.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<T>
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                !T o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2067
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
        .method private hidebysig 
            instance void M2<U> () cil managed 
        {
            // Method begins at RVA 0x20ea
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0`1'::M2
    } // end of class <>E__0`1
    .class nested private auto ansi abstract sealed beforefieldinit '<>o__0|1`3'<T, U, V>
        extends [mscorlib]System.Object
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public static class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`5<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !T, !U, !V>> '<>p__0'
    } // end of class <>o__0|1`3
    // Methods
    .method private hidebysig specialname static 
        void M2<T, U> (
            !!T o
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 1 (0x1)
        .maxstack 8
        IL_0000: ret
    } // end of method Extensions::M2
    .method assembly hidebysig static 
        void '<M2>b__1_0'<T, U, V> (
            object d,
            !!T t,
            !!U u,
            !!V v
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        .param [1]
            .custom instance void [System.Core]System.Runtime.CompilerServices.DynamicAttribute::.ctor() = (
                01 00 00 00
            )
        // Method begins at RVA 0x206c
        // Code size 114 (0x72)
        .maxstack 9
        IL_0000: ldsfld class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`5<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !0, !1, !2>> class Extensions/'<>o__0|1`3'<!!T, !!U, !!V>::'<>p__0'
        IL_0005: brtrue.s IL_0059
        IL_0007: ldc.i4 256
        IL_000c: ldstr "M1"
        IL_0011: ldnull
        IL_0012: ldtoken Extensions
        IL_0017: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
        IL_001c: ldc.i4.4
        IL_001d: newarr [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo
        IL_0022: dup
        IL_0023: ldc.i4.0
        IL_0024: ldc.i4.0
        IL_0025: ldnull
        IL_0026: call class [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo::Create(valuetype [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags, string)
        IL_002b: stelem.ref
        IL_002c: dup
        IL_002d: ldc.i4.1
        IL_002e: ldc.i4.1
        IL_002f: ldnull
        IL_0030: call class [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo::Create(valuetype [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags, string)
        IL_0035: stelem.ref
        IL_0036: dup
        IL_0037: ldc.i4.2
        IL_0038: ldc.i4.1
        IL_0039: ldnull
        IL_003a: call class [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo::Create(valuetype [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags, string)
        IL_003f: stelem.ref
        IL_0040: dup
        IL_0041: ldc.i4.3
        IL_0042: ldc.i4.1
        IL_0043: ldnull
        IL_0044: call class [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo::Create(valuetype [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags, string)
        IL_0049: stelem.ref
        IL_004a: call class [System.Core]System.Runtime.CompilerServices.CallSiteBinder [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.Binder::InvokeMember(valuetype [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags, string, class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.Type>, class [mscorlib]System.Type, class [mscorlib]System.Collections.Generic.IEnumerable`1<class [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo>)
        IL_004f: call class [System.Core]System.Runtime.CompilerServices.CallSite`1<!0> class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`5<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !!T, !!U, !!V>>::Create(class [System.Core]System.Runtime.CompilerServices.CallSiteBinder)
        IL_0054: stsfld class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`5<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !0, !1, !2>> class Extensions/'<>o__0|1`3'<!!T, !!U, !!V>::'<>p__0'
        IL_0059: ldsfld class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`5<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !0, !1, !2>> class Extensions/'<>o__0|1`3'<!!T, !!U, !!V>::'<>p__0'
        IL_005e: ldfld !0 class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`5<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !!T, !!U, !!V>>::Target
        IL_0063: ldsfld class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`5<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !0, !1, !2>> class Extensions/'<>o__0|1`3'<!!T, !!U, !!V>::'<>p__0'
        IL_0068: ldarg.0
        IL_0069: ldarg.1
        IL_006a: ldarg.2
        IL_006b: ldarg.3
        IL_006c: callvirt instance void class [mscorlib]System.Action`5<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !!T, !!U, !!V>::Invoke(!0, !1, !2, !3, !4)
        IL_0071: ret
    } // end of method Extensions::'<M2>b__1_0'
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]").
    Replace("[System.Core]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[System.Core]"));

        var src2 = """
public static class Extensions
{
    extension<T>(T o)
    {
        void M2<U>()
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            void local<V>(dynamic d, T t, U u, V v)
            {
                d.M1(t, u, v);
            }
        }
    }

    extension<T>(T o)
    {
        void M2<U>(int x)
        {
            void local<V>(dynamic d, T t, U u, V v)
            {
                d.M1(t, u, v);
            }
        }
    }
}
""";
        var comp2 = CreateCompilation(src2, targetFramework: TargetFramework.StandardAndCSharp);
        CompileAndVerify(comp2).VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_DynamicCallSite_02()
    {
        var src = """
public static class Extensions
{
    extension<T>(T o)
    {
        void M2()
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            void local(dynamic d, T t)
            {
                d.M1(t);
            }
        }
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.StandardAndCSharp);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics(); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Consider executing and verifying behavior

        verifier.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0`1'<T>
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                !T o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2067
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0`1'::'<Extension>$'
        .method private hidebysig 
            instance void M2 () cil managed 
        {
            // Method begins at RVA 0x20d4
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0`1'::M2
    } // end of class <>E__0`1
    .class nested private auto ansi abstract sealed beforefieldinit '<>o__1`1'<T>
        extends [mscorlib]System.Object
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public static class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`3<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !T>> '<>p__0'
    } // end of class <>o__1`1
    // Methods
    .method private hidebysig specialname static 
        void M2<T> (
            !!T o
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 1 (0x1)
        .maxstack 8
        IL_0000: ret
    } // end of method Extensions::M2
    .method assembly hidebysig static 
        void '<M2>b__1_0'<T> (
            object d,
            !!T t
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        .param [1]
            .custom instance void [System.Core]System.Runtime.CompilerServices.DynamicAttribute::.ctor() = (
                01 00 00 00
            )
        // Method begins at RVA 0x206c
        // Code size 92 (0x5c)
        .maxstack 9
        IL_0000: ldsfld class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`3<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !0>> class Extensions/'<>o__1`1'<!!T>::'<>p__0'
        IL_0005: brtrue.s IL_0045
        IL_0007: ldc.i4 256
        IL_000c: ldstr "M1"
        IL_0011: ldnull
        IL_0012: ldtoken Extensions
        IL_0017: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
        IL_001c: ldc.i4.2
        IL_001d: newarr [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo
        IL_0022: dup
        IL_0023: ldc.i4.0
        IL_0024: ldc.i4.0
        IL_0025: ldnull
        IL_0026: call class [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo::Create(valuetype [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags, string)
        IL_002b: stelem.ref
        IL_002c: dup
        IL_002d: ldc.i4.1
        IL_002e: ldc.i4.1
        IL_002f: ldnull
        IL_0030: call class [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo::Create(valuetype [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags, string)
        IL_0035: stelem.ref
        IL_0036: call class [System.Core]System.Runtime.CompilerServices.CallSiteBinder [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.Binder::InvokeMember(valuetype [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags, string, class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.Type>, class [mscorlib]System.Type, class [mscorlib]System.Collections.Generic.IEnumerable`1<class [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo>)
        IL_003b: call class [System.Core]System.Runtime.CompilerServices.CallSite`1<!0> class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`3<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !!T>>::Create(class [System.Core]System.Runtime.CompilerServices.CallSiteBinder)
        IL_0040: stsfld class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`3<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !0>> class Extensions/'<>o__1`1'<!!T>::'<>p__0'
        IL_0045: ldsfld class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`3<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !0>> class Extensions/'<>o__1`1'<!!T>::'<>p__0'
        IL_004a: ldfld !0 class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`3<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !!T>>::Target
        IL_004f: ldsfld class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`3<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !0>> class Extensions/'<>o__1`1'<!!T>::'<>p__0'
        IL_0054: ldarg.0
        IL_0055: ldarg.1
        IL_0056: callvirt instance void class [mscorlib]System.Action`3<class [System.Core]System.Runtime.CompilerServices.CallSite, object, !!T>::Invoke(!0, !1, !2)
        IL_005b: ret
    } // end of method Extensions::'<M2>b__1_0'
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]").
    Replace("[System.Core]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[System.Core]"));

        var src2 = """
public static class Extensions
{
    extension<T>(T o)
    {
        void M2()
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            void local(dynamic d, T t)
            {
                d.M1(t);
            }
        }
    }

    extension<T>(T o)
    {
        void M2(int x)
        {
            void local(dynamic d, T t)
            {
                d.M1(t);
            }
        }
    }
}
""";
        var comp2 = CreateCompilation(src2, targetFramework: TargetFramework.StandardAndCSharp);
        CompileAndVerify(comp2).VerifyDiagnostics();
    }

    [Fact]
    public void Implementation_DynamicCallSite_03()
    {
        var src = """
public static class Extensions
{
    extension(object o)
    {
        void M2()
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            void local(dynamic d)
            {
                d.M1();
            }
        }
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.StandardAndCSharp);
        var verifier = CompileAndVerify(comp).VerifyDiagnostics(); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Consider executing and verifying behavior

        verifier.VerifyTypeIL("Extensions", """
.class public auto ansi abstract sealed beforefieldinit Extensions
    extends [mscorlib]System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    // Nested Types
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends [mscorlib]System.Object
    {
        // Methods
        .method private hidebysig specialname static 
            void '<Extension>$' (
                object o
            ) cil managed 
        {
            .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
                01 00 00 00
            )
            // Method begins at RVA 0x2067
            // Code size 1 (0x1)
            .maxstack 8
            IL_0000: ret
        } // end of method '<>E__0'::'<Extension>$'
        .method private hidebysig 
            instance void M2 () cil managed 
        {
            // Method begins at RVA 0x20c9
            // Code size 2 (0x2)
            .maxstack 8
            IL_0000: ldnull
            IL_0001: throw
        } // end of method '<>E__0'::M2
    } // end of class <>E__0
    .class nested private auto ansi abstract sealed beforefieldinit '<>o__1'
        extends [mscorlib]System.Object
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        // Fields
        .field public static class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`2<class [System.Core]System.Runtime.CompilerServices.CallSite, object>> '<>p__0'
    } // end of class <>o__1
    // Methods
    .method private hidebysig specialname static 
        void M2 (
            object o
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        // Method begins at RVA 0x2067
        // Code size 1 (0x1)
        .maxstack 8
        IL_0000: ret
    } // end of method Extensions::M2
    .method assembly hidebysig static 
        void '<M2>b__1_0' (
            object d
        ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
            01 00 00 00
        )
        .param [1]
            .custom instance void [System.Core]System.Runtime.CompilerServices.DynamicAttribute::.ctor() = (
                01 00 00 00
            )
        // Method begins at RVA 0x206c
        // Code size 81 (0x51)
        .maxstack 9
        IL_0000: ldsfld class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`2<class [System.Core]System.Runtime.CompilerServices.CallSite, object>> Extensions/'<>o__1'::'<>p__0'
        IL_0005: brtrue.s IL_003b
        IL_0007: ldc.i4 256
        IL_000c: ldstr "M1"
        IL_0011: ldnull
        IL_0012: ldtoken Extensions
        IL_0017: call class [mscorlib]System.Type [mscorlib]System.Type::GetTypeFromHandle(valuetype [mscorlib]System.RuntimeTypeHandle)
        IL_001c: ldc.i4.1
        IL_001d: newarr [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo
        IL_0022: dup
        IL_0023: ldc.i4.0
        IL_0024: ldc.i4.0
        IL_0025: ldnull
        IL_0026: call class [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo::Create(valuetype [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags, string)
        IL_002b: stelem.ref
        IL_002c: call class [System.Core]System.Runtime.CompilerServices.CallSiteBinder [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.Binder::InvokeMember(valuetype [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags, string, class [mscorlib]System.Collections.Generic.IEnumerable`1<class [mscorlib]System.Type>, class [mscorlib]System.Type, class [mscorlib]System.Collections.Generic.IEnumerable`1<class [Microsoft.CSharp]Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo>)
        IL_0031: call class [System.Core]System.Runtime.CompilerServices.CallSite`1<!0> class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`2<class [System.Core]System.Runtime.CompilerServices.CallSite, object>>::Create(class [System.Core]System.Runtime.CompilerServices.CallSiteBinder)
        IL_0036: stsfld class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`2<class [System.Core]System.Runtime.CompilerServices.CallSite, object>> Extensions/'<>o__1'::'<>p__0'
        IL_003b: ldsfld class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`2<class [System.Core]System.Runtime.CompilerServices.CallSite, object>> Extensions/'<>o__1'::'<>p__0'
        IL_0040: ldfld !0 class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`2<class [System.Core]System.Runtime.CompilerServices.CallSite, object>>::Target
        IL_0045: ldsfld class [System.Core]System.Runtime.CompilerServices.CallSite`1<class [mscorlib]System.Action`2<class [System.Core]System.Runtime.CompilerServices.CallSite, object>> Extensions/'<>o__1'::'<>p__0'
        IL_004a: ldarg.0
        IL_004b: callvirt instance void class [mscorlib]System.Action`2<class [System.Core]System.Runtime.CompilerServices.CallSite, object>::Invoke(!0, !1)
        IL_0050: ret
    } // end of method Extensions::'<M2>b__1_0'
} // end of class Extensions
""".Replace("[mscorlib]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[mscorlib]").
    Replace("[System.Core]", ExecutionConditionUtil.IsMonoOrCoreClr ? "[netstandard]" : "[System.Core]"));

        var src2 = """
public static class Extensions
{
    extension(object o)
    {
        void M2()
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            void local(dynamic d)
            {
                d.M1();
            }
        }
    }

    extension(object o)
    {
        void M2(int x)
        {
            #pragma warning disable CS8321 // The local function 'local' is declared but never used
            void local(dynamic d)
            {
                d.M1();
            }
        }
    }
}
""";
        var comp2 = CreateCompilation(src2, targetFramework: TargetFramework.StandardAndCSharp);
        CompileAndVerify(comp2).VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethodInvocation_Simple()
    {
        var src = """
new object().M();

public static class Extensions
{
    extension(object o)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new object().M()");
        Assert.Equal("void Extensions.<>E__0.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethodInvocation_Inaccessible()
    {
        var src = """
new object().M();

public static class Extensions
{
    extension(object o)
    {
        void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS1061: 'object' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // new object().M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("object", "M").WithLocation(1, 14));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new object().M()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Equal([], model.GetSymbolInfo(invocation).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal([], model.GetMemberGroup(invocation).ToTestDisplayStrings());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void Extensions.<>E__0.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void Extensions.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        src = """
new object().M();

public static class Extensions
{
    private static void M(this object o) { }
}
""";
        comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS1061: 'object' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // new object().M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("object", "M").WithLocation(1, 14));

        tree = comp.SyntaxTrees[0];
        model = comp.GetSemanticModel(tree);
        invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new object().M()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Equal([], model.GetSymbolInfo(invocation).CandidateSymbols.ToTestDisplayStrings());

        memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void System.Object.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void System.Object.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_Inaccessible_02()
    {
        var src = """
new object().M();

public static class E1
{
    extension(object o)
    {
        void M() { }
    }
}
public static class E2
{
    extension(object o)
    {
        public void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new object().M()");
        Assert.Equal("void E2.<>E__0.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(invocation).ToTestDisplayStrings());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("void E2.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E2.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        src = """
new object().M();

public static class E1
{
    private static void M(this object o) { }
}
public static class E2
{
    public static void M(this object o) { }
}
""";
        comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        tree = comp.SyntaxTrees[0];
        model = comp.GetSemanticModel(tree);
        invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new object().M()");
        Assert.Equal("void System.Object.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(invocation).ToTestDisplayStrings());

        memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("void System.Object.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void System.Object.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_GenericReceiverParameter()
    {
        var src = """
new object().M();

public static class Extensions
{
    extension<T>(T t)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new object().M()");
        Assert.Equal("void Extensions.<>E__0<System.Object>.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal(["void Extensions.<>E__0<System.Object>.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void StaticMethodInvocation_GenericReceiverParameter_Constrained()
    {
        var src = """
object.M();
int.M();
new object().M2();

public static class Extensions
{
    extension<T>(T) where T : struct
    {
        public static void M() { }
    }
    public static void M2<T>(this T t) where T : struct { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0453: The type 'object' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Extensions.extension<T>(T)'
            // object.M();
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M").WithArguments("Extensions.extension<T>(T)", "T", "object").WithLocation(1, 8),
            // (3,14): error CS0453: The type 'object' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Extensions.M2<T>(T)'
            // new object().M2();
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M2").WithArguments("Extensions.M2<T>(T)", "T", "object").WithLocation(3, 14));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "object.M()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);

        invocation = GetSyntax<InvocationExpressionSyntax>(tree, "int.M()");
        Assert.Equal("void Extensions.<>E__0<System.Int32>.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.M");
        Assert.Equal(["void Extensions.<>E__0<System.Int32>.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyAccess_GenericReceiverParameter_Constrained()
    {
        var src = """
_ = object.P;
_ = int.P;

public static class E
{
    extension<T>(T) where T : struct
    {
        public static int P => 0;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS9286: 'object' does not contain a definition for 'P' and no accessible extension member 'P' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // _ = object.P;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "object.P").WithArguments("object", "P").WithLocation(1, 5));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.P");
        Assert.Equal("System.Int32 E.<>E__0<T>.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : handle GetMemberGroup on a property access

        memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.P");
        Assert.Equal("System.Int32 E.<>E__0<System.Int32>.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : handle GetMemberGroup on a property access
    }

    [Fact]
    public void ReceiverParameter_TypeWithUseSiteError()
    {
        var lib1_cs = "public class MissingBase { }";
        var comp1 = CreateCompilation(lib1_cs, assemblyName: "missing");
        comp1.VerifyDiagnostics();

        var lib2_cs = "public class UseSiteError : MissingBase { }";
        var comp2 = CreateCompilation(lib2_cs, [comp1.EmitToImageReference()]);
        comp2.VerifyDiagnostics();

        var src = """
class C<T> { }
static class Extensions
{
    extension(UseSiteError) { }
    extension(C<UseSiteError>) { }
}

class C1 
{
    void M(UseSiteError x) { }
    void M(C<UseSiteError> x) { }
}
""";
        var comp = CreateCompilation(src, [comp2.EmitToImageReference()]);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_SuppressConstraintChecksInitially()
    {
        var text = @"
public class C1<T> where T : struct { }

public static class Extensions
{
    extension<T>(C1<T>) { }
}
";
        var comp = CreateCompilation(text);
        comp.VerifyEmitDiagnostics(
            // (6,18): error CS0453: The type 'T' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'C1<T>'
            //     extension<T>(C1<T>) { }
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "C1<T>").WithArguments("C1<T>", "T", "T").WithLocation(6, 18));
    }

    [Fact]
    public void ReceiverParameter_SuppressConstraintChecksInitially_PointerAsTypeArgument()
    {
        var text = @"
public class C<T> { }

unsafe static class Extensions
{
    extension(C<int*>) { }
}
";
        var comp = CreateCompilation(text, options: TestOptions.UnsafeDebugDll);
        comp.VerifyEmitDiagnostics(
            // (6,15): error CS0306: The type 'int*' may not be used as a type argument
            //     extension(C<int*>) { }
            Diagnostic(ErrorCode.ERR_BadTypeArgument, "C<int*>").WithArguments("int*").WithLocation(6, 15));
    }

    [Fact]
    public void InstanceMethodInvocation_VariousScopes_Errors()
    {
        var cSrc = """
class C
{
    public static void Main()
    {
        new object().Method();
        _ = new object().Property;
    }
}
""";

        var eSrc = """
static class Extensions
{
    extension(object o)
    {
        public void Method() => throw null;
        public int Property => throw null;
    }
}
""";

        var src1 = $$"""
namespace N
{
    {{cSrc}}
    namespace N2
    {
        {{eSrc}}
    }
}
""";

        verify(src1,
            // (7,22): error CS1061: 'object' does not contain a definition for 'Method' and no accessible extension method 'Method' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            //         new object().Method();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Method").WithArguments("object", "Method").WithLocation(7, 22),
            // (8,26): error CS1061: 'object' does not contain a definition for 'Property' and no accessible extension method 'Property' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            //         _ = new object().Property;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Property").WithArguments("object", "Property").WithLocation(8, 26));

        var src2 = $$"""
file {{eSrc}}
""";

        verify(new[] { cSrc, src2 },
            // 0.cs(5,22): error CS1061: 'object' does not contain a definition for 'Method' and no accessible extension method 'Method' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            //         new object().Method();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Method").WithArguments("object", "Method").WithLocation(5, 22),
            // 0.cs(6,26): error CS1061: 'object' does not contain a definition for 'Property' and no accessible extension method 'Property' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            //         _ = new object().Property;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Property").WithArguments("object", "Property").WithLocation(6, 26));

        static void verify(CSharpTestSource src, params DiagnosticDescription[] expected)
        {
            var comp = CreateCompilation(src, options: TestOptions.DebugExe);
            comp.VerifyEmitDiagnostics(expected);

            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);

            var method = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().Method");
            Assert.Null(model.GetSymbolInfo(method).Symbol);
            Assert.Empty(model.GetMemberGroup(method));

            var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().Property");
            Assert.Null(model.GetSymbolInfo(property).Symbol);
            Assert.Empty(model.GetMemberGroup(property));
        }
    }

    [Fact]
    public void InstanceMethodInvocation_FromUsingNamespace()
    {
        var cSrc = """
class C
{
    public static void Main()
    {
        new object().Method();
    }
}
""";

        var eSrc = """
namespace N2
{
    static class E
    {
        extension(object o)
        {
            public void Method() => throw null;
        }
    }
}
""";

        var src1 = $$"""
using N2;
{{cSrc}}

{{eSrc}}
""";
        verify(src1, "N2.E.<>E__0");

        var src2 = $$"""
using N2;
using N2; // 1, 2
{{cSrc}}

{{eSrc}}
""";

        var comp = CreateCompilation(src2, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics(
            // (2,1): hidden CS8019: Unnecessary using directive.
            // using N2; // 1, 2
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N2;").WithLocation(2, 1),
            // (2,7): warning CS0105: The using directive for 'N2' appeared previously in this namespace
            // using N2; // 1, 2
            Diagnostic(ErrorCode.WRN_DuplicateUsing, "N2").WithArguments("N2").WithLocation(2, 7)
            );

        var src3 = $$"""
namespace N3
{
    using N2;

    namespace N4
    {
        {{cSrc}}
    }

    {{eSrc}}
}
""";
        verify(src3, "N3.N2.E.<>E__0");

        void verify(string src, string extensionName)
        {
            var comp = CreateCompilation(src, options: TestOptions.DebugExe);
            comp.VerifyEmitDiagnostics();
            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
            //CompileAndVerify(comp, expectedOutput: "").VerifyDiagnostics();

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            var invocation = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().Method");
            Assert.Equal($$"""void {{extensionName}}.Method()""", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
            Assert.Equal([$$"""void {{extensionName}}.Method()"""], model.GetMemberGroup(invocation).ToTestDisplayStrings());
        }
    }

    [Fact]
    public void InstanceMethodInvocation_UsingNamespaceNecessity()
    {
        var src = """
using N;

class C
{
    public static void Main()
    {
        new object().Method();
    }
}

""";
        var eSrc = """
namespace N
{
    public static class E
    {
        extension(object o)
        {
            public void Method() { System.Console.Write("method"); }
        }
    }
}
""";

        var comp = CreateCompilation([src, eSrc], options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics();

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
        //CompileAndVerify(comp, expectedOutput: "method");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var invocation = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().Method");
        Assert.Equal("void N.E.<>E__0.Method()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Equal(["void N.E.<>E__0.Method()"], model.GetMemberGroup(invocation).ToTestDisplayStrings());

        src = """
using N;

class C
{
    public static void Main() { }
}

namespace N
{
    public static class Extensions
    {
        extension(object o)
        {
            public void Method() { }
        }
    }
}
""";

        comp = CreateCompilation([src, eSrc]);
        comp.VerifyEmitDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1));
    }

    [Theory, CombinatorialData]
    public void InstanceMethodInvocation_Ambiguity(bool e1BeforeE2)
    {
        var e1 = """
static class E1
{
    extension(object o)
    {
        public void Method() => throw null;
    }
}
""";

        var e2 = """
static class E2
{
    extension(object o)
    {
        public void Method() => throw null;
    }
}
""";

        var src = $$"""
new object().Method();

{{(e1BeforeE2 ? e1 : e2)}}
{{(e1BeforeE2 ? e2 : e1)}}
""";
        var comp = CreateCompilation(src);
        if (!e1BeforeE2)
        {
            comp.VerifyEmitDiagnostics(
                // (1,14): error CS0121: The call is ambiguous between the following methods or properties: 'E2.extension(object).Method()' and 'E1.extension(object).Method()'
                // new object().Method();
                Diagnostic(ErrorCode.ERR_AmbigCall, "Method").WithArguments("E2.extension(object).Method()", "E1.extension(object).Method()").WithLocation(1, 14));
        }
        else
        {
            comp.VerifyEmitDiagnostics(
                // (1,14): error CS0121: The call is ambiguous between the following methods or properties: 'E1.extension(object).Method()' and 'E2.extension(object).Method()'
                // new object().Method();
                Diagnostic(ErrorCode.ERR_AmbigCall, "Method").WithArguments("E1.extension(object).Method()", "E2.extension(object).Method()").WithLocation(1, 14));
        }
    }

    [Fact]
    public void InstanceMethodInvocation_Overloads()
    {
        var src = """
new object().Method(42);
new object().Method("hello");

static class E1
{
    extension(object o)
    {
        public void Method(int i) { System.Console.Write($"E1.Method({i}) "); }
    }
}

static class E2
{
    extension(object o)
    {
        public void Method(string s) { System.Console.Write($"E2.Method({s}) "); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
        //CompileAndVerify(comp, expectedOutput: "E1.Method(42) E2.Method(hello)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var invocation1 = GetSyntax<InvocationExpressionSyntax>(tree, "new object().Method(42)");
        Assert.Equal("void E1.<>E__0.Method(System.Int32 i)", model.GetSymbolInfo(invocation1).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation1));

        var invocation2 = GetSyntax<InvocationExpressionSyntax>(tree, """new object().Method("hello")""");
        Assert.Equal("void E2.<>E__0.Method(System.String s)", model.GetSymbolInfo(invocation2).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation2));

        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new object().Method").First();
        Assert.Equal(["void E1.<>E__0.Method(System.Int32 i)", "void E2.<>E__0.Method(System.String s)"], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new object().Method").Last();
        Assert.Equal(["void E1.<>E__0.Method(System.Int32 i)", "void E2.<>E__0.Method(System.String s)"], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_Overloads_DifferentScopes_NestedNamespace()
    {
        var src = """
namespace N1
{
    static class E1
    {
        extension(object o)
        {
            public void Method(int i) { System.Console.Write($"E1.Method({i}) "); }
        }
    }

    namespace N2
    {
        static class E2
        {
            extension(object o)
            {
                public void Method(string s) { System.Console.Write($"E2.Method({s}) "); }
            }
        }

        class C
        {
            public static void Main()
            {
                new object().Method(42);
                new object().Method("hello");
            }
        }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics();
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
        //CompileAndVerify(comp, expectedOutput: "E1.Method(42) E2.Method(hello)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var invocation1 = GetSyntax<InvocationExpressionSyntax>(tree, "new object().Method(42)");
        Assert.Equal("void N1.E1.<>E__0.Method(System.Int32 i)", model.GetSymbolInfo(invocation1).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation1));

        var invocation2 = GetSyntax<InvocationExpressionSyntax>(tree, """new object().Method("hello")""");
        Assert.Equal("void N1.N2.E2.<>E__0.Method(System.String s)", model.GetSymbolInfo(invocation2).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation2));

        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new object().Method").First();
        Assert.Equal(["void N1.N2.E2.<>E__0.Method(System.String s)", "void N1.E1.<>E__0.Method(System.Int32 i)"], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new object().Method").Last();
        Assert.Equal(["void N1.N2.E2.<>E__0.Method(System.String s)", "void N1.E1.<>E__0.Method(System.Int32 i)"], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_NamespaceVsUsing_FromNamespace()
    {
        var src = """
using N2;

new object().Method(42);
new object().Method("hello");
new object().Method(default);

static class E1
{
    extension(object o)
    {
        public void Method(int i) { System.Console.Write("E1.Method "); }
    }
}

namespace N2
{
    static class E2
    {
        extension(object o)
        {
            public void Method(string s) { System.Console.Write("E2.Method "); }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
        //CompileAndVerify(comp, expectedOutput: "E1.Method E2.Method E1.Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var invocation1 = GetSyntax<InvocationExpressionSyntax>(tree, "new object().Method(42)");
        Assert.Equal("void E1.<>E__0.Method(System.Int32 i)", model.GetSymbolInfo(invocation1).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation1));
        Assert.Equal(["void E1.<>E__0.Method(System.Int32 i)", "void N2.E2.<>E__0.Method(System.String s)"], model.GetMemberGroup(invocation1.Expression).ToTestDisplayStrings());

        var invocation2 = GetSyntax<InvocationExpressionSyntax>(tree, """new object().Method("hello")""");
        Assert.Equal("void N2.E2.<>E__0.Method(System.String s)", model.GetSymbolInfo(invocation2).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation2));
        Assert.Equal(["void E1.<>E__0.Method(System.Int32 i)", "void N2.E2.<>E__0.Method(System.String s)"], model.GetMemberGroup(invocation2.Expression).ToTestDisplayStrings());

        var invocation3 = GetSyntax<InvocationExpressionSyntax>(tree, "new object().Method(default)");
        Assert.Equal("void E1.<>E__0.Method(System.Int32 i)", model.GetSymbolInfo(invocation3).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation3));
        Assert.Equal(["void E1.<>E__0.Method(System.Int32 i)", "void N2.E2.<>E__0.Method(System.String s)"], model.GetMemberGroup(invocation3.Expression).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_DerivedDerivedType()
    {
        var src = """
new Derived().M();

class Base { }
class Derived : Base { }

static class E
{
    extension(object o)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new Derived().M()");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation));

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new Derived().M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_ImplementedInterface()
    {
        var src = """
new C().M();

interface I { }
class C : I { }

static class E
{
    extension(I i)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new C().M()");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation));

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_IndirectlyImplementedInterface()
    {
        var src = """
new C().M();

interface I { }
interface Indirect : I { }
class C : Indirect { }

static class E
{
    extension(I i)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new C().M()");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation));

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_TypeParameterImplementedInterface()
    {
        var src = """
class C
{
    void M<T>(T t) where T : I
    {
        t.M();
    }
}

interface I { }

static class E
{
    extension(I i)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "t.M()");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "t.M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void StaticMethodInvocation_MatchingExtendedType_TypeParameterImplementedInterface()
    {
        var src = """
class C
{
    void M<T>() where T : I
    {
        T.M();
    }
}

interface I { }

static class E
{
    extension(I)
    {
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,9): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         T.M();
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(5, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "T.M");
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_TypeParameterWithBaseClass()
    {
        var src = $$"""
class C<T> { }

class D
{
    void M<T>(T t) where T : C<T>
    {
        t.M2();
    }
}

static class E
{
    extension<T>(C<T> c)
    {
        public void M2() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "t.M2()");
        Assert.Equal("void E.<>E__0<T>.M2()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "t.M2");
        Assert.Equal(["void E.<>E__0<T>.M2()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_ConstrainedTypeParameter()
    {
        var src = $$"""
D.M<string>("");

class D
{
    public static void M<T>(T t) where T : class
    {
        t.M2();
    }
}

static class E1
{
    extension<T>(T t) where T : struct
    {
        public void M2() { }
    }
}

static class E2
{
    extension<T>(T t) where T : class
    {
        public void M2() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "t.M2()");
        Assert.Equal("void E2.<>E__0<T>.M2()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "t.M2");
        Assert.Equal(["void E2.<>E__0<T>.M2()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_BaseType()
    {
        var src = """
new object().M();
new object().M2();

static class E
{
    extension(string s)
    {
        public void M() => throw null;
    }
    public static void M2(this string s) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS1929: 'object' does not contain a definition for 'M' and the best extension method overload 'E.extension(string).M()' requires a receiver of type 'string'
            // new object().M();
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "new object()").WithArguments("object", "M", "E.extension(string).M()", "string").WithLocation(1, 1),
            // (2,1): error CS1929: 'object' does not contain a definition for 'M2' and the best extension method overload 'E.M2(string)' requires a receiver of type 'string'
            // new object().M2();
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "new object()").WithArguments("object", "M2", "E.M2(string)", "string").WithLocation(2, 1)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_GenericType()
    {
        var src = """
new C<int>().M();

class C<T> { }

static class E
{
    extension<T>(C<T> c)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new C<int>().M()");
        Assert.Equal("void E.<>E__0<System.Int32>.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        Assert.Equal(["void E.<>E__0<System.Int32>.M()"], model.GetMemberGroup(invocation.Expression).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_GenericType_GenericMember_01()
    {
        var src = """
new C<int>().M<string>();

class C<T> { }

static class E
{
    extension<T>(C<T> c)
    {
        public void M<U>() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS1061: 'C<int>' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'C<int>' could be found (are you missing a using directive or an assembly reference?)
            // new C<int>().M<string>();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M<string>").WithArguments("C<int>", "M").WithLocation(1, 14));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new C<int>().M<string>()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Equal([], model.GetMemberGroup(invocation).ToTestDisplayStrings());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<int>().M<string>");
        Assert.Equal(["void E.<>E__0<System.Int32>.M<U>()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_GenericType_GenericMember_02()
    {
        var src = """
new C<int>().M<int, string>();

class C<T> { }

static class E
{
    extension<T>(C<T> c)
    {
        public void M<U>() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new C<int>().M<int, string>()");
        Assert.Equal("void E.<>E__0<System.Int32>.M<System.String>()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(invocation).ToTestDisplayStrings());

        Assert.Equal(["void E.<>E__0<System.Int32>.M<System.String>()"], model.GetMemberGroup(invocation.Expression).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_GenericType_GenericMember_OmittedTypeArgument_01()
    {
        var src = """
new C<int>().M<,>();

class C<T> { }

static class E
{
    extension<T>(C<T> c)
    {
        public void M<U, V>() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS8389: Omitting the type argument is not allowed in the current context
            // new C<int>().M<,>();
            Diagnostic(ErrorCode.ERR_OmittedTypeArgument, "new C<int>().M<,>").WithLocation(1, 1),
            // (1,14): error CS1061: 'C<int>' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'C<int>' could be found (are you missing a using directive or an assembly reference?)
            // new C<int>().M<,>();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M<,>").WithArguments("C<int>", "M").WithLocation(1, 14));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new C<int>().M<,>()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Equal([], model.GetMemberGroup(invocation).ToTestDisplayStrings());

        Assert.Equal(["void E.<>E__0<System.Int32>.M<U, V>()"], model.GetMemberGroup(invocation.Expression).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_GenericType_GenericMember_OmittedTypeArgument_02()
    {
        var src = """
new C<int>().M<,,>();

class C<T> { }

static class E
{
    extension<T>(C<T> c)
    {
        public void M<U, V>() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS8389: Omitting the type argument is not allowed in the current context
            // new C<int>().M<,,>();
            Diagnostic(ErrorCode.ERR_OmittedTypeArgument, "new C<int>().M<,,>").WithLocation(1, 1),
            // (1,1): error CS1929: 'C<int>' does not contain a definition for 'M' and the best extension method overload 'E.extension<?>(C<?>).M<?, ?>()' requires a receiver of type 'C<?>'
            // new C<int>().M<,,>();
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "new C<int>()").WithArguments("C<int>", "M", "E.extension<?>(C<?>).M<?, ?>()", "C<?>").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new C<int>().M<,,>()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Equal([], model.GetMemberGroup(invocation).ToTestDisplayStrings());

        Assert.Equal([], model.GetMemberGroup(invocation.Expression).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_GenericType_GenericMember_BrokenConstraint()
    {
        var src = """
new C<int>().M<int, string>();

class C<T> { }

static class E
{
    extension<T>(C<T> c)
    {
        public void M<U>() where U : struct => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'U' in the generic type or method 'E.extension<int>(C<int>).M<U>()'
            // new C<int>().M<int, string>();
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M<int, string>").WithArguments("E.extension<int>(C<int>).M<U>()", "U", "string").WithLocation(1, 14));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new C<int>().M<int, string>()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Equal([], model.GetMemberGroup(invocation).ToTestDisplayStrings());
        Assert.Equal([], model.GetMemberGroup(invocation.Expression).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_BrokenConstraint()
    {
        var source = """
new object().Method();
new object().Method2();

static class E
{
    extension<T>(T t) where T : struct
    {
        public void Method() { }
    }
    public static void Method2<T>(this T t) where T : struct { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS0453: The type 'object' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'E.extension<T>(T)'
            // new object().Method();
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "Method").WithArguments("E.extension<T>(T)", "T", "object").WithLocation(1, 14),
            // (2,14): error CS0453: The type 'object' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'E.Method2<T>(T)'
            // new object().Method2();
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "Method2").WithArguments("E.Method2<T>(T)", "T", "object").WithLocation(2, 14)
            );
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_BrokenConstraint_Nullability()
    {
        var source = """
#nullable enable
bool b = true;
var o = b ? null : new object();
o.Method();

static class E
{
    extension<T>(T t) where T : notnull
    {
        public void Method() { System.Console.Write(t is null); }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (4,1): warning CS8602: Dereference of a possibly null reference.
            // o.Method();
            Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(4, 1));
        CompileAndVerify(comp, expectedOutput: "True");

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.Method");
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Nullability is undone
        Assert.Equal("void E.extension<System.Object>(System.Object!).Method()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString(includeNonNullable: true));
    }

    [Fact]
    public void ReceiverParameter_AliasType()
    {
        var source = """
using Alias = C;

new Alias().M();

class C { }

static class E
{
    extension(Alias a)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new Alias().M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethodInvocation_DynamicArgument()
    {
        // No extension members in dynamic invocation
        var src = """
dynamic d = null;
new object().M(d);
new object().M2(d);

static class E
{
    extension(object o)
    {
        public void M(object o1) => throw null;
    }
    public static void M2(this object o, object o2) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,1): error CS1973: 'object' has no applicable method named 'M' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.
            // new object().M(d);
            Diagnostic(ErrorCode.ERR_BadArgTypeDynamicExtension, "new object().M(d)").WithArguments("object", "M").WithLocation(2, 1),
            // (3,1): error CS1973: 'object' has no applicable method named 'M2' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.
            // new object().M2(d);
            Diagnostic(ErrorCode.ERR_BadArgTypeDynamicExtension, "new object().M2(d)").WithArguments("object", "M2").WithLocation(3, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal(["void E.<>E__0.M(System.Object o1)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_DynamicDifference_Nested()
    {
        var src = """
new C<dynamic>().M();

class C<T> { }

static class E
{
    extension(C<object> c)
    {
        public void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "M").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<dynamic>().M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_DynamicDifference_InBase()
    {
        var src = """
new D().M();

class C<T> { }
class D : C<dynamic> { }

static class E
{
    extension(C<object> c)
    {
        public void M()
        {
            System.Console.Write("M");
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "M").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new D().M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_DynamicDifference_InInterface()
    {
        var src = """
new D().M();

interface I<T> { }
class D : I<dynamic> { }

static class E
{
    extension(I<object> i)
    {
        public void M() { System.Console.Write("M"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (4,11): error CS1966: 'D': cannot implement a dynamic interface 'I<dynamic>'
            // class D : I<dynamic> { }
            Diagnostic(ErrorCode.ERR_DeriveFromConstructedDynamic, "I<dynamic>").WithArguments("D", "I<dynamic>").WithLocation(4, 11));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new D().M");
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_TupleNamesDifference()
    {
        var src = """
new C<(int a, int b)>().M();
new C<(int, int)>().M();
new C<(int other, int)>().M();

class C<T> { }

static class E
{
    extension(C<(int a, int b)> c)
    {
        public void M() { System.Console.Write("M"); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<(int a, int b)>().M");
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<(int, int)>().M");
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<(int other, int)>().M");
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        src = """
new C<(int a, int b)>().M();
new C<(int, int)>().M();
new C<(int other, int)>().M();

class C<T> { }

static class E
{
    public static void M(this C<(int a, int b)> c) { System.Console.Write("M"); }
}
""";
        comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_TupleNamesDifference_InBase()
    {
        var src = """
new D1().M();
new D2().M();
new D3().M();

class C<T> { }
class D1 : C<(int a, int b)> { }
class D2 : C<(int, int)> { }
class D3 : C<(int other, int)> { }

static class E
{
    extension(C<(int a, int b)> c)
    {
        public void M() { System.Console.Write("M"); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethodInvocation_MatchingExtendedType_TupleNamesDifference_InInterface()
    {
        var src = """
new D1().M();
new D2().M();
new D3().M();

class I<T> { }
class D1 : I<(int a, int b)> { }
class D2 : I<(int, int)> { }
class D3 : I<(int other, int)> { }

static class E
{
    extension(I<(int a, int b)> i)
    {
        public void M() { System.Console.Write("M"); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "MMM").VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethodInvocation_Nameof()
    {
        var src = """
object o = null;
System.Console.Write($"{nameof(o.M)} ");

static class E
{
    extension(object)
    {
        public void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,32): error CS8093: Extension method groups are not allowed as an argument to 'nameof'.
            // System.Console.Write($"{nameof(o.M)} ");
            Diagnostic(ErrorCode.ERR_NameofExtensionMethod, "o.M").WithLocation(2, 32));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.M");
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_Nameof_ViaType()
    {
        var src = """
System.Console.Write($"{nameof(E.M)} ");

static class E
{
    extension(object)
    {
        public void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "M").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "E.M");
        Assert.Equal(["void E.M(this System.Object)", "void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_Nameof_Overloads()
    {
        var src = """
object o = null;
System.Console.Write($"{nameof(o.M)} ");

static class E
{
    extension(object o)
    {
        public void M() { }
        public void M(int i) { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,32): error CS8093: Extension method groups are not allowed as an argument to 'nameof'.
            // System.Console.Write($"{nameof(o.M)} ");
            Diagnostic(ErrorCode.ERR_NameofExtensionMethod, "o.M").WithLocation(2, 32));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.M");
        Assert.Equal(["void E.<>E__0.M()", "void E.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_Nameof_SimpleName()
    {
        var src = """
class C
{
    void M()
    {
        _ = nameof(Method);
    }
}

static class E
{
    extension(object o)
    {
        public void Method() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,20): error CS0103: The name 'Method' does not exist in the current context
            //         _ = nameof(Method);
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Method").WithArguments("Method").WithLocation(5, 20));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var identifier = GetSyntax<IdentifierNameSyntax>(tree, "Method");
        Assert.Equal([], model.GetMemberGroup(identifier).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_Null_Method()
    {
        var src = """
#nullable enable

object? o = null;
o.Method();

static class E
{
    extension(object o)
    {
        public void Method() { System.Console.Write("Method"); }
    }
}
""";
        var comp = CreateCompilation(src);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : nullability is undone
        comp.VerifyEmitDiagnostics(
            // (4,1): warning CS8602: Dereference of a possibly null reference.
            // o.Method();
            Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(4, 1));

        CompileAndVerify(comp, expectedOutput: "Method");
    }

    [Fact]
    public void InstanceMethodInvocation_ColorColor_Method()
    {
        var src = """
C.M(new C());

class C
{
    public static void M(C C)
    {
        C.Method();
    }
}

static class E
{
    extension(C c)
    {
        public void Method() { System.Console.Write("Method "); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Equal("void E.<>E__0.Method()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.Method()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_ColorColor_Static_Method()
    {
        var src = """
C.M(null);

class C
{
    public static void M(C C)
    {
        C.Method();
    }
}

static class E
{
    extension(C c)
    {
        public void Method() { System.Console.Write("Method"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Equal("void E.<>E__0.Method()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.Method()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_PatternBased_ForEach_NoMethod()
    {
        var src = """
foreach (var x in new C())
{
    System.Console.Write(x);
    break;
}

class C { }
class D { }

static class E
{
    extension(C c)
    {
        public D GetEnumerator() => new D();
    }

    extension(D d)
    {
        public bool MoveNext() => true;
        public int Current => 42;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,19): error CS0117: 'D' does not contain a definition for 'Current'
            // foreach (var x in new C())
            Diagnostic(ErrorCode.ERR_NoSuchMember, "new C()").WithArguments("D", "Current").WithLocation(1, 19),
            // (1,19): error CS0202: foreach requires that the return type 'D' of 'E.extension(C).GetEnumerator()' must have a suitable public 'MoveNext' method and public 'Current' property
            // foreach (var x in new C())
            Diagnostic(ErrorCode.ERR_BadGetEnumerator, "new C()").WithArguments("D", "E.extension(C).GetEnumerator()").WithLocation(1, 19)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var loop = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().Single();
        Assert.Null(model.GetForEachStatementInfo(loop).GetEnumeratorMethod);
        Assert.Null(model.GetForEachStatementInfo(loop).MoveNextMethod);
        Assert.Null(model.GetForEachStatementInfo(loop).CurrentProperty);
    }

    [Fact]
    public void InstanceMethodInvocation_NameOf_SingleParameter()
    {
        var src = """
class C
{
    public static void Main()
    {
        string x = "";
        System.Console.Write(nameof(x));
    }
}


static class E
{
    extension(C c)
    {
        public string nameof(string s) => throw null;
    }
}
""";

        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "x").VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethodInvocation_Simple_ExpressionTree()
    {
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : decide whether to allow expression tree scenarios. Verify shape of the tree if we decide to allow
        var source = """
using System.Linq.Expressions;
Expression<System.Action> x = () => new C().M(42);

class C
{
    public void M() => throw null;
}

static class E
{
    extension(C c)
    {
        public void M(int i) { System.Console.Write("E.M"); }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
        //CompileAndVerify(comp, expectedOutput: "").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M()", "void E.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_NextScope()
    {
        // If overload resolution on extension type methods yields no applicable candidates,
        // we look in the next scope.
        var source = """
using N;

new C().M(42);

class C
{
    public void M() => throw null;
}

static class E1
{
    extension(C c)
    {
        public void M(string s) => throw null;
    }
}

namespace N
{
    static class E2
    {
        extension(C c)
        {
            public void M(int i) { System.Console.Write($"E2.M({i})"); }
        }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "E2.M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void N.E2.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M()", "void E1.<>E__0.M(System.String s)", "void N.E2.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_NewExtensionPriority()
    {
        var source = """
new C().M(42);

class C
{
    public void M() => throw null;
}

static class E1
{
    extension(C c)
    {
        public void M(int i) => throw null;
    }
}

static class E2
{
    public static void M(this C c, int i) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0121: The call is ambiguous between the following methods or properties: 'E1.extension(C).M(int)' and 'E2.M(C, int)'
            // new C().M(42);
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E1.extension(C).M(int)", "E2.M(C, int)").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void C.M()", "void E1.<>E__0.M(System.Int32 i)", "void C.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_NewExtensionPriority_02()
    {
        var source = """
new C().M(42);

class C
{
    public void M() => throw null;
}

static class E
{
    extension(C c)
    {
        public void M(int i) => throw null;
    }
    public static void M(this C c, int i) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0121: The call is ambiguous between the following methods or properties: 'E.extension(C).M(int)' and 'E.M(C, int)'
            // new C().M(42);
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E.extension(C).M(int)", "E.M(C, int)").WithLocation(1, 9),
            // (12,21): error CS0111: Type 'E' already defines a member called 'M' with the same parameter types
            //         public void M(int i) => throw null;
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M").WithArguments("M", "E").WithLocation(12, 21)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void C.M()", "void E.<>E__0.M(System.Int32 i)", "void C.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_FallbackToExtensionMethod()
    {
        // The extension method is picked up if extension declaration candidates were not applicable
        var source = """
new C().M(42);

class C
{
    public static void M() => throw null;
}

static class E1
{
    extension(C c)
    {
        public void M(string s) => throw null;
        public void M(char c1) => throw null;
    }
}

static class E2
{
    public static void M(this C c, int i) { System.Console.Write($"E2.M({i})"); }
}
""";
        var comp = CreateCompilation(source);

        CompileAndVerify(comp, expectedOutput: "E2.M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void C.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M()", "void E1.<>E__0.M(System.String s)", "void E1.<>E__0.M(System.Char c1)", "void C.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_SimpleName()
    {
        // Extension invocation comes into play on an invocation on a member access but not an invocation on a simple name
        var source = """
class C
{
    public void M() => throw null;

    void M2()
    {
        M(42); // 1
    }
}

static class E
{
    extension(C c)
    {
        public void M(int i) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // 0.cs(7,9): error CS1501: No overload for method 'M' takes 1 arguments
            //         M(42); // 1
            Diagnostic(ErrorCode.ERR_BadArgCount, "M").WithArguments("M", "1").WithLocation(7, 9)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "M(42)");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Empty(model.GetMemberGroup(invocation));
        Assert.Equal(["void C.M()"], model.GetMemberGroup(invocation.Expression).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_ArgumentName()
    {
        // Instance method with incompatible parameter name is skipped in favor of extension declaration method
        var source = """
new C().M(b: 42);

class C
{
    public void M(int a) => throw null;
}

static class E1
{
    extension(C c)
    {
        public void M(int b) { System.Console.Write($"E1.M({b})"); }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "E1.M(42)");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E1.<>E__0.M(System.Int32 b)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M(System.Int32 a)", "void E1.<>E__0.M(System.Int32 b)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_ArgumentName_02()
    {
        // Extension declaration method with incompatible parameter name is skipped in favor of extension method
        var source = """
new C().M(c: 42);

public class C
{
    public static void M(int a) => throw null;
}

static class E1
{
    extension(C c)
    {
        public void M(int b) => throw null;
    }
}

public static class E2
{
    public static void M(this C self, int c)
    {
        System.Console.Write($"E2.M({c})");
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "E2.M(42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void C.M(System.Int32 c)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        Assert.Equal(["void C.M(System.Int32 a)", "void E1.<>E__0.M(System.Int32 b)", "void C.M(System.Int32 c)"],
            model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_ArgumentName_03()
    {
        var source = """
new object().M(c: 43, b: 42);

static class E
{
    extension(object o)
    {
        public void M(int b, int c) { System.Console.Write($"E.M({b}, {c})"); }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "E.M(42, 43)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("void E.<>E__0.M(System.Int32 b, System.Int32 c)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethodInvocation_ArgumentName_04()
    {
        var source = """
new object().M(o: new object());

static class E
{
    extension(object o)
    {
        public void M(object o2) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,16): error CS1744: Named argument 'o' specifies a parameter for which a positional argument has already been given
            // new object().M(o: new object());
            Diagnostic(ErrorCode.ERR_NamedArgumentUsedInPositional, "o").WithArguments("o").WithLocation(1, 16));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void InstanceMethodInvocation_RefKind()
    {
        var source = """
int i = 42;
int j;

new object().M(ref i, out j);

static class E
{
    extension(object o)
    {
        public void M(ref int b, out int c) { c = 43; System.Console.Write($"E.M({b}, {c})"); }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "E.M(42, 43)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("void E.<>E__0.M(ref System.Int32 b, out System.Int32 c)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethodInvocation_AmbiguityWithExtensionOnBaseType_PreferMoreSpecific()
    {
        var source = """
System.Console.Write(new C().M(42));

class Base { }

class C : Base { }

static class E1
{
    extension(Base b)
    {
        public int M(int i) => throw null;
    }
}

static class E2
{
    extension(C c)
    {
        public int M(int i) => i;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("System.Int32 E2.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["System.Int32 E1.<>E__0.M(System.Int32 i)", "System.Int32 E2.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        source = """
System.Console.Write(new C().M(42));

public class Base { }

public class C : Base { }

public static class E1
{
    public static int M(this Base b, int i) => throw null;
}

public static class E2
{
    public static int M(this C c, int i) => i;
}
""";
        comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();
    }

    [Fact]
    public void InstanceMethodInvocation_TypeArguments()
    {
        var source = """
new C().M<object>(42);

class C { }

static class E
{
    extension(C c)
    {
        public void M(int i) => throw null;
        public void M<T>(int i)
        {
            System.Console.Write("ran");
        }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M<object>");
        Assert.Equal("void E.<>E__0.M<System.Object>(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M<System.Object>(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_TypeArguments_WrongNumber()
    {
        var source = """
new C().M<object, object>(42);

class C { }

static class E
{
    extension(C c)
    {
        public void M(int i) => throw null;
        public void M<T>(int i) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // 0.cs(1,9): error CS1061: 'C' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            // new C().M<object, object>(42);
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M<object, object>").WithArguments("C", "M").WithLocation(1, 9)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M<object, object>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void E.<>E__0.M(System.Int32 i)", "void E.<>E__0.M<T>(System.Int32 i)"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void E.<>E__0.M(System.Int32 i)", "void E.<>E__0.M<T>(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_TypeArguments_Omitted()
    {
        var source = """
new C().M<>(42);

class C { }

static class E
{
    extension(C c)
    {
        public void M<T>(int i) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS8389: Omitting the type argument is not allowed in the current context
            // new C().M<>(42);
            Diagnostic(ErrorCode.ERR_OmittedTypeArgument, "new C().M<>").WithLocation(1, 1)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M<>");
        Assert.Equal("void E.<>E__0.M<?>(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M<?>(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_TypeArguments_Inferred()
    {
        // No type arguments passed, but the extension declaration method is found and the type parameter inferred
        var source = """
new C().M(42);

class C { }

static class E
{
    extension(C c)
    {
        public void M<T>(T t)
        {
            System.Console.Write($"M({t})");
        }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "M(42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E.<>E__0.M<System.Int32>(System.Int32 t)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M<T>(T t)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void StaticMethodInvocation_InstanceExtensionMethod()
    {
        // The extension method is not static, but the receiver is a type
        var source = """
C.M();

class C { }

static class E
{
    extension(C c)
    {
        public void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0120: An object reference is required for the non-static field, method, or property 'E.extension(C).M()'
            // C.M();
            Diagnostic(ErrorCode.ERR_ObjectRequired, "C.M").WithArguments("E.extension(C).M()").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        source = """
C.Method();

public class C { }

public static class E
{
    public static void Method(this C c) { }
}
""";
        comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // 0.cs(1,1): error CS0120: An object reference is required for the non-static field, method, or property 'E.Method(C)'
            // C.Method();
            Diagnostic(ErrorCode.ERR_ObjectRequired, "C.Method").WithArguments("E.Method(C)").WithLocation(1, 1));
    }

    [Fact]
    public void InstanceMethodInvocation_StaticExtensionMethod()
    {
        // The extension method is static but the receiver is a value
        var source = """
new C().M();

class C { }

static class E
{
    extension(C c)
    {
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0176: Member 'E.extension(C).M()' cannot be accessed with an instance reference; qualify it with a type name instead
            // new C().M();
            Diagnostic(ErrorCode.ERR_ObjectProhibited, "new C().M").WithArguments("E.extension(C).M()").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_GenericType()
    {
        var src = """
new C<int>().StaticType<string>();

class C<T> { }

static class E
{
    extension<T>(C<T> c)
    {
        public static class StaticType<U> { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS1061: 'C<int>' does not contain a definition for 'StaticType' and no accessible extension method 'StaticType' accepting a first argument of type 'C<int>' could be found (are you missing a using directive or an assembly reference?)
            // new C<int>().StaticType<string>();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "StaticType<string>").WithArguments("C<int>", "StaticType").WithLocation(1, 14),
            // (9,29): error CS9282: Extension declarations can include only methods or properties
            //         public static class StaticType<U> { }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "StaticType").WithLocation(9, 29));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<int>().StaticType<string>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_RefOmittedComCall()
    {
        // For COM import type, omitting the ref is allowed
        string source = @"
using System;
using System.Runtime.InteropServices;

[ComImport, Guid(""1234C65D-1234-447A-B786-64682CBEF136"")]
class C { }

static class E
{
    extension(C c)
    {
        public void M(ref short p) { }
        public void M(sbyte p) { }
        public void I(ref int p) { }
    }
}

class X
{
    public static void Goo()
    {
        short x = 123;
        C c = new C();
        c.M(x);
        c.I(123);
    }
}
";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void ParameterCapturing_023_ColorColor_MemberAccess_InstanceAndStatic_ExtensionDeclarationMethods()
    {
        // See ParameterCapturing_023_ColorColor_MemberAccess_InstanceAndStatic_Method
        var source = """
struct S1(Color Color)
{
    public void Test()
    {
        Color.M1(this);
    }
}

class Color { }

static class E
{
    extension(Color c)
    {
        public void M1(S1 x, int y = 0) { System.Console.WriteLine("instance"); }

        public static void M1<T>(T x) where T : unmanaged { System.Console.WriteLine("static"); }
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : missing ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver
        var comp = CreateCompilation(source, options: TestOptions.ReleaseDll);
        comp.VerifyEmitDiagnostics(
            //// (5,9): error CS9106: Identifier 'Color' is ambiguous between type 'Color' and parameter 'Color Color' in this context.
            ////         Color.M1(this);
            //Diagnostic(ErrorCode.ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver, "Color").WithArguments("Color", "Color", "Color Color").WithLocation(5, 9)
            );

        Assert.NotEmpty(comp.GetTypeByMetadataName("S1").InstanceConstructors.OfType<SynthesizedPrimaryConstructor>().Single().GetCapturedParameters());

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.M1");
        Assert.Equal("void E.<>E__0.M1(S1 x, [System.Int32 y = 0])", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ParameterCapturing_023_ColorColor_MemberAccess_InstanceAndStatic_ExtensionDeclarationMembersVsExtensionMethod()
    {
        var source = """
public struct S1(Color Color)
{
    public void Test()
    {
        Color.M1(this);
    }
}

public class Color { }

public static class E1
{
    public static void M1(this Color c, S1 x, int y = 0) { System.Console.WriteLine("instance"); }
}

static class E2
{
    extension(Color c)
    {
        public static void M1<T>(T x) where T : unmanaged { System.Console.WriteLine("static"); }
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : missing ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver
        var comp = CreateCompilation(source, options: TestOptions.ReleaseDll);
        comp.VerifyEmitDiagnostics(
            //// (5,9): error CS9106: Identifier 'Color' is ambiguous between type 'Color' and parameter 'Color Color' in this context.
            ////         Color.M1(this);
            //Diagnostic(ErrorCode.ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver, "Color").WithArguments("Color", "Color", "Color Color").WithLocation(5, 9)
            );

        Assert.NotEmpty(comp.GetTypeByMetadataName("S1").InstanceConstructors.OfType<SynthesizedPrimaryConstructor>().Single().GetCapturedParameters());

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.M1");
        Assert.Equal("void Color.M1(S1 x, [System.Int32 y = 0])", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethodInvocation_NotOnBase()
    {
        // Unlike `this`, `base` is not an expression in itself.
        // "Extension invocation" and "extension member lookup" do not apply to `base_access` syntax.
        var src = """
class Base { }

class Derived : Base
{
    void Main()
    {
        M(); // 1
        base.M(); // 2
    }
}

static class E
{
    extension(Base b)
    {
        public void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (7,9): error CS0103: The name 'M' does not exist in the current context
            //         M(); // 1
            Diagnostic(ErrorCode.ERR_NameNotInContext, "M").WithArguments("M").WithLocation(7, 9),
            // (8,14): error CS0117: 'Base' does not contain a definition for 'M'
            //         base.M(); // 2
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("Base", "M").WithLocation(8, 14));
    }

    [Fact]
    public void LookupKind_Invocation()
    {
        // Non-invocable extension member in inner scope is skipped in favor of invocable one from outer scope
        var src = """
using N;

new object().Member();

static class E
{
    extension(object o)
    {
        public int Member => 0;
    }
}

namespace N
{
    static class E2
    {
        extension(object o)
        {
            public void Member() { System.Console.Write("ran "); }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().Member");
        Assert.Equal("void N.E2.<>E__0.Member()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethodInvocation_Generic_NotUnique()
    {
        var src = """
new C<object, dynamic>().M();
new C<dynamic, object>().M();

new C<object, dynamic>().M2();
new C<dynamic, object>().M2();

class C<T, U> { }

static class E
{
    extension<T>(C<T, T> c)
    {
        public string M() => "hi";
    }
    public static string M2<T>(this C<T, T> c) => "hi";
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,26): error CS1061: 'C<object, dynamic>' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'C<object, dynamic>' could be found (are you missing a using directive or an assembly reference?)
            // new C<object, dynamic>().M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("C<object, dynamic>", "M").WithLocation(1, 26),
            // (2,26): error CS1061: 'C<dynamic, object>' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'C<dynamic, object>' could be found (are you missing a using directive or an assembly reference?)
            // new C<dynamic, object>().M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("C<dynamic, object>", "M").WithLocation(2, 26),
            // (4,26): error CS1061: 'C<object, dynamic>' does not contain a definition for 'M2' and no accessible extension method 'M2' accepting a first argument of type 'C<object, dynamic>' could be found (are you missing a using directive or an assembly reference?)
            // new C<object, dynamic>().M2();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M2").WithArguments("C<object, dynamic>", "M2").WithLocation(4, 26),
            // (5,26): error CS1061: 'C<dynamic, object>' does not contain a definition for 'M2' and no accessible extension method 'M2' accepting a first argument of type 'C<dynamic, object>' could be found (are you missing a using directive or an assembly reference?)
            // new C<dynamic, object>().M2();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M2").WithArguments("C<dynamic, object>", "M2").WithLocation(5, 26));
    }

    [Fact]
    public void InstanceMethodInvocation_Generic_NestedTuples()
    {
        var src = """
var s = new C<(string, string)>.Nested<(int, int)>().M();
System.Console.Write(s);

class C<T>
{
    internal class Nested<U> { }
}

static class E
{
    extension<T1, T2>(C<(T1, T1)>.Nested<(T2, T2)> cn)
    {
        public string M() => "hi";
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<(string, string)>.Nested<(int, int)>().M");
        Assert.Equal("System.String E.<>E__0<System.String, System.Int32>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethodInvocation_Generic_PointerArray()
    {
        var src = """
unsafe
{
    string s = new C<long*[]>.Nested<int*[]>().M();
    System.Console.Write(s);
}

unsafe class C<T>
{
    internal class Nested<U> { }
}

unsafe static class E
{
    extension<T1, T2>(C<T1*[]>.Nested<T2*[]> cn)
        where T1 : unmanaged
        where T2 : unmanaged
    {
        public string M() => "hi";
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugExe);
        CompileAndVerify(comp, expectedOutput: "hi").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<long*[]>.Nested<int*[]>().M");
        Assert.Equal("System.String E.<>E__0<System.Int64, System.Int32>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethodInvocation_Generic_Pointer()
    {
        var src = """
unsafe
{
    new C<long*[]>.Nested<int*[]>().M();
    new C<long*[]>.Nested<int*[]>().M2();
}

unsafe class C<T>
{
    internal class Nested<U> { }
}

static class E
{
    extension<T1, T2>(C<T1[]>.Nested<T2[]> cn)
    {
        public string M() => null;
    }
    public static string M2<T1, T2>(this C<T1[]>.Nested<T2[]> cn) => null;
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugExe);
        comp.VerifyEmitDiagnostics(
            // (3,37): error CS0306: The type 'long*' may not be used as a type argument
            //     new C<long*[]>.Nested<int*[]>().M();
            Diagnostic(ErrorCode.ERR_BadTypeArgument, "M").WithArguments("long*").WithLocation(3, 37),
            // (3,37): error CS0306: The type 'int*' may not be used as a type argument
            //     new C<long*[]>.Nested<int*[]>().M();
            Diagnostic(ErrorCode.ERR_BadTypeArgument, "M").WithArguments("int*").WithLocation(3, 37),
            // (4,37): error CS0306: The type 'long*' may not be used as a type argument
            //     new C<long*[]>.Nested<int*[]>().M2();
            Diagnostic(ErrorCode.ERR_BadTypeArgument, "M2").WithArguments("long*").WithLocation(4, 37),
            // (4,37): error CS0306: The type 'int*' may not be used as a type argument
            //     new C<long*[]>.Nested<int*[]>().M2();
            Diagnostic(ErrorCode.ERR_BadTypeArgument, "M2").WithArguments("int*").WithLocation(4, 37)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<long*[]>.Nested<int*[]>().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void InstanceMethodInvocation_Generic_FunctionPointer()
    {
        var src = """
unsafe
{
    string s = new C<delegate*<int>[]>.Nested<delegate*<long>[]>().M();
    System.Console.Write(s);
}

unsafe class C<T>
{
    internal class Nested<U> { }
}

unsafe static class E
{
    extension<T1, T2>(C<delegate*<T1>[]>.Nested<delegate*<T2>[]> cn)
    {
        public string M() => "hi";
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugExe);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<delegate*<int>[]>.Nested<delegate*<long>[]>().M");
        Assert.Equal("System.String E.<>E__0<System.Int32, System.Int64>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethodInvocation_Generic_ForInterface()
    {
        var src = """
string s = new C<int>().M();
System.Console.Write(s);

class C<T> : I<T> { }
interface I<T> { }

static class E
{
    extension<T>(I<T> i)
    {
        public string M() => "hi";
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<int>().M");
        Assert.Equal("System.String E.<>E__0<System.Int32>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethodInvocation_Generic_ForBaseInterface()
    {
        var src = """
string s = new C<int>().M();
System.Console.Write(s);

class C<T> : I<T> { }
interface I<T> : I2<T> { }
interface I2<T> { }

static class E
{
    extension<T>(I2<T> i)
    {
        public string M() => "hi";
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<int>().M");
        Assert.Equal("System.String E.<>E__0<System.Int32>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethodInvocation_Generic_ForBase()
    {
        var src = """
string s = new C<int, string>().M();
System.Console.Write(s);

class Base<T, U> { }
class C<T, U> : Base<U, T> { }

static class E
{
    extension<T, U>(Base<T, U> b)
    {
        public string M() => "hi";
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C<int, string>().M");
        Assert.Equal("System.String E.<>E__0<System.String, System.Int32>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethodInvocation_Obsolete()
    {
        var src = """
new object().Method();

static class E
{
    extension(object o)
    {
        [System.Obsolete("Method is obsolete", true)]
        public void Method() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0619: 'E.extension(object).Method()' is obsolete: 'Method is obsolete'
            // new object().Method();
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Method()").WithArguments("E.extension(object).Method()", "Method is obsolete").WithLocation(1, 1));
    }

    [Fact]
    public void InstanceMethodInvocation_BrokenConstraintMethodOuterExtension()
    {
        var src = """
static class E2
{
    extension(object o)
    {
        public void M<T>() => throw null;
    }
}

namespace Inner
{
    class C
    {
        public static void Main()
        {
            new C().M<object>();
        }
    }

    static class E1
    {
        extension(C c)
        {
            public string M<T>() where T : struct => throw null;
        }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M<object>");
        Assert.Equal("void E2.<>E__0.M<System.Object>()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E2.<>E__0.M<System.Object>()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethodInvocation_MultipleSubstitutions()
    {
        var src = """
new C().M();

interface I<T> { }
class C : I<int>, I<string> { }

static class E
{
    extension<T>(I<T> i)
    {
        public void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS1061: 'C' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            // new C().M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("C", "M").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Theory, CombinatorialData]
    public void InstanceMethodInvocation_MultipleExtensions(bool e1BeforeE2)
    {
        var e1 = """
static class E1
{
    extension(object o)
    {
        public string M() => throw null;
    }
}
""";

        var e2 = """
static class E2
{
    extension(object o)
    {
        public string M() => throw null;
    }
}
""";

        var src = $$"""
new object().M();
{{(e1BeforeE2 ? e1 : e2)}}
{{(e1BeforeE2 ? e2 : e1)}}
""";
        var comp = CreateCompilation(src);
        if (!e1BeforeE2)
        {
            comp.VerifyEmitDiagnostics(
                // (1,14): error CS0121: The call is ambiguous between the following methods or properties: 'E2.extension(object).M()' and 'E1.extension(object).M()'
                // new object().M();
                Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E2.extension(object).M()", "E1.extension(object).M()").WithLocation(1, 14));
        }
        else
        {
            comp.VerifyEmitDiagnostics(
                // (1,14): error CS0121: The call is ambiguous between the following methods or properties: 'E1.extension(object).M()' and 'E2.extension(object).M()'
                // new object().M();
                Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E1.extension(object).M()", "E2.extension(object).M()").WithLocation(1, 14));
        }

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        if (e1BeforeE2)
        {
            Assert.Equal(["System.String E1.<>E__0.M()", "System.String E2.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
        }
        else
        {
            Assert.Equal(["System.String E2.<>E__0.M()", "System.String E1.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
        }
    }

    public class ThreePermutationGenerator : IEnumerable<object[]>
    {
        private readonly List<object[]> _data = [
            [0, 1, 2],
            [0, 2, 1],
            [1, 0, 2],
            [1, 2, 0],
            [2, 0, 1],
            [2, 1, 0]];

        public IEnumerator<object[]> GetEnumerator() => _data.GetEnumerator();

        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void InstanceMethodInvocation_InterfaceAppearsTwice(int first, int second, int third)
    {
        string[] segments = [
            """
            static class E1
            {
                extension<T>(I1<T> i)
                {
                    public string M() => null;
                }
            }
            """,
            """
            static class E2
            {
                extension(I2 i) { }
            }
            """,
            """
            static class E3
            {
                extension(C c) { }
            }
            """];

        var src = $$"""
System.Console.Write(new C().M());

interface I1<T> { }
interface I2 : I1<string> { }

class C : I1<int>, I2 { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,30): error CS1061: 'C' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            // System.Console.Write(new C().M());
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("C", "M").WithLocation(1, 30));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void InstanceMethodInvocation_SingleStageInference()
    {
        var src = """
public class C
{
    public void M(I<string> i, out object o)
    {
        i.M(out o);
        i.M2(out o);
    }
}

public static class E
{
   public static void M<T>(this I<T> i, out T t) { t = default; }
}

static class E2
{
    extension<T>(I<T> i)
    {
       public void M2(out T t) { t = default; }
    }
}

public interface I<out T> { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "i.M");
        Assert.Equal("void I<System.Object>.M<System.Object>(out System.Object t)", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void I<System.String>.M<System.String>(out System.String t)"], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "i.M2");
        Assert.Equal("void E2.<>E__0<System.Object>.M2(out System.Object t)", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void E2.<>E__0<System.String>.M2(out System.String t)"], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void GetCompatibleExtension_Conversion_01()
    {
        var src = """
using System.Collections.Generic;

IEnumerable<string> i = null;
i.M();
_ = i.P;

static class E
{
    extension(IEnumerable<object> o)
    {
        public void M() { System.Console.Write(o is null); }
        public int P { get { System.Console.Write(o is null); return 0; } }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "TrueTrue").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "i.M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "i.P");
        Assert.Equal("System.Int32 E.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        src = """
using System.Collections.Generic;

IEnumerable<object> i = null;
i.M();
_ = i.P;

static class E
{
    extension(IEnumerable<string> o)
    {
        public static void M() { }
        public static int P => throw null;
    }
}
""";
        comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics(
            // (4,1): error CS1929: 'IEnumerable<object>' does not contain a definition for 'M' and the best extension method overload 'E.extension(IEnumerable<string>).M()' requires a receiver of type 'System.Collections.Generic.IEnumerable<string>'
            // i.M();
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "i").WithArguments("System.Collections.Generic.IEnumerable<object>", "M", "E.extension(System.Collections.Generic.IEnumerable<string>).M()", "System.Collections.Generic.IEnumerable<string>").WithLocation(4, 1),
            // (5,5): error CS9286: 'IEnumerable<object>' does not contain a definition for 'P' and no accessible extension member 'P' for receiver of type 'IEnumerable<object>' could be found (are you missing a using directive or an assembly reference?)
            // _ = i.P;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "i.P").WithArguments("System.Collections.Generic.IEnumerable<object>", "P").WithLocation(5, 5)
            );
    }

    [Fact]
    public void GetCompatibleExtension_Conversion_02()
    {
        var src = """
string.M();
_ = string.P;

static class E
{
    extension(object)
    {
        public static void M() { System.Console.Write("ran "); }
        public static int P { get { System.Console.Write("ran2"); return 0; } }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran ran2").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "string.M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void GetCompatibleExtension_Conversion_03()
    {
        var src = """
int.M();
_ = int.P;

static class E
{
    extension(object)
    {
        public static void M() { System.Console.Write("ran "); }
        public static int P { get { System.Console.Write("ran2"); return 0; } }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran ran2").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void GetCompatibleExtension_Conversion_04()
    {
        var src = """
int.M();
42.M2();

_ = int.P;
_ = 42.P2;

static class E
{
    extension(int? i)
    {
        public static void M() { }
        public static int P => 0;
        public int P2 => 0;
    }
    public static void M2(this int? i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS1929: 'int' does not contain a definition for 'M' and the best extension method overload 'E.extension(int?).M()' requires a receiver of type 'int?'
            // int.M();
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "int").WithArguments("int", "M", "E.extension(int?).M()", "int?").WithLocation(1, 1),
            // (2,1): error CS1929: 'int' does not contain a definition for 'M2' and the best extension method overload 'E.M2(int?)' requires a receiver of type 'int?'
            // 42.M2();
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "42").WithArguments("int", "M2", "E.M2(int?)", "int?").WithLocation(2, 1),
            // (4,5): error CS9286: 'int' does not contain a definition for 'P' and no accessible extension member 'P' for receiver of type 'int' could be found (are you missing a using directive or an assembly reference?)
            // _ = int.P;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "int.P").WithArguments("int", "P").WithLocation(4, 5),
            // (5,5): error CS9286: 'int' does not contain a definition for 'P2' and no accessible extension member 'P2' for receiver of type 'int' could be found (are you missing a using directive or an assembly reference?)
            // _ = 42.P2;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "42.P2").WithArguments("int", "P2").WithLocation(5, 5));
    }

    [Fact]
    public void GetCompatibleExtension_Conversion_05()
    {
        var src = """
MyEnum.Zero.M();

enum MyEnum { Zero }

static class E
{
    extension(System.Enum e)
    {
        public void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void GetCompatibleExtension_Conversion_06()
    {
        var src = """
dynamic d = new C();
d.M();
d.M2();

static class E
{
    extension(object o)
    {
        public void M() => throw null;
    }

    public static void M2(this object o) => throw null;
}

class C
{
    public void M() { System.Console.Write("ran "); }
    public void M2() { System.Console.Write("ran2"); }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        CompileAndVerify(comp, expectedOutput: ExpectedOutput("ran ran2"), verify: Verification.FailsPEVerify).VerifyDiagnostics();
    }

    [Fact]
    public void GetCompatibleExtension_Conversion_07()
    {
        var src = """
object o = null;
o.M();
o.M2();

static class E
{
    extension(dynamic d)
    {
        public void M() { }
    }

    public static void M2(this dynamic d) { }
}
""";
        var comp = CreateCompilation(src);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : validate extension parameter
        comp.VerifyEmitDiagnostics(
            // (12,32): error CS1103: The first parameter of an extension method cannot be of type 'dynamic'
            //     public static void M2(this dynamic d) { }
            Diagnostic(ErrorCode.ERR_BadTypeforThis, "dynamic").WithArguments("dynamic").WithLocation(12, 32));
    }

    [Fact]
    public void GetCompatibleExtension_Conversion_08()
    {
        var src = """
(int a, int b) t = default;
t.M();
t.M2();

static class E
{
    extension((int c, int d) t)
    {
        public void M() { }
    }

    public static void M2(this (int c, int d) t) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void GetCompatibleExtension_Conversion_09()
    {
        var src = """
int[] i = default;
i.M();
i.M2();

static class E
{
    extension(System.ReadOnlySpan<int> ros)
    {
        public void M() { }
    }

    public static void M2(this System.ReadOnlySpan<int> ros) { }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net90);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void GetCompatibleExtension_Conversion_10()
    {
        var missingSrc = """
public class Missing { }
""";
        var missingRef = CreateCompilation(missingSrc, assemblyName: "missing").EmitToImageReference();

        var derivedSrc = """
public class Derived : Missing { }
""";
        var derivedRef = CreateCompilation(derivedSrc, references: [missingRef]).EmitToImageReference();

        var src = """
new Derived().M();
new Derived().M2();

class Other { }

static class E
{
    extension(Other o)
    {
        public void M() { }
    }

    public static void M2(this Other o) { }
}
""";
        var comp = CreateCompilation(src, references: [derivedRef]);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0012: The type 'Missing' is defined in an assembly that is not referenced. You must add a reference to assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // new Derived().M();
            Diagnostic(ErrorCode.ERR_NoTypeDef, "new Derived().M").WithArguments("Missing", "missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 1),
            // (1,15): error CS0012: The type 'Missing' is defined in an assembly that is not referenced. You must add a reference to assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // new Derived().M();
            Diagnostic(ErrorCode.ERR_NoTypeDef, "M").WithArguments("Missing", "missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 15),
            // (2,1): error CS0012: The type 'Missing' is defined in an assembly that is not referenced. You must add a reference to assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // new Derived().M2();
            Diagnostic(ErrorCode.ERR_NoTypeDef, "new Derived().M2").WithArguments("Missing", "missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(2, 1),
            // (2,15): error CS0012: The type 'Missing' is defined in an assembly that is not referenced. You must add a reference to assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // new Derived().M2();
            Diagnostic(ErrorCode.ERR_NoTypeDef, "M2").WithArguments("Missing", "missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(2, 15));
    }

    [Fact]
    public void GetCompatibleExtension_Conversion_11()
    {
        var missingSrc = """
public class Missing { }
""";
        var missingRef = CreateCompilation(missingSrc, assemblyName: "missing").EmitToImageReference();

        var derivedSrc = """
public class Derived : Missing { }
""";
        var derivedRef = CreateCompilation(derivedSrc, references: [missingRef]).EmitToImageReference();

        var src = """
new Derived().M();
new Derived().M2();

static class E
{
    extension(Derived d)
    {
        public void M() { }
    }

    public static void M2(this Derived d) { }
}
""";
        var comp = CreateCompilation(src, references: [derivedRef]);
        comp.VerifyEmitDiagnostics(
            // (1,15): error CS0012: The type 'Missing' is defined in an assembly that is not referenced. You must add a reference to assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // new Derived().M();
            Diagnostic(ErrorCode.ERR_NoTypeDef, "M").WithArguments("Missing", "missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 15),
            // (2,15): error CS0012: The type 'Missing' is defined in an assembly that is not referenced. You must add a reference to assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // new Derived().M2();
            Diagnostic(ErrorCode.ERR_NoTypeDef, "M2").WithArguments("Missing", "missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(2, 15));
    }

    [Fact]
    public void GetCompatibleExtension_Conversion_12()
    {
        var missingSrc = """
public class Missing { }
""";
        var missingRef = CreateCompilation(missingSrc, assemblyName: "missing").EmitToImageReference();

        var derivedSrc = """
public class I<T> { }
public class Derived : I<Missing> { }
""";
        var derivedRef = CreateCompilation(derivedSrc, references: [missingRef]).EmitToImageReference();

        var src = """
new Derived().M();
new Derived().M2();

static class E
{
    extension(I<object> i)
    {
        public void M() { }
    }

    public static void M2(this I<object> i) { }
}
""";
        var comp = CreateCompilation(src, references: [derivedRef]);
        comp.VerifyEmitDiagnostics(
                // (1,1): error CS1929: 'Derived' does not contain a definition for 'M' and the best extension method overload 'E.extension(I<object>).M()' requires a receiver of type 'I<object>'
                // new Derived().M();
                Diagnostic(ErrorCode.ERR_BadInstanceArgType, "new Derived()").WithArguments("Derived", "M", "E.extension(I<object>).M()", "I<object>").WithLocation(1, 1),
                // (2,1): error CS1929: 'Derived' does not contain a definition for 'M2' and the best extension method overload 'E.M2(I<object>)' requires a receiver of type 'I<object>'
                // new Derived().M2();
                Diagnostic(ErrorCode.ERR_BadInstanceArgType, "new Derived()").WithArguments("Derived", "M2", "E.M2(I<object>)", "I<object>").WithLocation(2, 1));
    }

    [Fact]
    public void GetCompatibleExtension_TypeInference_01()
    {
        var src = """
I<object, string>.M();

interface I<out T1, out T2> { }

static class E
{
    extension<T>(I<T, T>)
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "I<object, string>.M");
        Assert.Equal("void E.<>E__0<System.Object>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void GetCompatibleExtension_TypeInference_02()
    {
        var src = """
I<object, string>.M();

interface I<in T1, in T2> { }

static class E
{
    extension<T>(I<T, T>)
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "I<object, string>.M");
        Assert.Equal("void E.<>E__0<System.String>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void GetCompatibleExtension_TypeInference_03()
    {
        var src = """
I<object, string>.M();

interface I<T1, T2> { }

static class E
{
    extension<T>(I<T, T>)
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,19): error CS1061: 'I<object, string>' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'I<object, string>' could be found (are you missing a using directive or an assembly reference?)
            // I<object, string>.M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("I<object, string>", "M").WithLocation(1, 19));
    }

    [Fact]
    public void GetCompatibleExtension_Constraint_UseSiteInfo_01()
    {
        var missingSrc = """
public struct Missing { public int i; }
""";
        var missingRef = CreateCompilation(missingSrc, assemblyName: "missing").EmitToImageReference();

        var containerSrc = """
public struct Container { public Missing field; }
""";
        var containerRef = CreateCompilation(containerSrc, references: [missingRef]).EmitToImageReference();

        var src = """
Container.M();

static class E
{
    extension<T>(T t) where T : unmanaged
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src, references: [containerRef]);
        comp.VerifyEmitDiagnostics(
            // (1,11): error CS8377: The type 'Container' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter 'T' in the generic type or method 'E.extension<T>(T)'
            // Container.M();
            Diagnostic(ErrorCode.ERR_UnmanagedConstraintNotSatisfied, "M").WithArguments("E.extension<T>(T)", "T", "Container").WithLocation(1, 11),
            // (1,11): error CS0012: The type 'Missing' is defined in an assembly that is not referenced. You must add a reference to assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // Container.M();
            Diagnostic(ErrorCode.ERR_NoTypeDef, "M").WithArguments("Missing", "missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 11));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Container.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);

        src = """
new Container().M();

static class E
{
    public static void M<T>(this T t) where T : unmanaged { }
}
""";
        comp = CreateCompilation(src, references: [containerRef]);
        comp.VerifyEmitDiagnostics(
            // (1,17): error CS8377: The type 'Container' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter 'T' in the generic type or method 'E.M<T>(T)'
            // new Container().M();
            Diagnostic(ErrorCode.ERR_UnmanagedConstraintNotSatisfied, "M").WithArguments("E.M<T>(T)", "T", "Container").WithLocation(1, 17),
            // (1,17): error CS0012: The type 'Missing' is defined in an assembly that is not referenced. You must add a reference to assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // new Container().M();
            Diagnostic(ErrorCode.ERR_NoTypeDef, "M").WithArguments("Missing", "missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 17));

        src = """
new object().M(new Container());

static class E
{
    public static void M<T>(this object o, T t) where T : unmanaged { }
}
""";
        comp = CreateCompilation(src, references: [containerRef]);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS8377: The type 'Container' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter 'T' in the generic type or method 'E.M<T>(object, T)'
            // new object().M(new Container());
            Diagnostic(ErrorCode.ERR_UnmanagedConstraintNotSatisfied, "M").WithArguments("E.M<T>(object, T)", "T", "Container").WithLocation(1, 14),
            // (1,14): error CS0012: The type 'Missing' is defined in an assembly that is not referenced. You must add a reference to assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // new object().M(new Container());
            Diagnostic(ErrorCode.ERR_NoTypeDef, "M").WithArguments("Missing", "missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 14));
    }

    [Fact]
    public void GetCompatibleExtension_Constraint_UseSiteInfo_02()
    {
        var missingSrc = """
public struct Missing { public int i; }
""";
        var missingRef = CreateCompilation(missingSrc, assemblyName: "missing").EmitToImageReference();

        var containerSrc = """
public struct Container { public Missing field; }
""";
        var containerRef = CreateCompilation(containerSrc, references: [missingRef]).EmitToImageReference();

        var src = """
using N;

Container.M();

static class E
{
    extension<T>(T t) where T : unmanaged
    {
        public static void M(int inapplicable) => throw null;
    }
}

namespace N
{
    static class E2
    {
        extension<T>(T t)
        {
            public static void M() { }
        }
    }
}
""";
        var comp = CreateCompilation(src, references: [containerRef]);
        comp.VerifyEmitDiagnostics(); // The inapplicable candidate gets rejected before we get to check its constraints

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Container.M");
        Assert.Equal("void N.E2.<>E__0<Container>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());

        src = """
Container.M();

static class E
{
    extension<T>(T t) where T : unmanaged
    {
        public static void M(int inapplicable) => throw null;
    }
}
""";
        comp = CreateCompilation(src, references: [containerRef]);
        comp.VerifyEmitDiagnostics(
            // (1,11): error CS7036: There is no argument given that corresponds to the required parameter 'inapplicable' of 'E.extension<T>(T).M(int)'
            // Container.M();
            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "M").WithArguments("inapplicable", "E.extension<T>(T).M(int)").WithLocation(1, 11));

        src = """
using N;

Container.M();

static class E
{
    extension<T>(T t) where T : unmanaged
    {
        public static void M() => throw null; // applicable to arguments
    }
}

namespace N
{
    static class E2
    {
        extension<T>(T t)
        {
            public static void M() => throw null;
        }
    }
}
""";
        comp = CreateCompilation(src, references: [containerRef]);
        comp.VerifyEmitDiagnostics();

        tree = comp.SyntaxTrees.Single();
        model = comp.GetSemanticModel(tree);
        memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Container.M");
        Assert.Equal("void N.E2.<>E__0<Container>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());

        src = """
using N;

new Container().M();

static class E
{
    public static void M<T>(this T t) where T : unmanaged { }
}

namespace N
{
    static class E2
    {
        public static void M<T>(this T t) { }
    }
}
""";
        // Expecting an error to be reported since we're not able to check whether the constraint is violated
        // Tracked by https://github.com/dotnet/roslyn/issues/77407
        comp = CreateCompilation(src, references: [containerRef]);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void GetCompatibleExtension_Constraint_UseSiteInfo_03()
    {
        var missingSrc = """
public struct Missing { public int i; }
""";
        var missingRef = CreateCompilation(missingSrc, assemblyName: "missing").EmitToImageReference();

        var containerSrc = """
public struct Container { public Missing field; }
""";
        var containerRef = CreateCompilation(containerSrc, references: [missingRef]).EmitToImageReference();

        var src = """
int.M(new Container());

static class E
{
    extension(int)
    {
        public static void M<T>(T t) where T : unmanaged { }
    }
}
""";
        var comp = CreateCompilation(src, references: [containerRef]);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS8377: The type 'Container' must be a non-nullable value type, along with all fields at any level of nesting, in order to use it as parameter 'T' in the generic type or method 'E.extension(int).M<T>(T)'
            // int.M(new Container());
            Diagnostic(ErrorCode.ERR_UnmanagedConstraintNotSatisfied, "M").WithArguments("E.extension(int).M<T>(T)", "T", "Container").WithLocation(1, 5),
            // (1,5): error CS0012: The type 'Missing' is defined in an assembly that is not referenced. You must add a reference to assembly 'missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
            // int.M(new Container());
            Diagnostic(ErrorCode.ERR_NoTypeDef, "M").WithArguments("Missing", "missing, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(1, 5));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void InstancePropertyAccess_Simple()
    {
        var src = """
System.Console.Write(new object().P);

public static class Extensions
{
    extension(object o)
    {
        public int P => 42;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().P");
        Assert.Equal("System.Int32 Extensions.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void InstancePropertyAccess_StaticExtensionProperty()
    {
        var src = """
System.Console.Write(new object().P);

public static class Extensions
{
    extension(object o)
    {
        public static int P => 42;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,22): error CS9286: 'object' does not contain a definition for 'P' and no accessible extension member 'P' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // System.Console.Write(new object().P);
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "new object().P").WithArguments("object", "P").WithLocation(1, 22));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().P");
        Assert.Equal("System.Int32 Extensions.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void InstancePropertyAccess_Invoked()
    {
        var src = """
new object().P();

public static class Extensions
{
    extension(object o)
    {
        public int P => 42;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS1061: 'object' does not contain a definition for 'P' and no accessible extension method 'P' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // new object().P();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "P").WithArguments("object", "P").WithLocation(1, 14));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "new object().P()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Equal([], model.GetSymbolInfo(invocation).CandidateSymbols.ToTestDisplayStrings());

        Assert.Equal(["System.Int32 Extensions.<>E__0.P { get; }"], model.GetMemberGroup(invocation.Expression).ToTestDisplayStrings());
    }

    [Fact]
    public void InstancePropertyAccess_Invoked_Invocable()
    {
        var src = """
new object().P();

public static class Extensions
{
    extension(object o)
    {
        public System.Action P { get { return () => { System.Console.Write("ran"); }; } }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().P");
        Assert.Equal("System.Action Extensions.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : handle GetMemberGroup on a property access
    }

    [Fact]
    public void StaticMethodInvocation_Simple()
    {
        var src = """
object.M();

public static class Extensions
{
    extension(object)
    {
        public static int M() => 42;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "object.M()");
        Assert.Equal("System.Int32 Extensions.<>E__0.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(invocation).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void StaticMethodInvocation_TypeArguments()
    {
        var source = """
C.M<object>(42);

class C { }

static class E
{
    extension(C)
    {
        public static void M(int i) => throw null;
        public static void M<T>(int i) { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M<object>");
        Assert.Equal("void E.<>E__0.M<System.Object>(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M<System.Object>(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Theory, CombinatorialData]
    public void StaticMethodInvocation_Ambiguity_Method(bool e1BeforeE2)
    {
        var e1 = """
static class E1
{
    extension(object)
    {
        public static void Method() => throw null;
    }
}
""";

        var e2 = """
static class E2
{
    extension(object)
    {
        public static void Method() => throw null;
    }
}
""";

        var src = $$"""
object.Method();

{{(e1BeforeE2 ? e1 : e2)}}
{{(e1BeforeE2 ? e2 : e1)}}
""";
        var comp = CreateCompilation(src);
        if (!e1BeforeE2)
        {
            comp.VerifyEmitDiagnostics(
                // (1,8): error CS0121: The call is ambiguous between the following methods or properties: 'E2.extension(object).Method()' and 'E1.extension(object).Method()'
                // object.Method();
                Diagnostic(ErrorCode.ERR_AmbigCall, "Method").WithArguments("E2.extension(object).Method()", "E1.extension(object).Method()").WithLocation(1, 8));
        }
        else
        {
            comp.VerifyEmitDiagnostics(
                // (1,8): error CS0121: The call is ambiguous between the following methods or properties: 'E1.extension(object).Method()' and 'E2.extension(object).Method()'
                // object.Method();
                Diagnostic(ErrorCode.ERR_AmbigCall, "Method").WithArguments("E1.extension(object).Method()", "E2.extension(object).Method()").WithLocation(1, 8));
        }
    }

    [Fact]
    public void StaticPropertyAccess_InstanceExtensionProperty()
    {
        var src = """
System.Console.Write(new object().P);

public static class Extensions
{
    extension(object o)
    {
        public static int P => 42;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,22): error CS9286: 'object' does not contain a definition for 'P' and no accessible extension member 'P' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // System.Console.Write(new object().P);
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "new object().P").WithArguments("object", "P").WithLocation(1, 22));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().P");
        Assert.Equal("System.Int32 Extensions.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_ExtensionMethod()
    {
        var source = """
bool b = true;
var x = b ? object.M : object.M;

static class E
{
    extension(object o)
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,9): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'method group' and 'method group'
            // var x = b ? object.M : object.M;
            Diagnostic(ErrorCode.ERR_InvalidQM, "b ? object.M : object.M").WithArguments("method group", "method group").WithLocation(2, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").ToArray();
        Assert.Null(model.GetSymbolInfo(memberAccess[0]).Symbol);
        Assert.Null(model.GetSymbolInfo(memberAccess[1]).Symbol);

        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess[0]).ToTestDisplayStrings());
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess[1]).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_ExtensionProperty()
    {
        var source = """
bool b = true;
var x = b ? object.StaticProperty : object.StaticProperty;
System.Console.Write(x);

static class E
{
    extension(object o)
    {
        public static int StaticProperty => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.StaticProperty").ToArray();
        Assert.Equal("System.Int32 E.<>E__0.StaticProperty { get; }", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("System.Int32 E.<>E__0.StaticProperty { get; }", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_DifferentTypes()
    {
        var source = """
bool b = true;
var x = b ? object.StaticProperty : object.StaticProperty2;
System.Console.Write(x.ToString());

static class E
{
    extension(object o)
    {
        public static int StaticProperty => 42;
        public static long StaticProperty2 => 43;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticProperty");
        Assert.Equal("System.Int32 E.<>E__0.StaticProperty { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess).Type.ToTestDisplayString());
        Assert.Equal("System.Int64", model.GetTypeInfo(memberAccess).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_WithTargetType()
    {
        var source = """
bool b = true;
long x = b ? object.StaticProperty : object.StaticProperty;
System.Console.Write(x.ToString());

static class E
{
    extension(object o)
    {
        public static int StaticProperty => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.StaticProperty").ToArray();
        Assert.Equal("System.Int32 E.<>E__0.StaticProperty { get; }", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("System.Int32 E.<>E__0.StaticProperty { get; }", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());

        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess[0]).Type.ToTestDisplayString());
        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess[0]).ConvertedType.ToTestDisplayString());

        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess[1]).Type.ToTestDisplayString());
        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess[1]).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_TwoExtensions_WithTargetType()
    {
        var source = """
bool b = true;
string x = b ? D.f : D.f;
System.Console.Write(x);

class D { }

static class E1
{
    extension(D)
    {
        public static string f => "ran";
    }
}

static class E2
{
    extension(object o)
    {
        public static void f() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,16): error CS9286: 'D' does not contain a definition for 'f' and no accessible extension member 'f' for receiver of type 'D' could be found (are you missing a using directive or an assembly reference?)
            // string x = b ? D.f : D.f;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "D.f").WithArguments("D", "f").WithLocation(2, 16),
            // (2,22): error CS9286: 'D' does not contain a definition for 'f' and no accessible extension member 'f' for receiver of type 'D' could be found (are you missing a using directive or an assembly reference?)
            // string x = b ? D.f : D.f;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "D.f").WithArguments("D", "f").WithLocation(2, 22));
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_TwoExtensions_WithTargetDelegateType()
    {
        var source = """
bool b = true;
System.Action x = b ? D.f : D.f;
System.Console.Write(x);

class D { }

static class E
{
    extension(D)
    {
        public static string f => null;
    }
}

static class E2
{
    extension(object o)
    {
        public static void f() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,23): error CS9286: 'D' does not contain a definition for 'f' and no accessible extension member 'f' for receiver of type 'D' could be found (are you missing a using directive or an assembly reference?)
            // System.Action x = b ? D.f : D.f;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "D.f").WithArguments("D", "f").WithLocation(2, 23),
            // (2,29): error CS9286: 'D' does not contain a definition for 'f' and no accessible extension member 'f' for receiver of type 'D' could be found (are you missing a using directive or an assembly reference?)
            // System.Action x = b ? D.f : D.f;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "D.f").WithArguments("D", "f").WithLocation(2, 29));
    }

    [Fact]
    public void ResolveAll_Cast_Static_Operand()
    {
        var source = """
var x = (long)object.StaticProperty;
System.Console.Write(x.ToString());

static class E
{
    extension(object o)
    {
        public static int StaticProperty => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticProperty");
        Assert.Equal("System.Int32 E.<>E__0.StaticProperty { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess).Type.ToTestDisplayString());
        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Cast_Static_Operand_TwoExtensions()
    {
        var source = """
var x = (string)D.f;
System.Console.Write(x);

class D { }

static class E1
{
    extension(D)
    {
        public static string f => "ran";
    }
}

static class E2
{
    extension(object)
    {
        public static void f() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,17): error CS9286: 'D' does not contain a definition for 'f' and no accessible extension member 'f' for receiver of type 'D' could be found (are you missing a using directive or an assembly reference?)
            // var x = (string)D.f;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "D.f").WithArguments("D", "f").WithLocation(1, 17));
    }

    [Fact]
    public void ResolveAll_Cast_Static_Operand_TwoExtensions_DelegateType()
    {
        var source = """
var x = (System.Action)D.f;
System.Action a = D.f;

class D { }

static class E1
{
    extension(D)
    {
        public static string f => null;
    }
}

static class E2
{
    extension(object)
    {
        public static void f() => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,24): error CS9286: 'D' does not contain a definition for 'f' and no accessible extension member 'f' for receiver of type 'D' could be found (are you missing a using directive or an assembly reference?)
            // var x = (System.Action)D.f;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "D.f").WithArguments("D", "f").WithLocation(1, 24),
            // (2,19): error CS9286: 'D' does not contain a definition for 'f' and no accessible extension member 'f' for receiver of type 'D' could be found (are you missing a using directive or an assembly reference?)
            // System.Action a = D.f;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "D.f").WithArguments("D", "f").WithLocation(2, 19));

        // Note: a conversion to a delegate type does not provide invocation context for resolving the member access
        source = """
var x = (System.Action)D.f;
System.Action a = D.f;

class C
{
    public static void f() { }
}

class D : C
{
    public static new string f => null!;
}
""";
        comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0030: Cannot convert type 'string' to 'System.Action'
            // var x = (System.Action)D.f;
            Diagnostic(ErrorCode.ERR_NoExplicitConv, "(System.Action)D.f").WithArguments("string", "System.Action").WithLocation(1, 9),
            // (2,19): error CS0029: Cannot implicitly convert type 'string' to 'System.Action'
            // System.Action a = D.f;
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "D.f").WithArguments("string", "System.Action").WithLocation(2, 19));
    }

    [Fact]
    public void ResolveAll_MethodTypeInference()
    {
        var source = """
write(object.M);
void write<T>(T t) { System.Console.Write(t.ToString()); }

static class E
{
    extension(object)
    {
        public static int M => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess).Type.ToTestDisplayString());
        Assert.Equal("System.Int32", model.GetTypeInfo(memberAccess).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ArrayCreation_Initializer_Static()
    {
        var source = """
var x = new[] { object.StaticProperty, object.StaticProperty };
System.Console.Write((x[0], x[1]));

static class E
{
    extension(object)
    {
        public static int StaticProperty => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "(42, 42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.StaticProperty").ToArray();
        Assert.Equal("System.Int32 E.<>E__0.StaticProperty { get; }", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("System.Int32 E.<>E__0.StaticProperty { get; }", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ArrayCreation_Rank()
    {
        var source = """
var x = new object[object.StaticProperty];
System.Console.Write(x.Length.ToString());

static class E
{
    extension(object o)
    {
        public static int StaticProperty => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.StaticProperty");
        Assert.Equal("System.Int32 E.<>E__0.StaticProperty { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Deconstruction_Declaration()
    {
        var source = """
var (x, y) = object.M;
System.Console.Write((x, y));

static class E
{
    extension(object)
    {
        public static (int, int) M => (42, 43);
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "(42, 43)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("(System.Int32, System.Int32) E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Deconstruction_Assignment()
    {
        var source = """
int x, y;
(x, y) = object.M;
System.Console.Write((x, y));

static class E
{
    extension(object o)
    {
        public static (int, int) M => (42, 43);
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "(42, 43)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("(System.Int32, System.Int32) E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_TupleExpression()
    {
        var source = """
System.Console.Write((object.M, object.M));

static class E
{
    extension(object o)
    {
        public static int M => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "(42, 42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").ToArray();
        Assert.Equal("System.Int32 E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("System.Int32 E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_CollectionExpression()
    {
        var source = """
int[] x = [object.M];
System.Console.Write(x[0].ToString());

static class E
{
    extension(object o)
    {
        public static int M => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_CollectionExpression_ExtensionAddMethod()
    {
        var source = """
using System.Collections;
using System.Collections.Generic;

MyCollection c = [42];

static class E
{
    extension(MyCollection c)
    {
        public void Add(int i) { System.Console.Write("ran"); }
    }
}

public class MyCollection : IEnumerable<int>
{
    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();
    }

    [Fact]
    public void ResolveAll_CollectionExpression_ExtensionAddMethod_RefReceiverParameter()
    {
        // The receiver argument gets an implicit `ref` when the parameter is `ref`
        var source = """
using System.Collections;
using System.Collections.Generic;

MyCollection c = [42];
System.Console.Write(c is null);

static class E
{
    extension(ref MyCollection c)
    {
        public void Add(int i) { System.Console.Write("ran "); c = null; }
    }
}

public class MyCollection : IEnumerable<int>
{
    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran True").VerifyDiagnostics();
    }

    [Fact]
    public void ResolveAll_CollectionExpression_ExtensionAddMethod_InReceiverParameter()
    {
        var source = """
using System.Collections;
using System.Collections.Generic;

MyCollection c = [42];

static class E
{
    extension(in MyCollection c)
    {
        public void Add(int i) { System.Console.Write("ran"); }
    }
}

public class MyCollection : IEnumerable<int>
{
    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();
    }

    [Fact]
    public void ResolveAll_CollectionExpression_ExtensionAddMethod_RefParameter()
    {
        var source = """
using System.Collections;
using System.Collections.Generic;

MyCollection c = [42];

static class E
{
    extension(MyCollection c)
    {
        public void Add(ref int i) { System.Console.Write("ran"); }
    }
}

public class MyCollection : IEnumerable<int>
{
    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (4,18): error CS1954: The best overloaded method match 'E.extension(MyCollection).Add(ref int)' for the collection initializer element cannot be used. Collection initializer 'Add' methods cannot have ref or out parameters.
            // MyCollection c = [42];
            Diagnostic(ErrorCode.ERR_InitializerAddHasParamModifiers, "[42]").WithArguments("E.extension(MyCollection).Add(ref int)").WithLocation(4, 18));
    }

    [Fact]
    public void ResolveAll_CollectionExpression_ExtensionAddDelegateTypeProperty()
    {
        var source = """
using System.Collections;
using System.Collections.Generic;

MyCollection c = [42];

static class E
{
    extension(MyCollection c)
    {
        public System.Action<int> Add => (int i) => { };
    }
}

public class MyCollection : IEnumerable<int>
{
    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (4,18): error CS1061: 'MyCollection' does not contain a definition for 'Add' and no accessible extension method 'Add' accepting a first argument of type 'MyCollection' could be found (are you missing a using directive or an assembly reference?)
            // MyCollection c = [42];
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "[42]").WithArguments("MyCollection", "Add").WithLocation(4, 18)
            );
    }

    [Fact]
    public void ResolveAll_Initializer_Property()
    {
        var source = """
var x = new System.Collections.Generic.List<int>() { object.M };
System.Console.Write(x[0]);

static class E
{
    extension(object o)
    {
        public static int M => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Initializer_Method()
    {
        var source = """
var x = new System.Collections.Generic.List<int>() { object.M };

static class E
{
    extension(object o)
    {
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,54): error CS1950: The best overloaded Add method 'List<int>.Add(int)' for the collection initializer has some invalid arguments
            // var x = new System.Collections.Generic.List<int>() { object.M };
            Diagnostic(ErrorCode.ERR_BadArgTypesForCollectionAdd, "object.M").WithArguments("System.Collections.Generic.List<int>.Add(int)").WithLocation(1, 54),
            // (1,54): error CS1503: Argument 1: cannot convert from 'method group' to 'int'
            // var x = new System.Collections.Generic.List<int>() { object.M };
            Diagnostic(ErrorCode.ERR_BadArgType, "object.M").WithArguments("1", "method group", "int").WithLocation(1, 54));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void E.<>E__0.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.OverloadResolutionFailure, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Initializer_ObjectInitializer()
    {
        var source = """
var x = new C() { f = object.M };
System.Console.Write(x.f.ToString());

class C
{
    public int f;
}

static class E
{
    extension(object o)
    {
        public static int M => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalAccess_Receiver()
    {
        var source = """
System.Console.Write(object.M?.ToString());

static class E
{
    extension(object o)
    {
        public static string M => "ran";
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalAccess_WhenNotNull_Property()
    {
        var source = """
var x = new object()?.M;
System.Console.Write(x.ToString());

static class E
{
    extension(object o)
    {
        public string M => "ran";
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberBinding = GetSyntax<MemberBindingExpressionSyntax>(tree, ".M");
        Assert.Equal("System.String E.<>E__0.M { get; }", model.GetSymbolInfo(memberBinding).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ConditionalAccess_WhenNotNull_Invocation()
    {
        var source = """
var x = new object()?.M();
System.Console.Write(x.ToString());

static class E
{
    extension(object o)
    {
        public string M() => "ran";
        public string M(int i) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberBinding = GetSyntax<MemberBindingExpressionSyntax>(tree, ".M");
        Assert.Equal("System.String E.<>E__0.M()", model.GetSymbolInfo(memberBinding).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_CompoundAssignment_Left()
    {
        var source = """
object.M += 41;
System.Console.Write(E.M.ToString());

static class E
{
    extension(object o)
    {
        public static int M { get => 42; set { } }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.<>E__0.M { get; set; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_CompoundAssignment_Right()
    {
        var source = """
int x = 1;
x += object.M;
System.Console.Write(x.ToString());

static class E
{
    extension(object o)
    {
        public static int M => 41;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_BinaryOperator_UserDefinedOperator()
    {
        var source = """
var x = object.M + object.M;
System.Console.Write(x.ToString());

public class C
{
    public static int operator+(C c1, C c2) => 42;
}

static class E
{
    extension(object o)
    {
        public static C M => new C();
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").ToArray();
        Assert.Equal("C E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("C E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());

        var binaryOp = GetSyntax<BinaryExpressionSyntax>(tree, "object.M + object.M");
        Assert.Equal("System.Int32 C.op_Addition(C c1, C c2)", model.GetSymbolInfo(binaryOp).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_BinaryOperator_NoUserDefinedOperator()
    {
        var source = """
var x = object.M + object.M;
System.Console.Write(x.ToString());

public class C { }

static class E
{
    extension(object o)
    {
        public static C M => new C();
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0019: Operator '+' cannot be applied to operands of type 'C' and 'C'
            // var x = object.M + object.M;
            Diagnostic(ErrorCode.ERR_BadBinaryOps, "object.M + object.M").WithArguments("+", "C", "C").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").ToArray();
        Assert.Equal("C E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess[0]).Symbol.ToTestDisplayString());
        Assert.Equal("C E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess[1]).Symbol.ToTestDisplayString());

        var binaryOp = GetSyntax<BinaryExpressionSyntax>(tree, "object.M + object.M");
        Assert.Null(model.GetSymbolInfo(binaryOp).Symbol);
    }

    [Fact]
    public void ResolveAll_IncrementOperator()
    {
        var source = """
object.M++;

public class C { }

static class E
{
    extension(object o)
    {
        public static int M { get { System.Console.Write("get "); return 41; } set { System.Console.Write($"set({value}) "); } }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "get set(42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.<>E__0.M { get; set; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var unaryOp = GetSyntax<PostfixUnaryExpressionSyntax>(tree, "object.M++");
        Assert.Equal("System.Int32 System.Int32.op_Increment(System.Int32 value)", model.GetSymbolInfo(unaryOp).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_UnaryOperator()
    {
        var source = """
_ = !object.M;

public class C { }

static class E
{
    extension(object o)
    {
        public static bool M { get { System.Console.Write("ran"); return true; } }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Boolean E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var unaryOp = GetSyntax<PrefixUnaryExpressionSyntax>(tree, "!object.M");
        Assert.Equal("System.Boolean System.Boolean.op_LogicalNot(System.Boolean value)",
            model.GetSymbolInfo(unaryOp).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_NullCoalescingOperator()
    {
        var source = """
var x = object.M ?? object.M2;
System.Console.Write(x);

static class E
{
    extension(object o)
    {
        public static string M => null;
        public static string M2 => "ran";
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal("System.String E.<>E__0.M2 { get; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_NullCoalescingAssignmentOperator()
    {
        var source = """
object.M ??= object.M2;

static class E
{
    extension(object o)
    {
        public static string M { get { System.Console.Write("get "); return null; }  set { System.Console.Write($"set({value}) "); } }
        public static string M2 => "ran";
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "get set(ran)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.<>E__0.M { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal("System.String E.<>E__0.M2 { get; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Query_Select()
    {
        var source = """
using System.Linq;

int[] array = [1];
var r = from int i in array select object.M;
foreach (var x in r)
{
    System.Console.Write(x.ToString());
}

static class E
{
    extension(object o)
    {
        public static string M => "ran";
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact(Skip = "Tracked by https://github.com/dotnet/roslyn/issues/76130 : WasPropertyBackingFieldAccessChecked asserts that we're setting twice")]
    public void ResolveAll_Query_Cast()
    {
        var source = """
using System.Linq;

var r = from string s in object.M from string s2 in object.M2 select s.ToString();
foreach (var x in r)
{
    System.Console.Write(x.ToString());
}

static class E
{
    extension(object o)
    {
        public static object[] M => ["ran"];
        public static object[] M2 => [""];
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Object[] E.M", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal("System.Object[] E.M2", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Return_Lambda()
    {
        var source = """
var x = () =>
    {
        bool b = true;
        if (b)
            return object.M;
        else
            return object.M2;
    };
System.Console.Write(x().ToString());

static class E
{
    extension(object o)
    {
        public static int M => 42;
        public static int M2 => 0;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal("System.Int32 E.<>E__0.M2 { get; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_ExpressionBodiedLambda()
    {
        var source = """
var x = () => object.M;
System.Console.Write(x().ToString());

static class E
{
    extension(object o)
    {
        public static int M => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_YieldReturn()
    {
        var source = """
foreach (var y in local())
{
    System.Console.Write(y.ToString());
}

System.Collections.Generic.IEnumerable<int> local()
{
    bool b = true;
    if (b)
        yield return object.M;
    else
        yield return object.M2;
}

static class E
{
    extension(object o)
    {
        public static int M => 42;
        public static int M2 => 0;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal("System.Int32 E.<>E__0.M2 { get; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_YieldReturn_Lambda()
    {
        var source = """
var x = System.Collections.Generic.IEnumerable<int> () =>
    {
        bool b = true;
        if (b)
            yield return object.M;
        else
            yield return object.M2;
    };

foreach (var y in x())
{
    System.Console.Write(y.ToString());
}

static class E
{
    extension(object o)
    {
        public static int M => 42;
        public static int M2 => 0;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,56): error CS1643: Not all code paths return a value in lambda expression of type 'Func<IEnumerable<int>>'
            // var x = System.Collections.Generic.IEnumerable<int> () =>
            Diagnostic(ErrorCode.ERR_AnonymousReturnExpected, "=>").WithArguments("lambda expression", "System.Func<System.Collections.Generic.IEnumerable<int>>").WithLocation(1, 56),
            // (5,13): error CS1621: The yield statement cannot be used inside an anonymous method or lambda expression
            //             yield return object.M;
            Diagnostic(ErrorCode.ERR_YieldInAnonMeth, "yield").WithLocation(5, 13),
            // (7,13): error CS1621: The yield statement cannot be used inside an anonymous method or lambda expression
            //             yield return object.M2;
            Diagnostic(ErrorCode.ERR_YieldInAnonMeth, "yield").WithLocation(7, 13));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Int32 E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal("System.Int32 E.<>E__0.M2 { get; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Throw()
    {
        var source = """
try
{
    throw object.M;
}
catch (System.Exception e)
{
    System.Console.Write(e.Message);
}

static class E
{
    extension(object o)
    {
        public static System.Exception M => new System.Exception("ran");
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.Exception E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_FieldInitializer()
    {
        var source = """
System.Console.Write(C.field.ToString());

class C
{
    public static string field = object.M;
}

static class E
{
    extension(object o)
    {
        public static string M => "ran";
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static()
    {
        var src = """
local(object.M);

void local(string s)
{
    System.Console.Write(s);
}

static class E
{
    extension(object o)
    {
        public static string M => "ran";
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").First();
        Assert.Equal("System.String E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static_DelegateTypeParameter()
    {
        var src = """
local(object.M);

void local(System.Func<string> d)
{
    System.Console.Write(d());
}

static class E
{
    extension(object o)
    {
        public static string M() => "ran";
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").First();
        Assert.Equal("System.String E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static_Inferred()
    {
        var src = """
System.Console.Write(local(object.M));

T local<T>(T t)
{
    return t;
}

static class E
{
    extension(object o)
    {
        public static string M => "ran";
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.M").First();
        Assert.Equal("System.String E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static_DelegateTypeParameter_InapplicableInstanceMember()
    {
        var src = """
local(object.ToString);

void local(System.Func<int, string> d)
{
    System.Console.Write(d(42));
}

static class E
{
    extension(object o)
    {
        public static string ToString(int i) => "ran";
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.ToString").First();
        Assert.Equal("System.String E.<>E__0.ToString(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Invocation_Static_DelegateTypeParameter_PropertyAndMethod()
    {
        var src = """
var o = new object();
C.M(o.Member);

class C
{
    public static void M(System.Action a) { a(); }
}

static class E1
{
    extension(object o)
    {
        public string Member => throw null;
    }
}

public static class E2
{
    public static void Member(this object o) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,5): error CS9286: 'object' does not contain a definition for 'Member' and no accessible extension member 'Member' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // C.M(o.Member);
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "o.Member").WithArguments("object", "Member").WithLocation(2, 5));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "o.Member");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
        Assert.Equal(["System.String E1.<>E__0.Member { get; }", "void E2.Member(this System.Object o)"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_ObjectCreation_Static()
    {
        var source = """
new C(object.M);

class C
{
    public C(string s) { System.Console.Write(s); }
}

static class E
{
    extension(object o)
    {
        public static string M => "ran";
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_BinaryOperator_Static_TwoExtensions()
    {
        var src = """
bool b = D.f + D.f;

class C
{
    public static bool operator +(C c, System.Action a) => true;
}

class D { }

static class E1
{
    extension(D d)
    {
        public static C f => null;
    }
}

static class E2
{
    extension(object o)
    {
        public static void f() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,10): error CS9286: 'D' does not contain a definition for 'f' and no accessible extension member 'f' for receiver of type 'D' could be found (are you missing a using directive or an assembly reference?)
            // bool b = D.f + D.f;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "D.f").WithArguments("D", "f").WithLocation(1, 10),
            // (1,16): error CS9286: 'D' does not contain a definition for 'f' and no accessible extension member 'f' for receiver of type 'D' could be found (are you missing a using directive or an assembly reference?)
            // bool b = D.f + D.f;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "D.f").WithArguments("D", "f").WithLocation(1, 16));
    }

    [Fact]
    public void ResolveAll_Lambda_Static_TwoAsGoodExtensions_LambdaConverted()
    {
        var src = """
System.Func<System.Action> l = () => object.f;

static class E1
{
    extension(object o)
    {
        public static string f => null;
    }
}

static class E2
{
    extension(object o)
    {
        public static void f() { System.Console.Write("ran"); }
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : the diagnostic should describe what went wrong
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,38): error CS9286: 'object' does not contain a definition for 'f' and no accessible extension member 'f' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // System.Func<System.Action> l = () => object.f;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "object.f").WithArguments("object", "f").WithLocation(1, 38)
            );

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E1.<>E__0.f { get; }", "void E2.<>E__0.f()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Lambda_Instance_ExtensionMethodVsExtensionMember()
    {
        var src = """
System.Func<System.Action> lambda = () => new object().Member;

static class E
{
    extension(object o)
    {
        public string Member => throw null;
    }

    public static void Member(this object o) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,43): error CS9286: 'object' does not contain a definition for 'Member' and no accessible extension member 'Member' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // System.Func<System.Action> lambda = () => new object().Member;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "new object().Member").WithArguments("object", "Member").WithLocation(1, 43));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().Member");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void ResolveAll_Lambda_Instance_MethodGroupWithMultipleOverloads()
    {
        var src = """
System.Func<System.Action> lambda = () => new object().Member;
lambda()();

static class E
{
    extension(object o)
    {
        public void Member() { System.Console.Write("ran"); }
        public void Member(int i) => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().Member");
        Assert.Equal("void E.<>E__0.Member()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Lambda_Static_TwoExtensions_ConversionToDelegateType_ExplicitReturnType()
    {
        var src = """
var l = System.Action () => D.f;

class D { }

static class E1
{
    extension(object o)
    {
        public static string f => null;
    }
}
static class E2
{
    extension(object o)
    {
        public static void f() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,29): error CS9286: 'D' does not contain a definition for 'f' and no accessible extension member 'f' for receiver of type 'D' could be found (are you missing a using directive or an assembly reference?)
            // var l = System.Action () => D.f;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "D.f").WithArguments("D", "f").WithLocation(1, 29)
            );
    }

    [Fact]
    public void ResolveAll_Lambda_Static_TwoExtensions_ConversionToDelegateType()
    {
        var src = """
System.Func<System.Action> l = () => D.f;

class D { }

static class E1
{
    extension(D)
    {
        public static string f => null;
    }
}

static class E2
{
    extension(object)
    {
        public static void f() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,38): error CS9286: 'D' does not contain a definition for 'f' and no accessible extension member 'f' for receiver of type 'D' could be found (are you missing a using directive or an assembly reference?)
            // System.Func<System.Action> l = () => D.f;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "D.f").WithArguments("D", "f").WithLocation(1, 38)
            );
    }

    [Fact]
    public void ResolveAll_SwitchExpression_Static_Default()
    {
        var src = """
bool b = true;
var s = b switch { true => object.f, false => default };
System.Console.Write(s);

static class E
{
    extension(object)
    {
        public static string f => "hi";
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hi").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.f").First();
        Assert.Equal("System.String E.<>E__0.f { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());

        var defaultExpr = GetSyntax<LiteralExpressionSyntax>(tree, "default");
        Assert.Equal("System.String", model.GetTypeInfo(defaultExpr).Type.ToTestDisplayString());
        Assert.Equal("System.String", model.GetTypeInfo(defaultExpr).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_RefTernary()
    {
        var src = """
bool b = true;
string s1 = "ran";
string s2 = null;

var x = b ? ref s1.f : ref s2.f;
System.Console.Write(x);

static class E
{
    extension(ref string s)
    {
        public ref string f => ref s;
    }

    public static ref string M(this ref string s) => ref s;
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : missing error on extension parameter
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (15,30): error CS8337: The first parameter of a 'ref' extension method 'M' must be a value type or a generic type constrained to struct.
            //     public static ref string M(this ref string s) => ref s;
            Diagnostic(ErrorCode.ERR_RefExtensionMustBeValueTypeOrConstrainedToOne, "M").WithArguments("M").WithLocation(15, 30));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "s1.f");
        Assert.Equal("ref System.String E.<>E__0.f { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ResolveAll_Query_Static_InstanceMethodGroup()
    {
        var src = """
string query = from x in object.ToString select x;

static class E
{
    extension(object)
    {
        public static string ToString() => null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,33): error CS0119: 'object.ToString()' is a method, which is not valid in the given context
            // string query = from x in object.ToString select x;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "ToString").WithArguments("object.ToString()", "method").WithLocation(1, 33));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.ToString");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String System.Object.ToString()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Query_Static_ExtensionMethodGroup()
    {
        var src = """
string query = from x in object.M select x;

static class E
{
    extension(object o)
    {
        public static string M() => null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,33): error CS0119: 'E.extension(object).M()' is a method, which is not valid in the given context
            // string query = from x in object.M select x;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "M").WithArguments("E.extension(object).M()", "method").WithLocation(1, 33));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess)); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : consider handling BoundBadExpression better
    }

    [Fact]
    public void ResolveAll_Instance_Invocation_InnerInapplicableExtensionMethodVsOuterInvocableExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            new object().M();
        }
    }

    public static class Extension
    {
        public static void M(this object o, int i) { } // not applicable because of second parameter
    }
}

static class E
{
    extension(object o)
    {
        public System.Action M => () => { System.Console.Write("ran"); };
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("System.Action E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : handle GetMemberGroup on a property access
    }

    [Fact]
    public void ResolveAll_Instance_Invocation_InnerIrrelevantExtensionMethodVsOuterInvocableExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            new object().M();
        }
    }

    public static class Extension
    {
        public static void M(this string o, int i) { } // not eligible because of `this` parameter
    }
}

static class E
{
    extension(object o)
    {
        public System.Action M => () => { System.Console.Write("ran"); };
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("System.Action E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : handle GetMemberGroup on a property access
    }

    [Fact]
    public void ResolveAll_Instance_InferredVariable_InnerExtensionMethodVsOuterInvocableExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            var x = new object().M;
            x(42);
        }
    }

    public static class Extension
    {
        public static void M(this object o, int i) { System.Console.Write("ran"); }
    }
}

static class E
{
    extension(object o)
    {
        public System.Action M => () => throw null;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("void System.Object.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void System.Object.M(System.Int32 i)", "System.Action E.<>E__0.M { get; }"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Instance_LocalDeclaration_InnerExtensionMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            int x = new object().M;
        }
    }

    public static class Extension
    {
        public static void M(this object o, int i) { }
    }
}

static class E
{
    extension(object o)
    {
        public int M => 42;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics(
            // (7,34): error CS0428: Cannot convert method group 'M' to non-delegate type 'int'. Did you intend to invoke the method?
            //             int x = new object().M;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "M").WithArguments("M", "int").WithLocation(7, 34));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void System.Object.M(System.Int32 i)", "System.Int32 E.<>E__0.M { get; }"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Static_LocalDeclaration_InnerExtensionMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            int x = object.M;
        }
    }

    public static class Extension
    {
        public static void M(this object o, int i) { }
    }
}

static class E
{
    extension(object o)
    {
        public static int M => 42;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics(
            // (7,28): error CS0428: Cannot convert method group 'M' to non-delegate type 'int'. Did you intend to invoke the method?
            //             int x = object.M;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "M").WithArguments("M", "int").WithLocation(7, 28));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void System.Object.M(System.Int32 i)", "System.Int32 E.<>E__0.M { get; }"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Static_LocalDeclaration_InstanceInnerExtensionTypeMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            int x = object.M;
        }
    }

    static class E1
    {
        extension(object o)
        {
            public void M(int i) { }
        }
    }
}

static class E2
{
    extension(object)
    {
        public static int M => 42;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics(
            // (7,28): error CS0428: Cannot convert method group 'M' to non-delegate type 'int'. Did you intend to invoke the method?
            //             int x = object.M;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "M").WithArguments("M", "int").WithLocation(7, 28));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void N.E1.<>E__0.M(System.Int32 i)", "System.Int32 E2.<>E__0.M { get; }"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Instance_LocalDeclaration_StaticInnerExtensionTypeMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            int x = new object().M;
        }
    }

    static class E1
    {
        extension(object)
        {
            public static void M(int i) => throw null;
        }
    }
}

static class E2
{
    extension(object o)
    {
        public int M => 42;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics(
            // (7,34): error CS0428: Cannot convert method group 'M' to non-delegate type 'int'. Did you intend to invoke the method?
            //             int x = new object().M;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "M").WithArguments("M", "int").WithLocation(7, 34));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void N.E1.<>E__0.M(System.Int32 i)", "System.Int32 E2.<>E__0.M { get; }"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Instance_LocalDeclaration_InnerIrrelevantExtensionMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            int x = new object().M;
            System.Console.Write(x);
        }
    }

    public static class Extension
    {
        public static void M(this string o, int i) { } // not eligible because of `this` parameter
    }
}

static class E
{
    extension(object o)
    {
        public int M => 42;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("System.Int32 E.<>E__0.M { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : handle GetMemberGroup on a property access
    }

    [Fact]
    public void ResolveAll_Instance_LocalDeclaration_DelegateType_InnerInapplicableExtensionMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            System.Action x = new object().M;
            x();
        }
    }

    public static class Extension
    {
        public static void M(this object o, int i) { }
    }
}

static class E
{
    extension(object o)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void System.Object.M(System.Int32 i)", "void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_Instance_LocalDeclaration_DelegateType_InnerIrrelevantExtensionMethodVsOuterExtensionProperty()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            System.Action x = new object().M;
            x();
        }
    }

    public static class Extension
    {
        public static void M(this string o, int i) { } // not eligible because of `this` parameter
    }
}

static class E
{
    extension(object o)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ResolveAll_ConditionalOperator_Static_TwoAsGoodExtensions_Property()
    {
        var source = """
bool b = true;
var x = b ? object.StaticProperty : object.StaticProperty;

static class E1
{
    extension(object)
    {
        public static int StaticProperty => 42;
    }
}
static class E2
{
    extension(object)
    {
        public static int StaticProperty => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (2,13): error CS9286: 'object' does not contain a definition for 'StaticProperty' and no accessible extension member 'StaticProperty' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // var x = b ? object.StaticProperty : object.StaticProperty;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "object.StaticProperty").WithArguments("object", "StaticProperty").WithLocation(2, 13),
            // (2,37): error CS9286: 'object' does not contain a definition for 'StaticProperty' and no accessible extension member 'StaticProperty' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // var x = b ? object.StaticProperty : object.StaticProperty;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "object.StaticProperty").WithArguments("object", "StaticProperty").WithLocation(2, 37));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "object.StaticProperty").ToArray();
        Assert.Null(model.GetSymbolInfo(memberAccess[0]).Symbol);
        Assert.Null(model.GetSymbolInfo(memberAccess[1]).Symbol);
    }

    [Fact]
    public void DelegateConversion_TypeReceiver()
    {
        var source = """
D d = C.M;
d(42);

delegate void D(int i);

class C { }

static class E
{
    extension(C)
    {
        public static void M(int i) { System.Console.Write($"E.M({i})"); }
    }
}
""";
        var comp = CreateCompilation(source);
        var verifier = CompileAndVerify(comp, expectedOutput: "E.M(42)").VerifyDiagnostics();
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size       35 (0x23)
  .maxstack  2
  IL_0000:  ldsfld     "D Program.<>O.<0>__M"
  IL_0005:  dup
  IL_0006:  brtrue.s   IL_001b
  IL_0008:  pop
  IL_0009:  ldnull
  IL_000a:  ldftn      "void E.M(int)"
  IL_0010:  newobj     "D..ctor(object, System.IntPtr)"
  IL_0015:  dup
  IL_0016:  stsfld     "D Program.<>O.<0>__M"
  IL_001b:  ldc.i4.s   42
  IL_001d:  callvirt   "void D.Invoke(int)"
  IL_0022:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Null(model.GetTypeInfo(memberAccess).Type);
        Assert.Equal("D", model.GetTypeInfo(memberAccess).ConvertedType.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
        Assert.Equal(ConversionKind.MethodGroup, model.GetConversion(memberAccess).Kind);
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Creation()
    {
        var source = """
D d = new D(C.M);
d(42);

delegate void D(int i);

class C { }

static class E
{
    extension(C)
    {
        public static void M(int i) { System.Console.Write($"E.M({i})"); }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "E.M(42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Null(model.GetTypeInfo(memberAccess).Type);
        Assert.Equal("D", model.GetTypeInfo(memberAccess).ConvertedType.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
        Assert.Equal(ConversionKind.MethodGroup, model.GetConversion(memberAccess).Kind);
    }

    [Fact]
    public void DelegateConversion_InstanceReceiver_Creation()
    {
        var source = """
D d = new D(new C().M);
d(42);

delegate void D(int i);

class C { }

static class E
{
    extension(C)
    {
        public void M(int i) { System.Console.Write($"E.M({i})"); }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "E.M(42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M");
        Assert.Equal("void E.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Null(model.GetTypeInfo(memberAccess).Type);
        Assert.Equal("D", model.GetTypeInfo(memberAccess).ConvertedType.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
        Assert.Equal(ConversionKind.MethodGroup, model.GetConversion(memberAccess).Kind);
    }

    [Fact]
    public void DelegateConversion_InstanceReceiver()
    {
        var source = """
D d = new C(42).M;
d(43);

delegate void D(int i);

class C(int x)
{
    public int x = x;
    public void M() => throw null;
}

static class E
{
    extension(C c)
    {
        public void M(int i) { System.Console.Write($"{c.x}.M({i})"); }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        var verifier = CompileAndVerify(comp, expectedOutput: "42.M(43)").VerifyDiagnostics();
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size       26 (0x1a)
  .maxstack  2
  IL_0000:  ldc.i4.s   42
  IL_0002:  newobj     "C..ctor(int)"
  IL_0007:  ldftn      "void E.M(C, int)"
  IL_000d:  newobj     "D..ctor(object, System.IntPtr)"
  IL_0012:  ldc.i4.s   43
  IL_0014:  callvirt   "void D.Invoke(int)"
  IL_0019:  ret
}
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C(42).M");
        Assert.Equal("void E.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M()", "void E.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
        Assert.Equal(ConversionKind.MethodGroup, model.GetConversion(memberAccess).Kind);
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Overloads()
    {
        var source = """
D d = C.M;
d(42);

C.M(42);

delegate void D(int i);

class C { }

static class E
{
    extension(C)
    {
        public static void M(int i) { System.Console.Write("ran "); }

        public static void M(string s) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.M").First();
        Assert.Equal("void E.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M(System.Int32 i)", "void E.<>E__0.M(System.String s)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_ValueReceiver_Overloads()
    {
        var source = """
D d = new C().M;
d(42);

new C().M(42);

delegate void D(int i);

class C { }

static class E
{
    extension(C c)
    {
        public void M(int i) { System.Console.Write("ran "); }
        public void M(string s) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new C().M").First();
        Assert.Equal("void E.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M(System.Int32 i)", "void E.<>E__0.M(System.String s)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Overloads_DifferentExtensions()
    {
        var source = """
D d = C.M;
d(42);

C.M(42);

delegate void D(int i);

class C { }

static class E1
{
    extension(C)
    {
        public static void M(int i) { System.Console.Write("ran "); }
    }
}
static class E2
{
    extension(C)
    {
        public static void M(string s) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "C.M").First();
        Assert.Equal("void E1.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E1.<>E__0.M(System.Int32 i)", "void E2.<>E__0.M(System.String s)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_WrongSignature()
    {
        var source = """
D d = new C().M;
d(42);

new C().M(42);

delegate void D(int i);

class C { }

static class E
{
    extension(C c)
    {
        public void M(string s) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,15): error CS0123: No overload for 'M' matches delegate 'D'
            // D d = new C().M;
            Diagnostic(ErrorCode.ERR_MethDelegateMismatch, "M").WithArguments("M", "D").WithLocation(1, 15),
            // (4,11): error CS1503: Argument 2: cannot convert from 'int' to 'string'
            // new C().M(42);
            Diagnostic(ErrorCode.ERR_BadArgType, "42").WithArguments("2", "int", "string").WithLocation(4, 11));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new C().M").First();
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void E.<>E__0.M(System.String s)"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void E.<>E__0.M(System.String s)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_ZeroArityMatchesAny()
    {
        var source = """
D d = object.Method;
d("");

d = object.Method<string>;
d("");

delegate void D(string s);

static class E
{
    extension(object)
    {
        public static void Method(int i) => throw null;
        public static void Method<T>(T t) { System.Console.Write("Method "); }
        public static void Method<T1, T2>(T1 t1, T2 t2) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "Method Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Method");
        Assert.Equal("void E.<>E__0.Method<System.String>(System.String t)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.Method(System.Int32 i)", "void E.<>E__0.Method<T>(T t)", "void E.<>E__0.Method<T1, T2>(T1 t1, T2 t2)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_ValueReceiver_Overloads_OuterScope_WithInapplicableInstanceMember()
    {
        var source = """
using N;

D d = new C().M;
d(42);

new C().M(42);

delegate void D(int i);

class C
{
    public void M(char c) { }
}

namespace N
{
    static class E1
    {
        extension(C c)
        {
            public void M(int i)
            {
                System.Console.Write("ran ");
            }
        }
    }
}

static class E2
{
    extension(C c)
    {
        public void M(string s) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "new C().M").First();
        Assert.Equal("void N.E1.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M(System.Char c)", "void E2.<>E__0.M(System.String s)", "void N.E1.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Overloads_InnerScope()
    {
        var source = """
using N;

D d = C.M;
d(42);

delegate void D(int i);

class C { }

static class E1
{
    extension(C)
    {
        public static void M(int i) { System.Console.Write("ran"); }
    }
}

namespace N
{
    static class E2
    {
        extension(C)
        {
            public static void M(int i) => throw null;
        }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // 0.cs(1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1));

        CompileAndVerify(comp, expectedOutput: "ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E1.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E1.<>E__0.M(System.Int32 i)", "void N.E2.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_TypeArguments_01()
    {
        var source = """
D d = object.M<object>;
d(42);

delegate void D(int i);

static class E
{
    extension(object)
    {
        public static void M(int i) => throw null;
        public static void M<T>(int i) { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M<object>");
        Assert.Equal("void E.<>E__0.M<System.Object>(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M<System.Object>(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_TypeArguments_02()
    {
        var source = """
D d = object.M<object, int>;
d(42);

delegate void D(int i);

static class E
{
    extension(object)
    {
        public static void M<T>(T t) { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS0117: 'object' does not contain a definition for 'M'
            // D d = object.M<object, int>;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M<object, int>").WithArguments("object", "M").WithLocation(1, 14));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M<object, int>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_TypeArguments_03()
    {
        var source = """
D d = object.M<object, int>;
d(42);

delegate void D(int i);

static class E
{
    extension<T>(T t)
    {
        public static void M<U>(U u) { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M<object, int>");
        Assert.Equal("void E.<>E__0<System.Object>.M<System.Int32>(System.Int32 u)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0<System.Object>.M<System.Int32>(System.Int32 u)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_TypeArguments_04()
    {
        var source = """
D d = object.M<object>;
d(42);

delegate void D(int i);

static class E
{
    extension<T>(T)
    {
        public static void M(int i) { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M<object>");
        Assert.Equal("void E.<>E__0<System.Object>.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0<System.Object>.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_OptionalParameter()
    {
        var source = """
System.Action a = object.M;
System.Action a2 = E.M2;

static class E
{
    extension(object)
    {
        public static void M(int i = 0) => throw null;
    }

    public static void M2(int i = 0) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,26): error CS0123: No overload for 'M' matches delegate 'Action'
            // System.Action a = object.M;
            Diagnostic(ErrorCode.ERR_MethDelegateMismatch, "M").WithArguments("M", "System.Action").WithLocation(1, 26),
            // (2,22): error CS0123: No overload for 'M2' matches delegate 'Action'
            // System.Action a2 = E.M2;
            Diagnostic(ErrorCode.ERR_MethDelegateMismatch, "M2").WithArguments("M2", "System.Action").WithLocation(2, 22));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void E.<>E__0.M([System.Int32 i = 0])"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        source = """
static class E
{
    static void Main()
    {
        System.Action a2 = E.M2;
    }

    public static void M2(int i = 0) => throw null;
}
""";
        comp = CreateCompilation(source, parseOptions: TestOptions.Regular7);
        comp.VerifyEmitDiagnostics(
            // (5,30): error CS0123: No overload for 'M2' matches delegate 'Action'
            //         System.Action a2 = E.M2;
            Diagnostic(ErrorCode.ERR_MethDelegateMismatch, "M2").WithArguments("M2", "System.Action").WithLocation(5, 30));
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_ReturnRefKindMismatch()
    {
        var source = """
D d = object.M;

delegate int D();

static class E
{
    extension(object)
    {
        public static ref int M() => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,7): error CS8189: Ref mismatch between 'E.extension(object).M()' and delegate 'D'
            // D d = object.M;
            Diagnostic(ErrorCode.ERR_DelegateRefMismatch, "object.M").WithArguments("E.extension(object).M()", "D").WithLocation(1, 7));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal(["ref System.Int32 E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_ReturnTypeMismatch()
    {
        var source = """
D d = object.M;

delegate int D();

static class E
{
    extension(object)
    {
        public static string M() => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,7): error CS0407: 'string E.extension(object).M()' has the wrong return type
            // D d = object.M;
            Diagnostic(ErrorCode.ERR_BadRetType, "object.M").WithArguments("E.extension(object).M()", "string").WithLocation(1, 7));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal(["System.String E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_BadParameterConversion()
    {
        var source = """
D d = object.M;
D2 d2 = object.M2;

delegate void D(long l);
delegate void D2(int i);

static class E
{
    extension(object)
    {
        public static void M(int i) => throw null;
        public static void M2(long l) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS0123: No overload for 'M' matches delegate 'D'
            // D d = object.M;
            Diagnostic(ErrorCode.ERR_MethDelegateMismatch, "M").WithArguments("M", "D").WithLocation(1, 14),
            // (2,9): error CS0123: No overload for 'E.extension(object).M2(long)' matches delegate 'D2'
            // D2 d2 = object.M2;
            Diagnostic(ErrorCode.ERR_MethDelegateMismatch, "object.M2").WithArguments("E.extension(object).M2(long)", "D2").WithLocation(2, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal(["void E.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M2");
        Assert.Equal(["void E.<>E__0.M2(System.Int64 l)"], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Conditional()
    {
        var source = """
System.Action a = object.M;

static class E
{
    extension(object)
    {
        [System.Diagnostics.Conditional("DEBUG")]
        public static void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,19): error CS1618: Cannot create delegate with 'E.extension(object).M()' because it or a method it overrides has a Conditional attribute
            // System.Action a = object.M;
            Diagnostic(ErrorCode.ERR_DelegateOnConditional, "object.M").WithArguments("E.extension(object).M()").WithLocation(1, 19));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Partial()
    {
        var source = """
System.Action a = object.M;

static partial class E
{
    extension(object)
    {
        static partial void M();
    }
}
""";
        var comp = CreateCompilation(source);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : the error on the partial method seems misleading
        comp.VerifyEmitDiagnostics(
            // (1,26): error CS0117: 'object' does not contain a definition for 'M'
            // System.Action a = object.M;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("object", "M").WithLocation(1, 26),
            // (7,29): error CS0751: A partial member must be declared within a partial type
            //         static partial void M();
            Diagnostic(ErrorCode.ERR_PartialMemberOnlyInPartialClass, "M").WithLocation(7, 29));
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Pointer()
    {
        var source = """
D d = object.M;

unsafe delegate int* D();

unsafe static class E
{
    extension(object)
    {
        public static int* M() => throw null;
    }
}
""";
        var comp = CreateCompilation(source, options: TestOptions.UnsafeDebugExe);
        comp.VerifyEmitDiagnostics(
            // (1,7): error CS0214: Pointers and fixed size buffers may only be used in an unsafe context
            // D d = object.M;
            Diagnostic(ErrorCode.ERR_UnsafeNeeded, "object.M").WithLocation(1, 7));
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_RefReadonlyMismatch()
    {
        var source = """
D d = object.M;
D2 d2 = object.M2;

D d3 = E.M3;
D2 d4 = E.M4;

delegate void D(ref int i);
delegate void D2(ref readonly int i);

static class E
{
    extension(object)
    {
        public static void M(ref readonly int i) => throw null;
        public static void M2(ref int i) => throw null;
    }

    public static void M3(ref readonly int i) => throw null;
    public static void M4(ref int i) => throw null;
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,7): warning CS9198: Reference kind modifier of parameter 'ref readonly int i' doesn't match the corresponding parameter 'ref int i' in target.
            // D d = object.M;
            Diagnostic(ErrorCode.WRN_TargetDifferentRefness, "object.M").WithArguments("ref readonly int i", "ref int i").WithLocation(1, 7),
            // (2,16): error CS0123: No overload for 'M2' matches delegate 'D2'
            // D2 d2 = object.M2;
            Diagnostic(ErrorCode.ERR_MethDelegateMismatch, "M2").WithArguments("M2", "D2").WithLocation(2, 16),
            // (4,8): warning CS9198: Reference kind modifier of parameter 'ref readonly int i' doesn't match the corresponding parameter 'ref int i' in target.
            // D d3 = E.M3;
            Diagnostic(ErrorCode.WRN_TargetDifferentRefness, "E.M3").WithArguments("ref readonly int i", "ref int i").WithLocation(4, 8),
            // (5,11): error CS0123: No overload for 'M4' matches delegate 'D2'
            // D2 d4 = E.M4;
            Diagnostic(ErrorCode.ERR_MethDelegateMismatch, "M4").WithArguments("M4", "D2").WithLocation(5, 11));
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_Obsolete()
    {
        var source = """
System.Action a = object.M;

static class E
{
    extension(object)
    {
        [System.Obsolete("obsolete", true)]
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,19): error CS0619: 'E.extension(object).M()' is obsolete: 'obsolete'
            // System.Action a = object.M;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.M").WithArguments("E.extension(object).M()", "obsolete").WithLocation(1, 19));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_ReceiverTypeKind_01()
    {
        var source = """
System.Action a = object.M;
System.Action a2 = int.M;
a();
a2();

static class E
{
    extension(object)
    {
        public static void M() { System.Console.Write("ran "); }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_ReceiverTypeKind_02()
    {
        var source = """
System.Action a2 = int.M;
a2();

static class E
{
    extension(int)
    {
        public static void M() { System.Console.Write("ran"); }
    }
}
""";

        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();
    }

    [Fact]
    public void DelegateConversion_InstanceReceiver_ReceiverTypeKind()
    {
        var source = """
object o = null;
int i = 0;

System.Action a = o.M;
System.Action a2 = i.M;

static class E
{
    extension(object o)
    {
        public void M() => throw null;
    }

    extension(int i)
    {
        public void M() => throw null;
    }
}
""";

        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (5,20): error CS1113: Extension method 'E.extension(int).M()' defined on value type 'int' cannot be used to create delegates
            // System.Action a2 = i.M;
            Diagnostic(ErrorCode.ERR_ValueTypeExtDelegate, "i.M").WithArguments("E.extension(int).M()", "int").WithLocation(5, 20));
    }

    [Fact]
    public void DelegateConversion_InstanceReceiver_RefStructReceiver()
    {
        var source = """
System.Span<int> s = default;

System.Action a = s.M;

static class E
{
    extension(object o)
    {
        public void M() => throw null;
    }
}
""";

        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net90);
        comp.VerifyEmitDiagnostics(
            // (3,21): error CS1061: 'Span<int>' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'Span<int>' could be found (are you missing a using directive or an assembly reference?)
            // System.Action a = s.M;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("System.Span<int>", "M").WithLocation(3, 21));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "s.M");
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void DelegateConversion_TypeReceiver_RefStructReceiver()
    {
        var source = """
System.Action a = System.Span<int>.M;

static class E
{
    extension(object)
    {
        public static void M() => throw null;
    }
}
""";

        // Note: we apply the same conversion requirements even though no conversion on the receiver
        //   is needed in a static scenario. 
        var comp = CreateCompilation(source, targetFramework: TargetFramework.Net90);
        comp.VerifyEmitDiagnostics(
            // (1,36): error CS0117: 'Span<int>' does not contain a definition for 'M'
            // System.Action a = System.Span<int>.M;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M").WithArguments("System.Span<int>", "M").WithLocation(1, 36));
    }

    [Fact]
    public void InstancePropertyAccess_Obsolete()
    {
        var src = """
_ = new object().Property;
new object().Property = 43;

static class E
{
    extension(object o)
    {
        [System.Obsolete("Property is obsolete", true)]
        public int Property { get => 42; set { } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0619: 'E.extension(object).Property' is obsolete: 'Property is obsolete'
            // _ = new object().Property;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Property").WithArguments("E.extension(object).Property", "Property is obsolete").WithLocation(1, 5),
            // (2,1): error CS0619: 'E.extension(object).Property' is obsolete: 'Property is obsolete'
            // new object().Property = 43;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Property").WithArguments("E.extension(object).Property", "Property is obsolete").WithLocation(2, 1));
    }

    [Fact]
    public void StaticPropertyAccess_Obsolete()
    {
        var src = """
_ = object.Property;
object.Property = 43;

static class E
{
    extension(object)
    {
        [System.Obsolete("Property is obsolete", true)]
        public static int Property { get => 42; set { } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0619: 'E.extension(object).Property' is obsolete: 'Property is obsolete'
            // _ = object.Property;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Property").WithArguments("E.extension(object).Property", "Property is obsolete").WithLocation(1, 5),
            // (2,1): error CS0619: 'E.extension(object).Property' is obsolete: 'Property is obsolete'
            // object.Property = 43;
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "object.Property").WithArguments("E.extension(object).Property", "Property is obsolete").WithLocation(2, 1));
    }

    [Fact]
    public void InstancePropertyAccess_Obsolete_InInvocation()
    {
        var src = """
new object().Property();

static class E
{
    extension(object o)
    {
        [System.Obsolete("Property is obsolete", true)]
        public System.Action Property { get => throw null; set { } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0619: 'E.extension(object).Property' is obsolete: 'Property is obsolete'
            // new object().Property();
            Diagnostic(ErrorCode.ERR_DeprecatedSymbolStr, "new object().Property").WithArguments("E.extension(object).Property", "Property is obsolete").WithLocation(1, 1));
    }

    [Fact]
    public void InstancePropertyAccess_ColorColor()
    {
        var src = """
C.M(new C());

class C
{
    public static void M(C C)
    {
        C.Property = 42;
    }
}

static class E
{
    extension(C c)
    {
        public int Property { set { System.Console.Write(value); } }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property");
        Assert.Equal("System.Int32 E.<>E__0.Property { set; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property)); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : handle GetMemberGroup on a property access
    }

    [Fact]
    public void StaticPropertyAccess_ColorColor()
    {
        var src = """
C.M(null);

class C
{
    public static void M(C C)
    {
        C.Property = 42;
    }
}

static class E
{
    extension(C c)
    {
        public static int Property { set { System.Console.Write("Property"); } }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Property").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property");
        Assert.Equal("System.Int32 E.<>E__0.Property { set; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(property)); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : handle GetMemberGroup on a property access
    }

    [Fact]
    public void ConditionalReceiver_Property_MemberAccess()
    {
        var src = """
bool b = true;
System.Console.Write((b ? "" : null).Property.ToString());

static class E
{
    extension(string s)
    {
        public int Property => 42;
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, """(b ? "" : null).Property""");
        Assert.Equal("System.Int32 E.<>E__0.Property { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void PropertyAccess_ReturnNotLValue()
    {
        var src = """
object.Property.field = 1;

public struct S
{
    public int field;
}
static class E
{
    extension(object)
    {
        public static S Property { get => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS1612: Cannot modify the return value of 'E.extension(object).Property' because it is not a variable
            // object.Property.field = 1;
            Diagnostic(ErrorCode.ERR_ReturnNotLValue, "object.Property").WithArguments("E.extension(object).Property").WithLocation(1, 1));
    }

    [Fact]
    public void StaticPropertyAccess_RefProperty_01()
    {
        var src = """
localFuncRef(ref object.Property);
localFuncOut(out object.Property);

void localFuncRef(ref int i) => throw null;
void localFuncOut(out int i) => throw null;

static class E
{
    extension(object)
    {
        public static int Property { get => throw null; set => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,18): error CS0206: A non ref-returning property or indexer may not be used as an out or ref value
            // localFuncRef(ref object.Property);
            Diagnostic(ErrorCode.ERR_RefProperty, "object.Property").WithLocation(1, 18),
            // (2,18): error CS0206: A non ref-returning property or indexer may not be used as an out or ref value
            // localFuncOut(out object.Property);
            Diagnostic(ErrorCode.ERR_RefProperty, "object.Property").WithLocation(2, 18));
    }

    [Fact]
    public void StaticPropertyAccess_RefProperty_02()
    {
        var src = """
localFuncRef(ref object.Property);

void localFuncRef(ref int i) => throw null;

static class E
{
    extension(object)
    {
        public static ref int Property { get => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
    }

    [Fact]
    public void StaticPropertyAccess_AssignReadonlyNotField()
    {
        var src = """
object.Property = 1;

static class E
{
    extension(object)
    {
        public static ref readonly int Property { get => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS8331: Cannot assign to property 'Property' or use it as the right hand side of a ref assignment because it is a readonly variable
            // object.Property = 1;
            Diagnostic(ErrorCode.ERR_AssignReadonlyNotField, "object.Property").WithArguments("property", "Property").WithLocation(1, 1));
    }

    [Fact]
    public void StaticPropertyAccess_AssgReadonlyProp()
    {
        var src = """
object.Property = 1;

static class E
{
    extension(object)
    {
        public static int Property { get => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0200: Property or indexer 'E.extension(object).Property' cannot be assigned to -- it is read only
            // object.Property = 1;
            Diagnostic(ErrorCode.ERR_AssgReadonlyProp, "object.Property").WithArguments("E.extension(object).Property").WithLocation(1, 1));
    }

    [Fact]
    public void StaticPropertyAccess_InitOnlyProperty()
    {
        var src = """
object.Property = 1;

static class E
{
    extension(object)
    {
        public static int Property { init => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (7,38): error CS8856: The 'init' accessor is not valid on static members
            //         public static int Property { init => throw null; }
            Diagnostic(ErrorCode.ERR_BadInitAccessor, "init").WithLocation(7, 38));
    }

    [Fact]
    public void InstancePropertyAccess_InitOnlyProperty()
    {
        var src = """
new object().Property = 1;

static class E
{
    extension(object o)
    {
        public int Property { init => throw null; }
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 :(instance) confirm whether init-only accessors should be allowed in extensions
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS8852: Init-only property or indexer 'E.extension(object).Property' can only be assigned in an object initializer, or on 'this' or 'base' in an instance constructor or an 'init' accessor.
            // new object().Property = 1;
            Diagnostic(ErrorCode.ERR_AssignmentInitOnly, "new object().Property").WithArguments("E.extension(object).Property").WithLocation(1, 1));
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
    public void InstancePropertyAccess_InitOnlyProperty_ObjectInitializer()
    {
        var src = """
_ = new object() { Property = 1 };

static class E
{
    extension(object o)
    {
        public int Property { init => throw null; }
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm whether init-only accessors should be allowed in extensions
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var assignment = GetSyntax<AssignmentExpressionSyntax>(tree, "Property = 1");
        Assert.Equal("System.Int32 E.<>E__0.Property { init; }", model.GetSymbolInfo(assignment.Left).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void StaticPropertyAccess_InaccessibleSetter()
    {
        var src = """
object.Property = 1;

static class E
{
    extension(object)
    {
        public static int Property { get => throw null; private set => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0272: The property or indexer 'E.extension(object).Property' cannot be used in this context because the set accessor is inaccessible
            // object.Property = 1;
            Diagnostic(ErrorCode.ERR_InaccessibleSetter, "object.Property").WithArguments("E.extension(object).Property").WithLocation(1, 1));
    }

    [Fact]
    public void ParameterCapturing_023_ColorColor_MemberAccess_InstanceAndStatic_ExtensionTypeMethods()
    {
        // See ParameterCapturing_023_ColorColor_MemberAccess_InstanceAndStatic_Method
        var source = """
struct S1(Color Color)
{
    public void Test()
    {
        Color.M1(this);
    }
}

class Color { }

static class E
{
    extension(Color c)
    {
        public void M1(S1 x, int y = 0)
        {
            System.Console.WriteLine("instance");
        }

        public static void M1<T>(T x) where T : unmanaged
        {
            System.Console.WriteLine("static");
        }
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : missing ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver
        var comp = CreateCompilation(source, options: TestOptions.ReleaseDll);
        comp.VerifyEmitDiagnostics(
            //// (5,9): error CS9106: Identifier 'Color' is ambiguous between type 'Color' and parameter 'Color Color' in this context.
            ////         Color.M1(this);
            //Diagnostic(ErrorCode.ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver, "Color").WithArguments("Color", "Color", "Color Color").WithLocation(5, 9)
            );

        Assert.NotEmpty(comp.GetTypeByMetadataName("S1").InstanceConstructors.OfType<SynthesizedPrimaryConstructor>().Single().GetCapturedParameters());

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.M1");
        Assert.Equal("void E.<>E__0.M1(S1 x, [System.Int32 y = 0])", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ParameterCapturing_023_ColorColor_MemberAccess_InstanceAndStatic_ExtensionTypeProperties()
    {
        var source = """
struct S1(Color Color)
{
    public void Test()
    {
        _ = Color.P1;
    }
}

class Color { }

static class E1
{
    extension(Color c)
    {
        public int P1 => 0;
    }
}

static class E2
{
    extension(Color)
    {
        public static int P1 => 0;
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : missing ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver
        var comp = CreateCompilation(source, options: TestOptions.ReleaseDll);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.P1");
        Assert.Equal("System.Int32 E1.<>E__0.P1 { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ParameterCapturing_023_ColorColor_MemberAccess_InstanceAndStatic_ExtensionTypeMembersVsExtensionMethod()
    {
        var source = """
public struct S1(Color Color)
{
    public void Test()
    {
        Color.M1(this);
    }
}

public class Color { }

public static class E1
{
    public static void M1(this Color c, S1 x, int y = 0)
    {
        System.Console.WriteLine("instance");
    }
}

static class E
{
    extension(Color)
    {
        public static void M1<T>(T x) where T : unmanaged
        {
            System.Console.WriteLine("static");
        }
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : missing ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver
        var comp = CreateCompilation(source, options: TestOptions.ReleaseDll);
        comp.VerifyEmitDiagnostics(
            //// (5,9): error CS9106: Identifier 'Color' is ambiguous between type 'Color' and parameter 'Color Color' in this context.
            ////         Color.M1(this);
            //Diagnostic(ErrorCode.ERR_AmbiguousPrimaryConstructorParameterAsColorColorReceiver, "Color").WithArguments("Color", "Color", "Color Color").WithLocation(5, 9)
            );

        Assert.NotEmpty(comp.GetTypeByMetadataName("S1").InstanceConstructors.OfType<SynthesizedPrimaryConstructor>().Single().GetCapturedParameters());

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.M1");
        Assert.Equal("void Color.M1(S1 x, [System.Int32 y = 0])", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void InstanceMethod_MemberAccess()
    {
        var src = """
new object().M.ToString();

static class E
{
    extension(object o)
    {
        public int M() => 42;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS0119: 'E.extension(object).M()' is a method, which is not valid in the given context
            // new object().M.ToString();
            Diagnostic(ErrorCode.ERR_BadSKunknown, "M").WithArguments("E.extension(object).M()", "method").WithLocation(1, 14));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        src = """
new object().M.ToString();

static class E
{
    public static int M(this object o) => 42;
}
""";
        comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS0119: 'E.M(object)' is a method, which is not valid in the given context
            // new object().M.ToString();
            Diagnostic(ErrorCode.ERR_BadSKunknown, "M").WithArguments("E.M(object)", "method").WithLocation(1, 14));

        tree = comp.SyntaxTrees.Single();
        model = comp.GetSemanticModel(tree);
        memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void InstanceMethod_MemberAccess_Missing()
    {
        var src = """
new object().M.ToString();
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,14): error CS1061: 'object' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // new object().M.ToString();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("object", "M").WithLocation(1, 14));
    }

    [Fact]
    public void CheckValueKind_AssignToMethodGroup()
    {
        var src = """
object.M = null;

static class E
{
    extension(object)
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS1656: Cannot assign to 'M' because it is a 'method group'
            // object.M = null;
            Diagnostic(ErrorCode.ERR_AssgReadonlyLocalCause, "object.M").WithArguments("M", "method group").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void E.<>E__0.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Equal(["void E.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void AccessOnVoid_Invocation()
    {
        var src = """
object.M().ToString();

static class E
{
    extension(object)
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,11): error CS0023: Operator '.' cannot be applied to operand of type 'void'
            // object.M().ToString();
            Diagnostic(ErrorCode.ERR_BadUnaryOp, ".").WithArguments(".", "void").WithLocation(1, 11));
    }

    [Fact]
    public void ExtensionMemberLookup_InaccessibleMembers()
    {
        var src = """
object.Method();
_ = object.Property;

static class E
{
    extension(object o)
    {
        private static void Method() => throw null;
        private static int Property => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'Method'
            // object.Method();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Method").WithArguments("object", "Method").WithLocation(1, 8),
            // (2,12): error CS0117: 'object' does not contain a definition for 'Property'
            // _ = object.Property;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Property").WithArguments("object", "Property").WithLocation(2, 12));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Method");
        Assert.Equal(["void E.<>E__0.Method()"], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Equal([], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings()); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : handle GetMemberGroup on a property access
    }

    [Fact]
    public void ExtensionMemberLookup_InterpolationHandler_Simple()
    {
        var src = """
_ = f($"{(object)1} {f2()}");

static int f(InterpolationHandler s) => 0;
static string f2() => "hello";

[System.Runtime.CompilerServices.InterpolatedStringHandler]
public struct InterpolationHandler
{
    public InterpolationHandler(int literalLength, int formattedCount) => throw null;
    public void AppendLiteral(string value) { }
    public void AppendFormatted<T>(T hole, int alignment = 0, string format = null) => throw null;
}
""";

        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ExtensionMemberLookup_InterpolationHandler_AppendLiteralExtensionMethod()
    {
        var src = """
_ = f($"{(object)1} {f2()}");

static int f(InterpolationHandler s) => 0;
static string f2() => "hello";

[System.Runtime.CompilerServices.InterpolatedStringHandler]
public struct InterpolationHandler
{
    public InterpolationHandler(int literalLength, int formattedCount) => throw null;
    public void AppendFormatted<T>(T hole, int alignment = 0, string format = null) => throw null;
}

public static class Extensions
{
    public static void AppendLiteral(this InterpolationHandler ih, string value) { }
}
""";

        // Interpolation handlers don't allow extension methods
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (1,20): error CS1061: 'InterpolationHandler' does not contain a definition for 'AppendLiteral' and no accessible extension method 'AppendLiteral' accepting a first argument of type 'InterpolationHandler' could be found (are you missing a using directive or an assembly reference?)
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, " ").WithArguments("InterpolationHandler", "AppendLiteral").WithLocation(1, 20),
            // (1,20): error CS8941: Interpolated string handler method '?.()' is malformed. It does not return 'void' or 'bool'.
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_InterpolatedStringHandlerMethodReturnMalformed, " ").WithArguments("?.()").WithLocation(1, 20));
    }

    [Fact]
    public void ExtensionMemberLookup_InterpolationHandler_AppendLiteralExtensionDeclarationMethod()
    {
        var src = """
_ = f($"{(object)1} {f2()}");

static int f(InterpolationHandler s) => 0;
static string f2() => "hello";

[System.Runtime.CompilerServices.InterpolatedStringHandler]
public struct InterpolationHandler
{
    public InterpolationHandler(int literalLength, int formattedCount) => throw null;
    public void AppendFormatted<T>(T hole, int alignment = 0, string format = null) => throw null;
}

static class E
{
    extension(InterpolationHandler i)
    {
        public void AppendLiteral(string value) { }
    }
}
""";

        // Interpolation handlers don't allow extension methods
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (1,20): error CS1061: 'InterpolationHandler' does not contain a definition for 'AppendLiteral' and no accessible extension method 'AppendLiteral' accepting a first argument of type 'InterpolationHandler' could be found (are you missing a using directive or an assembly reference?)
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, " ").WithArguments("InterpolationHandler", "AppendLiteral").WithLocation(1, 20),
            // (1,20): error CS8941: Interpolated string handler method '?.()' is malformed. It does not return 'void' or 'bool'.
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_InterpolatedStringHandlerMethodReturnMalformed, " ").WithArguments("?.()").WithLocation(1, 20));
    }

    [Fact]
    public void ExtensionMemberLookup_InterpolationHandler_AppendFormattedExtensionMethod()
    {
        var src = """
/*<bind>*/
_ = f($"{(object)1} {f2()}");
/*</bind>*/

static int f(InterpolationHandler s) => 0;
static string f2() => "hello";

[System.Runtime.CompilerServices.InterpolatedStringHandler]
public struct InterpolationHandler
{
    public InterpolationHandler(int literalLength, int formattedCount) => throw null;
    public void AppendLiteral(string value) { }
}

public static class Extensions
{
    public static void AppendFormatted<T>(this InterpolationHandler ih, T hole, int alignment = 0, string format = null) { }
}
""";

        // Interpolation handlers don't allow extension methods
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (2,9): error CS1061: 'InterpolationHandler' does not contain a definition for 'AppendFormatted' and no accessible extension method 'AppendFormatted' accepting a first argument of type 'InterpolationHandler' could be found (are you missing a using directive or an assembly reference?)
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "{(object)1}").WithArguments("InterpolationHandler", "AppendFormatted").WithLocation(2, 9),
            // (2,9): error CS8941: Interpolated string handler method '?.()' is malformed. It does not return 'void' or 'bool'.
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_InterpolatedStringHandlerMethodReturnMalformed, "{(object)1}").WithArguments("?.()").WithLocation(2, 9),
            // (2,21): error CS1061: 'InterpolationHandler' does not contain a definition for 'AppendFormatted' and no accessible extension method 'AppendFormatted' accepting a first argument of type 'InterpolationHandler' could be found (are you missing a using directive or an assembly reference?)
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "{f2()}").WithArguments("InterpolationHandler", "AppendFormatted").WithLocation(2, 21),
            // (2,21): error CS8941: Interpolated string handler method '?.()' is malformed. It does not return 'void' or 'bool'.
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_InterpolatedStringHandlerMethodReturnMalformed, "{f2()}").WithArguments("?.()").WithLocation(2, 21)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_InterpolationHandler_AppendFormattedExtensionTypeMethod()
    {
        var src = """
_ = f($"{(object)1} {f2()}");

static int f(InterpolationHandler s) => 0;
static string f2() => "hello";

[System.Runtime.CompilerServices.InterpolatedStringHandler]
public struct InterpolationHandler
{
    public InterpolationHandler(int literalLength, int formattedCount) => throw null;
    public void AppendLiteral(string value) { }
}

static class E
{
    extension(InterpolationHandler i)
    {
        public void AppendFormatted<T>(T hole, int alignment = 0, string format = null) { }
    }
}
""";

        // Interpolation handlers don't allow extension methods
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS1061: 'InterpolationHandler' does not contain a definition for 'AppendFormatted' and no accessible extension method 'AppendFormatted' accepting a first argument of type 'InterpolationHandler' could be found (are you missing a using directive or an assembly reference?)
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "{(object)1}").WithArguments("InterpolationHandler", "AppendFormatted").WithLocation(1, 9),
            // (1,9): error CS8941: Interpolated string handler method '?.()' is malformed. It does not return 'void' or 'bool'.
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_InterpolatedStringHandlerMethodReturnMalformed, "{(object)1}").WithArguments("?.()").WithLocation(1, 9),
            // (1,21): error CS1061: 'InterpolationHandler' does not contain a definition for 'AppendFormatted' and no accessible extension method 'AppendFormatted' accepting a first argument of type 'InterpolationHandler' could be found (are you missing a using directive or an assembly reference?)
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "{f2()}").WithArguments("InterpolationHandler", "AppendFormatted").WithLocation(1, 21),
            // (1,21): error CS8941: Interpolated string handler method '?.()' is malformed. It does not return 'void' or 'bool'.
            // _ = f($"{(object)1} {f2()}");
            Diagnostic(ErrorCode.ERR_InterpolatedStringHandlerMethodReturnMalformed, "{f2()}").WithArguments("?.()").WithLocation(1, 21));
    }

    [Fact]
    public void LiteralReceiver_Property_Enum_Set()
    {
        var src = """
Enum.Zero.Property = 1;

enum Enum
{
    Zero
}

static class E
{
    extension(Enum e)
    {
        public int Property { set => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        // Consider improving the error message
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
            // Enum.Zero.Property = 1;
            Diagnostic(ErrorCode.ERR_AssgLvalueExpected, "Enum.Zero.Property").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Enum.Zero.Property");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 E.<>E__0.Property { set; }"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : handle GetMemberGroup on a property access
    }

    [Fact]
    public void LiteralReceiver_Property_Integer_ForLong()
    {
        var src = """
1.Property = 42;
_ = 2.Property;

static class E
{
    extension(long l)
    {
        public int Property { get { System.Console.Write("get "); return 42; } set { System.Console.Write("set "); }  }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS9286: 'int' does not contain a definition for 'Property' and no accessible extension member 'Property' for receiver of type 'int' could be found (are you missing a using directive or an assembly reference?)
            // 1.Property = 42;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "1.Property").WithArguments("int", "Property").WithLocation(1, 1),
            // (2,5): error CS9286: 'int' does not contain a definition for 'Property' and no accessible extension member 'Property' for receiver of type 'int' could be found (are you missing a using directive or an assembly reference?)
            // _ = 2.Property;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "2.Property").WithArguments("int", "Property").WithLocation(2, 5));

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : review the behavior of the semantic model APIs
        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "1.Property");
        Assert.Equal("System.Int32 E.<>E__0.Property { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess1).CandidateReason);

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "2.Property");
        Assert.Equal("System.Int32 E.<>E__0.Property { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess2).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Property_String()
    {
        var src = """
"".Property = 42;
_ = "".Property;

static class E
{
    extension(string s)
    {
        public int Property { get { System.Console.Write("get "); return 42; } set { System.Console.Write("set "); }  }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "set get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "\"\".Property").First();
        Assert.Equal("System.Int32 E.<>E__0.Property { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "\"\".Property").Last();
        Assert.Equal("System.Int32 E.<>E__0.Property { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void SwitchReceiver_Property_String()
    {
        var src = """
bool b = true;
(b switch { true => "", _ => "" }).Property = 42;
_ = (b switch { true => "", _ => "" }).Property;

static class E
{
    extension(string s)
    {
        public int Property { get { System.Console.Write("get "); return 42; } set { System.Console.Write("set "); }  }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "set get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, """(b switch { true => "", _ => "" }).Property""").First();
        Assert.Equal("System.Int32 E.<>E__0.Property { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, """(b switch { true => "", _ => "" }).Property""").Last();
        Assert.Equal("System.Int32 E.<>E__0.Property { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ConditionalReceiver_Property_String()
    {
        var src = """
bool b = true;
(b ? "" : null).Property = 42;
_ = (b ? "" : null).Property;

static class E
{
    extension(string s)
    {
        public int Property { get { System.Console.Write("get "); return 42; } set { System.Console.Write("set "); }  }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "set get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, """(b ? "" : null).Property""").First();
        Assert.Equal("System.Int32 E.<>E__0.Property { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, """(b ? "" : null).Property""").Last();
        Assert.Equal("System.Int32 E.<>E__0.Property { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void LiteralReceiver_Property_Integer_Get()
    {
        var src = """
_ = 1.Property;

static class E
{
    extension(int i)
    {
        public int Property { get { System.Console.Write("get"); return 42; } }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "1.Property");
        Assert.Equal("System.Int32 E.<>E__0.Property { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void LiteralReceiver_Property_Integer_Set()
    {
        var src = """
1.Property = 1;

static class E
{
    extension(int i)
    {
        public int Property { set => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        // Consider improving the error message
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
            // 1.Property = 1;
            Diagnostic(ErrorCode.ERR_AssgLvalueExpected, "1.Property").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "1.Property");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 E.<>E__0.Property { set; }"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Property_Null()
    {
        var src = """
null.Property = 1;
_ = null.Property;

static class E
{
    extension(object o)
    {
        public int Property { get => throw null; set => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0023: Operator '.' cannot be applied to operand of type '<null>'
            // null.Property = 1;
            Diagnostic(ErrorCode.ERR_BadUnaryOp, "null.Property").WithArguments(".", "<null>").WithLocation(1, 1),
            // (2,5): error CS0023: Operator '.' cannot be applied to operand of type '<null>'
            // _ = null.Property;
            Diagnostic(ErrorCode.ERR_BadUnaryOp, "null.Property").WithArguments(".", "<null>").WithLocation(2, 5));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "null.Property").First();
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess1).CandidateReason);

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "null.Property").Last();
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess2).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Property_Default()
    {
        var src = """
default.Property = 1;
_ = default.Property;

static class E
{
    extension(object o)
    {
        public int Property { get => throw null; set => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS8716: There is no target type for the default literal.
            // default.Property = 1;
            Diagnostic(ErrorCode.ERR_DefaultLiteralNoTargetType, "default").WithLocation(1, 1),
            // (2,5): error CS8716: There is no target type for the default literal.
            // _ = default.Property;
            Diagnostic(ErrorCode.ERR_DefaultLiteralNoTargetType, "default").WithLocation(2, 5));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "default.Property").First();
        Assert.Equal("System.Int32 E.<>E__0.Property { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess1).CandidateReason);

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "default.Property").Last();
        Assert.Equal("System.Int32 E.<>E__0.Property { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess2).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Property_Tuple_Get()
    {
        var src = """
_ = (1, 2).Property;

static class E
{
    extension((int, int) t)
    {
        public int Property { get { System.Console.Write("get "); return 42; } }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "get").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "(1, 2).Property");
        Assert.Equal("System.Int32 E.<>E__0.Property { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void LiteralReceiver_Property_Tuple_Set()
    {
        var src = """
(1, 2).Property = 1;

static class E
{
    extension((int, int) t)
    {
        public int Property { set { System.Console.Write($"set(value)"); }}
    }
}
""";
        var comp = CreateCompilation(src);
        // Consider improving the error message
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0131: The left-hand side of an assignment must be a variable, property or indexer
            // (1, 2).Property = 1;
            Diagnostic(ErrorCode.ERR_AssgLvalueExpected, "(1, 2).Property").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "(1, 2).Property");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 E.<>E__0.Property { set; }"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.NotAVariable, model.GetSymbolInfo(memberAccess).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Property_Tuple_Default()
    {
        var src = """
(default, default).Property = 1;
_ = (default, default).Property;

static class E
{
    extension((object, object) t)
    {
        public int Property { get => throw null; set => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,2): error CS8716: There is no target type for the default literal.
            // (default, default).Property = 1;
            Diagnostic(ErrorCode.ERR_DefaultLiteralNoTargetType, "default").WithLocation(1, 2),
            // (1,11): error CS8716: There is no target type for the default literal.
            // (default, default).Property = 1;
            Diagnostic(ErrorCode.ERR_DefaultLiteralNoTargetType, "default").WithLocation(1, 11),
            // (2,6): error CS8716: There is no target type for the default literal.
            // _ = (default, default).Property;
            Diagnostic(ErrorCode.ERR_DefaultLiteralNoTargetType, "default").WithLocation(2, 6),
            // (2,15): error CS8716: There is no target type for the default literal.
            // _ = (default, default).Property;
            Diagnostic(ErrorCode.ERR_DefaultLiteralNoTargetType, "default").WithLocation(2, 15));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "(default, default).Property").First();
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess1).CandidateReason);

        var memberAccess2 = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "(default, default).Property").Last();
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess2).CandidateReason);
    }

    [Fact]
    public void LiteralReceiver_Property_Tuple_Integer_ForLong()
    {
        var src = """
(1, 1).Property = 1;
_ = (2, 2).Property;

static class E
{
    extension((long, long) t)
    {
        public int Property { get => throw null; set => throw null; }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS9286: '(int, int)' does not contain a definition for 'Property' and no accessible extension member 'Property' for receiver of type '(int, int)' could be found (are you missing a using directive or an assembly reference?)
            // (1, 1).Property = 1;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "(1, 1).Property").WithArguments("(int, int)", "Property").WithLocation(1, 1),
            // (2,5): error CS9286: '(int, int)' does not contain a definition for 'Property' and no accessible extension member 'Property' for receiver of type '(int, int)' could be found (are you missing a using directive or an assembly reference?)
            // _ = (2, 2).Property;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "(2, 2).Property").WithArguments("(int, int)", "Property").WithLocation(2, 5));

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : review the behavior of the semantic model APIs
        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "(1, 1).Property");
        Assert.Equal("System.Int32 E.<>E__0.Property { get; set; }", model.GetSymbolInfo(memberAccess1).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess1).CandidateReason);

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "(2, 2).Property");
        Assert.Equal("System.Int32 E.<>E__0.Property { get; set; }", model.GetSymbolInfo(memberAccess2).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(CandidateReason.None, model.GetSymbolInfo(memberAccess2).CandidateReason);
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndProperty()
    {
        var src = """
System.Console.Write(object.M);

static class E1
{
    extension(object)
    {
        public static string M() => throw null;
    }
}

static class E2
{
    extension(object)
    {
        public static string M => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,22): error CS9286: 'object' does not contain a definition for 'M' and no accessible extension member 'M' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // System.Console.Write(object.M);
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "object.M").WithArguments("object", "M").WithLocation(1, 22));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E1.<>E__0.M()", "System.String E2.<>E__0.M { get; }"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess)); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : consider handling BoundBadExpression better
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndProperty_Generic()
    {
        var src = """
System.Console.Write(object.M);

static class E1
{
    extension<T>(T)
    {
        public static string M() => throw null;
    }
}

static class E2
{
    extension<T>(T)
    {
        public static string M => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,22): error CS9286: 'object' does not contain a definition for 'M' and no accessible extension member 'M' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // System.Console.Write(object.M);
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "object.M").WithArguments("object", "M").WithLocation(1, 22));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : consider handling BoundBadExpression better
        Assert.Equal(["System.String E1.<>E__0<T>.M()", "System.String E2.<>E__0<T>.M { get; }"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void PreferMoreSpecific_Static_MethodAndProperty_Invocation()
    {
        var src = """
System.Console.Write(object.M());

static class E1
{
    extension(object)
    {
        public static string M() => "ran";
    }
}

static class E2
{
    extension(object)
    {
        public static string M => throw null; // not invocable
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("System.String E1.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["System.String E1.<>E__0.M()", "System.String E2.<>E__0.M { get; }"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void GetCompatibleExtensions_TwoSubstitutions()
    {
        var src = """
C.M();
new C().M2();

interface I<T> { }
class C : I<int>, I<string> { }

static class E
{
    extension<T>(I<T>)
    {
        public static void M() { }
    }

    public static void M2<T>(this I<T> i) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,3): error CS1061: 'C' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            // C.M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("C", "M").WithLocation(1, 3),
            // (2,9): error CS1061: 'C' does not contain a definition for 'M2' and no accessible extension method 'M2' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            // new C().M2();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M2").WithArguments("C", "M2").WithLocation(2, 9));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess1).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess1).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess1));

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "new C().M2");
        Assert.Null(model.GetSymbolInfo(memberAccess2).Symbol);
        Assert.Equal([], model.GetSymbolInfo(memberAccess2).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess2));
    }

    [Theory, ClassData(typeof(ThreePermutationGenerator))]
    public void PreferMoreSpecific_Static_MethodAndMoreSpecificInvocablePropertyAndMoreSpecificMethod(int first, int second, int third)
    {
        string[] segments = [
            """
            static class E1
            {
                extension(object)
                {
                    public static string M() => throw null;
                }
            }
            """,
            """
            static class E2
            {
                extension(C)
                {
                    public static System.Func<string> M => null;
                }
            }
            """,
            """
            static class E3
            {
                extension(C)
                {
                    public static string M() => throw null;
                }
            }
            """];

        var src = $$"""
System.Console.Write(C.M());

class C { }

{{segments[first]}}

{{segments[second]}}

{{segments[third]}}
""";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics(
            // (1,22): error CS9286: 'C' does not contain a definition for 'M' and no accessible extension member 'M' for receiver of type 'C' could be found (are you missing a using directive or an assembly reference?)
            // System.Console.Write(C.M());
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "C.M").WithArguments("C", "M").WithLocation(1, 22));
    }

    [Fact]
    public void AmbiguousCallOnInterface()
    {
        var src = """
I2.M();

interface I<T>
{
    public static void M() { }
}

interface I2 : I<int>, I<string> { }
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : consider improving the symbols in this error message
        comp.VerifyEmitDiagnostics(
            // (1,4): error CS0121: The call is ambiguous between the following methods or properties: 'I<T>.M()' and 'I<T>.M()'
            // I2.M();
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("I<T>.M()", "I<T>.M()").WithLocation(1, 4));
    }

    [Fact]
    public void AmbiguousCallOnInterface_Generic()
    {
        var src = """
I2.M<int>();

interface I<T>
{
    public static void M<U>() { }
}

interface I2 : I<int>, I<string> { }
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (1,4): error CS0121: The call is ambiguous between the following methods or properties: 'I<T>.M<U>()' and 'I<T>.M<U>()'
            // I2.M<int>();
            Diagnostic(ErrorCode.ERR_AmbigCall, "M<int>").WithArguments("I<T>.M<U>()", "I<T>.M<U>()").WithLocation(1, 4));
    }

    [Fact]
    public void OmittedTypeArguments()
    {
        var src = """
object.P<int>;
object.P<>;

static class E
{
    extension(object)
    {
        public static int P => 42;
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
            // object.P<int>;
            Diagnostic(ErrorCode.ERR_IllegalStatement, "object.P<int>").WithLocation(1, 1),
            // (1,8): error CS0117: 'object' does not contain a definition for 'P'
            // object.P<int>;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "P<int>").WithArguments("object", "P").WithLocation(1, 8),
            // (2,1): error CS8389: Omitting the type argument is not allowed in the current context
            // object.P<>;
            Diagnostic(ErrorCode.ERR_OmittedTypeArgument, "object.P<>").WithLocation(2, 1),
            // (2,1): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
            // object.P<>;
            Diagnostic(ErrorCode.ERR_IllegalStatement, "object.P<>").WithLocation(2, 1),
            // (2,8): error CS0117: 'object' does not contain a definition for 'P'
            // object.P<>;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "P<>").WithArguments("object", "P").WithLocation(2, 8));
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_ForEach_NoMethod()
    {
        var src = """
foreach (var x in new C())
{
    System.Console.Write(x);
    break;
}

class C { }
class D { }

static class E
{
    extension(C c)
    {
        public D GetEnumerator() => new D();
    }
    extension(D d)
    {
        public bool MoveNext() => true;
        public int Current => 42;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,19): error CS0117: 'D' does not contain a definition for 'Current'
            // foreach (var x in new C())
            Diagnostic(ErrorCode.ERR_NoSuchMember, "new C()").WithArguments("D", "Current").WithLocation(1, 19),
            // (1,19): error CS0202: foreach requires that the return type 'D' of 'E.extension(C).GetEnumerator()' must have a suitable public 'MoveNext' method and public 'Current' property
            // foreach (var x in new C())
            Diagnostic(ErrorCode.ERR_BadGetEnumerator, "new C()").WithArguments("D", "E.extension(C).GetEnumerator()").WithLocation(1, 19)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var loop = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().Single();
        Assert.Null(model.GetForEachStatementInfo(loop).GetEnumeratorMethod);
        Assert.Null(model.GetForEachStatementInfo(loop).MoveNextMethod);
        Assert.Null(model.GetForEachStatementInfo(loop).CurrentProperty);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_ForEach_NoApplicableMethod()
    {
        var src = """
foreach (var x in new C())
{
    System.Console.Write(x);
    break;
}

class C
{
    public void GetEnumerator(int notApplicable) { } // not applicable
}
class D { }

static class E
{
    extension(C c)
    {
        public D GetEnumerator() => new D();
    }
    extension(D d)
    {
        public bool MoveNext() => true;
        public int Current => 42;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,19): error CS0117: 'D' does not contain a definition for 'Current'
            // foreach (var x in new C())
            Diagnostic(ErrorCode.ERR_NoSuchMember, "new C()").WithArguments("D", "Current").WithLocation(1, 19),
            // (1,19): error CS0202: foreach requires that the return type 'D' of 'E.extension(C).GetEnumerator()' must have a suitable public 'MoveNext' method and public 'Current' property
            // foreach (var x in new C())
            Diagnostic(ErrorCode.ERR_BadGetEnumerator, "new C()").WithArguments("D", "E.extension(C).GetEnumerator()").WithLocation(1, 19)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var loop = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().Single();
        Assert.Null(model.GetForEachStatementInfo(loop).GetEnumeratorMethod);
        Assert.Null(model.GetForEachStatementInfo(loop).MoveNextMethod);
        Assert.Null(model.GetForEachStatementInfo(loop).CurrentProperty);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_ForEach_WrongArity()
    {
        var src = """
using System.Collections;

foreach (var x in new C()) { }

class C { }

static class E
{
    extension(C c)
    {
        public IEnumerator GetEnumerator<T>() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,19): error CS0411: The type arguments for method 'E.extension(C).GetEnumerator<T>()' cannot be inferred from the usage. Try specifying the type arguments explicitly.
            // foreach (var x in new C()) { }
            Diagnostic(ErrorCode.ERR_CantInferMethTypeArgs, "new C()").WithArguments("E.extension(C).GetEnumerator<T>()").WithLocation(3, 19),
            // (3,19): error CS1579: foreach statement cannot operate on variables of type 'C' because 'C' does not contain a public instance or extension definition for 'GetEnumerator'
            // foreach (var x in new C()) { }
            Diagnostic(ErrorCode.ERR_ForEachMissingMember, "new C()").WithArguments("C", "GetEnumerator").WithLocation(3, 19));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var loop = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().Single();
        Assert.Null(model.GetForEachStatementInfo(loop).GetEnumeratorMethod);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_ForEach_NonInvocable()
    {
        var src = """
using System.Collections;

foreach (var x in new C()) { }

class C { }

static class E
{
    extension(C c)
    {
        public IEnumerator GetEnumerator => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,19): error CS1579: foreach statement cannot operate on variables of type 'C' because 'C' does not contain a public instance or extension definition for 'GetEnumerator'
            // foreach (var x in new C()) { }
            Diagnostic(ErrorCode.ERR_ForEachMissingMember, "new C()").WithArguments("C", "GetEnumerator").WithLocation(3, 19));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var loop = tree.GetRoot().DescendantNodes().OfType<ForEachStatementSyntax>().Single();
        Assert.Null(model.GetForEachStatementInfo(loop).GetEnumeratorMethod);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Deconstruct_NoMethod()
    {
        var src = """
var (x, y) = new C();
System.Console.Write((x, y));

class C { }

static class E
{
    extension(C c)
    {
        public void Deconstruct(out int i, out int j) { i = 42; j = 43; }
    }
}
""";
        var comp = CreateCompilation(src);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based deconstruction
        CompileAndVerify(comp, expectedOutput: "(42, 43)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var deconstruction = tree.GetRoot().DescendantNodes().OfType<AssignmentExpressionSyntax>().First();

        Assert.Equal("void E.<>E__0.Deconstruct(out System.Int32 i, out System.Int32 j)",
            model.GetDeconstructionInfo(deconstruction).Method.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Deconstruct_FallbackToExtensionMethod()
    {
        // If the method from the extension type is not applicable, we fall back
        // to a Deconstruct extension method
        var src = """
var (x, y) = new C();
System.Console.Write((x, y));

public class C { }

static class E
{
    extension(C c)
    {
        public void Deconstruct(int inapplicable) => throw null;
    }
}

public static class E2
{
    public static void Deconstruct(this C c, out int i, out int j) { i = 42; j = 43; }
}
""";
        var comp = CreateCompilation(src);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based deconstruction
        CompileAndVerify(comp, expectedOutput: "(42, 43)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var deconstruction = tree.GetRoot().DescendantNodes().OfType<AssignmentExpressionSyntax>().First();

        Assert.Equal("void E2.Deconstruct(this C c, out System.Int32 i, out System.Int32 j)",
            model.GetDeconstructionInfo(deconstruction).Method.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Deconstruct_DelegateTypeProperty()
    {
        var src = """
var (x1, y1) = new C1();

var (x2, y2) = new C2();

class C1 { }

class C2
{
    public D Deconstruct => (out int i, out int j) => { i = 42; j = 43; };
}

delegate void D(out int i, out int j);

static class E
{
    extension(C1 c)
    {
        public D Deconstruct => (out int i, out int j) => { i = 42; j = 43; };
    }
}
""";
        var comp = CreateCompilation(src);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : revisit pattern-based deconstruction
        comp.VerifyDiagnostics(
            // (1,6): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'x1'.
            // var (x1, y1) = new C1();
            Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "x1").WithArguments("x1").WithLocation(1, 6),
            // (1,10): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'y1'.
            // var (x1, y1) = new C1();
            Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "y1").WithArguments("y1").WithLocation(1, 10),

            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : It looks like the following error is not reported for instance scenario. Noise?

            // (1,16): error CS1061: 'C1' does not contain a definition for 'Deconstruct' and no accessible extension method 'Deconstruct' accepting a first argument of type 'C1' could be found (are you missing a using directive or an assembly reference?)
            // var (x1, y1) = new C1();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "new C1()").WithArguments("C1", "Deconstruct").WithLocation(1, 16),

            // (1,16): error CS8129: No suitable 'Deconstruct' instance or extension method was found for type 'C1', with 2 out parameters and a void return type.
            // var (x1, y1) = new C1();
            Diagnostic(ErrorCode.ERR_MissingDeconstruct, "new C1()").WithArguments("C1", "2").WithLocation(1, 16),
            // (3,6): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'x2'.
            // var (x2, y2) = new C2();
            Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "x2").WithArguments("x2").WithLocation(3, 6),
            // (3,10): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'y2'.
            // var (x2, y2) = new C2();
            Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "y2").WithArguments("y2").WithLocation(3, 10),
            // (3,16): error CS8129: No suitable 'Deconstruct' instance or extension method was found for type 'C2', with 2 out parameters and a void return type.
            // var (x2, y2) = new C2();
            Diagnostic(ErrorCode.ERR_MissingDeconstruct, "new C2()").WithArguments("C2", "2").WithLocation(3, 16)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var deconstruction = tree.GetRoot().DescendantNodes().OfType<AssignmentExpressionSyntax>().First();

        Assert.Null(model.GetDeconstructionInfo(deconstruction).Method);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Deconstruct_DynamicProperty()
    {
        var src = """
var (x, y) = new C();

class C { }

static class E
{
    extension(C c)
    {
        public dynamic Deconstruct => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : revisit pattern-based deconstruction
        comp.VerifyEmitDiagnostics(
            // (1,6): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'x'.
            // var (x, y) = new C();
            Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "x").WithArguments("x").WithLocation(1, 6),
            // (1,9): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'y'.
            // var (x, y) = new C();
            Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "y").WithArguments("y").WithLocation(1, 9),
            // (1,14): error CS1061: 'C' does not contain a definition for 'Deconstruct' and no accessible extension method 'Deconstruct' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            // var (x, y) = new C();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "new C()").WithArguments("C", "Deconstruct").WithLocation(1, 14),
            // (1,14): error CS8129: No suitable 'Deconstruct' instance or extension method was found for type 'C', with 2 out parameters and a void return type.
            // var (x, y) = new C();
            Diagnostic(ErrorCode.ERR_MissingDeconstruct, "new C()").WithArguments("C", "2").WithLocation(1, 14)
            );

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var deconstruction = tree.GetRoot().DescendantNodes().OfType<AssignmentExpressionSyntax>().First();

        Assert.Null(model.GetDeconstructionInfo(deconstruction).Method);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Deconstruct_NoApplicableMethod()
    {
        var src = """
var (x, y) = new C();
System.Console.Write((x, y));

class C
{
    public void Deconstruct() { } // not applicable
}

static class E
{
    extension(C c)
    {
        public void Deconstruct(out int i, out int j) { i = 42; j = 43; }
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based deconstruction
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "(42, 43)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var deconstruction = tree.GetRoot().DescendantNodes().OfType<AssignmentExpressionSyntax>().First();

        Assert.Equal("void E.<>E__0.Deconstruct(out System.Int32 i, out System.Int32 j)",
            model.GetDeconstructionInfo(deconstruction).Method.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Dispose_Async_NoMethod()
    {
        var src = """
using System.Threading.Tasks;

/*<bind>*/
await using var x1 = new C1();
/*</bind>*/

await using var x2 = new C2();

class C1 { }
class C2 { }

static class E
{
    extension(C1 c)
    {
        public async Task DisposeAsync()
        {
            System.Console.Write("RAN");
            await Task.Yield();
        }
    }

    public static async Task DisposeAsync(this C2 c)
    {
        System.Console.Write("RAN");
        await Task.Yield();
    }
}
""";
        var comp = CreateCompilation(src);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based disposal

        var expectedDiagnostics = new[] {
            // (4,1): error CS8410: 'C1': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.
            // await using var x1 = new C1();
            Diagnostic(ErrorCode.ERR_NoConvToIAsyncDisp, "await using var x1 = new C1();").WithArguments("C1").WithLocation(4, 1),
            // (7,1): error CS8410: 'C2': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.
            // await using var x2 = new C2();
            Diagnostic(ErrorCode.ERR_NoConvToIAsyncDisp, "await using var x2 = new C2();").WithArguments("C2").WithLocation(7, 1)
            };

        comp.VerifyDiagnostics(expectedDiagnostics);

        string expectedOperationTree = """
IUsingDeclarationOperation(IsAsynchronous: True) (OperationKind.UsingDeclaration, Type: null, IsInvalid) (Syntax: 'await using ... = new C1();')
  DeclarationGroup:
    IVariableDeclarationGroupOperation (1 declarations) (OperationKind.VariableDeclarationGroup, Type: null, IsInvalid, IsImplicit) (Syntax: 'await using ... = new C1();')
      IVariableDeclarationOperation (1 declarators) (OperationKind.VariableDeclaration, Type: null, IsInvalid) (Syntax: 'var x1 = new C1()')
        Declarators:
            IVariableDeclaratorOperation (Symbol: C1 x1) (OperationKind.VariableDeclarator, Type: null, IsInvalid) (Syntax: 'x1 = new C1()')
              Initializer:
                IVariableInitializerOperation (OperationKind.VariableInitializer, Type: null, IsInvalid) (Syntax: '= new C1()')
                  IObjectCreationOperation (Constructor: C1..ctor()) (OperationKind.ObjectCreation, Type: C1, IsInvalid) (Syntax: 'new C1()')
                    Arguments(0)
                    Initializer:
                      null
        Initializer:
          null
""";

        VerifyOperationTreeAndDiagnosticsForTest<LocalDeclarationStatementSyntax>(src, expectedOperationTree, expectedDiagnostics);
    }

    [Fact]
    public void TestPatternBasedDisposal_ExtensionMethod()
    {
        string source = @"
public class C
{
    public static async System.Threading.Tasks.Task<int> Main()
    {
        await using (var x = new C())
        {
        }

        return 1;
    }
}
public static class Extensions
{
    extension (C c)
    {
        public System.Threading.Tasks.ValueTask DisposeAsync()
            => throw null;
    }
}
";
        // extension methods do not contribute to pattern-based disposal
        var comp = CreateCompilationWithTasksExtensions(new[] { source, IAsyncDisposableDefinition }, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // 0.cs(6,22): error CS8410: 'C': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.
            //         await using (var x = new C())
            Diagnostic(ErrorCode.ERR_NoConvToIAsyncDisp, "var x = new C()").WithArguments("C").WithLocation(6, 22)
            );
    }

    [Fact]
    public void PatternBased_Dispose_Async_DelegateTypeProperty()
    {
        var src = """
using System.Threading.Tasks;

await using var x = new C();

class C
{
    public System.Func<Task> DisposeAsync => async () => { System.Console.Write("ran2"); await Task.Yield(); };
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,1): error CS8410: 'C': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.
            // await using var x = new C();
            Diagnostic(ErrorCode.ERR_NoConvToIAsyncDisp, "await using var x = new C();").WithArguments("C").WithLocation(3, 1)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Dispose_Async_DelegateTypeProperty()
    {
        var src = """
using System.Threading.Tasks;

await using var x = new C();

class C { }

static class E
{
    extension(C c)
    {
        public System.Func<Task> DisposeAsync => async () => { System.Console.Write("ran2"); await Task.Yield(); };
    }
}
""";
        var comp = CreateCompilation(src);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 :(instance) confirm when spec'ing pattern-based disposal
        comp.VerifyEmitDiagnostics(
            // (3,1): error CS8410: 'C': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.
            // await using var x = new C();
            Diagnostic(ErrorCode.ERR_NoConvToIAsyncDisp, "await using var x = new C();").WithArguments("C").WithLocation(3, 1)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Dispose_Async_NoApplicableMethod()
    {
        var src = """
using System.Threading.Tasks;

/*<bind>*/
await using var x = new C();
/*</bind>*/

class C
{
    public Task DisposeAsync(int notApplicable) => throw null; // not applicable
}

static class E
{
    extension(C c)
    {
        public async Task DisposeAsync()
        {
            System.Console.Write("RAN");
            await Task.Yield();
        }
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based disposal
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (4,1): error CS8410: 'C': type used in an asynchronous using statement must implement 'System.IAsyncDisposable' or implement a suitable 'DisposeAsync' method.
            // await using var x = new C();
            Diagnostic(ErrorCode.ERR_NoConvToIAsyncDisp, "await using var x = new C();").WithArguments("C").WithLocation(4, 1)
            );

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : verify IOperation
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Dispose_RefStruct()
    {
        var src = """
using var x1 = new S1();
using var x2 = new S2();

ref struct S1 { }

ref struct S2
{
}

static class E
{
    extension(S1 s)
    {
        public void Dispose() { }
    }

    public static void Dispose(this S2 s) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,1): error CS1674: 'S1': type used in a using statement must implement 'System.IDisposable'.
            // using var x1 = new S1();
            Diagnostic(ErrorCode.ERR_NoConvToIDisp, "using var x1 = new S1();").WithArguments("S1").WithLocation(1, 1),
            // (2,1): error CS1674: 'S2': type used in a using statement must implement 'System.IDisposable'.
            // using var x2 = new S2();
            Diagnostic(ErrorCode.ERR_NoConvToIDisp, "using var x2 = new S2();").WithArguments("S2").WithLocation(2, 1)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Fixed_NoMethod()
    {
        var text = """
unsafe class C
{
    public static void Main()
    {
        fixed (int* p = new Fixable())
        {
            System.Console.WriteLine(p[1]);
        }
    }
}

class Fixable { }

static class E
{
    extension(Fixable f)
    {
        public ref int GetPinnableReference() { System.Console.Write("pin "); return ref (new int[] { 1, 2, 3 })[0]; }
    }
}
""";
        var comp = CreateCompilation(text, options: TestOptions.UnsafeReleaseExe);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based fixed
        comp.VerifyEmitDiagnostics();
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Fixed_NoMethod_DelegateTypeProperty()
    {
        var text = @"
unsafe class C
{
    public static void Main()
    {
        fixed (int* p = new Fixable1())
        {
            System.Console.WriteLine(p[1]);
        }

        fixed (int* p = new Fixable2())
        {
            System.Console.WriteLine(p[1]);
        }
    }
}

class Fixable1 { }

class Fixable2
{
    public MyDelegate GetPinnableReference => throw null;
}

delegate ref int MyDelegate();

static class E
{
    extension(Fixable1 f)
    {
        public MyDelegate GetPinnableReference => throw null;
    }
}
";
        var comp = CreateCompilation(text, options: TestOptions.UnsafeReleaseExe);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based fixed
        comp.VerifyEmitDiagnostics(
            // (6,25): error CS8385: The given expression cannot be used in a fixed statement
            //         fixed (int* p = new Fixable1())
            Diagnostic(ErrorCode.ERR_ExprCannotBeFixed, "new Fixable1()").WithLocation(6, 25),
            // (11,25): error CS8385: The given expression cannot be used in a fixed statement
            //         fixed (int* p = new Fixable2())
            Diagnostic(ErrorCode.ERR_ExprCannotBeFixed, "new Fixable2()").WithLocation(11, 25)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Fixed_NoApplicableMethod()
    {
        var src = """
unsafe class C
{
    public static void Main()
    {
        fixed (int* p = new Fixable())
        {
            System.Console.WriteLine(p[1]);
        }
    }
}

class Fixable
{
    public ref int GetPinnableReference(int notApplicable) => throw null; // not applicable
}

static class E
{
    extension(Fixable f)
    {
        public ref int GetPinnableReference() { return ref (new int[] { 1, 2, 3 })[0]; }
    }
}
""";

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based fixed
        var comp = CreateCompilation(src, options: TestOptions.UnsafeReleaseExe);
        comp.VerifyEmitDiagnostics();
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : verify IOperation
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Fixed_Static()
    {
        var text = @"
unsafe class C
{
    public static void Main()
    {
        fixed (int* p = new Fixable())
        {
        }
    }
}

class Fixable { }

static class E
{
    extension(Fixable f)
    {
        public static ref int GetPinnableReference() => throw null;
    }
}
";

        var comp = CreateCompilation(text, options: TestOptions.UnsafeReleaseExe);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based fixed
        comp.VerifyEmitDiagnostics(
            // (6,25): error CS0176: Member 'E.extension(Fixable).GetPinnableReference()' cannot be accessed with an instance reference; qualify it with a type name instead
            //         fixed (int* p = new Fixable())
            Diagnostic(ErrorCode.ERR_ObjectProhibited, "new Fixable()").WithArguments("E.extension(Fixable).GetPinnableReference()").WithLocation(6, 25),
            // (6,25): error CS8385: The given expression cannot be used in a fixed statement
            //         fixed (int* p = new Fixable())
            Diagnostic(ErrorCode.ERR_ExprCannotBeFixed, "new Fixable()").WithLocation(6, 25));
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Await_ExtensionIsCompleted()
    {
        var text = @"
using System;
using System.Runtime.CompilerServices;

int i = await new C();
System.Console.Write(i);

class C
{
    public D GetAwaiter() => new D();
}

class D : INotifyCompletion
{
    public int GetResult() => 42;
    public void OnCompleted(Action continuation) => throw null;
}

static class E
{
    extension(D d)
    {
        public bool IsCompleted => true;
    }
}
";

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based await
        var comp = CreateCompilation(text);
        comp.VerifyEmitDiagnostics(
            // (5,9): error CS0117: 'D' does not contain a definition for 'IsCompleted'
            // int i = await new C();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "await new C()").WithArguments("D", "IsCompleted").WithLocation(5, 9)
            );
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Await_ExtensionGetAwaiter()
    {
        var text = @"
using System;
using System.Runtime.CompilerServices;

int i = await new C();
System.Console.Write(i);

class C
{
}

class D : INotifyCompletion
{
    public int GetResult() => 42;
    public void OnCompleted(Action continuation) => throw null;
    public bool IsCompleted => true;
}

static class E
{
    extension(C c)
    {
        public D GetAwaiter() => new D();
    }
}
";

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based await
        var comp = CreateCompilation(text);
        comp.VerifyEmitDiagnostics();
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_Await_ExtensionGetResult()
    {
        var text = @"
using System;
using System.Runtime.CompilerServices;

int i = await new C();
System.Console.Write(i);

class C
{
    public D GetAwaiter() => new D();
}

class D : INotifyCompletion
{
    public void OnCompleted(Action continuation) => throw null;
    public bool IsCompleted => true;
}

static class E
{
    extension(D d)
    {
        public int GetResult() => 42;
    }
}
";

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based await
        var comp = CreateCompilation(text);

        // The error is consistent with classic extension methods
        comp.VerifyEmitDiagnostics(
            // (5,9): error CS0117: 'D' does not contain a definition for 'GetResult'
            // int i = await new C();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "await new C()").WithArguments("D", "GetResult").WithLocation(5, 9)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_IndexIndexer_NoLength()
    {
        var src = """
var c = new C();

/*<bind>*/
_ = c[^1];
/*</bind>*/

class C
{
    public int this[int i]
    {
        get { System.Console.Write("indexer "); return 0; }
    }
}

static class E
{
    extension(C c)
    {
        public int Length
        {
            get { System.Console.Write("length "); return 42; }
        }
    }
}
""";
        DiagnosticDescription[] expectedDiagnostics = [
            // (4,7): error CS1503: Argument 1: cannot convert from 'System.Index' to 'int'
            // _ = c[^1];
            Diagnostic(ErrorCode.ERR_BadArgType, "^1").WithArguments("1", "System.Index", "int").WithLocation(4, 7)];

        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : revisit as part of "implicit indexer access" section
        comp.VerifyEmitDiagnostics(expectedDiagnostics);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
        //CompileAndVerify(comp, expectedOutput: "length indexer");

        string expectedOperationTree = """
ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: System.Int32, IsInvalid) (Syntax: '_ = c[^1]')
Left:
  IDiscardOperation (Symbol: System.Int32 _) (OperationKind.Discard, Type: System.Int32) (Syntax: '_')
Right:
  IInvalidOperation (OperationKind.Invalid, Type: System.Int32, IsInvalid) (Syntax: 'c[^1]')
    Children(2):
        ILocalReferenceOperation: c (OperationKind.LocalReference, Type: C) (Syntax: 'c')
        IUnaryOperation (UnaryOperatorKind.Hat) (OperationKind.Unary, Type: System.Index, IsInvalid) (Syntax: '^1')
          Operand:
            ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 1, IsInvalid) (Syntax: '1')
""";

        VerifyOperationTreeAndDiagnosticsForTest<AssignmentExpressionSyntax>(src, expectedOperationTree, expectedDiagnostics, targetFramework: TargetFramework.Net70);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_RangeIndexer_NoMethod()
    {
        var src = """
var c = new C();

/*<bind>*/
_ = c[1..^1];
/*</bind>*/

class C { }

static class E
{
    extension(C c)
    {
        public int Slice(int i, int j) { System.Console.Write("slice "); return 0; }

        public int Length
        {
            get { System.Console.Write("length "); return 42; }
        }
    }
}
""";

        DiagnosticDescription[] expectedDiagnostics = [
            // (4,5): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            // _ = c[1..^1];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "c[1..^1]").WithArguments("C").WithLocation(4, 5)];

        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : revisit as part of "implicit indexer access" section
        comp.VerifyEmitDiagnostics(expectedDiagnostics);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
        //CompileAndVerify(comp, expectedOutput: "length slice");

        string expectedOperationTree = """
ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: ?, IsInvalid) (Syntax: '_ = c[1..^1]')
Left:
  IDiscardOperation (Symbol: ? _) (OperationKind.Discard, Type: ?) (Syntax: '_')
Right:
  IInvalidOperation (OperationKind.Invalid, Type: ?, IsInvalid) (Syntax: 'c[1..^1]')
    Children(2):
        IRangeOperation (OperationKind.Range, Type: System.Range, IsInvalid) (Syntax: '1..^1')
          LeftOperand:
            IConversionOperation (TryCast: False, Unchecked) (OperatorMethod: System.Index System.Index.op_Implicit(System.Int32 value)) (OperationKind.Conversion, Type: System.Index, IsInvalid, IsImplicit) (Syntax: '1')
              Conversion: CommonConversion (Exists: True, IsIdentity: False, IsNumeric: False, IsReference: False, IsUserDefined: True) (MethodSymbol: System.Index System.Index.op_Implicit(System.Int32 value))
              Operand:
                ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 1, IsInvalid) (Syntax: '1')
          RightOperand:
            IUnaryOperation (UnaryOperatorKind.Hat) (OperationKind.Unary, Type: System.Index, IsInvalid) (Syntax: '^1')
              Operand:
                ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 1, IsInvalid) (Syntax: '1')
        ILocalReferenceOperation: c (OperationKind.LocalReference, Type: C, IsInvalid) (Syntax: 'c')
""";

        VerifyOperationTreeAndDiagnosticsForTest<AssignmentExpressionSyntax>(src, expectedOperationTree, expectedDiagnostics, targetFramework: TargetFramework.Net70);
    }

    [Fact]
    public void ExtensionMemberLookup_PatternBased_RangeIndexer_NoApplicableMethod()
    {
        var src = """
var c = new C();

/*<bind>*/
_ = c[1..^1];
/*</bind>*/

class C
{
    public int Slice(int notApplicable) => throw null; // not applicable
}

static class E
{
    extension(C c)
    {
        public int Slice(int i, int j) { System.Console.Write("slice "); return 0; }

        public int Length
        {
            get { System.Console.Write("length "); return 42; }
        }
    }
}
""";

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : revisit as part of "implicit indexer access" section
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        comp.VerifyEmitDiagnostics(
            // (4,5): error CS0021: Cannot apply indexing with [] to an expression of type 'C'
            // _ = c[1..^1];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "c[1..^1]").WithArguments("C").WithLocation(4, 5));
    }

    [Fact]
    public void ExtensionMemberLookup_Patterns()
    {
        var src = """
var c = new C();

_ = c is { Property: 42 };

class C { }

static class E
{
    extension(C c)
    {
        public int Property
        {
            get { System.Console.Write("property"); return 42; }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "property").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var nameColon = GetSyntax<NameColonSyntax>(tree, "Property:");
        Assert.Equal("System.Int32 E.<>E__0.Property { get; }", model.GetSymbolInfo(nameColon.Name).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_Patterns_ExtendedPropertyPattern()
    {
        var src = """
var c = new C();

_ = c is { Property.Property2: 43 };

class C { }

static class E1
{
    extension(C c)
    {
        public int Property { get { System.Console.Write("property "); return 42; } }
    }
}

static class E2
{
    extension(int i)
    {
        public int Property2 { get { System.Console.Write("property2"); return 43; } }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "property property2").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var expressionColon = GetSyntax<ExpressionColonSyntax>(tree, "Property.Property2:");
        Assert.Equal("System.Int32 E2.<>E__0.Property2 { get; }", model.GetSymbolInfo(expressionColon.Expression).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_Patterns_ListPattern_NoInstanceLength()
    {
        var src = """
System.Console.Write(new C() is ["hi"]);

class C
{
    public string this[System.Index i]
    {
        get { System.Console.Write("indexer "); return "hi"; }
    }
}

static class E
{
    extension(C c)
    {
        public int Length
        {
            get { System.Console.Write("length "); return 42; }
        }
    }
}
""";

        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net70);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm that we want extensions to contribute to list-patterns
        comp.VerifyEmitDiagnostics(
            // (1,33): error CS8985: List patterns may not be used for a value of type 'C'. No suitable 'Length' or 'Count' property was found.
            // System.Console.Write(new C() is ["hi"]);
            Diagnostic(ErrorCode.ERR_ListPatternRequiresLength, @"[""hi""]").WithArguments("C").WithLocation(1, 33)
            );
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
        //CompileAndVerify(comp, expectedOutput: "length indexer");
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
    public void ExtensionMemberLookup_ObjectInitializer()
    {
        var src = """
/*<bind>*/
_ = new C() { Property = 42 };
/*</bind>*/

class C { }

static class E
{
    extension(C c)
    {
        public int Property { set { System.Console.Write("property"); } }
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
        //CompileAndVerify(comp, expectedOutput: "property");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var assignment = GetSyntax<AssignmentExpressionSyntax>(tree, "Property = 42");
        Assert.Equal("System.Int32 E.<>E__0.Property { set; }", model.GetSymbolInfo(assignment.Left).Symbol.ToTestDisplayString());
    }

    [ConditionalFact(typeof(NoUsedAssembliesValidation))] // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
    public void ExtensionMemberLookup_With()
    {
        var src = """
/*<bind>*/
_ = new S() with { Property = 42 };
/*</bind>*/

struct S { }

static class E
{
    extension(S s)
    {
        public int Property { set { System.Console.Write("property"); } }
    }
}
""";

        var comp = CreateCompilation(src);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : need to decide whether extensions apply here
        comp.VerifyDiagnostics();
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : metadata is undone
        //CompileAndVerify(comp, expectedOutput: "property");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var assignment = GetSyntax<AssignmentExpressionSyntax>(tree, "Property = 42");
        Assert.Equal("System.Int32 E.<>E__0.Property { set; }", model.GetSymbolInfo(assignment.Left).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ExtensionMemberLookup_CollectionInitializer_NoMethod()
    {
        var src = """
using System.Collections;
using System.Collections.Generic;

/*<bind>*/
_ = new C() { 42 };
/*</bind>*/

class C : IEnumerable<int>, IEnumerable
{
    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}

static class E
{
    extension(C c)
    {
        public void Add(int i) { System.Console.Write("add"); }
    }
}
""";

        var comp = CreateCompilation(src);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based collection initializer
        CompileAndVerify(comp, expectedOutput: "add").VerifyDiagnostics();

        string expectedOperationTree = """
ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: C) (Syntax: '_ = new C() { 42 }')
Left:
  IDiscardOperation (Symbol: C _) (OperationKind.Discard, Type: C) (Syntax: '_')
Right:
  IObjectCreationOperation (Constructor: C..ctor()) (OperationKind.ObjectCreation, Type: C) (Syntax: 'new C() { 42 }')
    Arguments(0)
    Initializer:
      IObjectOrCollectionInitializerOperation (OperationKind.ObjectOrCollectionInitializer, Type: C) (Syntax: '{ 42 }')
        Initializers(1):
            IInvocationOperation ( void E.<>E__0.Add(System.Int32 i)) (OperationKind.Invocation, Type: System.Void, IsImplicit) (Syntax: '42')
              Instance Receiver:
                IInstanceReferenceOperation (ReferenceKind: ImplicitReceiver) (OperationKind.InstanceReference, Type: C, IsImplicit) (Syntax: 'C')
              Arguments(1):
                  IArgumentOperation (ArgumentKind.Explicit, Matching Parameter: i) (OperationKind.Argument, Type: null, IsImplicit) (Syntax: '42')
                    ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 42) (Syntax: '42')
                    InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
                    OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
""";
        var expectedDiagnostics = DiagnosticDescription.None;

        VerifyOperationTreeAndDiagnosticsForTest<AssignmentExpressionSyntax>(src, expectedOperationTree, expectedDiagnostics);
    }

    [Fact]
    public void ExtensionMemberLookup_CollectionInitializer_NoApplicableMethod()
    {
        var src = """
using System.Collections;
using System.Collections.Generic;

class Program
{
    static void Main()
    {
        /*<bind>*/
        _ = new C() { 42 };
        /*</bind>*/
    }
}

class C : IEnumerable<int>, IEnumerable
{
    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
    public void Add(string notApplicable) => throw null;
}

static class E
{
    extension(object o)
    {
        public void Add(int i) { System.Console.Write("add"); }
    }
}
""";

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based collection initializer
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "add").VerifyDiagnostics();

        string expectedOperationTree = """
ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: C) (Syntax: '_ = new C() { 42 }')
  Left:
    IDiscardOperation (Symbol: C _) (OperationKind.Discard, Type: C) (Syntax: '_')
  Right:
    IObjectCreationOperation (Constructor: C..ctor()) (OperationKind.ObjectCreation, Type: C) (Syntax: 'new C() { 42 }')
      Arguments(0)
      Initializer:
        IObjectOrCollectionInitializerOperation (OperationKind.ObjectOrCollectionInitializer, Type: C) (Syntax: '{ 42 }')
          Initializers(1):
              IInvocationOperation ( void E.<>E__0.Add(System.Int32 i)) (OperationKind.Invocation, Type: System.Void, IsImplicit) (Syntax: '42')
                Instance Receiver:
                  IConversionOperation (TryCast: False, Unchecked) (OperationKind.Conversion, Type: System.Object, IsImplicit) (Syntax: 'C')
                    Conversion: CommonConversion (Exists: True, IsIdentity: False, IsNumeric: False, IsReference: True, IsUserDefined: False) (MethodSymbol: null)
                    Operand:
                      IInstanceReferenceOperation (ReferenceKind: ImplicitReceiver) (OperationKind.InstanceReference, Type: C, IsImplicit) (Syntax: 'C')
                Arguments(1):
                    IArgumentOperation (ArgumentKind.Explicit, Matching Parameter: i) (OperationKind.Argument, Type: null, IsImplicit) (Syntax: '42')
                      ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 42) (Syntax: '42')
                      InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
                      OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
""";
        var expectedDiagnostics = DiagnosticDescription.None;

        VerifyOperationTreeAndDiagnosticsForTest<AssignmentExpressionSyntax>(src, expectedOperationTree, expectedDiagnostics);

        VerifyFlowGraph(comp, comp.SyntaxTrees.Single().GetRoot().DescendantNodes().OfType<MethodDeclarationSyntax>().First(), """
Block[B0] - Entry
    Statements (0)
    Next (Regular) Block[B1]
        Entering: {R1}
.locals {R1}
{
    CaptureIds: [0]
    Block[B1] - Block
        Predecessors: [B0]
        Statements (3)
            IFlowCaptureOperation: 0 (OperationKind.FlowCapture, Type: null, IsImplicit) (Syntax: 'new C() { 42 }')
              Value:
                IObjectCreationOperation (Constructor: C..ctor()) (OperationKind.ObjectCreation, Type: C) (Syntax: 'new C() { 42 }')
                  Arguments(0)
                  Initializer:
                    null
            IInvocationOperation ( void E.<>E__0.Add(System.Int32 i)) (OperationKind.Invocation, Type: System.Void, IsImplicit) (Syntax: '42')
              Instance Receiver:
                IConversionOperation (TryCast: False, Unchecked) (OperationKind.Conversion, Type: System.Object, IsImplicit) (Syntax: 'C')
                  Conversion: CommonConversion (Exists: True, IsIdentity: False, IsNumeric: False, IsReference: True, IsUserDefined: False) (MethodSymbol: null)
                    (ImplicitReference)
                  Operand:
                    IFlowCaptureReferenceOperation: 0 (OperationKind.FlowCaptureReference, Type: C, IsImplicit) (Syntax: 'new C() { 42 }')
              Arguments(1):
                  IArgumentOperation (ArgumentKind.Explicit, Matching Parameter: i) (OperationKind.Argument, Type: null, IsImplicit) (Syntax: '42')
                    ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 42) (Syntax: '42')
                    InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
                    OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
            IExpressionStatementOperation (OperationKind.ExpressionStatement, Type: null) (Syntax: '_ = new C() { 42 };')
              Expression:
                ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: C) (Syntax: '_ = new C() { 42 }')
                  Left:
                    IDiscardOperation (Symbol: C _) (OperationKind.Discard, Type: C) (Syntax: '_')
                  Right:
                    IFlowCaptureReferenceOperation: 0 (OperationKind.FlowCaptureReference, Type: C, IsImplicit) (Syntax: 'new C() { 42 }')
        Next (Regular) Block[B2]
            Leaving: {R1}
}
Block[B2] - Exit
    Predecessors: [B1]
    Statements (0)
""");
    }

    [Fact]
    public void ExtensionMemberLookup_CollectionInitializer_NoApplicableMethod_ExpressionTree()
    {
        var src = """
using System.Collections;
using System.Collections.Generic;

try
{
    System.Linq.Expressions.Expression<System.Func<C>> e = () => new C() { 42 };
    System.Console.Write(e);
}
catch (System.ArgumentException ae)
{
    System.Console.Write(ae.Message);
}

class C : IEnumerable<int>, IEnumerable
{
    IEnumerator<int> IEnumerable<int>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
    public void Add(string notApplicable) => throw null;
}

static class E
{
    extension(object o)
    {
        public void Add(int i) { System.Console.Write("add"); }
    }
}
""";

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm when spec'ing pattern-based collection initializer
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : expression trees
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net90);
        comp.VerifyEmitDiagnostics(
            // (6,76): error CS8075: An extension Add method is not supported for a collection initializer in an expression lambda.
            //     System.Linq.Expressions.Expression<System.Func<C>> e = () => new C() { 42 };
            Diagnostic(ErrorCode.ERR_ExtensionCollectionElementInitializerInExpressionTree, "42").WithLocation(6, 76)
            );
    }

    [Fact]
    public void ExtensionMemberLookup_Query_NoMethod()
    {
        var src = """
/*<bind>*/
string query = from x in new C() select x;
/*</bind>*/

System.Console.Write(query);

class C { }

static class E
{
    extension(C c)
    {
        public string Select(System.Func<C, C> selector) => "hello";
    }
}
""";

        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hello").VerifyDiagnostics();

        string expectedOperationTree = """
IVariableDeclarationGroupOperation (1 declarations) (OperationKind.VariableDeclarationGroup, Type: null) (Syntax: 'string quer ... ) select x;')
  IVariableDeclarationOperation (1 declarators) (OperationKind.VariableDeclaration, Type: null) (Syntax: 'string quer ... () select x')
    Declarators:
        IVariableDeclaratorOperation (Symbol: System.String query) (OperationKind.VariableDeclarator, Type: null) (Syntax: 'query = fro ... () select x')
          Initializer:
            IVariableInitializerOperation (OperationKind.VariableInitializer, Type: null) (Syntax: '= from x in ... () select x')
              ITranslatedQueryOperation (OperationKind.TranslatedQuery, Type: System.String) (Syntax: 'from x in n ... () select x')
                Expression:
                  IInvocationOperation ( System.String E.<>E__0.Select(System.Func<C, C> selector)) (OperationKind.Invocation, Type: System.String, IsImplicit) (Syntax: 'select x')
                    Instance Receiver:
                      IObjectCreationOperation (Constructor: C..ctor()) (OperationKind.ObjectCreation, Type: C) (Syntax: 'new C()')
                        Arguments(0)
                        Initializer:
                          null
                    Arguments(1):
                        IArgumentOperation (ArgumentKind.Explicit, Matching Parameter: selector) (OperationKind.Argument, Type: null, IsImplicit) (Syntax: 'x')
                          IDelegateCreationOperation (OperationKind.DelegateCreation, Type: System.Func<C, C>, IsImplicit) (Syntax: 'x')
                            Target:
                              IAnonymousFunctionOperation (Symbol: lambda expression) (OperationKind.AnonymousFunction, Type: null, IsImplicit) (Syntax: 'x')
                                IBlockOperation (1 statements) (OperationKind.Block, Type: null, IsImplicit) (Syntax: 'x')
                                  IReturnOperation (OperationKind.Return, Type: null, IsImplicit) (Syntax: 'x')
                                    ReturnedValue:
                                      IParameterReferenceOperation: x (OperationKind.ParameterReference, Type: C) (Syntax: 'x')
                          InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
                          OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
    Initializer:
      null
""";

        VerifyOperationTreeAndDiagnosticsForTest<LocalDeclarationStatementSyntax>(src, expectedOperationTree, DiagnosticDescription.None);
    }

    [Fact]
    public void ExtensionMemberLookup_Query_NoApplicableMethod()
    {
        var src = """
/*<bind>*/
string query = from x in new C() select x;
/*</bind>*/

System.Console.Write(query);

class C
{
    public string Select(int notApplicable) => throw null; // not applicable
}

static class E
{
    extension(C c)
    {
        public string Select(System.Func<C, C> selector) => "hello";
    }
}
""";

        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "hello").VerifyDiagnostics();

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : verify IOperation
    }

    [Fact]
    public void ExtensionMemberLookup_Invocation_ZeroArityMatchesAny()
    {
        var source = $$"""
object.Method("");
object.Method<string>("");

static class E
{
    extension(object)
    {
        public static void Method(int i) => throw null;
        public static void Method<T>(T t) { System.Console.Write("Method "); }
        public static void Method<T1, T2>(T1 t1, T2 t2) => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "Method Method").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, """object.Method("")""");
        Assert.Equal("void E.<>E__0.Method<System.String>(System.String t)", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Empty(model.GetMemberGroup(invocation)); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : need to fix the semantic model
    }

    [Fact]
    public void StaticPropertyAccess_ZeroArityMatchesAny()
    {
        var source = """
int i = object.P;

static class E1
{
    extension(object)
    {
        public static int P => 42;
    }
}

static class E2
{
    extension(object)
    {
        public static void P<T>() => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS9286: 'object' does not contain a definition for 'P' and no accessible extension member 'P' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // int i = object.P;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "object.P").WithArguments("object", "P").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.P");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 E1.<>E__0.P { get; }", "void E2.<>E__0.P<T>()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void StaticPropertyAccess_NonZeroArity()
    {
        var source = """
int i = object.P<int>;

static class E1
{
    extension(object)
    {
        public static int P => 42;
    }
}

static class E2
{
    extension(object)
    {
        public static void P<T>() => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,16): error CS0428: Cannot convert method group 'P' to non-delegate type 'int'. Did you intend to invoke the method?
            // int i = object.P<int>;
            Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "P<int>").WithArguments("P", "int").WithLocation(1, 16));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.P<int>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void E2.<>E__0.P<System.Int32>()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void StaticMethodAccess_NonZeroArity()
    {
        var source = """
object.M<int>();

static class E1
{
    extension(object)
    {
        public static void M() { }
        public static void M<T1, T2>() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'M'
            // object.M<int>();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M<int>").WithArguments("object", "M").WithLocation(1, 8));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M<int>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void E1.<>E__0.M()", "void E1.<>E__0.M<T1, T2>()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void E1.<>E__0.M()", "void E1.<>E__0.M<T1, T2>()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void AddressOf_TypeReceiver()
    {
        var src = """
unsafe class C
{
    static void Main()
    {
        delegate*<string, object, void> ptr = &C.M;
        ptr("ran", null);
    }
}

static class E
{
    extension(C)
    {
        public static void M(string s, object o) { System.Console.Write(s); }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugExe);
        comp.VerifyEmitDiagnostics();
        var verifier = CompileAndVerify(comp, expectedOutput: "ran", verify: Verification.Fails with { ILVerifyMessage = "[Main]: ImportCalli not implemented" });
        verifier.VerifyIL("C.Main", """
{
  // Code size       24 (0x18)
  .maxstack  3
  .locals init (delegate*<string, object, void> V_0, //ptr
                delegate*<string, object, void> V_1)
  IL_0000:  nop
  IL_0001:  ldftn      "void E.M(string, object)"
  IL_0007:  stloc.0
  IL_0008:  ldloc.0
  IL_0009:  stloc.1
  IL_000a:  ldstr      "ran"
  IL_000f:  ldnull
  IL_0010:  ldloc.1
  IL_0011:  calli      "delegate*<string, object, void>"
  IL_0016:  nop
  IL_0017:  ret
} 
""");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Equal("void E.<>E__0.M(System.String s, System.Object o)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void AddressOf_InstanceReceiver()
    {
        var src = """
unsafe class C
{
    static void Main()
    {
        C c = new C();
        delegate*<string, object, void> ptr = &c.M;
        ptr("ran", null);

        delegate*<string, object, void> ptr2 = &c.M2;
    }
}

static class E
{
    extension(C)
    {
        public void M(string s, object o) { System.Console.Write(s); }
    }
    public static void M2(this C c, string s, object o) { System.Console.Write(s); }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugExe);
        comp.VerifyEmitDiagnostics(
            // (6,48): error CS8759: Cannot create a function pointer for 'E.extension(C).M(string, object)' because it is not a static method
            //         delegate*<string, object, void> ptr = &c.M;
            Diagnostic(ErrorCode.ERR_FuncPtrMethMustBeStatic, "c.M").WithArguments("E.extension(C).M(string, object)").WithLocation(6, 48),
            // (9,48): error CS8788: Cannot use an extension method with a receiver as the target of a '&' operator.
            //         delegate*<string, object, void> ptr2 = &c.M2;
            Diagnostic(ErrorCode.ERR_CannotUseReducedExtensionMethodInAddressOf, "&c.M2").WithLocation(9, 48));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "c.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void AddressOf_AmbiguousBestMethod()
    {
        var src = """
unsafe class C
{
    static void M1()
    {
        delegate*<string, string, void> ptr = &C.M;
    }
}

static class E
{
    extension(C)
    {
        public static void M(string s, object o) {}
        public static void M(object o, string s) {}
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyEmitDiagnostics(
            // (5,48): error CS0121: The call is ambiguous between the following methods or properties: 'E.extension(C).M(string, object)' and 'E.extension(C).M(object, string)'
            //         delegate*<string, string, void> ptr = &C.M;
            Diagnostic(ErrorCode.ERR_AmbigCall, "C.M").WithArguments("E.extension(C).M(string, object)", "E.extension(C).M(object, string)").WithLocation(5, 48));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void E.<>E__0.M(System.String s, System.Object o)", "void E.<>E__0.M(System.Object o, System.String s)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void AddressOf_TypeReceiver_UnmanagedCallersOnly_01()
    {
        var src = """
unsafe class C
{
    static void Main()
    {
        delegate*<void> ptr = &C.M;
        delegate*<void> ptr2 = &E.M;
    }
}

static class E
{
    extension(C)
    {
        [System.Runtime.InteropServices.UnmanagedCallersOnly]
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugExe, targetFramework: TargetFramework.Net90);
        comp.VerifyEmitDiagnostics(
            // (5,32): error CS8786: Calling convention of 'E.extension(C).M()' is not compatible with 'Default'.
            //         delegate*<void> ptr = &C.M;
            Diagnostic(ErrorCode.ERR_WrongFuncPtrCallingConvention, "C.M").WithArguments("E.extension(C).M()", "Default").WithLocation(5, 32),
            // (6,33): error CS8786: Calling convention of 'E.M()' is not compatible with 'Default'.
            //         delegate*<void> ptr2 = &E.M;
            Diagnostic(ErrorCode.ERR_WrongFuncPtrCallingConvention, "E.M").WithArguments("E.M()", "Default").WithLocation(6, 33));
    }

    [Fact]
    public void AddressOf_TypeReceiver_UnmanagedCallersOnly_02()
    {
        var src = """
unsafe class C
{
    static void Main()
    {
        delegate* unmanaged<void> ptr = &C.M;
        delegate* unmanaged<void> ptr2 = &E.M;
    }
}

static class E
{
    extension(C)
    {
        [System.Runtime.InteropServices.UnmanagedCallersOnly]
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugExe, targetFramework: TargetFramework.Net90);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void TwoExtensions_MethodAndProperty()
    {
        var src = """
System.Console.Write(object.M());

static class E1
{
    extension(object)
    {
        public static string M() => throw null;
    }
}

static class E2
{
    extension(object)
    {
        public static System.Func<string> M => null;
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics(
            // (1,22): error CS9286: 'object' does not contain a definition for 'M' and no accessible extension member 'M' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // System.Console.Write(object.M());
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "object.M").WithArguments("object", "M").WithLocation(1, 22));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);

        Assert.Equal(["System.String E1.<>E__0.M()", "System.Func<System.String> E2.<>E__0.M { get; }"],
            model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());

        Assert.Empty(model.GetMemberGroup(memberAccess)); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : consider handling BoundBadExpression better
    }

    [Fact]
    public void Nameof_Static_Method()
    {
        var src = """
System.Console.Write(nameof(C.Method));

class C { }

static class E
{
    extension(C)
    {
        public static string Method() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,29): error CS8093: Extension method groups are not allowed as an argument to 'nameof'.
            // System.Console.Write(nameof(C.Method));
            Diagnostic(ErrorCode.ERR_NameofExtensionMethod, "C.Method").WithLocation(1, 29));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E.<>E__0.Method()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void Nameof_Instance_Method()
    {
        var src = """
C c = null;
_ = nameof(c.Method);

class C { }

static class E
{
    extension(C)
    {
        public string Method() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,12): error CS8093: Extension method groups are not allowed as an argument to 'nameof'.
            // _ = nameof(c.Method);
            Diagnostic(ErrorCode.ERR_NameofExtensionMethod, "c.Method").WithLocation(2, 12));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "c.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
    }

    [Fact]
    public void Nameof_Static_Property()
    {
        var src = """
System.Console.Write(nameof(C.Property));

class C { }

static class E
{
    extension(C)
    {
        public static string Property => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Property").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property");
        Assert.Equal("System.String E.<>E__0.Property { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void Nameof_Static_WrongArityMethod()
    {
        var src = """
System.Console.Write(nameof(C.Method));

class C { }

static class E
{
    extension(C)
    {
        public static string Method<T>() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,29): error CS8093: Extension method groups are not allowed as an argument to 'nameof'.
            // System.Console.Write(nameof(C.Method));
            Diagnostic(ErrorCode.ERR_NameofExtensionMethod, "C.Method").WithLocation(1, 29));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.String E.<>E__0.Method<T>()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void Nameof_Instance_Property()
    {
        var src = """
C c = null;
System.Console.Write(nameof(c.Property));

class C { }

static class E
{
    extension(C)
    {
        public string Property => "Property";
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : should we get an error as with methods?
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Property").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "c.Property");
        Assert.Equal("System.String E.<>E__0.Property { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void Nameof_Static_Property_Generic_01()
    {
        var src = """
System.Console.Write(nameof(C.Property));

class C : I<string> { }
interface I<T> { }

static class E
{
    extension<T>(I<T> i)
    {
        public static string Property => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "Property").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property");
        Assert.Equal("System.String E.<>E__0<System.String>.Property { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void Nameof_Static_Property_Generic_02()
    {
        var src = """
System.Console.Write(nameof(C.Property));

class C : I<string>, I<int> { }
interface I<T> { }

static class E
{
    extension<T>(I<T> i)
    {
        public static string Property => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,29): error CS9286: 'C' does not contain a definition for 'Property' and no accessible extension member 'Property' for receiver of type 'C' could be found (are you missing a using directive or an assembly reference?)
            // System.Console.Write(nameof(C.Property));
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "C.Property").WithArguments("C", "Property").WithLocation(1, 29));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C.Property");
        Assert.Equal("System.String E.<>E__0<T>.Property { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void Nameof_Overloads_01()
    {
        var src = """
System.Console.Write($"{nameof(object.M)} ");

static class E
{
    extension(object)
    {
        public static void M() { }
        public static void M(int i) { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,32): error CS8093: Extension method groups are not allowed as an argument to 'nameof'.
            // System.Console.Write($"{nameof(object.M)} ");
            Diagnostic(ErrorCode.ERR_NameofExtensionMethod, "object.M").WithLocation(1, 32));
    }

    [Fact]
    public void Nameof_Overloads_02()
    {
        var src = """
System.Console.Write($"{nameof(object.M)} ");

static class E1
{
    extension<T>(T) where T : class
    {
        public static void M() { }
    }
}

static class E2
{
    extension<T>(T) where T : struct
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,32): error CS8093: Extension method groups are not allowed as an argument to 'nameof'.
            // System.Console.Write($"{nameof(object.M)} ");
            Diagnostic(ErrorCode.ERR_NameofExtensionMethod, "object.M").WithLocation(1, 32));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void E1.<>E__0<System.Object>.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void E1.<>E__0<System.Object>.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void Nameof_SimpleName()
    {
        var src = """
class C
{
    void M()
    {
        _ = nameof(Method);
        _ = nameof(Property);
    }
}

static class E
{
    extension(object)
    {
        public static void Method() { }
        public static int Property => 0;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,20): error CS0103: The name 'Method' does not exist in the current context
            //         _ = nameof(Method);
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Method").WithArguments("Method").WithLocation(5, 20),
            // (6,20): error CS0103: The name 'Property' does not exist in the current context
            //         _ = nameof(Property);
            Diagnostic(ErrorCode.ERR_NameNotInContext, "Property").WithArguments("Property").WithLocation(6, 20));
    }

    [Fact]
    public void Nameof_NoParameter()
    {
        var src = """
class C
{
    void M()
    {
        System.Console.Write(nameof());
    }
}

static class E
{
    extension(C c)
    {
        public string nameof() => throw null;
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (5,30): error CS0103: The name 'nameof' does not exist in the current context
            //         System.Console.Write(nameof());
            Diagnostic(ErrorCode.ERR_NameNotInContext, "nameof").WithArguments("nameof").WithLocation(5, 30));
    }

    [Fact]
    public void Nameof_SingleParameter()
    {
        var src = """
class C
{
    public static void Main()
    {
        string x = "";
        System.Console.Write(nameof(x));
    }
}

static class E
{
    extension(C c)
    {
        public string nameof(string s) => throw null;
    }
}
""";

        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "x").VerifyDiagnostics();
    }

    [Fact]
    public void StaticMethodInvocation_TypeParameter_InNameof()
    {
        var source = """
public static class C
{
    static void M<T>()
    {
        _ = nameof(T.Method);
    }

    extension<T>(T)
    {
        public static void Method() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // 0.cs(5,20): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //         _ = nameof(T.Method);
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(5, 20));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "T.Method");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void SymbolInfoForMethodGroup03()
    {
        var source = """
public class A { }

static class E
{
    extension(A a)
    {
        public string Extension() { return null; }
    }
}
public class Program
{
    public static void Main(string[] args)
    {
        A a = null;
        _ = nameof(a.Extension);
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (15,20): error CS8093: Extension method groups are not allowed as an argument to 'nameof'.
            //         _ = nameof(a.Extension);
            Diagnostic(ErrorCode.ERR_NameofExtensionMethod, "a.Extension").WithLocation(15, 20));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "a.Extension");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void StaticMethodInvocation_PartialStaticClass()
    {
        var source = """
object.M();
object.M2();

public static partial class C
{
    extension(object)
    {
        public static void M() { System.Console.Write("ran "); }
    }
}

public static partial class C
{
    extension(object)
    {
        public static void M2() { System.Console.Write("ran2"); }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran ran2").VerifyDiagnostics();
    }

    [Fact]
    public void StaticMethodInvocation_TupleTypeReceiver()
    {
        var src = """
(string, string).M();
(int a, int b).M();
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : consider parsing this
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,2): error CS1525: Invalid expression term 'string'
            // (string, string).M();
            Diagnostic(ErrorCode.ERR_InvalidExprTerm, "string").WithArguments("string").WithLocation(1, 2),
            // (1,10): error CS1525: Invalid expression term 'string'
            // (string, string).M();
            Diagnostic(ErrorCode.ERR_InvalidExprTerm, "string").WithArguments("string").WithLocation(1, 10),
            // (2,2): error CS8185: A declaration is not allowed in this context.
            // (int a, int b).M();
            Diagnostic(ErrorCode.ERR_DeclarationExpressionNotPermitted, "int a").WithLocation(2, 2),
            // (2,2): error CS0165: Use of unassigned local variable 'a'
            // (int a, int b).M();
            Diagnostic(ErrorCode.ERR_UseDefViolation, "int a").WithArguments("a").WithLocation(2, 2),
            // (2,9): error CS8185: A declaration is not allowed in this context.
            // (int a, int b).M();
            Diagnostic(ErrorCode.ERR_DeclarationExpressionNotPermitted, "int b").WithLocation(2, 9),
            // (2,9): error CS0165: Use of unassigned local variable 'b'
            // (int a, int b).M();
            Diagnostic(ErrorCode.ERR_UseDefViolation, "int b").WithArguments("b").WithLocation(2, 9),
            // (2,16): error CS1061: '(int a, int b)' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type '(int a, int b)' could be found (are you missing a using directive or an assembly reference?)
            // (int a, int b).M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("(int a, int b)", "M").WithLocation(2, 16));
    }

    [Fact]
    public void StaticMethodInvocation_TupleTypeReceiver_02()
    {
        var src = """
((string, string)).M();
((int a, int b)).M();
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : consider parsing this
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,3): error CS1525: Invalid expression term 'string'
            // ((string, string)).M();
            Diagnostic(ErrorCode.ERR_InvalidExprTerm, "string").WithArguments("string").WithLocation(1, 3),
            // (1,11): error CS1525: Invalid expression term 'string'
            // ((string, string)).M();
            Diagnostic(ErrorCode.ERR_InvalidExprTerm, "string").WithArguments("string").WithLocation(1, 11),
            // (2,3): error CS8185: A declaration is not allowed in this context.
            // ((int a, int b)).M();
            Diagnostic(ErrorCode.ERR_DeclarationExpressionNotPermitted, "int a").WithLocation(2, 3),
            // (2,3): error CS0165: Use of unassigned local variable 'a'
            // ((int a, int b)).M();
            Diagnostic(ErrorCode.ERR_UseDefViolation, "int a").WithArguments("a").WithLocation(2, 3),
            // (2,10): error CS8185: A declaration is not allowed in this context.
            // ((int a, int b)).M();
            Diagnostic(ErrorCode.ERR_DeclarationExpressionNotPermitted, "int b").WithLocation(2, 10),
            // (2,10): error CS0165: Use of unassigned local variable 'b'
            // ((int a, int b)).M();
            Diagnostic(ErrorCode.ERR_UseDefViolation, "int b").WithArguments("b").WithLocation(2, 10),
            // (2,18): error CS1061: '(int a, int b)' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type '(int a, int b)' could be found (are you missing a using directive or an assembly reference?)
            // ((int a, int b)).M();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M").WithArguments("(int a, int b)", "M").WithLocation(2, 18));
    }

    [Fact]
    public void StaticMethodInvocation_PointerTypeReceiver()
    {
        var src = """
unsafe class C
{
    void M()
    {
        int*.M();
        delegate*<void>.M();
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : consider parsing this
        var comp = CreateCompilation(src, options: TestOptions.UnsafeDebugDll);
        comp.VerifyDiagnostics(
            // (5,13): error CS1001: Identifier expected
            //         int*.M();
            Diagnostic(ErrorCode.ERR_IdentifierExpected, ".").WithLocation(5, 13),
            // (5,13): error CS1003: Syntax error, ',' expected
            //         int*.M();
            Diagnostic(ErrorCode.ERR_SyntaxError, ".").WithArguments(",").WithLocation(5, 13),
            // (5,14): error CS1002: ; expected
            //         int*.M();
            Diagnostic(ErrorCode.ERR_SemicolonExpected, "M").WithLocation(5, 14),
            // (6,17): error CS1514: { expected
            //         delegate*<void>.M();
            Diagnostic(ErrorCode.ERR_LbraceExpected, "*").WithLocation(6, 17),
            // (6,17): warning CS8848: Operator '*' cannot be used here due to precedence. Use parentheses to disambiguate.
            //         delegate*<void>.M();
            Diagnostic(ErrorCode.WRN_PrecedenceInversion, "*").WithArguments("*").WithLocation(6, 17),
            // (6,18): error CS1525: Invalid expression term '<'
            //         delegate*<void>.M();
            Diagnostic(ErrorCode.ERR_InvalidExprTerm, "<").WithArguments("<").WithLocation(6, 18),
            // (6,19): error CS1525: Invalid expression term 'void'
            //         delegate*<void>.M();
            Diagnostic(ErrorCode.ERR_InvalidExprTerm, "void").WithArguments("void").WithLocation(6, 19),
            // (6,24): error CS1525: Invalid expression term '.'
            //         delegate*<void>.M();
            Diagnostic(ErrorCode.ERR_InvalidExprTerm, ".").WithArguments(".").WithLocation(6, 24));
    }

    [Fact]
    public void StaticMethodInvocation_DynamicTypeReceiver()
    {
        var src = """
dynamic.M();
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics(
            // (1,1): error CS0103: The name 'dynamic' does not exist in the current context
            // dynamic.M();
            Diagnostic(ErrorCode.ERR_NameNotInContext, "dynamic").WithArguments("dynamic").WithLocation(1, 1));
    }

    [Fact]
    public void DisplayString_Constraint()
    {
        var source = """
static class E
{
    extension<T>(T) where T : struct
    {
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(extension);

        var format = new SymbolDisplayFormat(genericsOptions: SymbolDisplayGenericsOptions.IncludeTypeParameters | SymbolDisplayGenericsOptions.IncludeTypeConstraints);
        Assert.Equal("extension<T>(T) where T : struct", symbol.ToDisplayString(format));
    }

    [Fact]
    public void DisplayString_Modifier()
    {
        var source = """
static class E
{
    extension(ref readonly int)
    {
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();
        var symbol = model.GetDeclaredSymbol(extension);

        var format = new SymbolDisplayFormat(parameterOptions: SymbolDisplayParameterOptions.IncludeType | SymbolDisplayParameterOptions.IncludeModifiers);
        Assert.Equal("extension(ref readonly Int32)", symbol.ToDisplayString(format));
    }

    [Fact]
    public void NameConflict_01_EnclosingStaticTypeNameWithExtensionTypeParameterName()
    {
        var src = """
static class Extensions
{
    extension<Extensions>(Extensions)
    {
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void NameConflict_02_EnclosingStaticTypeNameWithReceiverParameterName()
    {
        var src = """
static class Extensions
{
    extension(int Extensions)
    {
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void NameConflict_03_ExtensionTypeParameterNameWithReceiverParameterName()
    {
        var src = """
static class Extensions
{
#line 7
    extension<T>(T[] T)
    {
        void M1(){}
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (7,22): error CS9287: 'T': a receiver parameter cannot have the same name as an extension container type parameter
            //     extension<T>(T[] T)
            Diagnostic(ErrorCode.ERR_ReceiverParameterSameNameAsTypeParameter, "T").WithArguments("T").WithLocation(7, 22)
            );
    }

    [Fact]
    public void NameConflict_04_ExtensionTypeParameterNameWithMemberParameterName()
    {
        var src = """
static class Extensions
{
    extension<T>(T[] p)
    {
#line 14
        void M2(int T){}
        static void M3(int T){}
        int this[int T] => 0;
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (14,21): error CS9288: 'T': a parameter, local variable, or local function cannot have the same name as an extension container type parameter
            //         void M2(int T){}
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(14, 21),
            // (15,28): error CS9288: 'T': a parameter, local variable, or local function cannot have the same name as an extension container type parameter
            //         static void M3(int T){}
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(15, 28),
            // (16,22): error CS9288: 'T': a parameter, local variable, or local function cannot have the same name as an extension container type parameter
            //         int this[int T] => 0;
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(16, 22)
            );
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_05_ExtensionTypeParameterNameWithSetterValueParameter(bool isStatic)
    {
        var src = @"
static class Extensions
{
    extension<value>(value[] p)
    {
        " + (isStatic ? "static" : "") + @"
        int P11 {set{}}

        " + (isStatic ? "static" : "") + @"
        int P12 => 0;
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (4,15): warning CS8981: The type name 'value' only contains lower-cased ascii characters. Such names may become reserved for the language.
            //     extension<value>(value[] p)
            Diagnostic(ErrorCode.WRN_LowerCaseTypeName, "value").WithArguments("value").WithLocation(4, 15),
            // (7,18): error CS9294: 'value': an automatically-generated parameter name conflicts with an extension type parameter name
            //         int P11 {set{}}
            Diagnostic(ErrorCode.ERR_ValueParameterSameNameAsExtensionTypeParameter, "set").WithLocation(7, 18)
            );
    }

    [Fact]
    public void NameConflict_06_ExtensionTypeParameterNameWithSetterValueParameter()
    {
        var src = @"
static class Extensions
{
    extension<value>(value[] p)
    {
        int this[int i] {set{}}
        int this[long i] => 0;
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (4,15): warning CS8981: The type name 'value' only contains lower-cased ascii characters. Such names may become reserved for the language.
            //     extension<value>(value[] p)
            Diagnostic(ErrorCode.WRN_LowerCaseTypeName, "value").WithArguments("value").WithLocation(4, 15),
            // (6,26): error CS9294: 'value': an automatically-generated parameter name conflicts with an extension type parameter name
            //         int this[int i] {set{}}
            Diagnostic(ErrorCode.ERR_ValueParameterSameNameAsExtensionTypeParameter, "set").WithLocation(6, 26)
            );
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_07_ExtensionTypeParameterNameWithLocalFunctionParameterName(bool isStatic1, bool isStatic2)
    {
        var modifier1 = isStatic1 ? "static " : "";
        var modifier2 = isStatic2 ? "static " : "";

        var src = @"
#pragma warning disable CS8321 // The local function 'local' is declared but never used

static class Extensions
{
    extension<T>(T[] p)
    {
        " + modifier1 + @"void M4()
        {
            " + modifier2 + @"int local(int T)
            {
                return T;
            }
        }
        " + modifier1 + @"int P7
        {
            set
            {
                " + modifier2 + @"int local(int T)
                {
                    return T;
                }
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_08_ExtensionTypeParameterNameWithLambdaParameterName(bool isStatic1, bool isStatic2)
    {
        var modifier1 = isStatic1 ? "static " : "";
        var modifier2 = isStatic2 ? "static " : "";

        var src = @"
static class Extensions
{
    extension<T>(T[] p)
    {
        " + modifier1 + @"void M4()
        {
            System.Func<int, int> l = " + modifier2 + @"(int T) =>
            {
                return T;
            };
        }
        " + modifier1 + @"int P7
        {
            set
            {
                System.Func<int, int> l = " + modifier2 + @"(int T) =>
                {
                    return T;
                };
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_09_ExtensionTypeParameterNameWithLocalName(bool isStatic)
    {
        var modifier = isStatic ? "static " : "";

        var src = @"
static class Extensions
{
    extension<T>(T[] p)
    {
        " + modifier + @"int M4()
        {
#line 19
            int T = 0;
            return T;
        }
        " + modifier + @"int M5()
        {
            int T() => 0;
            return T();
        }
        " + modifier + @"int P7
        {
            get
            {
                int T = 0;
                return T;
            }
        }
        " + modifier + @"int P8
        {
            get
            {
                int T() => 0;
                return T();
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (19,17): error CS9288: 'T': a parameter, local variable, or local function cannot have the same name as an extension container type parameter
            //             int T = 0;
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(19, 17),
            // (24,17): error CS9288: 'T': a parameter, local variable, or local function cannot have the same name as an extension container type parameter
            //             int T() => 0;
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(24, 17),
            // (31,21): error CS9288: 'T': a parameter, local variable, or local function cannot have the same name as an extension container type parameter
            //                 int T = 0;
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(31, 21),
            // (39,21): error CS9288: 'T': a parameter, local variable, or local function cannot have the same name as an extension container type parameter
            //                 int T() => 0;
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(39, 21)
            );
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_10_ExtensionTypeParameterNameWithLocalNameInLocalFunction(bool isStatic1, bool isStatic2)
    {
        var modifier1 = isStatic1 ? "static " : "";
        var modifier2 = isStatic2 ? "static " : "";

        var src = @"
#pragma warning disable CS8321 // The local function 'local' is declared but never used

static class Extensions
{
    extension<T>(T[] p)
    {
        " + modifier1 + @"void M4()
        {
            " + modifier2 + @"int local()
            {
                int T = 0;
                return T;
            }
        }
        " + modifier1 + @"void M5()
        {
            " + modifier2 + @"int local()
            {
                int T() => 0;
                return T();
            }
        }
        " + modifier1 + @"int P7
        {
            set
            {
                " + modifier2 + @"int local()
                {
                    int T = 0;
                    return T;
                }
            }
        }
        " + modifier1 + @"int P8
        {
            set
            {
                " + modifier2 + @"int local()
                {
                    int T() => 0;
                    return T();
                }
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_11_ExtensionTypeParameterNameWithLocalNameInLambda(bool isStatic1, bool isStatic2)
    {
        var modifier1 = isStatic1 ? "static " : "";
        var modifier2 = isStatic2 ? "static " : "";

        var src = @"
static class Extensions
{
    extension<T>(T[] p)
    {
        " + modifier1 + @"void M4()
        {
            System.Func<int> l = " + modifier2 + @"() =>
            {
                int T = 0;
                return T;
            };
        }
        " + modifier1 + @"void M5()
        {
            System.Func<int> l = " + modifier2 + @"() =>
            {
                int T() => 0;
                return T();
            };
        }
        " + modifier1 + @"int P7
        {
            set
            {
                System.Func<int> l = " + modifier2 + @"() =>
                {
                    int T = 0;
                    return T;
                };
            }
        }
        " + modifier1 + @"int P8
        {
            set
            {
                System.Func<int> l = " + modifier2 + @"() =>
                {
                    int T() => 0;
                    return T();
                };
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void NameConflict_12_ExtensionTypeParameterNameWithAnotherExtensionTypeParameterName()
    {
        var src = """
static class Extensions
{
#line 55
    extension<T, T>(T[] p)
    {}
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (55,18): error CS0692: Duplicate type parameter 'T'
            //     extension<T, T>(T[] p)
            Diagnostic(ErrorCode.ERR_DuplicateTypeParameter, "T").WithArguments("T").WithLocation(55, 18),
            // (55,21): error CS0229: Ambiguity between 'T' and 'T'
            //     extension<T, T>(T[] p)
            Diagnostic(ErrorCode.ERR_AmbigMember, "T").WithArguments("T", "T").WithLocation(55, 21),
            // (55,25): error CS9295: The extended type 'T[]' must reference all the type parameters declared by the extension, but type parameter 'T' is not referenced.
            //     extension<T, T>(T[] p)
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "p").WithArguments("T[]", "T").WithLocation(55, 25),
            // (55,25): error CS9295: The extended type 'T[]' must reference all the type parameters declared by the extension, but type parameter 'T' is not referenced.
            //     extension<T, T>(T[] p)
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "p").WithArguments("T[]", "T").WithLocation(55, 25)
            );
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_13_ExtensionTypeParameterNameWithMemberTypeParameterName(bool isStatic)
    {
        var modifier = isStatic ? "static" : "";

        var src = @"
static class Extensions
{
    extension<T>(T[] p)
    {
        " + modifier + @"
#line 60
        void M9<T>(){}

        " + modifier + @"
#line 61
        void M10<T, T>(){}
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (60,17): error CS9289: Type parameter 'T' has the same name as an extension container type parameter
            //         void M9<T>(){}
            Diagnostic(ErrorCode.ERR_TypeParameterSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(60, 17),
            // (61,18): error CS9289: Type parameter 'T' has the same name as an extension container type parameter
            //         void M10<T, T>(){}
            Diagnostic(ErrorCode.ERR_TypeParameterSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(61, 18),
            // (61,21): error CS9289: Type parameter 'T' has the same name as an extension container type parameter
            //         void M10<T, T>(){}
            Diagnostic(ErrorCode.ERR_TypeParameterSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(61, 21)
            );
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_14_ExtensionTypeParameterNameWithLocalFunctionTypeParameterName(bool isStatic1, bool isStatic2)
    {
        var modifier1 = isStatic1 ? "static " : "";
        var modifier2 = isStatic2 ? "static" : "";

        var src = @"
#pragma warning disable CS8321 // The local function 'local' is declared but never used

static class Extensions
{
    extension<T>(T[] p)
    {
        " + modifier1 + @"void M4()
        {
            " + modifier2 + @"
            T local<T>(T p1)
            {
                return p1;
            }
        }
        " + modifier1 + @"void M5()
        {
            void local2()
            {
                " + modifier2 + @"
                T local<T>(T p1)
                {
                    return p1;
                }
            }
        }
        " + modifier1 + @"int P7
        {
            set
            {
                " + modifier2 + @"
                T local<T>(T p1)
                {
                    return p1;
                }
            }
        }
        " + modifier1 + @"int P8
        {
            set
            {
                void local2()
                {
                    " + modifier2 + @"
                    T local<T>(T p1)
                    {
                        return p1;
                    }
                }
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : We might need to add a new warning if we don't want to refer to extension as a type in diagnostics

        comp.VerifyEmitDiagnostics(
            // (11,21): warning CS0693: Type parameter 'T' has the same name as the type parameter from outer type 'Extensions.extension<T>(T[])'
            //             T local<T>(T p1)
            Diagnostic(ErrorCode.WRN_TypeParameterSameAsOuterTypeParameter, "T").WithArguments("T", "Extensions.extension<T>(T[])").WithLocation(11, 21),
            // (21,25): warning CS0693: Type parameter 'T' has the same name as the type parameter from outer type 'Extensions.extension<T>(T[])'
            //                 T local<T>(T p1)
            Diagnostic(ErrorCode.WRN_TypeParameterSameAsOuterTypeParameter, "T").WithArguments("T", "Extensions.extension<T>(T[])").WithLocation(21, 25),
            // (32,25): warning CS0693: Type parameter 'T' has the same name as the type parameter from outer type 'Extensions.extension<T>(T[])'
            //                 T local<T>(T p1)
            Diagnostic(ErrorCode.WRN_TypeParameterSameAsOuterTypeParameter, "T").WithArguments("T", "Extensions.extension<T>(T[])").WithLocation(32, 25),
            // (45,29): warning CS0693: Type parameter 'T' has the same name as the type parameter from outer type 'Extensions.extension<T>(T[])'
            //                     T local<T>(T p1)
            Diagnostic(ErrorCode.WRN_TypeParameterSameAsOuterTypeParameter, "T").WithArguments("T", "Extensions.extension<T>(T[])").WithLocation(45, 29)
            );
    }

    [Fact]
    public void NameConflict_15_ExtensionTypeParameterNameWithMemberName()
    {
        var src = """
static class Extensions
{
    extension<T>(C1<T> p)
    {
        int T()
        {
            return T;
        }
    }

    extension<T>(C2<T> p)
    {
        int T => T;
    }

    extension<T>(C3<T> p)
    {
        [System.Runtime.CompilerServices.IndexerName("T")]
        int this[int x] => T;
    }

    extension<T>(C4<T> p)
    {
        static int T()
        {
            return T;
        }
    }

    extension<T>(C5<T> p)
    {
        static int T => T;
    }

    extension<get_P>(C6<get_P> p)
    {
        int P => 0;
    }

    extension<get_Indexer>(C7<get_Indexer> p)
    {
        [System.Runtime.CompilerServices.IndexerName("Indexer")]
        int this[int x] => 0;
    }

    extension<get_Item>(C8<get_Item> p)
    {
        int this[int x] => 0;
    }
}

class C1<T> {} 
class C2<T> {} 
class C3<T> {} 
class C4<T> {} 
class C5<T> {} 
class C6<T> {} 
class C7<T> {} 
class C8<T> {} 
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (7,20): error CS0119: 'T' is a type, which is not valid in the given context
            //             return T;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "T").WithArguments("T", "type").WithLocation(7, 20),
            // (13,18): error CS0119: 'T' is a type, which is not valid in the given context
            //         int T => T;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "T").WithArguments("T", "type").WithLocation(13, 18),
            // (19,28): error CS0119: 'T' is a type, which is not valid in the given context
            //         int this[int x] => T;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "T").WithArguments("T", "type").WithLocation(19, 28),
            // (26,20): error CS0119: 'T' is a type, which is not valid in the given context
            //             return T;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "T").WithArguments("T", "type").WithLocation(26, 20),
            // (32,25): error CS0119: 'T' is a type, which is not valid in the given context
            //         static int T => T;
            Diagnostic(ErrorCode.ERR_BadSKunknown, "T").WithArguments("T", "type").WithLocation(32, 25)
            );
    }

    [Fact]
    public void NameConflict_16_ReceiverParameterNameWithMemberName()
    {
        var src = """
static class Extensions
{
    extension(int M1)
    {
        void M1()
        {
            int x = M1;
            x++;
        }
    }

    extension(long P1)
    {
        int P1
        {
            get
            {
                P1 = long.MaxValue;
                return 0;
            }
        }
    }

    extension(byte Indexer)
    {
        [System.Runtime.CompilerServices.IndexerName("Indexer")]
        int this[int y]
        {
            get
            {
                byte x = Indexer;
                x++;
                return 0;
            }
        }
    }

    extension(short M1)
    {
        static void M1()
        {
            short x = M1;
            x++;
        }
    }

    extension(string P1)
    {
        static int P1
        {
            get
            {
                P1 = "val";
                return 0;
            }
        }
    }

    extension(int[] get_P)
    {
        int P => 0;
    }

    extension(long[] get_Indexer)
    {
        [System.Runtime.CompilerServices.IndexerName("Indexer")]
        int this[int x] => 0;
    }

    extension(byte[] get_Item)
    {
        int this[int x] => 0;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (42,23): error CS9293: Cannot use extension parameter 'short M1' in this context.
            //             short x = M1;
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "M1").WithArguments("short M1").WithLocation(42, 23),
            // (53,17): error CS9293: Cannot use extension parameter 'string P1' in this context.
            //                 P1 = "val";
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "P1").WithArguments("string P1").WithLocation(53, 17)
            );
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_17_ReceiverParameterNameWithMemberTypeParameterName(bool isStatic)
    {
        var modifier = isStatic ? "static" : "";

        var src = @"
static class Extensions
{
    extension(int T)
    {
        " + modifier + @"
#line 5
        void M1<T>(){}
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,17): error CS9292: Type parameter 'T' has the same name as an extension parameter
            //         void M1<T>(){}
            Diagnostic(ErrorCode.ERR_TypeParameterSameNameAsExtensionParameter, "T").WithArguments("T").WithLocation(5, 17)
            );
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_18_ReceiverParameterNameWithLocalFunctionTypeParameterName(bool isStatic1, bool isStatic2)
    {
        var modifier1 = isStatic1 ? "static " : "";
        var modifier2 = isStatic2 ? "static" : "";

        var src = @"
#pragma warning disable CS8321 // The local function 'local' is declared but never used

static class Extensions
{
    extension(int T)
    {
        " + modifier1 + @"void M4()
        {
            " + modifier2 + @"
            T local<T>(T p1)
            {
                return p1;
            }
        }
        " + modifier1 + @"void M5()
        {
            void local2()
            {
                " + modifier2 + @"
                T local<T>(T p1)
                {
                    return p1;
                }
            }
        }
        " + modifier1 + @"int P7
        {
            set
            {
                " + modifier2 + @"
                T local<T>(T p1)
                {
                    return p1;
                }
            }
        }
        " + modifier1 + @"int P8
        {
            set
            {
                void local2()
                {
                    " + modifier2 + @"
                    T local<T>(T p1)
                    {
                        return p1;
                    }
                }
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void NameConflict_19_ReceiverParameterNameWithMemberParameterName()
    {
        var src = """
static class Extensions
{
    extension(int p)
    {
        void M2(int p){}
        static void M3(int p){}
        int this[int p] => 0;
        void M3(int p2, int p2) {}
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,21): error CS9290: 'p': a parameter, local variable, or local function cannot have the same name as an extension parameter
            //         void M2(int p){}
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionParameter, "p").WithArguments("p").WithLocation(5, 21),
            // (6,28): error CS9290: 'p': a parameter, local variable, or local function cannot have the same name as an extension parameter
            //         static void M3(int p){}
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionParameter, "p").WithArguments("p").WithLocation(6, 28),
            // (7,22): error CS9290: 'p': a parameter, local variable, or local function cannot have the same name as an extension parameter
            //         int this[int p] => 0;
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionParameter, "p").WithArguments("p").WithLocation(7, 22),
            // (8,29): error CS0100: The parameter name 'p2' is a duplicate
            //         void M3(int p2, int p2) {}
            Diagnostic(ErrorCode.ERR_DuplicateParamName, "p2").WithArguments("p2").WithLocation(8, 29)
            );
    }

    [Fact]
    public void NameConflict_20_ReceiverParameterNameWithSetterValueParameter()
    {
        var src = """
static class Extensions
{
    extension(int value)
    {
        int P1 {get=>0;}
        int P2 {set{}}
        int this[int x] {get=>0;}
        int this[long x] {set{}}
        int this[long x, int value] {set{}}
        static int P6 {get=>0;}
        static int P7 {set{}}
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (6,17): error CS9291: 'value': an automatically-generated parameter name conflicts with an extension parameter name
            //         int P2 {set{}}
            Diagnostic(ErrorCode.ERR_ValueParameterSameNameAsExtensionParameter, "set").WithLocation(6, 17),
            // (8,27): error CS9291: 'value': an automatically-generated parameter name conflicts with an extension parameter name
            //         int this[long x] {set{}}
            Diagnostic(ErrorCode.ERR_ValueParameterSameNameAsExtensionParameter, "set").WithLocation(8, 27),
            // (9,30): error CS9290: 'value': a parameter, local variable, or local function cannot have the same name as an extension parameter
            //         int this[long x, int value] {set{}}
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionParameter, "value").WithArguments("value").WithLocation(9, 30),
            // (9,30): error CS0316: The parameter name 'value' conflicts with an automatically-generated parameter name
            //         int this[long x, int value] {set{}}
            Diagnostic(ErrorCode.ERR_DuplicateGeneratedName, "value").WithArguments("value").WithLocation(9, 30),
            // (9,38): error CS9291: 'value': an automatically-generated parameter name conflicts with an extension parameter name
            //         int this[long x, int value] {set{}}
            Diagnostic(ErrorCode.ERR_ValueParameterSameNameAsExtensionParameter, "set").WithLocation(9, 38),
            // (11,24): error CS9291: 'value': an automatically-generated parameter name conflicts with an extension parameter name
            //         static int P7 {set{}}
            Diagnostic(ErrorCode.ERR_ValueParameterSameNameAsExtensionParameter, "set").WithLocation(11, 24)
            );
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_21_ReceiverParameterNameWithLocalFunctionParameterName(bool isStatic1, bool isStatic2)
    {
        var modifier1 = isStatic1 ? "static " : "";
        var modifier2 = isStatic2 ? "static " : "";

        var src = @"
#pragma warning disable CS8321 // The local function 'local' is declared but never used

static class Extensions
{
    extension(string p)
    {
        " + modifier1 + @"void M4()
        {
            " + modifier2 + @"int local(int p)
            {
                return p;
            }
        }
        " + modifier1 + @"int P7
        {
            set
            {
                " + modifier2 + @"int local(int p)
                {
                    return p;
                }
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_22_ReceiverParameterNameWithLambdaParameterName(bool isStatic1, bool isStatic2)
    {
        var modifier1 = isStatic1 ? "static " : "";
        var modifier2 = isStatic2 ? "static " : "";

        var src = @"
static class Extensions
{
    extension(string p)
    {
        " + modifier1 + @"void M4()
        {
            System.Func<int, int> l = " + modifier2 + @"(int p) =>
            {
                return p;
            };
        }
        " + modifier1 + @"int P7
        {
            set
            {
                System.Func<int, int> l = " + modifier2 + @"(int p) =>
                {
                    return p;
                };
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_23_ReceiverParameterNameWithLocalName(bool isStatic)
    {
        var modifier = isStatic ? "static " : "";

        var src = @"
static class Extensions
{
    extension(int p)
    {
        " + modifier + @"int M4()
        {
#line 7
            int p = 0;
            return p;
        }
        " + modifier + @"int M5()
        {
            int p() => 0;
            return p();
        }
        " + modifier + @"int P7
        {
            get
            {
                int p = 0;
                return p;
            }
        }
        " + modifier + @"int P8
        {
            get
            {
                int p() => 0;
                return p();
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (7,17): error CS0136: A local or parameter named 'p' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
            //             int p = 0;
            Diagnostic(ErrorCode.ERR_LocalIllegallyOverrides, "p").WithArguments("p").WithLocation(7, 17),
            // (12,17): error CS0136: A local or parameter named 'p' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
            //             int p() => 0;
            Diagnostic(ErrorCode.ERR_LocalIllegallyOverrides, "p").WithArguments("p").WithLocation(12, 17),
            // (19,21): error CS0136: A local or parameter named 'p' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
            //                 int p = 0;
            Diagnostic(ErrorCode.ERR_LocalIllegallyOverrides, "p").WithArguments("p").WithLocation(19, 21),
            // (27,21): error CS0136: A local or parameter named 'p' cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter
            //                 int p() => 0;
            Diagnostic(ErrorCode.ERR_LocalIllegallyOverrides, "p").WithArguments("p").WithLocation(27, 21)
            );
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_24_ReceiverParameterNameWithLocalNameInLocalFunction(bool isStatic1, bool isStatic2)
    {
        var modifier1 = isStatic1 ? "static " : "";
        var modifier2 = isStatic2 ? "static " : "";

        var src = @"
#pragma warning disable CS8321 // The local function 'local' is declared but never used

static class Extensions
{
    extension(string p)
    {
        " + modifier1 + @"void M4()
        {
            " + modifier2 + @"int local()
            {
                int p = 0;
                return p;
            }
        }
        " + modifier1 + @"void M5()
        {
            " + modifier2 + @"int local()
            {
                int p() => 0;
                return p();
            }
        }
        " + modifier1 + @"int P7
        {
            set
            {
                " + modifier2 + @"int local()
                {
                    int p = 0;
                    return p;
                }
            }
        }
        " + modifier1 + @"int P8
        {
            set
            {
                " + modifier2 + @"int local()
                {
                    int p() => 0;
                    return p();
                }
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Theory]
    [CombinatorialData]
    public void NameConflict_25_ReceiverParameterNameWithLocalNameInLambda(bool isStatic1, bool isStatic2)
    {
        var modifier1 = isStatic1 ? "static " : "";
        var modifier2 = isStatic2 ? "static " : "";

        var src = @"
static class Extensions
{
    extension(string p)
    {
        " + modifier1 + @"void M4()
        {
            System.Func<int> l = " + modifier2 + @"() =>
            {
                int p = 0;
                return p;
            };
        }
        " + modifier1 + @"void M5()
        {
            System.Func<int> l = " + modifier2 + @"() =>
            {
                int p() => 0;
                return p();
            };
        }
        " + modifier1 + @"int P7
        {
            set
            {
                System.Func<int> l = " + modifier2 + @"() =>
                {
                    int p = 0;
                    return p;
                };
            }
        }
        " + modifier1 + @"int P8
        {
            set
            {
                System.Func<int> l = " + modifier2 + @"() =>
                {
                    int p() => 0;
                    return p();
                };
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void NameConflict_26_ExampleFromSpec()
    {
        var src = @"
using System.Linq;

public static class E
{
    extension<T>(T[] ts)
    {
        public bool M1(T t) => ts.Contains(t);        // `T` and `ts` are in scope
        public static bool M2(T t) => ts.Contains(t); // Error: Cannot refer to `ts` from static context
        public void M3(int T, string ts) { }          // Error: Cannot reuse names `T` and `ts`
        public void M4<T, ts>(string s) { }           // Error: Cannot reuse names `T` and `ts`
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (9,39): error CS9293: Cannot use extension parameter 'T[] ts' in this context.
            //         public static bool M2(T t) => ts.Contains(t); // Error: Cannot refer to `ts` from static context
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "ts").WithArguments("T[] ts").WithLocation(9, 39),
            // (10,28): error CS9288: 'T': a parameter, local variable, or local function cannot have the same name as an extension container type parameter
            //         public void M3(int T, string ts) { }          // Error: Cannot reuse names `T` and `ts`
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(10, 28),
            // (10,38): error CS9290: 'ts': a parameter, local variable, or local function cannot have the same name as an extension parameter
            //         public void M3(int T, string ts) { }          // Error: Cannot reuse names `T` and `ts`
            Diagnostic(ErrorCode.ERR_LocalSameNameAsExtensionParameter, "ts").WithArguments("ts").WithLocation(10, 38),
            // (11,24): error CS9289: Type parameter 'T' has the same name as an extension container type parameter
            //         public void M4<T, ts>(string s) { }           // Error: Cannot reuse names `T` and `ts`
            Diagnostic(ErrorCode.ERR_TypeParameterSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(11, 24),
            // (11,27): warning CS8981: The type name 'ts' only contains lower-cased ascii characters. Such names may become reserved for the language.
            //         public void M4<T, ts>(string s) { }           // Error: Cannot reuse names `T` and `ts`
            Diagnostic(ErrorCode.WRN_LowerCaseTypeName, "ts").WithArguments("ts").WithLocation(11, 27),
            // (11,27): error CS9292: Type parameter 'ts' has the same name as an extension parameter
            //         public void M4<T, ts>(string s) { }           // Error: Cannot reuse names `T` and `ts`
            Diagnostic(ErrorCode.ERR_TypeParameterSameNameAsExtensionParameter, "ts").WithArguments("ts").WithLocation(11, 27)
            );
    }

    [Fact]
    public void NameConflict_27_ExampleFromSpec()
    {
        var src = @"
public static class E
{
    extension<T>(T[] ts)
    {
        public int T() { return M(ts); } // Generated static method M<T>(T[]) is found
        public string M() { return T(ts); } // Error: T is a type parameter
    }
}

class CTest
{
    static int M<T>(T[] ts)
    {
        return T(ts);
    }
    
    static int T<U>(U[] ts) => 0;
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (6,33): error CS0029: Cannot implicitly convert type 'string' to 'int'
            //         public int T() { return M(ts); } // Generated static method M<T>(T[]) is found
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "M(ts)").WithArguments("string", "int").WithLocation(6, 33),
            // (7,36): error CS0119: 'T' is a type, which is not valid in the given context
            //         public string M() { return T(ts); } // Error: T is a type parameter
            Diagnostic(ErrorCode.ERR_BadSKunknown, "T").WithArguments("T", "type").WithLocation(7, 36),
            // (15,16): error CS0119: 'T' is a type, which is not valid in the given context
            //         return T(ts);
            Diagnostic(ErrorCode.ERR_BadSKunknown, "T").WithArguments("T", "type").WithLocation(15, 16)
            );
    }

    [Fact]
    public void NameConflict_28_ExampleFromSpec()
    {
        var src = @"
public static class E
{
    extension(int P)
    {
        public int P() { return M(P); } // Generated static method M<T>(T[]) is found
        public string M() { return P(P); } // Error: P is a parameter
    }
}

class CTest
{
    static int M(int P)
    {
        return P(P);
    }
    
    static int P(int P) => 0;
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (6,33): error CS0029: Cannot implicitly convert type 'string' to 'int'
            //         public int P() { return M(P); } // Generated static method M<T>(T[]) is found
            Diagnostic(ErrorCode.ERR_NoImplicitConv, "M(P)").WithArguments("string", "int").WithLocation(6, 33),
            // (7,36): error CS0149: Method name expected
            //         public string M() { return P(P); } // Error: P is a parameter
            Diagnostic(ErrorCode.ERR_MethodNameExpected, "P").WithLocation(7, 36),
            // (15,16): error CS0149: Method name expected
            //         return P(P);
            Diagnostic(ErrorCode.ERR_MethodNameExpected, "P").WithLocation(15, 16)
            );
    }

    [Fact]
    public void NameConflict_29_WithStaticTypeTypeParameter()
    {
        var src = @"
public static class E<T>
{
    extension(int p)
    {
        public void M1<T>() {}
    }

    extension<T>(T[] p)
    {
        public void M2<T>() {}
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (4,5): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            //     extension(int p)
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(4, 5),
            // (6,24): warning CS0693: Type parameter 'T' has the same name as the type parameter from outer type 'E<T>'
            //         public void M1<T>() {}
            Diagnostic(ErrorCode.WRN_TypeParameterSameAsOuterTypeParameter, "T").WithArguments("T", "E<T>").WithLocation(6, 24),
            // (9,5): error CS9283: Extensions must be declared in a top-level, non-generic, static class
            //     extension<T>(T[] p)
            Diagnostic(ErrorCode.ERR_BadExtensionContainingType, "extension").WithLocation(9, 5),
            // (9,15): warning CS0693: Type parameter 'T' has the same name as the type parameter from outer type 'E<T>'
            //     extension<T>(T[] p)
            Diagnostic(ErrorCode.WRN_TypeParameterSameAsOuterTypeParameter, "T").WithArguments("T", "E<T>").WithLocation(9, 15),
            // (11,24): error CS9289: Type parameter 'T' has the same name as an extension container type parameter
            //         public void M2<T>() {}
            Diagnostic(ErrorCode.ERR_TypeParameterSameNameAsExtensionTypeParameter, "T").WithArguments("T").WithLocation(11, 24)
            );
    }

    [Fact]
    public void ReceiverParameterScope_01_InStaticMember()
    {
        var src = """
static class Extensions
{
    extension(int p)
    {
        static int P1 { get => p; }
        static int M2()
        {
            return p;
        }
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,32): error CS9293: Cannot use extension parameter 'int p' in this context.
            //         static int P1 { get => p; }
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "p").WithArguments("int p").WithLocation(5, 32),
            // (8,20): error CS9293: Cannot use extension parameter 'int p' in this context.
            //             return p;
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "p").WithArguments("int p").WithLocation(8, 20)
            );
    }

    [Fact]
    public void ReceiverParameterScope_02_InStaticMember()
    {
        var src = """
static class Extensions
{
    extension(int p)
    {
        static int P1
        {
            get
            {
                int local() => p;
                return local();
            }
        }
        static int M2()
        {
            int local() => p;
            return local();
        }
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (9,32): error CS9293: Cannot use extension parameter 'int p' in this context.
            //                 int local() => p;
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "p").WithArguments("int p").WithLocation(9, 32),
            // (15,28): error CS9293: Cannot use extension parameter 'int p' in this context.
            //             int local() => p;
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "p").WithArguments("int p").WithLocation(15, 28)
            );
    }

    [Fact]
    public void ReceiverParameterScope_03_InStaticMember()
    {
        var src = """
static class Extensions
{
    extension(int p)
    {
        static string P1 { get => nameof(p); }
        static string M2()
        {
            return nameof(p);
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ReceiverParameterScope_04_InStaticLocalFunction()
    {
        var src = """
static class Extensions
{
    extension(int p)
    {
        int P1
        {
            get
            {
                static int local() => p;
                return local();
            }
        }
        int M2()
        {
            static int local() => p;
            return local();
        }
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (9,39): error CS8421: A static local function cannot contain a reference to 'p'.
            //                 static int local() => p;
            Diagnostic(ErrorCode.ERR_StaticLocalFunctionCannotCaptureVariable, "p").WithArguments("p").WithLocation(9, 39),
            // (15,35): error CS8421: A static local function cannot contain a reference to 'p'.
            //             static int local() => p;
            Diagnostic(ErrorCode.ERR_StaticLocalFunctionCannotCaptureVariable, "p").WithArguments("p").WithLocation(15, 35)
            );
    }

    [Theory]
    [CombinatorialData]
    public void ReceiverParameterScope_05_InAttribute(bool isStatic)
    {
        var modifier = isStatic ? "static " : "";

        var src = @"
static class Extensions
{
    extension(int p)
    {
        [MyAttr(nameof(p))]
        " + modifier + @"int P1 { get => 0; }

        [MyAttr(nameof(p))]
        " + modifier + @"int M2()
        {
            return 0;
        }
    }
}

class MyAttr : System.Attribute
{
    public MyAttr(string s) {}
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Theory]
    [CombinatorialData]
    public void ReceiverParameterScope_06_InAttribute(bool isStatic)
    {
        var modifier = isStatic ? "static " : "";

        var src = @"
static class Extensions
{
    extension(int p)
    {
        [MyAttr(p)]
        " + modifier + @"int P1 { get => 0; }

        [MyAttr(p)]
        " + modifier + @"int M2()
        {
            return 0;
        }
    }
}

class MyAttr : System.Attribute
{
    public MyAttr(int p) {}
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics(
            // (6,17): error CS9293: Cannot use extension parameter 'int p' in this context.
            //         [MyAttr(p)]
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "p").WithArguments("int p").WithLocation(6, 17),
            // (6,17): error CS0182: An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type
            //         [MyAttr(p)]
            Diagnostic(ErrorCode.ERR_BadAttributeArgument, "p").WithLocation(6, 17),
            // (9,17): error CS9293: Cannot use extension parameter 'int p' in this context.
            //         [MyAttr(p)]
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "p").WithArguments("int p").WithLocation(9, 17),
            // (9,17): error CS0182: An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type
            //         [MyAttr(p)]
            Diagnostic(ErrorCode.ERR_BadAttributeArgument, "p").WithLocation(9, 17)
            );
    }

    [Fact]
    public void ReceiverParameterScope_07_InAttribute()
    {
        var src = @"
static class Extensions
{
    extension(int p)
    {
        [MyAttr(nameof(p))]
        int this[int y]
        {
            get
            {
                return 0;
            }
        }
    }
}

class MyAttr : System.Attribute
{
    public MyAttr(string p) {}
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ReceiverParameterScope_08_InAttribute()
    {
        var src = @"
static class Extensions
{
    extension(string p)
    {
        [System.Runtime.CompilerServices.IndexerName(p)]
        int this[int y]
        {
            get
            {
                return 0;
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (6,54): error CS9293: Cannot use extension parameter 'string p' in this context.
            //         [System.Runtime.CompilerServices.IndexerName(p)]
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "p").WithArguments("string p").WithLocation(6, 54),
            // (6,54): error CS0182: An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type
            //         [System.Runtime.CompilerServices.IndexerName(p)]
            Diagnostic(ErrorCode.ERR_BadAttributeArgument, "p").WithLocation(6, 54)
            );
    }

    [Theory]
    [CombinatorialData]
    public void ReceiverParameterScope_09_InDefaultValue(bool isStatic)
    {
        var modifier = isStatic ? "static " : "";

        var src = @"
static class Extensions
{
    extension(int p)
    {
        " + modifier + @"int M2(string x = nameof(p))
        {
            return 0;
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Theory]
    [CombinatorialData]
    public void ReceiverParameterScope_10_InDefaultValue(bool isStatic)
    {
        var modifier = isStatic ? "static" : "";

        var src = @"
static class Extensions
{
    extension(int p)
    {
        " + modifier + @"
#line 6
        int M2(int x = p)
        {
            return 0;
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics(
            // (6,24): error CS9293: Cannot use extension parameter 'int p' in this context.
            //         int M2(int x = p)
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "p").WithArguments("int p").WithLocation(6, 24),
            // (6,24): error CS1736: Default parameter value for 'x' must be a compile-time constant
            //         int M2(int x = p)
            Diagnostic(ErrorCode.ERR_DefaultValueMustBeConstant, "p").WithArguments("x").WithLocation(6, 24)
            );
    }

    [Theory]
    [CombinatorialData]
    public void ReceiverParameterScope_11_InNestedType(bool isStatic)
    {
        var modifier = isStatic ? "static" : "";

        var src = @"
static class Extensions
{
    extension(int p)
    {
        class Nested
        {
            " + modifier + @"
            int M2()
            {
                return p;
            }

            " + modifier + @"
            string M3()
            {
                return nameof(p);
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics(
            // (6,15): error CS9282: Extension declarations can include only methods or properties
            //         class Nested
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "Nested").WithLocation(6, 15),
            // (11,24): error CS9293: Cannot use extension parameter 'int p' in this context.
            //                 return p;
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "p").WithArguments("int p").WithLocation(11, 24)
            );
    }

    [Fact]
    public void CycleInAttribute_01()
    {
        var src = @"
static class Extensions
{
    const string Str = ""val"";
    extension(string p)
    {
        [System.Runtime.CompilerServices.IndexerName(Str)]
        int this[int y]
        {
            get
            {
                return 0;
            }
        }
    }
}
";
        var comp = CreateCompilation(src);

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : We do not allow complex forms of IndexerName attribute due to a possible binding cycle
        comp.VerifyEmitDiagnostics(
            // (7,54): error CS8078: An expression is too long or complex to compile
            //         [System.Runtime.CompilerServices.IndexerName(Str)]
            Diagnostic(ErrorCode.ERR_InsufficientStack, "Str").WithLocation(7, 54)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_01()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        public void M1() {}
    }

    extension(object receiver)
    {
        public void M1() {}
    }

    extension(int receiver)
    {
        public void M2() {}
    }

    extension(ref int receiver)
    {
        public void M2() {}
    }

    extension(in int receiver)
    {
        public void M3() {}
    }

    extension(ref int receiver)
    {
        public void M3() {}
    }

    extension(ref readonly int receiver)
    {
        public void M4() {}
    }

    extension(ref int receiver)
    {
        public void M4() {}
    }

    extension(ref readonly int receiver)
    {
        public void M5() {}
    }

    extension(in int receiver)
    {
        public void M5() {}
    }

    static public void M6(this int receiver) {}

    static public void M6(this ref int receiver) {}

    static public void M7(this in int receiver) {}

    static public void M7(this ref int receiver) {}

    static public void M8(this ref readonly int receiver) {}

    static public void M8(this ref int receiver) {}

    static public void M9(this ref readonly int receiver) {}

    static public void M9(this in int receiver) {}

    extension(object receiver)
    {
        public void M10() {}
        public void M10() {}
    }

    extension(object receiver1)
    {
        public void M13() {}
    }

    extension(object receiver2)
    {
        public void M13() {}
    }
}
""";
        var comp = CreateCompilation(src);

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Despite the fact that we do not complain about M6, should we report an error for M2 (the only difference is receiver ref-ness)?
        comp.VerifyDiagnostics(
            // (10,21): error CS0111: Type 'Extensions' already defines a member called 'M1' with the same parameter types
            //         public void M1() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M1").WithArguments("M1", "Extensions").WithLocation(10, 21),
            // (20,21): error CS0111: Type 'Extensions' already defines a member called 'M2' with the same parameter types
            //         public void M2() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M2").WithArguments("M2", "Extensions").WithLocation(20, 21),
            // (30,21): error CS0111: Type 'Extensions' already defines a member called 'M3' with the same parameter types
            //         public void M3() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M3").WithArguments("M3", "Extensions").WithLocation(30, 21),
            // (40,21): error CS0111: Type 'Extensions' already defines a member called 'M4' with the same parameter types
            //         public void M4() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M4").WithArguments("M4", "Extensions").WithLocation(40, 21),
            // (50,21): error CS0111: Type 'Extensions' already defines a member called 'M5' with the same parameter types
            //         public void M5() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M5").WithArguments("M5", "Extensions").WithLocation(50, 21),
            // (59,24): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'ref' and 'in'
            //     static public void M7(this ref int receiver) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M7").WithArguments("Extensions", "method", "ref", "in").WithLocation(59, 24),
            // (63,24): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'ref' and 'ref readonly'
            //     static public void M8(this ref int receiver) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M8").WithArguments("Extensions", "method", "ref", "ref readonly").WithLocation(63, 24),
            // (67,24): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'in' and 'ref readonly'
            //     static public void M9(this in int receiver) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M9").WithArguments("Extensions", "method", "in", "ref readonly").WithLocation(67, 24),
            // (72,21): error CS0111: Type 'Extensions' already defines a member called 'M10' with the same parameter types
            //         public void M10() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M10").WithArguments("M10", "Extensions").WithLocation(72, 21),
            // (82,21): error CS0111: Type 'Extensions' already defines a member called 'M13' with the same parameter types
            //         public void M13() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M13").WithArguments("M13", "Extensions").WithLocation(82, 21)
            );

        comp = CreateCompilation("""
static class Extensions
{
    static void Main()
    {
        int i = 0;
        i.M11();
        "".M11();

        ((long)i).M12(i);
        ((long)i).M12(ref i);
    }

    extension(int receiver)
    {
        public void M11() {}
    }

    extension(string receiver)
    {
        public void M11() {}
    }

    extension(long receiver)
    {
        public void M12(int x) {}
    }

    extension(long receiver)
    {
        public void M12(ref int x) {}
    }
}
""");

        CompileAndVerify(comp).VerifyDiagnostics();
    }

    [Fact]
    public void MemberNameAndSignatureConflict_02()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        static public void M1() {}
    }

    extension(object receiver)
    {
        static public void M1() {}
    }

    extension(object receiver)
    {
        static public void M2(ref int x) {}
    }

    extension(object receiver)
    {
        static public void M2(ref readonly int x) {}
    }

    extension(object receiver)
    {
        static public void M3(in int x) {}
    }

    extension(object receiver)
    {
        static public void M3(ref readonly int x) {}
    }

    extension(object receiver)
    {
        static public void M4(ref int x) {}
    }

    extension(object receiver)
    {
        static public void M4(in int x) {}
    }

    extension(object receiver)
    {
        static public void M5() {}
        static public void M5() {}
    }

    extension(int receiver)
    {
        static public void M6() {}
    }

    extension(string receiver)
    {
        static public void M6() {}
    }

    extension(int receiver)
    {
        static public int M7() => 0;
    }

    extension(long receiver)
    {
        static public long M7() => 0;
    }

    extension(int receiver)
    {
        public static void M8() {}
    }

    extension(ref int receiver)
    {
        public static void M8() {}
    }

    extension(int receiver)
    {
        public void M9() {}
    }

    extension(int receiver)
    {
        public static void M9(int x) {}
    }

    extension(ref int receiver)
    {
        public void M10() {}
    }

    extension(int receiver)
    {
        public static void M10(in int x) {}
    }

    extension(int receiver)
    {
        public void M11() {}
        public static void M11(int x) {}
    }

    extension(ref int receiver)
    {
        public void M12() {}
        public static void M12(in int x) {}
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (10,28): error CS0111: Type 'Extensions' already defines a member called 'M1' with the same parameter types
            //         static public void M1() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M1").WithArguments("M1", "Extensions").WithLocation(10, 28),
            // (20,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'ref readonly' and 'ref'
            //         static public void M2(ref readonly int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M2").WithArguments("Extensions", "method", "ref readonly", "ref").WithLocation(20, 28),
            // (30,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'ref readonly' and 'in'
            //         static public void M3(ref readonly int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M3").WithArguments("Extensions", "method", "ref readonly", "in").WithLocation(30, 28),
            // (40,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'in' and 'ref'
            //         static public void M4(in int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M4").WithArguments("Extensions", "method", "in", "ref").WithLocation(40, 28),
            // (46,28): error CS0111: Type 'Extensions' already defines a member called 'M5' with the same parameter types
            //         static public void M5() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M5").WithArguments("M5", "Extensions").WithLocation(46, 28),

            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : It feels unfortunate that we generate conflicting signatures, the methods extend different types (refer to M6 and M7 cases)

            // (56,28): error CS0111: Type 'Extensions' already defines a member called 'M6' with the same parameter types
            //         static public void M6() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M6").WithArguments("M6", "Extensions").WithLocation(56, 28),
            // (66,28): error CS0111: Type 'Extensions' already defines a member called 'M7' with the same parameter types
            //         static public long M7() => 0;
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M7").WithArguments("M7", "Extensions").WithLocation(66, 28), // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Signatures in metadata are different in this case (return type is different), consider if we want to enable this specific case 

            // (76,28): error CS0111: Type 'Extensions' already defines a member called 'M8' with the same parameter types
            //         public static void M8() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M8").WithArguments("M8", "Extensions").WithLocation(76, 28),

            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Are we comfortable with these four conflicts?

            // (86,28): error CS0111: Type 'Extensions' already defines a member called 'M9' with the same parameter types
            //         public static void M9(int x) {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M9").WithArguments("M9", "Extensions").WithLocation(86, 28),
            // (96,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'in' and 'ref'
            //         public static void M10(in int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M10").WithArguments("Extensions", "method", "in", "ref").WithLocation(96, 28),
            // (102,28): error CS0111: Type 'Extensions' already defines a member called 'M11' with the same parameter types
            //         public static void M11(int x) {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M11").WithArguments("M11", "Extensions").WithLocation(102, 28),
            // (108,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'in' and 'ref'
            //         public static void M12(in int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M12").WithArguments("Extensions", "method", "in", "ref").WithLocation(108, 28)
            );

        comp = CreateCompilation("""
static class Extensions
{
    static void Main()
    {
        int i = 0;
        i.M13();
        int.M13(ref i);
        M13(i);
        M13(ref i);

        i.M14();
        int.M14(i);
        M14(ref i);
        M14(i);
    }

    extension(int receiver)
    {
        public void M13() => System.Console.Write(1);
    }

    extension(int receiver)
    {
        public static void M13(ref int x) => System.Console.Write(2);
    }

    extension(ref int receiver)
    {
        public void M14() => System.Console.Write(3);
    }

    extension(int receiver)
    {
        public static void M14(int x) => System.Console.Write(4);
    }
}
""", options: TestOptions.DebugExe);

        CompileAndVerify(comp, expectedOutput: "12123434").VerifyDiagnostics();
    }

    [Fact]
    public void MemberNameAndSignatureConflict_03()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        public int P1 => 1;
    }

    extension(object receiver)
    {
        public int P1 => 4;
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (10,20): error CS0102: The type 'Extensions' already contains a definition for 'P1'
            //         public int P1 => 4;
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "P1").WithArguments("Extensions", "P1").WithLocation(10, 20)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_04()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        static public int P1 => 1;
    }

    extension(object receiver)
    {
        static public int P1 => 4;
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (10,27): error CS0102: The type 'Extensions' already contains a definition for 'P1'
            //         static public int P1 => 4;
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "P1").WithArguments("Extensions", "P1").WithLocation(10, 27)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_05()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        public int P1 => 1;
        public int get_P2() => 2;
    }

    extension(object receiver)
    {
        public int get_P1() => 3;
        public int P2 => 4;
    }
}

static class Extensions2
{
    extension(object receiver)
    {
        public int P3 => 1;
        public int get_P4() => 2;
        public int get_P3() => 3;
        public int P4 => 4;
    }
}

static class Extensions3
{
    extension(object receiver)
    {
        public int P1 => 1;
        public int set_P2(int x) => 2;
    }

    extension(object receiver)
    {
        public int set_P1(int y) => 3;
        public int P2 => 4;
    }
}

static class Extensions4
{
    extension(object receiver)
    {
        public int P3 => 1;
        public int set_P4(int z) => 2;
        public int set_P3(int z) => 3;
        public int P4 => 4;
    }
}

static class Extensions5
{
    extension(object receiver)
    {
        public int this[int x] => 1;
        public int get_Item(long y) => 2;
    }

    extension(object receiver)
    {
        public int get_Item(int a) => 3;
        public int this[long b] => 4;
    }
}

static class Extensions6
{
    extension(object receiver)
    {
        [System.Runtime.CompilerServices.IndexerName("Indexer")]
        public int this[int x] => 1;
    }

    extension(object receiver)
    {
        public int get_Indexer(int a) => 3;
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,26): error CS0082: Type 'Extensions' already reserves a member called 'get_P1' with the same parameter types
            //         public int P1 => 1;
            Diagnostic(ErrorCode.ERR_MemberReserved, "1").WithArguments("get_P1", "Extensions").WithLocation(5, 26),
            // (12,26): error CS0082: Type 'Extensions' already reserves a member called 'get_P2' with the same parameter types
            //         public int P2 => 4;
            Diagnostic(ErrorCode.ERR_MemberReserved, "4").WithArguments("get_P2", "Extensions").WithLocation(12, 26),
            // (20,26): error CS0082: Type 'Extensions2' already reserves a member called 'get_P3' with the same parameter types
            //         public int P3 => 1;
            Diagnostic(ErrorCode.ERR_MemberReserved, "1").WithArguments("get_P3", "Extensions2").WithLocation(20, 26),
            // (23,26): error CS0082: Type 'Extensions2' already reserves a member called 'get_P4' with the same parameter types
            //         public int P4 => 4;
            Diagnostic(ErrorCode.ERR_MemberReserved, "4").WithArguments("get_P4", "Extensions2").WithLocation(23, 26),
            // (31,20): error CS0082: Type 'Extensions3' already reserves a member called 'set_P1' with the same parameter types
            //         public int P1 => 1;
            Diagnostic(ErrorCode.ERR_MemberReserved, "P1").WithArguments("set_P1", "Extensions3").WithLocation(31, 20),
            // (38,20): error CS0082: Type 'Extensions3' already reserves a member called 'set_P2' with the same parameter types
            //         public int P2 => 4;
            Diagnostic(ErrorCode.ERR_MemberReserved, "P2").WithArguments("set_P2", "Extensions3").WithLocation(38, 20),
            // (46,20): error CS0082: Type 'Extensions4' already reserves a member called 'set_P3' with the same parameter types
            //         public int P3 => 1;
            Diagnostic(ErrorCode.ERR_MemberReserved, "P3").WithArguments("set_P3", "Extensions4").WithLocation(46, 20),
            // (49,20): error CS0082: Type 'Extensions4' already reserves a member called 'set_P4' with the same parameter types
            //         public int P4 => 4;
            Diagnostic(ErrorCode.ERR_MemberReserved, "P4").WithArguments("set_P4", "Extensions4").WithLocation(49, 20),
            // (57,35): error CS0082: Type 'Extensions5' already reserves a member called 'get_Item' with the same parameter types
            //         public int this[int x] => 1;
            Diagnostic(ErrorCode.ERR_MemberReserved, "1").WithArguments("get_Item", "Extensions5").WithLocation(57, 35),
            // (64,36): error CS0082: Type 'Extensions5' already reserves a member called 'get_Item' with the same parameter types
            //         public int this[long b] => 4;
            Diagnostic(ErrorCode.ERR_MemberReserved, "4").WithArguments("get_Item", "Extensions5").WithLocation(64, 36),
            // (73,35): error CS0082: Type 'Extensions6' already reserves a member called 'get_Indexer' with the same parameter types
            //         public int this[int x] => 1;
            Diagnostic(ErrorCode.ERR_MemberReserved, "1").WithArguments("get_Indexer", "Extensions6").WithLocation(73, 35)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_06()
    {
        var src = """
static class Extensions1
{
    extension(object receiver)
    {
        public int P1 => 1;
    }

    extension(object receiver)
    {
        public int P1 {set{}}
    }
}

static class Extensions2
{
    extension(object receiver1)
    {
        public int this[int x] => 1;
    }

    extension(object receiver2)
    {
        public int this[int y] {set{}}
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (10,20): error CS0102: The type 'Extensions1' already contains a definition for 'P1'
            //         public int P1 {set{}}
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "P1").WithArguments("Extensions1", "P1").WithLocation(10, 20),
            // (23,20): error CS0111: Type 'Extensions2' already defines a member called 'this' with the same parameter types
            //         public int this[int y] {set{}}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "this").WithArguments("this", "Extensions2").WithLocation(23, 20)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_07()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        public void M(){}
    }

    extension(__arglist)
    {
        public void M(object x){}
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (8,15): error CS1669: __arglist is not valid in this context
            //     extension(__arglist)
            Diagnostic(ErrorCode.ERR_IllegalVarArgs, "__arglist").WithLocation(8, 15)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_08()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        public void M1() {}
    }

    public static void M1(object receiver) {}

    extension(int receiver)
    {
        public void M2() {}
    }

    public static void M2(ref int receiver) {}

    extension(in int receiver)
    {
        public void M3() {}
    }

    public static void M3(ref int receiver) {}

    extension(ref readonly int receiver)
    {
        public void M4() {}
    }

    public static void M4(ref int receiver) {}

    extension(ref readonly int receiver)
    {
        public void M5() {}
    }

    public static void M5(in int receiver) {}

    extension(object receiver1)
    {
        public void M13() {}
    }

    public static void M13(object receiver2) {}
}
""";
        var comp = CreateCompilation(src);

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Should we report an error for M2 (the only difference is receiver ref-ness)?
        comp.VerifyDiagnostics(
            // (5,21): error CS0111: Type 'Extensions' already defines a member called 'M1' with the same parameter types
            //         public void M1() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M1").WithArguments("M1", "Extensions").WithLocation(5, 21),

            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : The error might be somewhat confusing in this scenario because there are no parameters and we complain about ref-ness of the receiver.

            // (19,21): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'in' and 'ref'
            //         public void M3() {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M3").WithArguments("Extensions", "method", "in", "ref").WithLocation(19, 21),
            // (26,21): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'ref readonly' and 'ref'
            //         public void M4() {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M4").WithArguments("Extensions", "method", "ref readonly", "ref").WithLocation(26, 21),
            // (33,21): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'ref readonly' and 'in'
            //         public void M5() {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M5").WithArguments("Extensions", "method", "ref readonly", "in").WithLocation(33, 21),
            // (40,21): error CS0111: Type 'Extensions' already defines a member called 'M13' with the same parameter types
            //         public void M13() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M13").WithArguments("M13", "Extensions").WithLocation(40, 21)
            );

        comp = CreateCompilation("""
static class Extensions
{
    static void Main()
    {
        1.M2();
    }

    extension(int receiver)
    {
        public void M2() {}
    }

    public static void M2(this ref int receiver) {}
}
""");

        comp.VerifyDiagnostics(
            // (5,11): error CS0121: The call is ambiguous between the following methods or properties: 'Extensions.extension(int).M2()' and 'Extensions.M2(ref int)'
            //         1.M2();
            Diagnostic(ErrorCode.ERR_AmbigCall, "M2").WithArguments("Extensions.extension(int).M2()", "Extensions.M2(ref int)").WithLocation(5, 11)
            );

        comp = CreateCompilation("""
static class Extensions
{
    static void Main()
    {
        int i = 0;
        1.M2();
        M2(i);
        M2(ref i);

        ((long)i).M12(i);
        ((long)i).M12(ref i);
    }

    extension(int receiver)
    {
        public void M2() {}
    }

    public static void M2(ref int receiver) {}

    extension(long receiver)
    {
        public void M12(int x) {}
    }

    public static void M12(this long receiver, ref int x) {}
}
""");

        CompileAndVerify(comp).VerifyDiagnostics();
    }

    [Fact]
    public void MemberNameAndSignatureConflict_09()
    {
        var src = """
static class Extensions
{
    public static void M1(object receiver) {}

    extension(object receiver)
    {
        public void M1() {}
    }

    public static void M2(ref int receiver) {}

    extension(int receiver)
    {
        public void M2() {}
    }

    public static void M3(ref int receiver) {}

    extension(in int receiver)
    {
        public void M3() {}
    }

    public static void M4(ref int receiver) {}

    extension(ref readonly int receiver)
    {
        public void M4() {}
    }

    public static void M5(in int receiver) {}

    extension(ref readonly int receiver)
    {
        public void M5() {}
    }

    public static void M13(object receiver2) {}

    extension(object receiver1)
    {
        public void M13() {}
    }
}
""";
        var comp = CreateCompilation(src);

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Should we report an error for M2 (the only difference is receiver ref-ness)?
        comp.VerifyDiagnostics(
            // (7,21): error CS0111: Type 'Extensions' already defines a member called 'M1' with the same parameter types
            //         public void M1() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M1").WithArguments("M1", "Extensions").WithLocation(7, 21),

            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : The error might be somewhat confusing in this scenario because there are no parameters and we complain about ref-ness of the receiver.

            // (21,21): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'in' and 'ref'
            //         public void M3() {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M3").WithArguments("Extensions", "method", "in", "ref").WithLocation(21, 21),
            // (28,21): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'ref readonly' and 'ref'
            //         public void M4() {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M4").WithArguments("Extensions", "method", "ref readonly", "ref").WithLocation(28, 21),
            // (35,21): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'ref readonly' and 'in'
            //         public void M5() {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M5").WithArguments("Extensions", "method", "ref readonly", "in").WithLocation(35, 21),
            // (42,21): error CS0111: Type 'Extensions' already defines a member called 'M13' with the same parameter types
            //         public void M13() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M13").WithArguments("M13", "Extensions").WithLocation(42, 21)
            );

        comp = CreateCompilation("""
static class Extensions
{
    static void Main()
    {
        1.M2();
    }

    public static void M2(this ref int receiver) {}

    extension(int receiver)
    {
        public void M2() {}
    }
}
""");

        comp.VerifyDiagnostics(
            // (5,11): error CS0121: The call is ambiguous between the following methods or properties: 'Extensions.extension(int).M2()' and 'Extensions.M2(ref int)'
            //         1.M2();
            Diagnostic(ErrorCode.ERR_AmbigCall, "M2").WithArguments("Extensions.extension(int).M2()", "Extensions.M2(ref int)").WithLocation(5, 11)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_10()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        static public void M1() {}
    }

    static public void M1() {}

    extension(object receiver)
    {
        static public void M2(ref int x) {}
    }

    static public void M2(ref readonly int x) {}

    extension(object receiver)
    {
        static public void M3(in int x) {}
    }

    static public void M3(ref readonly int x) {}

    extension(object receiver)
    {
        static public void M4(ref int x) {}
    }

    static public void M4(in int x) {}


    extension(int receiver)
    {
        static public int M7() => 0;
    }

    static public long M7() => 0;


    public static void M9(int receiver) {}

    extension(int receiver)
    {
        public static void M9(int x) {}
    }

    public static void M10(ref int receiver) {}

    extension(int receiver)
    {
        public static void M10(in int x) {}
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,28): error CS0111: Type 'Extensions' already defines a member called 'M1' with the same parameter types
            //         static public void M1() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M1").WithArguments("M1", "Extensions").WithLocation(5, 28),
            // (12,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'ref' and 'ref readonly'
            //         static public void M2(ref int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M2").WithArguments("Extensions", "method", "ref", "ref readonly").WithLocation(12, 28),
            // (19,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'in' and 'ref readonly'
            //         static public void M3(in int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M3").WithArguments("Extensions", "method", "in", "ref readonly").WithLocation(19, 28),
            // (26,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'ref' and 'in'
            //         static public void M4(ref int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M4").WithArguments("Extensions", "method", "ref", "in").WithLocation(26, 28),

            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : It feels unfortunate that we generate conflicting signatures

            // (34,27): error CS0111: Type 'Extensions' already defines a member called 'M7' with the same parameter types
            //         static public int M7() => 0;
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M7").WithArguments("M7", "Extensions").WithLocation(34, 27),

            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Are we comfortable with these two conflicts?

            // (44,28): error CS0111: Type 'Extensions' already defines a member called 'M9' with the same parameter types
            //         public static void M9(int x) {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M9").WithArguments("M9", "Extensions").WithLocation(44, 28),
            // (51,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'in' and 'ref'
            //         public static void M10(in int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M10").WithArguments("Extensions", "method", "in", "ref").WithLocation(51, 28)
            );

        comp = CreateCompilation("""
static class Extensions
{
    static void Main()
    {
        int i = 0;
        i.M13();
        int.M13(ref i);
        M13(i);
        M13(ref i);

        i.M14();
        int.M14(i);
        M14(ref i);
        M14(i);
    }

    public static void M13(this int receiver) => System.Console.Write(1);

    extension(int receiver)
    {
        public static void M13(ref int x) => System.Console.Write(2);
    }

    public static void M14(this ref int receiver) => System.Console.Write(3);

    extension(int receiver)
    {
        public static void M14(int x) => System.Console.Write(4);
    }
}
""", options: TestOptions.DebugExe);

        CompileAndVerify(comp, expectedOutput: "12123434").VerifyDiagnostics();
    }

    [Fact]
    public void MemberNameAndSignatureConflict_11()
    {
        var src = """
static class Extensions
{
    static public void M1() {}

    extension(object receiver)
    {
        static public void M1() {}
    }

    static public void M2(ref readonly int x) {}

    extension(object receiver)
    {
        static public void M2(ref int x) {}
    }

    static public void M3(ref readonly int x) {}

    extension(object receiver)
    {
        static public void M3(in int x) {}
    }

    static public void M4(in int x) {}

    extension(object receiver)
    {
        static public void M4(ref int x) {}
    }

    static public long M7() => 0;

    extension(int receiver)
    {
        static public int M7() => 0;
    }

    extension(int receiver)
    {
        public static void M9(int x) {}
    }

    public static void M9(int receiver) {}

    extension(int receiver)
    {
        public static void M10(in int x) {}
    }

    public static void M10(ref int receiver) {}
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (7,28): error CS0111: Type 'Extensions' already defines a member called 'M1' with the same parameter types
            //         static public void M1() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M1").WithArguments("M1", "Extensions").WithLocation(7, 28),
            // (14,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'ref' and 'ref readonly'
            //         static public void M2(ref int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M2").WithArguments("Extensions", "method", "ref", "ref readonly").WithLocation(14, 28),
            // (21,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'in' and 'ref readonly'
            //         static public void M3(in int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M3").WithArguments("Extensions", "method", "in", "ref readonly").WithLocation(21, 28),
            // (28,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'ref' and 'in'
            //         static public void M4(ref int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M4").WithArguments("Extensions", "method", "ref", "in").WithLocation(28, 28),

            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : It feels unfortunate that we generate conflicting signatures

            // (35,27): error CS0111: Type 'Extensions' already defines a member called 'M7' with the same parameter types
            //         static public int M7() => 0;
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M7").WithArguments("M7", "Extensions").WithLocation(35, 27),

            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Are we comfortable with these two conflicts?

            // (40,28): error CS0111: Type 'Extensions' already defines a member called 'M9' with the same parameter types
            //         public static void M9(int x) {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M9").WithArguments("M9", "Extensions").WithLocation(40, 28),
            // (47,28): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'in' and 'ref'
            //         public static void M10(in int x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M10").WithArguments("Extensions", "method", "in", "ref").WithLocation(47, 28)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_12()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        public int P1 => 1;
    }

    public static int get_P1(object receiver) => 4;

    public static int get_P2(object receiver) => 4;

    extension(object receiver)
    {
        public int P2 => 1;
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,26): error CS0111: Type 'Extensions' already defines a member called 'get_P1' with the same parameter types
            //         public int P1 => 1;
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "1").WithArguments("get_P1", "Extensions").WithLocation(5, 26),
            // (14,26): error CS0111: Type 'Extensions' already defines a member called 'get_P2' with the same parameter types
            //         public int P2 => 1;
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "1").WithArguments("get_P2", "Extensions").WithLocation(14, 26)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_13()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        static public int P1 => 1;
    }

    public static int P1 => 4;

    public static int P2 => 4;

    extension(object receiver)
    {
        static public int P2 => 1;
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (8,29): error CS0082: Type 'Extensions' already reserves a member called 'get_P1' with the same parameter types
            //     public static int P1 => 4;
            Diagnostic(ErrorCode.ERR_MemberReserved, "4").WithArguments("get_P1", "Extensions").WithLocation(8, 29),
            // (10,29): error CS0082: Type 'Extensions' already reserves a member called 'get_P2' with the same parameter types
            //     public static int P2 => 4;
            Diagnostic(ErrorCode.ERR_MemberReserved, "4").WithArguments("get_P2", "Extensions").WithLocation(10, 29)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_14()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        static public int get_P1() => 1;
    }

    public static int P1 => 4;

    public static int P2 => 4;

    extension(object receiver)
    {
        static public int get_P2() => 1;
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (8,29): error CS0082: Type 'Extensions' already reserves a member called 'get_P1' with the same parameter types
            //     public static int P1 => 4;
            Diagnostic(ErrorCode.ERR_MemberReserved, "4").WithArguments("get_P1", "Extensions").WithLocation(8, 29),
            // (10,29): error CS0082: Type 'Extensions' already reserves a member called 'get_P2' with the same parameter types
            //     public static int P2 => 4;
            Diagnostic(ErrorCode.ERR_MemberReserved, "4").WithArguments("get_P2", "Extensions").WithLocation(10, 29)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_15()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        public int P1 => 1;
    }

    public static int set_P1(object receiver, int x) => 4;
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void MemberNameAndSignatureConflict_16()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        static public int P1 => 1;
    }

    public static int P1 {set{}}

    static public int get_P2() => 1;
    public static int P2 {set{}}
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Are we comfortable reporting an error like this?

            // (8,23): error CS0082: Type 'Extensions' already reserves a member called 'get_P1' with the same parameter types
            //     public static int P1 {set{}}
            Diagnostic(ErrorCode.ERR_MemberReserved, "P1").WithArguments("get_P1", "Extensions").WithLocation(8, 23),

            // (11,23): error CS0082: Type 'Extensions' already reserves a member called 'get_P2' with the same parameter types
            //     public static int P2 {set{}}
            Diagnostic(ErrorCode.ERR_MemberReserved, "P2").WithArguments("get_P2", "Extensions").WithLocation(11, 23)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_17()
    {
        var src = """
static class Extensions
{
    extension(object receiver)
    {
        static public int set_P1(int x) => 1;
    }

    public static int P1 => 4;

    static public int set_P2(int x) => 1;
    public static int P2 => 4;
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Are we comfortable reporting an error like this?

            // (8,23): error CS0082: Type 'Extensions' already reserves a member called 'set_P1' with the same parameter types
            //     public static int P1 => 4;
            Diagnostic(ErrorCode.ERR_MemberReserved, "P1").WithArguments("set_P1", "Extensions").WithLocation(8, 23),

            // (11,23): error CS0082: Type 'Extensions' already reserves a member called 'set_P2' with the same parameter types
            //     public static int P2 => 4;
            Diagnostic(ErrorCode.ERR_MemberReserved, "P2").WithArguments("set_P2", "Extensions").WithLocation(11, 23)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_18()
    {
        var src = """
public static class Extensions
{
    extension(object receiver)
    {
        static public void M1(int x) {}
    }

    public static int M1 => 4;

    extension(object receiver)
    {
        static public void M2(int x) {}
    }

    public static int M2 = 4;

    extension(object receiver)
    {
        static public void M3(int x) {}
    }

#pragma warning disable CS0067 // The event 'Extensions.M3' is never used
    public static event System.Action M3;
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (5,28): error CS0102: The type 'Extensions' already contains a definition for 'M1'
            //         static public void M1(int x) {}
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "M1").WithArguments("Extensions", "M1").WithLocation(5, 28),
            // (12,28): error CS0102: The type 'Extensions' already contains a definition for 'M2'
            //         static public void M2(int x) {}
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "M2").WithArguments("Extensions", "M2").WithLocation(12, 28),
            // (19,28): error CS0102: The type 'Extensions' already contains a definition for 'M3'
            //         static public void M3(int x) {}
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "M3").WithArguments("Extensions", "M3").WithLocation(19, 28)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_19()
    {
        var src = """
public static class Extensions
{
    public static int M1 => 4;

    extension(object receiver)
    {
        static public void M1(int x) {}
    }

    public static int M2 = 4;

    extension(object receiver)
    {
        static public void M2(int x) {}
    }

#pragma warning disable CS0067 // The event 'Extensions.M3' is never used
    public static event System.Action M3;

    extension(object receiver)
    {
        static public void M3(int x) {}
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (7,28): error CS0102: The type 'Extensions' already contains a definition for 'M1'
            //         static public void M1(int x) {}
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "M1").WithArguments("Extensions", "M1").WithLocation(7, 28),
            // (14,28): error CS0102: The type 'Extensions' already contains a definition for 'M2'
            //         static public void M2(int x) {}
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "M2").WithArguments("Extensions", "M2").WithLocation(14, 28),
            // (22,28): error CS0102: The type 'Extensions' already contains a definition for 'M3'
            //         static public void M3(int x) {}
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "M3").WithArguments("Extensions", "M3").WithLocation(22, 28)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_20_ReceiverType_TupleNameDifference()
    {
        var src = """
public static class Extensions
{
    extension((int a, int b) receiver)
    {
        void M1() {}
    }

    extension((int c, int d))
    {
        static void M1() {}
    }

    extension(int receiver)
    {
        void M1() {}
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (10,21): error CS0111: Type 'Extensions' already defines a member called 'M1' with the same parameter types
            //         static void M1() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M1").WithArguments("M1", "Extensions").WithLocation(10, 21)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_21_ReceiverType_NativeIntDifference()
    {
        var src = """
public static class Extensions
{
    extension(System.IntPtr receiver)
    {
        void M1() {}
    }

    extension(nint)
    {
        static void M1() {}
    }

    extension(int receiver)
    {
        void M1() {}
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net90);

        comp.VerifyDiagnostics(
            // (10,21): error CS0111: Type 'Extensions' already defines a member called 'M1' with the same parameter types
            //         static void M1() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M1").WithArguments("M1", "Extensions").WithLocation(10, 21)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_22_ReceiverType_NullabilityDifference()
    {
        var src = """
#nullable enable

public static class Extensions
{
    extension(string[])
    {
        static void M1() {}
    }

    extension(string?[] receiver)
    {
        void M1() {}
    }

    extension(int receiver)
    {
        void M1() {}
    }
}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (12,14): error CS0111: Type 'Extensions' already defines a member called 'M1' with the same parameter types
            //         void M1() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M1").WithArguments("M1", "Extensions").WithLocation(12, 14)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_23_Receiver_TypeDifference()
    {
        var src = """
public static class Extensions
{
    extension(int receiver)
    {
        void M1() {}
    }

    extension(long)
    {
        static void M1() {}
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp).VerifyDiagnostics();
    }

    [Theory]
    [CombinatorialData]
    public void MemberNameAndSignatureConflict_24_Genericity(bool insertAtTheBeginning)
    {
        var insert = """
    extension<S>(S[])
    {
        static void M1(int z) {}
    }
""";

        var src = @"
public static class Extensions
{
" + (insertAtTheBeginning ? insert : "") + @"

    extension<T>(T[]) where T : class
    {
        static void M1(T x) {}
    }

" + (!insertAtTheBeginning ? insert : "") + @"

    extension<U>(U[] receiver) where U : struct
    {
#line 17
        void M1(U y) {}
        void M2(U y) {}
        static void M2(U x) {}
    }

    extension(int[] receiver)
    {
        void M1(int a) {}
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (17,14): error CS0111: Type 'Extensions' already defines a member called 'M1' with the same parameter types
            //         void M1(U y) {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M1").WithArguments("M1", "Extensions").WithLocation(17, 14),
            // (19,21): error CS0111: Type 'Extensions' already defines a member called 'M2' with the same parameter types
            //         static void M2(U x) {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M2").WithArguments("M2", "Extensions").WithLocation(19, 21)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_25_Genericity_DifferentArity()
    {
        var src = """
public static class Extensions1
{
    extension<T1>(T1)
    {
        static void M1(T1 x) {}
    }

    extension<T1, U1>(T1)
    {
        static void M1(T1 x) {}
    }
}

public static class Extensions2
{
    extension<T2, U2>(T2)
    {
        static void M1(T2 x) {}
    }

    extension<T2>(T2)
    {
        static void M1(T2 x) {}
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (8,23): error CS9295: The extended type 'T1' must reference all the type parameters declared by the extension, but type parameter 'U1' is not referenced.
            //     extension<T1, U1>(T1)
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "T1").WithArguments("T1", "U1").WithLocation(8, 23),
            // (16,23): error CS9295: The extended type 'T2' must reference all the type parameters declared by the extension, but type parameter 'U2' is not referenced.
            //     extension<T2, U2>(T2)
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "T2").WithArguments("T2", "U2").WithLocation(16, 23));
    }

    [Fact]
    public void MemberNameAndSignatureConflict_26_Genericity()
    {
        var src = """
public static class Extensions1
{
    extension<T, S>(C<T, S>)
    {
        static void M1() {}
    }

    extension<T, S>(C<S, T>)
    {
        static void M1() {}
    }
}

class C<T, S> {}
""";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (10,21): error CS0111: Type 'Extensions1' already defines a member called 'M1' with the same parameter types
            //         static void M1() {}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M1").WithArguments("M1", "Extensions1").WithLocation(10, 21)
            );
    }

    [Fact]
    public void MemberNameAndSignatureConflict_27_Genericity()
    {
        var src = """
public static class Extensions1
{
    extension<T, S>(C<T, S>)
    {
        void M1() {}
    }

    extension<T, S>(C<S, T>)
    {
        void M1() {}
    }
}

class C<T, S> {}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp).VerifyDiagnostics();
    }

    [Theory]
    [CombinatorialData]
    public void MemberNameAndSignatureConflict_28_Genericity(bool insertAtTheBeginning)
    {
        var insert = """
    extension<S>(S[])
    {
        static void M1(ref int z) {}
    }
""";

        var src = @"
public static class Extensions
{
" + (insertAtTheBeginning ? insert : "") + @"

    extension<T>(T[])
    {
        static void M1(ref T x) {}
    }

" + (!insertAtTheBeginning ? insert : "") + @"

    extension<U>(U[] receiver)
    {
#line 17
        void M1(in U y) {}
        void M2(ref U y) {}
        static void M2(in U x) {}
    }

    extension(int[] receiver)
    {
        void M1(ref int a) {}
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (17,14): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'in' and 'ref'
            //         void M1(in U y) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M1").WithArguments("Extensions", "method", "in", "ref").WithLocation(17, 14),
            // (19,21): error CS0663: 'Extensions' cannot define an overloaded method that differs only on parameter modifiers 'in' and 'ref'
            //         static void M2(in U x) {}
            Diagnostic(ErrorCode.ERR_OverloadRefKind, "M2").WithArguments("Extensions", "method", "in", "ref").WithLocation(19, 21)
            );
    }

    [Theory]
    [CombinatorialData]
    public void MemberNameAndSignatureConflict_29_Indexers(bool insertAtTheBeginning)
    {
        var insert = """
    extension<S>(S[])
    {
        static void M1(int z) {}
    }
""";

        var src = @"
public static class Extensions
{
" + (insertAtTheBeginning ? insert : "") + @"

    extension<T>(T[])
    {
#line 8
        int this[T x] => default;
    }

" + (!insertAtTheBeginning ? insert : "") + @"

    extension<U>(U[] receiver)
    {
        void Item(U x) {}
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (8,13): error CS0102: The type 'Extensions' already contains a definition for 'Item'
            //         int this[T x] => default;
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "this").WithArguments("Extensions", "Item").WithLocation(8, 13)
            );
    }

    [Theory]
    [CombinatorialData]
    public void MemberNameAndSignatureConflict_30_Indexers(bool insertAtTheBeginning)
    {
        var insert = """
    extension<S>(S[])
    {
        static void M1(int z) {}
    }
""";

        var src = @"
public static class Extensions
{
" + (insertAtTheBeginning ? insert : "") + @"

    extension<T>(T[])
    {
        int this[T x] => default;
    }

" + (!insertAtTheBeginning ? insert : "") + @"

    extension<U>(U[] receiver)
    {
#line 18
        int this[U x] { set{}}
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (18,13): error CS0111: Type 'Extensions' already defines a member called 'this' with the same parameter types
            //         int this[U x] { set{}}
            Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "this").WithArguments("this", "Extensions").WithLocation(18, 13)
            );
    }

    [Theory]
    [CombinatorialData]
    public void MemberNameAndSignatureConflict_31_Indexers(bool insertAtTheBeginning)
    {
        var insert = """
    extension<S>(S[])
    {
        static void M1(int z) {}
    }
""";

        var src = @"
public static class Extensions
{
" + (insertAtTheBeginning ? insert : "") + @"

    extension<T>(T[])
    {
        int this[T x] => default;
    }

" + (!insertAtTheBeginning ? insert : "") + @"

    extension<U>(U[] receiver)
    {
#line 18
        [System.Runtime.CompilerServices.IndexerName(""NotItem"")]
        int this[int x] { set{}}
    }
}
";
        var comp = CreateCompilation(src);

        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : The "within a type" part of the message might be somewhat misleading
        comp.VerifyDiagnostics(
            // (19,13): error CS0668: Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type
            //         int this[int x] { set{}}
            Diagnostic(ErrorCode.ERR_InconsistentIndexerNames, "this").WithLocation(19, 13)
            );
    }

    [Theory]
    [CombinatorialData]
    public void MemberNameAndSignatureConflict_32_Properties(bool insertAtTheBeginning)
    {
        var insert = """
    extension<S>(S[])
    {
        static void M1(int z) {}
    }
""";

        var src = @"
public static class Extensions
{
" + (insertAtTheBeginning ? insert : "") + @"

    extension<T>(T[])
    {
        T P => default;
    }

" + (!insertAtTheBeginning ? insert : "") + @"

    extension<U>(U[] receiver)
    {
#line 18
        void P(U x) {}
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (18,14): error CS0102: The type 'Extensions' already contains a definition for 'P'
            //         void P(U x) {}
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "P").WithArguments("Extensions", "P").WithLocation(18, 14)
            );
    }

    [Theory]
    [CombinatorialData]
    public void MemberNameAndSignatureConflict_33_Properties(bool insertAtTheBeginning)
    {
        var insert = """
    extension<S>(S[])
    {
        static void M1(int z) {}
    }
""";

        var src = @"
public static class Extensions
{
" + (insertAtTheBeginning ? insert : "") + @"

    extension<T>(T[])
    {
#line 8
        T P => default;
    }

" + (!insertAtTheBeginning ? insert : "") + @"

    extension<U>(U[] receiver)
    {
        static void set_P(U x) {}
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (8,11): error CS0082: Type 'Extensions' already reserves a member called 'set_P' with the same parameter types
            //         T P => default;
            Diagnostic(ErrorCode.ERR_MemberReserved, "P").WithArguments("set_P", "Extensions").WithLocation(8, 11)
            );
    }

    [Theory]
    [CombinatorialData]
    public void MemberNameAndSignatureConflict_34_Properties(bool insertAtTheBeginning)
    {
        var insert = """
    extension<S>(S[])
    {
        static void M1(int z) {}
    }
""";

        var src = @"
public static class Extensions
{
" + (insertAtTheBeginning ? insert : "") + @"

    extension<T>(T[])
    {
#line 8
        T P => default;
    }

" + (!insertAtTheBeginning ? insert : "") + @"

    extension<U>(U[] receiver)
    {
        U[] get_P => null;
    }
}
";
        var comp = CreateCompilation(src);

        comp.VerifyDiagnostics(
            // (8,16): error CS0102: The type 'Extensions' already contains a definition for 'get_P'
            //         T P => default;
            Diagnostic(ErrorCode.ERR_DuplicateNameInClass, "default").WithArguments("Extensions", "get_P").WithLocation(8, 16)
            );
    }

    [Fact]
    public void MethodInvocation_01()
    {
        var source = """
new object().M();

static class E1
{
    extension(object o)
    {
        public void M() { }
    }
}
static class E2
{
    public static void M(this object o) { }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (1,14): error CS0121: The call is ambiguous between the following methods or properties: 'E1.extension(object).M()' and 'E2.M(object)'
            // new object().M();
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E1.extension(object).M()", "E2.M(object)").WithLocation(1, 14));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal(["void E1.<>E__0.M()", "void System.Object.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void MethodInvocation_02()
    {
        var source = """
new object().M(42);

static class E1
{
    extension(object o)
    {
        public void M(int i) { System.Console.Write("ran"); }
    }
}
static class E2
{
    public static void M(this object o, string s) => throw null;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("void E1.<>E__0.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_03()
    {
        var source = """
new object().M("");

static class E1
{
    extension(object o)
    {
        public void M(int i) => throw null;
    }
}
static class E2
{
    public static void M(this object o, string s) { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M");
        Assert.Equal("void System.Object.M(System.String s)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_04()
    {
        var source = """
42.M();

static class E1
{
    extension(int i)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
static class E2
{
    public static void M(this int? i) => throw null;
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M");
        Assert.Equal("void E1.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_05()
    {
        var source = """
42.M();

static class E1
{
    extension(int? i)
    {
        public void M() => throw null;
    }
}
static class E2
{
    public static void M(this int i) { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M");
        Assert.Equal("void System.Int32.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_06()
    {
        var src = """
object.M();

public static class E
{
    extension(object)
    {
        public static void M<T>() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0411: The type arguments for method 'E.extension(object).M<T>()' cannot be inferred from the usage. Try specifying the type arguments explicitly.
            // object.M();
            Diagnostic(ErrorCode.ERR_CantInferMethTypeArgs, "M").WithArguments("E.extension(object).M<T>()").WithLocation(1, 8));
    }

    [Fact]
    public void MethodInvocation_RemoveLowerPriorityMembers_01()
    {
        var source = """
42.M(43);

static class E1
{
    extension(int i)
    {
        public void M(int j) => throw null;

        [System.Runtime.CompilerServices.OverloadResolutionPriority(1)]
        public void M(long l) { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation([source, OverloadResolutionPriorityAttributeDefinition]);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M");
        Assert.Equal("void E1.<>E__0.M(System.Int64 l)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveLowerPriorityMembers_02()
    {
        var source = """
42.M(43);

static class E1
{
    extension(int i)
    {
        public void M(int j) { System.Console.Write("ran"); }
    }
    extension(int i)
    {
        [System.Runtime.CompilerServices.OverloadResolutionPriority(1)]
        public void M(long l) => throw null;
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : ORPA should look at the containing static class (rather than look at the extension declaration) as the "containing type"
        var comp = CreateCompilation([source, OverloadResolutionPriorityAttributeDefinition]);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M");
        Assert.Equal("void E1.<>E__0.M(System.Int32 j)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveLowerPriorityMembers_03()
    {
        var source = """
42.M(43);

static class E1
{
    extension(int i)
    {
        public void M(int j) { System.Console.Write("ran"); }
    }
    [System.Runtime.CompilerServices.OverloadResolutionPriority(1)]
    public static void M(this int i, long l) => throw null;
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : ORPA should look at the containing static class (rather than look at the extension declaration) as the "containing type"
        var comp = CreateCompilation([source, OverloadResolutionPriorityAttributeDefinition]);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M");
        Assert.Equal("void E1.<>E__0.M(System.Int32 j)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveLowerPriorityMembers_04()
    {
        var source = """
42.M(43);

static class E1
{
    public static void M(this int i, int j) { System.Console.Write("ran"); }
    extension(int i)
    {
        [System.Runtime.CompilerServices.OverloadResolutionPriority(1)]
        public void M(long l) => throw null;
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : ORPA should look at the containing static class (rather than look at the extension declaration) as the "containing type"
        var comp = CreateCompilation([source, OverloadResolutionPriorityAttributeDefinition]);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M");
        Assert.Equal("void System.Int32.M(System.Int32 j)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveStaticInstanceMismatches_01()
    {
        var src = """
using N;

42.M();

static class E1
{
    extension(object o)
    {
        public static void M() => throw null; // skipped
    }
}

namespace N
{
    static class E2
    {
        extension(object o)
        {
            public void M() { System.Console.Write("ran"); }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M");
        Assert.Equal("void N.E2.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveStaticInstanceMismatches_02()
    {
        var src = """
using N;

42.M();

static class E1
{
    extension(object o)
    {
        public void M() { System.Console.Write("ran"); }
    }
}

namespace N
{
    static class E2
    {
        extension(object o)
        {
            public void M() => throw null;
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1));
        CompileAndVerify(comp, expectedOutput: "ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M");
        Assert.Equal("void E1.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveStaticInstanceMismatches_03()
    {
        var src = """
using N;

int.M();

static class E1
{
    extension(object o)
    {
        public void M() => throw null;
    }
}

namespace N
{
    static class E2
    {
        extension(object o)
        {
            public static void M() { System.Console.Write("ran"); }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.M");
        Assert.Equal("void N.E2.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveStaticInstanceMismatches_ColorColor_01()
    {
        var src = """
using N;

Color.M2(null);

class Color 
{ 
    public static void M2(Color Color)
    {
        Color.M();
    }
}

static class E1
{
    extension(Color)
    {
        public static void M() { System.Console.Write("ran"); }
    }
}

namespace N
{
    static class E2
    {
        extension(Color c)
        {
            public void M() => throw null;
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1));

        CompileAndVerify(comp, expectedOutput: "ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.M");
        Assert.Equal("void E1.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(SymbolKind.NamedType, model.GetSymbolInfo(memberAccess.Expression).Symbol.Kind);
    }

    [Fact]
    public void MethodInvocation_RemoveStaticInstanceMismatches_ColorColor_02()
    {
        var src = """
using N;

Color.M2(new Color());

class Color 
{ 
    public static void M2(Color Color)
    {
        Color.M();
    }
}

static class E1
{
    extension(Color c)
    {
        public void M() { System.Console.Write("ran"); }
    }
}

namespace N
{
    static class E2
    {
        extension(Color)
        {
            public static void M() => throw null;
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): hidden CS8019: Unnecessary using directive.
            // using N;
            Diagnostic(ErrorCode.HDN_UnusedUsingDirective, "using N;").WithLocation(1, 1));
        CompileAndVerify(comp, expectedOutput: "ran");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.M");
        Assert.Equal("void E1.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(SymbolKind.Parameter, model.GetSymbolInfo(memberAccess.Expression).Symbol.Kind);
    }

    [Fact]
    public void MethodInvocation_RemoveInaccessibleTypeArguments()
    {
        var src = """
int.M(new A.C());

static class E1
{
    extension(int)
    {
        public static void M<T>(I<T> x) { }
    }
}

interface I<T> { }

class A
{
    private class B { }
    public class C : I<B> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0122: 'E1.extension(int).M<A.B>(I<A.B>)' is inaccessible due to its protection level
            // int.M(new A.C());
            Diagnostic(ErrorCode.ERR_BadAccess, "M").WithArguments("E1.extension(int).M<A.B>(I<A.B>)").WithLocation(1, 5));
    }

    [Fact]
    public void MethodInvocation_RemoveLessDerivedMembers()
    {
        var src = """
"".M("");

static class E
{
    extension(object o)
    {
        public void M(string s) { }
    }
    extension(string s)
    {
        public void M(object o) { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,4): error CS0121: The call is ambiguous between the following methods or properties: 'E.extension(object).M(string)' and 'E.extension(string).M(object)'
            // "".M("");
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E.extension(object).M(string)", "E.extension(string).M(object)").WithLocation(1, 4));
    }

    [Fact]
    public void MethodInvocation_RemoveWorseMembers_01()
    {
        var src = """
I<C2> i = null;
i.M();

static class E1
{
    extension(I<C1> i)
    {
        public void M() { }
    }
}
static class E2
{
    extension(I<object> i)
    {
        public void M() { }
    }
}
interface I<out T> { }
class C1 { }
class C2 : C1 { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "i.M");
        Assert.Equal("void E1.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveWorseMembers_02()
    {
        var src = """
I<C2>.M();

static class E1
{
    extension(I<C1>)
    {
        public static void M() { }
    }
}
static class E2
{
    extension(I<object>)
    {
        public static void M() { }
    }
}
interface I<out T> { }
class C1 { }
class C2 : C1 { }
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm whether we want this betterness behavior (for methods and/or properties)
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "I<C2>.M");
        Assert.Equal("void E1.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveWorseMembers_03()
    {
        var src = """
42.M();

static class E1
{
    extension<T>(T t)
    {
        public void M() { }
    }
}
static class E2
{
    extension(int i)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M");
        Assert.Equal("void E2.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveWorseMembers_04()
    {
        var src = """
int.M();

static class E1
{
    extension<T>(T)
    {
        public static void M() { }
    }
}
static class E2
{
    extension(int)
    {
        public static void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.M");
        Assert.Equal("void E2.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveWorseMembers_05()
    {
        var src = """
42.M();

static class E1
{
    extension(int i)
    {
        public void M() { }
    }
}
static class E2
{
    extension(in int i)
    {
        public void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M");
        Assert.Equal("void E1.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveWorseMembers_06()
    {
        var src = """
int.M();

static class E1
{
    extension(int)
    {
        public static void M() { }
    }
}
static class E2
{
    extension(in int i)
    {
        public static void M() => throw null;
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm whether we want this betterness behavior (for methods and/or properties)
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.M");
        Assert.Equal("void E1.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_RemoveWorseMembers_07()
    {
        var src = """
int.M(42);

static class E1
{
    extension(int)
    {
        public static void M<T>(T t) { }
    }
}
static class E2
{
    extension<T>(T t)
    {
        public static void M(int i) => throw null;
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm whether we want this betterness behavior for methods
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0121: The call is ambiguous between the following methods or properties: 'E1.extension(int).M<T>(T)' and 'E2.extension<T>(T).M(int)'
            // int.M(42);
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E1.extension(int).M<T>(T)", "E2.extension<T>(T).M(int)").WithLocation(1, 5));
    }

    [Fact]
    public void MethodInvocation_RemoveWorseMembers_08()
    {
        var src = """
int.M(42);
0.M2(42);

static class E1
{
    extension<T>(T t)
    {
        public static void M<U>(U u) => throw null;
        public void M2<U>(U u) => throw null;
    }
}
static class E2
{
    extension<T>(T t)
    {
        public static void M(int i) { System.Console.Write("ran "); }
        public void M2(int i) { System.Console.Write("ran2"); }
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm whether we want this betterness behavior for methods when the receiver is a type
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran ran2").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.M");
        Assert.Equal("void E2.<>E__0<System.Int32>.M(System.Int32 i)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_ByValueArgumentForRefReadonlyParameter_01()
    {
        var src = """
int.M(42);

static class E
{
    extension(int)
    {
        public static void M(ref readonly int i) { System.Console.Write(i); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,7): warning CS9193: Argument 1 should be a variable because it is passed to a 'ref readonly' parameter
            // int.M(42);
            Diagnostic(ErrorCode.WRN_RefReadonlyNotVariable, "42").WithArguments("1").WithLocation(1, 7));

        CompileAndVerify(comp, expectedOutput: "42");
    }

    [Fact]
    public void MethodInvocation_ByValueArgumentForRefReadonlyParameter_02()
    {
        var src = """
int i = 42;
int.M(i);

static class E
{
    extension(int)
    {
        public static void M(ref readonly int i) { System.Console.Write(i); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,7): warning CS9192: Argument 1 should be passed with 'ref' or 'in' keyword
            // int.M(i);
            Diagnostic(ErrorCode.WRN_ArgExpectedRefOrIn, "i").WithArguments("1").WithLocation(2, 7));

        CompileAndVerify(comp, expectedOutput: "42");
    }

    [Fact]
    public void MethodInvocation_ByValueArgumentForRefReadonlyParameter_03()
    {
        var src = """
var f = (ref readonly int i) => int.M(i);
int i = 42;
f(ref i);


static class E
{
    extension(int)
    {
        public static void M(ref readonly int i) { System.Console.Write(i); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,39): warning CS9195: Argument 1 should be passed with the 'in' keyword
            // var f = (ref readonly int i) => int.M(i);
            Diagnostic(ErrorCode.WRN_ArgExpectedIn, "i").WithArguments("1").WithLocation(1, 39));

        CompileAndVerify(comp, expectedOutput: "42");
    }

    [Fact]
    public void MethodInvocation_RefArgumentForInParameter()
    {
        var src = """
int i = 42;
int.M(ref i);

static class E
{
    extension(int)
    {
        public static void M(in int i) { System.Console.Write(i); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,11): warning CS9191: The 'ref' modifier for argument 1 corresponding to 'in' parameter is equivalent to 'in'. Consider using 'in' instead.
            // int.M(ref i);
            Diagnostic(ErrorCode.WRN_BadArgRef, "i").WithArguments("1").WithLocation(2, 11));

        CompileAndVerify(comp, expectedOutput: "42");
    }

    [Fact]
    public void MethodInvocation_ByValueReceiverForRefReadonlyParameter_01()
    {
        var src = """
42.M();

static class E
{
    extension(ref readonly int i)
    {
        public void M() { System.Console.Write(42); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): warning CS9193: Argument 0 should be a variable because it is passed to a 'ref readonly' parameter
            // 42.M();
            Diagnostic(ErrorCode.WRN_RefReadonlyNotVariable, "42").WithArguments("0").WithLocation(1, 1));

        CompileAndVerify(comp, expectedOutput: "42");
    }

    [Fact]
    public void MethodInvocation_ByValueReceiverForRefReadonlyParameter_02()
    {
        var src = """
int i = 42;
i.M();

static class E
{
    extension(ref readonly int i)
    {
        public void M() { System.Console.Write(i); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();
    }

    [Fact]
    public void MethodInvocation_ByValueReceiverForRefReadonlyParameter_03()
    {
        var src = """
var f = (ref readonly int i) => i.M();
int i = 42;
f(ref i);

static class E
{
    extension(ref readonly int i)
    {
        public void M() { System.Console.Write(i); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();
    }

    [Fact]
    public void MethodInvocation_Params()
    {
        var src = """
int.M(42, 43);

static class E
{
    extension(int)
    {
        public static void M(params int[] i) { System.Console.Write((i[0], i[1])); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "(42, 43)").VerifyDiagnostics();
    }

    [Fact]
    public void MethodInvocation_Params_02()
    {
        var src = """
int.M([42, 43]);

static class E
{
    extension(int)
    {
        public static void M(params int[] i) { System.Console.Write((i[0], i[1])); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "(42, 43)").VerifyDiagnostics();
    }

    [Fact]
    public void MethodInvocation_Params_03()
    {
        var src = """
int.M([42, 43]);

static class E
{
    extension(int)
    {
        public static void M(params long[] l) { System.Console.Write((l[0], l[1]));  }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "(42, 43)").VerifyDiagnostics();
    }

    [Fact]
    public void MethodInvocation_DefaultValue()
    {
        var src = """
int.M();

static class E
{
    extension(int)
    {
        public static void M(int i = 42) { System.Console.Write(i); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();
    }

    [Fact]
    public void MethodInvocation_DefaultValue_02()
    {
        var src = """
42.M();

static class E
{
    extension(int i = 0)
    {
        public void M(int j = 1) { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,15): error CS9284: The receiver parameter of an extension cannot have a default value
            //     extension(int i = 0)
            Diagnostic(ErrorCode.ERR_ExtensionParameterDisallowsDefaultValue, "int i = 0").WithLocation(5, 15));
    }

    [Fact]
    public void MethodInvocation_InaccessibleTypeArguments()
    {
        var src = """
new A.C().M();
new A.C().M2();

static class E1
{
    extension<T>(I<T> i)
    {
        public void M() { }
    }
    public static void M2<T>(this I<T> i) { }
}

interface I<T> { }

class A
{
    private class B { }
    public class C : I<B> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,11): error CS0122: 'E1.extension<A.B>(I<A.B>).M()' is inaccessible due to its protection level
            // new A.C().M();
            Diagnostic(ErrorCode.ERR_BadAccess, "M").WithArguments("E1.extension<A.B>(I<A.B>).M()").WithLocation(1, 11),
            // (2,11): error CS0122: 'E1.M2<A.B>(I<A.B>)' is inaccessible due to its protection level
            // new A.C().M2();
            Diagnostic(ErrorCode.ERR_BadAccess, "M2").WithArguments("E1.M2<A.B>(I<A.B>)").WithLocation(2, 11));
    }

    [Fact]
    public void PropertyAccess_InaccessibleTypeArguments()
    {
        var src = """
_ = new A.C().P;

static class E1
{
    extension<T>(I<T> i)
    {
        public int P => 0;
    }
}

interface I<T> { }

class A
{
    private class B { }
    public class C : I<B> { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS9286: 'A.C' does not contain a definition for 'P' and no accessible extension member 'P' for receiver of type 'A.C' could be found (are you missing a using directive or an assembly reference?)
            // _ = new A.C().P;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "new A.C().P").WithArguments("A.C", "P").WithLocation(1, 5));
    }

    [Fact]
    public void MethodInvocation_ReceiverConversion()
    {
        var src = """
42.M();

static class E
{
    extension(object o)
    {
        public void M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var literal = GetSyntax<LiteralExpressionSyntax>(tree, "42");
        Assert.Equal("System.Int32", model.GetTypeInfo(literal).Type.ToTestDisplayString());
        Assert.Equal("System.Object", model.GetTypeInfo(literal).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_ReceiverConversion_ColorColor()
    {
        var src = """
Color.M2(new Color(42));

class Color(int i) : Base(i)
{ 
    public static void M2(Color Color)
    {
        Color.M();
    }
}

class Base(int i) { public int value = i; }

static class E
{
    extension(Base b)
    {
        public void M() { System.Console.Write(b.value); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var color = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.M").Expression;
        Assert.Equal("Color", model.GetTypeInfo(color).Type.ToTestDisplayString());
        Assert.Equal("Base", model.GetTypeInfo(color).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void PropertyAccess_ReceiverConversion()
    {
        var src = """
_  = 42.P;

static class E
{
    extension(object o)
    {
        public int P => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var literal = GetSyntax<LiteralExpressionSyntax>(tree, "42");
        Assert.Equal("System.Int32", model.GetTypeInfo(literal).Type.ToTestDisplayString());
        Assert.Equal("System.Object", model.GetTypeInfo(literal).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void PropertyAccess_ReceiverConversion_ColorColor()
    {
        var src = """
Color.M2(new Color(42));

class Color(int i) : Base(i)
{ 
    public static void M2(Color Color)
    {
        _ = Color.P;
    }
}

class Base(int i) { public int value = i; }

static class E
{
    extension(Base b)
    {
        public int P { get { System.Console.Write(b.value); return 0; } }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var color = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.P").Expression;
        Assert.Equal("Color", model.GetTypeInfo(color).Type.ToTestDisplayString());
        Assert.Equal("Base", model.GetTypeInfo(color).ConvertedType.ToTestDisplayString());
    }

    [Fact]
    public void MethodInvocation_BrokenConstraint_01()
    {
        var src = """
42.M("", null);

static class E
{
    extension(object o)
    {
        public void M<T>(T t, C<T> c) where T : struct => throw null;
    }
}

class C<U> where U : struct { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,4): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'E.extension(object).M<T>(T, C<T>)'
            // 42.M("", null);
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M").WithArguments("E.extension(object).M<T>(T, C<T>)", "T", "string").WithLocation(1, 4));
    }

    [Fact]
    public void MethodInvocation_BrokenConstraint_02()
    {
        var src = """
42.M(null, "");

static class E
{
    extension(object o)
    {
        public void M<T>(C<T> c, T t) where T : struct => throw null;
    }
}

class C<U> where U : struct { }
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,4): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'E.extension(object).M<T>(C<T>, T)'
            // 42.M(null, "");
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M").WithArguments("E.extension(object).M<T>(C<T>, T)", "T", "string").WithLocation(1, 4));
    }

    [Fact]
    public void MethodInvocation_ExtraRef()
    {
        var src = """
int i = 0;
int.M(ref i);

static class E
{
    extension(int)
    {
        public static void M(int i) => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,11): error CS1615: Argument 2 may not be passed with the 'ref' keyword
            // int.M(ref i);
            Diagnostic(ErrorCode.ERR_BadArgExtraRef, "i").WithArguments("2", "ref").WithLocation(2, 11));
    }

    [Fact]
    public void SingleCandidate_Extension()
    {
        string src = """
public class C
{
    static void Main()
    {
        dynamic d = 1;
        var result = new C().Test("name", d);
        System.Console.Write(result);        
    }
}

static class Extensions
{
    extension(C c)
    {
        public int Test(string name, object value) => 123;
    }
}
""";

        var comp = CreateCompilation(src, targetFramework: TargetFramework.StandardAndCSharp);

        comp.VerifyDiagnostics(
            // (6,22): error CS1973: 'C' has no applicable method named 'Test' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.
            //         var result = new C().Test("name", d);
            Diagnostic(ErrorCode.ERR_BadArgTypeDynamicExtension, @"new C().Test(""name"", d)").WithArguments("C", "Test").WithLocation(6, 22));
    }

    [Fact]
    public void ArgList_Error()
    {
        string source = """
dynamic d = 1;
object.M(d);

static class Extensions
{
    extension(object)
    {
        public static int M(__arglist) => 123;
    }
}
""";
        CreateCompilation(source, targetFramework: TargetFramework.Net90).VerifyDiagnostics(
            // (2,10): error CS1503: Argument 2: cannot convert from 'dynamic' to '__arglist'
            // object.M(d);
            Diagnostic(ErrorCode.ERR_BadArgType, "d").WithArguments("2", "dynamic", "__arglist").WithLocation(2, 10));
    }

    [Fact]
    public void ArgList()
    {
        string source = """
int i = 1;
object.M(__arglist(i));

static class Extensions
{
    extension(object)
    {
        public static void M(__arglist) { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void MethodInvocation_ReceiverWithTupleDifferences()
    {
        string source = """
C<(int, int other)>.M();

static class Extensions
{
    extension(C<(int a, int b)>)
    {
        public static void M() { System.Console.Write("ran"); }
    }
}

class C<T> { }
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();
    }

    [Fact]
    public void PropertyAccess_RemoveStaticInstanceMismatches_InstanceReceiver()
    {
        var source = """
System.Console.Write(42.P);

static class E1
{
    extension(int i)
    {
        public int P => 43;
    }
}
static class E2
{
    extension(int)
    {
        public static int P => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "43").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.P");
        Assert.Equal("System.Int32 E1.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void PropertyAccess_RemoveStaticInstanceMismatches_StaticReceiver()
    {
        var source = """
System.Console.Write(int.P);

static class E1
{
    extension(int i)
    {
        public int P => throw null;
    }
}
static class E2
{
    extension(int)
    {
        public static int P => 42;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.P");
        Assert.Equal("System.Int32 E2.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyAccess_RemoveStaticInstanceMismatches_ColorColor_01()
    {
        var source = """
class Color
{
    static void M(Color Color)
    {
        _ = Color.P;
    }
}

static class E1
{
    extension(Color c)
    {
        public int P => 0;
    }
}
static class E2
{
    extension(Color)
    {
        public static int P => 0;
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (5,13): error CS9286: 'Color' does not contain a definition for 'P' and no accessible extension member 'P' for receiver of type 'Color' could be found (are you missing a using directive or an assembly reference?)
            //         _ = Color.P;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "Color.P").WithArguments("Color", "P").WithLocation(5, 13));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.P");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Int32 E1.<>E__0.P { get; }", "System.Int32 E2.<>E__0.P { get; }"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyAccess_RemoveStaticInstanceMismatches_ColorColor_02()
    {
        var source = """
Color.M(new Color());

class Color
{
    public static void M(Color Color)
    {
        _ = Color.P;
    }
}

static class E1
{
    extension(Color c)
    {
        public int P { get { System.Console.Write("ran"); return 0; } }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.P");
        Assert.Equal("System.Int32 E1.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal("Color Color", model.GetSymbolInfo(memberAccess.Expression).Symbol.ToTestDisplayString());
        Assert.Equal(SymbolKind.Parameter, model.GetSymbolInfo(memberAccess.Expression).Symbol.Kind);
    }

    [Fact]
    public void PropertyAccess_RemoveStaticInstanceMismatches_ColorColor_03()
    {
        var source = """
Color.M(null);

class Color
{
    public static void M(Color Color)
    {
        _ = Color.P;
    }
}

static class E1
{
    extension(Color c)
    {
        public static int P { get { System.Console.Write("ran"); return 0; } }
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "Color.P");
        Assert.Equal("System.Int32 E1.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal("Color", model.GetSymbolInfo(memberAccess.Expression).Symbol.ToTestDisplayString());
        Assert.Equal(SymbolKind.NamedType, model.GetSymbolInfo(memberAccess.Expression).Symbol.Kind);
    }

    [Fact]
    public void RefOmittedComCall()
    {
        // For COM import type, omitting the ref is allowed
        string source = @"
using System;
using System.Runtime.InteropServices;

short x = 123;
C c = new C();
c.M(x);
c.I(123);

[ComImport, Guid(""1234C65D-1234-447A-B786-64682CBEF136"")]
class C { }

static class E
{
    extension(C c)
    {
        public void M(ref short p) { }
        public void M(sbyte p) { }
        public void I(ref int p) { }
    }
}
";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void RefOmittedComCall_02()
    {
        string source = @"
using System;
using System.Runtime.InteropServices;

C c = default;
c.M();
c.M2();

[ComImport, Guid(""1234C65D-1234-447A-B786-64682CBEF136"")]
class C { }

static class E
{
    extension(ref C c)
    {
        public void M() { }
    }
    public static void M2(this ref C c) { }
}
";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : missing ERR_RefExtensionMustBeValueTypeOrConstrainedToOne on the extension parameter
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (7,3): error CS1061: 'C' does not contain a definition for 'M2' and no accessible extension method 'M2' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
            // c.M2();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M2").WithArguments("C", "M2").WithLocation(7, 3),
            // (18,24): error CS8337: The first parameter of a 'ref' extension method 'M2' must be a value type or a generic type constrained to struct.
            //     public static void M2(this ref C c) { }
            Diagnostic(ErrorCode.ERR_RefExtensionMustBeValueTypeOrConstrainedToOne, "M2").WithArguments("M2").WithLocation(18, 24));
    }

    [Fact]
    public void RefOmittedComCall_03()
    {
        string source = @"
using System;
using System.Runtime.InteropServices;

C c = default;
c.M();
c.M2();

[ComImport, Guid(""1234C65D-1234-447A-B786-64682CBEF136"")]
struct C { }

static class E
{
    extension(ref C c)
    {
        public void M() { }
    }
    public static void M2(this ref C c) { }
}
";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (9,2): error CS0592: Attribute 'ComImport' is not valid on this declaration type. It is only valid on 'class, interface' declarations.
            // [ComImport, Guid("1234C65D-1234-447A-B786-64682CBEF136")]
            Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "ComImport").WithArguments("ComImport", "class, interface").WithLocation(9, 2));
    }

    [Fact]
    public void RefOmittedComCall_04()
    {
        // For COM import type, omitting the ref is allowed (even in static scenarios)
        string source = @"
using System;
using System.Runtime.InteropServices;

short x = 42;
short y = 43;
C.M(x.ToString(), y.ToString());

[ComImport, Guid(""1234C65D-1234-447A-B786-64682CBEF136"")]
class C { }

static class E
{
    extension(C)
    {
        public static void M(ref string p, ref string p2) { }
    }
}
";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        var verifier = CompileAndVerify(comp);
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size       32 (0x20)
  .maxstack  2
  .locals init (short V_0, //x
                short V_1, //y
                string V_2,
                string V_3)
  IL_0000:  ldc.i4.s   42
  IL_0002:  stloc.0
  IL_0003:  ldc.i4.s   43
  IL_0005:  stloc.1
  IL_0006:  ldloca.s   V_0
  IL_0008:  call       "string short.ToString()"
  IL_000d:  stloc.2
  IL_000e:  ldloca.s   V_2
  IL_0010:  ldloca.s   V_1
  IL_0012:  call       "string short.ToString()"
  IL_0017:  stloc.3
  IL_0018:  ldloca.s   V_3
  IL_001a:  call       "void E.M(ref string, ref string)"
  IL_001f:  ret
}
""");

        source = """
using System;
using System.Runtime.InteropServices;

short x = 42;
C.M(x.ToString());

[ComImport, Guid("1234C65D-1234-447A-B786-64682CBEF136")]
class C 
{ 
    public extern static void M(ref string p);
}
""";
        comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        verifier = CompileAndVerify(comp, verify: Verification.FailsPEVerify);
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size       19 (0x13)
  .maxstack  1
  .locals init (short V_0, //x
                string V_1)
  IL_0000:  ldc.i4.s   42
  IL_0002:  stloc.0
  IL_0003:  ldloca.s   V_0
  IL_0005:  call       "string short.ToString()"
  IL_000a:  stloc.1
  IL_000b:  ldloca.s   V_1
  IL_000d:  call       "void C.M(ref string)"
  IL_0012:  ret
}
""");
    }

    [Fact]
    public void RefOmittedComCall_05()
    {
        string source = @"
using System;
using System.Runtime.InteropServices;

short x = 42;
C.M(x.ToString());

[ComImport, Guid(""1234C65D-1234-447A-B786-64682CBEF136"")]
class C { }

static class E
{
    extension(C)
    {
        public static void M(string p) { }
    }
}
";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        var verifier = CompileAndVerify(comp);
        verifier.VerifyIL("<top-level-statements-entry-point>", """
{
  // Code size       16 (0x10)
  .maxstack  1
  .locals init (short V_0) //x
  IL_0000:  ldc.i4.s   42
  IL_0002:  stloc.0
  IL_0003:  ldloca.s   V_0
  IL_0005:  call       "string short.ToString()"
  IL_000a:  call       "void E.M(string)"
  IL_000f:  ret
}
""");
    }

    [Fact]
    public void Nullability_Method_01()
    {
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Nullability is undone
        string source = """
#nullable enable

string? s = null;
s.M();

static class E
{
    extension<T>(T t)
    {
        public void M() { System.Console.Write(t is null); }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics(
            // (4,1): warning CS8602: Dereference of a possibly null reference.
            // s.M();
            Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(4, 1));
        CompileAndVerify(comp, expectedOutput: "True");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "s.M");
        Assert.Equal("void E.<>E__0<System.String>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void Nullability_Method_02()
    {
        string source = """
#nullable enable

string s = "";
s.M(null);

static class E
{
    extension<T>(T t)
    {
        public void M(T t2) { System.Console.Write(t2 is null); }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "True");

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "s.M");
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : Nullability is undone
        Assert.Equal("void E.<>E__0<System.String>.M(System.String t2)", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void PropertyAccess_RemoveWorseMembers_01()
    {
        string source = """
string s = "";
System.Console.Write(s.P);

static class E
{
    extension(string s)
    {
        public int P => 42;
    }
    extension(object o)
    {
        public int P => throw null;
    }
}
""";
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "s.P");
        Assert.Equal("System.Int32 E.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyAccess_RemoveWorseMembers_02()
    {
        string source = """
System.Console.Write(string.P);

static class E1
{
    extension(string s)
    {
        public static int P => 42;
    }
}
static class E2
{
    extension(object o)
    {
        public static int P => throw null;
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm what betterness behavior we want for static properties
        var comp = CreateCompilation(source);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "string.P");
        Assert.Equal("System.Int32 E1.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyAccess_RemoveWorseMembers_03()
    {
        var src = """
I<string> i = null;
System.Console.Write(i.P);

interface I<out T> { }

static class E
{
    extension(I<string> i)
    {
        public int P => 42;
    }
    extension(I<object> i)
    {
        public int P => throw null;
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm what betterness behavior we want for properties
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "i.P");
        Assert.Equal("System.Int32 E.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyAccess_RemoveWorseMembers_04()
    {
        var src = """
I<string> i = null;
System.Console.Write(i.P);

interface I<out T> { }

static class E
{
    extension(I<object> i)
    {
        public int P => throw null;
    }
    extension(I<string> i)
    {
        public int P => 42;
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm what betterness behavior we want for properties
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "i.P");
        Assert.Equal("System.Int32 E.<>E__1.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyAccess_RemoveWorseMembers_05()
    {
        var src = """
System.Console.Write(42.P);

static class E1
{
    extension(int i)
    {
        public int P => 42;
    }
}
static class E2
{
    extension(in int i)
    {
        public int P => throw null;
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : confirm what betterness behavior we want for properties
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.P");
        Assert.Equal("System.Int32 E1.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyAccess_RemoveWorseMembers_06()
    {
        var src = """
System.Console.Write(int.P);

static class E1
{
    extension(int i)
    {
        public static int P => 42;
    }
}

static class E2
{
    extension(in int i)
    {
        public static int P => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.P");
        Assert.Equal("System.Int32 E1.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyAccess_RemoveWorseMembers_07()
    {
        var src = """
System.Console.Write(int.P);

static class E1
{
    extension(int i)
    {
        public static int P => 42;
    }
}

static class E2
{
    extension<T>(T t)
    {
        public static int P => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.P");
        Assert.Equal("System.Int32 E1.<>E__0.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyOrMethod_RemoveWorseMembers_01()
    {
        var src = """
string s = null;
s.M();

static class E
{
    extension(string s)
    {
        public System.Action M => throw null;
    }
    extension(object o)
    {
        public string M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,1): error CS9286: 'string' does not contain a definition for 'M' and no accessible extension member 'M' for receiver of type 'string' could be found (are you missing a using directive or an assembly reference?)
            // s.M();
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "s.M").WithArguments("string", "M").WithLocation(2, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "s.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Action E.<>E__0.M { get; }", "System.String E.<>E__1.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyOrMethod_RemoveWorseMembers_02()
    {
        var src = """
string.M();

static class E
{
    extension(object)
    {
        public static System.Action M => throw null;
    }
    extension(string)
    {
        public static string M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS9286: 'string' does not contain a definition for 'M' and no accessible extension member 'M' for receiver of type 'string' could be found (are you missing a using directive or an assembly reference?)
            // string.M();
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "string.M").WithArguments("string", "M").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "string.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Action E.<>E__0.M { get; }", "System.String E.<>E__1.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyOrMethod_RemoveWorseMembers_03()
    {
        var src = """
I<string> i = null;
i.M();

interface I<out T> { }

static class E
{
    extension(I<string> i)
    {
        public System.Action M => throw null;
    }
    extension(I<object> i)
    {
        public string M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,1): error CS9286: 'I<string>' does not contain a definition for 'M' and no accessible extension member 'M' for receiver of type 'I<string>' could be found (are you missing a using directive or an assembly reference?)
            // i.M();
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "i.M").WithArguments("I<string>", "M").WithLocation(2, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "i.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Action E.<>E__0.M { get; }", "System.String E.<>E__1.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyOrMethod_RemoveWorseMembers_04()
    {
        var src = """
I<string> i = null;
i.M();

interface I<out T> { }

static class E1
{
    extension(I<object> i)
    {
        public System.Action M => throw null;
    }
}

static class E2
{
    extension(I<string> i)
    {
        public string M() => throw null;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,1): error CS9286: 'I<string>' does not contain a definition for 'M' and no accessible extension member 'M' for receiver of type 'I<string>' could be found (are you missing a using directive or an assembly reference?)
            // i.M();
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "i.M").WithArguments("I<string>", "M").WithLocation(2, 1));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "i.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["System.Action E1.<>E__0.M { get; }", "System.String E2.<>E__0.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Empty(model.GetMemberGroup(memberAccess));
    }

    [Fact]
    public void Dynamic_01()
    {
        var src = """
dynamic d = new object();
object.M(d);
new object().M(d);

static class E
{
    extension<U>(U)
    {
        public static int M<T>(T t) => throw null;
    }
    public static int M2<U, T>(this U u, T t) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,1): error CS1929: 'object' does not contain a definition for 'M' and the best extension method overload 'E.extension<U>(U).M<T>(T)' requires a receiver of type 'U'
            // object.M(d);
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "object").WithArguments("object", "M", "E.extension<U>(U).M<T>(T)", "U").WithLocation(2, 1),
            // (3,1): error CS1929: 'object' does not contain a definition for 'M' and the best extension method overload 'E.extension<U>(U).M<T>(T)' requires a receiver of type 'U'
            // new object().M(d);
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "new object()").WithArguments("object", "M", "E.extension<U>(U).M<T>(T)", "U").WithLocation(3, 1));
    }

    [Fact]
    public void Dynamic_02()
    {
        var src = """
dynamic d = new object();
object.M(d);
new object().M2(d);

static class E
{
    extension(object)
    {
        public static int M<T>(T t) => throw null;
    }
    public static int M2<T>(this object o, T t) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,1): error CS1973: 'object' has no applicable method named 'M' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.
            // object.M(d);
            Diagnostic(ErrorCode.ERR_BadArgTypeDynamicExtension, "object.M(d)").WithArguments("object", "M").WithLocation(2, 1),
            // (3,1): error CS1973: 'object' has no applicable method named 'M2' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.
            // new object().M2(d);
            Diagnostic(ErrorCode.ERR_BadArgTypeDynamicExtension, "new object().M2(d)").WithArguments("object", "M2").WithLocation(3, 1));
    }

    [Fact]
    public void Dynamic_03()
    {
        var src = """
dynamic d = new object();
object.M(d);
new object().M2(d);

static class E
{
    extension<U>(U)
    {
        public static int M(object o) => throw null;
    }
    public static int M2<U>(this U u, object o) => throw null;
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,1): error CS1929: 'object' does not contain a definition for 'M' and the best extension method overload 'E.extension<U>(U).M(object)' requires a receiver of type 'U'
            // object.M(d);
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "object").WithArguments("object", "M", "E.extension<U>(U).M(object)", "U").WithLocation(2, 1),
            // (3,1): error CS1973: 'object' has no applicable method named 'M2' but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax.
            // new object().M2(d);
            Diagnostic(ErrorCode.ERR_BadArgTypeDynamicExtension, "new object().M2(d)").WithArguments("object", "M2").WithLocation(3, 1));
    }

    [Fact]
    public void Dynamic_04()
    {
        var src = """
int i = 42;
i.M(i);
i.M2(i);

static class E
{
    extension(object o)
    {
        public void M(dynamic d) { System.Console.Write(d); }
    }

    public static void M2(this object o, dynamic d) { }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net90);
        CompileAndVerify(comp, expectedOutput: ExpectedOutput("42"), verify: Verification.FailsPEVerify).VerifyDiagnostics();
    }

    [Fact]
    public void Dynamic_05()
    {
        var src = """
try
{
    dynamic d = 42;
    _ = d.P;
}
catch (Microsoft.CSharp.RuntimeBinder.RuntimeBinderException e)
{
    System.Console.Write(e.Message);
}

static class E
{
    extension(object o)
    {
        public int P => 0;
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net90);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: ExpectedOutput("'int' does not contain a definition for 'P'"), verify: Verification.FailsPEVerify);

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "d.P");
        var dynamicType = model.GetTypeInfo(memberAccess.Expression).Type;
        Assert.True(dynamicType.IsDynamic());
        AssertEqualAndNoDuplicates(["System.Int32 E.<>E__0.P { get; }"], model.LookupSymbols(position: 0, dynamicType, name: "P", includeReducedExtensionMethods: true).ToTestDisplayStrings());
        AssertEqualAndNoDuplicates(["System.Int32 E.<>E__0.P { get; }"], model.LookupSymbols(position: 0, dynamicType, name: null, includeReducedExtensionMethods: true).ToTestDisplayStrings());
    }

    [Fact]
    public void Dynamic_06()
    {
        var src = """
try
{
    dynamic d = 42;
    d.M();
}
catch (Microsoft.CSharp.RuntimeBinder.RuntimeBinderException e)
{
    System.Console.Write(e.Message);
}

static class E
{
    extension(object o)
    {
        public void M() { }
    }
}
""";
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net90);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: ExpectedOutput("'int' does not contain a definition for 'M'"), verify: Verification.FailsPEVerify);
    }

    [Fact]
    public void ResolveExtension_01()
    {
        var src = """
using N;

System.Console.Write(object.M());

static class E1
{
    extension(string) // inapplicable
    {
        public static System.Action M => null;
    }
}

namespace N
{
    static class E2
    {
        extension(object)
        {
            public static int M() => 42;
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: ExpectedOutput("42")).VerifyDiagnostics();
    }

    [Fact]
    public void ResolveExtension_02()
    {
        var src = """
using N;

object.M();

static class E1
{
    extension(string) // inapplicable
    {
        public static System.Action M => null;
    }
}

namespace N
{
    static class E2
    {
        extension(object)
        {
            public static System.Action M => () => { System.Console.Write("ran"); };
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: ExpectedOutput("ran")).VerifyDiagnostics();
    }

    [Fact]
    public void ResolveExtension_03()
    {
        var src = """
using N;

new object().M();

static class E1
{
    public static void M(this string s) { } // inapplicable
}

namespace N
{
    static class E2
    {
        extension(object o)
        {
            public System.Action M => () => { System.Console.Write("ran"); };
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: ExpectedOutput("ran")).VerifyDiagnostics();
    }

    [Fact]
    public void ResolveExtension_04()
    {
        var src = """
using N;

new object().M();

static class E1
{
    public static void M(this string s) { } // inapplicable
}

namespace N
{
    static class E2
    {
        extension(object o)
        {
            public void M() { System.Console.Write("ran"); }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: ExpectedOutput("ran")).VerifyDiagnostics();
    }

    [Fact]
    public void ResolveExtension_05()
    {
        var src = """
using N;

new object().M();

static class E1
{
    extension(string s) // inapplicable
    {
        public void M() { }
    }
}

namespace N
{
    static class E2
    {
        extension(object o)
        {
            public System.Action M => () => { System.Console.Write("ran"); };
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: ExpectedOutput("ran")).VerifyDiagnostics();
    }

    [Fact]
    public void ResolveExtension_06()
    {
        var src = """
using N;

new object().M();

static class E1
{
    extension(string s) // inapplicable
    {
        public void M() { }
    }
}

namespace N
{
    static class E2
    {
        extension(object o)
        {
            public void M() { System.Console.Write("ran"); }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: ExpectedOutput("ran")).VerifyDiagnostics();
    }

    [Fact]
    public void PropertyAccess_ByValueReceiverForRefReadonlyParameter_01()
    {
        var src = """
_ = 42.P;

static class E
{
    extension(ref readonly int i)
    {
        public int P { get { System.Console.Write(i); return 0; } }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): warning CS9193: Argument 0 should be a variable because it is passed to a 'ref readonly' parameter
            // _ = 42.P;
            Diagnostic(ErrorCode.WRN_RefReadonlyNotVariable, "42").WithArguments("0").WithLocation(1, 5));

        CompileAndVerify(comp, expectedOutput: "42");
    }

    [Fact]
    public void PropertyAccess_ByValueReceiverForRefReadonlyParameter_02()
    {
        var src = """
int i = 42;
_ = i.P;

static class E
{
    extension(ref readonly int i)
    {
        public int P { get { System.Console.Write(i); return 0; } }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();
    }

    [Fact]
    public void PropertyAccess_ByValueReceiverForRefReadonlyParameter_03()
    {
        var src = """
var f = (ref readonly int i) => i.P;
int i = 42;
f(ref i);

static class E
{
    extension(ref readonly int i)
    {
        public int P { get { System.Console.Write(i); return 0; } }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "42").VerifyDiagnostics();
    }

    [Fact]
    public void PropertyAccess_AmbiguityWithNoArguments()
    {
        var src = """
int x = new object().M;

public static class E1
{
    extension(object o)
    {
        public int M => 42;
    }
}

public static class E2
{
    public static void M(this object o) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS9286: 'object' does not contain a definition for 'M' and no accessible extension member 'M' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // int x = new object().M;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "new object().M").WithArguments("object", "M").WithLocation(1, 9));
    }

    [Fact]
    public void ConstAccess()
    {
        var src = """
_ = int.Const;

static class E
{
    extension(int)
    {
        public const int Const = 42;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS0117: 'int' does not contain a definition for 'Const'
            // _ = int.Const;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "Const").WithArguments("int", "Const").WithLocation(1, 9),
            // (7,26): error CS9282: Extension declarations can include only methods or properties
            //         public const int Const = 42;
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "Const").WithLocation(7, 26));
    }

    [Fact]
    public void ParamsReceiver_01()
    {
        // extension(params int[] i)
        var ilSrc = """
.class public auto ansi abstract sealed beforefieldinit E
    extends System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends System.Object
    {
        // Methods
        .method private hidebysig specialname static void '<Extension>$' ( int32[] i ) cil managed 
        {
            .param [1]
            .custom instance void [mscorlib]System.ParamArrayAttribute::.ctor() = ( 01 00 00 00)

            IL_0000: ret
        }
        .method public hidebysig instance void M () cil managed 
        {
            IL_0000: ldnull
            IL_0001: throw
        }
    }
    .method public hidebysig specialname static void 'M' ( int32[] i ) cil managed 
    {
        .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
            01 00 00 00
        )
        .param [1]
        .custom instance void [mscorlib]System.ParamArrayAttribute::.ctor() = ( 01 00 00 00)

        IL_0000: ldstr "ran"
        IL_0005: call void [mscorlib]System.Console::Write(string)
        IL_000a: ret
    }
}
""";
        var src = """
int[] i = null;
i.M();
""";
        var comp = CreateCompilationWithIL(src, ilSrc);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran");

        src = """
int i = 0;
i.M();
""";
        comp = CreateCompilationWithIL(src, ilSrc);
        comp.VerifyEmitDiagnostics(
            // (2,1): error CS1929: 'int' does not contain a definition for 'M' and the best extension method overload 'E.extension(params int[]).M()' requires a receiver of type 'params int[]'
            // i.M();
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "i").WithArguments("int", "M", "E.extension(params int[]).M()", "params int[]").WithLocation(2, 1));

        src = """
int i = 0;
i.M(2);
""";
        comp = CreateCompilationWithIL(src, ilSrc);
        comp.VerifyEmitDiagnostics(
            // (2,3): error CS1501: No overload for method 'M' takes 1 arguments
            // i.M(2);
            Diagnostic(ErrorCode.ERR_BadArgCount, "M").WithArguments("M", "1").WithLocation(2, 3));
    }

    [Fact]
    public void ParamsReceiver_02()
    {
        // extension(params int[] i)
        var ilSrc = """
.class public auto ansi abstract sealed beforefieldinit E
    extends System.Object
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.ExtensionAttribute::.ctor() = (
        01 00 00 00
    )
    .class nested public auto ansi sealed beforefieldinit '<>E__0'
        extends System.Object
    {
        .method private hidebysig specialname static void '<Extension>$' ( int32[] i ) cil managed 
        {
            .param [1]
            .custom instance void [mscorlib]System.ParamArrayAttribute::.ctor() = ( 01 00 00 00)

            IL_0000: ret
        }
        .method public hidebysig specialname instance int32 get_P () cil managed 
        {
            IL_0000: ldnull
            IL_0001: throw
        }
        .property instance int32 P()
        {
            .get instance int32 E/'<>E__0'::get_P()
        }
    }
    .method public hidebysig specialname static int32 'get_P' ( int32[] i ) cil managed 
    {
        .param [1]
        .custom instance void [mscorlib]System.ParamArrayAttribute::.ctor() = ( 01 00 00 00)

        IL_0000: ldstr "ran"
        IL_0005: call void [mscorlib]System.Console::Write(string)
        IL_000a: ldc.i4.0
        IL_000b: ret
    }
}
""";
        var src = """
int[] i = null;
_ = i.P;
""";
        var comp = CreateCompilationWithIL(src, ilSrc);
        comp.VerifyEmitDiagnostics();
        CompileAndVerify(comp, expectedOutput: "ran");

        src = """
int i = 0;
_ = i.P;
""";
        comp = CreateCompilationWithIL(src, ilSrc);
        comp.VerifyEmitDiagnostics(
            // (2,5): error CS9286: 'int' does not contain a definition for 'P' and no accessible extension member 'P' for receiver of type 'int' could be found (are you missing a using directive or an assembly reference?)
            // _ = i.P;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "i.P").WithArguments("int", "P").WithLocation(2, 5));

        src = """
int i = 0;
_ = i.P(1);
""";
        comp = CreateCompilationWithIL(src, ilSrc);
        comp.VerifyEmitDiagnostics(
            // (2,7): error CS1061: 'int' does not contain a definition for 'P' and no accessible extension method 'P' accepting a first argument of type 'int' could be found (are you missing a using directive or an assembly reference?)
            // _ = i.P(1);
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "P").WithArguments("int", "P").WithLocation(2, 7));
    }

    [Fact]
    public void ExplicitTypeArguments_01()
    {
        var src = """
string s = "ran";
s.M<object>();

static class E
{
    extension<T>(T t)
    {
        public void M() { System.Console.Write(t); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "s.M<object>()");
        Assert.Equal("void E.<>E__0<System.Object>.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetMemberGroup(invocation).ToTestDisplayStrings());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "s.M<object>");
        Assert.Equal(["void E.<>E__0<System.Object>.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExplicitTypeArguments_02()
    {
        var src = """
42.M<object>();

static class E
{
    extension<T>(T t) where T : struct
    {
        public void M() { System.Console.Write(t); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,4): error CS0453: The type 'object' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'E.extension<T>(T)'
            // 42.M<object>();
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M<object>").WithArguments("E.extension<T>(T)", "T", "object").WithLocation(1, 4));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "42.M<object>()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);
        Assert.Equal([], model.GetMemberGroup(invocation).ToTestDisplayStrings());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M<object>");
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExplicitTypeArguments_03()
    {
        var src = """
string s = "ran";
_ = s.P<object>;

static class E
{
    extension<T>(T t)
    {
        public int P => 0;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,7): error CS1061: 'string' does not contain a definition for 'P' and no accessible extension method 'P' accepting a first argument of type 'string' could be found (are you missing a using directive or an assembly reference?)
            // _ = s.P<object>;
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "P<object>").WithArguments("string", "P").WithLocation(2, 7));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "s.P<object>");
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExplicitTypeArguments_04()
    {
        var src = """
string s = "ran";
s.M<string>();

static class E
{
    extension<T>(T t)
    {
        public void M() => throw null;
    }
    extension(string s)
    {
        public void M<T>() { System.Console.Write(s); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "s.M<string>");
        Assert.Equal(["void E.<>E__0<System.String>.M()", "void E.<>E__1.M<System.String>()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExplicitTypeArguments_05()
    {
        var src = """
string s = null;
s.M<string>();

static class E
{
    extension<T>(T t)
    {
        public void M<U>() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (2,3): error CS1061: 'string' does not contain a definition for 'M' and no accessible extension method 'M' accepting a first argument of type 'string' could be found (are you missing a using directive or an assembly reference?)
            // s.M<string>();
            Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "M<string>").WithArguments("string", "M").WithLocation(2, 3));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "s.M<string>");
        Assert.Equal(["void E.<>E__0<System.String>.M<U>()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExplicitTypeArguments_06()
    {
        var src = """
C<string, string>.M<string>();

class C<T1, T2> { }
static class E
{
    extension<T, U>(C<T, U> t)
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,19): error CS0117: 'C<string, string>' does not contain a definition for 'M'
            // C<string, string>.M<string>();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M<string>").WithArguments("C<string, string>", "M").WithLocation(1, 19));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<string, string>.M<string>");
        Assert.Equal(["void E.<>E__0<System.String, System.String>.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExplicitTypeArguments_07()
    {
        var src = """
string.M<object, long>(42);

static class E
{
    extension<T>(T t)
    {
        public static void M<U>(U u) { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "string.M<object, long>(42)");
        Assert.Equal("void E.<>E__0<System.Object>.M<System.Int64>(System.Int64 u)", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "string.M<object, long>");
        Assert.Equal(["void E.<>E__0<System.Object>.M<System.Int64>(System.Int64 u)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExplicitTypeArguments_08()
    {
        var src = """
object.M<string, long>(42);

static class E
{
    extension<T>(T t)
    {
        public static void M<U>(U u) { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS1929: 'object' does not contain a definition for 'M' and the best extension method overload 'E.extension<string>(string).M<long>(long)' requires a receiver of type 'string'
            // object.M<string, long>(42);
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "object").WithArguments("object", "M", "E.extension<string>(string).M<long>(long)", "string").WithLocation(1, 1));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M<string, long>");
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void ExplicitTypeArguments_09()
    {
        var src = """
42.M<object>(42);
42.M2<object>(42);

static class E
{
    extension(int i)
    {
        public void M<T>(T t) where T : struct { }
    }

    public static void M2<T>(this int i, T t) where T : struct { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,4): error CS0453: The type 'object' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'E.extension(int).M<T>(T)'
            // 42.M<object>(42);
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M<object>").WithArguments("E.extension(int).M<T>(T)", "T", "object").WithLocation(1, 4),
            // (2,4): error CS0453: The type 'object' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'E.M2<T>(int, T)'
            // 42.M2<object>(42);
            Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M2<object>").WithArguments("E.M2<T>(int, T)", "T", "object").WithLocation(2, 4));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M<object>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M2<object>");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void GetDeclaredSymbol_01()
    {
        var src = """
static class E
{
    extension(int i)
    {
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var extensionParameter = tree.GetRoot().DescendantNodes().OfType<ParameterSyntax>().Single();

        var symbol = model.GetDeclaredSymbol(extensionParameter);
        Assert.Equal(SymbolKind.Parameter, symbol.Kind);
        Assert.Equal("System.Int32 i", symbol.ToTestDisplayString());
    }

    readonly string[] _objectMembers = [
        "System.String System.Object.ToString()",
        "System.Boolean System.Object.Equals(System.Object obj)",
        "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
        "System.Int32 System.Object.GetHashCode()",
        "System.Type System.Object.GetType()",
        "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"];

    [Fact]
    public void LookupSymbols_Simple()
    {
        var src = """
object.M();
_ = object.Property;

public static class E
{
    extension(object)
    {
        public static void M() => throw null;
        public static int Property => throw null;
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "object.M()");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        var property = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.Property");
        Assert.Equal("System.Int32 E.<>E__0.Property { get; }", model.GetSymbolInfo(property).Symbol.ToTestDisplayString());

        var e = ((Compilation)comp).GlobalNamespace.GetTypeMember("E");
        AssertEqualAndNoDuplicates(["void E.M()"], model.LookupSymbols(position: 0, e, name: "M").ToTestDisplayStrings());
        AssertEqualAndNoDuplicates(["void E.M()", "void E.<>E__0.M()"], model.LookupSymbols(position: 0, e, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, e, name: "Property").ToTestDisplayStrings());
        AssertEqualAndNoDuplicates(["System.Int32 E.<>E__0.Property { get; }"], model.LookupSymbols(position: 0, e, name: "Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates(["System.Int32 E.get_Property()"], model.LookupSymbols(position: 0, e, name: "get_Property").ToTestDisplayStrings());

        AssertEqualAndNoDuplicates(["System.Int32 E.get_Property()"],
            model.LookupSymbols(position: 0, e, name: "get_Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, o, name: "M").ToTestDisplayStrings());
        AssertEqualAndNoDuplicates(["void E.<>E__0.M()"], model.LookupSymbols(position: 0, o, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, o, name: "Property").ToTestDisplayStrings());
        AssertEqualAndNoDuplicates(["System.Int32 E.<>E__0.Property { get; }"], model.LookupSymbols(position: 0, o, name: "Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates(["void E.<>E__0.M()", "System.Int32 E.<>E__0.Property { get; }", .. _objectMembers],
            model.LookupSymbols(position: 0, o, name: null, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        Assert.Equal([
            "System.Boolean System.Object.Equals(System.Object objA, System.Object objB)",
            "System.Boolean System.Object.ReferenceEquals(System.Object objA, System.Object objB)"],
            model.LookupStaticMembers(position: 0, o, name: null).ToTestDisplayStrings()); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : should we include extension static members?

        Assert.Empty(model.LookupNamespacesAndTypes(position: 0, o, name: null));
    }

    [Fact]
    public void LookupSymbols_Inapplicable()
    {
        var src = """
object.M();
_ = object.Property;

public static class E
{
    extension(string)
    {
        public static void M() => throw null;
        public static int Property => throw null;
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,1): error CS1929: 'object' does not contain a definition for 'M' and the best extension method overload 'E.extension(string).M()' requires a receiver of type 'string'
            // object.M();
            Diagnostic(ErrorCode.ERR_BadInstanceArgType, "object").WithArguments("object", "M", "E.extension(string).M()", "string").WithLocation(1, 1),
            // (2,5): error CS9286: 'object' does not contain a definition for 'Property' and no accessible extension member 'Property' for receiver of type 'object' could be found (are you missing a using directive or an assembly reference?)
            // _ = object.Property;
            Diagnostic(ErrorCode.ERR_ExtensionResolutionFailed, "object.Property").WithArguments("object", "Property").WithLocation(2, 5));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, o, name: "M").ToTestDisplayStrings());
        AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, o, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, o, name: "Property").ToTestDisplayStrings());
        AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, o, name: "Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates(_objectMembers, model.LookupSymbols(position: 0, o, name: null, includeReducedExtensionMethods: true).ToTestDisplayStrings());
    }

    [Fact]
    public void LookupSymbols_Substituted_01()
    {
        var src = """
string.M();
_ = string.Property;

public static class E
{
    extension<T>(T)
    {
        public static void M() => throw null;
        public static int Property => throw null;
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, o, name: "M").ToTestDisplayStrings());
        AssertEqualAndNoDuplicates(["void E.<>E__0<System.Object>.M()"], model.LookupSymbols(position: 0, o, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, o, name: "Property").ToTestDisplayStrings());
        AssertEqualAndNoDuplicates(["System.Int32 E.<>E__0<System.Object>.Property { get; }"], model.LookupSymbols(position: 0, o, name: "Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates(["void E.<>E__0<System.Object>.M()", "System.Int32 E.<>E__0<System.Object>.Property { get; }", .. _objectMembers],
            model.LookupSymbols(position: 0, o, name: null, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        var s = ((Compilation)comp).GetSpecialType(SpecialType.System_String);
        AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, s, name: "M").ToTestDisplayStrings());
        AssertEqualAndNoDuplicates(["void E.<>E__0<System.String>.M()"], model.LookupSymbols(position: 0, s, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, s, name: "Property").ToTestDisplayStrings());
        AssertEqualAndNoDuplicates(["System.Int32 E.<>E__0<System.String>.Property { get; }"], model.LookupSymbols(position: 0, s, name: "Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());
    }

    [Fact]
    public void LookupSymbols_Substituted_02()
    {
        var src = """
string.M(42);

public static class E
{
    extension<T>(T)
    {
        public static void M<U>(U u) => throw null;
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var s = ((Compilation)comp).GetSpecialType(SpecialType.System_String);
        AssertEqualAndNoDuplicates(["void E.<>E__0<System.String>.M<U>(U u)"], model.LookupSymbols(position: 0, s, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());
    }

    [Fact]
    public void LookupSymbols_StaticAndInstance()
    {
        var src = """
public static class E1
{
    extension(object)
    {
        public static void M() => throw null;
        public static int Property => throw null;
    }
}
public static class E2
{
    extension(object)
    {
        public void M() => throw null;
        public int Property => throw null;
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertEqualAndNoDuplicates(["void E1.<>E__0.M()", "void E2.<>E__0.M()"],
            model.LookupSymbols(position: 0, o, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates(["System.Int32 E1.<>E__0.Property { get; }", "System.Int32 E2.<>E__0.Property { get; }"],
            model.LookupSymbols(position: 0, o, name: "Property", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates([
            "void E1.<>E__0.M()",
            "System.Int32 E1.<>E__0.Property { get; }",
            "void E2.<>E__0.M()",
            "System.Int32 E2.<>E__0.Property { get; }",
            .. _objectMembers], model.LookupSymbols(position: 0, o, name: null, includeReducedExtensionMethods: true).ToTestDisplayStrings());
    }

    [Fact]
    public void LookupSymbols_MethodAndProperty()
    {
        var src = """
public static class E1
{
    extension(object)
    {
        public static void MP() => throw null;
    }
}
public static class E2
{
    extension(object)
    {
        public int MP => throw null;
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertEqualAndNoDuplicates(["void E1.<>E__0.MP()", "System.Int32 E2.<>E__0.MP { get; }"],
            model.LookupSymbols(position: 0, o, name: "MP", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates(["void E1.<>E__0.MP()", "System.Int32 E2.<>E__0.MP { get; }", .. _objectMembers],
            model.LookupSymbols(position: 0, o, name: null, includeReducedExtensionMethods: true).ToTestDisplayStrings());
    }

    [Fact]
    public void LookupSymbols_ClassicAndNew()
    {
        var src = """

public static class E
{
    extension(object)
    {
        public static void M() => throw null;
        public void M(string s) => throw null;
    }

    public static void M(this object o, int i) { }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertEqualAndNoDuplicates(["void E.<>E__0.M()", "void E.<>E__0.M(System.String s)", "void System.Object.M(System.Int32 i)"],
            model.LookupSymbols(position: 0, o, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates(["void E.<>E__0.M()", "void E.<>E__0.M(System.String s)", "void System.Object.M(System.Int32 i)", .. _objectMembers],
            model.LookupSymbols(position: 0, o, name: null, includeReducedExtensionMethods: true).ToTestDisplayStrings());
    }

    [Fact]
    public void LookupSymbols_NestedType()
    {
        var src = """

public static class E
{
    extension(object)
    {
        static class Nested { }
    }
}
""";

        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (6,22): error CS9282: Extension declarations can include only methods or properties
            //         static class Nested { }
            Diagnostic(ErrorCode.ERR_ExtensionDisallowsMember, "Nested").WithLocation(6, 22));

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);

        var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);
        AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, o, name: "Nested", includeReducedExtensionMethods: true).ToTestDisplayStrings());
        AssertEqualAndNoDuplicates([.. _objectMembers], model.LookupSymbols(position: 0, o, name: null, includeReducedExtensionMethods: true).ToTestDisplayStrings());

        Assert.Empty(model.LookupNamespacesAndTypes(position: 0, o, name: null));
    }

    [Fact]
    public void LookupSymbols_ExtensionParameter()
    {
        var src = """
public static class E
{
    extension(object o)
    {
    }
}
""";

        var comp = CreateCompilation(src);

        var tree = comp.SyntaxTrees.Single();
        var model = comp.GetSemanticModel(tree);
        var extension = tree.GetRoot().DescendantNodes().OfType<ExtensionDeclarationSyntax>().Single();

        int position = extension.OpenBraceToken.EndPosition;
        AssertEqualAndNoDuplicates(["System.Object o"], model.LookupSymbols(position, null, name: "o").ToTestDisplayStrings());
        AssertEx.Equal("System.Object o", model.LookupSymbols(position, null, name: null).OfType<IParameterSymbol>().Single().ToTestDisplayString());
        Assert.Empty(model.LookupNamespacesAndTypes(position, null, name: "o"));

        position = extension.OpenBraceToken.Position;
        Assert.Empty(model.LookupSymbols(position, null, name: "o"));
        Assert.Empty(model.LookupSymbols(position, null, name: null).OfType<IParameterSymbol>());
    }

    [Fact]
    public void GetMemberGroup_01()
    {
        var src = """
object.M<int>();
new object().M2<int>();

static class E
{
    extension(object)
    {
        public static void M<U>() where U : class { }
    }

    public static void M2<U>(this object o) where U : class { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'U' in the generic type or method 'E.extension(object).M<U>()'
            // object.M<int>();
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "M<int>").WithArguments("E.extension(object).M<U>()", "U", "int").WithLocation(1, 8),
            // (2,14): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'U' in the generic type or method 'E.M2<U>(object)'
            // new object().M2<int>();
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "M2<int>").WithArguments("E.M2<U>(object)", "U", "int").WithLocation(2, 14));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M<int>");
        Assert.Equal([], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M2<int>");
        Assert.Equal([], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void GetMemberGroup_02()
    {
        var src = """
object.M(42);
new object().M2(42);

static class E
{
    extension(object)
    {
        public static void M<U>(U u) where U : class { }
    }

    public static void M2<U>(this object o, U u) where U : class { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'U' in the generic type or method 'E.extension(object).M<U>(U)'
            // object.M(42);
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "M").WithArguments("E.extension(object).M<U>(U)", "U", "int").WithLocation(1, 8),
            // (2,14): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'U' in the generic type or method 'E.M2<U>(object, U)'
            // new object().M2(42);
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "M2").WithArguments("E.M2<U>(object, U)", "U", "int").WithLocation(2, 14));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal(["void E.<>E__0.M<U>(U u)"], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "new object().M2");
        Assert.Equal(["void System.Object.M2<U>(U u)"], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void GetMemberGroup_03()
    {
        var src = """
int.M<int>();
42.M2<int>();

static class E
{
    extension<T>(T) where T : class
    {
        public static void M() { }
    }

    public static void M2<T>(this T t) where T : class { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'T' in the generic type or method 'E.extension<T>(T)'
            // int.M<int>();
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "M<int>").WithArguments("E.extension<T>(T)", "T", "int").WithLocation(1, 5),
            // (2,4): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'T' in the generic type or method 'E.M2<T>(T)'
            // 42.M2<int>();
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "M2<int>").WithArguments("E.M2<T>(T)", "T", "int").WithLocation(2, 4));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.M<int>");
        Assert.Equal([], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M2<int>");
        Assert.Equal([], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void GetMemberGroup_04()
    {
        var src = """
int.M();
42.M2();

static class E
{
    extension<T>(T) where T : class
    {
        public static void M() { }
    }

    public static void M2<T>(this T t) where T : class { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,5): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'T' in the generic type or method 'E.extension<T>(T)'
            // int.M();
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "M").WithArguments("E.extension<T>(T)", "T", "int").WithLocation(1, 5),
            // (2,4): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'T' in the generic type or method 'E.M2<T>(T)'
            // 42.M2();
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "M2").WithArguments("E.M2<T>(T)", "T", "int").WithLocation(2, 4));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess1 = GetSyntax<MemberAccessExpressionSyntax>(tree, "int.M");
        Assert.Equal([], model.GetMemberGroup(memberAccess1).ToTestDisplayStrings());

        var memberAccess2 = GetSyntax<MemberAccessExpressionSyntax>(tree, "42.M2");
        Assert.Equal([], model.GetMemberGroup(memberAccess2).ToTestDisplayStrings());
    }

    [Fact]
    public void GetMemberGroup_05()
    {
        var src = """
object.M();

static class E
{
    extension(object)
    {
        public static void M() { }
        public static void M(int i) { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal(["void E.<>E__0.M()", "void E.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void GetMemberGroup_06()
    {
        var src = """
_ = object.P;

static class E
{
    extension(object)
    {
        public static int P => 0;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.P");
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : handle GetMemberGroup on a property access
    }

    [Fact]
    public void GetMemberGroup_07()
    {
        var src = """
object.M();

static class E1
{
    extension(object)
    {
        public static int M => 0;
    }
}
static class E2
{
    extension(object)
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal(["System.Int32 E1.<>E__0.M { get; }", "void E2.<>E__0.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void GetMemberGroup_08()
    {
        var src = """
string.M();

static class E1
{
    extension<T>(T)
    {
        public static int M => 0;
    }
}
static class E2
{
    extension<T>(T)
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "string.M");
        Assert.Equal("void E2.<>E__0<System.String>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["System.Int32 E1.<>E__0<System.String>.M { get; }", "void E2.<>E__0<System.String>.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "string.M()");
        Assert.Equal("void E2.<>E__0<System.String>.M()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void GetMemberGroup_09()
    {
        var src = """
string.M();

static class E1
{
    extension<T>(T)
    {
        public static void M() { }
    }
}
static class E2
{
    extension<T>(T)
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0121: The call is ambiguous between the following methods or properties: 'E1.extension<T>(T).M()' and 'E2.extension<T>(T).M()'
            // string.M();
            Diagnostic(ErrorCode.ERR_AmbigCall, "M").WithArguments("E1.extension<T>(T).M()", "E2.extension<T>(T).M()").WithLocation(1, 8));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "string.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void E1.<>E__0<System.String>.M()", "void E2.<>E__0<System.String>.M()"], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void E1.<>E__0<System.String>.M()", "void E2.<>E__0<System.String>.M()"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void GetMemberGroup_10()
    {
        var src = """
System.Action a = new System.Action(object.M);

static class E
{
    extension(object)
    {
        public static void M() { }
        public static void M(int i) { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("void E.<>E__0.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0.M()", "void E.<>E__0.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void GetMemberGroup_11()
    {
        var src = """
System.Action a = new System.Action(object.M);

static class E
{
    extension<T>(T)
    {
        public static void M() { }
        public static void M(int i) { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("void E.<>E__0<System.Object>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void E.<>E__0<System.Object>.M()", "void E.<>E__0<System.Object>.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void GetMemberGroup_12()
    {
        var src = """
System.Action a = (System.Action)object.M;

static class E
{
    extension<T>(T)
    {
        public static void M() { }
        public static void M(int i) { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.M");
        Assert.Equal("void E.<>E__0<System.Object>.M()", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void E.<>E__0<System.Object>.M()", "void E.<>E__0<System.Object>.M(System.Int32 i)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());

        var cast = GetSyntax<CastExpressionSyntax>(tree, "(System.Action)object.M");
        Assert.Equal("void E.<>E__0<System.Object>.M()", model.GetSymbolInfo(cast).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(cast).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal([], model.GetMemberGroup(cast).ToTestDisplayStrings());
    }

    [Fact]
    public void ToBadExpression_01()
    {
        var source = """
class A
{
    void F() { }
}

class C
{
    static void M(A a)
    {
        a.F();
        M(a.F);
    }
    static void M(System.Action a) { }
}

static class E1
{
    static void F<T>(this T t) { }
}

static class E2
{
    extension<T>(T)
    {
        static void F() { }
    }
}
""";
        var comp = CreateCompilation(source);
        comp.VerifyDiagnostics(
            // (10,11): error CS0122: 'A.F()' is inaccessible due to its protection level
            //         a.F();
            Diagnostic(ErrorCode.ERR_BadAccess, "F").WithArguments("A.F()").WithLocation(10, 11),
            // (11,13): error CS0122: 'A.F()' is inaccessible due to its protection level
            //         M(a.F);
            Diagnostic(ErrorCode.ERR_BadAccess, "F").WithArguments("A.F()").WithLocation(11, 13));

        var tree = comp.SyntaxTrees[0];
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntaxes<MemberAccessExpressionSyntax>(tree, "a.F").ToArray();
        Assert.Null(model.GetSymbolInfo(memberAccess[0]).Symbol);
        Assert.Equal(["void A.F()"], model.GetSymbolInfo(memberAccess[0]).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void A.F()", "void E2.<>E__0<A>.F()", "void A.F<A>()"], model.GetMemberGroup(memberAccess[0]).ToTestDisplayStrings());

        Assert.Null(model.GetSymbolInfo(memberAccess[1]).Symbol);
        Assert.Equal(["void A.F()", "void E2.<>E__0<A>.F()", "void A.F<A>()"], model.GetSymbolInfo(memberAccess[1]).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal(["void A.F()", "void E2.<>E__0<A>.F()", "void A.F<A>()"], model.GetMemberGroup(memberAccess[1]).ToTestDisplayStrings());
    }

    [Fact]
    public void PropertyAccess_NotAmbiguousWithInapplicableMethod()
    {
        var src = """
int i = object.P;
System.Console.Write(i);

static class E1
{
    extension<T>(T) where T : struct
    {
        public static void P() { }
    }
}

static class E2
{
    extension<T>(T) where T : class
    {
        public static int P => 42;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "object.P");
        Assert.Equal("System.Int32 E2.<>E__0<System.Object>.P { get; }", model.GetSymbolInfo(memberAccess).Symbol.ToTestDisplayString());
        Assert.Equal([], model.GetSymbolInfo(memberAccess).CandidateSymbols.ToTestDisplayStrings());
        Assert.Equal([], model.GetMemberGroup(memberAccess).ToTestDisplayStrings()); // Tracked by https://github.com/dotnet/roslyn/issues/76130 : handle GetMemberGroup on a property access
    }

    [Fact]
    public void GetSymbolInfo_GenericMethodInGenericType_01()
    {
        var src = """
class C<T>
{
    public static void M<T2>(T2 x) { }
    public static void M(int x) { }
}

class D
{
    public void Test()
    {
        C<int>.M<int>(1);
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var genericName = GetSyntax<GenericNameSyntax>(tree, "M<int>");
        Assert.Equal("void C<System.Int32>.M<System.Int32>(System.Int32 x)", model.GetSymbolInfo(genericName).Symbol.ToTestDisplayString());
        Assert.Equal(["void C<System.Int32>.M<System.Int32>(System.Int32 x)"], model.GetMemberGroup(genericName).ToTestDisplayStrings());
    }

    [Fact]
    public void GetSymbolInfo_GenericMethodInGenericType_02()
    {
        var src = """
class C<T>
{
    public static void M<T2>(T2 x) where T2 : class { }
}

class D
{
    public void Test()
    {
        C<int>.M<int>(1);
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (10,16): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'T2' in the generic type or method 'C<int>.M<T2>(T2)'
            //         C<int>.M<int>(1);
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "M<int>").WithArguments("C<int>.M<T2>(T2)", "T2", "int").WithLocation(10, 16));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var genericName = GetSyntax<GenericNameSyntax>(tree, "M<int>");
        Assert.Null(model.GetSymbolInfo(genericName).Symbol);
        Assert.Equal([], model.GetMemberGroup(genericName).ToTestDisplayStrings());
    }

    [Fact]
    public void GetSymbolInfo_GenericMethodInGenericType_03()
    {
        var src = """
class C<T>
{
    public static void M<T2>(T2 x) where T2 : class { }
}

class D
{
    public void Test()
    {
        C<int>.M(1);
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (10,16): error CS0452: The type 'int' must be a reference type in order to use it as parameter 'T2' in the generic type or method 'C<int>.M<T2>(T2)'
            //         C<int>.M(1);
            Diagnostic(ErrorCode.ERR_RefConstraintNotSatisfied, "M").WithArguments("C<int>.M<T2>(T2)", "T2", "int").WithLocation(10, 16));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var memberAccess = GetSyntax<MemberAccessExpressionSyntax>(tree, "C<int>.M");
        Assert.Null(model.GetSymbolInfo(memberAccess).Symbol);
        Assert.Equal(["void C<System.Int32>.M<T2>(T2 x)"], model.GetMemberGroup(memberAccess).ToTestDisplayStrings());
    }

    [Fact]
    public void GetSymbolInfo_04()
    {
        var src = """
class C
{
    private static void M<T>()
    {
        M<T>();
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var genericName = GetSyntax<InvocationExpressionSyntax>(tree, "M<T>()").Expression;
        Assert.Equal("void C.M<T>()", model.GetSymbolInfo(genericName).Symbol.ToTestDisplayString());
        Assert.Equal(["void C.M<T>()"], model.GetMemberGroup(genericName).ToTestDisplayStrings());
    }

    [Fact]
    public void GetSymbolInfo_05()
    {
        var src = """
public static class E
{
    extension<T>(T t)
    {
        static void M()
        {
            T.M<T>();
            T.M();
            E.M<T>();
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (7,13): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //             T.M<T>();
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(7, 13),
            // (8,13): error CS0704: Cannot do non-virtual member lookup in 'T' because it is a type parameter
            //             T.M();
            Diagnostic(ErrorCode.ERR_LookupInTypeVariable, "T").WithArguments("T").WithLocation(8, 13));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var expr = GetSyntax<InvocationExpressionSyntax>(tree, "T.M<T>()").Expression;
        Assert.Null(model.GetSymbolInfo(expr).Symbol);
        Assert.Equal([], model.GetMemberGroup(expr).ToTestDisplayStrings());

        expr = GetSyntax<InvocationExpressionSyntax>(tree, "T.M()").Expression;
        Assert.Null(model.GetSymbolInfo(expr).Symbol);
        Assert.Equal([], model.GetMemberGroup(expr).ToTestDisplayStrings());

        expr = GetSyntax<InvocationExpressionSyntax>(tree, "E.M<T>()").Expression;
        Assert.Equal("void E.M<T>()", model.GetSymbolInfo(expr).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.M<T>()"], model.GetMemberGroup(expr).ToTestDisplayStrings());
    }

    [Fact]
    public void GetSymbolInfo_06()
    {
        var src = """
public static class E
{
    extension<T>(T t)
    {
        void M()
        {
            t.M<T>();
            t.M();
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var expr = GetSyntax<InvocationExpressionSyntax>(tree, "t.M<T>()").Expression;
        Assert.Equal("void E.<>E__0<T>.M()", model.GetSymbolInfo(expr).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0<T>.M()"], model.GetMemberGroup(expr).ToTestDisplayStrings());

        expr = GetSyntax<InvocationExpressionSyntax>(tree, "t.M()").Expression;
        Assert.Equal("void E.<>E__0<T>.M()", model.GetSymbolInfo(expr).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0<T>.M()"], model.GetMemberGroup(expr).ToTestDisplayStrings());
    }

    [Fact]
    public void GetSymbolInfo_07()
    {
        var src = """
public static class E
{
    extension<T>(T t)
    {
        void M<U>(U u)
        {
            t.M<T, U>(u);
            t.M(u);

            t.M(42);
            42.M(u);
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var extensionParameterSyntax = tree.GetRoot().DescendantNodes().OfType<ParameterSyntax>().First();
        IParameterSymbol extensionParameter = model.GetDeclaredSymbol(extensionParameterSyntax);
        Assert.Equal("T t", extensionParameter.ToTestDisplayString());
        var t = extensionParameter.Type;

        var expr = GetSyntax<InvocationExpressionSyntax>(tree, "t.M<T, U>(u)").Expression;
        Assert.Equal("void E.<>E__0<T>.M<U>(U u)", model.GetSymbolInfo(expr).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0<T>.M<U>(U u)"], model.GetMemberGroup(expr).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates(["void E.<>E__0<T>.M<U>(U u)"], model.LookupSymbols(position: expr.SpanStart, t, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        expr = GetSyntax<InvocationExpressionSyntax>(tree, "t.M(u)").Expression;
        Assert.Equal("void E.<>E__0<T>.M<U>(U u)", model.GetSymbolInfo(expr).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0<T>.M<U>(U u)"], model.GetMemberGroup(expr).ToTestDisplayStrings());

        expr = GetSyntax<InvocationExpressionSyntax>(tree, "t.M(42)").Expression;
        Assert.Equal("void E.<>E__0<T>.M<System.Int32>(System.Int32 u)", model.GetSymbolInfo(expr).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0<T>.M<U>(U u)"], model.GetMemberGroup(expr).ToTestDisplayStrings());

        expr = GetSyntax<InvocationExpressionSyntax>(tree, "42.M(u)").Expression;
        Assert.Equal("void E.<>E__0<System.Int32>.M<U>(U u)", model.GetSymbolInfo(expr).Symbol.ToTestDisplayString());
        Assert.Equal(["void E.<>E__0<System.Int32>.M<U>(U u)"], model.GetMemberGroup(expr).ToTestDisplayStrings());
    }

    [Fact]
    public void GetSymbolInfo_08()
    {
        var src = """
public static class E
{
    public static void M<T>(this T t)
    {
        t.M<T>();
        t.M();
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);

        var extensionParameterSyntax = tree.GetRoot().DescendantNodes().OfType<ParameterSyntax>().First();
        IParameterSymbol extensionParameter = model.GetDeclaredSymbol(extensionParameterSyntax);
        Assert.Equal("T t", extensionParameter.ToTestDisplayString());
        var t = extensionParameter.Type;

        var expr = GetSyntax<InvocationExpressionSyntax>(tree, "t.M<T>()").Expression;
        Assert.Equal("void T.M<T>()", model.GetSymbolInfo(expr).Symbol.ToTestDisplayString());
        Assert.Equal(["void T.M<T>()"], model.GetMemberGroup(expr).ToTestDisplayStrings());

        AssertEqualAndNoDuplicates(["void T.M<T>()"], model.LookupSymbols(position: expr.SpanStart, t, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());

        expr = GetSyntax<InvocationExpressionSyntax>(tree, "t.M()").Expression;
        Assert.Equal("void T.M<T>()", model.GetSymbolInfo(expr).Symbol.ToTestDisplayString());
        Assert.Equal(["void T.M<T>()"], model.GetMemberGroup(expr).ToTestDisplayStrings());
    }

    [Fact]
    public void LangVer_01()
    {
        var libSrc = """
public static class E
{
    extension(object)
    {
        public void M() { }
        public static void M2() { }
        public static int P => 0;
    }
}

""";
        var libComp = CreateCompilation(libSrc, parseOptions: TestOptions.RegularNext);
        libComp.VerifyEmitDiagnostics();
        var libRef = libComp.EmitToImageReference();

        var srcCompat = """
new object().M();
System.Action a = new object().M;
var x = new object().M;

E.M(new object());
E.get_P();
E.M2();
""";
        var comp = CreateCompilation(srcCompat, references: [libRef], parseOptions: TestOptions.Regular13);
        comp.VerifyEmitDiagnostics();

        comp = CreateCompilation(srcCompat, references: [libRef], parseOptions: TestOptions.RegularNext);
        comp.VerifyEmitDiagnostics();

        comp = CreateCompilation(srcCompat, references: [libRef]);
        comp.VerifyEmitDiagnostics();

        var src = """
object.M2();
System.Action a = object.M2;
var x = object.M2;

_ = object.P;
""";
        comp = CreateCompilation(src, references: [libRef], parseOptions: TestOptions.Regular13);
        comp.VerifyEmitDiagnostics(
            // (1,8): error CS0117: 'object' does not contain a definition for 'M2'
            // object.M2();
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M2").WithArguments("object", "M2").WithLocation(1, 8),
            // (2,26): error CS0117: 'object' does not contain a definition for 'M2'
            // System.Action a = object.M2;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M2").WithArguments("object", "M2").WithLocation(2, 26),
            // (3,16): error CS0117: 'object' does not contain a definition for 'M2'
            // var x = object.M2;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "M2").WithArguments("object", "M2").WithLocation(3, 16),
            // (5,12): error CS0117: 'object' does not contain a definition for 'P'
            // _ = object.P;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "P").WithArguments("object", "P").WithLocation(5, 12));
        verifySymbolInfo(comp, newLangVer: false);

        comp = CreateCompilation(src, references: [libRef], parseOptions: TestOptions.RegularNext);
        comp.VerifyEmitDiagnostics();
        verifySymbolInfo(comp, newLangVer: true);

        comp = CreateCompilation(src, references: [libRef]);
        comp.VerifyEmitDiagnostics();
        verifySymbolInfo(comp, newLangVer: true);

        static void verifySymbolInfo(CSharpCompilation comp, bool newLangVer)
        {
            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);
            var o = ((Compilation)comp).GetSpecialType(SpecialType.System_Object);

            if (newLangVer)
            {
                AssertEqualAndNoDuplicates(["void E.<>E__0.M()"], model.LookupSymbols(position: 0, o, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());
                AssertEqualAndNoDuplicates(["void E.<>E__0.M2()"], model.LookupSymbols(position: 0, o, name: "M2", includeReducedExtensionMethods: true).ToTestDisplayStrings());
                AssertEqualAndNoDuplicates(["System.Int32 E.<>E__0.P { get; }"], model.LookupSymbols(position: 0, o, name: "P", includeReducedExtensionMethods: true).ToTestDisplayStrings());
            }
            else
            {
                AssertEqualAndNoDuplicates(["void System.Object.M()"], model.LookupSymbols(position: 0, o, name: "M", includeReducedExtensionMethods: true).ToTestDisplayStrings());
                AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, o, name: "M2", includeReducedExtensionMethods: true).ToTestDisplayStrings());
                AssertEqualAndNoDuplicates([], model.LookupSymbols(position: 0, o, name: "P", includeReducedExtensionMethods: true).ToTestDisplayStrings());
            }
        }
    }

    [Fact]
    public void This_01()
    {
        var src = """
static class E
{
    extension(object)
    {
        public void M()
        {
            var x = this;
            this.ToString();
            local();

            void local()
            {
                var y = this;
            }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (7,21): error CS0027: Keyword 'this' is not available in the current context
            //             var x = this;
            Diagnostic(ErrorCode.ERR_ThisInBadContext, "this").WithLocation(7, 21),
            // (8,13): error CS0027: Keyword 'this' is not available in the current context
            //             this.ToString();
            Diagnostic(ErrorCode.ERR_ThisInBadContext, "this").WithLocation(8, 13),
            // (13,25): error CS0027: Keyword 'this' is not available in the current context
            //                 var y = this;
            Diagnostic(ErrorCode.ERR_ThisInBadContext, "this").WithLocation(13, 25));
    }

    [Fact]
    public void This_02()
    {
        var src = """
static class E
{
    extension(object o)
    {
        public void M()
        {
            M2();
            this.M2();
            M2(new object());
        }
        public void M2() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (7,13): error CS7036: There is no argument given that corresponds to the required parameter 'o' of 'E.M2(object)'
            //             M2();
            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "M2").WithArguments("o", "E.M2(object)").WithLocation(7, 13),
            // (8,13): error CS0027: Keyword 'this' is not available in the current context
            //             this.M2();
            Diagnostic(ErrorCode.ERR_ThisInBadContext, "this").WithLocation(8, 13));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Null(model.GetSymbolInfo(invocation).Symbol);

        invocation = GetSyntax<InvocationExpressionSyntax>(tree, "this.M2()");
        Assert.Equal("void E.<>E__0.M2()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());

        invocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2(new object())");
        Assert.Equal("void E.M2(this System.Object o)", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void This_03()
    {
        var src = """
static class E
{
    extension(object o)
    {
        public static void M()
        {
            M2();
        }
        public void M2() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (7,13): error CS7036: There is no argument given that corresponds to the required parameter 'o' of 'E.M2(object)'
            //             M2();
            Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "M2").WithArguments("o", "E.M2(object)").WithLocation(7, 13));
    }

    [Fact]
    public void This_04()
    {
        var src = """
static class E
{
    extension(object o)
    {
        public void M()
        {
            M2();
        }
        public static void M2() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var invocation = GetSyntax<InvocationExpressionSyntax>(tree, "M2()");
        Assert.Equal("void E.M2()", model.GetSymbolInfo(invocation).Symbol.ToTestDisplayString());
    }

    [Fact]
    public void ReceiverParameter_Access_01()
    {
        var src = """
static class E
{
    extension(object o)
    {
        public void M()
        {
            o.M2();
        }
        public void M2() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_Access_02()
    {
        var src = """
static class E
{
    extension(object o)
    {
        public void M()
        {
            o.M2();
        }
        public static void M2() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (7,13): error CS0176: Member 'E.extension(object).M2()' cannot be accessed with an instance reference; qualify it with a type name instead
            //             o.M2();
            Diagnostic(ErrorCode.ERR_ObjectProhibited, "o.M2").WithArguments("E.extension(object).M2()").WithLocation(7, 13));
    }

    [Fact]
    public void ReceiverParameter_Access_03()
    {
        var src = """
static class E
{
    extension(object o)
    {
        public static void M()
        {
            o.M2();
        }
        public void M2() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (7,13): error CS9293: Cannot use extension parameter 'object o' in this context.
            //             o.M2();
            Diagnostic(ErrorCode.ERR_InvalidExtensionParameterReference, "o").WithArguments("object o").WithLocation(7, 13));
    }

    [Fact]
    public void ReceiverParameter_Access_04()
    {
        var src = """
static class E
{
    extension(object o)
    {
        public void M()
        {
            local();
            void local()
            {
                o.M2();
            }
        }
        public void M2() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics();
    }

    [Fact]
    public void ReceiverParameter_Access_05()
    {
        var src = """
static class E
{
    extension(object o, object o2)
    {
        public void M()
        {
            o2.ToString();
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (3,25): error CS9285: An extension container can have only one receiver parameter
            //     extension(object o, object o2)
            Diagnostic(ErrorCode.ERR_ReceiverParameterOnlyOne, "object o2").WithLocation(3, 25),
            // (7,13): error CS0103: The name 'o2' does not exist in the current context
            //             o2.ToString();
            Diagnostic(ErrorCode.ERR_NameNotInContext, "o2").WithArguments("o2").WithLocation(7, 13));
    }

    [Fact]
    public void ReceiverParameter_Access_06()
    {
        var src = """
static class E
{
    extension(System.Span<int> s)
    {
        public async void M()
        {
            s.ToString();
            await System.Threading.Tasks.Task.Yield();
            s.ToString();
        }
    }
}
""";
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : we should produce this error instead:
        // error CS4012: Parameters of type 'Span<int>' cannot be declared in async methods or async lambda expressions.
        var comp = CreateCompilation(src, targetFramework: TargetFramework.Net90);
        comp.VerifyEmitDiagnostics(
            // (7,13): error CS4007: Instance of type 'System.Span<int>' cannot be preserved across 'await' or 'yield' boundary.
            //             s.ToString();
            Diagnostic(ErrorCode.ERR_ByRefTypeAndAwait, "s").WithArguments("System.Span<int>").WithLocation(7, 13),
            // (9,13): error CS4007: Instance of type 'System.Span<int>' cannot be preserved across 'await' or 'yield' boundary.
            //             s.ToString();
            Diagnostic(ErrorCode.ERR_ByRefTypeAndAwait, "s").WithArguments("System.Span<int>").WithLocation(9, 13));
    }

    [Fact]
    public void ReceiverParameter_TypeParametersMustBeUsed()
    {
        var src = """
int i = C.P;

class C { }

static class E
{
    extension<T, U>(C)
    {
        static int P => 0;
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,11): error CS0117: 'C' does not contain a definition for 'P'
            // int i = C.P;
            Diagnostic(ErrorCode.ERR_NoSuchMember, "P").WithArguments("C", "P").WithLocation(1, 11),
            // (7,21): error CS9295: The extended type 'C' must reference all the type parameters declared by the extension, but type parameter 'T' is not referenced.
            //     extension<T, U>(C)
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "C").WithArguments("C", "T").WithLocation(7, 21),
            // (7,21): error CS9295: The extended type 'C' must reference all the type parameters declared by the extension, but type parameter 'U' is not referenced.
            //     extension<T, U>(C)
            Diagnostic(ErrorCode.ERR_UnderspecifiedExtension, "C").WithArguments("C", "U").WithLocation(7, 21));
    }

    public partial class RegionAnalysisTests : FlowTestBase
    {
        // Tracked by https://github.com/dotnet/roslyn/issues/76130 : consider removing `this` from the region analysis tests
        [Fact]
        public void RegionAnalysis_01()
        {
            var analysisResults = CompileAndAnalyzeDataFlowExpression("""
static class E
{
    extension(int i)
    {
        public void M(int i2)
        {
            _ = /*<bind>*/i + i2/*</bind>*/;
        }
    }
}
""");
            VerifyDataFlowAnalysis("""
VariablesDeclared:
AlwaysAssigned:
Captured:
CapturedInside:
CapturedOutside:
DataFlowsIn: i, i2
DataFlowsOut:
DefinitelyAssignedOnEntry: i, this, i2
DefinitelyAssignedOnExit: i, this, i2
ReadInside: i, i2
ReadOutside:
WrittenInside:
WrittenOutside: i, this, i2
""", analysisResults);
        }

        [Fact]
        public void RegionAnalysis_02()
        {
            var analysisResults = CompileAndAnalyzeDataFlowExpression("""
static class E
{
    extension(int i)
    {
        public void M(int i2)
        {
            /*<bind>*/this.ToString()/*</bind>*/;
        }
    }
}
""");
            VerifyDataFlowAnalysis("""
VariablesDeclared:
AlwaysAssigned:
Captured:
CapturedInside:
CapturedOutside:
DataFlowsIn: this
DataFlowsOut:
DefinitelyAssignedOnEntry: i, this, i2
DefinitelyAssignedOnExit: i, this, i2
ReadInside: this
ReadOutside:
WrittenInside:
WrittenOutside: i, this, i2
""", analysisResults);
        }

        [Fact]
        public void RegionAnalysis_03()
        {
            var analysisResults = CompileAndAnalyzeDataFlowExpression("""
static class E
{
    extension(int i)
    {
        public void M(int i2)
        {
            int i3 = 0;
/*<bind>*/
            System.Action<int> = () => i + i2 + i3;
/*</bind>*/
        }
    }
}
""");
            VerifyDataFlowAnalysis("""
VariablesDeclared:
AlwaysAssigned:
Captured: i, i2, i3
CapturedInside: i, i2, i3
CapturedOutside:
DataFlowsIn: i, i2, i3
DataFlowsOut:
DefinitelyAssignedOnEntry: i, this, i2, i3
DefinitelyAssignedOnExit: i, this, i2, i3
ReadInside: i, i2, i3
ReadOutside:
WrittenInside:
WrittenOutside: i, this, i2, i3
""", analysisResults);
        }

        [Fact]
        public void RegionAnalysis_04()
        {
            var analysisResults = CompileAndAnalyzeDataFlowExpression("""
static class E
{
    extension(ref int i)
    {
        public void M(ref int i2)
        {
            _ = /*<bind>*/i + i2/*</bind>*/;
        }
    }
}
""");
            VerifyDataFlowAnalysis("""
VariablesDeclared:
AlwaysAssigned:
Captured:
CapturedInside:
CapturedOutside:
DataFlowsIn: i, i2
DataFlowsOut:
DefinitelyAssignedOnEntry: i, this, i2
DefinitelyAssignedOnExit: i, this, i2
ReadInside: i, i2
ReadOutside: i, i2
WrittenInside:
WrittenOutside: i, this, i2
""", analysisResults);
        }

        [Fact]
        public void RegionAnalysis_05()
        {
            var analysisResults = CompileAndAnalyzeDataFlowExpression("""
static class E
{
    extension(out int i)
    {
        public void M(out int i2)
        {
            /*<bind>*/i = i2 = 0;/*</bind>*/
        }
    }
}
""");
            VerifyDataFlowAnalysis("""
VariablesDeclared:
AlwaysAssigned: i, i2
Captured:
CapturedInside:
CapturedOutside:
DataFlowsIn:
DataFlowsOut: i, i2
DefinitelyAssignedOnEntry: this
DefinitelyAssignedOnExit: i, this, i2
ReadInside:
ReadOutside: i, i2
WrittenInside: i, i2
WrittenOutside: this
""", analysisResults);
        }

        [Fact]
        public void RegionAnalysis_06()
        {
            var analysisResults = CompileAndAnalyzeDataFlowExpression("""
static class E
{
    extension(int i)
    {
        public void M(int i2)
        {
            /*<bind>*/i = i2 = 0;/*</bind>*/
        }
    }
}
""");
            VerifyDataFlowAnalysis("""
VariablesDeclared:
AlwaysAssigned: i, i2
Captured:
CapturedInside:
CapturedOutside:
DataFlowsIn:
DataFlowsOut:
DefinitelyAssignedOnEntry: i, this, i2
DefinitelyAssignedOnExit: i, this, i2
ReadInside:
ReadOutside:
WrittenInside: i, i2
WrittenOutside: i, this, i2
""", analysisResults);
        }

        [Fact]
        public void RegionAnalysis_07()
        {
            var analysisResults = CompileAndAnalyzeDataFlowExpression("""
static class E
{
    extension(ref int i)
    {
        public void M(ref int i2)
        {
            /*<bind>*/i = ref i2;/*</bind>*/
        }
    }
}
""");
            VerifyDataFlowAnalysis("""
VariablesDeclared:
AlwaysAssigned: i
Captured:
CapturedInside:
CapturedOutside:
DataFlowsIn: i2
DataFlowsOut: i, i2
DefinitelyAssignedOnEntry: i, this, i2
DefinitelyAssignedOnExit: i, this, i2
ReadInside: i2
ReadOutside: i, i2
WrittenInside: i, i2
WrittenOutside: i, this, i2
""", analysisResults);
        }

        [Fact]
        public void RegionAnalysis_08()
        {
            var analysisResults = CompileAndAnalyzeDataFlowExpression("""
static class E
{
    extension(int i)
    {
        public void M(int i2)
        {
            void local(int i3)
            {
                _ = /*<bind>*/i + i2 + i3/*</bind>*/;
            }
        }
    }
}
""");
            VerifyDataFlowAnalysis("""
VariablesDeclared:
AlwaysAssigned:
Captured: i, i2
CapturedInside: i, i2
CapturedOutside:
DataFlowsIn: i3
DataFlowsOut:
DefinitelyAssignedOnEntry: i, this, i2, i3
DefinitelyAssignedOnExit: i, this, i2, i3
ReadInside: i, i2, i3
ReadOutside:
WrittenInside:
WrittenOutside: i, this, i2, i3
""", analysisResults);
        }

        [Fact]
        public void RegionAnalysis_09()
        {
            var analysisResults = CompileAndAnalyzeDataFlowExpression("""
static class E
{
    extension(out int i)
    {
        public void M(out int i2)
        {
            void local(out int i3)
            {
                /*<bind>*/i = i2 = i3 = 0;/*</bind>*/
            }
        }
    }
}
""");
            VerifyDataFlowAnalysis("""
VariablesDeclared:
AlwaysAssigned: i, i2, i3
Captured: i, i2
CapturedInside: i, i2
CapturedOutside:
DataFlowsIn:
DataFlowsOut: i, i2, i3
DefinitelyAssignedOnEntry: this
DefinitelyAssignedOnExit: i, this, i2, i3
ReadInside:
ReadOutside: i, i2, i3
WrittenInside: i, i2, i3
WrittenOutside: this
""", analysisResults);
        }
    }

    [Fact]
    public void Base_01()
    {
        var src = """
static class E
{
    extension(object)
    {
        public void M()
        {
            base.ToString();
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (7,13): error CS1512: Keyword 'base' is not available in the current context
            //             base.ToString();
            Diagnostic(ErrorCode.ERR_BaseInBadContext, "base").WithLocation(7, 13));
    }

    [Fact]
    public void FunctionType_TypeReceiver_01()
    {
        var src = """
var x = int.M;
x();

public static class E
{
    extension<T>(T t)
    {
        public static void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var localDeclaration = GetSyntax<VariableDeclarationSyntax>(tree, "var x = int.M");
        Assert.Equal("System.Action", model.GetTypeInfo(localDeclaration.Type).Type.ToTestDisplayString());
    }

    [Fact]
    public void FunctionType_TypeReceiver_02()
    {
        var src = """
var x = int.M;

public static class E
{
    extension<T>(T t)
    {
        public void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS8917: The delegate type could not be inferred.
            // var x = int.M;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "int.M").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var localDeclaration = GetSyntax<VariableDeclarationSyntax>(tree, "var x = int.M");
        Assert.True(model.GetTypeInfo(localDeclaration.Type).Type.IsErrorType());
    }

    [Fact]
    public void FunctionType_TypeReceiver_03()
    {
        var src = """
var x = int.M;

public static class E
{
    public static void M<T>(this T t) { }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS8917: The delegate type could not be inferred.
            // var x = int.M;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "int.M").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var localDeclaration = GetSyntax<VariableDeclarationSyntax>(tree, "var x = int.M");
        Assert.True(model.GetTypeInfo(localDeclaration.Type).Type.IsErrorType());
    }

    [Fact]
    public void FunctionType_InstanceReceiver_01()
    {
        var src = """
var x = 42.M;

public static class E
{
    extension<T>(T t)
    {
        public void M() { System.Console.Write(t); }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS1113: Extension method 'E.extension<int>(int).M()' defined on value type 'int' cannot be used to create delegates
            // var x = 42.M;
            Diagnostic(ErrorCode.ERR_ValueTypeExtDelegate, "42.M").WithArguments("E.extension<int>(int).M()", "int").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var localDeclaration = GetSyntax<VariableDeclarationSyntax>(tree, "var x = 42.M");
        Assert.Equal("System.Action", model.GetTypeInfo(localDeclaration.Type).Type.ToTestDisplayString());
    }

    [Fact]
    public void FunctionType_InstanceReceiver_02()
    {
        var src = """
var x = "ran".M;
x();

public static class E
{
    extension<T>(T t)
    {
        public void M() { System.Console.Write(t); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var localDeclaration = GetSyntax<VariableDeclarationSyntax>(tree, """var x = "ran".M""");
        Assert.Equal("System.Action", model.GetTypeInfo(localDeclaration.Type).Type.ToTestDisplayString());
    }

    [Fact]
    public void FunctionType_InstanceReceiver_03()
    {
        var src = """
var x = 42.M;

public static class E
{
    extension<T>(T t)
    {
        public static void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS8917: The delegate type could not be inferred.
            // var x = 42.M;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "42.M").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var localDeclaration = GetSyntax<VariableDeclarationSyntax>(tree, "var x = 42.M");
        Assert.True(model.GetTypeInfo(localDeclaration.Type).Type.IsErrorType());
    }

    [Fact]
    public void FunctionType_InstanceReceiver_04()
    {
        var src = """
var x = 42.M;

public static class E
{
    extension(int)
    {
        public void M<T>() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS8917: The delegate type could not be inferred.
            // var x = 42.M;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, "42.M").WithLocation(1, 9));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var localDeclaration = GetSyntax<VariableDeclarationSyntax>(tree, "var x = 42.M");
        Assert.True(model.GetTypeInfo(localDeclaration.Type).Type.IsErrorType());
    }

    [Fact]
    public void FunctionType_InstanceReceiver_05()
    {
        var src = """
var x = "ran".M<object>;
x();

public static class E
{
    extension(string s)
    {
        public void M<T>() { System.Console.Write(s); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var localDeclaration = GetSyntax<VariableDeclarationSyntax>(tree, """var x = "ran".M<object>""");
        Assert.Equal("System.Action", model.GetTypeInfo(localDeclaration.Type).Type.ToTestDisplayString());
    }

    [Fact]
    public void FunctionType_InstanceReceiver_06()
    {
        var src = """
var x = "ran".M;
x();

public static class E
{
    extension(string s)
    {
        public void M() { System.Console.Write(s); }
        public void M<T>(T t) { }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var localDeclaration = GetSyntax<VariableDeclarationSyntax>(tree, """var x = "ran".M""");
        Assert.Equal("System.Action", model.GetTypeInfo(localDeclaration.Type).Type.ToTestDisplayString());
    }

    [Fact]
    public void FunctionType_InstanceReceiver_07()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            var x = "".M;
            System.Console.Write(x);
        }
    }

    public static class E1
    {
        extension(string s)
        {
            public void M<T>() { }
        }
    }
}

public static class E2
{
    extension(string s)
    {
        public int M => 42;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyEmitDiagnostics(
            // (7,21): error CS8917: The delegate type could not be inferred.
            //             var x = "".M;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, @""""".M").WithLocation(7, 21));

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var localDeclaration = GetSyntax<VariableDeclarationSyntax>(tree, """var x = "".M""");
        Assert.True(model.GetTypeInfo(localDeclaration.Type).Type.IsErrorType());
    }

    [Fact]
    public void FunctionType_InstanceReceiver_08()
    {
        var src = """
namespace N
{
    public class C
    {
        public static void Main()
        {
            var x = "ran".M;
            x(42);
        }
    }

    public static class E1
    {
        extension(string s)
        {
            public void M<T>() { }
        }
    }
}

public static class E2
{
    extension(string s)
    {
        public void M(int i) { System.Console.Write((s, i)); }
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: "(ran, 42)").VerifyDiagnostics();

        var tree = comp.SyntaxTrees.First();
        var model = comp.GetSemanticModel(tree);
        var localDeclaration = GetSyntax<VariableDeclarationSyntax>(tree, """var x = "ran".M""");
        Assert.Equal("System.Action<System.Int32>", model.GetTypeInfo(localDeclaration.Type).Type.ToTestDisplayString());
    }

    [Fact]
    public void FunctionType_InstanceReceiver_09()
    {
        var src = """
var x = "ran".M;

public static class E1
{
    extension(string s)
    {
        public void M() { }
    }
}

public static class E2
{
    extension(string s)
    {
        public void M(int i) { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (1,9): error CS8917: The delegate type could not be inferred.
            // var x = "ran".M;
            Diagnostic(ErrorCode.ERR_CannotInferDelegateType, @"""ran"".M").WithLocation(1, 9));
    }

    [Fact]
    public void FunctionType_InstanceReceiver_10()
    {
        var src = """
System.Delegate x = "ran".M;
x.DynamicInvoke();

id("ran".M)();

T id<T>(T t) => t;

public static class E
{
    extension(string s)
    {
        public void M() { System.Console.Write("ran "); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran ran").VerifyDiagnostics();
    }

    [Fact]
    public void FunctionType_InstanceReceiver_11()
    {
        var src = """
using N;

var x = "ran".M;

public static class E1
{
    extension<T>(T t) where T : struct
    {
        public void M<U>() { }
    }
}

namespace N
{
    public static class E2
    {
        extension<T>(T t)
        {
            public void M() { }
        }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyDiagnostics();
    }

    [Fact]
    public void FunctionType_ColorColorReceiver_01()
    {
        var src = """
Color.M2(new Color());

public class Color
{
    public static void M2(Color Color)
    {
        var x = Color.M;
        x();
    }
}

public static class E
{
    extension<T>(T t)
    {
        public void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();
    }

    [Fact]
    public void FunctionType_ColorColorReceiver_02()
    {
        var src = """
Color.M2(null);

public class Color
{
    public static void M2(Color Color)
    {
        var x = Color.M;
        x();
    }
}

public static class E
{
    extension<T>(T)
    {
        public static void M() { System.Console.Write("ran"); }
    }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();
    }

    [Fact]
    public void FunctionType_ColorColorReceiver_03()
    {
        var src = """
Color.M2(new Color());

public class Color
{
    public static void M2(Color Color)
    {
        var x = Color.M;
        x();
    }
    public void M() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();
    }

    [Fact]
    public void FunctionType_ColorColorReceiver_04()
    {
        var src = """
Color.M2(null);

public class Color
{
    public static void M2(Color Color)
    {
        var x = Color.M;
        x();
    }
    public static void M() { System.Console.Write("ran"); }
}
""";
        var comp = CreateCompilation(src);
        CompileAndVerify(comp, expectedOutput: "ran").VerifyDiagnostics();
    }

    [Fact]
    public void FunctionType_ColorColorReceiver_05()
    {
        var src = """
public class Color
{
    public static void M2(Color Color)
    {
        var x = Color.M;
    }
}

public static class E1
{
    extension<T>(T)
    {
        public static void M() { }
    }
}

public static class E2
{
    extension<T>(T)
    {
        public void M() { }
    }
}
""";
        var comp = CreateCompilation(src);
        comp.VerifyEmitDiagnostics(
            // (5,17): error CS0121: The call is ambiguous between the following methods or properties: 'E1.extension<T>(T).M()' and 'E2.extension<T>(T).M()'
            //         var x = Color.M;
            Diagnostic(ErrorCode.ERR_AmbigCall, "Color.M").WithArguments("E1.extension<T>(T).M()", "E2.extension<T>(T).M()").WithLocation(5, 17));
    }

    [Fact]
    public void Params_ExtensionScopes_01()
    {
        var source = """
static class E1
{
    extension(N.C c)
    {
        public void M(int[] x) => System.Console.Write(3);
    }
}

namespace N
{
    static class E2
    {
        extension(C c)
        {
            public void M(params int[] x) => System.Console.Write(2);
        }
    }

    class C
    {
        public void M(params int[] x) => System.Console.Write(1);
        public static void Main()
        {
            var d = new C().M;
            System.Console.WriteLine(d.GetType());
            d();
        }
    }
}
""";

        var expectedOutput = """
<>f__AnonymousDelegate0`1[System.Int32]
1
""";

        CompileAndVerify(source, symbolValidator: validateSymbols, expectedOutput: expectedOutput).VerifyDiagnostics();

        static void validateSymbols(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<MethodSymbol>("<>f__AnonymousDelegate0.Invoke");
            Assert.Equal("void <>f__AnonymousDelegate0<T1>.Invoke(params T1[] arg)", m.ToTestDisplayString());
        }
    }

    [Fact]
    public void Params_ExtensionScopes_02()
    {
        var source = """
static class E1
{
    extension(N.C c)
    {
        public void M(params int[] x) => System.Console.Write(3);
    }
}

namespace N
{
    static class E2
    {
        extension(C c)
        {
            public void M(params int[] x) => System.Console.Write(2);
        }
    }

    class C
    {
        public void M(params int[] x) => System.Console.Write(1);
        public static void Main()
        {
            var d = new C().M;
            System.Console.WriteLine(d.GetType());
            d();
        }
    }
}
""";

        var expectedOutput = """
<>f__AnonymousDelegate0`1[System.Int32]
1
""";

        CompileAndVerify(source, symbolValidator: validateSymbols, expectedOutput: expectedOutput).VerifyDiagnostics();

        static void validateSymbols(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<MethodSymbol>("<>f__AnonymousDelegate0.Invoke");
            Assert.Equal("void <>f__AnonymousDelegate0<T1>.Invoke(params T1[] arg)", m.ToTestDisplayString());
        }
    }
    [Fact]
    public void Params_ExtensionScopes_07()
    {
        var source = """
static class E1
{
    extension(N.C c)
    {
        public void M(params int[] x) => System.Console.Write(1);
    }
}

namespace N
{
    static class E2
    {
        extension(C)
        {
            public void M(int[] x) => System.Console.Write(2);
        }
    }

    class C
    {
        public static void Main()
        {
            var d = new C().M;
            System.Console.WriteLine(d.GetType());
            d(default);
        }
    }
}
""";

        var expectedOutput = """
System.Action`1[System.Int32[]]
2
""";

        CompileAndVerify(source, expectedOutput: expectedOutput).VerifyDiagnostics();
    }

    [Fact]
    public void Params_ExtensionScopes_08()
    {
        var source = """
static class E1
{
    extension(N.C c)
    {
        public void M(int[] x) => System.Console.Write(1);
    }
}

namespace N
{
    static class E2
    {
        extension(C c)
        {
            public void M(params int[] x) => System.Console.Write(2);
        }
    }

    class C
    {
        public static void Main()
        {
            var d = new C().M;
            System.Console.WriteLine(d.GetType());
            d();
        }
    }
}
""";

        var expectedOutput = """
<>f__AnonymousDelegate0`1[System.Int32]
2
""";

        CreateCompilation(source).VerifyDiagnostics();
        CompileAndVerify(source, symbolValidator: validateSymbols, expectedOutput: expectedOutput).VerifyDiagnostics();

        static void validateSymbols(ModuleSymbol module)
        {
            var m = module.GlobalNamespace.GetMember<MethodSymbol>("<>f__AnonymousDelegate0.Invoke");
            Assert.Equal("void <>f__AnonymousDelegate0<T1>.Invoke(params T1[] arg)", m.ToTestDisplayString());
        }
    }

    [Fact]
    public void ImplementsIEnumerableT_21_AddIsNotAnExtension()
    {
        var src = """
using System.Collections;
using System.Collections.Generic;

class MyCollection : IEnumerable<long>
{
    IEnumerator<long> IEnumerable<long>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}

static class Ext
{
    extension(MyCollection c)
    {
        public void Add(long l) {}
    }
}

class Program
{
    static void Main()
    {
        Test();
        Test(1);
        Test(2, 3);
    }
#line 24
    static void Test(params MyCollection a)
    {
    }

    static void Test2()
    {
        Test([2, 3]);
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.ReleaseExe);

        comp.VerifyDiagnostics(
            // (24,22): error CS9227: 'MyCollection' does not contain a definition for a suitable instance 'Add' method
            //     static void Test(params MyCollection a)
            Diagnostic(ErrorCode.ERR_ParamsCollectionExtensionAddMethod, "params MyCollection a").WithArguments("MyCollection").WithLocation(24, 22)
            );
    }

    [Fact]
    public void TestGetEnumeratorPatternViaExtensionWithOptionalParameter()
    {
        var source = @"
using System;
public class C
{
    public static void Main()
    /*<bind>*/
    {
        foreach (var i in new C())
        {
            Console.Write(i);
        }
    }
    /*</bind>*/

    public sealed class Enumerator
    {
        public Enumerator(int start) => Current = start;
        public int Current { get; private set; }
        public bool MoveNext() => Current++ != 3;
    }
}
public static class Extensions
{
    extension(C self)
    {
        public C.Enumerator GetEnumerator(int x = 1) => new C.Enumerator(x);
    }
}";
        var verifier = CompileAndVerify(source, expectedOutput: "23");

        VerifyFlowGraphAndDiagnosticsForTest<BlockSyntax>((CSharpCompilation)verifier.Compilation,
@"
Block[B0] - Entry
    Statements (0)
    Next (Regular) Block[B1]
        Entering: {R1}
.locals {R1}
{
    CaptureIds: [0]
    Block[B1] - Block
        Predecessors: [B0]
        Statements (1)
            IFlowCaptureOperation: 0 (OperationKind.FlowCapture, Type: null, IsImplicit) (Syntax: 'new C()')
              Value:
                IInvocationOperation ( C.Enumerator Extensions.<>E__0.GetEnumerator([System.Int32 x = 1])) (OperationKind.Invocation, Type: C.Enumerator, IsImplicit) (Syntax: 'new C()')
                  Instance Receiver:
                    IConversionOperation (TryCast: False, Unchecked) (OperationKind.Conversion, Type: C, IsImplicit) (Syntax: 'new C()')
                      Conversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
                        (Identity)
                      Operand:
                        IObjectCreationOperation (Constructor: C..ctor()) (OperationKind.ObjectCreation, Type: C) (Syntax: 'new C()')
                          Arguments(0)
                          Initializer:
                            null
                  Arguments(1):
                      IArgumentOperation (ArgumentKind.DefaultValue, Matching Parameter: x) (OperationKind.Argument, Type: null, IsImplicit) (Syntax: 'new C()')
                        ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 1, IsImplicit) (Syntax: 'new C()')
                        InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
                        OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
        Next (Regular) Block[B2]
    Block[B2] - Block
        Predecessors: [B1] [B3]
        Statements (0)
        Jump if False (Regular) to Block[B4]
            IInvocationOperation ( System.Boolean C.Enumerator.MoveNext()) (OperationKind.Invocation, Type: System.Boolean, IsImplicit) (Syntax: 'new C()')
              Instance Receiver:
                IFlowCaptureReferenceOperation: 0 (OperationKind.FlowCaptureReference, Type: C.Enumerator, IsImplicit) (Syntax: 'new C()')
              Arguments(0)
            Leaving: {R1}
        Next (Regular) Block[B3]
            Entering: {R2}
    .locals {R2}
    {
        Locals: [System.Int32 i]
        Block[B3] - Block
            Predecessors: [B2]
            Statements (2)
                ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: null, IsImplicit) (Syntax: 'var')
                  Left:
                    ILocalReferenceOperation: i (IsDeclaration: True) (OperationKind.LocalReference, Type: System.Int32, IsImplicit) (Syntax: 'var')
                  Right:
                    IPropertyReferenceOperation: System.Int32 C.Enumerator.Current { get; private set; } (OperationKind.PropertyReference, Type: System.Int32, IsImplicit) (Syntax: 'var')
                      Instance Receiver:
                        IFlowCaptureReferenceOperation: 0 (OperationKind.FlowCaptureReference, Type: C.Enumerator, IsImplicit) (Syntax: 'new C()')
                IExpressionStatementOperation (OperationKind.ExpressionStatement, Type: null) (Syntax: 'Console.Write(i);')
                  Expression:
                    IInvocationOperation (void System.Console.Write(System.Int32 value)) (OperationKind.Invocation, Type: System.Void) (Syntax: 'Console.Write(i)')
                      Instance Receiver:
                        null
                      Arguments(1):
                          IArgumentOperation (ArgumentKind.Explicit, Matching Parameter: value) (OperationKind.Argument, Type: null) (Syntax: 'i')
                            ILocalReferenceOperation: i (OperationKind.LocalReference, Type: System.Int32) (Syntax: 'i')
                            InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
                            OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
            Next (Regular) Block[B2]
                Leaving: {R2}
    }
}
Block[B4] - Exit
    Predecessors: [B2]
    Statements (0)
", []);
    }

    [Fact]
    public void TestGetEnumeratorPatternViaExtensionWithOptionalParameter_02()
    {
        var source = @"
using System;
public struct C
{
    public static void Main()
    /*<bind>*/
    {
        foreach (var i in new C())
        {
            Console.Write(i);
        }
    }
    /*</bind>*/

    public sealed class Enumerator
    {
        public Enumerator(int start) => Current = start;
        public int Current { get; private set; }
        public bool MoveNext() => Current++ != 3;
    }
}
public static class Extensions
{
    extension(object self)
    {
        public C.Enumerator GetEnumerator(int x = 1) => new C.Enumerator(x);
    }
}";
        var verifier = CompileAndVerify(source, expectedOutput: "23", parseOptions: TestOptions.RegularPreview.WithFeature("run-nullable-analysis", "never")); // Tracked by https://github.com/dotnet/roslyn/issues/76130: Nullable analysis asserts 

        VerifyFlowGraphAndDiagnosticsForTest<BlockSyntax>((CSharpCompilation)verifier.Compilation,
@"
Block[B0] - Entry
    Statements (0)
    Next (Regular) Block[B1]
        Entering: {R1}
.locals {R1}
{
    CaptureIds: [0]
    Block[B1] - Block
        Predecessors: [B0]
        Statements (1)
            IFlowCaptureOperation: 0 (OperationKind.FlowCapture, Type: null, IsImplicit) (Syntax: 'new C()')
              Value:
                IInvocationOperation ( C.Enumerator Extensions.<>E__0.GetEnumerator([System.Int32 x = 1])) (OperationKind.Invocation, Type: C.Enumerator, IsImplicit) (Syntax: 'new C()')
                  Instance Receiver:
                    IConversionOperation (TryCast: False, Unchecked) (OperationKind.Conversion, Type: System.Object, IsImplicit) (Syntax: 'new C()')
                      Conversion: CommonConversion (Exists: True, IsIdentity: False, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
                        (Boxing)
                      Operand:
                        IObjectCreationOperation (Constructor: C..ctor()) (OperationKind.ObjectCreation, Type: C) (Syntax: 'new C()')
                          Arguments(0)
                          Initializer:
                            null
                  Arguments(1):
                      IArgumentOperation (ArgumentKind.DefaultValue, Matching Parameter: x) (OperationKind.Argument, Type: null, IsImplicit) (Syntax: 'new C()')
                        ILiteralOperation (OperationKind.Literal, Type: System.Int32, Constant: 1, IsImplicit) (Syntax: 'new C()')
                        InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
                        OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
        Next (Regular) Block[B2]
    Block[B2] - Block
        Predecessors: [B1] [B3]
        Statements (0)
        Jump if False (Regular) to Block[B4]
            IInvocationOperation ( System.Boolean C.Enumerator.MoveNext()) (OperationKind.Invocation, Type: System.Boolean, IsImplicit) (Syntax: 'new C()')
              Instance Receiver:
                IFlowCaptureReferenceOperation: 0 (OperationKind.FlowCaptureReference, Type: C.Enumerator, IsImplicit) (Syntax: 'new C()')
              Arguments(0)
            Leaving: {R1}
        Next (Regular) Block[B3]
            Entering: {R2}
    .locals {R2}
    {
        Locals: [System.Int32 i]
        Block[B3] - Block
            Predecessors: [B2]
            Statements (2)
                ISimpleAssignmentOperation (OperationKind.SimpleAssignment, Type: null, IsImplicit) (Syntax: 'var')
                  Left:
                    ILocalReferenceOperation: i (IsDeclaration: True) (OperationKind.LocalReference, Type: System.Int32, IsImplicit) (Syntax: 'var')
                  Right:
                    IPropertyReferenceOperation: System.Int32 C.Enumerator.Current { get; private set; } (OperationKind.PropertyReference, Type: System.Int32, IsImplicit) (Syntax: 'var')
                      Instance Receiver:
                        IFlowCaptureReferenceOperation: 0 (OperationKind.FlowCaptureReference, Type: C.Enumerator, IsImplicit) (Syntax: 'new C()')
                IExpressionStatementOperation (OperationKind.ExpressionStatement, Type: null) (Syntax: 'Console.Write(i);')
                  Expression:
                    IInvocationOperation (void System.Console.Write(System.Int32 value)) (OperationKind.Invocation, Type: System.Void) (Syntax: 'Console.Write(i)')
                      Instance Receiver:
                        null
                      Arguments(1):
                          IArgumentOperation (ArgumentKind.Explicit, Matching Parameter: value) (OperationKind.Argument, Type: null) (Syntax: 'i')
                            ILocalReferenceOperation: i (OperationKind.LocalReference, Type: System.Int32) (Syntax: 'i')
                            InConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
                            OutConversion: CommonConversion (Exists: True, IsIdentity: True, IsNumeric: False, IsReference: False, IsUserDefined: False) (MethodSymbol: null)
            Next (Regular) Block[B2]
                Leaving: {R2}
    }
}
Block[B4] - Exit
    Predecessors: [B2]
    Statements (0)
", []);
    }

    [Fact]
    public void TestMoveNextPatternViaExtensions_OnInstanceGetEnumerator()
    {
        var source = @"
using System;
public class C
{
    public static void Main()
    {
        foreach (var i in new C())
        {
            Console.Write(i);
        }
    }
    public sealed class Enumerator
    {
        public int Current { get; private set; }
    }

    public C.Enumerator GetEnumerator() => new C.Enumerator();
}
public static class Extensions
{
    extension(C.Enumerator e)
    {
        public bool MoveNext() => false;
    }
}";
        CreateCompilation(source)
            .VerifyDiagnostics(
                // (7,27): error CS0117: 'C.Enumerator' does not contain a definition for 'MoveNext'
                //         foreach (var i in new C())
                Diagnostic(ErrorCode.ERR_NoSuchMember, "new C()").WithArguments("C.Enumerator", "MoveNext").WithLocation(7, 27),
                // (7,27): error CS0202: foreach requires that the return type 'C.Enumerator' of 'C.GetEnumerator()' must have a suitable public 'MoveNext' method and public 'Current' property
                //         foreach (var i in new C())
                Diagnostic(ErrorCode.ERR_BadGetEnumerator, "new C()").WithArguments("C.Enumerator", "C.GetEnumerator()").WithLocation(7, 27)
                );
    }

    [Fact]
    public void TestGetEnumeratorPatternViaRefExtensionOnNonAssignableVariable()
    {
        var source = @"
using System;
public struct C
{
    public static void Main()
    {
        foreach (var i in new C())
        {
            Console.Write(i);
        }
    }
    public struct Enumerator
    {
        public int Current { get; private set; }
        public bool MoveNext() => Current++ != 3;
    }
}
public static class Extensions
{
    extension(ref C self)
    {
        public C.Enumerator GetEnumerator() => new C.Enumerator();
    }
}";
        CreateCompilation(source)
                .VerifyDiagnostics(
                // (7,27): error CS1510: A ref or out value must be an assignable variable
                //         foreach (var i in new C())
                Diagnostic(ErrorCode.ERR_RefLvalueExpected, "new C()").WithLocation(7, 27));
    }

    [Fact]
    public void ExpressionTrees_01_InstanceMethod()
    {
        var src = """
using System;
using System.Linq.Expressions;

public static class Extensions
{
    extension(object o)
    {
        public string M(string s) => o + s;
    }
}

class Program
{
    static void Main()
    {
        var e = Test();
        System.Console.Write(e.Compile().Invoke("1", "2"));
        System.Console.Write(": ");
        System.Console.Write(e);
    }

    static Expression<Func<object, string, string>> Test()
    {
        return (o, s) => o.M(s);
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: @"12: (o, s) => o.M(s)").VerifyDiagnostics();
    }

    [Fact]
    public void ExpressionTrees_02_StaticMethod()
    {
        var src = """
using System;
using System.Linq.Expressions;

public static class Extensions
{
    extension(object o)
    {
        public static string M(string s) => s;
    }
}

class Program
{
    static void Main()
    {
        var e = Test();
        System.Console.Write(e.Compile().Invoke("1"));
        System.Console.Write(": ");
        System.Console.Write(e);
    }

    static Expression<Func<string, string>> Test()
    {
        return (s) => object.M(s);
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: @"1: s => M(s)").VerifyDiagnostics();
    }

    [Fact]
    public void ExpressionTrees_03_InstanceIndexer()
    {
        var src = """
using System;
using System.Linq.Expressions;

public static class Extensions
{
    extension(object o)
    {
        public string this[string s] => o + s;
    }
}

class Program
{
    static void Main()
    {
        var e = Test();
        System.Console.Write(e.Compile().Invoke("1", "2"));
        System.Console.Write(": ");
        System.Console.Write(e);
    }

    static Expression<Func<object, string, string>> Test()
    {
        return (o, s) => o[s];
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (24,26): error CS0021: Cannot apply indexing with [] to an expression of type 'object'
            //         return (o, s) => o[s];
            Diagnostic(ErrorCode.ERR_BadIndexLHS, "o[s]").WithArguments("object").WithLocation(24, 26)
            );
    }

    [Fact]
    public void ExpressionTrees_04_InstanceProperty()
    {
        var src = """
using System;
using System.Linq.Expressions;

public static class Extensions
{
    extension(object o)
    {
        public string P => (string)o;
    }
}

class Program
{
    static void Main()
    {
        var e = Test();
        System.Console.Write(e.Compile().Invoke("1"));
        System.Console.Write(": ");
        System.Console.Write(e);
    }

    static Expression<Func<object, string>> Test()
    {
        return (o) => o.P;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (24,23): error CS9296: An expression tree may not contain an extension property access
            //         return (o) => o.P;
            Diagnostic(ErrorCode.ERR_ExpressionTreeContainsExtensionPropertyAccess, "o.P").WithLocation(24, 23)
            );
    }

    [Fact]
    public void ExpressionTrees_05_InstanceProperty()
    {
        var src = """
using System;
using System.Linq.Expressions;

public static class Extensions
{
    extension(object o)
    {
        public string P { get => (string)o; set {}}
    }
}

class Program
{
    static void Main()
    {
        var e = Test();
        System.Console.Write(e.Compile().Invoke("1"));
        System.Console.Write(": ");
        System.Console.Write(e);
    }

    static Expression<Func<string, object>> Test()
    {
        return (s) => new object() { P = s };
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (24,38): error CS9296: An expression tree may not contain an extension property access
            //         return (s) => new object() { P = s };
            Diagnostic(ErrorCode.ERR_ExpressionTreeContainsExtensionPropertyAccess, "P").WithLocation(24, 38)
            );
    }

    [Fact]
    public void ExpressionTrees_06_InstanceProperty()
    {
        var src = """
using System;
using System.Linq.Expressions;

public static class Extensions
{
    extension(object o)
    {
        public C P { get => default; }
    }
}

public class C
{
    public string F;
}

class Program
{
    static void Main()
    {
        var e = Test();
        System.Console.Write(e.Compile().Invoke("1"));
        System.Console.Write(": ");
        System.Console.Write(e);
    }

    static Expression<Func<string, object>> Test()
    {
        return (s) => new object() { P = { F = s } };
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (29,38): error CS9296: An expression tree may not contain an extension property access
            //         return (s) => new object() { P = { F = s } };
            Diagnostic(ErrorCode.ERR_ExpressionTreeContainsExtensionPropertyAccess, "P").WithLocation(29, 38)
            );
    }

    [Fact]
    public void ExpressionTrees_07_InstanceProperty()
    {
        var src = """
using System;
using System.Linq.Expressions;

public static class Extensions
{
    extension(object o)
    {
        public string P { get => default; }
    }
}

class Program
{
    static void Main()
    {
    }

    static Expression<Func<object, bool>> Test()
    {
        return (o) => o is object { P: "s" };
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (20,23): error CS8122: An expression tree may not contain an 'is' pattern-matching operator.
            //         return (o) => o is object { P: "s" };
            Diagnostic(ErrorCode.ERR_ExpressionTreeContainsIsMatch, @"o is object { P: ""s"" }").WithLocation(20, 23)
            );
    }

    [Fact]
    public void ExpressionTrees_08_StaticProperty()
    {
        var src = """
using System;
using System.Linq.Expressions;

public static class Extensions
{
    extension(object o)
    {
        public static string P => "o";
    }
}

class Program
{
    static void Main()
    {
        var e = Test();
        System.Console.Write(e.Compile().Invoke());
        System.Console.Write(": ");
        System.Console.Write(e);
    }

    static Expression<Func<string>> Test()
    {
        return () => object.P;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        comp.VerifyDiagnostics(
            // (24,22): error CS9296: An expression tree may not contain an extension property access
            //         return () => object.P;
            Diagnostic(ErrorCode.ERR_ExpressionTreeContainsExtensionPropertyAccess, "object.P").WithLocation(24, 22)
            );
    }

    [Fact]
    public void ExpressionTrees_09_DelegateCreation_InstanceMethod()
    {
        var src = """
using System;
using System.Linq.Expressions;

public static class Extensions
{
    extension(object o)
    {
        public string M(string s) => o + s;
    }
}

class Program
{
    static void Main()
    {
        var e = Test();
        System.Console.Write(e.Compile().Invoke("1").Invoke("2"));
        System.Console.Write(": ");
        System.Console.Write(e);
    }

    static Expression<Func<object, Func<string, string>>> Test()
    {
        return (o) => o.M;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: @"12: o => Convert(System.String M(System.Object, System.String).CreateDelegate(System.Func`2[System.String,System.String], o)" + (ExecutionConditionUtil.IsMonoOrCoreClr ? ", Func`2)" : ")")).VerifyDiagnostics();
    }

    [Fact]
    public void ExpressionTrees_10_DelegateCreation_StaticMethod()
    {
        var src = """
using System;
using System.Linq.Expressions;

public static class Extensions
{
    extension(object o)
    {
        public static string M(string s) => s;
    }
}

class Program
{
    static void Main()
    {
        var e = Test();
        System.Console.Write(e.Compile().Invoke().Invoke("1"));
        System.Console.Write(": ");
        System.Console.Write(e);
    }

    static Expression<Func<Func<string, string>>> Test()
    {
        return () => object.M;
    }
}
""";
        var comp = CreateCompilation(src, options: TestOptions.DebugExe);
        CompileAndVerify(comp, expectedOutput: @"1: () => Convert(System.String M(System.String).CreateDelegate(System.Func`2[System.String,System.String], null)" + (ExecutionConditionUtil.IsMonoOrCoreClr ? ", Func`2)" : ")")).VerifyDiagnostics();
    }
}
