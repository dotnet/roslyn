// Copyright (c) Microsoft.  All Rights Reserved.  Licensed under the Apache License, Version 2.0.  See License.txt in the project root for license information.

using System;
using System.Collections.Immutable;
using System.Linq;
using Microsoft.CodeAnalysis.CSharp.Symbols;
using Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp.Test.Utilities;
using Microsoft.CodeAnalysis.Test.Utilities;
using Roslyn.Test.Utilities;
using Xunit;
using static Microsoft.CodeAnalysis.CSharp.Symbols.FlowAnalysisAnnotations;

namespace Microsoft.CodeAnalysis.CSharp.UnitTests.Semantics
{
    [CompilerTrait(CompilerFeature.NullableReferenceTypes)]
    public class NullableReferenceTypesTests : CSharpTestBase
    {
        [Fact, WorkItem(31297, "https://github.com/dotnet/roslyn/issues/31297")]
        public void SuppressNullableWarning_RefSpanReturn()
        {
            var comp = CreateCompilationWithMscorlibAndSpan(@"
using System;
class C
{
    ref Span<byte> M()
    {
        Span<byte> x = stackalloc byte[10];
        ref Span<byte> y = ref x!;
        return ref y; // 1
    }
    ref Span<byte> M2()
    {
        Span<byte> x = stackalloc byte[10];
        ref Span<byte> y = ref x;
        return ref y!; // 2
    }
}", options: TestOptions.ReleaseDll);

            comp.VerifyDiagnostics(
                // (9,20): error CS8157: Cannot return 'y' by reference because it was initialized to a value that cannot be returned by reference
                //         return ref y; // 1
                Diagnostic(ErrorCode.ERR_RefReturnNonreturnableLocal, "y").WithArguments("y").WithLocation(9, 20),
                // (15,20): error CS8598: The suppression operator is not allowed in this context
                //         return ref y!; // 2
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "y").WithLocation(15, 20)
                );
        }

        [Fact, WorkItem(31297, "https://github.com/dotnet/roslyn/issues/31297")]
        public void SuppressNullableWarning_RefReassignment()
        {
            var comp = CreateCompilationWithMscorlibAndSpan(@"
class C
{
    void M()
    {
        ref var x = ref NullableRef();
        x = ref x!;

        ref var y = ref NullableRef()!;
        y = ref y!;
    }

    ref string? NullableRef() => throw null;
}", options: WithNonNullTypesTrue());

            // Need to refine. Tracked by https://github.com/dotnet/roslyn/issues/31297
            comp.VerifyDiagnostics(
                // (7,17): error CS8598: The suppression operator is not allowed in this context
                //         x = ref x!;
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "x").WithLocation(7, 17),
                // (10,17): error CS8598: The suppression operator is not allowed in this context
                //         y = ref y!;
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "y").WithLocation(10, 17)
                );
        }

        [Fact, WorkItem(30151, "https://github.com/dotnet/roslyn/issues/30151")]
        public void SuppressNullableWarning_WholeArrayInitializer()
        {
            var comp = CreateCompilationWithMscorlibAndSpan(@"
class C
{
    unsafe void M()
    {
        string[] s = new[] { null, string.Empty }; // expecting a warning
        string[] s2 = (new[] { null, string.Empty })!;
        int* s3 = (stackalloc[] { 1 })!;
        System.Span<string> s4 = (stackalloc[] { null, string.Empty })!;
    }
}", options: TestOptions.UnsafeDebugDll);

            // Missing warning
            // Need to confirm whether this suppression should be allowed or be effective
            // If so, we need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/30151

            comp.VerifyDiagnostics(
                // (8,20): error CS1525: Invalid expression term 'stackalloc'
                //         int* s3 = (stackalloc[] { 1 })!;
                Diagnostic(ErrorCode.ERR_InvalidExprTerm, "stackalloc").WithArguments("stackalloc").WithLocation(8, 20),
                // (9,35): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('string')
                //         System.Span<string> s4 = (stackalloc[] { null, string.Empty })!;
                Diagnostic(ErrorCode.ERR_ManagedAddr, "stackalloc[] { null, string.Empty }").WithArguments("string").WithLocation(9, 35),
                // (9,35): error CS1525: Invalid expression term 'stackalloc'
                //         System.Span<string> s4 = (stackalloc[] { null, string.Empty })!;
                Diagnostic(ErrorCode.ERR_InvalidExprTerm, "stackalloc").WithArguments("stackalloc").WithLocation(9, 35)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_NullCoalescingAssignment()
        {
            var comp = CreateCompilation(@"
class C
{
    void M(int? i, int i2, dynamic d)
    {
        i! ??= i2; // 1
        i ??= i2!;
        i! ??= d; // 2
        i ??= d!;
    }
    void M(string? s, string s2, dynamic d)
    {
        s! ??= s2; // 3
        s ??= s2!;
        s! ??= d; // 4
        s ??= d!;
    }
}", options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): error CS8598: The suppression operator is not allowed in this context
                //         i! ??= i2; // 1
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "i").WithLocation(6, 9),
                // (8,9): error CS8598: The suppression operator is not allowed in this context
                //         i! ??= d; // 2
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "i").WithLocation(8, 9),
                // (9,9): hidden CS8607: Expression is probably never null.
                //         i ??= d!;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "i").WithLocation(9, 9),
                // (13,9): error CS8598: The suppression operator is not allowed in this context
                //         s! ??= s2; // 3
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "s").WithLocation(13, 9),
                // (15,9): error CS8598: The suppression operator is not allowed in this context
                //         s! ??= d; // 4
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "s").WithLocation(15, 9),
                // (16,9): hidden CS8607: Expression is probably never null.
                //         s ??= d!;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "s").WithLocation(16, 9)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_ExpressionTree()
        {
            var comp = CreateCompilation(@"
using System;
using System.Linq.Expressions;
class C
{
    void M()
    {
        string x = null;
        Expression<Func<string>> e = () => x!;
        Expression<Func<string>> e2 = (() => x)!;
        Expression<Func<Func<string>>> e3 = () => M2!;
    }
    string M2() => throw null;
}");
            comp.VerifyDiagnostics();
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_QueryReceiver()
        {
            string source = @"
using System;
namespace NS { }
static class C
{
    static void Main()
    {
        _ = from x in null! select x;
        _ = from x in default! select x;
        _ = from x in (y => y)! select x;
        _ = from x in NS! select x;
        _ = from x in Main! select x;
    }

    static object Select(this object x, Func<int, int> y)
    {
        return null;
    }
}
";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (8,29): error CS0186: Use of null is not valid in this context
                //         _ = from x in null! select x;
                Diagnostic(ErrorCode.ERR_NullNotValid, "select x").WithLocation(8, 29),
                // (9,32): error CS8312: Use of default literal is not valid in this context
                //         _ = from x in default! select x;
                Diagnostic(ErrorCode.ERR_DefaultLiteralNotValid, "select x").WithLocation(9, 32),
                // (10,33): error CS1936: Could not find an implementation of the query pattern for source type 'anonymous method'.  'Select' not found.
                //         _ = from x in (y => y)! select x;
                Diagnostic(ErrorCode.ERR_QueryNoProvider, "select x").WithArguments("anonymous method", "Select").WithLocation(10, 33),
                // (11,23): error CS8598: The suppression operator is not allowed in this context
                //         _ = from x in NS! select x;
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "NS").WithLocation(11, 23),
                // (11,23): error CS0119: 'NS' is a namespace, which is not valid in the given context
                //         _ = from x in NS! select x;
                Diagnostic(ErrorCode.ERR_BadSKunknown, "NS").WithArguments("NS", "namespace").WithLocation(11, 23),
                // (12,23): error CS0119: 'C.Main()' is a method, which is not valid in the given context
                //         _ = from x in Main! select x;
                Diagnostic(ErrorCode.ERR_BadSKunknown, "Main").WithArguments("C.Main()", "method").WithLocation(12, 23)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_Query()
        {
            string source = @"
using System.Linq;
class C
{
    static void M(System.Collections.Generic.IEnumerable<int> c)
    {
        var q = (from x in c select x)!;
    }
}
";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics();
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_EventInCompoundAssignment()
        {
            var comp = CreateCompilation(@"
class C
{
    public event System.Action E;
    void M()
    {
        E! += () => {};
    }
}");
            comp.VerifyDiagnostics(
                // (7,9): error CS8598: The suppression operator is not allowed in this context
                //         E! += () => {};
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "E").WithLocation(7, 9)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void OperationsInNonDeclaringType()
        {
            var text = @"
class C
{
    public event System.Action E;
}

class D
{
    void Method(ref System.Action a, C c)
    {
        c.E! = a; //CS0070
        c.E! += a;
        a = c.E!; //CS0070
        Method(ref c.E!, c); //CS0070
        c.E!.Invoke(); //CS0070
        bool b1 = c.E! is System.Action; //CS0070
        c.E!++; //CS0070
        c.E! |= true; //CS0070
    }
}
";
            CreateCompilation(text).VerifyDiagnostics(
                // (11,9): error CS8598: The suppression operator is not allowed in this context
                //         c.E! = a; //CS0070
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "c.E").WithLocation(11, 9),
                // (12,9): error CS8598: The suppression operator is not allowed in this context
                //         c.E! += a;
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "c.E").WithLocation(12, 9),
                // (13,15): error CS0070: The event 'C.E' can only appear on the left hand side of += or -= (except when used from within the type 'C')
                //         a = c.E!; //CS0070
                Diagnostic(ErrorCode.ERR_BadEventUsage, "E").WithArguments("C.E", "C").WithLocation(13, 15),
                // (14,22): error CS0070: The event 'C.E' can only appear on the left hand side of += or -= (except when used from within the type 'C')
                //         Method(ref c.E!, c); //CS0070
                Diagnostic(ErrorCode.ERR_BadEventUsage, "E").WithArguments("C.E", "C").WithLocation(14, 22),
                // (15,11): error CS0070: The event 'C.E' can only appear on the left hand side of += or -= (except when used from within the type 'C')
                //         c.E!.Invoke(); //CS0070
                Diagnostic(ErrorCode.ERR_BadEventUsage, "E").WithArguments("C.E", "C").WithLocation(15, 11),
                // (16,21): error CS0070: The event 'C.E' can only appear on the left hand side of += or -= (except when used from within the type 'C')
                //         bool b1 = c.E! is System.Action; //CS0070
                Diagnostic(ErrorCode.ERR_BadEventUsage, "E").WithArguments("C.E", "C").WithLocation(16, 21),
                // (17,9): error CS8598: The suppression operator is not allowed in this context
                //         c.E!++; //CS0070
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "c.E").WithLocation(17, 9),
                // (18,9): error CS8598: The suppression operator is not allowed in this context
                //         c.E! |= true; //CS0070
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "c.E").WithLocation(18, 9)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_Fixed()
        {
            var text = @"
public class MyClass
{
    int field = 0;
    unsafe public void Main()
    {
        int i = 45;
        fixed (int *j = &(i!)) { }
        fixed (int *k = &(this!.field)) { }

        int[] a = new int[] {1,2,3};
        fixed (int *b = a!)
        {
            fixed (int *c = b!) { }
        }
    }
}
";
            CreateCompilation(text, options: TestOptions.UnsafeReleaseDll).VerifyDiagnostics(
                // (8,27): error CS8598: The suppression operator is not allowed in this context
                //         fixed (int *j = &(i!)) { }
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "i").WithLocation(8, 27),
                // (14,29): error CS8385: The given expression cannot be used in a fixed statement
                //             fixed (int *c = b!) { }
                Diagnostic(ErrorCode.ERR_ExprCannotBeFixed, "b").WithLocation(14, 29)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_MemberAccess()
        {
            var comp = CreateCompilation(@"
namespace NS
{
    public static class C
    {
        public static void M()
        {
            _ = null!.field; // 1
            _ = default!.field; // 2
            _ = NS!.C.field; // 3
            _ = NS.C!.field; // 4
            _ = nameof(C!.M); // 5
            _ = nameof(C.M!); // 6
            _ = nameof(missing!); // 7
        }
    }
    public class Base { public virtual void M() { } }
    public class D : Base
    {
        public override void M()
        {
            _ = this!.ToString(); // 8
            _ = base!.ToString(); // 9
        }
    }
}");
            // Like cast, suppressions are allowed on `this`, but not on `base`

            comp.VerifyDiagnostics(
                // (8,17): error CS0023: Operator '.' cannot be applied to operand of type '<null>'
                //             _ = null!.field; // 1
                Diagnostic(ErrorCode.ERR_BadUnaryOp, "null!.field").WithArguments(".", "<null>").WithLocation(8, 17),
                // (9,25): error CS0023: Operator '.' cannot be applied to operand of type 'default'
                //             _ = default!.field; // 2
                Diagnostic(ErrorCode.ERR_BadUnaryOp, ".").WithArguments(".", "default").WithLocation(9, 25),
                // (10,17): error CS8598: The suppression operator is not allowed in this context
                //             _ = NS!.C.field; // 3
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "NS").WithLocation(10, 17),
                // (10,23): error CS0117: 'C' does not contain a definition for 'field'
                //             _ = NS!.C.field; // 3
                Diagnostic(ErrorCode.ERR_NoSuchMember, "field").WithArguments("NS.C", "field").WithLocation(10, 23),
                // (11,17): error CS8598: The suppression operator is not allowed in this context
                //             _ = NS.C!.field; // 4
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "NS.C").WithLocation(11, 17),
                // (11,23): error CS0117: 'C' does not contain a definition for 'field'
                //             _ = NS.C!.field; // 4
                Diagnostic(ErrorCode.ERR_NoSuchMember, "field").WithArguments("NS.C", "field").WithLocation(11, 23),
                // (12,24): error CS8598: The suppression operator is not allowed in this context
                //             _ = nameof(C!.M); // 5
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "C").WithLocation(12, 24),
                // (12,24): error CS8082: Sub-expression cannot be used in an argument to nameof.
                //             _ = nameof(C!.M); // 5
                Diagnostic(ErrorCode.ERR_SubexpressionNotInNameof, "C!").WithLocation(12, 24),
                // (13,24): error CS8081: Expression does not have a name.
                //             _ = nameof(C.M!); // 6
                Diagnostic(ErrorCode.ERR_ExpressionHasNoName, "C.M!").WithLocation(13, 24),
                // (14,24): error CS0103: The name 'missing' does not exist in the current context
                //             _ = nameof(missing!); // 7
                Diagnostic(ErrorCode.ERR_NameNotInContext, "missing").WithArguments("missing").WithLocation(14, 24),
                // (23,17): error CS0175: Use of keyword 'base' is not valid in this context
                //             _ = base!.ToString(); // 9
                Diagnostic(ErrorCode.ERR_BaseIllegal, "base").WithLocation(23, 17)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SymbolInfoForMethodGroup03()
        {
            var source = @"
public class A
{
    public static void M(A a)
    {
        _ = nameof(a.Extension!);
    }
}
public static class X1
{
    public static string Extension(this A a) { return null; }
}";
            var compilation = CreateCompilationWithMscorlib40AndSystemCore(source);
            compilation.VerifyDiagnostics(
                // (6,20): error CS8081: Expression does not have a name.
                //         _ = nameof(a.Extension!);
                Diagnostic(ErrorCode.ERR_ExpressionHasNoName, "a.Extension!").WithLocation(6, 20)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_StringInterpolation()
        {
            var source = @"
public class C
{
    public static void Main()
    {
        M(""world"", null);
    }
    public static void M(string x, string? y)
    {
        System.IFormattable z = $""hello ""!;
        System.IFormattable z2 = $""{x} {y} {y!}""!;
        System.Console.Write(z);
        System.Console.Write(z2);
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics();
            CompileAndVerify(comp, expectedOutput: "hello world");

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            var suppression = tree.GetRoot().DescendantNodes().OfType<PostfixUnaryExpressionSyntax>().First();
            Assert.Equal(@"$""hello ""!", suppression.ToString());

            // Need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/32661

            // should be IFormattable twice
            //VerifyTypeInfo(model, suppression, "System.String", "System.IFormattable");

            var interpolated = suppression.Operand;
            Assert.Equal(@"$""hello """, interpolated.ToString());
            VerifyTypeInfo(model, interpolated, "System.String", "System.IFormattable");
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_StringInterpolation_ExplicitCast()
        {
            var source = @"
public class C
{
    public static void Main()
    {
        M(""world"", null);
    }
    public static void M(string x, string? y)
    {
        var z = (System.IFormattable)($""hello ""!);
        var z2 = (System.IFormattable)($""{x} {y} {y!}""!);
        System.Console.Write(z);
        System.Console.Write(z2);
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics();
            CompileAndVerify(comp, expectedOutput: "hello world");

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            // Need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/32661

            var suppression = tree.GetRoot().DescendantNodes().OfType<PostfixUnaryExpressionSyntax>().First();

            Assert.Equal(@"$""hello ""!", suppression.ToString());
            //VerifyTypeInfo(model, suppression, "System.String", "System.String");

            var interpolated = suppression.Operand;
            Assert.Equal(@"$""hello """, interpolated.ToString());
            VerifyTypeInfo(model, interpolated, "System.String", "System.String");
        }

        private static void VerifyTypeInfo(SemanticModel model, ExpressionSyntax expression, string expectedType, string expectedConvertedType)
        {
            var type = model.GetTypeInfo(expression);
            if (expectedType is null)
            {
                Assert.Null(type.Type);
            }
            else
            {
                var actualType = type.Type.ToTestDisplayString();
                Assert.True(expectedType == actualType, $"Unexpected TypeInfo.Type '{actualType}'");
            }

            if (expectedConvertedType is null)
            {
                Assert.Null(type.ConvertedType);
            }
            else
            {
                var actualConvertedType = type.ConvertedType.ToTestDisplayString();
                Assert.True(expectedConvertedType == actualConvertedType, $"Unexpected TypeInfo.ConvertedType '{actualConvertedType}'");
            }
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_Default()
        {
            var source =
@"class C
{
    static void M()
    {
        string s = default!;
        s.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            CompileAndVerify(comp);

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            var suppression = tree.GetRoot().DescendantNodes().OfType<PostfixUnaryExpressionSyntax>().Single();

            // Need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/32661

            //VerifyTypeInfo(model, suppression, "System.String", "System.String");

            var literal = suppression.Operand;
            VerifyTypeInfo(model, literal, "System.String", "System.String");
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_Constant()
        {
            var source =
@"class C
{
    static void M()
    {
        const int i = 3!;
        _ = i;
        const string s = null!;
        _ = s;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);
            var suppressions = tree.GetRoot().DescendantNodes().OfType<PostfixUnaryExpressionSyntax>().ToArray();

            // Need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/32661

            //Assert.Equal(3, model.GetConstantValue(suppressions[0]).Value);
            //Assert.Null(model.GetConstantValue(suppressions[1]).Value);
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_MethodGroupInNameof()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void M<T>()
    {
        _ = nameof(C.M<T>!);
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,24): error CS0119: 'T' is a type, which is not valid in the given context
                //         _ = nameof(C.M<T>!);
                Diagnostic(ErrorCode.ERR_BadSKunknown, "T").WithArguments("T", "type").WithLocation(6, 24),
                // (6,27): error CS1525: Invalid expression term ')'
                //         _ = nameof(C.M<T>!);
                Diagnostic(ErrorCode.ERR_InvalidExprTerm, ")").WithArguments(")").WithLocation(6, 27)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_MethodGroup()
        {
            var source =
@"class C
{
    delegate string Copier(string s);
    static void Main()
    {
        Copier c = M2;
        Copier c2 = M2!;
    }
    static string? M2(string? s) => throw null;
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics(
                // (6,20): warning CS8621: Nullability of reference types in return type of 'string? C.M2(string? s)' doesn't match the target delegate 'C.Copier'.
                //         Copier c = M2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "M2").WithArguments("string? C.M2(string? s)", "C.Copier").WithLocation(6, 20)
                );
            CompileAndVerify(comp);

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            // Need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/32661

            // unepxected answer from semantic model
            var suppression = tree.GetRoot().DescendantNodes().OfType<PostfixUnaryExpressionSyntax>().Single();
            //VerifyTypeInfo(model, suppression, null, "C.Copier");

            var methodGroup = suppression.Operand;
            VerifyTypeInfo(model, methodGroup, null, "C.Copier");
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void InvalidUseOfMethodGroup()
        {
            var source =
@"class A
{
    internal object E() { return null; }
    private object F() { return null; }
    static void M(A a)
    {
        object o;
        a.E! += a.E!; // 1
        if (a.E! != null) // 2
        {
            M(a.E!); // 3
            a.E!.ToString(); // 4
            a.P!.ToString(); // 5
            o = !(a.E!); // 6
            o = a.E! ?? a.F!; // 7
        }
        a.F! += a.F!; // 8
        if (a.F! != null) // 9
        {
            M(a.F!); // 10
            a.F!.ToString(); // 11
            o = !(a.F!); // 12
            o = (o != null) ? a.E! : a.F!; // 13
        }
    }
}";
            CreateCompilation(source).VerifyDiagnostics(
                // (8,9): error CS8598: The suppression operator is not allowed in this context
                //         a.E! += a.E!; // 1
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "a.E").WithLocation(8, 9),
                // (9,13): error CS0019: Operator '!=' cannot be applied to operands of type 'method group' and '<null>'
                //         if (a.E! != null) // 2
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "a.E! != null").WithArguments("!=", "method group", "<null>").WithLocation(9, 13),
                // (11,15): error CS1503: Argument 1: cannot convert from 'method group' to 'A'
                //             M(a.E!); // 3
                Diagnostic(ErrorCode.ERR_BadArgType, "a.E").WithArguments("1", "method group", "A").WithLocation(11, 15),
                // (12,15): error CS0119: 'A.E()' is a method, which is not valid in the given context
                //             a.E!.ToString(); // 4
                Diagnostic(ErrorCode.ERR_BadSKunknown, "E").WithArguments("A.E()", "method").WithLocation(12, 15),
                // (13,15): error CS1061: 'A' does not contain a definition for 'P' and no accessible extension method 'P' accepting a first argument of type 'A' could be found (are you missing a using directive or an assembly reference?)
                //             a.P!.ToString(); // 5
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "P").WithArguments("A", "P").WithLocation(13, 15),
                // (14,17): error CS0023: Operator '!' cannot be applied to operand of type 'method group'
                //             o = !(a.E!); // 6
                Diagnostic(ErrorCode.ERR_BadUnaryOp, "!(a.E!)").WithArguments("!", "method group").WithLocation(14, 17),
                // (15,17): error CS0019: Operator '??' cannot be applied to operands of type 'method group' and 'method group'
                //             o = a.E! ?? a.F!; // 7
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "a.E! ?? a.F!").WithArguments("??", "method group", "method group").WithLocation(15, 17),
                // (17,9): error CS8598: The suppression operator is not allowed in this context
                //         a.F! += a.F!; // 8
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "a.F").WithLocation(17, 9),
                // (18,13): error CS0019: Operator '!=' cannot be applied to operands of type 'method group' and '<null>'
                //         if (a.F! != null) // 9
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "a.F! != null").WithArguments("!=", "method group", "<null>").WithLocation(18, 13),
                // (20,15): error CS1503: Argument 1: cannot convert from 'method group' to 'A'
                //             M(a.F!); // 10
                Diagnostic(ErrorCode.ERR_BadArgType, "a.F").WithArguments("1", "method group", "A").WithLocation(20, 15),
                // (21,15): error CS0119: 'A.F()' is a method, which is not valid in the given context
                //             a.F!.ToString(); // 11
                Diagnostic(ErrorCode.ERR_BadSKunknown, "F").WithArguments("A.F()", "method").WithLocation(21, 15),
                // (22,17): error CS0023: Operator '!' cannot be applied to operand of type 'method group'
                //             o = !(a.F!); // 12
                Diagnostic(ErrorCode.ERR_BadUnaryOp, "!(a.F!)").WithArguments("!", "method group").WithLocation(22, 17),
                // (23,17): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'method group' and 'method group'
                //             o = (o != null) ? a.E! : a.F!; // 13
                Diagnostic(ErrorCode.ERR_InvalidQM, "(o != null) ? a.E! : a.F!").WithArguments("method group", "method group").WithLocation(23, 17)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_AccessPropertyWithoutArguments()
        {
            string source1 = @"
Imports System
Imports System.Runtime.InteropServices
<Assembly: PrimaryInteropAssembly(0, 0)>
<Assembly: Guid(""165F752D-E9C4-4F7E-B0D0-CDFD7A36E210"")>
<ComImport()>
<Guid(""165F752D-E9C4-4F7E-B0D0-CDFD7A36E211"")>
Public Interface IB
    Property Value(Optional index As Object = Nothing) As Object
End Interface
";

            var reference = BasicCompilationUtils.CompileToMetadata(source1);

            string source2 = @"
class CIB : IB
{
    public dynamic get_Value(object index = null)
    {
        return ""Test"";
    }

    public void set_Value(object index = null, object Value = null)
    {
    }
}

class Test
{
    static void Main()
    {
        IB x = new CIB();
        System.Console.WriteLine(x.Value!.Length);
    }
}
";

            var compilation2 = CreateCompilation(source2, new[] { reference.WithEmbedInteropTypes(true), CSharpRef }, options: TestOptions.ReleaseExe);

            CompileAndVerify(compilation2, expectedOutput: @"4");
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_CollectionInitializerProperty()
        {
            var source = @"
public class C
{
    public string P { get; set; } = null!;
    void M()
    {
        _ = new C() { P! = null };
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,21): error CS1922: Cannot initialize type 'C' with a collection initializer because it does not implement 'System.Collections.IEnumerable'
                //         _ = new C() { P! = null };
                Diagnostic(ErrorCode.ERR_CollectionInitRequiresIEnumerable, "{ P! = null }").WithArguments("C").WithLocation(7, 21),
                // (7,23): error CS0747: Invalid initializer member declarator
                //         _ = new C() { P! = null };
                Diagnostic(ErrorCode.ERR_InvalidInitializerElementInitializer, "P! = null").WithLocation(7, 23),
                // (7,23): error CS8598: The suppression operator is not allowed in this context
                //         _ = new C() { P! = null };
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "P").WithLocation(7, 23)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_InInvocation()
        {
            var source = @"
public class C
{
    public System.Action? field = null;
    void M()
    {
        this.M!();
        nameof!(M);
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): error CS8598: The suppression operator is not allowed in this context
                //         this.M!();
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "this.M").WithLocation(7, 9),
                // (8,9): error CS0103: The name 'nameof' does not exist in the current context
                //         nameof!(M);
                Diagnostic(ErrorCode.ERR_NameNotInContext, "nameof").WithArguments("nameof").WithLocation(8, 9)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_InInvocation2()
        {
            var source = @"
public class C
{
    public System.Action? field = null;
    void M()
    {
        this!.field!();
    }
}";
            var comp = CreateCompilationWithCSharp(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            CompileAndVerify(comp);
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_InInvocationAndDynamic()
        {
            var source = @"
public class C
{
    void M()
    {
        dynamic? d = new object();
        d.M!(); // 1
        int z = d.y.z;

        d = null;
        d!.M();

        d = null;
        int y = d.y; // 2

        d = null;
        d.M!(); // 3

        d += null;
        d += null!;
    }
}";
            // What warnings should we produce on dynamic?
            // Should `!` be allowed on members/invocations on dynamic?
            // See https://github.com/dotnet/roslyn/issues/32364

            var comp = CreateCompilationWithCSharp(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): error CS8598: The suppression operator is not allowed in this context
                //         d.M!(); // 1
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "d.M").WithLocation(7, 9),
                // (14,17): warning CS8602: Possible dereference of a null reference.
                //         int y = d.y; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "d").WithLocation(14, 17),
                // (17,9): error CS8598: The suppression operator is not allowed in this context
                //         d.M!(); // 3
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "d.M").WithLocation(17, 9),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         d.M!(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "d").WithLocation(17, 9)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_Stackalloc()
        {
            var comp = CreateCompilationWithMscorlibAndSpan(@"
class Test
{
    void M()
    {
        System.Span<int> a3 = stackalloc[] { 1, 2, 3 }!;
        var x3 = true ? stackalloc[] { 1, 2, 3 }! : a3;
    }
}", TestOptions.UnsafeReleaseDll);

            // Note: when we allow stackalloc expressions to be nested in other expressions,
            // we'll have to look at conversion from expression of suppressed stackalloc
            comp.VerifyDiagnostics(
                // (6,31): error CS1525: Invalid expression term 'stackalloc'
                //         System.Span<int> a3 = stackalloc[] { 1, 2, 3 }!;
                Diagnostic(ErrorCode.ERR_InvalidExprTerm, "stackalloc").WithArguments("stackalloc").WithLocation(6, 31),
                // (7,25): error CS1525: Invalid expression term 'stackalloc'
                //         var x3 = true ? stackalloc[] { 1, 2, 3 }! : a3;
                Diagnostic(ErrorCode.ERR_InvalidExprTerm, "stackalloc").WithArguments("stackalloc").WithLocation(7, 25)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_MethodGroup2()
        {
            var source =
@"class C
{
    delegate string? Copier(string? s);
    static void Main()
    {
        Copier c = M2;
        Copier c2 = M2!;
    }
    static string M2(string s) => throw null;
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics(
                // (6,20): warning CS8622: Nullability of reference types in type of parameter 's' of 'string C.M2(string s)' doesn't match the target delegate 'C.Copier'.
                //         Copier c = M2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "M2").WithArguments("s", "string C.M2(string s)", "C.Copier").WithLocation(6, 20)
                );
            CompileAndVerify(comp);
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_Lambda()
        {
            var source =
@"class C
{
    delegate string Copier(string s);
    static void Main()
    {
        Copier c = (string? x) => { return null; }!;
        Copier c2 = (string? x) => { return null; };
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics(
                // (6,44): warning CS8603: Possible null reference return.
                //         Copier c = (string? x) => { return null; }!;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(6, 44),
                // (7,21): warning CS8622: Nullability of reference types in type of parameter 'x' of 'lambda expression' doesn't match the target delegate 'C.Copier'.
                //         Copier c2 = (string? x) => { return null; };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(string? x) => { return null; }").WithArguments("x", "lambda expression", "C.Copier").WithLocation(7, 21),
                // (7,45): warning CS8603: Possible null reference return.
                //         Copier c2 = (string? x) => { return null; };
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(7, 45)
                );
            CompileAndVerify(comp);

            // Need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/32661

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            var suppression = tree.GetRoot().DescendantNodes().OfType<PostfixUnaryExpressionSyntax>().Single();
            Assert.Equal("(string? x) => { return null; }!", suppression.ToString());
            //VerifyTypeInfo(model, suppression, null, "C.Copier");

            var lambda = suppression.Operand;
            Assert.Equal("(string? x) => { return null; }", lambda.ToString());
            VerifyTypeInfo(model, lambda, null, "C.Copier");
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_Lambda_ExplicitCast()
        {
            var source =
@"class C
{
    delegate string Copier(string s);
    static void M()
    {
        var c = (Copier)((string? x) => { return null; }!);
        var c2 = (Copier)((string? x) => { return null; });
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,50): warning CS8603: Possible null reference return.
                //         var c = (Copier)((string? x) => { return null; }!);
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(6, 50),
                // (7,18): warning CS8622: Nullability of reference types in type of parameter 'x' of 'lambda expression' doesn't match the target delegate 'C.Copier'.
                //         var c2 = (Copier)((string? x) => { return null; });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(Copier)((string? x) => { return null; })").WithArguments("x", "lambda expression", "C.Copier").WithLocation(7, 18),
                // (7,51): warning CS8603: Possible null reference return.
                //         var c2 = (Copier)((string? x) => { return null; });
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(7, 51)
                );
            CompileAndVerify(comp);

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            // Need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/32661

            var suppression = tree.GetRoot().DescendantNodes().OfType<PostfixUnaryExpressionSyntax>().Single();
            Assert.Equal("(string? x) => { return null; }!", suppression.ToString());
            //VerifyTypeInfo(model, suppression, "C.Copier", "C.Copier");

            var lambda = suppression.Operand;
            Assert.Equal("(string? x) => { return null; }", lambda.ToString());
            VerifyTypeInfo(model, lambda, null, "C.Copier");
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_Lambda2()
        {
            var source =
@"class C
{
    delegate string? Copier(string? s);
    static void Main()
    {
        Copier c = (string x) => { return string.Empty; }!;
        Copier c2 = (string x) => { return string.Empty; };
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics(
                // (7,21): warning CS8622: Nullability of reference types in type of parameter 'x' of 'lambda expression' doesn't match the target delegate 'C.Copier'.
                //         Copier c2 = (string x) => { return string.Empty; };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(string x) => { return string.Empty; }").WithArguments("x", "lambda expression", "C.Copier").WithLocation(7, 21)
                );
            CompileAndVerify(comp);

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);
            var suppression = tree.GetRoot().DescendantNodes().OfType<PostfixUnaryExpressionSyntax>().Single();
            Assert.Equal("(string x) => { return string.Empty; }!", suppression.ToString());

            // Need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/32661

            //VerifyTypeInfo(model, suppression, null, "C.Copier");

            var lambda = suppression.Operand;
            Assert.Equal("(string x) => { return string.Empty; }", lambda.ToString());
            VerifyTypeInfo(model, lambda, null, "C.Copier");
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_Lambda2_ExplicitCast()
        {
            var source =
@"class C
{
    delegate string? Copier(string? s);
    static void Main()
    {
        var c = (Copier)((string x) => { return string.Empty; }!);
        var c2 = (Copier)((string x) => { return string.Empty; });
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics(
                // (7,18): warning CS8622: Nullability of reference types in type of parameter 'x' of 'lambda expression' doesn't match the target delegate 'C.Copier'.
                //         var c2 = (Copier)((string x) => { return string.Empty; });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(Copier)((string x) => { return string.Empty; })").WithArguments("x", "lambda expression", "C.Copier").WithLocation(7, 18)
                );
            CompileAndVerify(comp);

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            // Need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/32661

            var suppression = tree.GetRoot().DescendantNodes().OfType<PostfixUnaryExpressionSyntax>().Single();
            Assert.Equal("(string x) => { return string.Empty; }!", suppression.ToString());
            //VerifyTypeInfo(model, suppression, "C.Copier", "C.Copier");

            var lambda = suppression.Operand;
            Assert.Equal("(string x) => { return string.Empty; }", lambda.ToString());
            VerifyTypeInfo(model, lambda, null, "C.Copier");
        }

        [Fact, WorkItem(32697, "https://github.com/dotnet/roslyn/issues/32697")]
        public void SuppressNullableWarning_LambdaInOverloadResolution()
        {
            var source =
@"class C
{
    static void Main(string? x)
    {
        var s = M(() => { return x; });
        s /*T:string?*/ .ToString(); // 1

        var s2 = M(() => { return x; }!); // suppressed
        s2 /*T:string?*/ .ToString(); // 2

        var s3 = M(M2);
        s3 /*T:string*/ .ToString(); // 3

        var s4 = M(M2!); // suppressed
        s4 /*T:string*/ .ToString(); // 4
    }
    static T M<T>(System.Func<T> x) => throw null;
    static string? M2() => throw null;
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyTypes();

            // Missing warnings on s3 and s4
            // Tracked by https://github.com/dotnet/roslyn/issues/32697

            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s /*T:string?*/ .ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         s2 /*T:string?*/ .ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(9, 9)
                );
            CompileAndVerify(comp);
        }

        [Fact, WorkItem(32698, "https://github.com/dotnet/roslyn/issues/32698")]
        public void SuppressNullableWarning_DelegateCreation()
        {
            var source =
@"class C
{
    static void Main()
    {
        _ = new System.Func<string, string>((string? x) => { return null; }!);
        _ = new System.Func<string?, string?>((string x) => { return string.Empty; }!);
        _ = new System.Func<string, string>(M1!);
        _ = new System.Func<string?, string?>(M2!);

        // without suppression
        _ = new System.Func<string, string>((string? x) => { return null; }); // 1
        _ = new System.Func<string?, string?>((string x) => { return string.Empty; }); // 2
        _ = new System.Func<string, string>(M1); // 3
        _ = new System.Func<string?, string?>(M2); // 4
    }
    static string? M1(string? x) => throw null;
    static string M2(string x) => throw null;
}";

            // missing warnings
            // Tracked by https://github.com/dotnet/roslyn/issues/32698

            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics(
                );
            CompileAndVerify(comp);

            // Need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/32661
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_MethodGroupInOverloadResolution_NoReceiver()
        {
            var source =
@"using System;
using System.Collections.Generic;
class A
{
    class B
    {
        void F()
        {
            IEnumerable<string?> c = null!;
            c.S(G);
            c.S(G!);

            IEnumerable<string> c2 = null!;
            c2.S(G);
            c2.S(G2);
        }
    }
    object G(string s) => throw null;
    object G2(string? s) => throw null;
}
static class E
{
    internal static IEnumerable<U> S<T, U>(this IEnumerable<T> c, Func<T, U> f)
    {
        throw new NotImplementedException();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,17): error CS0120: An object reference is required for the non-static field, method, or property 'A.G(string)'
                //             c.S(G);
                Diagnostic(ErrorCode.ERR_ObjectRequired, "G").WithArguments("A.G(string)").WithLocation(10, 17),
                // (11,17): error CS0120: An object reference is required for the non-static field, method, or property 'A.G(string)'
                //             c.S(G!);
                Diagnostic(ErrorCode.ERR_ObjectRequired, "G").WithArguments("A.G(string)").WithLocation(11, 17),
                // (14,18): error CS0120: An object reference is required for the non-static field, method, or property 'A.G(string)'
                //             c2.S(G);
                Diagnostic(ErrorCode.ERR_ObjectRequired, "G").WithArguments("A.G(string)").WithLocation(14, 18),
                // (15,18): error CS0120: An object reference is required for the non-static field, method, or property 'A.G2(string?)'
                //             c2.S(G2);
                Diagnostic(ErrorCode.ERR_ObjectRequired, "G2").WithArguments("A.G2(string?)").WithLocation(15, 18)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_MethodGroupInOverloadResolution()
        {
            var source =
@"using System;
using System.Collections.Generic;
class A
{
    void M()
    {
        IEnumerable<string?> c = null!;
        c.S(G); // 1
        c.S(G!);

        IEnumerable<string> c2 = null!;
        c2.S(G);
        c2.S(G2);
    }
    static object G(string s) => throw null;
    static object G2(string? s) => throw null;
}
static class E
{
    internal static IEnumerable<U> S<T, U>(this IEnumerable<T> c, Func<T, U> f)
    {
        throw new NotImplementedException();
    }
}";

            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8622: Nullability of reference types in type of parameter 's' of 'object A.G(string s)' doesn't match the target delegate 'Func<string?, object>'.
                //         c.S(G); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "G").WithArguments("s", "object A.G(string s)", "System.Func<string?, object>").WithLocation(8, 13)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void ErrorInLambdaArgumentList()
        {
            var source = @"
class Program
{
    public Program(string x) : this((() => x)!) { }
}";

            CreateCompilation(source).VerifyDiagnostics(
                // (4,38): error CS1660: Cannot convert lambda expression to type 'string' because it is not a delegate type
                //     public Program(string x) : this((() => x)!) { }
                Diagnostic(ErrorCode.ERR_AnonMethToNonDel, "() => x").WithArguments("lambda expression", "string").WithLocation(4, 38)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void CS1113ERR_ValueTypeExtDelegate01()
        {
            var source =
@"class C
{
    public void M() { }
}
interface I
{
    void M();
}
enum E
{
}
struct S
{
    public void M() { }
}
static class SC
{
    static void Test(C c, I i, E e, S s, double d)
    {
        System.Action cm = c.M!;   // OK -- instance method
        System.Action cm1 = c.M1!; // OK -- extension method on ref type
        System.Action im = i.M!;   // OK -- instance method
        System.Action im2 = i.M2!; // OK -- extension method on ref type
        System.Action em3 = e.M3!; // BAD -- extension method on value type
        System.Action sm = s.M!;   // OK -- instance method
        System.Action sm4 = s.M4!; // BAD -- extension method on value type
        System.Action dm5 = d.M5!; // BAD -- extension method on value type
    }

    static void M1(this C c) { }
    static void M2(this I i) { }
    static void M3(this E e) { }
    static void M4(this S s) { }
    static void M5(this double d) { }
}";
            CreateCompilationWithMscorlib40(source, references: new[] { SystemCoreRef }).VerifyDiagnostics(
                // (24,29): error CS1113: Extension methods 'SC.M3(E)' defined on value type 'E' cannot be used to create delegates
                Diagnostic(ErrorCode.ERR_ValueTypeExtDelegate, "e.M3").WithArguments("SC.M3(E)", "E").WithLocation(24, 29),
                // (26,29): error CS1113: Extension methods 'SC.M4(S)' defined on value type 'S' cannot be used to create delegates
                Diagnostic(ErrorCode.ERR_ValueTypeExtDelegate, "s.M4").WithArguments("SC.M4(S)", "S").WithLocation(26, 29),
                // (27,29): error CS1113: Extension methods 'SC.M5(double)' defined on value type 'double' cannot be used to create delegates
                Diagnostic(ErrorCode.ERR_ValueTypeExtDelegate, "d.M5").WithArguments("SC.M5(double)", "double").WithLocation(27, 29));
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void BugCodePlex_30_01()
        {
            string source1 = @"
using System;
class C
{
    static void Main()
    {
        Goo(() => { return () => 0; ; }!);
        Goo(() => { return () => 0; }!);
    }
    static void Goo(Func<Func<short>> x) { Console.Write(1); }
    static void Goo(Func<Func<int>> x) { Console.Write(2); }
}
";
            CompileAndVerify(source1, expectedOutput: @"22");
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_AddressOfWithLambdaOrMethodGroup()
        {
            var source = @"
unsafe class C
{
    static void M()
    {
        _ = &(() => {}!);
        _ = &(M!);
    }
}";
            var comp = CreateCompilation(source, options: TestOptions.UnsafeReleaseDll);
            comp.VerifyDiagnostics(
                // (6,15): error CS8598: The suppression operator is not allowed in this context
                //         _ = &(() => {}!);
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "() => {}").WithLocation(6, 15),
                // (7,15): error CS8598: The suppression operator is not allowed in this context
                //         _ = &(M!);
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "M").WithLocation(7, 15)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void TestLambdaWithError19()
        {
            var source =
@"using System;
using System.Linq.Expressions;

class Program
{
    static void Main(string[] args)
    {
        Ma(string.Empty, ((x, y) => x.ToString())!);
        Mb(string.Empty, ((x, y) => x.ToString())!);
        Mc(string.Empty, ((x, y) => x.ToString())!);
    }
    static void Ma<T>(T t, Expression<Action<T, T, int>> action) { }
    static void Mb<T>(T t, Expression<Action<T, T, int>> action) { }
    static void Mb<T>(T t, Action<T, T, int> action) { }
    static void Mc<T>(T t, Expression<Action<T, T, int>> action) { }
    static void Mc() { }
}
";
            var compilation = CreateCompilationWithMscorlib40AndSystemCore(source);
            var tree = compilation.SyntaxTrees[0];
            var sm = compilation.GetSemanticModel(tree);
            foreach (var lambda in tree.GetRoot().DescendantNodes().OfType<LambdaExpressionSyntax>())
            {
                var reference = lambda.Body.DescendantNodesAndSelf().OfType<IdentifierNameSyntax>().First();
                Assert.Equal("x", reference.ToString());
                var typeInfo = sm.GetTypeInfo(reference);
                Assert.Equal(TypeKind.Class, typeInfo.Type.TypeKind);
                Assert.Equal("String", typeInfo.Type.Name);
                Assert.NotEmpty(typeInfo.Type.GetMembers("Replace"));
            }
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_DelegateComparison()
        {
            var source = @"
class C
{
    static void M()
    {
        System.Func<int> x = null;
        _ = x == (() => 1)!;
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (7,13): error CS0019: Operator '==' cannot be applied to operands of type 'Func<int>' and 'lambda expression'
                //         _ = x == (() => 1)!;
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x == (() => 1)!").WithArguments("==", "System.Func<int>", "lambda expression").WithLocation(7, 13)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_ArgList()
        {
            var source = @"
class C
{
    static void M()
    {
        _ = __arglist!;
        M(__arglist(__arglist()!));
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (6,13): error CS0190: The __arglist construct is valid only within a variable argument method
                //         _ = __arglist!;
                Diagnostic(ErrorCode.ERR_ArgsInvalid, "__arglist").WithLocation(6, 13),
                // (7,21): error CS0226: An __arglist expression may only appear inside of a call or new expression
                //         M(__arglist(__arglist()!));
                Diagnostic(ErrorCode.ERR_IllegalArglist, "__arglist()").WithLocation(7, 21)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void BadInvocationInLambda()
        {
            var src = @"
using System;
using System.Linq.Expressions;

class C
{
    Expression<Action<dynamic>> e = x => new object[](x);
    Expression<Action<dynamic>> e2 = x => new object[](x)!;
}";
            // Suppressed expression cannot be used as a statement
            var comp = CreateCompilationWithMscorlib40AndSystemCore(src);
            comp.VerifyDiagnostics(
                // (7,52): error CS1586: Array creation must have array size or array initializer
                //     Expression<Action<dynamic>> e = x => new object[](x);
                Diagnostic(ErrorCode.ERR_MissingArraySize, "[]").WithLocation(7, 52),
                // (7,42): error CS0149: Method name expected
                //     Expression<Action<dynamic>> e = x => new object[](x);
                Diagnostic(ErrorCode.ERR_MethodNameExpected, "new object[]").WithLocation(7, 42),
                // (8,53): error CS1586: Array creation must have array size or array initializer
                //     Expression<Action<dynamic>> e2 = x => new object[](x)!;
                Diagnostic(ErrorCode.ERR_MissingArraySize, "[]").WithLocation(8, 53),
                // (8,43): error CS0149: Method name expected
                //     Expression<Action<dynamic>> e2 = x => new object[](x)!;
                Diagnostic(ErrorCode.ERR_MethodNameExpected, "new object[]").WithLocation(8, 43),
                // (8,43): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
                //     Expression<Action<dynamic>> e2 = x => new object[](x)!;
                Diagnostic(ErrorCode.ERR_IllegalStatement, "new object[](x)!").WithLocation(8, 43)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_AsStatement()
        {
            var src = @"
class C
{
    void M2(string x)
    {
        x!;
        M2(x)!;
    }
    string M(string x)
    {
        x!;
        M(x)!;
        throw null;
    }
}";
            // Suppressed expression cannot be used as a statement
            var comp = CreateCompilation(src);
            comp.VerifyDiagnostics(
                // (6,9): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
                //         x!;
                Diagnostic(ErrorCode.ERR_IllegalStatement, "x!").WithLocation(6, 9),
                // (7,9): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
                //         M2(x)!;
                Diagnostic(ErrorCode.ERR_IllegalStatement, "M2(x)!").WithLocation(7, 9),
                // (11,9): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
                //         x!;
                Diagnostic(ErrorCode.ERR_IllegalStatement, "x!").WithLocation(11, 9),
                // (12,9): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
                //         M(x)!;
                Diagnostic(ErrorCode.ERR_IllegalStatement, "M(x)!").WithLocation(12, 9)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_VoidInvocation()
        {
            var src = @"
class C
{
    void M()
    {
        _ = M()!;
    }
}";
            var comp = CreateCompilation(src);
            comp.VerifyDiagnostics(
                // (6,9): error CS8209: A value of type 'void' may not be assigned.
                //         _ = M()!;
                Diagnostic(ErrorCode.ERR_VoidAssignment, "_").WithLocation(6, 9)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void CS0023ERR_BadUnaryOp_lambdaExpression()
        {
            var text = @"
class X
{
    static void Main()
    {
        System.Func<int, int> f = (arg => { arg = 2; return arg; } !).ToString();
        
        var x = (delegate { } !).ToString();
    }
}
";
            CreateCompilation(text).VerifyDiagnostics(
                // (6,35): error CS0023: Operator '.' cannot be applied to operand of type 'lambda expression'
                //         System.Func<int, int> f = (arg => { arg = 2; return arg; } !).ToString();
                Diagnostic(ErrorCode.ERR_BadUnaryOp, "(arg => { arg = 2; return arg; } !).ToString").WithArguments(".", "lambda expression").WithLocation(6, 35),
                // (8,17): error CS0023: Operator '.' cannot be applied to operand of type 'anonymous method'
                //         var x = (delegate { } !).ToString();
                Diagnostic(ErrorCode.ERR_BadUnaryOp, "(delegate { } !).ToString").WithArguments(".", "anonymous method").WithLocation(8, 17)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void ConditionalMemberAccess001()
        {
            var text = @"
class Program
{
    static void Main(string[] args)
    {
        var x4 = (()=> { return 1; } !) ?.ToString();
    }
}
";

            CreateCompilationWithMscorlib45(text).VerifyDiagnostics(
                // (6,18): error CS0023: Operator '?' cannot be applied to operand of type 'lambda expression'
                //         var x4 = (()=> { return 1; } !) ?.ToString();
                Diagnostic(ErrorCode.ERR_BadUnaryOp, "(()=> { return 1; } !) ?.ToString()").WithArguments("?", "lambda expression").WithLocation(6, 18),
                // (6,18): error CS0023: Operator '?' cannot be applied to operand of type 'lambda expression'
                //         var x4 = (()=> { return 1; } !) ?.ToString();
                Diagnostic(ErrorCode.ERR_BadUnaryOp, "(()=> { return 1; } !) ?.ToString()").WithArguments("?", "lambda expression").WithLocation(6, 18)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void DynamicCollectionInitializer_Errors()
        {
            string source = @"
using System;

unsafe class C
{
    public dynamic X;
    public static int* ptr = null;

    static void M()
    {
        var c = new C
        {
            X =
            {
                M!,
                ptr!,
                () => {}!,
                default(TypedReference)!,
                M()!,
                __arglist
            }
        };
    }
}
";
            // Should `!` be disallowed on arguments to dynamic?
            // See https://github.com/dotnet/roslyn/issues/32364

            CreateCompilationWithMscorlib40AndSystemCore(source, options: TestOptions.UnsafeReleaseDll).VerifyDiagnostics(
                // (15,17): error CS1976: Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?
                //                 M!,
                Diagnostic(ErrorCode.ERR_BadDynamicMethodArgMemgrp, "M").WithLocation(15, 17),
                // (16,17): error CS1978: Cannot use an expression of type 'int*' as an argument to a dynamically dispatched operation.
                //                 ptr!,
                Diagnostic(ErrorCode.ERR_BadDynamicMethodArg, "ptr").WithArguments("int*").WithLocation(16, 17),
                // (17,17): error CS1977: Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type.
                //                 () => {}!,
                Diagnostic(ErrorCode.ERR_BadDynamicMethodArgLambda, "() => {}").WithLocation(17, 17),
                // (18,17): error CS1978: Cannot use an expression of type 'TypedReference' as an argument to a dynamically dispatched operation.
                //                 default(TypedReference)!,
                Diagnostic(ErrorCode.ERR_BadDynamicMethodArg, "default(TypedReference)").WithArguments("System.TypedReference").WithLocation(18, 17),
                // (19,17): error CS1978: Cannot use an expression of type 'void' as an argument to a dynamically dispatched operation.
                //                 M()!,
                Diagnostic(ErrorCode.ERR_BadDynamicMethodArg, "M()").WithArguments("void").WithLocation(19, 17),
                // (20,17): error CS0190: The __arglist construct is valid only within a variable argument method
                //                 __arglist
                Diagnostic(ErrorCode.ERR_ArgsInvalid, "__arglist").WithLocation(20, 17),
                // (20,17): error CS1978: Cannot use an expression of type 'RuntimeArgumentHandle' as an argument to a dynamically dispatched operation.
                //                 __arglist
                Diagnostic(ErrorCode.ERR_BadDynamicMethodArg, "__arglist").WithArguments("System.RuntimeArgumentHandle").WithLocation(20, 17)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void TestNullCoalesceWithMethodGroup()
        {
            var source = @"
using System;

class Program
{
    static void Main()
    {
        Action a = Main! ?? Main;
        Action a2 = Main ?? Main!;
    }
}
";
            CreateCompilation(source).VerifyDiagnostics(
                // (8,20): error CS0019: Operator '??' cannot be applied to operands of type 'method group' and 'method group'
                //         Action a = Main! ?? Main;
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "Main! ?? Main").WithArguments("??", "method group", "method group").WithLocation(8, 20),
                // (9,21): error CS0019: Operator '??' cannot be applied to operands of type 'method group' and 'method group'
                //         Action a2 = Main ?? Main!;
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "Main ?? Main!").WithArguments("??", "method group", "method group").WithLocation(9, 21)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_IsAsOperatorWithBadSuppressedExpression()
        {
            var source = @"
class C
{
    void M()
    {
        _ = (() => {}!) is null; // 1
        _ = (M!) is null; // 2
        _ = (null, null)! is object; // 3
        _ = null! is object; // 4
        _ = default! is object; // 5

        _ = (() => {}!) as object; // 6
        _ = (M!) as object; // 7
        _ = (null, null)! as object; // 8
        _ = null! as object; // ok
        _ = default! as string; // 10
    }
}
";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (6,13): error CS0837: The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.
                //         _ = (() => {}!) is null; // 1
                Diagnostic(ErrorCode.ERR_LambdaInIsAs, "(() => {}!) is null").WithLocation(6, 13),
                // (7,13): error CS0837: The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.
                //         _ = (M!) is null; // 2
                Diagnostic(ErrorCode.ERR_LambdaInIsAs, "(M!) is null").WithLocation(7, 13),
                // (8,13): error CS0023: Operator 'is' cannot be applied to operand of type '(<null>, <null>)'
                //         _ = (null, null)! is object; // 3
                Diagnostic(ErrorCode.ERR_BadUnaryOp, "(null, null)! is object").WithArguments("is", "(<null>, <null>)").WithLocation(8, 13),
                // (9,13): warning CS0184: The given expression is never of the provided ('object') type
                //         _ = null! is object; // 4
                Diagnostic(ErrorCode.WRN_IsAlwaysFalse, "null! is object").WithArguments("object").WithLocation(9, 13),
                // (10,13): error CS0023: Operator 'is' cannot be applied to operand of type 'default'
                //         _ = default! is object; // 5
                Diagnostic(ErrorCode.ERR_BadUnaryOp, "default! is object").WithArguments("is", "default").WithLocation(10, 13),
                // (12,13): error CS0837: The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.
                //         _ = (() => {}!) as object; // 6
                Diagnostic(ErrorCode.ERR_LambdaInIsAs, "(() => {}!) as object").WithLocation(12, 13),
                // (13,13): error CS0837: The first operand of an 'is' or 'as' operator may not be a lambda expression, anonymous method, or method group.
                //         _ = (M!) as object; // 7
                Diagnostic(ErrorCode.ERR_LambdaInIsAs, "(M!) as object").WithLocation(13, 13),
                // (14,13): error CS8307: The first operand of an 'as' operator may not be a tuple literal without a natural type.
                //         _ = (null, null)! as object; // 8
                Diagnostic(ErrorCode.ERR_TypelessTupleInAs, "(null, null)! as object").WithLocation(14, 13),
                // (16,13): warning CS0458: The result of the expression is always 'null' of type 'string'
                //         _ = default! as string; // 10
                Diagnostic(ErrorCode.WRN_AlwaysNull, "default! as string").WithArguments("string").WithLocation(16, 13)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void ImplicitDelegateCreationWithIncompleteLambda()
        {
            var source =
@"
using System;
class C
{
    public void F()
    {
        Action<int> x = (i => i.)!
    }
}
";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (7,33): error CS1001: Identifier expected
                //         Action<int> x = (i => i.)!
                Diagnostic(ErrorCode.ERR_IdentifierExpected, ")").WithLocation(7, 33),
                // (7,35): error CS1002: ; expected
                //         Action<int> x = (i => i.)!
                Diagnostic(ErrorCode.ERR_SemicolonExpected, "").WithLocation(7, 35),
                // (7,31): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
                //         Action<int> x = (i => i.)!
                Diagnostic(ErrorCode.ERR_IllegalStatement, "i.").WithLocation(7, 31)
                );

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var lambda = tree.GetRoot().DescendantNodes().Where(n => n.IsKind(SyntaxKind.SimpleLambdaExpression)).Single();

            var param = lambda.ChildNodes().Where(n => n.IsKind(SyntaxKind.Parameter)).Single();
            var symbol1 = model.GetDeclaredSymbol(param);
            Assert.Equal("System.Int32 i", symbol1.ToTestDisplayString());

            var id = lambda.DescendantNodes().First(n => n.IsKind(SyntaxKind.IdentifierName));
            var symbol2 = model.GetSymbolInfo(id).Symbol;
            Assert.Equal("System.Int32 i", symbol2.ToTestDisplayString());

            Assert.Same(symbol1, symbol2);
        }

        [Fact, WorkItem(32179, "https://github.com/dotnet/roslyn/issues/32179")]
        public void SuppressNullableWarning_DefaultStruct()
        {
            var source =
@"public struct S
{
    public string field;
}
public class C
{
    public S field;
    void M()
    {
        S s = default; // assigns null to S.field
        _ = s;
        _ = new C(); // assigns null to C.S.field
    }
}";
            // We should probably warn for such scenarios (either in the definition of S, or in the usage of S)
            // Tracked by https://github.com/dotnet/roslyn/issues/32179
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_ThrowNull()
        {
            var source =
@"class C
{
    void M()
    {
        throw null!;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_ThrowExpression()
        {
            var source =
@"class C
{
    void M()
    {
        (throw null)!;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): error CS0201: Only assignment, call, increment, decrement, await, and new object expressions can be used as a statement
                //         (throw null)!;
                Diagnostic(ErrorCode.ERR_IllegalStatement, "(throw null)!").WithLocation(5, 9),
                // (5,10): error CS8115: A throw expression is not allowed in this context.
                //         (throw null)!;
                Diagnostic(ErrorCode.ERR_ThrowMisplaced, "throw").WithLocation(5, 10)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_IsNull()
        {
            var source =
@"class C
{
    bool M(object o)
    {
        return o is null!;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,21): hidden CS8606: Result of the comparison is possibly always false.
                //         return o is null!;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "null!").WithLocation(5, 21)
                );
            CompileAndVerify(comp);
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_MiscNull()
        {
            var source = @"
using System.Linq.Expressions;
class C
{
    void M<T>(object o, int? i)
    {
        _ = null is object; // 1
        _ = null! is object; // 2

        int i2 = null!; // 3
        var i3 = (int)null!; // 4
        T t = null!; // 5
        var t2 = (T)null!; // 6
        _ = null == null!;
        _ = (null!, null) == (null, null!);
        (null)++; // 9
        (null!)++; // 10
        _ = !null; // 11
        _ = !(null!); // 12
        Expression<System.Func<object>> testExpr = () => null! ?? ""hello""; // 13
        _ = o == null;
        _ = o == null!; // 14
        _ = null ?? o;
        _ = null! ?? o;
        _ = i == null;
        _ = i == null!;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): warning CS0184: The given expression is never of the provided ('object') type
                //         _ = null is object; // 1
                Diagnostic(ErrorCode.WRN_IsAlwaysFalse, "null is object").WithArguments("object").WithLocation(7, 13),
                // (8,13): warning CS0184: The given expression is never of the provided ('object') type
                //         _ = null! is object; // 2
                Diagnostic(ErrorCode.WRN_IsAlwaysFalse, "null! is object").WithArguments("object").WithLocation(8, 13),
                // (10,18): error CS0037: Cannot convert null to 'int' because it is a non-nullable value type
                //         int i2 = null!; // 3
                Diagnostic(ErrorCode.ERR_ValueCantBeNull, "null").WithArguments("int").WithLocation(10, 18),
                // (11,18): error CS0037: Cannot convert null to 'int' because it is a non-nullable value type
                //         var i3 = (int)null!; // 4
                Diagnostic(ErrorCode.ERR_ValueCantBeNull, "(int)null!").WithArguments("int").WithLocation(11, 18),
                // (12,15): error CS0403: Cannot convert null to type parameter 'T' because it could be a non-nullable value type. Consider using 'default(T)' instead.
                //         T t = null!; // 5
                Diagnostic(ErrorCode.ERR_TypeVarCantBeNull, "null").WithArguments("T").WithLocation(12, 15),
                // (13,18): error CS0037: Cannot convert null to 'T' because it is a non-nullable value type
                //         var t2 = (T)null!; // 6
                Diagnostic(ErrorCode.ERR_ValueCantBeNull, "(T)null!").WithArguments("T").WithLocation(13, 18),
                // (16,10): error CS1059: The operand of an increment or decrement operator must be a variable, property or indexer
                //         (null)++; // 9
                Diagnostic(ErrorCode.ERR_IncrementLvalueExpected, "null").WithLocation(16, 10),
                // (17,10): error CS8598: The suppression operator is not allowed in this context
                //         (null!)++; // 10
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "null").WithLocation(17, 10),
                // (18,13): error CS8310: Operator '!' cannot be applied to operand '<null>'
                //         _ = !null; // 11
                Diagnostic(ErrorCode.ERR_BadOpOnNullOrDefault, "!null").WithArguments("!", "<null>").WithLocation(18, 13),
                // (19,13): error CS8310: Operator '!' cannot be applied to operand '<null>'
                //         _ = !(null!); // 12
                Diagnostic(ErrorCode.ERR_BadOpOnNullOrDefault, "!(null!)").WithArguments("!", "<null>").WithLocation(19, 13),
                // (20,58): error CS0845: An expression tree lambda may not contain a coalescing operator with a null or default literal left-hand side
                //         Expression<System.Func<object>> testExpr = () => null! ?? "hello"; // 13
                Diagnostic(ErrorCode.ERR_ExpressionTreeContainsBadCoalesce, "null").WithLocation(20, 58),
                // (21,13): hidden CS8606: Result of the comparison is possibly always false.
                //         _ = o == null;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "o == null").WithLocation(21, 13),
                // (22,13): hidden CS8606: Result of the comparison is possibly always false.
                //         _ = o == null!; // 14
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "o == null!").WithLocation(22, 13)
                );
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_MiscDefault()
        {
            var source =
@"class C
{
    void M(dynamic d, int? i)
    {
        d.M(null!, default!, null, default); // 1
        _ = default == default!; // 2
        _ = default! == default!; // 3
        _ = 1 + default!; // 4
        _ = default ?? d; // 5
        _ = default! ?? d; // 6
        _ = i ?? default;
        _ = i ?? default!;
    }
    void M2(object o)
    {
        _ = o == default; // 7
        _ = o == default!; // 8
    }
}";
            // Should `!` be disallowed on arguments to dynamic (line // 1) ?
            // See https://github.com/dotnet/roslyn/issues/32364

            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,20): error CS8311: Cannot use a default literal as an argument to a dynamically dispatched operation.
                //         d.M(null!, default!, null, default); // 1
                Diagnostic(ErrorCode.ERR_BadDynamicMethodArgDefaultLiteral, "default").WithLocation(5, 20),
                // (5,36): error CS8311: Cannot use a default literal as an argument to a dynamically dispatched operation.
                //         d.M(null!, default!, null, default); // 1
                Diagnostic(ErrorCode.ERR_BadDynamicMethodArgDefaultLiteral, "default").WithLocation(5, 36),
                // (6,13): error CS8315: Operator '==' is ambiguous on operands 'default' and 'default'
                //         _ = default == default!; // 2
                Diagnostic(ErrorCode.ERR_AmbigBinaryOpsOnDefault, "default == default!").WithArguments("==").WithLocation(6, 13),
                // (7,13): error CS8315: Operator '==' is ambiguous on operands 'default' and 'default'
                //         _ = default! == default!; // 3
                Diagnostic(ErrorCode.ERR_AmbigBinaryOpsOnDefault, "default! == default!").WithArguments("==").WithLocation(7, 13),
                // (8,13): error CS8310: Operator '+' cannot be applied to operand 'default'
                //         _ = 1 + default!; // 4
                Diagnostic(ErrorCode.ERR_BadOpOnNullOrDefault, "1 + default!").WithArguments("+", "default").WithLocation(8, 13),
                // (9,13): error CS8310: Operator '??' cannot be applied to operand 'default'
                //         _ = default ?? d; // 5
                Diagnostic(ErrorCode.ERR_BadOpOnNullOrDefault, "default ?? d").WithArguments("??", "default").WithLocation(9, 13),
                // (10,13): error CS8310: Operator '??' cannot be applied to operand 'default'
                //         _ = default! ?? d; // 6
                Diagnostic(ErrorCode.ERR_BadOpOnNullOrDefault, "default! ?? d").WithArguments("??", "default").WithLocation(10, 13),
                // (16,13): hidden CS8606: Result of the comparison is possibly always false.
                //         _ = o == default; // 7
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "o == default").WithLocation(16, 13),
                // (17,13): hidden CS8606: Result of the comparison is possibly always false.
                //         _ = o == default!; // 8
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "o == default!").WithLocation(17, 13)
            );
        }

        [Fact]
        public void Test0()
        {
            var source = @"
class C
{
    static void Main()
    {
        string? x = null;
    }
}
";
            var c = CreateCompilation(source, parseOptions: TestOptions.Regular7);
            c.VerifyDiagnostics(
                // (6,15): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         string? x = null;
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(6, 15),
                // (6,17): warning CS0219: The variable 'x' is assigned but its value is never used
                //         string? x = null;
                Diagnostic(ErrorCode.WRN_UnreferencedVarAssg, "x").WithArguments("x").WithLocation(6, 17)
                );

            var c2 = CreateCompilation(source, parseOptions: TestOptions.Regular8);
            c2.VerifyDiagnostics(
                // (6,15): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? x = null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 15),
                // (6,17): warning CS0219: The variable 'x' is assigned but its value is never used
                //         string? x = null;
                Diagnostic(ErrorCode.WRN_UnreferencedVarAssg, "x").WithArguments("x").WithLocation(6, 17)
                );
        }

        [Fact]
        public void SpeakableInference_MethodTypeInference()
        {
            var source =
@"class Program
{
    void M<T>(T t)
    {
        if (t == null) throw null;
        t.ToString();
        var t2 = Copy(t);
        t2.ToString(); // warn
    }
    static T Copy<T>(T t) => throw null;
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2").WithLocation(8, 9)
                );
        }

        [Fact]
        public void SpeakableInference_MethodTypeInference_WithTuple()
        {
            var source =
@"class Program
{
    void M<T>(T t)
    {
        if (t == null) throw null;
        var tuple = (t, t);
        tuple.Item1.ToString();
        tuple.Item2.ToString();

        var tuple2 = Copy(tuple);
        tuple2.Item1.ToString(); // warn
        tuple2.Item2.ToString(); // warn

        var tuple3 = Copy<T, T>(tuple);
        tuple3.Item1.ToString(); // warn
        tuple3.Item2.ToString(); // warn
    }
    static (T, U) Copy<T, U>((T, U) t) => throw null;
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         tuple2.Item1.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "tuple2.Item1").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         tuple2.Item2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "tuple2.Item2").WithLocation(12, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         tuple3.Item1.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "tuple3.Item1").WithLocation(15, 9),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         tuple3.Item2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "tuple3.Item2").WithLocation(16, 9)
                );
        }

        [Fact]
        public void SpeakableInference_MethodTypeInference_WithNull()
        {
            var source =
@"class Program
{
    void M<T>(T t) where T : class?
    {
        if (t == null) throw null;
        t.ToString();
        var t2 = Copy(t, null);
        t2.ToString(); // warn
    }
    static T Copy<T, U>(T t, U t) => throw null;
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,18): error CS0411: The type arguments for method 'Program.Copy<T, U>(T, U)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         var t2 = Copy(t, null);
                Diagnostic(ErrorCode.ERR_CantInferMethTypeArgs, "Copy").WithArguments("Program.Copy<T, U>(T, U)").WithLocation(7, 18),
                // (10,32): error CS0100: The parameter name 't' is a duplicate
                //     static T Copy<T, U>(T t, U t) => throw null;
                Diagnostic(ErrorCode.ERR_DuplicateParamName, "t").WithArguments("t").WithLocation(10, 32)
                );
        }

        [Fact]
        public void SpeakableInference_MethodTypeInference_NullAssigned()
        {
            var source =
@"class Program
{
    void M<T>(T t) where T : class
    {
        t = null;
        var t2 = Copy(t);
        t2 /*T:T?*/ .ToString(); // warn
    }
    static T Copy<T>(T t) => throw null;
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (5,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(5, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         t2 /*T:T?*/ .ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2").WithLocation(7, 9)
                );
        }

        [Fact]
        public void SpeakableInference_MethodTypeInference_NullableValueType()
        {
            var source =
@"class Program
{
    void M(int? t)
    {
        if (t == null) throw null;
        t.Value.ToString();
        var t2 = Copy(t);
        t2.Value.ToString(); // warn
    }
    void M2<T>(T? t) where T : struct
    {
        if (t == null) throw null;
        t.Value.ToString();
        var t2 = Copy(t);
        t2.Value.ToString(); // warn
    }
     static T Copy<T>(T t) => throw null;
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8629: Nullable value type may be null.
                //         t2.Value.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t2.Value").WithLocation(8, 9),
                // (15,9): warning CS8629: Nullable value type may be null.
                //         t2.Value.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t2.Value").WithLocation(15, 9)
                );
        }

        [Fact]
        public void SpeakableInference_ArrayTypeInference()
        {
            var source =
@"class Program
{
    void M<T>(T t)
    {
        if (t == null) throw null;
        t.ToString();
        var t2 = new[] { t };
        t2[0].ToString(); // warn
    }
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t2[0].ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2[0]").WithLocation(8, 9)
                );
        }

        [Fact]
        public void SpeakableInference_ArrayTypeInference_WithTuple()
        {
            var source =
@"class Program
{
    void M<T>(T t)
    {
        if (t == null) throw null;
        var a = new[] { (t, t) };
        a[0].Item1.ToString();
        a[0].Item2.ToString();

        var b = new (T, T)[] { (t, t) };
        b[0].Item1.ToString();
        b[0].Item2.ToString();
    }
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         a[0].Item1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a[0].Item1").WithLocation(7, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         a[0].Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a[0].Item2").WithLocation(8, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].Item1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0].Item1").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0].Item2").WithLocation(12, 9)
                );
        }

        [Fact]
        public void SpeakableInference_ArrayTypeInference_WithNull()
        {
            var source =
@"class Program
{
    void M<T>(T t) where T : class?
    {
        if (t == null) throw null;
        t.ToString();
        var t2 = new[] { t, null };
        t2[0].ToString(); // warn
    }
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         var t2 = new[] { t, null };
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(7, 29),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t2[0].ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2[0]").WithLocation(8, 9)
                );
        }

        [Fact, WorkItem(30941, "https://github.com/dotnet/roslyn/issues/30941")]
        public void Verify30941()
        {
            var source = @"
class Outer : Base
{
    void M1(Base? x1)
    {
        Outer y = x1;
    }
}
class Base { }
";
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,19): error CS0266: Cannot implicitly convert type 'Base' to 'Outer'. An explicit conversion exists (are you missing a cast?)
                //         Outer y = x1;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x1").WithArguments("Base", "Outer").WithLocation(6, 19),
                // (6,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         Outer y = x1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(6, 19)
                );
        }

        [Fact, WorkItem(31958, "https://github.com/dotnet/roslyn/issues/31958")]
        public void Verify31958()
        {
            var source = @"
class C
{
    string? M(string s)
    {
        var d = (D)M;
        d(null).ToString();

        return null;
    }

    delegate string D(string? s);
}
";
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,17): warning CS8621: Nullability of reference types in return type of 'string? C.M(string s)' doesn't match the target delegate 'C.D'.
                //         var d = (D)M;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "(D)M").WithArguments("string? C.M(string s)", "C.D").WithLocation(6, 17),
                // (6,17): warning CS8622: Nullability of reference types in type of parameter 's' of 'string? C.M(string s)' doesn't match the target delegate 'C.D'.
                //         var d = (D)M;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(D)M").WithArguments("s", "string? C.M(string s)", "C.D").WithLocation(6, 17)
                );
        }

        [Fact, WorkItem(28377, "https://github.com/dotnet/roslyn/issues/28377")]
        public void Verify28377()
        {
            var source = @"
class C
{
    void M()
    {
        object x;
        x! = null;
    }
}
";
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): error CS8598: The suppression operator is not allowed in this context
                //         x! = null;
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "x").WithLocation(7, 9),
                // (7,9): error CS0165: Use of unassigned local variable 'x'
                //         x! = null;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x").WithArguments("x").WithLocation(7, 9)
                );
        }

        [Fact, WorkItem(31295, "https://github.com/dotnet/roslyn/issues/31295")]
        public void Verify31295()
        {
            var source = @"
class C
{
    void M()
    {
        for (var x = 0; ; x!++) { }
    }
}";
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,27): error CS8598: The suppression operator is not allowed in this context
                //         for (var x = 0; ; x!++) { }
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "x").WithLocation(6, 27)
                );
        }

        [Fact, WorkItem(26654, "https://github.com/dotnet/roslyn/issues/26654")]
        public void Verify26654()
        {
            var source = @"
public class C
{
    public void M(out string? x) => throw null;
    public void M2()
    {
        string y;
        M(out y!);
    }
}";
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact, WorkItem(30955, "https://github.com/dotnet/roslyn/issues/30955")]
        public void ArrayTypeInference_Verify30955()
        {
            var source = @"
class Outer
{
    void M0(object x0, object? y0)
    {
        var a = new[] { x0, 1 };
        a[0] = y0;
        var b = new[] { x0, x0 };
        b[0] = y0;
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8601: Possible null reference assignment.
                //         a[0] = y0;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y0").WithLocation(7, 16),
                // (9,16): warning CS8601: Possible null reference assignment.
                //         b[0] = y0;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y0").WithLocation(9, 16)
                );
        }

        [Fact, WorkItem(30598, "https://github.com/dotnet/roslyn/issues/30598")]
        public void Verify30598()
        {
            var source = @"
class Program
{
    static object F(object[]? x)
    {
        return x[          // warning: possibly null
            x.Length - 1]; // no warning
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8602: Possible dereference of a null reference.
                //         return x[          // warning: possibly null
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 16)
                );
        }

        [Fact, WorkItem(30925, "https://github.com/dotnet/roslyn/issues/30925")]
        public void Verify30925()
        {
            var source = @"
class Outer
{
    void M1<T>(T x1, object? y1) where T : class?
    {
        x1 = (T)y1;
    }

    void M2<T>(T x2, object? y2) where T : class?
    {
        x2 = y2;
    }

    void M3(string x3, object? y3)
    {
        x3 = (string)y3;
    }

    void M4(string x4, object? y4)
    {
        x4 = y4;
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x1 = (T)y1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)y1").WithLocation(6, 14),
                // (11,14): error CS0266: Cannot implicitly convert type 'object' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         x2 = y2;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "y2").WithArguments("object", "T").WithLocation(11, 14),
                // (11,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x2 = y2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2").WithLocation(11, 14),
                // (16,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x3 = (string)y3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)y3").WithLocation(16, 14),
                // (21,14): error CS0266: Cannot implicitly convert type 'object' to 'string'. An explicit conversion exists (are you missing a cast?)
                //         x4 = y4;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "y4").WithArguments("object", "string").WithLocation(21, 14),
                // (21,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x4 = y4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y4").WithLocation(21, 14)
                );
        }

        [Fact]
        public void SpeakableInference_ArrayTypeInference_NullableValueType()
        {
            var source =
@"class Program
{
    void M(int? t)
    {
        if (t == null) throw null;
        t.Value.ToString();
        var t2 = new[] { t };
        t2[0].Value.ToString(); // warn
    }
    void M2<T>(T? t) where T : struct
    {
        if (t == null) throw null;
        t.Value.ToString();
        var t2 = new[] { t };
        t2[0].Value.ToString(); // warn
    }
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8629: Nullable value type may be null.
                //         t2[0].Value.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t2[0].Value").WithLocation(8, 9),
                // (15,9): warning CS8629: Nullable value type may be null.
                //         t2[0].Value.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t2[0].Value").WithLocation(15, 9)
                );
        }

        [Fact]
        public void SpeakableInference_ArrayTypeInference_ConversionWithNullableOutput_WithNestedMismatch()
        {
            var source =
@"class A<T>
{
    public static implicit operator C<T>?(A<T> a) => throw null;
}
class B<T> : A<T>
{
}
class C<T>
{
    void M(B<string> x, C<string?> y)
    {
        var a = new[] { x, y };
        a[0].ToString();

        var b = new[] { y, x };
        b[0].ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/30480: Should report WRN_NoBestNullabilityArrayElements. Problem in BestTypeInferrer.Better
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,25): warning CS8619: Nullability of reference types in value of type 'C<string>' doesn't match target type 'C<string?>'.
                //         var a = new[] { x, y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<string>", "C<string?>").WithLocation(12, 25),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         a[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a[0]").WithLocation(13, 9),
                // (15,28): warning CS8619: Nullability of reference types in value of type 'C<string>' doesn't match target type 'C<string?>'.
                //         var b = new[] { y, x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<string>", "C<string?>").WithLocation(15, 28),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0]").WithLocation(16, 9)
                );
        }

        [Fact]
        public void SpeakableInference_LambdaReturnTypeInference()
        {
            var source =
@"class Program
{
    void M<T>(T t)
    {
        var x1 = F(() =>
        {
            if (t == null) throw null;
            bool b = true;
            if (b) return t;
            return t;
        });
        x1.ToString();

        var x2 = F<T>(() =>
        {
            if (t == null) throw null;
            bool b = true;
            if (b) return t;
            return t;
        });
        x2.ToString();
    }
    T F<T>(System.Func<T> f) => throw null;
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         x1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(12, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         x2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(21, 9)
                );
        }

        [Fact]
        public void SpeakableInference_LambdaReturnTypeInference2()
        {
            var source =
@"class Program
{
    void M<T>(T t, T t2)
    {
        var x1 = F(() =>
        {
            if (t == null) throw null;
            bool b = true;
            if (b) return t;
            return t2;
        });
        x1.ToString();

        var x2 = F<T>(() =>
        {
            if (t == null) throw null;
            bool b = true;
            if (b) return t;
            return t2;
        });
        x2.ToString();
    }
    T F<T>(System.Func<T> f) => throw null;
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         x1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(12, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         x2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(21, 9)
                );
        }

        [Fact]
        public void SpeakableInference_LambdaReturnTypeInference_WithSingleReturn()
        {
            var source =
@"class Program
{
    void M<T>()
    {
        var x1 = Copy(() => """");
        x1.ToString();
    }
    void M2<T>(T t)
    {
        if (t == null) throw null;
        var x1 = Copy(() => t);
        x1.ToString(); // 1
    }
    T Copy<T>(System.Func<T> f) => throw null;
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         x1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(12, 9)
                );
        }

        [Fact]
        public void SpeakableInference_LambdaReturnTypeInference_WithTuple()
        {
            var source =
@"class Program
{
    void M<T>(T t)
    {
        var x1 = Copy(() =>
        {
            if (t == null) throw null;
            bool b = true;
            if (b) return (t, t);
            return (t, t);
        });
        x1.Item1.ToString();
        x1.Item2.ToString();
    }
    T Copy<T>(System.Func<T> f) => throw null;
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         x1.Item1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1.Item1").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         x1.Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1.Item2").WithLocation(13, 9)
                );
        }

        [Fact]
        public void SpeakableInference_LambdaReturnTypeInference_ConversionWithNullableOutput()
        {
            var source =
@"class A
{
    public static implicit operator C?(A a) => new C();
}
class B : A
{
}
class C
{
    void M(B x, C y)
    {
        var x1 = F(() =>
        {
            bool b = true;
            if (b) return x;
            return y;
        });
        x1.ToString();

        var x2 = F(() =>
        {
            bool b = true;
            if (b) return y;
            return x;
        });
        x2.ToString();
    }
    T F<T>(System.Func<T> f) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         x1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(18, 9),
                // (26,9): warning CS8602: Possible dereference of a null reference.
                //         x2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(26, 9)
                );
        }

        [Fact]
        public void SpeakableInference_LambdaReturnTypeInference_ConversionWithNullableOutput2()
        {
            var source =
@"class A<T>
{
    public static implicit operator C<T>?(A<T> a) => throw null;
}
class B<T> : A<T>
{
}
class C<T>
{
    void M(B<string?> x, C<string?> y)
    {
        var x1 = F(() =>
        {
            bool b = true;
            if (b) return x;
            return y;
        });
        x1.ToString();

        var x2 = F(() =>
        {
            bool b = true;
            if (b) return y;
            return x;
        });
        x2.ToString();
    }
    U F<U>(System.Func<U> f) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         x1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(18, 9),
                // (26,9): warning CS8602: Possible dereference of a null reference.
                //         x2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(26, 9)
                );
        }

        [Fact]
        public void SpeakableInference_LambdaReturnTypeInference_ConversionWithNullableOutput_WithNestedMismatch()
        {
            var source =
@"class A<T>
{
    public static implicit operator C<T>?(A<T> a) => throw null;
}
class B<T> : A<T>
{
}
class C<T>
{
    void M(B<string> x, C<string?> y)
    {
        var x1 = F(() =>
        {
            bool b = true;
            if (b) return x;
            return y;
        });
        x1.ToString();

        var x2 = F(() =>
        {
            bool b = true;
            if (b) return y;
            return x;
        });
        x2.ToString();
    }
    U F<U>(System.Func<U> f) => throw null;
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,27): warning CS8619: Nullability of reference types in value of type 'C<string>' doesn't match target type 'C<string?>'.
                //             if (b) return x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<string>", "C<string?>").WithLocation(15, 27),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         x1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(18, 9),
                // (24,20): warning CS8619: Nullability of reference types in value of type 'C<string>' doesn't match target type 'C<string?>'.
                //             return x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<string>", "C<string?>").WithLocation(24, 20),
                // (26,9): warning CS8602: Possible dereference of a null reference.
                //         x2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(26, 9)
                );
        }

        [Fact]
        public void SpeakableInference_LambdaReturnTypeInference_ConversionWithNullableInput()
        {
            var source =
@"class A
{
    public static implicit operator C(A? a) => null; // warn
}
class B : A
{
}
class C
{
    void M(B? x, C y)
    {
        var x1 = F(() =>
        {
            bool b = true;
            if (b) return x;
            return y;
        });
        x1.ToString();

        var x2 = F(() =>
        {
            bool b = true;
            if (b) return y;
            return x;
        });
        x2.ToString();
    }
    T F<T>(System.Func<T> f) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,48): warning CS8603: Possible null reference return.
                //     public static implicit operator C(A? a) => null; // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(3, 48)
                );
        }

        [Fact]
        public void SpeakableInference_LambdaReturnTypeInference_WithNullabilityMismatch()
        {
            var source = @"
class C<T>
{
    void M(C<object>? x, C<object?> y)
    {
        var x1 = F(() =>
        {
            bool b = true;
            if (b) return x;
            return y;
        });
        _ = x1 /*T:C<object!>?*/;
        x1.ToString();

        var x2 = F(() =>
        {
            bool b = true;
            if (b) return y;
            return x;
        });
        _ = x2 /*T:C<object!>?*/;
        x2.ToString();
    }
    U F<U>(System.Func<U> f) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (10,20): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //             return y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(10, 20),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         x1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(13, 9),
                // (18,27): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //             if (b) return y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(18, 27),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         x2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(22, 9)
                );
        }

        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/32006")]
        [WorkItem(32006, "https://github.com/dotnet/roslyn/issues/32006")]
        public void SpeakableInference_LambdaReturnTypeInference_NonNullableTypelessOuptut()
        {
            // See https://github.com/dotnet/roslyn/issues/32006
            // need to relax assertion in GetImplicitTupleLiteralConversion
            var source =
@"
class C
{
    void M(C? c)
    {
        var x1 = F(() =>
        {
            bool b = true;
            if (b) return (c, c);
            return (null, null);
        });
        x1.ToString();
        x1.Item1.ToString();
    }
    T F<T>(System.Func<T> f) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         x1.Item1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1.Item1").WithLocation(13, 9)
                );
        }

        [Fact]
        public void SpeakableInference_VarInference()
        {
            var source =
@"class Program
{
    void M<T>(T t)
    {
        if (t == null) throw null;
        var t2 = t;
        t2.ToString();
    }
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            // Once we have a public API, we should check that the declaration type of `t2` is `T` https://github.com/dotnet/roslyn/issues/26198
        }

        [Fact]
        public void Directive_Qualifiers()
        {
            var source =
@"#nullable
#nullable enable
#nullable disable
#nullable restore
#nullable safeonly
#nullable yes
";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll);
            comp.VerifyDiagnostics(
                // (1,10): error CS8637: Expected 'enable', 'safeonly', 'disable', or 'restore'
                // #nullable
                Diagnostic(ErrorCode.ERR_NullableDirectiveQualifierExpected, "").WithLocation(1, 10),
                // (6,11): error CS8637: Expected 'enable', 'safeonly', 'disable', or 'restore'
                // #nullable yes
                Diagnostic(ErrorCode.ERR_NullableDirectiveQualifierExpected, "yes").WithLocation(6, 11)
                );
            comp.VerifyTypes();
        }

        [Fact]
        public void Directive_NullableDefault()
        {
            var source =
@"#pragma warning disable 0649
class A<T, U> { }
class B
{
    static A<object, string?> F1;
    static void G1()
    {
        object o1;
        o1 = F1/*T:A<object, string?>*/;
        o1 = F2/*T:A<object, string?>*/;
        o1 = F3/*T:A<object!, string?>!*/;
    }
#nullable disable
    static A<object, string?> F2;
    static void G2()
    {
        object o2;
        o2 = F1/*T:A<object, string?>*/;
        o2 = F2/*T:A<object, string?>*/;
        o2 = F3/*T:A<object!, string?>!*/;
    }
#nullable enable
    static A<object, string?> F3;
    static void G3()
    {
        object o3;
        o3 = F1/*T:A<object, string?>*/;
        o3 = F2/*T:A<object, string?>*/;
        o3 = F3/*T:A<object!, string?>!*/;
    }
}";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll);
            comp.VerifyDiagnostics(
                // (5,28): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static A<object, string?> F1;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 28),
                // (14,28): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static A<object, string?> F2;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(14, 28));
            comp.VerifyTypes();
        }

        [Fact]
        public void Directive_NullableFalse()
        {
            var source =
@"#pragma warning disable 0649
class A<T, U> { }
class B
{
    static A<object, string?> F1;
    static void G1()
    {
        object o1;
        o1 = F1/*T:A<object, string?>*/;
        o1 = F2/*T:A<object, string?>*/;
        o1 = F3/*T:A<object!, string?>!*/;
    }
#nullable disable
    static A<object, string?> F2;
    static void G2()
    {
        object o2;
        o2 = F1/*T:A<object, string?>*/;
        o2 = F2/*T:A<object, string?>*/;
        o2 = F3/*T:A<object!, string?>!*/;
    }
#nullable enable
    static A<object, string?> F3;
    static void G3()
    {
        object o3;
        o3 = F1/*T:A<object, string?>*/;
        o3 = F2/*T:A<object, string?>*/;
        o3 = F3/*T:A<object!, string?>!*/;
    }
}";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll.WithNullableContextOptions(NullableContextOptions.Disable));
            comp.VerifyDiagnostics(
                // (5,28): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static A<object, string?> F1;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 28),
                // (14,28): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static A<object, string?> F2;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(14, 28));
            comp.VerifyTypes();
        }

        [Fact]
        public void Directive_NullableTrue()
        {
            var source =
@"#pragma warning disable 0649
class A<T, U> { }
class B
{
    static A<object, string?> F1;
    static void G1()
    {
        object o1;
        o1 = F1/*T:A<object!, string?>!*/;
        o1 = F2/*T:A<object, string?>*/;
        o1 = F3/*T:A<object!, string?>!*/;
    }
#nullable disable
    static A<object, string?> F2;
    static void G2()
    {
        object o2;
        o2 = F1/*T:A<object!, string?>!*/;
        o2 = F2/*T:A<object, string?>*/;
        o2 = F3/*T:A<object!, string?>!*/;
    }
#nullable enable
    static A<object, string?> F3;
    static void G3()
    {
        object o3;
        o3 = F1/*T:A<object!, string?>!*/;
        o3 = F2/*T:A<object, string?>*/;
        o3 = F3/*T:A<object!, string?>!*/;
    }
}";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll.WithNullableContextOptions(NullableContextOptions.Enable));
            comp.VerifyDiagnostics(
                // (14,28): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static A<object, string?> F2;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(14, 28));
            comp.VerifyTypes();
        }

        [Fact]
        public void Directive_PartialClasses()
        {
            var source0 =
@"class Base<T> { }
class Program
{
#nullable enable
    static void F(Base<object?> b)
    {
    }
    static void Main()
    {
        F(new C1());
        F(new C2());
        F(new C3());
        F(new C4());
        F(new C5());
        F(new C6());
        F(new C7());
        F(new C8());
        F(new C9());
    }
}";
            var source1 =
@"#pragma warning disable 8632
partial class C1 : Base<object> { }
partial class C2 { }
partial class C3 : Base<object> { }
#nullable disable
partial class C4 { }
partial class C5 : Base<object> { }
partial class C6 { }
#nullable enable
partial class C7 : Base<object> { }
partial class C8 { }
partial class C9 : Base<object> { }
";
            var source2 =
@"#pragma warning disable 8632
partial class C1 { }
partial class C4 : Base<object> { }
partial class C7 { }
#nullable disable
partial class C2 : Base<object> { }
partial class C5 { }
partial class C8 : Base<object> { }
#nullable enable
partial class C3 { }
partial class C6 : Base<object> { }
partial class C9 { }
";

            // -nullable (default):
            var comp = CreateCompilation(new[] { source0, source1, source2 }, options: TestOptions.DebugDll);
            comp.VerifyDiagnostics(
                // (15,11): warning CS8620: Nullability of reference types in argument of type 'C6' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C6());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C6()").WithArguments("C6", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(15, 11),
                // (16,11): warning CS8620: Nullability of reference types in argument of type 'C7' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C7());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C7()").WithArguments("C7", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(16, 11),
                // (18,11): warning CS8620: Nullability of reference types in argument of type 'C9' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C9());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C9()").WithArguments("C9", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(18, 11));

            // -nullable-:
            comp = CreateCompilation(new[] { source0, source1, source2 }, options: TestOptions.DebugDll.WithNullableContextOptions(NullableContextOptions.Disable));
            comp.VerifyDiagnostics(
                // (15,11): warning CS8620: Nullability of reference types in argument of type 'C6' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C6());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C6()").WithArguments("C6", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(15, 11),
                // (16,11): warning CS8620: Nullability of reference types in argument of type 'C7' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C7());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C7()").WithArguments("C7", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(16, 11),
                // (18,11): warning CS8620: Nullability of reference types in argument of type 'C9' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C9());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C9()").WithArguments("C9", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(18, 11));

            // -nullable+:
            comp = CreateCompilation(new[] { source0, source1, source2 }, options: TestOptions.DebugDll.WithNullableContextOptions(NullableContextOptions.Enable));
            comp.VerifyDiagnostics(
                // (10,11): warning CS8620: Nullability of reference types in argument of type 'C1' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C1());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C1()").WithArguments("C1", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(10, 11),
                // (12,11): warning CS8620: Nullability of reference types in argument of type 'C3' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C3());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C3()").WithArguments("C3", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(12, 11),
                // (13,11): warning CS8620: Nullability of reference types in argument of type 'C4' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C4());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C4()").WithArguments("C4", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(13, 11),
                // (15,11): warning CS8620: Nullability of reference types in argument of type 'C6' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C6());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C6()").WithArguments("C6", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(15, 11),
                // (16,11): warning CS8620: Nullability of reference types in argument of type 'C7' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C7());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C7()").WithArguments("C7", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(16, 11),
                // (18,11): warning CS8620: Nullability of reference types in argument of type 'C9' doesn't match target type 'Base<object?>' for parameter 'b' in 'void Program.F(Base<object?> b)'.
                //         F(new C9());
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new C9()").WithArguments("C9", "Base<object?>", "b", "void Program.F(Base<object?> b)").WithLocation(18, 11));
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void Directive_EnableAndDisable_01()
        {
            var source =
@"#nullable enable
class Program
{
    static void F(object x)
    {
        object? y = null;
        F(y); // warning
    }
#nullable disable
    static void G()
    {
        F(null);
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (7,11): warning CS8604: Possible null reference argument for parameter 'x' in 'void Program.F(object x)'.
                //         F(y); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void Program.F(object x)").WithLocation(7, 11));
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void Directive_EnableAndDisable_02()
        {
            var source =
@"class Program
{
#nullable disable
    static void G()
    {
        F(null);
    }
#nullable enable
    static void F(object x)
    {
        object? y = null;
        F(y); // warning
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (12,11): warning CS8604: Possible null reference argument for parameter 'x' in 'void Program.F(object x)'.
                //         F(y); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void Program.F(object x)").WithLocation(12, 11));
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void Directive_EnableAndDisable_03()
        {
            var source =
@"class Program
{
    static void F(object x)
    {
        object? y = null;
        F(y); // warning
    }
#nullable disable
    static void G()
    {
        F(null);
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,11): warning CS8604: Possible null reference argument for parameter 'x' in 'void Program.F(object x)'.
                //         F(y); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void Program.F(object x)").WithLocation(6, 11));
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void Directive_EnableAndDisable_04()
        {
            var source =
@"class Program
{
    static void G()
    {
        F(null);
    }
#nullable enable
    static void F(object x)
    {
        object? y = null;
        F(y); // warning
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesFalse());
            comp.VerifyDiagnostics(
                // (11,11): warning CS8604: Possible null reference argument for parameter 'x' in 'void Program.F(object x)'.
                //         F(y); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void Program.F(object x)").WithLocation(11, 11));
        }

        [Fact]
        public void Directive_GloballyEnabled_GeneratedCode_DisabledByDefault()
        {
            var source =
@"
// <autogenerated />
class Program
{
    static void F(object x)
    {
        x = null; // no warning, generated file
    }
}";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll.WithNullableContextOptions(NullableContextOptions.Enable));
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Directive_GloballyEnabled_GeneratedCode_Enabled()
        {
            var source =
@"
// <autogenerated />
#nullable enable
class Program
{
    static void F(object x)
    {
        x = null; // warning
    }
}";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll.WithNullableContextOptions(NullableContextOptions.Enable));
            comp.VerifyDiagnostics(
                 // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         x = null; // warning
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(8, 13)
                );
        }

        [Fact]
        public void Directive_GloballyEnabled_GeneratedCode_RestoreToDisabled()
        {
            var source =
@"
// <autogenerated />
#nullable enable
partial class Program
{
#nullable restore
    static void F(object x)
    {
        x = null; // no warning, restored to disabled
    }
}";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll.WithNullableContextOptions(NullableContextOptions.Enable));
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Directive_GloballyEnabled_GeneratedCode_WarningsAreDisabledByDefault()
        {
            var source =
@"
// <autogenerated />
partial class Program
{
    static void G(object x)
    {
        x = null; // no warning
        F = null; // no warning
    
#pragma warning enable nullable
        x = null; // no warning - declared out of nullable context
        F = null; // warning - declared in a nullable context
    }

#nullable enable
    static object F = new object();
}";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll.WithNullableContextOptions(NullableContextOptions.Enable));
            comp.VerifyDiagnostics(
                 // (12,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                 //         F = null; // warning - declared in a nullable context
                 Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(12, 13)
                );
        }

        [Fact]
        public void Directive_GloballyEnabled_GeneratedCode_PartialClasses()
        {
            var source1 =
@"
// <autogenerated />
partial class Program
{
    static void G(object x)
    {
        x = null; // no warning
        F = null; // no warning
    }
}";

            var source2 =
@"
partial class Program
{
    static object F = new object();

    static void H()
    {
        F = null; // warning
    }
}";
            var comp = CreateCompilation(new[] { source1, source2 }, options: TestOptions.DebugDll.WithNullableContextOptions(NullableContextOptions.Enable));
            comp.VerifyDiagnostics(
                // (8,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F = null; // warning
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(8, 13)
                );
        }

        [Fact]
        public void Directive_GloballyEnabled_GeneratedCode_PartialClasses2()
        {
            var source1 =
@"
// <autogenerated />
partial class Program
{
#pragma warning enable nullable
    static void G(object x)
    {
        x = null; // no warning
        F = null; // warning
    }
}";

            var source2 =
@"
partial class Program
{
    static object F = new object();

    static void H()
    {
        F = null; // warning
    }
}";
            var comp = CreateCompilation(new[] { source1, source2 }, options: TestOptions.DebugDll.WithNullableContextOptions(NullableContextOptions.Enable));
            comp.VerifyDiagnostics(
                // (8,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F = null; // warning
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(8, 13),
                // (9,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F = null; // warning
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(9, 13)
                );
        }

        [WorkItem(30862, "https://github.com/dotnet/roslyn/issues/30862")]
        [Fact]
        public void DirectiveDisableWarningEnable()
        {
            var source =
@"#nullable enable
class Program
{
    static void F(object x)
    {
    }
#nullable disable
    static void F1(object? y, object? z)
    {
        F(y);
#pragma warning restore 8604
        F(z); // 1
    }
    static void F2(object? w)
    {
        F(w); // 2
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (8,26): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static void F1(object? y, object? z)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 26),
                // (8,37): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static void F1(object? y, object? z)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 37),
                // (14,26): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static void F2(object? w)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(14, 26));
        }

        [Fact, WorkItem(31740, "https://github.com/dotnet/roslyn/issues/31740")]
        public void Attribute_ArrayWithDifferentNullability()
        {
            var source =
@"
public class MyAttribute : System.Attribute
{
    public MyAttribute(string[] x) { }
}
#nullable enable
[My(new string[] { ""hello"" })]
class C { }
";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll);
            comp.VerifyDiagnostics();
        }

        [Fact, WorkItem(31740, "https://github.com/dotnet/roslyn/issues/31740")]
        public void Attribute_ArrayWithDifferentNullability2()
        {
            var source =
@"
public class MyAttribute : System.Attribute
{
    public MyAttribute(string[] x) { }
}
#nullable enable
[My(new string[] { null })]
class C { }
";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll);
            comp.VerifyDiagnostics();
            // Expecting a warning. Issue tracked by https://github.com/dotnet/roslyn/issues/23697
        }

        [Fact, WorkItem(31740, "https://github.com/dotnet/roslyn/issues/31740")]
        public void Attribute_ArrayWithDifferentNullability_DynamicAndTupleNames()
        {
            var source = @"
public class MyAttribute : System.Attribute
{
    public MyAttribute((string alice, string)[] x, dynamic[] y, object[] z) { }
}
#nullable enable
[My(new (string, string bob)[] { }, new object[] { }, new dynamic[] { })]
class C { }
";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll);
            comp.VerifyDiagnostics(
                // (7,2): error CS0181: Attribute constructor parameter 'x' has type '(string alice, string)[]', which is not a valid attribute parameter type
                // [My(new (string, string bob)[] { }, new object[] { }, new dynamic[] { })]
                Diagnostic(ErrorCode.ERR_BadAttributeParamType, "My").WithArguments("x", "(string alice, string)[]").WithLocation(7, 2),
                // (7,2): error CS0181: Attribute constructor parameter 'y' has type 'dynamic[]', which is not a valid attribute parameter type
                // [My(new (string, string bob)[] { }, new object[] { }, new dynamic[] { })]
                Diagnostic(ErrorCode.ERR_BadAttributeParamType, "My").WithArguments("y", "dynamic[]").WithLocation(7, 2)
                );
        }

        [Fact, WorkItem(31740, "https://github.com/dotnet/roslyn/issues/31740")]
        public void Attribute_ArrayWithDifferentNullability_Dynamic()
        {
            var source =
@"
public class MyAttribute : System.Attribute
{
    public MyAttribute(dynamic[] y) { }
}
#nullable enable
[My(new object[] { })]
class C { }
";
            var comp = CreateCompilation(source, options: TestOptions.DebugDll);
            comp.VerifyDiagnostics(
                // (7,2): error CS0181: Attribute constructor parameter 'y' has type 'dynamic[]', which is not a valid attribute parameter type
                // [My(new object[] { })]
                Diagnostic(ErrorCode.ERR_BadAttributeParamType, "My").WithArguments("y", "dynamic[]").WithLocation(7, 2)
                );
        }

        [Fact]
        public void NullableAndConditionalOperators()
        {
            var source =
@"class Program
{
    static void F1(object x)
    {
        _ = x is string? 1 : 2;
        _ = x is string? ? 1 : 2;  // error 1: is a nullable reference type
        _ = x is string ? ? 1 : 2; // error 2: is a nullable reference type
        _ = x as string?? x;
        _ = x as string ? ?? x;    // error 3: as a nullable reference type
    }
    static void F2(object y)
    {
        _ = y is object[]? 1 : 2;
        _ = y is object[]? ? 1 : 2;   // error 4
        _ = y is object[] ? ? 1 : 2;  // error 5
        _ = y as object[]?? y;
        _ = y as object[] ? ?? y;     // error 6
    }
    static void F3<T>(object z)
    {
        _ = z is T[][]? 1 : 2;
        _ = z is T[]?[] ? 1 : 2;
        _ = z is T[] ? [] ? 1 : 2;
        _ = z as T[][]?? z;
        _ = z as T[] ? [] ?? z;
    }
}";

            var comp = CreateCompilation(source, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics(
                // (6,18): error CS8650: It is not legal to use nullable reference type 'string?' in an is-type expression; use the underlying type 'string' instead.
                //         _ = x is string? ? 1 : 2;  // error 1: is a nullable reference type
                Diagnostic(ErrorCode.ERR_IsNullableType, "string?").WithArguments("string").WithLocation(6, 18),
                // (6,24): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = x is string? ? 1 : 2;  // error 1: is a nullable reference type
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(6, 24),
                // (7,18): error CS8650: It is not legal to use nullable reference type 'string?' in an is-type expression; use the underlying type 'string' instead.
                //         _ = x is string ? ? 1 : 2; // error 2: is a nullable reference type
                Diagnostic(ErrorCode.ERR_IsNullableType, "string ?").WithArguments("string").WithLocation(7, 18),
                // (7,25): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = x is string ? ? 1 : 2; // error 2: is a nullable reference type
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(7, 25),
                // (9,18): error CS8651: It is not legal to use nullable reference type 'string?' in an as expression; use the underlying type 'string' instead.
                //         _ = x as string ? ?? x;    // error 3: as a nullable reference type
                Diagnostic(ErrorCode.ERR_AsNullableType, "string ?").WithArguments("string").WithLocation(9, 18),
                // (9,25): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = x as string ? ?? x;    // error 3: as a nullable reference type
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(9, 25),
                // (14,18): error CS8650: It is not legal to use nullable reference type 'object[]?' in an is-type expression; use the underlying type 'object[]' instead.
                //         _ = y is object[]? ? 1 : 2;   // error 4
                Diagnostic(ErrorCode.ERR_IsNullableType, "object[]?").WithArguments("object[]").WithLocation(14, 18),
                // (14,26): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = y is object[]? ? 1 : 2;   // error 4
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(14, 26),
                // (15,18): error CS8650: It is not legal to use nullable reference type 'object[]?' in an is-type expression; use the underlying type 'object[]' instead.
                //         _ = y is object[] ? ? 1 : 2;  // error 5
                Diagnostic(ErrorCode.ERR_IsNullableType, "object[] ?").WithArguments("object[]").WithLocation(15, 18),
                // (15,27): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = y is object[] ? ? 1 : 2;  // error 5
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(15, 27),
                // (17,18): error CS8651: It is not legal to use nullable reference type 'object[]?' in an as expression; use the underlying type 'object[]' instead.
                //         _ = y as object[] ? ?? y;     // error 6
                Diagnostic(ErrorCode.ERR_AsNullableType, "object[] ?").WithArguments("object[]").WithLocation(17, 18),
                // (17,27): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = y as object[] ? ?? y;     // error 6
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(17, 27),
                // (22,21): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = z is T[]?[] ? 1 : 2;
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(22, 21),
                // (23,22): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = z is T[] ? [] ? 1 : 2;
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(23, 22),
                // (25,22): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = z as T[] ? [] ?? z;
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(25, 22)
                );

            comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,18): error CS8650: It is not legal to use nullable reference type 'string?' in an is-type expression; use the underlying type 'string' instead.
                //         _ = x is string? ? 1 : 2;  // error 1: is a nullable reference type
                Diagnostic(ErrorCode.ERR_IsNullableType, "string?").WithArguments("string").WithLocation(6, 18),
                // (7,18): error CS8650: It is not legal to use nullable reference type 'string?' in an is-type expression; use the underlying type 'string' instead.
                //         _ = x is string ? ? 1 : 2; // error 2: is a nullable reference type
                Diagnostic(ErrorCode.ERR_IsNullableType, "string ?").WithArguments("string").WithLocation(7, 18),
                // (9,18): error CS8651: It is not legal to use nullable reference type 'string?' in an as expression; use the underlying type 'string' instead.
                //         _ = x as string ? ?? x;    // error 3: as a nullable reference type
                Diagnostic(ErrorCode.ERR_AsNullableType, "string ?").WithArguments("string").WithLocation(9, 18),
                // (14,18): error CS8650: It is not legal to use nullable reference type 'object[]?' in an is-type expression; use the underlying type 'object[]' instead.
                //         _ = y is object[]? ? 1 : 2;   // error 4
                Diagnostic(ErrorCode.ERR_IsNullableType, "object[]?").WithArguments("object[]").WithLocation(14, 18),
                // (15,18): error CS8650: It is not legal to use nullable reference type 'object[]?' in an is-type expression; use the underlying type 'object[]' instead.
                //         _ = y is object[] ? ? 1 : 2;  // error 5
                Diagnostic(ErrorCode.ERR_IsNullableType, "object[] ?").WithArguments("object[]").WithLocation(15, 18),
                // (17,18): error CS8651: It is not legal to use nullable reference type 'object[]?' in an as expression; use the underlying type 'object[]' instead.
                //         _ = y as object[] ? ?? y;     // error 6
                Diagnostic(ErrorCode.ERR_AsNullableType, "object[] ?").WithArguments("object[]").WithLocation(17, 18)
                );
        }

        [Fact, WorkItem(29318, "https://github.com/dotnet/roslyn/issues/29318")]
        public void IsOperatorOnNonNullExpression()
        {
            var source = @"
class C
{
    void M(object o)
    {
        if (o is string)
        {
            o.ToString();
        }
        else
        {
            o.ToString();
        }
    }
}
";

            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular8);
            c.VerifyDiagnostics();
        }

        [Fact, WorkItem(29318, "https://github.com/dotnet/roslyn/issues/29318")]
        public void IsOperatorOnMaybeNullExpression()
        {
            var source = @"
class C
{
    static void Main(object? o)
    {
        if (o is string)
        {
            o.ToString();
        }
        else
        {
            o.ToString(); // 1
        }
    }
}
";

            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular8);
            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             o.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(12, 13)
                );
        }

        [Fact, WorkItem(29318, "https://github.com/dotnet/roslyn/issues/29318")]
        public void IsOperatorOnUnconstrainedType()
        {
            var source = @"
class C
{
    static void M<T>(T t)
    {
        if (t is string)
        {
            t.ToString();
        }
        else
        {
            t.ToString(); // 1
        }
    }
}
";

            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular8);
            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             t.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(12, 13)
                );
        }

        [Fact]
        public void IsOperator_AffectsNullConditionalOperator()
        {
            var source = @"
class C
{
    public object? field = null;
    static void M(C? c)
    {
        if (c?.field is string)
        {
            c.ToString();
            c.field.ToString();
        }
        else
        {
            c.ToString(); // 1
        }
    }
}
";

            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (14,13): warning CS8602: Possible dereference of a null reference.
                //             c.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(14, 13)
                );
        }

        [Fact]
        public void OmittedCall()
        {
            var source = @"
partial class C
{
    void M(string? x)
    {
        OmittedMethod(x);
    }
    partial void OmittedMethod(string x);
}
";

            var c = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular8, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (6,23): warning CS8604: Possible null reference argument for parameter 'x' in 'void C.OmittedMethod(string x)'.
                //         OmittedMethod(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "void C.OmittedMethod(string x)").WithLocation(6, 23)
                );
        }

        [Fact]
        public void OmittedInitializerCall()
        {
            var source = @"
using System.Collections;
partial class Collection : IEnumerable
{
    void M(string? x)
    {
        _ = new Collection() { x };
    }
    IEnumerator IEnumerable.GetEnumerator() => throw null;
    partial void Add(string x);
}
";

            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (7,32): warning CS8604: Possible null reference argument for parameter 'x' in 'void Collection.Add(string x)'.
                //         _ = new Collection() { x };
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "void Collection.Add(string x)").WithLocation(7, 32)
                );
        }

        [Fact]
        public void UpdateArrayRankSpecifier()
        {
            var source = @"
class C
{
    static void Main()
    {
        object[]? x = null;
    }
}
";
            var tree = Parse(source);
            var specifier = tree.GetRoot().DescendantNodes().OfType<ArrayRankSpecifierSyntax>().Single();
            Assert.Equal("[]", specifier.ToString());

            var newSpecifier = specifier.Update(
                specifier.OpenBracketToken,
                SyntaxFactory.SeparatedList<ExpressionSyntax>(
                    new[] { SyntaxFactory.LiteralExpression(SyntaxKind.NumericLiteralExpression, SyntaxFactory.Literal(3)) }),
                specifier.CloseBracketToken);
            Assert.Equal("[3]", newSpecifier.ToString());
        }

        [Fact]
        public void TestUnaryNegation()
        {
            // This test verifies that we no longer crash hitting an assertion
            var source = @"
public class C<T>
{
    C(C<object> c) => throw null;
    void M(bool b)
    {
        _ = new C<object>(!b);
    }
    public static implicit operator C<T>(T x) => throw null;
}
";

            var c = CreateCompilation(source, parseOptions: TestOptions.Regular8);
            c.VerifyDiagnostics();
        }

        [Fact]
        public void UnconstrainedAndErrorNullableFields()
        {
            var source = @"
public class C<T>
{
    public T? field;
    public Unknown? field2;
}
";

            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (5,12): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     public Unknown? field2;
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(5, 12),
                // (4,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public T? field;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 12),
                // (2,14): warning CS8618: Non-nullable field 'field' is uninitialized.
                // public class C<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "C").WithArguments("field", "field").WithLocation(2, 14)
                );
        }

        [Fact]
        public void NoNullableAnalysisWithoutNonNullTypes()
        {
            var source = @"
class C
{
    void M(string z)
    {
        z = null;
        z.ToString();
    }
}
" + NonNullTypesOn() + @"
class C2
{
    void M(string z)
    {
        z = null; // 1
        z.ToString(); // 2
    }
}
";
            var expected = new[]
            {
                // (15,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = null; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(15, 13),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(16, 9)
            };

            var c = CreateCompilation(new[] { source });
            c.VerifyDiagnostics(expected);

            c = CreateCompilation(source, parseOptions: TestOptions.RegularPreview);
            c.VerifyDiagnostics(expected);

            expected = new[]
            {
                // (10,2): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                // #nullable enable
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "nullable").WithArguments("nullable reference types").WithLocation(10, 2)
            };

            var c2 = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);
            c2.VerifyDiagnostics(expected);

            var c3 = CreateCompilation(source, parseOptions: TestOptions.RegularDefault, skipUsesIsNullable: true);
            c3.VerifyDiagnostics(expected);
        }

        [Fact]
        public void NonNullTypesOnPartialSymbol()
        {
            var source = @"
" + NonNullTypesOn() + @"
partial class C
{
" + NonNullTypesOff() + @"
    partial void M();
}
" + NonNullTypesOn() + @"
partial class C
{
" + NonNullTypesOff() + @"
    partial void M() { }
}
";
            var c = CreateCompilation(new[] { source });
            c.VerifyDiagnostics(
                );
        }

        [Fact(Skip = "Hits assertion in CheckValueKind")]
        public void SuppressionAsLValue()
        {
            var source = @"
class C
{
    void M(string? x)
    {
        ref string y = ref x;
        ref string y2 = ref x;
        (y2! = ref y) = ref y;
    }
}
";
            // https://github.com/dotnet/roslyn/issues/29710 should we produce an error for misuse of suppression on an L-value?
            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(31732, "https://github.com/dotnet/roslyn/issues/31732")]
        public void SuppressionOnUnconstrainedTypeParameter()
        {
            var source = @"
class C
{
    void M<T>(T t)
    {
        t!.ToString();
        t.ToString();
    }
}
";
            var c = CreateCompilation(new[] { source });
            c.VerifyDiagnostics();

            c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(31732, "https://github.com/dotnet/roslyn/issues/31732")]
        public void SuppressionOnNullableValueType()
        {
            var source = @"
class C
{
    void M(int? i)
    {
        i!!.Value.ToString(); // intentional double !
        i.Value.ToString();
    }
}
";
            var c = CreateCompilation(new[] { source });
            c.VerifyDiagnostics();

            c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(31732, "https://github.com/dotnet/roslyn/issues/31732")]
        public void SuppressionOnNullableValueType_AppliedOnField()
        {
            var source = @"
public struct S
{
    public string? field;
}
class C
{
    void M(S? s)
    {
        s.Value.field!.ToString();
    }
}
";
            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (10,9): warning CS8629: Nullable value type may be null.
                //         s.Value.field!.ToString();
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s.Value").WithLocation(10, 9)
                );
        }

        [Fact]
        [WorkItem(31732, "https://github.com/dotnet/roslyn/issues/31732")]
        public void SuppressionOnNullableReferenceType_AppliedOnField()
        {
            var source = @"
public class C
{
    public string? field;
    void M(C? c)
    {
        c.field!.ToString();
    }
}
";
            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         c.field!.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(7, 9)
                );
        }

        [Fact]
        [WorkItem(31732, "https://github.com/dotnet/roslyn/issues/31732")]
        public void SuppressionOnNullableReferenceType_AppliedOnField2()
        {
            var source = @"
public class C
{
    public string? field;
    void M(C? c)
    {
        c?.field!.ToString();
        c.ToString(); // We learned from suppressed dereference that `c` isn't null
    }
}
";
            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(31732, "https://github.com/dotnet/roslyn/issues/31732")]
        public void SuppressionOnArgument()
        {
            var source = @"
class C
{
    void M(string? s)
    {
        NonNull(s!);
        s.ToString(); // warn
    }
    void NonNull(string s) => throw null;
}
";
            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void SuppressionWithoutNonNullTypes()
        {
            var source = @"
[System.Obsolete("""", true!)] // 1, 2
class C
{
    string x = null!; // 3, 4
    static void Main(string z = null!) // 5
    {
        string y = null!; // 6, 7
    }
}
";
            var c = CreateCompilation(source);
            c.VerifyEmitDiagnostics(
                // (8,16): warning CS0219: The variable 'y' is assigned but its value is never used
                //         string y = null!; // 6, 7
                Diagnostic(ErrorCode.WRN_UnreferencedVarAssg, "y").WithArguments("y").WithLocation(8, 16),
                // (5,12): warning CS0414: The field 'C.x' is assigned but its value is never used
                //     string x = null!; // 3, 4
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "x").WithArguments("C.x").WithLocation(5, 12)
                );
        }

        [Fact, WorkItem(26812, "https://github.com/dotnet/roslyn/issues/26812")]
        public void DoubleAssignment()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using static System.Console;
class C
{
    static void Main()
    {
        string? x;
        x = x = """";
        WriteLine(x.Length);
        string? y;
        x = y = """";
        WriteLine(x.Length);
        WriteLine(y.Length);
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact, WorkItem(26746, "https://github.com/dotnet/roslyn/issues/26746")]
        public void TernaryWithConversionFromExpression()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C 
{
    public void M() 
    {
        uint a = 0;
        uint x = true ? a : 1;
        uint y = true ? 1 : a;
    }
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics();
        }

        [Fact, WorkItem(26746, "https://github.com/dotnet/roslyn/issues/26746")]
        public void TernaryWithImplicitUsedDefinedConversion_ConstantTrue()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void M()
    {
        C c = new C();
        C x = true ? c : 1;
        C y = true ? 1 : c;
    }
    public static implicit operator C?(int i) => throw null;
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (8,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         C y = true ? 1 : c;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "true ? 1 : c").WithLocation(8, 15)
                );
        }

        [Fact, WorkItem(26746, "https://github.com/dotnet/roslyn/issues/26746")]
        public void TernaryWithImplicitUsedDefinedConversion_ConstantFalse()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void M()
    {
        C c = new C();
        C x = false ? c : 1;
        C y = false ? 1 : c;
    }
    public static implicit operator C?(int i) => throw null;
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (7,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         C x = false ? c : 1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "false ? c : 1").WithLocation(7, 15)
                );
        }

        [Fact, WorkItem(26746, "https://github.com/dotnet/roslyn/issues/26746")]
        public void TernaryWithImplicitUsedDefinedConversion_NotConstant()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void M(bool b)
    {
        C c = new C();
        C x = b ? c : 1;
        C y = b ? 1 : c;
    }
    public static implicit operator C?(int i) => throw null;
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (7,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         C x = b ? c : 1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "b ? c : 1").WithLocation(7, 15),
                // (8,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         C y = b ? 1 : c;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "b ? 1 : c").WithLocation(8, 15)
                );
        }

        [Fact, WorkItem(26746, "https://github.com/dotnet/roslyn/issues/26746")]
        public void TernaryWithImplicitUsedDefinedConversion2()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void M()
    {
        C c = null!;
        int x = true ? c : 1;
        int y = true ? 1 : c;

        C? c2 = null;
        int x2 = true ? c2 : 1;
        int y2 = true ? 1 : c2;
    }
    public static implicit operator int(C i) => throw null;
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (11,25): warning CS8604: Possible null reference argument for parameter 'i' in 'C.implicit operator int(C i)'.
                //         int x2 = true ? c2 : 1;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "c2").WithArguments("i", "C.implicit operator int(C i)").WithLocation(11, 25)
                );
        }

        [Fact]
        public void AnnotationWithoutNonNullTypes()
        {
            var source = @"
class C<T> where T : class
{
    static string? field = M2(out string? x1); // warn 1 and 2
    static string? P // warn 3
    {
        get
        {
            string? x2 = null; // warn 4
            return x2;
        }
    }
    static string? MethodWithLocalFunction() // warn 5
    {
        string? x3 = local(null); // warn 6
        return x3;

        string? local(C<string?>? x) // warn 7, 8 and 9
        {
            string? x4 = null; // warn 10
            return x4;
        }
    }
    static string? Lambda() // warn 11
    {
        System.Func<string?, string?> x5 = (string? x) =>  // warn 12, 13 and 14
        {
            string? x6 = null; // warn 15
            return x6;
        };
        return x5(null);
    }
    static string M2(out string? x4) => throw null; // warn 16
    static string M3(C<string?> x, C<string> y) => throw null; // warn 17
    delegate string? MyDelegate(C<string?> x); // warn 18 and 19
    event MyDelegate? Event; // warn 20
    void M4() { Event(new C<string?>()); } // warn 21
    class D<T2> where T2 : T? { } // warn 22
    class D2 : C<string?> { } // warn 23
    public static C<T?> operator +(C<T> x, C<T?> y) => throw null; // warn 24 and 25
    class D3
    {
        D3(C<T?> x) => throw null; // warn 26
    }
    public string? this[C<string?> x] { get => throw null; } // warn 27 and 28
}
";
            var expectedDiagnostics = new[] {
                // (5,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string? P // warn 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 18),
                // (13,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string? MethodWithLocalFunction() // warn 5
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 18),
                // (24,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string? Lambda() // warn 11
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(24, 18),
                // (33,32): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string M2(out string? x4) => throw null; // warn 16
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(33, 32),
                // (34,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string M3(C<string?> x, C<string> y) => throw null; // warn 17
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(34, 30),
                // (36,21): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     event MyDelegate? Event; // warn 20
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(36, 21),
                // (40,47): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static C<T?> operator +(C<T> x, C<T?> y) => throw null; // warn 24 and 25
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(40, 47),
                // (40,46): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static C<T?> operator +(C<T> x, C<T?> y) => throw null; // warn 24 and 25
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(40, 46),
                // (40,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static C<T?> operator +(C<T> x, C<T?> y) => throw null; // warn 24 and 25
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(40, 22),
                // (40,21): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static C<T?> operator +(C<T> x, C<T?> y) => throw null; // warn 24 and 25
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(40, 21),
                // (45,33): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public string? this[C<string?> x] { get => throw null; } // warn 27 and 28
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(45, 33),
                // (45,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public string? this[C<string?> x] { get => throw null; } // warn 27 and 28
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(45, 18),
                // (4,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string? field = M2(out string? x1); // warn 1 and 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 18),
                // (43,15): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         D3(C<T?> x) => throw null; // warn 26
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(43, 15),
                // (43,14): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         D3(C<T?> x) => throw null; // warn 26
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(43, 14),
                // (35,20): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     delegate string? MyDelegate(C<string?> x); // warn 18 and 19
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(35, 20),
                // (35,41): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     delegate string? MyDelegate(C<string?> x); // warn 18 and 19
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(35, 41),
                // (38,29): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     class D<T2> where T2 : T? { } // warn 22
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(38, 29),
                // (38,28): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     class D<T2> where T2 : T? { } // warn 22
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(38, 28),
                // (39,24): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     class D2 : C<string?> { } // warn 23
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(39, 24),
                // (4,41): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static string? field = M2(out string? x1); // warn 1 and 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 41),
                // (9,19): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //             string? x2 = null; // warn 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 19),
                // (15,15): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? x3 = local(null); // warn 6
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(15, 15),
                // (20,19): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //             string? x4 = null; // warn 10
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(20, 19),
                // (18,31): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? local(C<string?>? x) // warn 7, 8 and 9
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 31),
                // (18,33): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? local(C<string?>? x) // warn 7, 8 and 9
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 33),
                // (18,15): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? local(C<string?>? x) // warn 7, 8 and 9
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 15),
                // (26,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         System.Func<string?, string?> x5 = (string? x) =>  // warn 12, 13 and 14
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(26, 27),
                // (26,36): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         System.Func<string?, string?> x5 = (string? x) =>  // warn 12, 13 and 14
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(26, 36),
                // (26,51): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         System.Func<string?, string?> x5 = (string? x) =>  // warn 12, 13 and 14
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(26, 51),
                // (28,19): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //             string? x6 = null; // warn 15
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(28, 19),
                // (37,35): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     void M4() { Event(new C<string?>()); } // warn 21
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(37, 35)
            };

            // https://github.com/dotnet/roslyn/issues/29839: are annotations on events meaningful/allowed?

            var c = CreateCompilation(source);
            c.VerifyDiagnostics(expectedDiagnostics);

            var c2 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c2.VerifyDiagnostics(
                // (43,14): warning CS8634: The type 'T?' cannot be used as type parameter 'T' in the generic type or method 'C<T>'. Nullability of type argument 'T?' doesn't match 'class' constraint.
                //         D3(C<T?> x) => throw null; // warn 26
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "T?").WithArguments("C<T>", "T", "T?").WithLocation(43, 14),
                // (35,35): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //     delegate string? MyDelegate(C<string?> x); // warn 18 and 19
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("C<T>", "T", "string?").WithLocation(35, 35),
                // (18,25): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         string? local(C<string?>? x) // warn 7, 8 and 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("C<T>", "T", "string?").WithLocation(18, 25),
                // (37,29): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //     void M4() { Event(new C<string?>()); } // warn 21
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("C<T>", "T", "string?").WithLocation(37, 29),
                // (37,17): warning CS8602: Possible dereference of a null reference.
                //     void M4() { Event(new C<string?>()); } // warn 21 and 22
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "Event").WithLocation(37, 17)
                );

            var c3 = CreateCompilation(new[] { source }, options: WithNonNullTypesFalse());
            c3.VerifyDiagnostics(expectedDiagnostics);
        }

        [Fact]
        public void AnnotationWithoutNonNullTypes_GenericType()
        {
            var source = @"
public class C<T> where T : class
{
    public T? M(T? x1) // warn 1 and 2
    {
        T? y1 = x1; // warn 3
        return y1;
    }
}
public class E<T> where T : struct
{
    public T? M(T? x2)
    {
        T? y2 = x2;
        return y2;
    }
}
";
            CSharpCompilation c = CreateCompilation(source);
            c.VerifyDiagnostics(
                // (4,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public T? M(T? x1) // warn 1 and 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 18),
                // (4,17): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public T? M(T? x1) // warn 1 and 2
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 17),
                // (4,13): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public T? M(T? x1) // warn 1 and 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 13),
                // (4,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public T? M(T? x1) // warn 1 and 2
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 12),
                // (6,10): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         T? y1 = x1; // warn 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 10),
                // (6,9): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         T? y1 = x1; // warn 3
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(6, 9)
                );

            var client = @"
class Client
{
    void M(C<string> c)
    {
        c.M("""").ToString();
    }
}
";
            var comp2 = CreateCompilation(new[] { client }, options: WithNonNullTypesTrue(), references: new[] { c.ToMetadataReference() });
            comp2.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         c.M("").ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, @"c.M("""")").WithLocation(6, 9)
                );

            c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics();

            comp2 = CreateCompilation(new[] { client }, options: WithNonNullTypesTrue(), references: new[] { c.EmitToImageReference() });
            comp2.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         c.M("").ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, @"c.M("""")").WithLocation(6, 9)
                );

            comp2 = CreateCompilation(new[] { client }, options: WithNonNullTypesTrue(), references: new[] { c.ToMetadataReference() });
            comp2.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         c.M("").ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, @"c.M("""")").WithLocation(6, 9)
                );
        }

        [Fact]
        public void AnnotationWithoutNonNullTypes_AttributeArgument()
        {
            var source =
@"class AAttribute : System.Attribute
{
    internal AAttribute(object o) { }
}
class B<T> { }
[A(typeof(object?))] // 1
class C1 { }
[A(typeof(int?))]
class C2 { }
[A(typeof(B<object?>))] // 2
class C3 { }
[A(typeof(B<int?>))]
class C4 { }";

            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (6,17): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // [A(typeof(object?))] // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 17),
                // (10,19): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // [A(typeof(B<object?>))] // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 19));

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Nullable_False_InCSharp7()
        {
            var comp = CreateCompilation("", options: WithNonNullTypesFalse(), parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableOption()
        {
            var comp = CreateCompilation("", options: WithNonNullTypes(NullableContextOptions.Enable), parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'NullableContextOptions' value: 'Enable' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("NullableContextOptions", "Enable", "7.3", "8.0").WithLocation(1, 1)
                );

            comp = CreateCompilation("", options: WithNonNullTypes(NullableContextOptions.SafeOnly), parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'NullableContextOptions' value: 'Safeonly' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("NullableContextOptions", "SafeOnly", "7.3", "8.0").WithLocation(1, 1)
                );

            comp = CreateCompilation("", options: WithNonNullTypes(NullableContextOptions.Warnings), parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'NullableContextOptions' value: 'Warnings' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("NullableContextOptions", "Warnings", "7.3", "8.0").WithLocation(1, 1)
                );

            comp = CreateCompilation("", options: WithNonNullTypes(NullableContextOptions.SafeOnlyWarnings), parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'NullableContextOptions' value: 'SafeOnlyWarnings' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("NullableContextOptions", "SafeOnlyWarnings", "7.3", "8.0").WithLocation(1, 1)
                );

            comp = CreateCompilation("", options: WithNonNullTypes(NullableContextOptions.Disable), parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics();

            comp = CreateCompilation("", options: WithNonNullTypes(NullableContextOptions.Enable), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            comp = CreateCompilation("", options: WithNonNullTypes(NullableContextOptions.SafeOnly), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            comp = CreateCompilation("", options: WithNonNullTypes(NullableContextOptions.Warnings), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            comp = CreateCompilation("", options: WithNonNullTypes(NullableContextOptions.SafeOnlyWarnings), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            comp = CreateCompilation("", options: WithNonNullTypes(NullableContextOptions.Disable), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new string[] { }, options: WithNonNullTypes(NullableContextOptions.Enable), parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new string[] { }, options: WithNonNullTypes(NullableContextOptions.Enable), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new string[] { }, options: WithNonNullTypes(NullableContextOptions.SafeOnly), parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new string[] { }, options: WithNonNullTypes(NullableContextOptions.SafeOnly), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new string[] { }, options: WithNonNullTypes(NullableContextOptions.Warnings), parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new string[] { }, options: WithNonNullTypes(NullableContextOptions.Warnings), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new string[] { }, options: WithNonNullTypes(NullableContextOptions.SafeOnlyWarnings), parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new string[] { }, options: WithNonNullTypes(NullableContextOptions.SafeOnlyWarnings), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new string[] { }, options: WithNonNullTypes(NullableContextOptions.Disable), parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new string[] { }, options: WithNonNullTypes(NullableContextOptions.Disable), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableAttribute_NotRequiredCSharp7_01()
        {
            var source =
@"using System.Threading.Tasks;
class C
{
    static async Task<string> F()
    {
        return await Task.FromResult(default(string));
    }
}";
            var comp = CreateCompilationWithMscorlib45(source, parseOptions: TestOptions.Regular7);
            comp.VerifyEmitDiagnostics();
        }

        [Fact]
        public void NullableAttribute_NotRequiredCSharp7_02()
        {
            var source =
@"using System;
using System.Threading.Tasks;
class C
{
    static async Task F<T>(Func<Task> f)
    {
        await G(async () =>
        {
            await f();
            return default(object);
        });
    }
    static async Task<TResult> G<TResult>(Func<Task<TResult>> f)
    {
        throw new NotImplementedException();
    }
}";
            var comp = CreateCompilationWithMscorlib45(source, parseOptions: TestOptions.Regular7);
            comp.VerifyEmitDiagnostics(
                // (13,32): warning CS1998: This async method lacks 'await' operators and will run synchronously. Consider using the 'await' operator to await non-blocking API calls, or 'await Task.Run(...)' to do CPU-bound work on a background thread.
                //     static async Task<TResult> G<TResult>(Func<Task<TResult>> f)
                Diagnostic(ErrorCode.WRN_AsyncLacksAwaits, "G").WithLocation(13, 32));
        }

        [Fact, WorkItem(26739, "https://github.com/dotnet/roslyn/issues/26618")]
        public void SuppressionOnNullConvertedToConstrainedTypeParameterType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public T M<T>() where T : C
    {
        return null!;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void MissingInt()
        {
            var source0 =
@"namespace System
{
    public class Object { }
    public abstract class ValueType { }
    public struct Void { }
    public struct Boolean { }
    public struct Enum { }
    public class Attribute { }
}";
            var comp0 = CreateEmptyCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"enum E { A }
class C
{
    int F() => (int)E.A;
}";
            var comp = CreateEmptyCompilation(
                source,
                references: new[] { ref0 },
                parseOptions: TestOptions.Regular8);
            comp.VerifyEmitDiagnostics(
                // (1,6): error CS0518: Predefined type 'System.Int32' is not defined or imported
                // enum E { A }
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "E").WithArguments("System.Int32").WithLocation(1, 6),
                // (4,5): error CS0518: Predefined type 'System.Int32' is not defined or imported
                //     int F() => (int)E.A;
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "int").WithArguments("System.Int32").WithLocation(4, 5),
                // (4,17): error CS0518: Predefined type 'System.Int32' is not defined or imported
                //     int F() => (int)E.A;
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "int").WithArguments("System.Int32").WithLocation(4, 17));
        }

        [Fact]
        public void MissingNullable()
        {
            var source = @"
namespace System
{
    public class Object { }
    public abstract class ValueType { }
    public struct Void { }
    public struct Boolean { }
    public struct Enum { }
    public class Attribute { }
}";
            var source2 = @"
class C<T> where T : struct
{
    void M()
    {
        T? local = null;
        _ = local;
    }
}
";
            var comp = CreateEmptyCompilation(new[] { source, source2 });
            comp.VerifyDiagnostics(
                // (6,9): error CS0518: Predefined type 'System.Nullable`1' is not defined or imported
                //         T? local = null;
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "T?").WithArguments("System.Nullable`1").WithLocation(6, 9)
                );

            var source3 = @"
class C<T> where T : struct
{
    void M(T? nullable) { }
}
";
            var comp2 = CreateEmptyCompilation(new[] { source, source3 });
            comp2.VerifyDiagnostics(
                // (4,12): error CS0518: Predefined type 'System.Nullable`1' is not defined or imported
                //     void M(T? nullable) { }
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "T?").WithArguments("System.Nullable`1").WithLocation(4, 12)
                );

            var source4 = @"
class C<T> where T : struct
{
    void M<U>() where U : T? { }
}
";
            var comp3 = CreateEmptyCompilation(new[] { source, source4 });
            comp3.VerifyDiagnostics(
                // (4,27): error CS0518: Predefined type 'System.Nullable`1' is not defined or imported
                //     void M<U>() where U : T? { }
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "T?").WithArguments("System.Nullable`1").WithLocation(4, 27),
                // (4,12): error CS0518: Predefined type 'System.Nullable`1' is not defined or imported
                //     void M<U>() where U : T? { }
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound, "U").WithArguments("System.Nullable`1").WithLocation(4, 12)
                );
        }

        [ConditionalFact(typeof(DesktopOnly))]
        public void UnannotatedAssemblies_WithSomeExtraAnnotations()
        {
            // https://github.com/dotnet/roslyn/issues/29821 external annotations should be removed or fully designed/productized
            var comp = CreateCompilation("");
            comp.VerifyDiagnostics();
            var systemNamespace = comp.GetMember<NamedTypeSymbol>("System.Object").ContainingNamespace;

            var expected = ImmutableArray.Create(
"System.String! System.String.Concat(System.String?, System.String?)",
"System.Boolean System.Boolean.Parse(System.String!)",
"void System.Buffer.BlockCopy(System.Array!, System.Int32, System.Array!, System.Int32, System.Int32)",
"System.Byte System.Buffer.GetByte(System.Array!, System.Int32)",
"void System.Buffer.SetByte(System.Array!, System.Int32, System.Byte)",
"System.Int32 System.Buffer.ByteLength(System.Array!)",
"System.Byte System.Byte.Parse(System.String!)",
"System.Byte System.Byte.Parse(System.String!, System.Globalization.NumberStyles)",
"System.Byte System.Byte.Parse(System.String!, System.IFormatProvider)",
"System.Byte System.Byte.Parse(System.String!, System.Globalization.NumberStyles, System.IFormatProvider)"
            );

            VerifyUsesOfNullability(systemNamespace, expected);
        }

        [Fact]
        public void AnnotatedAssemblies_WithSomeExtraAnnotations()
        {
            // https://github.com/dotnet/roslyn/issues/29821 external annotations should be removed or fully designed/productized
            var lib = @"
namespace System
{
    public class Object { }
    public struct Void { }
    public class Attribute { }
    public class ValueType { }
    public struct Boolean { }
    public class String
    {
        public String? Concat(String a, String b) => throw null;
    }
    public class Enum { }
    public struct Byte { }
    public struct Int32 { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
}
";
            var comp = CreateEmptyCompilation(lib);
            comp.VerifyDiagnostics(
                // (11,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public String? Concat(String a, String b) => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 22)
                );

            var comp2 = CreateEmptyCompilation("", references: new[] { comp.EmitToImageReference() });
            comp2.VerifyDiagnostics();

            var expected = ImmutableArray.Create("System.String! System.String.Concat(System.String?, System.String?)");
            var systemNamespace = comp2.GetMember<NamedTypeSymbol>("System.String").ContainingNamespace;
            VerifyUsesOfNullability(systemNamespace, expected);
        }

        [Fact]
        public void UnannotatedAssemblies_01()
        {
            var source0 =
@"public class A
{
    public static void F(string s) { }
}";
            var source1 =
@"class B
{
    static void Main()
    {
        A.F(string.Empty);
        A.F(null);
    }
}";
            TypeSymbolWithAnnotations getParameterType(Compilation c) => c.GetMember<MethodSymbol>("A.F").Parameters[0].Type;

            // 7.0 library
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var compRefs0 = new MetadataReference[] { new CSharpCompilationReference(comp0) };
            var metadataRefs0 = new[] { comp0.EmitToImageReference() };
            Assert.Equal(NullableAnnotation.Unknown, getParameterType(comp0).NullableAnnotation);

            // ... used in 7.0.
            var comp1 = CreateCompilation(source1, references: compRefs0, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.Unknown, getParameterType(comp1).NullableAnnotation);
            comp1 = CreateCompilation(source1, references: metadataRefs0, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.Unknown, getParameterType(comp1).NullableAnnotation);

            // ... used in 8.0.
            comp1 = CreateCompilation(source1, references: compRefs0);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.Unknown, getParameterType(comp1).NullableAnnotation);
            comp1 = CreateCompilation(source1, references: metadataRefs0);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.Unknown, getParameterType(comp1).NullableAnnotation);

            // 8.0 library
            comp0 = CreateCompilation(source0);
            comp0.VerifyDiagnostics();
            compRefs0 = new MetadataReference[] { new CSharpCompilationReference(comp0) };
            metadataRefs0 = new[] { comp0.EmitToImageReference() };
            Assert.Equal(NullableAnnotation.Unknown, getParameterType(comp0).NullableAnnotation);

            // ... used in 7.0.
            comp1 = CreateCompilation(source1, references: compRefs0, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.Unknown, getParameterType(comp1).NullableAnnotation);
            comp1 = CreateCompilation(source1, references: metadataRefs0, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.Unknown, getParameterType(comp1).NullableAnnotation);

            // ... used in 8.0.
            comp1 = CreateCompilation(source1, references: compRefs0);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.Unknown, getParameterType(comp1).NullableAnnotation);
            comp1 = CreateCompilation(source1, references: metadataRefs0);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.Unknown, getParameterType(comp1).NullableAnnotation);

            comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: compRefs0);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.Unknown, getParameterType(comp1).NullableAnnotation);
            comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: metadataRefs0);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.Unknown, getParameterType(comp1).NullableAnnotation);

            // 8.0 library
            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            comp0.VerifyDiagnostics();
            compRefs0 = new MetadataReference[] { new CSharpCompilationReference(comp0) };
            metadataRefs0 = new[] { comp0.EmitToImageReference() };
            Assert.Equal(NullableAnnotation.NotAnnotated, getParameterType(comp0).NullableAnnotation);

            // ... used in 7.0.
            comp1 = CreateCompilation(source1, references: compRefs0, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.NotAnnotated, getParameterType(comp1).NullableAnnotation);
            comp1 = CreateCompilation(source1, references: metadataRefs0, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.NotAnnotated, getParameterType(comp1).NullableAnnotation);

            // ... used in 8.0.
            comp1 = CreateCompilation(source1, references: compRefs0);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.NotAnnotated, getParameterType(comp1).NullableAnnotation);
            comp1 = CreateCompilation(source1, references: metadataRefs0);
            comp1.VerifyDiagnostics();
            Assert.Equal(NullableAnnotation.NotAnnotated, getParameterType(comp1).NullableAnnotation);

            comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: compRefs0);
            comp1.VerifyDiagnostics(
                // (6,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         A.F(null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 13));
            Assert.Equal(NullableAnnotation.NotAnnotated, getParameterType(comp1).NullableAnnotation);
            comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: metadataRefs0);
            comp1.VerifyDiagnostics(
                // (6,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         A.F(null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 13));
            Assert.Equal(NullableAnnotation.NotAnnotated, getParameterType(comp1).NullableAnnotation);
        }

        [Fact]
        public void UnannotatedAssemblies_02()
        {
            var source0 =
@"#pragma warning disable 67
public delegate void D();
public class C
{
    public object F;
    public event D E;
    public object P => null;
    public object this[object o] => null;
    public object M(object o) => null;
}";
            var source1 =
@"class P
{
    static void F(C c)
    {
        object o;
        o = c.F;
        c.E += null;
        o = c.P;
        o = c[null];
        o = c.M(null);
    }
}";

            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();

            void verify(Compilation c)
            {
                c.VerifyDiagnostics();
                Assert.Equal(NullableAnnotation.Unknown, c.GetMember<FieldSymbol>("C.F").Type.NullableAnnotation);
                Assert.Equal(NullableAnnotation.Unknown, c.GetMember<EventSymbol>("C.E").Type.NullableAnnotation);
                Assert.Equal(NullableAnnotation.Unknown, c.GetMember<PropertySymbol>("C.P").Type.NullableAnnotation);
                var indexer = c.GetMember<PropertySymbol>("C.this[]");
                Assert.Equal(NullableAnnotation.Unknown, indexer.Type.NullableAnnotation);
                Assert.Equal(NullableAnnotation.Unknown, indexer.Parameters[0].Type.NullableAnnotation);
                var method = c.GetMember<MethodSymbol>("C.M");
                Assert.Equal(NullableAnnotation.Unknown, method.ReturnType.NullableAnnotation);
                Assert.Equal(NullableAnnotation.Unknown, method.Parameters[0].Type.NullableAnnotation);
            }

            var comp1A = CreateCompilation(source1, references: new MetadataReference[] { new CSharpCompilationReference(comp0) });
            verify(comp1A);

            var comp1B = CreateCompilation(source1, references: new[] { comp0.EmitToImageReference() });
            verify(comp1B);
        }

        [Fact]
        public void UnannotatedAssemblies_03()
        {
            var source0 =
@"#pragma warning disable 67
public class C
{
    public (object, object) F;
    public (object, object) P => (null, null);
    public (object, object) M((object, object) o) => o;
}";
            var source1 =
@"class P
{
    static void F(C c)
    {
        (object, object) t;
        t = c.F;
        t = c.P;
        t = c.M((null, null));
    }
}";

            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();

            void verifyTuple(TypeSymbolWithAnnotations type)
            {
                var tuple = (TupleTypeSymbol)type.TypeSymbol;
                Assert.Equal(NullableAnnotation.Unknown, tuple.TupleElements[0].Type.NullableAnnotation);
                Assert.Equal(NullableAnnotation.Unknown, tuple.TupleElements[1].Type.NullableAnnotation);
            }

            void verify(Compilation c)
            {
                c.VerifyDiagnostics();
                verifyTuple(c.GetMember<FieldSymbol>("C.F").Type);
                verifyTuple(c.GetMember<PropertySymbol>("C.P").Type);
                var method = c.GetMember<MethodSymbol>("C.M");
                verifyTuple(method.ReturnType);
                verifyTuple(method.Parameters[0].Type);
            }

            var comp1A = CreateCompilation(source1, references: new[] { new CSharpCompilationReference(comp0) });
            verify(comp1A);

            var comp1B = CreateCompilation(source1, references: new[] { comp0.EmitToImageReference() });
            verify(comp1B);
        }

        [Fact]
        public void UnannotatedAssemblies_04()
        {
            var source =
@"class A { }
class B : A { }
interface I<T> where T : A { }
abstract class C<T> where T : A
{
    internal abstract void M<U>() where U : T;
}
class D : C<B>, I<B>
{
    internal override void M<T>() { }
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
            var derivedType = comp.GetMember<NamedTypeSymbol>("D");
            var baseType = derivedType.BaseTypeNoUseSiteDiagnostics;
            var constraintType = baseType.TypeParameters.Single().ConstraintTypesNoUseSiteDiagnostics.Single();
            Assert.Equal(NullableAnnotation.Unknown, constraintType.NullableAnnotation);
            var interfaceType = derivedType.Interfaces().Single();
            constraintType = interfaceType.TypeParameters.Single().ConstraintTypesNoUseSiteDiagnostics.Single();
            Assert.Equal(NullableAnnotation.Unknown, constraintType.NullableAnnotation);
            var method = baseType.GetMember<MethodSymbol>("M");
            constraintType = method.TypeParameters.Single().ConstraintTypesNoUseSiteDiagnostics.Single();
            Assert.Equal(NullableAnnotation.Unknown, constraintType.NullableAnnotation);
        }

        [Fact]
        public void UnannotatedAssemblies_05()
        {
            var source =
@"interface I<T>
{
    I<object[]> F(I<T> t);
}
class C : I<string>
{
    I<object[]> I<string>.F(I<string> s) => null;
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
            var type = comp.GetMember<NamedTypeSymbol>("C");
            var interfaceType = type.Interfaces().Single();
            var typeArg = interfaceType.TypeArgumentsNoUseSiteDiagnostics.Single();
            Assert.Equal(NullableAnnotation.Unknown, typeArg.NullableAnnotation);
            var method = type.GetMember<MethodSymbol>("I<System.String>.F");
            Assert.Equal(NullableAnnotation.Unknown, method.ReturnType.NullableAnnotation);
            typeArg = ((NamedTypeSymbol)method.ReturnType.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics.Single();
            Assert.Equal(NullableAnnotation.Unknown, typeArg.NullableAnnotation);
            var parameter = method.Parameters.Single();
            Assert.Equal(NullableAnnotation.Unknown, parameter.Type.NullableAnnotation);
            typeArg = ((NamedTypeSymbol)parameter.Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics.Single();
            Assert.Equal(NullableAnnotation.Unknown, typeArg.NullableAnnotation);
        }

        [Fact]
        public void UnannotatedAssemblies_06()
        {
            var source0 =
@"public class C<T>
{
    public T F;
}
public class C
{
    public static C<T> Create<T>(T t) => new C<T>();
}";
            var source1 =
@"class P
{
    static void F(object x, object? y)
    {
        object z;
        z = C.Create(x).F;
        z = C.Create(y).F;
    }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(),
                references: new[] { comp0.EmitToImageReference() });
            comp1.VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = C.Create(y).F;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "C.Create(y).F").WithLocation(7, 13));
        }

        [Fact]
        public void UnannotatedAssemblies_07()
        {
            var source0 =
@"public interface I
{
    object F(object o);
}";
            var source1 =
@"class A1 : I
{
    object I.F(object? o) => new object();
}
class A2 : I
{
    object? I.F(object o) => o;
}
class B1 : I
{
    public object F(object? o) => new object();
}
class B2 : I
{
    public object? F(object o) => o;
}
class C1
{
    public object F(object? o) => new object();
}
class C2
{
    public object? F(object o) => o;
}
class D1 : C1, I
{
}
class D2 : C2, I
{
}
class P
{
    static void F(object? x, A1 a1, A2 a2)
    {
        object y;
        y = ((I)a1).F(x);
        y = ((I)a2).F(x);
    }
    static void F(object? x, B1 b1, B2 b2)
    {
        object y;
        y = b1.F(x);
        y = b2.F(x);
        y = ((I)b1).F(x);
        y = ((I)b2).F(x);
    }
    static void F(object? x, D1 d1, D2 d2)
    {
        object y;
        y = d1.F(x);
        y = d2.F(x);
        y = ((I)d1).F(x);
        y = ((I)d2).F(x);
    }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();

            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(),
                references: new MetadataReference[] { new CSharpCompilationReference(comp0) });
            comp1.VerifyDiagnostics(
                // (43,18): warning CS8604: Possible null reference argument for parameter 'o' in 'object? B2.F(object o)'.
                //         y = b2.F(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("o", "object? B2.F(object o)").WithLocation(43, 18),
                // (43,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = b2.F(x);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "b2.F(x)").WithLocation(43, 13),
                // (51,18): warning CS8604: Possible null reference argument for parameter 'o' in 'object? C2.F(object o)'.
                //         y = d2.F(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("o", "object? C2.F(object o)").WithLocation(51, 18),
                // (51,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = d2.F(x);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "d2.F(x)").WithLocation(51, 13));

            comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(),
                references: new[] { comp0.EmitToImageReference() });
            comp1.VerifyDiagnostics(
                // (43,18): warning CS8604: Possible null reference argument for parameter 'o' in 'object? B2.F(object o)'.
                //         y = b2.F(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("o", "object? B2.F(object o)").WithLocation(43, 18),
                // (43,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = b2.F(x);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "b2.F(x)").WithLocation(43, 13),
                // (51,18): warning CS8604: Possible null reference argument for parameter 'o' in 'object? C2.F(object o)'.
                //         y = d2.F(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("o", "object? C2.F(object o)").WithLocation(51, 18),
                // (51,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = d2.F(x);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "d2.F(x)").WithLocation(51, 13));
        }

        [Fact]
        public void UnannotatedAssemblies_08()
        {
            var source0 =
@"public interface I
{
    object? F(object? o);
    object G(object o);
}";
            var source1 =
@"public class A : I
{
    object I.F(object o) => null;
    object I.G(object o) => null;
}
public class B : I
{
    public object F(object o) => null;
    public object G(object o) => null;
}
public class C
{
    public object F(object o) => null;
    public object G(object o) => null;
}
public class D : C
{
}";
            var source2 =
@"class P
{
    static void F(object o, A a)
    {
        ((I)a).F(o).ToString();
        ((I)a).G(null).ToString();
    }
    static void F(object o, B b)
    {
        b.F(o).ToString();
        b.G(null).ToString();
        ((I)b).F(o).ToString();
        ((I)b).G(null).ToString();
    }
    static void F(object o, D d)
    {
        d.F(o).ToString();
        d.G(null).ToString();
        ((I)d).F(o).ToString();
        ((I)d).G(null).ToString();
    }
}";
            var comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var comp1 = CreateCompilation(source1, references: new[] { ref0 }, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            var ref1 = comp1.EmitToImageReference();

            var comp2A = CreateCompilation(source2, references: new[] { ref0, ref1 }, parseOptions: TestOptions.Regular7);
            comp2A.VerifyDiagnostics();

            var comp2B = CreateCompilation(source2, references: new[] { ref0, ref1 });
            comp2B.VerifyDiagnostics();

            var comp2C = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { ref0, ref1 });
            comp2C.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         ((I)a).F(o).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((I)a).F(o)").WithLocation(5, 9),
                // (6,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         ((I)a).G(null).ToString();
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 18),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         ((I)b).F(o).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((I)b).F(o)").WithLocation(12, 9),
                // (13,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         ((I)b).G(null).ToString();
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(13, 18),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         ((I)d).F(o).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((I)d).F(o)").WithLocation(19, 9),
                // (20,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         ((I)d).G(null).ToString();
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(20, 18));

            var comp2D = CreateCompilation(new[] { source2 }, options: WithNonNullTypesFalse(), references: new[] { ref0, ref1 });
            comp2D.VerifyDiagnostics();
        }

        [Fact]
        public void UnannotatedAssemblies_09()
        {
            var source0 =
@"public abstract class A
{
    public abstract object? F(object x, object? y);
}";
            var source1 =
@"public abstract class B : A
{
    public abstract override object F(object x, object y);
    public abstract object G(object x, object y);
}";
            var source2 =
@"class C1 : B
{
    public override object F(object x, object y) => x;
    public override object G(object x, object y) => x;
}
class C2 : B
{
    public override object? F(object? x, object? y) => x;
    public override object? G(object? x, object? y) => x;
}
class P
{
    static void F(object? x, object y, C1 c)
    {
        c.F(x, y).ToString();
        c.G(x, y).ToString();
        ((B)c).F(x, y).ToString();
        ((B)c).G(x, y).ToString();
        ((A)c).F(x, y).ToString();
    }
    static void F(object? x, object y, C2 c)
    {
        c.F(x, y).ToString();
        c.G(x, y).ToString();
        ((B)c).F(x, y).ToString();
        ((B)c).G(x, y).ToString();
        ((A)c).F(x, y).ToString();
    }
}";
            var comp0 = CreateCompilation(source0);
            comp0.VerifyDiagnostics(
                // (3,47): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract object? F(object x, object? y);
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(3, 47),
                // (3,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract object? F(object x, object? y);
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(3, 27)
                );
            var ref0 = comp0.EmitToImageReference();

            var comp1 = CreateCompilation(source1, references: new[] { ref0 }, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            var ref1 = comp1.EmitToImageReference();

            var comp2 = CreateCompilation(source2, references: new[] { ref0, ref1 });
            comp2.VerifyDiagnostics(
                // (9,37): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override object? G(object? x, object? y) => x;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 37),
                // (9,48): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override object? G(object? x, object? y) => x;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 48),
                // (9,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override object? G(object? x, object? y) => x;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 27),
                // (21,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static void F(object? x, object y, C2 c)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(21, 25),
                // (13,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static void F(object? x, object y, C1 c)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 25),
                // (8,37): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override object? F(object? x, object? y) => x;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 37),
                // (8,48): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override object? F(object? x, object? y) => x;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 48),
                // (8,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override object? F(object? x, object? y) => x;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 27)
                );

            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            comp0.VerifyDiagnostics();
            ref0 = comp0.EmitToImageReference();

            comp1 = CreateCompilation(source1, references: new[] { ref0 }, parseOptions: TestOptions.Regular7);
            comp1.VerifyDiagnostics();
            ref1 = comp1.EmitToImageReference();

            comp2 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { ref0, ref1 });
            comp2.VerifyDiagnostics(
                // (15,13): warning CS8604: Possible null reference argument for parameter 'x' in 'object C1.F(object x, object y)'.
                //         c.F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "object C1.F(object x, object y)").WithLocation(15, 13),
                // (16,13): warning CS8604: Possible null reference argument for parameter 'x' in 'object C1.G(object x, object y)'.
                //         c.G(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "object C1.G(object x, object y)").WithLocation(16, 13),
                // (19,18): warning CS8604: Possible null reference argument for parameter 'x' in 'object? A.F(object x, object? y)'.
                //         ((A)c).F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "object? A.F(object x, object? y)").WithLocation(19, 18),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         ((A)c).F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((A)c).F(x, y)").WithLocation(19, 9),
                // (23,9): warning CS8602: Possible dereference of a null reference.
                //         c.F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.F(x, y)").WithLocation(23, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         c.G(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.G(x, y)").WithLocation(24, 9),
                // (27,18): warning CS8604: Possible null reference argument for parameter 'x' in 'object? A.F(object x, object? y)'.
                //         ((A)c).F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "object? A.F(object x, object? y)").WithLocation(27, 18),
                // (27,9): warning CS8602: Possible dereference of a null reference.
                //         ((A)c).F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((A)c).F(x, y)").WithLocation(27, 9));
        }

        [Fact]
        public void UnannotatedAssemblies_10()
        {
            var source0 =
@"public abstract class A<T>
{
    public T F;
}
public sealed class B : A<object>
{
}";
            var source1 =
@"class C
{
    static void Main()
    {
        B b = new B();
        b.F = null;
    }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();

            var comp1 = CreateCompilation(source1, references: new MetadataReference[] { new CSharpCompilationReference(comp0) });
            comp1.VerifyDiagnostics();

            comp1 = CreateCompilation(source1, references: new[] { comp0.EmitToImageReference() });
            comp1.VerifyDiagnostics();
        }

        [Fact]
        public void Embedded_WithObsolete()
        {
            string source = @"
namespace Microsoft.CodeAnalysis
{
    [Embedded]
    [System.Obsolete(""obsolete"")]
    class EmbeddedAttribute : System.Attribute
    {
        public EmbeddedAttribute() { }
    }
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();
            Assert.False(comp.GetMember("Microsoft.CodeAnalysis.EmbeddedAttribute").IsImplicitlyDeclared);
        }

        [Fact]
        public void NonNullTypes_Cycle5()
        {
            string source = @"
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = false)]
    class SomeAttribute : Attribute
    {
        public SomeAttribute() { }
        public int Property { get; set; }
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_Cycle12()
        {
            string source = @"
[System.Flags]
enum E { }
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_Cycle13()
        {
            string source = @"
interface I { }

[System.Obsolete(nameof(I2))]
interface I2 : I { }

";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_Cycle15()
        {
            string lib_cs = "public class Base { }";
            var lib = CreateCompilation(lib_cs, assemblyName: "lib");

            string lib2_cs = "public class C : Base { }";
            var lib2 = CreateCompilation(lib2_cs, references: new[] { lib.EmitToImageReference() }, assemblyName: "lib2");

            string source_cs = @"
[D]
class DAttribute : C { }
";
            var comp = CreateCompilation(source_cs, references: new[] { lib2.EmitToImageReference() });
            comp.VerifyDiagnostics(
                // (3,20): error CS0012: The type 'Base' is defined in an assembly that is not referenced. You must add a reference to assembly 'lib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
                // class DAttribute : C { }
                Diagnostic(ErrorCode.ERR_NoTypeDef, "C").WithArguments("Base", "lib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(3, 20),
                // (2,2): error CS0012: The type 'Base' is defined in an assembly that is not referenced. You must add a reference to assembly 'lib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
                // [D]
                Diagnostic(ErrorCode.ERR_NoTypeDef, "D").WithArguments("Base", "lib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(2, 2),
                // (2,2): error CS0012: The type 'Base' is defined in an assembly that is not referenced. You must add a reference to assembly 'lib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null'.
                // [D]
                Diagnostic(ErrorCode.ERR_NoTypeDef, "D").WithArguments("Base", "lib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null").WithLocation(2, 2)
                );
        }

        [Fact]
        public void NonNullTypes_Cycle16()
        {
            string source = @"
using System;
[AttributeUsage(AttributeTargets.Property)]
class AttributeWithProperty : System.ComponentModel.DisplayNameAttribute
{
    public override string DisplayName { get => throw null; }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_OnFields()
        {
            var obliviousLib = @"
public class Oblivious
{
    public static string s;
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);

            var lib = @"

" + NonNullTypesOn() + @"
public class External
{
    public static string s;
    public static string? ns;

" + NonNullTypesOff() + @"
    public static string fs;

" + NonNullTypesOff() + @"
    public static string? fns;
}
";

            var libComp = CreateCompilation(new[] { lib }, options: WithNonNullTypesTrue());
            libComp.VerifyDiagnostics(
                // (13,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static string? fns;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 25)
                );

            var source = @"


" + NonNullTypesOff() + @"
public class OuterA
{
" + NonNullTypesOn() + @"
    public class A
    {
        public static string s;
        public static string? ns;
    }
}

// NonNullTypes(true) by default
public class B
{
    public static string s;
    public static string? ns;
}

" + NonNullTypesOff() + @"
public class C
{
" + NonNullTypesOn() + @"
    public static string s;

" + NonNullTypesOn() + @"
    public static string? ns;
}

" + NonNullTypesOff() + @"
public class OuterD
{
    public class D
    {
" + NonNullTypesOn() + @"
        public static string s;
" + NonNullTypesOn() + @"
        public static string? ns;
    }
}

public class Oblivious2
{
" + NonNullTypesOff() + @"
    public static string s;
" + NonNullTypesOff() + @"
    public static string? ns;
}
" + NonNullTypesOn() + @"
class E
{
    public void M()
    {
        Oblivious.s /*T:string*/ = null;

        External.s /*T:string!*/ = null; // warn 1
        External.ns /*T:string?*/ = null;

        External.fs /*T:string*/ = null;
        External.fns /*T:string?*/ = null;

        OuterA.A.s /*T:string!*/ = null; // warn 2
        OuterA.A.ns /*T:string?*/ = null;

        B.s /*T:string!*/ = null; // warn 3
        B.ns /*T:string?*/ = null;

        C.s /*T:string!*/ = null; // warn 4
        C.ns /*T:string?*/ = null;

        OuterD.D.s /*T:string!*/ = null; // warn 5
        OuterD.D.ns /*T:string?*/ = null;

        Oblivious2.s /*T:string*/ = null;
        Oblivious2.ns /*T:string?*/ = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference(), libComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (49,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static string? ns;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(49, 25),
                // (58,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         External.s /*T:string!*/ = null; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(58, 36),
                // (64,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterA.A.s /*T:string!*/ = null; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(64, 36),
                // (67,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         B.s /*T:string!*/ = null; // warn 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(67, 29),
                // (70,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         C.s /*T:string!*/ = null; // warn 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(70, 29),
                // (73,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterD.D.s /*T:string!*/ = null; // warn 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(73, 36)
                );
        }

        [Fact]
        public void SuppressedNullConvertedToUnconstrainedT()
        {
            var source = @"
public class List2<T> { public T Item { get; set; } = null!; }
";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,55): error CS0403: Cannot convert null to type parameter 'T' because it could be a non-nullable value type. Consider using 'default(T)' instead.
                // public class List2<T> { public T Item { get; set; } = null!; }
                Diagnostic(ErrorCode.ERR_TypeVarCantBeNull, "null").WithArguments("T").WithLocation(2, 55)
                );
        }

        [Fact]
        public void TwiceSuppressedNullConvertedToUnconstrainedT()
        {
            var source = @"
public class List2<T> { public T Item { get; set; } = null!!; }
";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,55): error CS0403: Cannot convert null to type parameter 'T' because it could be a non-nullable value type. Consider using 'default(T)' instead.
                // public class List2<T> { public T Item { get; set; } = null!!; }
                Diagnostic(ErrorCode.ERR_TypeVarCantBeNull, "null").WithArguments("T").WithLocation(2, 55)
                );
        }

        [Fact]
        public void NonNullTypes_OnFields_Nested()
        {
            var obliviousLib = @"
public class List1<T> { public T Item { get; set; } = default(T); }
public class Oblivious
{
    public static List1<string> s;
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);

            var lib = @"
using System.Runtime.CompilerServices;
public class List2<T> { public T Item { get; set; } = default!; }
public class External
{
    public static List2<string> s;
    public static List2<string?> ns;

" + NonNullTypesOff() + @"
    public static List2<string> fs;
" + NonNullTypesOff() + @"
    public static List2<string?> fns;
}
";

            var libComp = CreateCompilation(new[] { lib }, options: WithNonNullTypesTrue());

            var source = @"

public class List3<T> { public T Item { get; set; } = default!; }

" + NonNullTypesOff() + @"
public class OuterA
{
" + NonNullTypesOn() + @"
    public class A
    {
        public static List3<string> s;
        public static List3<string?> ns;
    }
}

// NonNullTypes(true) by default
public class B
{
    public static List3<string> s;
    public static List3<string?> ns;
}

" + NonNullTypesOff() + @"
public class OuterD
{
    public class D
    {
" + NonNullTypesOn() + @"
        public static List3<string> s;
" + NonNullTypesOn() + @"
        public static List3<string?> ns;
    }
}

" + NonNullTypesOff() + @"
public class Oblivious2
{
    public static List3<string> s;
    public static List3<string?> ns;
}
" + NonNullTypesOn() + @"
class E
{
    public void M()
    {
        Oblivious.s.Item /*T:string*/ = null;

        External.s.Item /*T:string!*/ = null; // warn 1
        External.ns.Item /*T:string?*/ = null;

        External.fs.Item /*T:string*/ = null;
        External.fns.Item /*T:string?*/ = null;

        OuterA.A.s.Item /*T:string!*/ = null; // warn 2
        OuterA.A.ns.Item /*T:string?*/ = null;

        B.s.Item /*T:string!*/ = null; // warn 3
        B.ns.Item /*T:string?*/ = null;

        OuterD.D.s.Item /*T:string!*/ = null; // warn 4
        OuterD.D.ns.Item /*T:string?*/ = null;

        Oblivious2.s.Item /*T:string*/ = null;
        Oblivious2.ns.Item /*T:string?*/ = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference(), libComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (39,31): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static List3<string?> ns;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(39, 31),
                // (48,41): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         External.s.Item /*T:string!*/ = null; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(48, 41),
                // (54,41): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterA.A.s.Item /*T:string!*/ = null; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(54, 41),
                // (57,34): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         B.s.Item /*T:string!*/ = null; // warn 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(57, 34),
                // (60,41): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterD.D.s.Item /*T:string!*/ = null; // warn 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(60, 41)
                );
        }

        [Fact]
        public void NonNullTypes_OnFields_Tuples()
        {
            var obliviousLib = @"
public class Oblivious
{
    public static (string s, string s2) t;
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);

            var lib = @"
public class External
{
    public static (string s, string? ns) t;
}
";

            var libComp = CreateCompilation(new[] { lib }, options: WithNonNullTypesTrue());

            var source = @"


" + NonNullTypesOff() + @"
public class OuterA
{
" + NonNullTypesOn() + @"
    public class A
    {
        public static (string s, string? ns) t;
    }
}

// NonNullTypes(true) by default
public class B
{
    public static (string s, string? ns) t;
}

" + NonNullTypesOff() + @"
public class OuterD
{
    public class D
    {
" + NonNullTypesOn() + @"
        public static (string s, string? ns) t;
    }
}

" + NonNullTypesOff() + @"
public class Oblivious2
{
    public static (string s, string? ns) t;
}
" + NonNullTypesOn() + @"
class E
{
    public void M()
    {
        Oblivious.t.s /*T:string*/ = null;

        External.t.s /*T:string!*/ = null; // warn 1
        External.t.ns /*T:string?*/ = null;

        OuterA.A.t.s /*T:string!*/ = null; // warn 2
        OuterA.A.t.ns /*T:string?*/ = null;

        B.t.s /*T:string!*/ = null; // warn 3
        B.t.ns /*T:string?*/ = null;

        OuterD.D.t.s /*T:string!*/ = null; // warn 4
        OuterD.D.t.ns /*T:string?*/ = null;

        Oblivious2.t.s /*T:string*/ = null;
        Oblivious2.t.ns /*T:string?*/ = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference(), libComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (33,36): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static (string s, string? ns) t;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(33, 36),
                // (42,38): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         External.t.s /*T:string!*/ = null; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(42, 38),
                // (45,38): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterA.A.t.s /*T:string!*/ = null; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(45, 38),
                // (48,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         B.t.s /*T:string!*/ = null; // warn 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(48, 31),
                // (51,38): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterD.D.t.s /*T:string!*/ = null; // warn 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(51, 38)
                );
        }

        [Fact]
        public void NonNullTypes_OnFields_Arrays()
        {
            var obliviousLib = @"
public class Oblivious
{
    public static string[] s;
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);

            var lib = @"
public class External
{
    public static string[] s;
    public static string?[] ns;
}
";

            var libComp = CreateCompilation(new[] { lib }, options: WithNonNullTypesTrue());

            var source = @"


" + NonNullTypesOff() + @"
public class OuterA
{
" + NonNullTypesOn() + @"
    public class A
    {
        public static string[] s;
        public static string?[] ns;
    }
}

// NonNullTypes(true) by default
public class B
{
    public static string[] s;
    public static string?[] ns;
}

" + NonNullTypesOff() + @"
public class OuterD
{
    public class D
    {
" + NonNullTypesOn() + @"
        public static string[] s;
" + NonNullTypesOn() + @"
        public static string?[] ns;
    }
}

" + NonNullTypesOff() + @"
public class Oblivious2
{
    public static string[] s;
    public static string?[] ns;
}
" + NonNullTypesOn() + @"
class E
{
    public void M()
    {
        Oblivious.s[0] /*T:string*/ = null;

        External.s[0] /*T:string!*/ = null; // warn 1
        External.ns[0] /*T:string?*/ = null;

        OuterA.A.s[0] /*T:string!*/ = null; // warn 2
        OuterA.A.ns[0] /*T:string?*/ = null;

        B.s[0] /*T:string!*/ = null; // warn 3
        B.ns[0] /*T:string?*/ = null;

        OuterD.D.s[0] /*T:string!*/ = null; // warn 4
        OuterD.D.ns[0] /*T:string?*/ = null;

        Oblivious2.s[0] /*T:string*/ = null;
        Oblivious2.ns[0] /*T:string?*/ = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference(), libComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (38,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static string?[] ns;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(38, 25),
                // (47,39): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         External.s[0] /*T:string!*/ = null; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(47, 39),
                // (50,39): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterA.A.s[0] /*T:string!*/ = null; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(50, 39),
                // (53,32): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         B.s[0] /*T:string!*/ = null; // warn 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(53, 32),
                // (56,39): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterD.D.s[0] /*T:string!*/ = null; // warn 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(56, 39)
                );
        }

        [Fact]
        public void NonNullTypes_OnProperties()
        {
            var obliviousLib = @"
public class Oblivious
{
    public static string s { get; set; }
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);
            obliviousComp.VerifyDiagnostics();

            var lib = @"
public class External
{
    public static string s { get; set; }
    public static string? ns { get; set; }
}
";

            var libComp = CreateCompilation(new[] { lib }, options: WithNonNullTypesTrue());

            var source = @"


" + NonNullTypesOff() + @"
public class OuterA
{
    public class A
    {
" + NonNullTypesOn() + @"
        public static string s { get; set; }
" + NonNullTypesOn() + @"
        public static string? ns { get; set; }
    }
}

// NonNullTypes(true) by default
public class B
{
    public static string s { get; set; }
    public static string? ns { get; set; }
}

" + NonNullTypesOff() + @"
public class OuterD
{
" + NonNullTypesOn() + @"
    public class D
    {
        public static string s { get; set; }
        public static string? ns { get; set; }
    }
}

public class Oblivious2
{
" + NonNullTypesOff() + @"
    public static string s { get; set; }
" + NonNullTypesOff() + @"
    public static string? ns { get; set; }
}
" + NonNullTypesOn() + @"
class E
{
    public void M()
    {
        Oblivious.s /*T:string*/ = null;

        External.s /*T:string!*/ = null; // warn 1
        External.ns /*T:string?*/ = null;

        OuterA.A.s /*T:string!*/ = null; // warn 2
        OuterA.A.ns /*T:string?*/ = null;

        B.s /*T:string!*/ = null; // warn 3
        B.ns /*T:string?*/ = null;

        OuterD.D.s /*T:string!*/ = null; // warn 4
        OuterD.D.ns /*T:string?*/ = null;

        Oblivious2.s /*T:string*/ = null;
        Oblivious2.ns /*T:string?*/ = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference(), libComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (39,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static string? ns { get; set; }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(39, 25),
                // (48,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         External.s /*T:string!*/ = null; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(48, 36),
                // (51,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterA.A.s /*T:string!*/ = null; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(51, 36),
                // (54,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         B.s /*T:string!*/ = null; // warn 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(54, 29),
                // (57,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterD.D.s /*T:string!*/ = null; // warn 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(57, 36)
                );
        }

        [Fact]
        public void NonNullTypes_OnMethods()
        {
            var obliviousLib = @"
public class Oblivious
{
    public static string Method(string s) => throw null;
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);

            var lib = @"
public class External
{
    public static string Method(string s) => throw null;
    public static string? NMethod(string? ns) => throw null;
}
";

            var libComp = CreateCompilation(new[] { lib }, options: WithNonNullTypesTrue());

            var source = @"


" + NonNullTypesOff() + @"
public class OuterA
{
" + NonNullTypesOn() + @"
    public class A
    {
        public static string Method(string s) => throw null;
        public static string? NMethod(string? ns) => throw null;
    }
}

// NonNullTypes(true) by default
public class B
{
    public static string Method(string s) => throw null;
    public static string? NMethod(string? ns) => throw null;
}

" + NonNullTypesOff() + @"
public class OuterD
{
    public class D
    {
" + NonNullTypesOn() + @"
        public static string Method(string s) => throw null;
" + NonNullTypesOn() + @"
        public static string? NMethod(string? ns) => throw null;
    }
}

" + NonNullTypesOff() + @"
public class Oblivious2
{
    public static string Method(string s) => throw null;
    public static string? NMethod(string? ns) => throw null;
}
" + NonNullTypesOn() + @"
class E
{
    public void M()
    {
        Oblivious.Method(null) /*T:string*/;

        External.Method(null) /*T:string!*/; // warn 1
        External.NMethod(null) /*T:string?*/;

        OuterA.A.Method(null) /*T:string!*/; // warn 2
        OuterA.A.NMethod(null) /*T:string?*/;

        B.Method(null) /*T:string!*/; // warn 3
        B.NMethod(null) /*T:string?*/;

        OuterD.D.Method(null) /*T:string!*/; // warn 4
        OuterD.D.NMethod(null) /*T:string?*/;

        Oblivious2.Method(null) /*T:string*/;
        Oblivious2.NMethod(null) /*T:string?*/;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference(), libComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (38,41): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static string? NMethod(string? ns) => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(38, 41),
                // (38,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static string? NMethod(string? ns) => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(38, 25),
                // (47,25): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         External.Method(null) /*T:string!*/; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(47, 25),
                // (50,25): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterA.A.Method(null) /*T:string!*/; // warn 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(50, 25),
                // (53,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         B.Method(null) /*T:string!*/; // warn 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(53, 18),
                // (56,25): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         OuterD.D.Method(null) /*T:string!*/; // warn 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(56, 25)
                );
        }

        [Fact]
        public void NonNullTypes_OnModule()
        {
            var obliviousLib =
NonNullTypesOff() + @"
public class Oblivious { }
";

            var obliviousComp = CreateCompilation(new[] { obliviousLib });
            obliviousComp.VerifyDiagnostics();

            var compilation = CreateCompilation("", options: TestOptions.ReleaseDll,
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference() });
            compilation.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_ValueTypeArgument()
        {
            var source =
NonNullTypesOff() + @"
class A<T> { }
class B
{
    A<byte> P { get; }
}";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();
        }

        [WorkItem(28324, "https://github.com/dotnet/roslyn/issues/28324")]
        [Fact]
        public void NonNullTypes_GenericOverriddenMethod_ValueType()
        {
            var source =
NonNullTypesOff() + @"
class C<T> { }
abstract class A
{
    internal abstract C<T> F<T>() where T : struct;
}
class B : A
{
    internal override C<T> F<T>() => throw null;
}";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();

            var method = comp.GetMember<MethodSymbol>("A.F");
            var typeArg = ((NamedTypeSymbol)method.ReturnType.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0];
            Assert.True(typeArg.IsValueType);
            Assert.Equal(NullableAnnotation.Unknown, typeArg.NullableAnnotation);

            method = comp.GetMember<MethodSymbol>("B.F");
            typeArg = ((NamedTypeSymbol)method.ReturnType.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0];
            Assert.True(typeArg.IsValueType);
            Assert.Equal(NullableAnnotation.Unknown, typeArg.NullableAnnotation);

            // https://github.com/dotnet/roslyn/issues/29843: Test all combinations of base and derived
            // including explicit Nullable<T>.
        }

        // BoundExpression.Type for Task.FromResult(_f[0]) is Task<T!>
        // but the inferred type is Task<T~>.
        [Fact]
        public void CompareUnannotatedAndNonNullableTypeParameter()
        {
            var source =
@"#pragma warning disable 0649
using System.Threading.Tasks;
class C<T>
{
    T[] _f;
    Task<T> F() => Task.FromResult(_f[0]);
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,7): warning CS8618: Non-nullable field '_f' is uninitialized.
                // class C<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "C").WithArguments("field", "_f").WithLocation(3, 7));
        }

        [Fact]
        public void CircularConstraints()
        {
            var source =
@"class A<T> where T : B<T>.I
{
    internal interface I { }
}
class B<T> : A<T> where T : A<T>.I
{
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'NullableContextOptions' value: 'Enable' for C# 7.0. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("NullableContextOptions", "Enable", "7.0", "8.0").WithLocation(1, 1)
                );

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void AssignObliviousIntoLocals()
        {
            var obliviousLib = @"
public class Oblivious
{
    public static string f;
}
";

            var obliviousComp = CreateCompilation(obliviousLib, parseOptions: TestOptions.Regular7);

            var source = @"
class C
{
    void M()
    {
        string s = Oblivious.f;
        s /*T:string*/ .ToString();
        string ns = Oblivious.f;
        ns /*T:string*/ .ToString();
    }
}
";
            // Should a declared type affect an oblivious state? https://github.com/dotnet/roslyn/issues/27686
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8, references: new[] { obliviousComp.EmitToImageReference() });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypesTrue_Foreach()
        {
            var source = @"


class C
{
" + NonNullTypesOn() + @"
    public void M2()
    {
        foreach (string s in Collection())
        {
            s /*T:string!*/ .ToString();
        }

        foreach (string? ns in NCollection())
        {
            ns /*T:string?*/ .ToString(); // 1
        }

        foreach (var s1 in Collection())
        {
            s1 /*T:string!*/ .ToString();
        }

        foreach (var ns1 in NCollection())
        {
            ns1 /*T:string?*/ .ToString(); // 2
        }

        foreach (string s in FalseCollection())
        {
            s /*T:string*/ .ToString();
        }

        foreach (string? ns in FalseNCollection())
        {
            ns /*T:string?*/ .ToString(); // 3
        }

        foreach (var s1 in FalseCollection())
        {
            s1 /*T:string*/ .ToString();
        }

        foreach (var ns1 in FalseNCollection())
        {
            ns1 /*T:string?*/ .ToString(); // 4
        }
    }

" + NonNullTypesOn() + @"
    string[] Collection() => throw null;

" + NonNullTypesOn() + @"
    string?[] NCollection() => throw null;

" + NonNullTypesOff() + @"
    string[] FalseCollection() => throw null;

" + NonNullTypesOff() + @"
    string?[] FalseNCollection() => throw null; // 5
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (60,11): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     string?[] FalseNCollection() => throw null; // 5
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(60, 11),
                // (16,13): warning CS8602: Possible dereference of a null reference.
                //             ns /*T:string?*/ .ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns").WithLocation(16, 13),
                // (26,13): warning CS8602: Possible dereference of a null reference.
                //             ns1 /*T:string?*/ .ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns1").WithLocation(26, 13),
                // (36,13): warning CS8602: Possible dereference of a null reference.
                //             ns /*T:string?*/ .ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns").WithLocation(36, 13),
                // (46,13): warning CS8602: Possible dereference of a null reference.
                //             ns1 /*T:string?*/ .ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns1").WithLocation(46, 13)
                );
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void NonNullTypesFalse_Foreach()
        {
            var source = @"


class C
{
" + NonNullTypesOff() + @"
    public void M2()
    {
        foreach (string s in Collection())
        {
            s /*T:string!*/ .ToString();
        }

        foreach (string? ns in NCollection()) // 1
        {
            ns /*T:string?*/ .ToString();
        }

        foreach (var s1 in Collection())
        {
            s1 /*T:string!*/ .ToString();
        }

        foreach (var ns1 in NCollection())
        {
            ns1 /*T:string?*/ .ToString();
        }

        foreach (string s in FalseCollection())
        {
            s /*T:string*/ .ToString();
        }

        foreach (string? ns in FalseNCollection()) // 2
        {
            ns /*T:string?*/ .ToString();
        }

        foreach (var s1 in FalseCollection())
        {
            s1 /*T:string*/ .ToString();
        }

        foreach (var ns1 in FalseNCollection())
        {
            ns1 /*T:string?*/ .ToString();
        }
    }

" + NonNullTypesOn() + @"
    string[] Collection() => throw null;

" + NonNullTypesOn() + @"
    string?[] NCollection() => throw null;

" + NonNullTypesOff() + @"
    string[] FalseCollection() => throw null;

" + NonNullTypesOff() + @"
    string?[] FalseNCollection() => throw null; // 3
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (60,11): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     string?[] FalseNCollection() => throw null; // 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(60, 11),
                // (14,24): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         foreach (string? ns in NCollection()) // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(14, 24),
                // (34,24): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         foreach (string? ns in FalseNCollection()) // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(34, 24)
                );
        }

        [Fact]
        public void NonNullTypesTrue_OutVars()
        {
            var source = @"


class C
{
" + NonNullTypesOn() + @"
    public void M()
    {
        Out(out string s2);
        s2 /*T:string!*/ .ToString();
        s2 = null; // warn 1

        NOut(out string? ns2);
        ns2 /*T:string?*/ .ToString(); // warn 2
        ns2 = null;

        FalseOut(out string s3);
        s3 /*T:string*/ .ToString();
        s3 = null; // warn 3

        FalseNOut(out string? ns3);
        ns3 /*T:string?*/ .ToString(); // warn 4
        ns3 = null;

        Out(out var s4);
        s4 /*T:string!*/ .ToString();
        s4 = null; // warn 5

        NOut(out var ns4);
        ns4 /*T:string?*/ .ToString(); // warn 6
        ns4 = null;

        FalseOut(out var s5);
        s5 /*T:string*/ .ToString();
        s5 = null;

        FalseNOut(out var ns5);
        ns5 /*T:string?*/ .ToString(); // warn 6
        ns5 = null;
    }

" + NonNullTypesOn() + @"
    void Out(out string s) => throw null;

" + NonNullTypesOn() + @"
    void NOut(out string? ns) => throw null;

" + NonNullTypesOff() + @"
    void FalseOut(out string s) => throw null;

" + NonNullTypesOff() + @"
    void FalseNOut(out string? ns) => throw null; // warn 7
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (52,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     void FalseNOut(out string? ns) => throw null; // warn 7
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(52, 30),
                // (11,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s2 = null; // warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(11, 14),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         ns2 /*T:string?*/ .ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns2").WithLocation(14, 9),
                // (19,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s3 = null; // warn 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(19, 14),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         ns3 /*T:string?*/ .ToString(); // warn 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns3").WithLocation(22, 9),
                // (27,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s4 = null; // warn 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(27, 14),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         ns4 /*T:string?*/ .ToString(); // warn 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns4").WithLocation(30, 9),
                // (38,9): warning CS8602: Possible dereference of a null reference.
                //         ns5 /*T:string?*/ .ToString(); // warn 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns5").WithLocation(38, 9)
                );
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void NonNullTypesFalse_OutVars()
        {
            var source = @"


class C
{
" + NonNullTypesOff() + @"
    public void M()
    {
        Out(out string s2);
        s2 /*T:string!*/ .ToString();
        s2 = null;

        NOut(out string? ns2); // 1
        ns2 /*T:string?*/ .ToString(); // 2
        ns2 = null;

        FalseOut(out string s3);
        s3 /*T:string*/ .ToString();
        s3 = null;

        FalseNOut(out string? ns3); // 3
        ns3 /*T:string?*/ .ToString(); // 4
        ns3 = null;

        Out(out var s4);
        s4 /*T:string!*/ .ToString();
        s4 = null; // 5

        NOut(out var ns4);
        ns4 /*T:string?*/ .ToString(); // 6
        ns4 = null;

        FalseOut(out var s5);
        s5 /*T:string*/ .ToString();
        s5 = null;

        FalseNOut(out var ns5);
        ns5 /*T:string?*/ .ToString(); // 7
        ns5 = null;
    }

" + NonNullTypesOn() + @"
    void Out(out string s) => throw null;

" + NonNullTypesOn() + @"
    void NOut(out string? ns) => throw null;

" + NonNullTypesOff() + @"
    void FalseOut(out string s) => throw null;

" + NonNullTypesOff() + @"
    void FalseNOut(out string? ns) => throw null; // 8
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (52,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     void FalseNOut(out string? ns) => throw null; // 8
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(52, 30),
                // (13,24): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         NOut(out string? ns2); // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 24),
                // (21,29): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         FalseNOut(out string? ns3); // 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(21, 29)
                );
        }

        [Fact]
        public void NonNullTypesTrue_LocalDeclarations()
        {
            var source = @"


" + NonNullTypesOn() + @"
public class C : Base
{
    public void M()
    {
        string s2 = Method();
        s2 /*T:string!*/ .ToString();
        s2 = null; // warn 1

        string? ns2 = NMethod();
        ns2 /*T:string?*/ .ToString(); // warn 2
        ns2 = null;

        string s3 = FalseMethod();
        s3 /*T:string*/ .ToString();
        s3 = null; // warn 3

        string? ns3 = FalseNMethod();
        ns3 /*T:string?*/ .ToString(); // warn 4
        ns3 = null;

        var s4 = Method();
        s4 /*T:string!*/ .ToString();
        s4 = null; // warn 5

        var ns4 = NMethod();
        ns4 /*T:string?*/ .ToString(); // warn 6
        ns4 = null;

        var s5 = FalseMethod();
        s5 /*T:string*/ .ToString();
        s5 = null;

        var ns5 = FalseNMethod();
        ns5 /*T:string?*/ .ToString(); // warn 7
        ns5 = null;
    }
}
public class Base
{
" + NonNullTypesOn() + @"
    public string Method() => throw null;

" + NonNullTypesOn() + @"
    public string? NMethod() => throw null;

" + NonNullTypesOff() + @"
    public string FalseMethod() => throw null;

" + NonNullTypesOff() + @"
    public string? FalseNMethod() => throw null; // warn 8
}
";
            var compilation = CreateCompilation(new[] { source });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (54,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public string? FalseNMethod() => throw null; // warn 8
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(54, 18),
                // (11,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s2 = null; // warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(11, 14),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         ns2 /*T:string?*/ .ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns2").WithLocation(14, 9),
                // (19,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s3 = null; // warn 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(19, 14),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         ns3 /*T:string?*/ .ToString(); // warn 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns3").WithLocation(22, 9),
                // (27,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s4 = null; // warn 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(27, 14),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         ns4 /*T:string?*/ .ToString(); // warn 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns4").WithLocation(30, 9),
                // (38,9): warning CS8602: Possible dereference of a null reference.
                //         ns5 /*T:string?*/ .ToString(); // warn 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "ns5").WithLocation(38, 9)
                );
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void NonNullTypesFalse_LocalDeclarations()
        {
            var source = @"


" + NonNullTypesOff() + @"
public class C : Base
{
    public void M()
    {
        string s2 = Method();
        s2 /*T:string!*/ .ToString();
        s2 = null;

        string? ns2 = NMethod(); // 1
        ns2 /*T:string?*/ .ToString();
        ns2 = null;

        string s3 = FalseMethod();
        s3 /*T:string*/ .ToString();
        s3 = null;

        string? ns3 = FalseNMethod(); // 2
        ns3 /*T:string?*/ .ToString();
        ns3 = null;

        var s4 = Method();
        s4 /*T:string!*/ .ToString();
        s4 = null;

        var ns4 = NMethod();
        ns4 /*T:string?*/ .ToString();
        ns4 = null;

        var s5 = FalseMethod();
        s5 /*T:string*/ .ToString();
        s5 = null;

        var ns5 = FalseNMethod();
        ns5 /*T:string?*/ .ToString();
        ns5 = null;
    }
}
public class Base
{
" + NonNullTypesOn() + @"
    public string Method() => throw null;

" + NonNullTypesOn() + @"
    public string? NMethod() => throw null;

" + NonNullTypesOff() + @"
    public string FalseMethod() => throw null;

" + NonNullTypesOff() + @"
    public string? FalseNMethod() => throw null; // 3
}
";
            var compilation = CreateCompilation(new[] { source });

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (54,18): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public string? FalseNMethod() => throw null; // 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(54, 18),
                // (13,15): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? ns2 = NMethod(); // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 15),
                // (21,15): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         string? ns3 = FalseNMethod(); // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(21, 15)
                );
        }

        [Fact]
        public void NonNullTypes_Constraint()
        {
            var source = @"

public class S { }

" + NonNullTypesOn() + @"
public struct C<T> where T : S
{
    public void M(T t)
    {
        t.ToString();
        t = null; // warn
    }
}

" + NonNullTypesOff() + @"
public struct D<T> where T : S
{
    public void M(T t)
    {
        t.ToString();
        t = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (11,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t = null; // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(11, 13)
                );
        }

        [Fact]
        public void NonNullTypes_Delegate()
        {
            var source = @"


" + NonNullTypesOn() + @"
public delegate string[] MyDelegate(string[] x);

" + NonNullTypesOff() + @"
public delegate string[] MyFalseDelegate(string[] x);
" + NonNullTypesOn() + @"
public delegate string[]? MyNullableDelegate(string[]? x);

class C
{
    void M()
    {
        MyDelegate x1 = Method;
        MyDelegate x2 = FalseMethod;
        MyDelegate x4 = NullableReturnMethod; // warn 1
        MyDelegate x5 = NullableParameterMethod; // warn 2
        MyFalseDelegate y1 = Method;
        MyFalseDelegate y2 = FalseMethod;
        MyFalseDelegate y4 = NullableReturnMethod;
        MyFalseDelegate y5 = NullableParameterMethod;
        MyNullableDelegate z1 = Method; // warn 3
        MyNullableDelegate z2 = FalseMethod;
        MyNullableDelegate z4 = NullableReturnMethod; // warn 4
        MyNullableDelegate z5 = NullableParameterMethod; // warn 5
     }

" + NonNullTypesOn() + @"
    public string[] Method(string[] x) => throw null;

" + NonNullTypesOff() + @"
    public string[] FalseMethod(string[] x) => throw null;
" + NonNullTypesOn() + @"
    public string[]? NullableReturnMethod(string[] x) => throw null;
    public string[] NullableParameterMethod(string[]? x) => throw null;
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (18,25): warning CS8621: Nullability of reference types in return type of 'string[]? C.NullableReturnMethod(string[] x)' doesn't match the target delegate 'MyDelegate'.
                //         MyDelegate x4 = NullableReturnMethod; // warn 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "NullableReturnMethod").WithArguments("string[]? C.NullableReturnMethod(string[] x)", "MyDelegate").WithLocation(18, 25),
                // (24,33): warning CS8622: Nullability of reference types in type of parameter 'x' of 'string[] C.Method(string[] x)' doesn't match the target delegate 'MyNullableDelegate'.
                //         MyNullableDelegate z1 = Method; // warn 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "Method").WithArguments("x", "string[] C.Method(string[] x)", "MyNullableDelegate").WithLocation(24, 33),
                // (26,33): warning CS8622: Nullability of reference types in type of parameter 'x' of 'string[]? C.NullableReturnMethod(string[] x)' doesn't match the target delegate 'MyNullableDelegate'.
                //         MyNullableDelegate z4 = NullableReturnMethod; // warn 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "NullableReturnMethod").WithArguments("x", "string[]? C.NullableReturnMethod(string[] x)", "MyNullableDelegate").WithLocation(26, 33)
                );

            // https://github.com/dotnet/roslyn/issues/29844: Missing warnings 2 and 5
        }

        [Fact]
        public void NonNullTypes_Constructor()
        {
            var source = @"


public class C
{
" + NonNullTypesOn() + @"
    public C(string[] x) => throw null;
}
public class D
{
" + NonNullTypesOff() + @"
    public D(string[] x) => throw null;
}
" + NonNullTypesOn() + @"
public class E
{
    public string[] field = null!;
" + NonNullTypesOff() + @"
    public string[] obliviousField;
" + NonNullTypesOn() + @"
    public string[]? nullableField;

    void M()
    {
        new C(field);
        new C(obliviousField);
        new C(nullableField); // warn
        new D(field);
        new D(obliviousField);
        new D(nullableField);
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (27,15): warning CS8604: Possible null reference argument for parameter 'x' in 'C.C(string[] x)'.
                //         new C(nullableField); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "nullableField").WithArguments("x", "C.C(string[] x)").WithLocation(27, 15)
                );
        }

        [Fact]
        public void NonNullTypes_Constraint_Nested()
        {
            var source = @"

public class S { }
public class List<T> { public T Item { get; set; } = default!; }

" + NonNullTypesOn() + @"
public struct C<T, NT>
    where T : List<S>
    where NT : List<S?>
{
    public void M(T t, NT nt)
    {
        t.Item /*T:S!*/ .ToString();
        t.Item = null; // warn 1
        nt.Item /*T:S?*/ .ToString(); // warn 2
        nt.Item = null;
    }
}

" + NonNullTypesOff() + @"
public struct D<T, NT>
    where T : List<S>
    where NT : List<S?> // warn 3
{
    public void M(T t, NT nt)
    {
        t.Item /*T:S*/ .ToString();
        t.Item = null;
        nt.Item /*T:S?*/ .ToString();
        nt.Item = null;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyTypes();
            compilation.VerifyDiagnostics(
                // (23,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     where NT : List<S?> // warn 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(23, 22),
                // (14,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         t.Item = null; // warn 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(14, 18),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         nt.Item /*T:S?*/ .ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "nt.Item").WithLocation(15, 9)
                );
        }

        [Fact]
        public void IsAnnotated_01()
        {
            var source =
@"using System;

class C1
{
    string F1() => throw null;
    string? F2() => throw null;
    int F3() => throw null;
    int? F4() => throw null;
    Nullable<int> F5() => throw null;
}
" + NonNullTypesOff() + @"
class C2
{
    string F1() => throw null;
    string? F2() => throw null;
    int F3() => throw null;
    int? F4() => throw null;
    Nullable<int> F5() => throw null;
}
" + NonNullTypesOn() + @"
class C3
{
    string F1() => throw null;
    string? F2() => throw null;
    int F3() => throw null;
    int? F4() => throw null;
    Nullable<int> F5() => throw null;
}";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (6,11): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     string? F2() => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 11),
                // (15,11): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     string? F2() => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(15, 11)
                );

            verify("C1.F1", "System.String", NullableAnnotation.Unknown);
            verify("C1.F2", "System.String?", NullableAnnotation.Annotated);
            verify("C1.F3", "System.Int32", NullableAnnotation.Unknown);
            verify("C1.F4", "System.Int32?", NullableAnnotation.Annotated);
            verify("C1.F5", "System.Int32?", NullableAnnotation.Annotated);
            verify("C2.F1", "System.String", NullableAnnotation.Unknown);
            verify("C2.F2", "System.String?", NullableAnnotation.Annotated);
            verify("C2.F3", "System.Int32", NullableAnnotation.Unknown);
            verify("C2.F4", "System.Int32?", NullableAnnotation.Annotated);
            verify("C2.F5", "System.Int32?", NullableAnnotation.Annotated);
            verify("C3.F1", "System.String!", NullableAnnotation.NotAnnotated);
            verify("C3.F2", "System.String?", NullableAnnotation.Annotated);
            verify("C3.F3", "System.Int32", NullableAnnotation.NotAnnotated);
            verify("C3.F4", "System.Int32?", NullableAnnotation.Annotated);
            verify("C3.F5", "System.Int32?", NullableAnnotation.Annotated);

            // https://github.com/dotnet/roslyn/issues/29845: Test nested nullability.

            void verify(string methodName, string displayName, NullableAnnotation nullableAnnotation)
            {
                var method = comp.GetMember<MethodSymbol>(methodName);
                var type = method.ReturnType;
                Assert.Equal(displayName, type.ToTestDisplayString(true));
                Assert.Equal(nullableAnnotation, type.NullableAnnotation);
            }
        }

        [Fact]
        public void IsAnnotated_02()
        {
            var source =
@"using System;

class C1
{
    T F1<T>() => throw null;
    T? F2<T>() => throw null;
    T F3<T>() where T : class => throw null;
    T? F4<T>() where T : class => throw null;
    T F5<T>() where T : struct => throw null;
    T? F6<T>() where T : struct => throw null;
    Nullable<T> F7<T>() where T : struct => throw null;
}
" + NonNullTypesOff() + @"
class C2
{
    T F1<T>() => throw null;
    T? F2<T>() => throw null;
    T F3<T>() where T : class => throw null;
    T? F4<T>() where T : class => throw null;
    T F5<T>() where T : struct => throw null;
    T? F6<T>() where T : struct => throw null;
    Nullable<T> F7<T>() where T : struct => throw null;
}
" + NonNullTypesOn() + @"
class C3
{
    T F1<T>() => throw null;
    T? F2<T>() => throw null;
    T F3<T>() where T : class => throw null;
    T? F4<T>() where T : class => throw null;
    T F5<T>() where T : struct => throw null;
    T? F6<T>() where T : struct => throw null;
    Nullable<T> F7<T>() where T : struct => throw null;
}";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (6,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T? F2<T>() => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(6, 5),
                // (6,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     T? F2<T>() => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 6),
                // (8,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     T? F4<T>() where T : class => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 6),
                // (8,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T? F4<T>() where T : class => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 5),
                // (17,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T? F2<T>() => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(17, 5),
                // (28,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T? F2<T>() => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(28, 5),
                // (17,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     T? F2<T>() => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 6),
                // (19,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     T? F4<T>() where T : class => throw null;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(19, 6),
                // (19,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T? F4<T>() where T : class => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(19, 5)
            );

            verify("C1.F1", "T", NullableAnnotation.Unknown);
            verify("C1.F2", "T?", NullableAnnotation.Annotated);
            verify("C1.F3", "T", NullableAnnotation.Unknown);
            verify("C1.F4", "T?", NullableAnnotation.Annotated);
            verify("C1.F5", "T", NullableAnnotation.Unknown);
            verify("C1.F6", "T?", NullableAnnotation.Annotated);
            verify("C1.F7", "T?", NullableAnnotation.Annotated);
            verify("C2.F1", "T", NullableAnnotation.Unknown);
            verify("C2.F2", "T?", NullableAnnotation.Annotated);
            verify("C2.F3", "T", NullableAnnotation.Unknown);
            verify("C2.F4", "T?", NullableAnnotation.Annotated);
            verify("C2.F5", "T", NullableAnnotation.Unknown);
            verify("C2.F6", "T?", NullableAnnotation.Annotated);
            verify("C2.F7", "T?", NullableAnnotation.Annotated);
            verify("C3.F1", "T", NullableAnnotation.NotAnnotated);
            verify("C3.F2", "T?", NullableAnnotation.Annotated);
            verify("C3.F3", "T!", NullableAnnotation.NotAnnotated);
            verify("C3.F4", "T?", NullableAnnotation.Annotated);
            verify("C3.F5", "T", NullableAnnotation.NotAnnotated);
            verify("C3.F6", "T?", NullableAnnotation.Annotated);
            verify("C3.F7", "T?", NullableAnnotation.Annotated);

            // https://github.com/dotnet/roslyn/issues/29845: Test nested nullability.
            // https://github.com/dotnet/roslyn/issues/29845: Test all combinations of overrides.

            void verify(string methodName, string displayName, NullableAnnotation nullableAnnotation)
            {
                var method = comp.GetMember<MethodSymbol>(methodName);
                var type = method.ReturnType;
                Assert.Equal(displayName, type.ToTestDisplayString(true));
                Assert.Equal(nullableAnnotation, type.NullableAnnotation);
            }
        }

        [Fact]
        public void InheritedValueConstraintForNullable1_01()
        {
            var source = @"
class A
{
    public virtual T? Foo<T>() where T : struct 
    { 
        return null; 
    }
}

class B : A
{
    public override T? Foo<T>()
    {
        return null;
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            //var a = compilation.GetTypeByMetadataName("A");
            //var aFoo = a.GetMember<MethodSymbol>("Foo");
            //Assert.Equal("T? A.Foo<T>()", aFoo.ToTestDisplayString());

            //var b = compilation.GetTypeByMetadataName("B");
            //var bFoo = b.GetMember<MethodSymbol>("Foo");
            //Assert.Equal("T? A.Foo<T>()", bFoo.OverriddenMethod.ToTestDisplayString());

            compilation.VerifyDiagnostics();
        }

        [Fact]
        public void InheritedValueConstraintForNullable1_02()
        {
            var source = @"
class A
{
    public virtual void Foo<T>(T? x) where T : struct 
    { 
    }
}

class B : A
{
    public override void Foo<T>(T? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics();
        }

        [Fact]
        public void InheritedValueConstraintForNullable1_03()
        {
            var source = @"
class A
{
    public virtual System.Nullable<T> Foo<T>() where T : struct 
    { 
        return null; 
    }
}

class B : A
{
    public override T? Foo<T>()
    {
        return null;
    }
} 
";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void InheritedValueConstraintForNullable1_04()
        {
            var source = @"
class A
{
    public virtual void Foo<T>(System.Nullable<T> x) where T : struct 
    { 
    }
}

class B : A
{
    public override void Foo<T>(T? x)
    {
    }
} 
";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void InheritedValueConstraintForNullable1_05()
        {
            var source = @"
class A
{
    public virtual T? Foo<T>() where T : struct 
    { 
        return null; 
    }
}

class B : A
{
    public override System.Nullable<T> Foo<T>()
    {
        return null;
    }
} 
";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void InheritedValueConstraintForNullable1_06()
        {
            var source = @"
class A
{
    public virtual void M1<T>(T? x) where T : struct 
    { 
    }
}

class B : A
{
    public override void M1<T>(System.Nullable<T> x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics();

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.True(m1.Parameters[0].Type.IsNullableType());
            Assert.True(m1.Parameters[0].Type.IsValueType);
            Assert.True(m1.OverriddenMethod.Parameters[0].Type.IsNullableType());
        }

        [Fact]
        public void Overriding_03()
        {
            var source = @"
class A
{
    public virtual void M1<T>(T? x) where T : class 
    { 
    }

    public virtual T? M2<T>() where T : class 
    { 
        return null;
    }
}

class B : A
{
    public override void M1<T>(T? x)
    {
    }

    public override T? M2<T>()
    { 
        return null;
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics();

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.False(m1.Parameters[0].Type.IsNullableType());
            Assert.Equal(NullableAnnotation.Annotated, m1.Parameters[0].Type.NullableAnnotation);
            Assert.True(m1.Parameters[0].Type.IsReferenceType);
            Assert.False(m1.OverriddenMethod.Parameters[0].Type.IsNullableType());

            var m2 = b.GetMember<MethodSymbol>("M2");
            Assert.False(m2.ReturnType.IsNullableType());
            Assert.Equal(NullableAnnotation.Annotated, m2.ReturnType.NullableAnnotation);
            Assert.True(m2.ReturnType.IsReferenceType);
            Assert.False(m2.OverriddenMethod.ReturnType.IsNullableType());
        }

        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29846 : Override matches other M3<T>.")]
        [WorkItem(29846, "https://github.com/dotnet/roslyn/issues/29846")]
        public void Overriding_04()
        {
            var source = @"
class A
{
    public virtual void M1<T>(T? x) where T : struct 
    { 
    }

    public virtual void M1<T>(T x) 
    { 
    }

    public virtual void M2<T>(T? x) where T : struct 
    { 
    }

    public virtual void M2<T>(T x) 
    { 
    }

    public virtual void M3<T>(T x) 
    { 
    }

    public virtual void M3<T>(T? x) where T : struct 
    { 
    }
}

class B : A
{
    public override void M1<T>(T? x)
    {
    }

    public override void M2<T>(T x)
    {
    }

    public override void M3<T>(T? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.True(m1.Parameters[0].Type.IsNullableType());
            Assert.True(m1.OverriddenMethod.Parameters[0].Type.IsNullableType());

            var m2 = b.GetMember<MethodSymbol>("M2");
            Assert.False(m2.Parameters[0].Type.IsNullableType());
            Assert.False(m2.OverriddenMethod.Parameters[0].Type.IsNullableType());

            var m3 = b.GetMember<MethodSymbol>("M3");
            Assert.True(m3.Parameters[0].Type.IsNullableType());
            Assert.True(m3.OverriddenMethod.Parameters[0].Type.IsNullableType());
        }

        [Fact]
        [WorkItem(29847, "https://github.com/dotnet/roslyn/issues/29847")]
        public void Overriding_05()
        {
            var source = @"
class A
{
    public virtual void M1<T>(T? x) where T : struct 
    { 
    }

    public virtual void M1<T>(T? x) where T : class 
    { 
    }
}

class B : A
{
    public override void M1<T>(T? x)
    {
    }
} 

class C
{
    public virtual void M2<T>(T? x) where T : class 
    { 
    }

    public virtual void M2<T>(T? x) where T : struct 
    { 
    }
}

class D : C
{
    public override void M2<T>(T? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29847: The overriding is ambiguous.
            // We simply matched the first candidate. Should this be an error?
            compilation.VerifyDiagnostics();

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.True(m1.Parameters[0].Type.IsNullableType());
            Assert.True(m1.OverriddenMethod.Parameters[0].Type.IsNullableType());

            var d = compilation.GetTypeByMetadataName("D");
            var m2 = d.GetMember<MethodSymbol>("M2");
            Assert.False(m2.Parameters[0].Type.IsNullableType());
            Assert.False(m2.OverriddenMethod.Parameters[0].Type.IsNullableType());
        }

        [Fact]
        public void Overriding_06()
        {
            var source = @"
class A
{
    public virtual void M1<T>(System.Nullable<T> x) where T : struct
    {
    }

    public virtual void M2<T>(T? x) where T : struct
    {
    }

    public virtual void M3<T>(C<T?> x) where T : struct
    {
    }

    public virtual void M4<T>(C<System.Nullable<T>> x) where T : struct
    {
    }

    public virtual void M5<T>(C<T?> x) where T : class
    {
    }
}

class B : A
{
    public override void M1<T>(T? x)
    {
    }

    public override void M2<T>(T? x)
    {
    }

    public override void M3<T>(C<T?> x)
    {
    }

    public override void M4<T>(C<T?> x)
    {
    }

    public override void M5<T>(C<T?> x)
    {
    }
}

class C<T> {}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics();

            var b = compilation.GetTypeByMetadataName("B");
            var m3 = b.GetMember<MethodSymbol>("M3");
            var m4 = b.GetMember<MethodSymbol>("M4");
            var m5 = b.GetMember<MethodSymbol>("M5");
            Assert.True(((NamedTypeSymbol)m3.Parameters[0].Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
            Assert.True(((NamedTypeSymbol)m3.OverriddenMethod.Parameters[0].Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
            Assert.True(((NamedTypeSymbol)m4.Parameters[0].Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
            Assert.True(((NamedTypeSymbol)m4.OverriddenMethod.Parameters[0].Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
            Assert.False(((NamedTypeSymbol)m5.Parameters[0].Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
            Assert.False(((NamedTypeSymbol)m5.OverriddenMethod.Parameters[0].Type.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
        }

        [Fact]
        public void Overriding_07()
        {
            var source = @"
class A
{
    public void M1<T>(T x) 
    {
    }
}

class B : A
{
    public void M1<T>(T? x) where T : struct
    {
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics();

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.True(m1.Parameters[0].Type.IsNullableType());
            Assert.True(m1.Parameters[0].Type.TypeSymbol.StrippedType().IsValueType);
            Assert.Null(m1.OverriddenMethod);
        }

        [Fact]
        public void Overriding_08()
        {
            var source = @"
class A
{
    public void M1<T>(T x) 
    {
    }
}

class B : A
{
    public override void M1<T>(T? x) where T : struct
    {
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (11,38): error CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly
                //     public override void M1<T>(T? x) where T : struct
                Diagnostic(ErrorCode.ERR_OverrideWithConstraints, "where").WithLocation(11, 38),
                // (11,26): error CS0506: 'B.M1<T>(T?)': cannot override inherited member 'A.M1<T>(T)' because it is not marked virtual, abstract, or override
                //     public override void M1<T>(T? x) where T : struct
                Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M1").WithArguments("B.M1<T>(T?)", "A.M1<T>(T)").WithLocation(11, 26),
                // (11,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override void M1<T>(T? x) where T : struct
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(11, 32)
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.False(m1.Parameters[0].Type.IsNullableType());
            Assert.False(m1.Parameters[0].Type.TypeSymbol.StrippedType().IsValueType);
            Assert.False(m1.Parameters[0].Type.TypeSymbol.StrippedType().IsReferenceType);
            Assert.Null(m1.OverriddenMethod);
        }

        [Fact]
        public void Overriding_09()
        {
            var source = @"
class A
{
    public void M1<T>(T x) 
    {
    }

    public void M2<T>(T? x) 
    {
    }

    public void M3<T>(T? x) where T : class
    {
    }

    public void M4<T>(T? x) where T : struct
    {
    }
}

class B : A
{
    public override void M1<T>(T? x)
    {
    }

    public override void M2<T>(T? x)
    {
    }

    public override void M3<T>(T? x)
    {
    }

    public override void M4<T>(T? x)
    {
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (8,23): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void M2<T>(T? x)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 23),
                // (27,26): error CS0506: 'B.M2<T>(T?)': cannot override inherited member 'A.M2<T>(T?)' because it is not marked virtual, abstract, or override
                //     public override void M2<T>(T? x)
                Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M2").WithArguments("B.M2<T>(T?)", "A.M2<T>(T?)").WithLocation(27, 26),
                // (31,26): error CS0506: 'B.M3<T>(T?)': cannot override inherited member 'A.M3<T>(T?)' because it is not marked virtual, abstract, or override
                //     public override void M3<T>(T? x)
                Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M3").WithArguments("B.M3<T>(T?)", "A.M3<T>(T?)").WithLocation(31, 26),
                // (35,26): error CS0506: 'B.M4<T>(T?)': cannot override inherited member 'A.M4<T>(T?)' because it is not marked virtual, abstract, or override
                //     public override void M4<T>(T? x)
                Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M4").WithArguments("B.M4<T>(T?)", "A.M4<T>(T?)").WithLocation(35, 26),
                // (23,26): error CS0506: 'B.M1<T>(T?)': cannot override inherited member 'A.M1<T>(T)' because it is not marked virtual, abstract, or override
                //     public override void M1<T>(T? x)
                Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M1").WithArguments("B.M1<T>(T?)", "A.M1<T>(T)").WithLocation(23, 26),
                // (23,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override void M1<T>(T? x)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(23, 32),
                // (27,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override void M2<T>(T? x)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(27, 32),
                // (31,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override void M3<T>(T? x)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(31, 32),
                // (35,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override void M4<T>(T? x)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(35, 32)
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            var m2 = b.GetMember<MethodSymbol>("M2");
            var m3 = b.GetMember<MethodSymbol>("M3");
            var m4 = b.GetMember<MethodSymbol>("M4");
            Assert.False(m1.Parameters[0].Type.IsNullableType());
            Assert.False(m2.Parameters[0].Type.IsNullableType());
            Assert.False(m3.Parameters[0].Type.IsNullableType());
            Assert.False(m4.Parameters[0].Type.IsNullableType());

            Assert.Null(m1.OverriddenMethod);
            Assert.Null(m2.OverriddenMethod);
            Assert.Null(m3.OverriddenMethod);
            Assert.Null(m4.OverriddenMethod);
        }

        [Fact]
        public void Overriding_10()
        {
            var source = @"
class A
{
    public virtual void M1<T>(System.Nullable<T> x) where T : class
    { 
    }
}

class B : A
{
    public override void M1<T>(T? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (4,50): error CS0453: The type 'T' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                //     public virtual void M1<T>(System.Nullable<T> x) where T : class
                Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "x").WithArguments("System.Nullable<T>", "T", "T").WithLocation(4, 50),
                // (11,26): error CS0115: 'B.M1<T>(T?)': no suitable method found to override
                //     public override void M1<T>(T? x)
                Diagnostic(ErrorCode.ERR_OverrideNotExpected, "M1").WithArguments("B.M1<T>(T?)").WithLocation(11, 26),
                // (11,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override void M1<T>(T? x)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(11, 32)
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.False(m1.Parameters[0].Type.IsNullableType());
            Assert.Null(m1.OverriddenMethod);
        }

        [Fact]
        public void Overriding_11()
        {
            var source = @"
class A
{
    public virtual C<System.Nullable<T>> M1<T>() where T : class
    { 
        throw new System.NotImplementedException();
    }
}

class B : A
{
    public override C<T?> M1<T>()
    {
        throw new System.NotImplementedException();
    }
} 

class C<T> {}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                 // (4,42): error CS0453: The type 'T' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                 //     public virtual C<System.Nullable<T>> M1<T>() where T : class
                 Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M1").WithArguments("System.Nullable<T>", "T", "T").WithLocation(4, 42),
                 // (12,27): error CS0508: 'B.M1<T>()': return type must be 'C<T?>' to match overridden member 'A.M1<T>()'
                 //     public override C<T?> M1<T>()
                 Diagnostic(ErrorCode.ERR_CantChangeReturnTypeOnOverride, "M1").WithArguments("B.M1<T>()", "A.M1<T>()", "C<T?>").WithLocation(12, 27)
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.False(((NamedTypeSymbol)m1.ReturnType.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
            Assert.True(((NamedTypeSymbol)m1.OverriddenMethod.ReturnType.TypeSymbol).TypeArgumentsNoUseSiteDiagnostics[0].IsNullableType());
        }

        [Fact]
        public void Overriding_12()
        {
            var source = @"
class A
{
    public virtual string M1()
    { 
        throw new System.NotImplementedException();
    }

    public virtual string? M2()
    { 
        throw new System.NotImplementedException();
    }

    public virtual string? M3()
    { 
        throw new System.NotImplementedException();
    }

    public virtual System.Nullable<string> M4()
    { 
        throw new System.NotImplementedException();
    }

    public System.Nullable<string> M5()
    { 
        throw new System.NotImplementedException();
    }
}

class B : A
{
    public override string? M1()
    {
        throw new System.NotImplementedException();
    }

    public override string? M2()
    {
        throw new System.NotImplementedException();
    }

    public override string M3()
    {
        throw new System.NotImplementedException();
    }

    public override string? M4()
    {
        throw new System.NotImplementedException();
    }

    public override string? M5()
    {
        throw new System.NotImplementedException();
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                 // (32,29): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override string? M1()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M1").WithLocation(32, 29),
                 // (42,28): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override string M3()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M3").WithLocation(42, 28),
                 // (47,29): error CS0508: 'B.M4()': return type must be 'string?' to match overridden member 'A.M4()'
                 //     public override string? M4()
                 Diagnostic(ErrorCode.ERR_CantChangeReturnTypeOnOverride, "M4").WithArguments("B.M4()", "A.M4()", "string?").WithLocation(47, 29),
                 // (52,29): error CS0506: 'B.M5()': cannot override inherited member 'A.M5()' because it is not marked virtual, abstract, or override
                 //     public override string? M5()
                 Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M5").WithArguments("B.M5()", "A.M5()").WithLocation(52, 29),
                 // (19,44): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                 //     public virtual System.Nullable<string> M4()
                 Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M4").WithArguments("System.Nullable<T>", "T", "string").WithLocation(19, 44),
                 // (24,36): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                 //     public System.Nullable<string> M5()
                 Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "M5").WithArguments("System.Nullable<T>", "T", "string").WithLocation(24, 36)
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.False(m1.ReturnType.IsNullableType());
            Assert.False(m1.OverriddenMethod.ReturnType.IsNullableType());

            var m4 = b.GetMember<MethodSymbol>("M4");
            Assert.False(m4.ReturnType.IsNullableType());
            Assert.True(m4.OverriddenMethod.ReturnType.IsNullableType());

            var m5 = b.GetMember<MethodSymbol>("M4");
            Assert.False(m5.ReturnType.IsNullableType());
        }

        [Fact]
        public void Overriding_13()
        {
            var source = @"
class A
{
    public virtual void M1(string x)
    { 
    }

    public virtual void M2(string? x)
    { 
    }

    public virtual void M3(string? x)
    { 
    }

    public virtual void M4(System.Nullable<string> x)
    { 
    }

    public void M5(System.Nullable<string> x)
    { 
    }
}

class B : A
{
    public override void M1(string? x)
    {
    }

    public override void M2(string? x)
    {
    }

    public override void M3(string x)
    {
    }

    public override void M4(string? x)
    {
    }

    public override void M5(string? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (27,26): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                 //     public override void M1(string? x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M1").WithArguments("x").WithLocation(27, 26),
                 // (35,26): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                 //     public override void M3(string x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M3").WithArguments("x").WithLocation(35, 26),
                 // (39,26): error CS0115: 'B.M4(string)': no suitable method found to override
                 //     public override void M4(string? x)
                 Diagnostic(ErrorCode.ERR_OverrideNotExpected, "M4").WithArguments("B.M4(string?)").WithLocation(39, 26),
                 // (43,26): error CS0115: 'B.M5(string)': no suitable method found to override
                 //     public override void M5(string? x)
                 Diagnostic(ErrorCode.ERR_OverrideNotExpected, "M5").WithArguments("B.M5(string?)").WithLocation(43, 26),
                 // (16,52): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                 //     public virtual void M4(System.Nullable<string> x)
                 Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "x").WithArguments("System.Nullable<T>", "T", "string").WithLocation(16, 52),
                 // (20,44): error CS0453: The type 'string' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                 //     public void M5(System.Nullable<string> x)
                 Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "x").WithArguments("System.Nullable<T>", "T", "string").WithLocation(20, 44)
                );

            var b = compilation.GetTypeByMetadataName("B");
            var m1 = b.GetMember<MethodSymbol>("M1");
            Assert.False(m1.Parameters[0].Type.IsNullableType());
            Assert.Equal(NullableAnnotation.Annotated, m1.Parameters[0].Type.NullableAnnotation);
            Assert.True(m1.Parameters[0].Type.IsReferenceType);
            Assert.False(m1.OverriddenMethod.Parameters[0].Type.IsNullableType());

            var m4 = b.GetMember<MethodSymbol>("M4");
            Assert.False(m4.Parameters[0].Type.IsNullableType());
            Assert.Null(m4.OverriddenMethod);

            var m5 = b.GetMember<MethodSymbol>("M4");
            Assert.False(m5.Parameters[0].Type.IsNullableType());
        }

        [Fact]
        public void Overriding_14()
        {
            var source = @"
class A
{
    public virtual int M1()
    { 
        throw new System.NotImplementedException();
    }

    public virtual int? M2()
    { 
        throw new System.NotImplementedException();
    }

    public virtual int? M3()
    { 
        throw new System.NotImplementedException();
    }

    public virtual System.Nullable<int> M4()
    { 
        throw new System.NotImplementedException();
    }

    public System.Nullable<int> M5()
    { 
        throw new System.NotImplementedException();
    }
}

class B : A
{
    public override int? M1()
    {
        throw new System.NotImplementedException();
    }

    public override int? M2()
    {
        throw new System.NotImplementedException();
    }

    public override int M3()
    {
        throw new System.NotImplementedException();
    }

    public override int? M4()
    {
        throw new System.NotImplementedException();
    }

    public override int? M5()
    {
        throw new System.NotImplementedException();
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                 // (42,25): error CS0508: 'B.M3()': return type must be 'int?' to match overridden member 'A.M3()'
                 //     public override int M3()
                 Diagnostic(ErrorCode.ERR_CantChangeReturnTypeOnOverride, "M3").WithArguments("B.M3()", "A.M3()", "int?").WithLocation(42, 25),
                 // (52,26): error CS0506: 'B.M5()': cannot override inherited member 'A.M5()' because it is not marked virtual, abstract, or override
                 //     public override int? M5()
                 Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M5").WithArguments("B.M5()", "A.M5()").WithLocation(52, 26),
                 // (32,26): error CS0508: 'B.M1()': return type must be 'int' to match overridden member 'A.M1()'
                 //     public override int? M1()
                 Diagnostic(ErrorCode.ERR_CantChangeReturnTypeOnOverride, "M1").WithArguments("B.M1()", "A.M1()", "int").WithLocation(32, 26)
                );

            var b = compilation.GetTypeByMetadataName("B");
            Assert.True(b.GetMember<MethodSymbol>("M1").ReturnType.IsNullableType());
            Assert.True(b.GetMember<MethodSymbol>("M2").ReturnType.IsNullableType());
            Assert.False(b.GetMember<MethodSymbol>("M3").ReturnType.IsNullableType());
            Assert.True(b.GetMember<MethodSymbol>("M4").ReturnType.IsNullableType());
            Assert.True(b.GetMember<MethodSymbol>("M5").ReturnType.IsNullableType());
        }

        [Fact]
        public void Overriding_15()
        {
            var source = @"
class A
{
    public virtual void M1(int x)
    { 
    }

    public virtual void M2(int? x)
    { 
    }

    public virtual void M3(int? x)
    { 
    }

    public virtual void M4(System.Nullable<int> x)
    { 
    }

    public void M5(System.Nullable<int> x)
    { 
    }
}

class B : A
{
    public override void M1(int? x)
    {
    }

    public override void M2(int? x)
    {
    }

    public override void M3(int x)
    {
    }

    public override void M4(int? x)
    {
    }

    public override void M5(int? x)
    {
    }
} 
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (35,26): error CS0115: 'B.M3(int)': no suitable method found to override
                 //     public override void M3(int x)
                 Diagnostic(ErrorCode.ERR_OverrideNotExpected, "M3").WithArguments("B.M3(int)").WithLocation(35, 26),
                 // (43,26): error CS0506: 'B.M5(int?)': cannot override inherited member 'A.M5(int?)' because it is not marked virtual, abstract, or override
                 //     public override void M5(int? x)
                 Diagnostic(ErrorCode.ERR_CantOverrideNonVirtual, "M5").WithArguments("B.M5(int?)", "A.M5(int?)").WithLocation(43, 26),
                 // (27,26): error CS0115: 'B.M1(int?)': no suitable method found to override
                 //     public override void M1(int? x)
                 Diagnostic(ErrorCode.ERR_OverrideNotExpected, "M1").WithArguments("B.M1(int?)").WithLocation(27, 26)
                );

            var b = compilation.GetTypeByMetadataName("B");
            Assert.True(b.GetMember<MethodSymbol>("M1").Parameters[0].Type.IsNullableType());
            Assert.True(b.GetMember<MethodSymbol>("M2").Parameters[0].Type.IsNullableType());
            Assert.False(b.GetMember<MethodSymbol>("M3").Parameters[0].Type.IsNullableType());
            Assert.True(b.GetMember<MethodSymbol>("M4").Parameters[0].Type.IsNullableType());
            Assert.True(b.GetMember<MethodSymbol>("M5").Parameters[0].Type.IsNullableType());
        }

        [Fact]
        public void Overriding_16()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

abstract class A
{
    public abstract event System.Action<string> E1; 
    public abstract event System.Action<string>? E2; 
    public abstract event System.Action<string?>? E3; 
}

class B1 : A
{
    public override event System.Action<string?> E1 {add {} remove{}}
    public override event System.Action<string> E2 {add {} remove{}}
    public override event System.Action<string?>? E3 {add {} remove{}}
}

class B2 : A
{
    public override event System.Action<string?> E1; // 2
    public override event System.Action<string> E2; // 2
    public override event System.Action<string?>? E3; // 2

    void Dummy()
    {
        var e1 = E1;
        var e2 = E2;
        var e3 = E3;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (19,49): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override event System.Action<string> E2;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "E2").WithLocation(19, 49),
                 // (18,50): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override event System.Action<string?> E1;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "E1").WithLocation(18, 50),
                 // (26,49): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override event System.Action<string> E2; // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "E2").WithLocation(26, 49),
                 // (25,50): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override event System.Action<string?> E1; // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "E1").WithLocation(25, 50)
                );

            foreach (string typeName in new[] { "B1", "B2" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (string memberName in new[] { "E1", "E2" })
                {
                    var member = type.GetMember<EventSymbol>(memberName);
                    Assert.False(member.Type.Equals(member.OverriddenEvent.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
                }

                var e3 = type.GetMember<EventSymbol>("E3");
                Assert.True(e3.Type.Equals(e3.OverriddenEvent.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "A", "B1", "B2" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var ev in type.GetMembers().OfType<EventSymbol>())
                {
                    Assert.True(ev.Type.Equals(ev.AddMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                    Assert.True(ev.Type.Equals(ev.RemoveMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        [WorkItem(29851, "https://github.com/dotnet/roslyn/issues/29851")]
        public void Overriding_Methods()
        {
            var source = @"

public abstract class A
{
" + NonNullTypesOff() + @"
    public abstract System.Action<string> Oblivious1(System.Action<string> x);
" + NonNullTypesOn() + @"

    public abstract System.Action<string> Oblivious2(System.Action<string> x);
    public abstract System.Action<string> M3(System.Action<string> x);
    public abstract System.Action<string> M4(System.Action<string> x);
    public abstract System.Action<string>? M5(System.Action<string>? x);
}

public class B1 : A
{
    public override System.Action<string?> Oblivious1(System.Action<string?> x) => throw null;
    public override System.Action<string?> Oblivious2(System.Action<string?> x) => throw null; // warn 3 and 4 // https://github.com/dotnet/roslyn/issues/29851: Should not warn
    public override System.Action<string?> M3(System.Action<string?> x) => throw null; // warn 5 and 6
    public override System.Action<string?> M4(System.Action<string?> x) => throw null; // warn 7 and 8
    public override System.Action<string?> M5(System.Action<string?> x) => throw null; // warn 9 and 10
}

public class B2 : A
{

    public override System.Action<string> Oblivious1(System.Action<string> x) => throw null;
    public override System.Action<string> Oblivious2(System.Action<string> x) => throw null;
" + NonNullTypesOff() + @"
    public override System.Action<string> M3(System.Action<string> x) => throw null;
" + NonNullTypesOn() + @"

    public override System.Action<string> M4(System.Action<string> x) => throw null;
" + NonNullTypesOff() + @"
    public override System.Action<string> M5(System.Action<string> x) => throw null;
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (18,44): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                //     public override System.Action<string?> Oblivious2(System.Action<string?> x) => throw null; // warn 3 and 4 // https://github.com/dotnet/roslyn/issues/29851: Should not warn
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "Oblivious2").WithLocation(18, 44),
                // (18,44): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                //     public override System.Action<string?> Oblivious2(System.Action<string?> x) => throw null; // warn 3 and 4 // https://github.com/dotnet/roslyn/issues/29851: Should not warn
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "Oblivious2").WithArguments("x").WithLocation(18, 44),
                // (19,44): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                //     public override System.Action<string?> M3(System.Action<string?> x) => throw null; // warn 5 and 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M3").WithLocation(19, 44),
                // (19,44): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                //     public override System.Action<string?> M3(System.Action<string?> x) => throw null; // warn 5 and 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M3").WithArguments("x").WithLocation(19, 44),
                // (20,44): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                //     public override System.Action<string?> M4(System.Action<string?> x) => throw null; // warn 7 and 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M4").WithLocation(20, 44),
                // (20,44): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                //     public override System.Action<string?> M4(System.Action<string?> x) => throw null; // warn 7 and 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M4").WithArguments("x").WithLocation(20, 44),
                // (21,44): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                //     public override System.Action<string?> M5(System.Action<string?> x) => throw null; // warn 9 and 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M5").WithLocation(21, 44),
                // (21,44): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                //     public override System.Action<string?> M5(System.Action<string?> x) => throw null; // warn 9 and 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M5").WithArguments("x").WithLocation(21, 44)
                );

            var b1 = compilation.GetTypeByMetadataName("B1");
            verifyMethodMatchesOverridden(expectMatch: false, b1, "Oblivious1");
            verifyMethodMatchesOverridden(expectMatch: false, b1, "Oblivious2");
            verifyMethodMatchesOverridden(expectMatch: false, b1, "M3");
            verifyMethodMatchesOverridden(expectMatch: false, b1, "M4");
            verifyMethodMatchesOverridden(expectMatch: false, b1, "M5");

            var b2 = compilation.GetTypeByMetadataName("B2");
            verifyMethodMatchesOverridden(expectMatch: false, b2, "Oblivious1"); // https://github.com/dotnet/roslyn/issues/29851: They should match
            verifyMethodMatchesOverridden(expectMatch: true, b2, "Oblivious2"); // https://github.com/dotnet/roslyn/issues/29851: They should not match
            verifyMethodMatchesOverridden(expectMatch: false, b2, "M3");
            verifyMethodMatchesOverridden(expectMatch: true, b2, "M4"); // https://github.com/dotnet/roslyn/issues/29851: They should not match
            verifyMethodMatchesOverridden(expectMatch: false, b2, "M5");

            void verifyMethodMatchesOverridden(bool expectMatch, NamedTypeSymbol type, string methodName)
            {
                var member = type.GetMember<MethodSymbol>(methodName);
                Assert.Equal(expectMatch, member.ReturnType.Equals(member.OverriddenMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                Assert.Equal(expectMatch, member.Parameters.Single().Type.Equals(member.OverriddenMethod.Parameters.Single().Type, TypeCompareKind.ConsiderEverything));
            }
        }

        [Fact]
        public void Overriding_Properties_WithNullableTypeArgument()
        {
            var source = @"

" + NonNullTypesOn() + @"
public class List<T> { }
public class Base<T>
{
    public virtual List<T?> P { get; set; } = default;
}
public class Class<T> : Base<T>
{
" + NonNullTypesOff() + @"
    public override List<T?> P { get; set; } = default;
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (7,25): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public virtual List<T?> P { get; set; } = default;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 25),
                // (7,47): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     public virtual List<T?> P { get; set; } = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(7, 47),
                // (12,26): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public override List<T?> P { get; set; } = default;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(12, 26),
                // (12,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override List<T?> P { get; set; } = default;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(12, 27)
                );
        }

        [Fact]
        public void Overriding_Properties_WithNullableTypeArgument_WithClassConstraint()
        {
            var source = @"

" + NonNullTypesOn() + @"
public class List<T> { }
public class Base<T> where T : class
{
    public virtual List<T?> P { get; set; } = default;
}
public class Class<T> : Base<T> where T : class
{
" + NonNullTypesOff() + @"
    public override List<T?> P { get; set; } = default;
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (7,47): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     public virtual List<T?> P { get; set; } = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(7, 47),
                // (12,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override List<T?> P { get; set; } = default;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(12, 27)
                );
        }

        [Fact]
        public void Overriding_Properties_WithNullableTypeArgument_WithStructConstraint()
        {
            var source = @"

public class List<T> { }
public class Base<T> where T : struct
{
    public virtual List<T?> P { get; set; } = default;
}
public class Class<T> : Base<T> where T : struct
{
" + NonNullTypesOff() + @"
    public override List<T?> P { get; set; } = default;
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,47): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     public virtual List<T?> P { get; set; } = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(6, 47));
        }

        [Fact]
        public void Overriding_Indexer()
        {
            var source = @"
public class List<T> { }
public class Base
{
    public virtual List<string[]> this[List<string[]> x] { get => throw null; set => throw null; }
}
public class Class : Base
{
" + NonNullTypesOff() + @"
    public override List<string[]> this[List<string[]> x] { get => throw null; set => throw null; }
}
public class Class2 : Base {
" + NonNullTypesOn() + @"
    public override List<string[]> this[List<string[]> x] { get => throw null; set => throw null; }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Overriding_Indexer2()
        {
            var source = @"

" + NonNullTypesOn() + @"
public class List<T> { }
public class Oblivious
{
" + NonNullTypesOff() + @"
    public virtual List<string[]> this[List<string[]> x] { get => throw null; set => throw null; }
}
" + NonNullTypesOn() + @"
public class Class : Oblivious
{
    public override List<string[]> this[List<string[]> x] { get => throw null; set => throw null; }
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Overriding_21()
        {
            var source = @"

class C
{
    public static void Main()
    { 
    }
}

abstract class A
{
    public abstract event System.Action<string> E1; 
    public abstract event System.Action<string>? E2; 
}

class B1 : A
{
" + NonNullTypesOff() + @"
    public override event System.Action<string?> E1 {add {} remove{}} // 1, 2
" + NonNullTypesOff() + @"
    public override event System.Action<string> E2 {add {} remove{}}
}
" + NonNullTypesOn() + @"
class B2 : A
{
" + NonNullTypesOff() + @"
    public override event System.Action<string?> E1; // 3, 4
" + NonNullTypesOff() + @"
    public override event System.Action<string> E2;
" + NonNullTypesOn() + @"
    void Dummy()
    {
        var e1 = E1;
        var e2 = E2;
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (19,50): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                //     public override event System.Action<string?> E1 {add {} remove{}} // 1, 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "E1").WithLocation(19, 50),
                // (27,50): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                //     public override event System.Action<string?> E1; // 3, 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "E1").WithLocation(27, 50),
                // (27,47): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override event System.Action<string?> E1; // 3, 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(27, 47),
                // (19,47): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override event System.Action<string?> E1 {add {} remove{}} // 1, 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(19, 47)
                );
        }

        [Fact]
        public void Implementing_01()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

interface IA
{
    event System.Action<string> E1; 
    event System.Action<string>? E2; 
    event System.Action<string?>? E3; 
}

class B1 : IA
{
    public event System.Action<string?> E1 {add {} remove{}}
    public event System.Action<string> E2 {add {} remove{}}
    public event System.Action<string?>? E3 {add {} remove{}}
}

class B2 : IA
{
    public event System.Action<string?> E1; // 2
    public event System.Action<string> E2; // 2
    public event System.Action<string?>? E3; // 2

    void Dummy()
    {
        var e1 = E1;
        var e2 = E2;
        var e3 = E3;
    }
}

";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (26,40): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'event Action<string>? IA.E2'.
                 //     public event System.Action<string> E2; // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "E2").WithArguments("event Action<string>? IA.E2").WithLocation(26, 40),
                 // (25,41): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'event Action<string> IA.E1'.
                 //     public event System.Action<string?> E1; // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "E1").WithArguments("event Action<string> IA.E1").WithLocation(25, 41),
                 // (19,40): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'event Action<string>? IA.E2'.
                 //     public event System.Action<string> E2 {add {} remove{}}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "E2").WithArguments("event Action<string>? IA.E2").WithLocation(19, 40),
                 // (18,41): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'event Action<string> IA.E1'.
                 //     public event System.Action<string?> E1 {add {} remove{}}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "E1").WithArguments("event Action<string> IA.E1").WithLocation(18, 41)
                );

            var ia = compilation.GetTypeByMetadataName("IA");

            foreach (string memberName in new[] { "E1", "E2" })
            {
                var member = ia.GetMember<EventSymbol>(memberName);

                foreach (string typeName in new[] { "B1", "B2" })
                {
                    var type = compilation.GetTypeByMetadataName(typeName);

                    var impl = (EventSymbol)type.FindImplementationForInterfaceMember(member);
                    Assert.False(impl.Type.Equals(member.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
                }
            }

            var e3 = ia.GetMember<EventSymbol>("E3");

            foreach (string typeName in new[] { "B1", "B2" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                var impl = (EventSymbol)type.FindImplementationForInterfaceMember(e3);
                Assert.True(impl.Type.Equals(e3.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "IA", "B1", "B2" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var ev in type.GetMembers().OfType<EventSymbol>())
                {
                    Assert.True(ev.Type.Equals(ev.AddMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                    Assert.True(ev.Type.Equals(ev.RemoveMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Implementing_02()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

interface IA
{
    event System.Action<string> E1; 
    event System.Action<string>? E2; 
    event System.Action<string?>? E3; 
}

class B1 : IA
{
    event System.Action<string?> IA.E1 {add {} remove{}}
    event System.Action<string> IA.E2 {add {} remove{}}
    event System.Action<string?>? IA.E3 {add {} remove{}}
}

interface IB
{
    //event System.Action<string> E1; 
    //event System.Action<string>? E2; 
    event System.Action<string?>? E3; 
}

class B2 : IB
{
    //event System.Action<string?> IB.E1; // 2
    //event System.Action<string> IB.E2; // 2
    event System.Action<string?>? IB.E3; // 2
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (34,37): error CS0071: An explicit interface implementation of an event must use event accessor syntax
                 //     event System.Action<string?>? IB.E3; // 2
                 Diagnostic(ErrorCode.ERR_ExplicitEventFieldImpl, ".").WithLocation(34, 37),
                 // (34,40): error CS1519: Invalid token ';' in class, struct, or interface member declaration
                 //     event System.Action<string?>? IB.E3; // 2
                 Diagnostic(ErrorCode.ERR_InvalidMemberDecl, ";").WithArguments(";").WithLocation(34, 40),
                 // (34,38): error CS0065: 'B2.IB.E3': event property must have both add and remove accessors
                 //     event System.Action<string?>? IB.E3; // 2
                 Diagnostic(ErrorCode.ERR_EventNeedsBothAccessors, "E3").WithArguments("B2.IB.E3").WithLocation(34, 38),
                 // (30,12): error CS0535: 'B2' does not implement interface member 'IB.E3.remove'
                 // class B2 : IB
                 Diagnostic(ErrorCode.ERR_UnimplementedInterfaceMember, "IB").WithArguments("B2", "IB.E3.remove").WithLocation(30, 12),
                 // (30,12): error CS0535: 'B2' does not implement interface member 'IB.E3.add'
                 // class B2 : IB
                 Diagnostic(ErrorCode.ERR_UnimplementedInterfaceMember, "IB").WithArguments("B2", "IB.E3.add").WithLocation(30, 12),
                 // (19,36): warning CS8615: Nullability of reference types in type doesn't match implemented member 'event Action<string>? IA.E2'.
                 //     event System.Action<string> IA.E2 {add {} remove{}}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation, "E2").WithArguments("event Action<string>? IA.E2").WithLocation(19, 36),
                 // (18,37): warning CS8615: Nullability of reference types in type doesn't match implemented member 'event Action<string> IA.E1'.
                 //     event System.Action<string?> IA.E1 {add {} remove{}}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation, "E1").WithArguments("event Action<string> IA.E1").WithLocation(18, 37)
                );

            var ia = compilation.GetTypeByMetadataName("IA");
            var b1 = compilation.GetTypeByMetadataName("B1");

            foreach (string memberName in new[] { "E1", "E2" })
            {
                var member = ia.GetMember<EventSymbol>(memberName);

                var impl = (EventSymbol)b1.FindImplementationForInterfaceMember(member);
                Assert.False(impl.Type.Equals(member.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            var e3 = ia.GetMember<EventSymbol>("E3");
            {
                var impl = (EventSymbol)b1.FindImplementationForInterfaceMember(e3);
                Assert.True(impl.Type.Equals(e3.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "IA", "B1" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var ev in type.GetMembers().OfType<EventSymbol>())
                {
                    Assert.True(ev.Type.Equals(ev.AddMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                    Assert.True(ev.Type.Equals(ev.RemoveMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Overriding_17()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    public static void Main()
    { 
    }
}

abstract class A1
{
    public abstract string?[] P1 {get; set;} 
    public abstract string[] P2 {get; set;} 

    public abstract string?[] this[int x] {get; set;} 
    public abstract string[] this[short x] {get; set;} 
}

abstract class A2
{
    public abstract string?[]? P3 {get; set;} 

    public abstract string?[]? this[long x] {get; set;} 
}

class B1 : A1
{
    public override string[] P1 {get; set;} 
    public override string[]? P2 {get; set;} 
    
    public override string[] this[int x] // 1
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
    
    public override string[]? this[short x] // 2
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}

class B2 : A2
{
    public override string?[]? P3 {get; set;} 
    
    public override string?[]? this[long x] // 3
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (28,31): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override string[]? P2 {get; set;}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "P2").WithLocation(28, 31),
                 // (30,30): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override string[] this[int x] // 1
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "this").WithLocation(30, 30),
                 // (36,31): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override string[]? this[short x] // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "this").WithLocation(36, 31),
                 // (27,30): warning CS8608: Nullability of reference types in type doesn't match overridden member.
                 //     public override string[] P1 {get; set;}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnOverride, "P1").WithLocation(27, 30)
                );

            foreach (var member in compilation.GetTypeByMetadataName("B1").GetMembers().OfType<PropertySymbol>())
            {
                Assert.False(member.Type.Equals(member.OverriddenProperty.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (var member in compilation.GetTypeByMetadataName("B2").GetMembers().OfType<PropertySymbol>())
            {
                Assert.True(member.Type.Equals(member.OverriddenProperty.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "A1", "B1", "A2", "B2" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var property in type.GetMembers().OfType<PropertySymbol>())
                {
                    Assert.True(property.Type.Equals(property.GetMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                    Assert.True(property.Type.Equals(property.SetMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Overriding_22()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    public static void Main()
    { 
    }
}

abstract class A1
{
    public abstract string?[] P1 {get; set;} // 1
    public abstract string[] P2 {get; set;} 

    public abstract string?[] this[int x] {get; set;} // 2
    public abstract string[] this[short x] {get; set;} 
}

class B1 : A1
{
" + NonNullTypesOff() + @"
    public override string[] P1 {get; set;}
" + NonNullTypesOff() + @"
    public override string[]? P2 {get; set;} // 3

" + NonNullTypesOff() + @"
    public override string[] this[int x]
    {
        get {throw new System.NotImplementedException();}
        set {}
    }

" + NonNullTypesOff() + @"
    public override string[]? this[short x] // 4
    {
        get {throw new System.NotImplementedException();}
        set {}
    }
}
";
            var compilation = CreateCompilation(new[] { source });

            compilation.VerifyDiagnostics(
                // (14,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract string?[] this[int x] {get; set;} // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(14, 27),
                // (11,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract string?[] P1 {get; set;} // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 27),
                // (23,29): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override string[]? P2 {get; set;} // 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(23, 29),
                // (33,29): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override string[]? this[short x] // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(33, 29)
                );
        }

        [Fact]
        public void Implementing_03()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    public static void Main()
    { 
    }
}
interface IA
{
    string?[] P1 {get; set;} 
    string[] P2 {get; set;} 
    string?[] this[int x] {get; set;} 
    string[] this[short x] {get; set;} 
}
interface IA2
{
    string?[]? P3 {get; set;} 
    string?[]? this[long x] {get; set;} 
}
class B : IA, IA2
{
    public string[] P1 {get; set;} 
    public string[]? P2 {get; set;} 
    public string?[]? P3 {get; set;} 

    public string[] this[int x] // 1
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 

    public string[]? this[short x] // 2
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 

    public string?[]? this[long x]
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (23,22): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'string[] IA.P2'.
                 //     public string[]? P2 {get; set;}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "P2").WithArguments("string[] IA.P2").WithLocation(23, 22),
                 // (26,21): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'string?[] IA.this[int x]'.
                 //     public string[] this[int x] // 1
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "this").WithArguments("string?[] IA.this[int x]").WithLocation(26, 21),
                 // (32,22): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'string[] IA.this[short x]'.
                 //     public string[]? this[short x] // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "this").WithArguments("string[] IA.this[short x]").WithLocation(32, 22),
                 // (22,21): warning CS8612: Nullability of reference types in type doesn't match implicitly implemented member 'string?[] IA.P1'.
                 //     public string[] P1 {get; set;}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnImplicitImplementation, "P1").WithArguments("string?[] IA.P1").WithLocation(22, 21)
                );

            var b = compilation.GetTypeByMetadataName("B");

            foreach (var member in compilation.GetTypeByMetadataName("IA").GetMembers().OfType<PropertySymbol>())
            {
                var impl = (PropertySymbol)b.FindImplementationForInterfaceMember(member);
                Assert.False(impl.Type.Equals(member.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (var member in compilation.GetTypeByMetadataName("IA2").GetMembers().OfType<PropertySymbol>())
            {
                var impl = (PropertySymbol)b.FindImplementationForInterfaceMember(member);
                Assert.True(impl.Type.Equals(member.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "IA", "IA2", "B" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var property in type.GetMembers().OfType<PropertySymbol>())
                {
                    Assert.True(property.Type.Equals(property.GetMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                    Assert.True(property.Type.Equals(property.SetMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Implementing_04()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    public static void Main()
    { 
    }
}
interface IA
{
    string?[] P1 {get; set;} 
    string[] P2 {get; set;} 
    string?[] this[int x] {get; set;} 
    string[] this[short x] {get; set;} 
}
interface IA2
{
    string?[]? P3 {get; set;} 
    string?[]? this[long x] {get; set;} 
}
class B : IA, IA2
{
    string[] IA.P1 {get; set;} 
    string[]? IA.P2 {get; set;} 
    string?[]? IA2.P3 {get; set;} 

    string[] IA.this[int x] // 1
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 

    string[]? IA.this[short x] // 2
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 

    string?[]? IA2.this[long x]
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (22,17): warning CS8615: Nullability of reference types in type doesn't match implemented member 'string?[] IA.P1'.
                 //     string[] IA.P1 {get; set;}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation, "P1").WithArguments("string?[] IA.P1").WithLocation(22, 17),
                 // (23,18): warning CS8615: Nullability of reference types in type doesn't match implemented member 'string[] IA.P2'.
                 //     string[]? IA.P2 {get; set;}
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation, "P2").WithArguments("string[] IA.P2").WithLocation(23, 18),
                 // (26,17): warning CS8615: Nullability of reference types in type doesn't match implemented member 'string?[] IA.this[int x]'.
                 //     string[] IA.this[int x] // 1
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation, "this").WithArguments("string?[] IA.this[int x]").WithLocation(26, 17),
                 // (32,18): warning CS8615: Nullability of reference types in type doesn't match implemented member 'string[] IA.this[short x]'.
                 //     string[]? IA.this[short x] // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeOnExplicitImplementation, "this").WithArguments("string[] IA.this[short x]").WithLocation(32, 18)
                );

            var b = compilation.GetTypeByMetadataName("B");

            foreach (var member in compilation.GetTypeByMetadataName("IA").GetMembers().OfType<PropertySymbol>())
            {
                var impl = (PropertySymbol)b.FindImplementationForInterfaceMember(member);
                Assert.False(impl.Type.Equals(member.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (var member in compilation.GetTypeByMetadataName("IA2").GetMembers().OfType<PropertySymbol>())
            {
                var impl = (PropertySymbol)b.FindImplementationForInterfaceMember(member);
                Assert.True(impl.Type.Equals(member.Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "IA", "IA2", "B" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var property in type.GetMembers().OfType<PropertySymbol>())
                {
                    Assert.True(property.Type.Equals(property.GetMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                    Assert.True(property.Type.Equals(property.SetMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Overriding_18()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

abstract class A
{
    public abstract string[] M1(); 
    public abstract T[] M2<T>() where T : class; 
    public abstract T?[]? M3<T>() where T : class; 
}

class B : A
{
    public override string?[] M1()
    {
        return new string?[] {};
    } 

    public override S?[] M2<S>()
    {
        return new S?[] {};
    } 

    public override S?[]? M3<S>()
    {
        return new S?[] {};
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (23,26): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override S?[] M2<S>()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M2").WithLocation(23, 26),
                 // (18,31): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override string?[] M1()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M1").WithLocation(18, 31)
                );

            var b = compilation.GetTypeByMetadataName("B");
            foreach (string memberName in new[] { "M1", "M2" })
            {
                var member = b.GetMember<MethodSymbol>(memberName);
                Assert.False(member.ReturnType.Equals(member.OverriddenMethod.ConstructIfGeneric(member.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t))).ReturnType,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            var m3 = b.GetMember<MethodSymbol>("M3");
            Assert.True(m3.ReturnType.Equals(m3.OverriddenMethod.ConstructIfGeneric(m3.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t))).ReturnType,
                TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
        }

        [Fact]
        [WorkItem(28684, "https://github.com/dotnet/roslyn/issues/28684")]
        public void Overriding_23()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

abstract class A
{
    public abstract string[] M1(); 
    public abstract T[] M2<T>() where T : class; 
}

class B : A
{
" + NonNullTypesOff() + @"
    public override string?[] M1()
    {
        return new string?[] {};
    }

" + NonNullTypesOff() + @"
    public override S?[] M2<S>()
    {
        return new S?[] {};
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (18,31): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                //     public override string?[] M1()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M1").WithLocation(18, 31),
                // (24,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override S?[] M2<S>()
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(24, 22),
                // (24,26): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                //     public override S?[] M2<S>()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M2").WithLocation(24, 26),
                // (18,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override string?[] M1()
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 27),
                // (20,26): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         return new string?[] {};
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(20, 26),
                // (26,21): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         return new S?[] {};
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(26, 21)
                );
        }

        [Fact]
        public void Implementing_05()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

interface IA
{
    string[] M1(); 
    T[] M2<T>() where T : class; 
    T?[]? M3<T>() where T : class; 
}

class B : IA
{
    public string?[] M1()
    {
        return new string?[] {};
    } 

    public S?[] M2<S>() where S : class
    {
        return new S?[] {};
    } 

    public S?[]? M3<S>() where S : class
    {
        return new S?[] {};
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (23,17): warning CS8613: Nullability of reference types in return type doesn't match implicitly implemented member 'T[] IA.M2<T>()'.
                 //     public S?[] M2<S>() where S : class
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation, "M2").WithArguments("T[] IA.M2<T>()").WithLocation(23, 17),
                 // (18,22): warning CS8613: Nullability of reference types in return type doesn't match implicitly implemented member 'string[] IA.M1()'.
                 //     public string?[] M1()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation, "M1").WithArguments("string[] IA.M1()").WithLocation(18, 22)
                );

            var ia = compilation.GetTypeByMetadataName("IA");
            var b = compilation.GetTypeByMetadataName("B");

            foreach (var memberName in new[] { "M1", "M2" })
            {
                var member = ia.GetMember<MethodSymbol>(memberName);
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.False(implementing.ReturnType.Equals(implemented.ReturnType,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            {
                var member = ia.GetMember<MethodSymbol>("M3");
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.True(implementing.ReturnType.Equals(implemented.ReturnType,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }
        }

        [Fact]
        public void Implementing_06()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

interface IA
{
    string[] M1(); 
    T[] M2<T>() where T : class; 
    T?[]? M3<T>() where T : class; 
}

class B : IA
{
    string?[] IA.M1()
    {
        return new string?[] {};
    } 

    S?[] IA.M2<S>() 
    {
        return new S?[] {};
    } 

    S?[]? IA.M3<S>() 
    {
        return new S?[] {};
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (23,13): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'T[] IA.M2<T>()'.
                 //     S?[] IA.M2<S>()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "M2").WithArguments("T[] IA.M2<T>()").WithLocation(23, 13),
                 // (18,18): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'string[] IA.M1()'.
                 //     string?[] IA.M1()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "M1").WithArguments("string[] IA.M1()").WithLocation(18, 18)
                );

            var ia = compilation.GetTypeByMetadataName("IA");
            var b = compilation.GetTypeByMetadataName("B");

            foreach (var memberName in new[] { "M1", "M2" })
            {
                var member = ia.GetMember<MethodSymbol>(memberName);
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.False(implementing.ReturnType.Equals(implemented.ReturnType,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            {
                var member = ia.GetMember<MethodSymbol>("M3");
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.True(implementing.ReturnType.Equals(implemented.ReturnType,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }
        }

        [Fact]
        [WorkItem(28684, "https://github.com/dotnet/roslyn/issues/28684")]
        public void ImplementingNonNullWithNullable()
        {
            var source = @"
interface IA
{
    string[] M1();
    T[] M2<T>() where T : class;
}

class B : IA
{
" + NonNullTypesOff() + @"
    string?[] IA.M1()
    {
        return new string?[] {};
    }

" + NonNullTypesOff() + @"
    S?[] IA.M2<S>()
    {
        return new S?[] {};
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (11,18): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'string[] IA.M1()'.
                //     string?[] IA.M1()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "M1").WithArguments("string[] IA.M1()").WithLocation(11, 18),
                // (17,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     S?[] IA.M2<S>()
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 6),
                // (17,13): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'T[] IA.M2<T>()'.
                //     S?[] IA.M2<S>()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "M2").WithArguments("T[] IA.M2<T>()").WithLocation(17, 13),
                // (11,11): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     string?[] IA.M1()
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 11),
                // (13,26): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         return new string?[] {};
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 26),
                // (19,21): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         return new S?[] {};
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(19, 21)
                );
        }

        [Fact]
        public void ImplementingNullableWithNonNull_ReturnType()
        {
            var source = @"
interface IA
{
" + NonNullTypesOff() + @"
    string?[] M1();
" + NonNullTypesOff() + @"
    T?[] M2<T>() where T : class;
}
" + NonNullTypesOn() + @"
class B : IA
{
    string[] IA.M1() => throw null;
    S[] IA.M2<S>() => throw null;
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (13,12): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'T?[] IA.M2<T>()'.
                //     S[] IA.M2<S>() => throw null;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "M2").WithArguments("T?[] IA.M2<T>()").WithLocation(13, 12),
                // (12,17): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'string?[] IA.M1()'.
                //     string[] IA.M1() => throw null;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "M1").WithArguments("string?[] IA.M1()").WithLocation(12, 17),
                // (7,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     T?[] M2<T>() where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(7, 6),
                // (7,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T?[] M2<T>() where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 5),
                // (5,11): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     string?[] M1();
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 11)
                );
        }

        [Fact]
        public void ImplementingNullableWithNonNull_Parameter()
        {
            var source = @"
interface IA
{
" + NonNullTypesOff() + @"
    void M1(string?[] x);
" + NonNullTypesOff() + @"
    void M2<T>(T?[] x) where T : class;
}
" + NonNullTypesOn() + @"
class B : IA
{
    void IA.M1(string[] x) => throw null;
    void IA.M2<S>(S[] x)
        => throw null;
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (5,19): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     void M1(string?[] x);
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 19),
                // (7,16): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     void M2<T>(T?[] x) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 16),
                // (7,17): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     void M2<T>(T?[] x) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(7, 17),
                // (12,13): warning CS8617: Nullability of reference types in type of parameter 'x' doesn't match implemented member 'void IA.M1(string?[] x)'.
                //     void IA.M1(string[] x) => throw null;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation, "M1").WithArguments("x", "void IA.M1(string?[] x)").WithLocation(12, 13),
                // (13,13): warning CS8617: Nullability of reference types in type of parameter 'x' doesn't match implemented member 'void IA.M2<T>(T?[] x)'.
                //     void IA.M2<S>(S[] x)
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation, "M2").WithArguments("x", "void IA.M2<T>(T?[] x)").WithLocation(13, 13)
                );
        }

        [Fact]
        public void ImplementingObliviousWithNonNull()
        {
            var source = @"
interface IA
{
" + NonNullTypesOff() + @"
    string[] M1();
" + NonNullTypesOff() + @"
    T[] M2<T>() where T : class;
}
" + NonNullTypesOn() + @"
class B : IA
{
    string[] IA.M1() => throw null;
    S[] IA.M2<S>() => throw null;
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics();
        }

        [Fact]
        public void Overriding_19()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

abstract class A
{
    public abstract void M1(string[] x); 
    public abstract void M2<T>(T[] x) where T : class; 
    public abstract void M3<T>(T?[]? x) where T : class; 
}

class B : A
{
    public override void M1(string?[] x)
    {
    } 

    public override void M2<T>(T?[] x)
    {
    } 

    public override void M3<T>(T?[]? x)
    {
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (22,26): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                 //     public override void M2<T>(T?[] x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M2").WithArguments("x").WithLocation(22, 26),
                 // (18,26): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                 //     public override void M1(string?[] x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M1").WithArguments("x").WithLocation(18, 26)
                );

            var b = compilation.GetTypeByMetadataName("B");
            foreach (string memberName in new[] { "M1", "M2" })
            {
                var member = b.GetMember<MethodSymbol>(memberName);
                Assert.False(member.Parameters[0].Type.Equals(member.OverriddenMethod.ConstructIfGeneric(member.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t))).Parameters[0].Type,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            var m3 = b.GetMember<MethodSymbol>("M3");
            Assert.True(m3.Parameters[0].Type.Equals(m3.OverriddenMethod.ConstructIfGeneric(m3.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t))).Parameters[0].Type,
                TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
        }

        [Fact]
        [WorkItem(28684, "https://github.com/dotnet/roslyn/issues/28684")]
        public void Overriding_24()
        {
            var source = @"
" + NonNullTypesOn() + @"

abstract class A
{
    public abstract void M1(string[] x);
    public abstract void M2<T>(T[] x) where T : class;
}

class B : A
{
" + NonNullTypesOff() + @"
    public override void M1(string?[] x)
    {
    }

" + NonNullTypesOff() + @"
    public override void M2<T>(T?[] x)
    {
    }
}
";
            var compilation = CreateCompilation(new[] { source });

            compilation.VerifyDiagnostics(
                // (13,26): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                //     public override void M1(string?[] x)
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M1").WithArguments("x").WithLocation(13, 26),
                // (18,26): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                //     public override void M2<T>(T?[] x)
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M2").WithArguments("x").WithLocation(18, 26),
                // (18,33): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override void M2<T>(T?[] x)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 33),
                // (13,35): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public override void M1(string?[] x)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 35)
                );
        }

        [Fact]
        public void Overriding_25()
        {
            var ilSource = @"
.assembly extern mscorlib
{
  .publickeytoken = (B7 7A 5C 56 19 34 E0 89 )                         // .z\V.4..
  .ver 4:0:0:0
}

.assembly '<<GeneratedFileName>>'
{
}

.module '<<GeneratedFileName>>.dll'

.class public auto ansi beforefieldinit C`2<T,S>
       extends [mscorlib]System.Object
{
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  ret
  } // end of method C`2::.ctor

} // end of class C`2

.class public abstract auto ansi beforefieldinit A
       extends [mscorlib]System.Object
{
  .method public hidebysig newslot abstract virtual 
          instance class C`2<string modopt([mscorlib]System.Runtime.CompilerServices.IsConst),string> 
          M1() cil managed
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 03 00 00 00 01 02 01 00 00 ) 
  } // end of method A::M1

  .method family hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  ret
  } // end of method A::.ctor

} // end of class A

.class public auto ansi beforefieldinit System.Runtime.CompilerServices.NullableAttribute
       extends [mscorlib]System.Attribute
{
  .custom instance void [mscorlib]System.AttributeUsageAttribute::.ctor(valuetype [mscorlib]System.AttributeTargets) = ( 01 00 86 6B 00 00 01 00 54 02 0D 41 6C 6C 6F 77   // ...k....T..Allow
                                                                                                                         4D 75 6C 74 69 70 6C 65 00 )              // Multiple.
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(uint8 transformFlag) cil managed
  {
    // Code size       9 (0x9)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Attribute::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ret
  } // end of method NullableAttribute::.ctor

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(uint8[] transformFlags) cil managed
  {
    // Code size       9 (0x9)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Attribute::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ret
  } // end of method NullableAttribute::.ctor

} // end of class System.Runtime.CompilerServices.NullableAttribute
";

            var source = @"
class C
{
    public static void Main()
    { 
    }
}

class B : A
{
    public override C<string, string?> M1()
    {
        return new C<string, string?>();
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, new[] { CompileIL(ilSource, prependDefaultHeader: false) },
                                                            options: WithNonNullTypesTrue(),
                                                            parseOptions: TestOptions.Regular8);

            var m1 = compilation.GetTypeByMetadataName("B").GetMember<MethodSymbol>("M1");
            Assert.Equal("C<System.String? modopt(System.Runtime.CompilerServices.IsConst), System.String>", m1.OverriddenMethod.ReturnType.ToTestDisplayString());
            Assert.Equal("C<System.String modopt(System.Runtime.CompilerServices.IsConst), System.String?>", m1.ReturnType.ToTestDisplayString());

            compilation.VerifyDiagnostics(
                 // (11,40): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override C<string, string?> M1()
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M1").WithLocation(11, 40)
                );
        }

        [Fact]
        public void Implementing_07()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}
interface IA
{
    void M1(string[] x); 
    void M2<T>(T[] x) where T : class; 
    void M3<T>(T?[]? x) where T : class; 
}
class B : IA
{
    public void M1(string?[] x)
    {
    } 

    public void M2<T>(T?[] x)  where T : class
    {
    } 

    public void M3<T>(T?[]? x)  where T : class
    {
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (20,17): warning CS8614: Nullability of reference types in type of parameter 'x' doesn't match implicitly implemented member 'void IA.M2<T>(T[] x)'.
                 //     public void M2<T>(T?[] x)  where T : class
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation, "M2").WithArguments("x", "void IA.M2<T>(T[] x)").WithLocation(20, 17),
                 // (16,17): warning CS8614: Nullability of reference types in type of parameter 'x' doesn't match implicitly implemented member 'void IA.M1(string[] x)'.
                 //     public void M1(string?[] x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation, "M1").WithArguments("x", "void IA.M1(string[] x)").WithLocation(16, 17)
                );

            var ia = compilation.GetTypeByMetadataName("IA");
            var b = compilation.GetTypeByMetadataName("B");

            foreach (var memberName in new[] { "M1", "M2" })
            {
                var member = ia.GetMember<MethodSymbol>(memberName);
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.False(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            {
                var member = ia.GetMember<MethodSymbol>("M3");
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.True(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }
        }

        [Fact]
        public void Implementing_08()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}
interface IA
{
    void M1(string[] x); 
    void M2<T>(T[] x) where T : class; 
    void M3<T>(T?[]? x) where T : class; 
}
class B : IA
{
    void IA.M1(string?[] x)
    {
    } 

    void IA.M2<T>(T?[] x)  
    {
    } 

    void IA.M3<T>(T?[]? x)  
    {
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (20,13): warning CS8617: Nullability of reference types in type of parameter 'x' doesn't match implemented member 'void IA.M2<T>(T[] x)'.
                 //     void IA.M2<T>(T?[] x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation, "M2").WithArguments("x", "void IA.M2<T>(T[] x)").WithLocation(20, 13),
                 // (16,13): warning CS8617: Nullability of reference types in type of parameter 'x' doesn't match implemented member 'void IA.M1(string[] x)'.
                 //     void IA.M1(string?[] x)
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation, "M1").WithArguments("x", "void IA.M1(string[] x)").WithLocation(16, 13)
                );

            var ia = compilation.GetTypeByMetadataName("IA");
            var b = compilation.GetTypeByMetadataName("B");

            foreach (var memberName in new[] { "M1", "M2" })
            {
                var member = ia.GetMember<MethodSymbol>(memberName);
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.False(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            {
                var member = ia.GetMember<MethodSymbol>("M3");
                var implementing = (MethodSymbol)b.FindImplementationForInterfaceMember(member);
                var implemented = member.ConstructIfGeneric(implementing.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));
                Assert.True(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }
        }

        [Fact]
        public void Overriding_20()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

abstract class A1
{
    public abstract int this[string?[] x] {get; set;} 
}
abstract class A2
{
    public abstract int this[string[] x] {get; set;} 
}
abstract class A3
{
    public abstract int this[string?[]? x] {get; set;} 
}

class B1 : A1
{
    public override int this[string[] x] // 1
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
class B2 : A2
{
    public override int this[string[]? x] // 2
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
class B3 : A3
{
    public override int this[string?[]? x] // 3
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (24,25): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                 //     public override int this[string[] x] // 1
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "this").WithArguments("x").WithLocation(24, 25),
                 // (32,25): warning CS8610: Nullability of reference types in type of parameter 'x' doesn't match overridden member.
                 //     public override int this[string[]? x] // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "this").WithArguments("x").WithLocation(32, 25)
                );

            foreach (string typeName in new[] { "B1", "B2" })
            {
                foreach (var member in compilation.GetTypeByMetadataName(typeName).GetMembers().OfType<PropertySymbol>())
                {
                    Assert.False(member.Parameters[0].Type.Equals(member.OverriddenProperty.Parameters[0].Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
                }
            }

            foreach (var member in compilation.GetTypeByMetadataName("B3").GetMembers().OfType<PropertySymbol>())
            {
                Assert.True(member.Parameters[0].Type.Equals(member.OverriddenProperty.Parameters[0].Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "A1", "A2", "A3", "B1", "B2", "B3" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var property in type.GetMembers().OfType<PropertySymbol>())
                {
                    Assert.True(property.Type.Equals(property.GetMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                    Assert.True(property.Type.Equals(property.SetMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Implementing_09()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

interface IA1
{
    int this[string?[] x] {get; set;} 
}
interface IA2
{
    int this[string[] x] {get; set;} 
}
interface IA3
{
    int this[string?[]? x] {get; set;} 
}

class B1 : IA1
{
    public int this[string[] x] // 1
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
class B2 : IA2
{
    public int this[string[]? x] // 2
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
class B3 : IA3
{
    public int this[string?[]? x] // 3
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (32,16): warning CS8614: Nullability of reference types in type of parameter 'x' doesn't match implicitly implemented member 'int IA2.this[string[] x]'.
                 //     public int this[string[]? x] // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation, "this").WithArguments("x", "int IA2.this[string[] x]").WithLocation(32, 16),
                 // (24,16): warning CS8614: Nullability of reference types in type of parameter 'x' doesn't match implicitly implemented member 'int IA1.this[string?[] x]'.
                 //     public int this[string[] x] // 1
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnImplicitImplementation, "this").WithArguments("x", "int IA1.this[string?[] x]").WithLocation(24, 16)
                );

            foreach (string[] typeName in new[] { new[] { "IA1", "B1" }, new[] { "IA2", "B2" } })
            {
                var implemented = compilation.GetTypeByMetadataName(typeName[0]).GetMembers().OfType<PropertySymbol>().Single();
                var implementing = (PropertySymbol)compilation.GetTypeByMetadataName(typeName[1]).FindImplementationForInterfaceMember(implemented);
                Assert.False(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            {
                var implemented = compilation.GetTypeByMetadataName("IA3").GetMembers().OfType<PropertySymbol>().Single();
                var implementing = (PropertySymbol)compilation.GetTypeByMetadataName("B3").FindImplementationForInterfaceMember(implemented);
                Assert.True(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "IA1", "IA2", "IA3", "B1", "B2", "B3" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var property in type.GetMembers().OfType<PropertySymbol>())
                {
                    Assert.True(property.Type.Equals(property.GetMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                    Assert.True(property.Type.Equals(property.SetMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Implementing_10()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

interface IA1
{
    int this[string?[] x] {get; set;} 
}
interface IA2
{
    int this[string[] x] {get; set;} 
}
interface IA3
{
    int this[string?[]? x] {get; set;} 
}

class B1 : IA1
{
    int IA1.this[string[] x] // 1
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
class B2 : IA2
{
    int IA2.this[string[]? x] // 2
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
class B3 : IA3
{
    int IA3.this[string?[]? x] // 3
    {
        get {throw new System.NotImplementedException();}
        set {}
    } 
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                 // (24,13): warning CS8617: Nullability of reference types in type of parameter 'x' doesn't match implemented member 'int IA1.this[string?[] x]'.
                 //     int IA1.this[string[] x] // 1
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation, "this").WithArguments("x", "int IA1.this[string?[] x]").WithLocation(24, 13),
                 // (32,13): warning CS8617: Nullability of reference types in type of parameter 'x' doesn't match implemented member 'int IA2.this[string[] x]'.
                 //     int IA2.this[string[]? x] // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnExplicitImplementation, "this").WithArguments("x", "int IA2.this[string[] x]").WithLocation(32, 13)
                );

            foreach (string[] typeName in new[] { new[] { "IA1", "B1" }, new[] { "IA2", "B2" } })
            {
                var implemented = compilation.GetTypeByMetadataName(typeName[0]).GetMembers().OfType<PropertySymbol>().Single();
                var implementing = (PropertySymbol)compilation.GetTypeByMetadataName(typeName[1]).FindImplementationForInterfaceMember(implemented);
                Assert.False(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            {
                var implemented = compilation.GetTypeByMetadataName("IA3").GetMembers().OfType<PropertySymbol>().Single();
                var implementing = (PropertySymbol)compilation.GetTypeByMetadataName("B3").FindImplementationForInterfaceMember(implemented);
                Assert.True(implementing.Parameters[0].Type.Equals(implemented.Parameters[0].Type, TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            foreach (string typeName in new[] { "IA1", "IA2", "IA3", "B1", "B2", "B3" })
            {
                var type = compilation.GetTypeByMetadataName(typeName);

                foreach (var property in type.GetMembers().OfType<PropertySymbol>())
                {
                    Assert.True(property.Type.Equals(property.GetMethod.ReturnType, TypeCompareKind.ConsiderEverything));
                    Assert.True(property.Type.Equals(property.SetMethod.Parameters.Last().Type, TypeCompareKind.ConsiderEverything));
                }
            }
        }

        [Fact]
        public void Implementing_11()
        {
            var source = @"
public interface I1<T> 
{
    void M();
}

public class A {}
public interface I2 : I1<A?> { }
public interface I3 : I1<A> { }

public class C1 : I2, I1<A> 
{ 
    void I1<A?>.M(){}
    void I1<A>.M(){}
}

public class C2 : I1<A>, I2 
{ 
    void I1<A?>.M(){}
    void I1<A>.M(){}
}

public class C3 : I1<A>, I1<A?>
{
    void I1<A?>.M(){}
    void I1<A>.M(){}
}

public class C4 : I2, I3
{
    void I1<A?>.M(){}
    void I1<A>.M(){}
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,14): warning CS8645: 'I1<A>' is already listed in the interface list on type 'C1' with different nullability of reference types.
                // public class C1 : I2, I1<A>
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C1").WithArguments("I1<A>", "C1").WithLocation(11, 14),
                // (11,14): error CS8646: 'I1<A?>.M()' is explicitly implemented more than once.
                // public class C1 : I2, I1<A>
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C1").WithArguments("I1<A?>.M()").WithLocation(11, 14),
                // (11,14): error CS8646: 'I1<A>.M()' is explicitly implemented more than once.
                // public class C1 : I2, I1<A>
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C1").WithArguments("I1<A>.M()").WithLocation(11, 14),
                // (17,14): warning CS8645: 'I1<A?>' is already listed in the interface list on type 'C2' with different nullability of reference types.
                // public class C2 : I1<A>, I2
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C2").WithArguments("I1<A?>", "C2").WithLocation(17, 14),
                // (17,14): error CS8646: 'I1<A>.M()' is explicitly implemented more than once.
                // public class C2 : I1<A>, I2
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C2").WithArguments("I1<A>.M()").WithLocation(17, 14),
                // (17,14): error CS8646: 'I1<A?>.M()' is explicitly implemented more than once.
                // public class C2 : I1<A>, I2
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C2").WithArguments("I1<A?>.M()").WithLocation(17, 14),
                // (23,14): warning CS8645: 'I1<A?>' is already listed in the interface list on type 'C3' with different nullability of reference types.
                // public class C3 : I1<A>, I1<A?>
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C3").WithArguments("I1<A?>", "C3").WithLocation(23, 14),
                // (23,14): error CS8646: 'I1<A>.M()' is explicitly implemented more than once.
                // public class C3 : I1<A>, I1<A?>
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C3").WithArguments("I1<A>.M()").WithLocation(23, 14),
                // (23,14): error CS8646: 'I1<A?>.M()' is explicitly implemented more than once.
                // public class C3 : I1<A>, I1<A?>
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C3").WithArguments("I1<A?>.M()").WithLocation(23, 14),
                // (29,14): warning CS8645: 'I1<A>' is already listed in the interface list on type 'C4' with different nullability of reference types.
                // public class C4 : I2, I3
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C4").WithArguments("I1<A>", "C4").WithLocation(29, 14),
                // (29,14): error CS8646: 'I1<A?>.M()' is explicitly implemented more than once.
                // public class C4 : I2, I3
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C4").WithArguments("I1<A?>.M()").WithLocation(29, 14),
                // (29,14): error CS8646: 'I1<A>.M()' is explicitly implemented more than once.
                // public class C4 : I2, I3
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C4").WithArguments("I1<A>.M()").WithLocation(29, 14)
                );

            var c1 = (INamedTypeSymbol)comp.GetTypeByMetadataName("C1");
            var c1Interfaces = c1.Interfaces;
            var c1AllInterfaces = c1.AllInterfaces;
            Assert.Equal(2, c1Interfaces.Length);
            Assert.Equal(3, c1AllInterfaces.Length);
            Assert.Equal("I2", c1Interfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<A!>", c1Interfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I2", c1AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<A?>", c1AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<A!>", c1AllInterfaces[2].ToTestDisplayString(includeNonNullable: true));
            assertExplicitInterfaceImplementations(c1);

            var c2 = (INamedTypeSymbol)comp.GetTypeByMetadataName("C2");
            var c2Interfaces = c2.Interfaces;
            var c2AllInterfaces = c2.AllInterfaces;
            Assert.Equal(2, c2Interfaces.Length);
            Assert.Equal(3, c2AllInterfaces.Length);
            Assert.Equal("I1<A!>", c2Interfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I2", c2Interfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<A!>", c2AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I2", c2AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<A?>", c2AllInterfaces[2].ToTestDisplayString(includeNonNullable: true));
            assertExplicitInterfaceImplementations(c2);

            var c3 = (INamedTypeSymbol)comp.GetTypeByMetadataName("C3");
            var c3Interfaces = c3.Interfaces;
            var c3AllInterfaces = c3.AllInterfaces;
            Assert.Equal(2, c3Interfaces.Length);
            Assert.Equal(2, c3AllInterfaces.Length);
            Assert.Equal("I1<A!>", c3Interfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<A?>", c3Interfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<A!>", c3AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<A?>", c3AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
            assertExplicitInterfaceImplementations(c3);

            var c4 = (INamedTypeSymbol)comp.GetTypeByMetadataName("C4");
            var c4Interfaces = c4.Interfaces;
            var c4AllInterfaces = c4.AllInterfaces;
            Assert.Equal(2, c4Interfaces.Length);
            Assert.Equal(4, c4AllInterfaces.Length);
            Assert.Equal("I2", c4Interfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I3", c4Interfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I2", c4AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<A?>", c4AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I3", c4AllInterfaces[2].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<A!>", c4AllInterfaces[3].ToTestDisplayString(includeNonNullable: true));
            assertExplicitInterfaceImplementations(c4);

            void assertExplicitInterfaceImplementations(INamedTypeSymbol c)
            {
                var members = c.GetMembers("I1<A>.M");
                Assert.Equal(2, members.Length);
                var cMabImplementations = ((IMethodSymbol)members[0]).ExplicitInterfaceImplementations;
                Assert.Equal(1, cMabImplementations.Length);
                Assert.Equal("void I1<A?>.M()", cMabImplementations[0].ToTestDisplayString(includeNonNullable: true));
                var cMcdImplementations = ((IMethodSymbol)members[1]).ExplicitInterfaceImplementations;
                Assert.Equal(1, cMcdImplementations.Length);
                Assert.Equal("void I1<A!>.M()", cMcdImplementations[0].ToTestDisplayString(includeNonNullable: true));
            }
        }

        [Fact]
        public void Implementing_12()
        {
            var source = @"
public interface I1<T> 
{
    void M1();
    void M2();
}

public class A {}

public class C1 : I1<A?> 
{ 
    public void M1() => System.Console.WriteLine(""C1.M1"");
    void I1<A?>.M2() => System.Console.WriteLine(""C1.M2"");
}

public class C2 : C1, I1<A>
{
    new public void M1() => System.Console.WriteLine(""C2.M1"");
    void I1<A>.M2() => System.Console.WriteLine(""C2.M2"");

    static void Main()
    {
        var x = (C1)new C2();
        var y = (I1<A?>)x;
        y.M1();
        y.M2();
    }
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics();

            Action<ModuleSymbol> validate = (m) =>
            {
                bool isMetadata = m is PEModuleSymbol;

                var c1 = (INamedTypeSymbol)m.GlobalNamespace.GetTypeMember("C1");
                var c1Interfaces = c1.Interfaces;
                var c1AllInterfaces = c1.AllInterfaces;
                Assert.Equal(1, c1Interfaces.Length);
                Assert.Equal(1, c1AllInterfaces.Length);
                Assert.Equal("I1<A?>", c1Interfaces[0].ToTestDisplayString(includeNonNullable: true));
                Assert.Equal("I1<A?>", c1AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));

                var c2 = (INamedTypeSymbol)m.GlobalNamespace.GetTypeMember("C2");
                var c2Interfaces = c2.Interfaces;
                var c2AllInterfaces = c2.AllInterfaces;
                Assert.Equal(1, c2Interfaces.Length);
                Assert.Equal(2, c2AllInterfaces.Length);
                Assert.Equal("I1<A!>", c2Interfaces[0].ToTestDisplayString(includeNonNullable: true));
                Assert.Equal("I1<A?>", c2AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
                Assert.Equal("I1<A!>", c2AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));

                Assert.Equal("void C2.M1()", c2.FindImplementationForInterfaceMember(((TypeSymbol)c2Interfaces[0]).GetMember("M1")).ToTestDisplayString(includeNonNullable: true));
                Assert.Equal("void C2.M1()",
                             c2.FindImplementationForInterfaceMember(((TypeSymbol)c1Interfaces[0]).GetMember("M1")).ToTestDisplayString(includeNonNullable: true));

                var m2 = (IMethodSymbol)((TypeSymbol)c2).GetMember("I1<A>.M2");
                var m2Implementations = m2.ExplicitInterfaceImplementations;
                Assert.Equal(1, m2Implementations.Length);
                Assert.Equal(isMetadata ?
                                 "void I1<A>.M2()" :
                                 "void I1<A!>.M2()",
                             m2Implementations[0].ToTestDisplayString(includeNonNullable: true));

                Assert.Same(m2,
                            c2.FindImplementationForInterfaceMember(((TypeSymbol)c2Interfaces[0]).GetMember("M2")));
                Assert.Same(m2,
                            c2.FindImplementationForInterfaceMember(((TypeSymbol)c1Interfaces[0]).GetMember("M2")));
            };

            CompileAndVerify(comp, sourceSymbolValidator: validate, symbolValidator: validate, expectedOutput:
@"C2.M1
C2.M2
");
        }

        [Fact]
        public void Implementing_13()
        {
            var source = @"
public interface I1<T> 
{
    void M1();
    void M2();
}

public class A {}

public class C1 : I1<A?> 
{ 
    public void M1() => System.Console.WriteLine(""C1.M1"");
    void I1<A?>.M2() => System.Console.WriteLine(""C1.M2"");
    public virtual void M2() {}
}

public class C2 : C1, I1<A>
{
    static void Main()
    {
        var x = (C1)new C2();
        var y = (I1<A>)x;
        y.M1();
        y.M2();
    }
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics(
                // (17,23): warning CS8644: 'C2' does not implement interface member 'I1<A>.M2()'. Nullability of reference types in interface implemented by the base type doesn't match.
                // public class C2 : C1, I1<A>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInInterfaceImplementedByBase, "I1<A>").WithArguments("C2", "I1<A>.M2()").WithLocation(17, 23)
                );

            Action<ModuleSymbol> validate = (m) =>
            {
                bool isMetadata = m is PEModuleSymbol;

                var c1 = (INamedTypeSymbol)m.GlobalNamespace.GetTypeMember("C1");
                var c1Interfaces = c1.Interfaces;
                var c1AllInterfaces = c1.AllInterfaces;
                Assert.Equal(1, c1Interfaces.Length);
                Assert.Equal(1, c1AllInterfaces.Length);
                Assert.Equal("I1<A?>", c1Interfaces[0].ToTestDisplayString(includeNonNullable: true));
                Assert.Equal("I1<A?>", c1AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));

                var c2 = (INamedTypeSymbol)m.GlobalNamespace.GetTypeMember("C2");
                var c2Interfaces = c2.Interfaces;
                var c2AllInterfaces = c2.AllInterfaces;
                Assert.Equal(1, c2Interfaces.Length);
                Assert.Equal(2, c2AllInterfaces.Length);
                Assert.Equal("I1<A!>", c2Interfaces[0].ToTestDisplayString(includeNonNullable: true));
                Assert.Equal("I1<A?>", c2AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
                Assert.Equal("I1<A!>", c2AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));

                Assert.Equal("void C1.M1()", c2.FindImplementationForInterfaceMember(((TypeSymbol)c2Interfaces[0]).GetMember("M1")).ToTestDisplayString(includeNonNullable: true));
                Assert.Equal("void C1.M1()",
                             c2.FindImplementationForInterfaceMember(((TypeSymbol)c1Interfaces[0]).GetMember("M1")).ToTestDisplayString(includeNonNullable: true));

                var m2 = (IMethodSymbol)((TypeSymbol)c1).GetMember("I1<A>.M2");
                var m2Implementations = m2.ExplicitInterfaceImplementations;
                Assert.Equal(1, m2Implementations.Length);
                Assert.Equal(isMetadata ?
                                 "void I1<A>.M2()" :
                                 "void I1<A?>.M2()",
                             m2Implementations[0].ToTestDisplayString(includeNonNullable: true));

                Assert.Same(m2,
                            c2.FindImplementationForInterfaceMember(((TypeSymbol)c2Interfaces[0]).GetMember("M2")));
                Assert.Same(m2,
                            c2.FindImplementationForInterfaceMember(((TypeSymbol)c1Interfaces[0]).GetMember("M2")));
            };

            CompileAndVerify(comp, sourceSymbolValidator: validate, symbolValidator: validate, expectedOutput:
@"C1.M1
C1.M2
");
        }

        [Fact]
        public void Implementing_14()
        {
            var source = @"
public interface I1<T> 
{
    void M1();
}

public class A {}

public class C1 : I1<A?> 
{ 
}

public class C2 : C1, I1<A> 
{ 
}

public class C3 : C1, I1<A?> 
{ 
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,19): error CS0535: 'C1' does not implement interface member 'I1<A?>.M1()'
                // public class C1 : I1<A?>
                Diagnostic(ErrorCode.ERR_UnimplementedInterfaceMember, "I1<A?>").WithArguments("C1", "I1<A?>.M1()").WithLocation(9, 19),
                // (13,23): warning CS8644: 'C2' does not implement interface member 'I1<A>.M1()'. Nullability of reference types in interface implemented by the base type doesn't match.
                // public class C2 : C1, I1<A>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInInterfaceImplementedByBase, "I1<A>").WithArguments("C2", "I1<A>.M1()").WithLocation(13, 23)
                );
        }

        [Fact]
        public void Implementing_15()
        {
            var source1 = @"
public interface I1<T> 
{
    void M1();
}

public class A {}

public class C1 : I1<A?> 
{ 
}
";
            var comp1 = CreateCompilation(source1, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (9,19): error CS0535: 'C1' does not implement interface member 'I1<A?>.M1()'
                // public class C1 : I1<A?>
                Diagnostic(ErrorCode.ERR_UnimplementedInterfaceMember, "I1<A?>").WithArguments("C1", "I1<A?>.M1()").WithLocation(9, 19)
                );

            var source2 = @"
public class C2 : C1, I1<A> 
{ 
}

public class C3 : C1, I1<A?> 
{ 
}
";
            var comp2 = CreateCompilation(source2, references: new[] { comp1.ToMetadataReference() }, options: WithNonNullTypesTrue());
            comp2.VerifyDiagnostics(
                // (2,23): warning CS8644: 'C2' does not implement interface member 'I1<A>.M1()'. Nullability of reference types in interface implemented by the base type doesn't match.
                // public class C2 : C1, I1<A>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInInterfaceImplementedByBase, "I1<A>").WithArguments("C2", "I1<A>.M1()").WithLocation(2, 23)
                );
        }

        [Fact]
        public void Implementing_16()
        {
            var source = @"
public interface I1<T> 
{
    void M();
}

public interface I2<I2T> : I1<I2T?> where I2T : class { }
public interface I3<I3T> : I1<I3T> where I3T : class { }

public class C1<T> : I2<T>, I1<T> where T : class 
{ 
    void I1<T?>.M(){}
    void I1<T>.M(){}
}

public class C2<T> : I1<T>, I2<T> where T : class  
{ 
    void I1<T?>.M(){}
    void I1<T>.M(){}
}

public class C3<T> : I1<T>, I1<T?> where T : class 
{
    void I1<T?>.M(){}
    void I1<T>.M(){}
}

public class C4<T> : I2<T>, I3<T> where T : class 
{
    void I1<T?>.M(){}
    void I1<T>.M(){}
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,14): warning CS8645: 'I1<T>' is already listed in the interface list on type 'C1<T>' with different nullability of reference types.
                // public class C1<T> : I2<T>, I1<T> where T : class
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C1").WithArguments("I1<T>", "C1<T>").WithLocation(10, 14),
                // (10,14): error CS8646: 'I1<T?>.M()' is explicitly implemented more than once.
                // public class C1<T> : I2<T>, I1<T> where T : class
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C1").WithArguments("I1<T?>.M()").WithLocation(10, 14),
                // (10,14): error CS8646: 'I1<T>.M()' is explicitly implemented more than once.
                // public class C1<T> : I2<T>, I1<T> where T : class
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C1").WithArguments("I1<T>.M()").WithLocation(10, 14),
                // (16,14): warning CS8645: 'I1<T?>' is already listed in the interface list on type 'C2<T>' with different nullability of reference types.
                // public class C2<T> : I1<T>, I2<T> where T : class
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C2").WithArguments("I1<T?>", "C2<T>").WithLocation(16, 14),
                // (16,14): error CS8646: 'I1<T>.M()' is explicitly implemented more than once.
                // public class C2<T> : I1<T>, I2<T> where T : class
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C2").WithArguments("I1<T>.M()").WithLocation(16, 14),
                // (16,14): error CS8646: 'I1<T?>.M()' is explicitly implemented more than once.
                // public class C2<T> : I1<T>, I2<T> where T : class
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C2").WithArguments("I1<T?>.M()").WithLocation(16, 14),
                // (22,14): warning CS8645: 'I1<T?>' is already listed in the interface list on type 'C3<T>' with different nullability of reference types.
                // public class C3<T> : I1<T>, I1<T?> where T : class
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C3").WithArguments("I1<T?>", "C3<T>").WithLocation(22, 14),
                // (22,14): error CS8646: 'I1<T>.M()' is explicitly implemented more than once.
                // public class C3<T> : I1<T>, I1<T?> where T : class
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C3").WithArguments("I1<T>.M()").WithLocation(22, 14),
                // (22,14): error CS8646: 'I1<T?>.M()' is explicitly implemented more than once.
                // public class C3<T> : I1<T>, I1<T?> where T : class
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C3").WithArguments("I1<T?>.M()").WithLocation(22, 14),
                // (28,14): warning CS8645: 'I1<T>' is already listed in the interface list on type 'C4<T>' with different nullability of reference types.
                // public class C4<T> : I2<T>, I3<T> where T : class
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C4").WithArguments("I1<T>", "C4<T>").WithLocation(28, 14),
                // (28,14): error CS8646: 'I1<T?>.M()' is explicitly implemented more than once.
                // public class C4<T> : I2<T>, I3<T> where T : class
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C4").WithArguments("I1<T?>.M()").WithLocation(28, 14),
                // (28,14): error CS8646: 'I1<T>.M()' is explicitly implemented more than once.
                // public class C4<T> : I2<T>, I3<T> where T : class
                Diagnostic(ErrorCode.ERR_DuplicateExplicitImpl, "C4").WithArguments("I1<T>.M()").WithLocation(28, 14)
                );

            var c1 = (INamedTypeSymbol)comp.GetTypeByMetadataName("C1`1");
            var c1Interfaces = c1.Interfaces;
            var c1AllInterfaces = c1.AllInterfaces;
            Assert.Equal(2, c1Interfaces.Length);
            Assert.Equal(3, c1AllInterfaces.Length);
            Assert.Equal("I2<T!>", c1Interfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<T!>", c1Interfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I2<T!>", c1AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<T?>", c1AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<T!>", c1AllInterfaces[2].ToTestDisplayString(includeNonNullable: true));
            assertExplicitInterfaceImplementations(c1);

            var c2 = (INamedTypeSymbol)comp.GetTypeByMetadataName("C2`1");
            var c2Interfaces = c2.Interfaces;
            var c2AllInterfaces = c2.AllInterfaces;
            Assert.Equal(2, c2Interfaces.Length);
            Assert.Equal(3, c2AllInterfaces.Length);
            Assert.Equal("I1<T!>", c2Interfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I2<T!>", c2Interfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<T!>", c2AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I2<T!>", c2AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<T?>", c2AllInterfaces[2].ToTestDisplayString(includeNonNullable: true));
            assertExplicitInterfaceImplementations(c2);

            var c3 = (INamedTypeSymbol)comp.GetTypeByMetadataName("C3`1");
            var c3Interfaces = c3.Interfaces;
            var c3AllInterfaces = c3.AllInterfaces;
            Assert.Equal(2, c3Interfaces.Length);
            Assert.Equal(2, c3AllInterfaces.Length);
            Assert.Equal("I1<T!>", c3Interfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<T?>", c3Interfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<T!>", c3AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<T?>", c3AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
            assertExplicitInterfaceImplementations(c3);

            var c4 = (INamedTypeSymbol)comp.GetTypeByMetadataName("C4`1");
            var c4Interfaces = c4.Interfaces;
            var c4AllInterfaces = c4.AllInterfaces;
            Assert.Equal(2, c4Interfaces.Length);
            Assert.Equal(4, c4AllInterfaces.Length);
            Assert.Equal("I2<T!>", c4Interfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I3<T!>", c4Interfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I2<T!>", c4AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<T?>", c4AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I3<T!>", c4AllInterfaces[2].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<T!>", c4AllInterfaces[3].ToTestDisplayString(includeNonNullable: true));
            assertExplicitInterfaceImplementations(c4);

            void assertExplicitInterfaceImplementations(INamedTypeSymbol c)
            {
                var members = c.GetMembers("I1<T>.M");
                Assert.Equal(2, members.Length);
                var cMabImplementations = ((IMethodSymbol)members[0]).ExplicitInterfaceImplementations;
                Assert.Equal(1, cMabImplementations.Length);
                Assert.Equal("void I1<T?>.M()", cMabImplementations[0].ToTestDisplayString(includeNonNullable: true));
                var cMcdImplementations = ((IMethodSymbol)members[1]).ExplicitInterfaceImplementations;
                Assert.Equal(1, cMcdImplementations.Length);
                Assert.Equal("void I1<T!>.M()", cMcdImplementations[0].ToTestDisplayString(includeNonNullable: true));
            }
        }

        [Fact]
        public void Implementing_17()
        {
            var source = @"
public interface I1<T> 
{
    void M();
}

public class C3<T, U> : I1<T>, I1<U?> where T : class where U : class 
{
    void I1<U?>.M(){}
    void I1<T>.M(){}
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,14): error CS0695: 'C3<T, U>' cannot implement both 'I1<T>' and 'I1<U?>' because they may unify for some type parameter substitutions
                // public class C3<T, U> : I1<T>, I1<U?> where T : class where U : class
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C3").WithArguments("C3<T, U>", "I1<T>", "I1<U?>").WithLocation(7, 14)
                );

            var c3 = (INamedTypeSymbol)comp.GetTypeByMetadataName("C3`2");
            var c3Interfaces = c3.Interfaces;
            var c3AllInterfaces = c3.AllInterfaces;
            Assert.Equal(2, c3Interfaces.Length);
            Assert.Equal(2, c3AllInterfaces.Length);
            Assert.Equal("I1<T!>", c3Interfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<U?>", c3Interfaces[1].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<T!>", c3AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("I1<U?>", c3AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
            assertExplicitInterfaceImplementations(c3);

            void assertExplicitInterfaceImplementations(INamedTypeSymbol c)
            {
                var cMabImplementations = ((IMethodSymbol)((TypeSymbol)c).GetMember("I1<T>.M")).ExplicitInterfaceImplementations;
                Assert.Equal(1, cMabImplementations.Length);
                Assert.Equal("void I1<T!>.M()", cMabImplementations[0].ToTestDisplayString(includeNonNullable: true));
                var cMcdImplementations = ((IMethodSymbol)((TypeSymbol)c).GetMember("I1<U>.M")).ExplicitInterfaceImplementations;
                Assert.Equal(1, cMcdImplementations.Length);
                Assert.Equal("void I1<U?>.M()", cMcdImplementations[0].ToTestDisplayString(includeNonNullable: true));
            }
        }

        [Fact]
        public void Implementing_18()
        {
            var source = @"
public interface I1<T> 
{
    void M();
}

public class A {}

public class C3 : I1<A>
{
    void I1<A?>.M() 
    {
        System.Console.WriteLine(""C3.M"");
    }

    static void Main()
    {
        var x = new C3();
        ((I1<A>)x).M();
        ((I1<A?>)x).M();
    }
}

public class C4 : I1<A?>
{
    void I1<A?>.M(){}
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics(
                // (11,10): warning CS8643: Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.
                //     void I1<A?>.M()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInExplicitlyImplementedInterface, "I1<A?>").WithLocation(11, 10)
                );

            Action<ModuleSymbol> validate = (ModuleSymbol m) =>
            {
                bool isMetadata = m is PEModuleSymbol;

                var c3 = (INamedTypeSymbol)m.GlobalNamespace.GetTypeMember("C3");
                var c3Interfaces = c3.Interfaces;
                var c3AllInterfaces = c3.AllInterfaces;
                Assert.Equal(1, c3Interfaces.Length);
                Assert.Equal(1, c3AllInterfaces.Length);
                Assert.Equal("I1<A!>", c3Interfaces[0].ToTestDisplayString(includeNonNullable: true));
                Assert.Equal("I1<A!>", c3AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));

                var method = (IMethodSymbol)((TypeSymbol)c3).GetMember("I1<A>.M");
                Assert.Equal("I1<A>.M", method.Name);

                var mImplementations = method.ExplicitInterfaceImplementations;
                Assert.Equal(1, mImplementations.Length);
                Assert.Equal(isMetadata ?
                                 "void I1<A>.M()" :
                                 "void I1<A?>.M()",
                             mImplementations[0].ToTestDisplayString(includeNonNullable: true));

                Assert.Same(method,
                            c3.FindImplementationForInterfaceMember(((TypeSymbol)c3Interfaces[0]).GetMember("M")));

                Assert.Same(method,
                            c3.FindImplementationForInterfaceMember(mImplementations[0]));

                Assert.Same(method,
                            c3.FindImplementationForInterfaceMember(m.GlobalNamespace.GetTypeMember("C4").InterfacesNoUseSiteDiagnostics()[0].GetMember("M")));
            };

            CompileAndVerify(comp, sourceSymbolValidator: validate, symbolValidator: validate, expectedOutput:
@"C3.M
C3.M");
        }

        [Fact]
        public void Implementing_19()
        {
            var source = @"
public interface I1<T> 
{
    void M();
}

public class A {}

public class C3 : I1<A>, I1<A?>
{
    void I1<A?>.M() 
    {
        System.Console.WriteLine(""C3.M"");
    }

    static void Main()
    {
        var x = new C3();
        ((I1<A>)x).M();
        ((I1<A?>)x).M();
    }
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics(
                // (9,14): warning CS8645: 'I1<A?>' is already listed in the interface list on type 'C3' with different nullability of reference types.
                // public class C3 : I1<A>, I1<A?>
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C3").WithArguments("I1<A?>", "C3").WithLocation(9, 14)
                );

            Action<ModuleSymbol> validate = (ModuleSymbol m) =>
            {
                bool isMetadata = m is PEModuleSymbol;

                var c3 = (INamedTypeSymbol)m.GlobalNamespace.GetTypeMember("C3");
                var c3Interfaces = c3.Interfaces;
                var c3AllInterfaces = c3.AllInterfaces;

                if (isMetadata)
                {
                    Assert.Equal(1, c3Interfaces.Length);
                    Assert.Equal(1, c3AllInterfaces.Length);
                    Assert.Equal("I1<A!>", c3Interfaces[0].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A!>", c3AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
                }
                else
                {
                    Assert.Equal(2, c3Interfaces.Length);
                    Assert.Equal(2, c3AllInterfaces.Length);
                    Assert.Equal("I1<A!>", c3Interfaces[0].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A?>", c3Interfaces[1].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A!>", c3AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A?>", c3AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
                }

                var method = (IMethodSymbol)((TypeSymbol)c3).GetMember("I1<A>.M");
                Assert.Equal("I1<A>.M", method.Name);

                var mImplementations = method.ExplicitInterfaceImplementations;
                Assert.Equal(1, mImplementations.Length);
                Assert.Equal(isMetadata ?
                                 "void I1<A>.M()" :
                                 "void I1<A?>.M()",
                             mImplementations[0].ToTestDisplayString(includeNonNullable: true));

                Assert.Same(method,
                            c3.FindImplementationForInterfaceMember(((TypeSymbol)c3Interfaces[0]).GetMember("M")));

                Assert.Same(method,
                            c3.FindImplementationForInterfaceMember(mImplementations[0]));
            };

            CompileAndVerify(comp, sourceSymbolValidator: validate, symbolValidator: validate, expectedOutput:
@"C3.M
C3.M");
        }

        [Fact]
        public void Implementing_20()
        {
            var source = @"
public interface I1<T> 
{
    void M();
}

public class A {}

public interface I2 : I1<A?>
{}

public class C3 : I2, I1<A>
{
    void I1<A?>.M() 
    {
        System.Console.WriteLine(""C3.M"");
    }

    static void Main()
    {
        var x = new C3();
        ((I1<A>)x).M();
        ((I1<A?>)x).M();
    }
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics(
                // (12,14): warning CS8645: 'I1<A>' is already listed in the interface list on type 'C3' with different nullability of reference types.
                // public class C3 : I2, I1<A>
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C3").WithArguments("I1<A>", "C3").WithLocation(12, 14)
                );

            Action<ModuleSymbol> validate = (ModuleSymbol m) =>
            {
                bool isMetadata = m is PEModuleSymbol;

                var c3 = (INamedTypeSymbol)m.GlobalNamespace.GetTypeMember("C3");
                var c3Interfaces = c3.Interfaces;
                var c3AllInterfaces = c3.AllInterfaces;

                if (isMetadata)
                {
                    Assert.Equal(2, c3Interfaces.Length);
                    Assert.Equal(2, c3AllInterfaces.Length);
                    Assert.Equal("I2", c3Interfaces[0].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A?>", c3Interfaces[1].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I2", c3AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A?>", c3AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
                }
                else
                {
                    Assert.Equal(2, c3Interfaces.Length);
                    Assert.Equal(3, c3AllInterfaces.Length);
                    Assert.Equal("I2", c3Interfaces[0].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A!>", c3Interfaces[1].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I2", c3AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A?>", c3AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A!>", c3AllInterfaces[2].ToTestDisplayString(includeNonNullable: true));
                }

                var method = (IMethodSymbol)((TypeSymbol)c3).GetMember("I1<A>.M");
                Assert.Equal("I1<A>.M", method.Name);

                var mImplementations = method.ExplicitInterfaceImplementations;
                Assert.Equal(1, mImplementations.Length);
                Assert.Equal(isMetadata ?
                                 "void I1<A>.M()" :
                                 "void I1<A?>.M()",
                             mImplementations[0].ToTestDisplayString(includeNonNullable: true));

                Assert.Same(method,
                            c3.FindImplementationForInterfaceMember(((TypeSymbol)c3Interfaces[1]).GetMember("M")));

                Assert.Same(method,
                            c3.FindImplementationForInterfaceMember(mImplementations[0]));
            };

            CompileAndVerify(comp, sourceSymbolValidator: validate, symbolValidator: validate, expectedOutput:
@"C3.M
C3.M");
        }

        [Fact]
        public void Implementing_21()
        {
            var source = @"
public interface I1<T> 
{
    void M();
}

public class A {}

public partial class C3 : I1<A>
{
    void I1<A?>.M() 
    {
        System.Console.WriteLine(""C3.M"");
    }

    static void Main()
    {
        var x = new C3();
        ((I1<A>)x).M();
        ((I1<A?>)x).M();
    }
}

public partial class C3 : I1<A?> {}

";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue(TestOptions.DebugExe));
            comp.VerifyDiagnostics(
                // (9,22): warning CS8645: 'I1<A?>' is already listed in the interface list on type 'C3' with different nullability of reference types.
                // public partial class C3 : I1<A>
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C3").WithArguments("I1<A?>", "C3").WithLocation(9, 22)
                );

            Action<ModuleSymbol> validate = (ModuleSymbol m) =>
            {
                bool isMetadata = m is PEModuleSymbol;

                var c3 = (INamedTypeSymbol)m.GlobalNamespace.GetTypeMember("C3");
                var c3Interfaces = c3.Interfaces;
                var c3AllInterfaces = c3.AllInterfaces;

                if (isMetadata)
                {
                    Assert.Equal(1, c3Interfaces.Length);
                    Assert.Equal(1, c3AllInterfaces.Length);
                    Assert.Equal("I1<A!>", c3Interfaces[0].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A!>", c3AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
                }
                else
                {
                    Assert.Equal(2, c3Interfaces.Length);
                    Assert.Equal(2, c3AllInterfaces.Length);
                    Assert.Equal("I1<A!>", c3Interfaces[0].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A?>", c3Interfaces[1].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A!>", c3AllInterfaces[0].ToTestDisplayString(includeNonNullable: true));
                    Assert.Equal("I1<A?>", c3AllInterfaces[1].ToTestDisplayString(includeNonNullable: true));
                }

                var method = (IMethodSymbol)((TypeSymbol)c3).GetMember("I1<A>.M");
                Assert.Equal("I1<A>.M", method.Name);

                var mImplementations = method.ExplicitInterfaceImplementations;
                Assert.Equal(1, mImplementations.Length);
                Assert.Equal(isMetadata ?
                                 "void I1<A>.M()" :
                                 "void I1<A?>.M()",
                             mImplementations[0].ToTestDisplayString(includeNonNullable: true));

                Assert.Same(method,
                            c3.FindImplementationForInterfaceMember(((TypeSymbol)c3Interfaces[0]).GetMember("M")));

                Assert.Same(method,
                            c3.FindImplementationForInterfaceMember(mImplementations[0]));
            };

            CompileAndVerify(comp, sourceSymbolValidator: validate, symbolValidator: validate, expectedOutput:
@"C3.M
C3.M");
        }

        [Fact]
        public void PartialMethods_01()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

partial class C1
{
    partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
}

partial class C1
{
    partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
    { }
}";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30145: What nullability is getting emitted?
            compilation.VerifyDiagnostics(
                 // (16,18): warning CS8611: Nullability of reference types in type of parameter 'x' doesn't match partial method declaration.
                 //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("x").WithLocation(16, 18),
                 // (16,18): warning CS8611: Nullability of reference types in type of parameter 'y' doesn't match partial method declaration.
                 //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("y").WithLocation(16, 18),
                 // (16,18): warning CS8611: Nullability of reference types in type of parameter 'z' doesn't match partial method declaration.
                 //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("z").WithLocation(16, 18)
                );

            var c1 = compilation.GetTypeByMetadataName("C1");

            var m1 = c1.GetMember<MethodSymbol>("M1");
            var m1Impl = m1.PartialImplementationPart;
            var m1Def = m1.ConstructIfGeneric(m1Impl.TypeParameters.SelectAsArray(t => TypeSymbolWithAnnotations.Create(t)));

            for (int i = 0; i < 3; i++)
            {
                Assert.False(m1Impl.Parameters[i].Type.Equals(m1Def.Parameters[i].Type,
                    TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
            }

            Assert.True(m1Impl.Parameters[3].Type.Equals(m1Def.Parameters[3].Type,
                TypeCompareKind.AllIgnoreOptions & ~TypeCompareKind.AllNullableIgnoreOptions));
        }

        [Fact]
        public void PartialMethods_02_01()
        {
            var source = @"
partial class C1
{
" + NonNullTypesOff() + @"
    partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
}

partial class C1
{
    partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
    { }
}";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (10,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 25),
                // (10,24): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(10, 24),
                // (10,33): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 33),
                // (10,53): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 53),
                // (10,52): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(10, 52),
                // (10,74): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 74),
                // (10,73): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(10, 73),
                // (10,77): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 77),
                // (10,79): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 79),
                // (10,82): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 82),
                // (10,18): warning CS8611: Nullability of reference types in type of parameter 'x' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("x").WithLocation(10, 18),
                // (10,18): warning CS8611: Nullability of reference types in type of parameter 'y' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("y").WithLocation(10, 18),
                // (10,18): warning CS8611: Nullability of reference types in type of parameter 'z' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("z").WithLocation(10, 18),
                // (5,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 30),
                // (5,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 29),
                // (5,72): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 72),
                // (5,71): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 71),
                // (5,75): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 75),
                // (5,77): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 77),
                // (5,80): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 80)
                );
        }

        [Fact]
        public void PartialMethods_02_02()
        {
            var source = @"
partial class C1
{
" + NonNullTypesOff() + @"
    partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
}
" + NonNullTypesOn() + @"
partial class C1
{
    partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
    { }
}";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (10,18): warning CS8611: Nullability of reference types in type of parameter 'x' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("x").WithLocation(10, 18),
                // (10,18): warning CS8611: Nullability of reference types in type of parameter 'y' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("y").WithLocation(10, 18),
                // (10,18): warning CS8611: Nullability of reference types in type of parameter 'z' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("z").WithLocation(10, 18),
                // (5,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 30),
                // (5,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 29),
                // (5,72): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 72),
                // (5,71): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 71),
                // (5,75): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 75),
                // (5,77): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 77),
                // (5,80): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 80)
                );
        }

        [Fact]
        public void PartialMethods_03()
        {
            var source = @"
class C
{
    public static void Main()
    { 
    }
}

partial class C1
{
    partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
}

partial class C1
{
" + NonNullTypesOff() + @"
    partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
    { }
}";
            var compilation = CreateCompilation(new[] { source });
            compilation.VerifyDiagnostics(
                // (17,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 25),
                // (17,24): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(17, 24),
                // (17,33): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 33),
                // (17,53): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 53),
                // (17,52): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(17, 52),
                // (17,74): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 74),
                // (17,73): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(17, 73),
                // (17,77): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 77),
                // (17,79): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 79),
                // (17,82): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 82),
                // (17,18): warning CS8611: Nullability of reference types in type of parameter 'x' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("x").WithLocation(17, 18),
                // (17,18): warning CS8611: Nullability of reference types in type of parameter 'y' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("y").WithLocation(17, 18),
                // (17,18): warning CS8611: Nullability of reference types in type of parameter 'z' doesn't match partial method declaration.
                //     partial void M1<T>(T? x, T[]? y, System.Action<T?> z, System.Action<T?[]?>?[]? u) where T : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnPartial, "M1").WithArguments("z").WithLocation(17, 18),
                // (11,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 30),
                // (11,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(11, 29),
                // (11,72): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 72),
                // (11,71): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(11, 71),
                // (11,75): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 75),
                // (11,77): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 77),
                // (11,80): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     partial void M1<T>(T x, T?[] y, System.Action<T> z, System.Action<T?[]?>?[]? u) where T : class;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 80)
                );
        }

        [Fact]
        public void Overloading_01()
        {
            var source = @"
class A
{
    void Test1(string? x1) {}
    void Test1(string x2) {}

    string Test2(string y1) { return y1; }
    string? Test2(string y2) { return y2; }
}
";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).
                VerifyDiagnostics(
                // (5,10): error CS0111: Type 'A' already defines a member called 'Test1' with the same parameter types
                //     void Test1(string x2) {}
                Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "Test1").WithArguments("Test1", "A").WithLocation(5, 10),
                // (8,13): error CS0111: Type 'A' already defines a member called 'Test2' with the same parameter types
                //     string? Test2(string y2) { return y2; }
                Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "Test2").WithArguments("Test2", "A").WithLocation(8, 13)
                );
        }

        [Fact]
        public void Overloading_02()
        {
            var source = @"
class A
{
    public void M1<T>(T? x) where T : struct 
    { 
    }

    public void M1<T>(T? x) where T : class 
    { 
    }
}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics();
        }

        [Fact()]
        public void Test1()
        {
            CSharpCompilation c = CreateCompilation(
new[] { @"#pragma warning disable 8618
class C
{
    static void Main()
    {
    }

    void Test1()
    {
        string? x1 = null;
        string? y1 = x1; 
        string z1 = x1; 
    }

    void Test2()
    {
        string? x2 = """";
        string z2 = x2;
    }

    void Test3()
    {
        string? x3;
        string z3 = x3;
    }

    void Test4()
    {
        string x4;
        string z4 = x4;
    }

    void Test5()
    {
        string? x5 = """";
        x5 = null;
        string? y5;
        y5 = x5;
        string z5;
        z5 = x5;
    }

    void Test6()
    {
        string? x6 = """";
        string z6;
        z6 = x6;
    }

    void Test7()
    {
        CL1? x7 = null;
        CL1 y7 = x7.P1;
        CL1 z7 = x7?.P1;
        x7 = new CL1();
        CL1 u7 = x7.P1;
    }

    void Test8()
    {
        CL1? x8 = new CL1();
        CL1 y8 = x8.M1();
        x8 = null;
        CL1 u8 = x8.M1();
        CL1 z8 = x8?.M1();
    }

    void Test9(CL1? x9, CL1 y9)
    {
        CL1 u9;
        u9 = x9;
        u9 = y9;
        x9 = y9;
        CL1 v9;
        v9 = x9;
        y9 = null;
    }

    void Test10(CL1 x10)
    {
        CL1 u10;
        u10 = x10.P1;
        u10 = x10.P2;
        u10 = x10.M1();
        u10 = x10.M2();
        CL1? v10;
        v10 = x10.P2;
        v10 = x10.M2();
    }

    void Test11(CL1 x11, CL1? y11)
    {
        CL1 u11;
        u11 = x11.F1;
        u11 = x11.F2;
        CL1? v11;
        v11 = x11.F2;
        x11.F2 = x11.F1;
        u11 = x11.F2;

        v11 = y11.F1;
    }

    void Test12(CL1 x12)
    {
        S1 y12;
        CL1 u12;
        u12 = y12.F3;
        u12 = y12.F4;
    }

    void Test13(CL1 x13)
    {
        S1 y13;
        CL1? u13;
        u13 = y13.F3;
        u13 = y13.F4;
    }

    void Test14(CL1 x14)
    {
        S1 y14;
        y14.F3 = null;
        y14.F4 = null;
        y14.F3 = x14;
        y14.F4 = x14;
    }

    void Test15(CL1 x15)
    {
        S1 y15;
        CL1 u15;
        y15.F3 = null;
        y15.F4 = null;
        u15 = y15.F3;
        u15 = y15.F4;

        CL1? v15;
        v15 = y15.F4;
        y15.F4 = x15;
        u15 = y15.F4;
    }

    void Test16()
    {
        S1 y16;
        CL1 u16;
        y16 = new S1();
        u16 = y16.F3;
        u16 = y16.F4;
    }

    void Test17(CL1 z17)
    {
        S1 x17;
        x17.F4 = z17;
        S1 y17 = new S1();
        CL1 u17;
        u17 = y17.F4;

        y17 = x17;
        CL1 v17;
        v17 = y17.F4;
    }

    void Test18(CL1 z18)
    {
        S1 x18;
        x18.F4 = z18;
        S1 y18 = x18;
        CL1 u18;
        u18 = y18.F4;
    }

    void Test19(S1 x19, CL1 z19)
    {
        S1 y19;
        y19.F4 = null;
        CL1 u19;
        u19 = y19.F4;

        x19.F4 = z19;
        y19 = x19;
        CL1 v19;
        v19 = y19.F4;
    }

    void Test20(S1 x20, CL1 z20)
    {
        S1 y20;
        y20.F4 = z20;
        CL1 u20;
        u20 = y20.F4;

        y20 = x20;
        CL1 v20;
        v20 = y20.F4;
    }

    S1 GetS1()
    {
        return new S1();
    }
    void Test21(CL1 z21)
    {
        S1 y21;
        y21.F4 = z21;
        CL1 u21;
        u21 = y21.F4;

        y21 = GetS1();
        CL1 v21;
        v21 = y21.F4;
    }

    void Test22()
    {
        S1 y22;
        CL1 u22;
        u22 = y22.F4;

        y22 = GetS1();
        CL1 v22;
        v22 = y22.F4;
    }

    void Test23(CL1 z23)
    {
        S2 y23;
        y23.F5.F4 = z23;
        CL1 u23;
        u23 = y23.F5.F4;

        y23 = GetS2();
        CL1 v23;
        v23 = y23.F5.F4;
    }

    S2 GetS2()
    {
        return new S2();
    }

    void Test24()
    {
        S2 y24;
        CL1 u24;
        u24 = y24.F5.F4; // 1
        u24 = y24.F5.F4; // 2

        y24 = GetS2();
        CL1 v24;
        v24 = y24.F5.F4;
    }

    void Test25(CL1 z25)
    {
        S2 y25;
        S2 x25 = GetS2();
        x25.F5.F4 = z25;
        y25 = x25;
        CL1 v25;
        v25 = y25.F5.F4;
    }

    void Test26(CL1 x26, CL1? y26, CL1 z26)
    {
        x26.P1 = y26;
        x26.P1 = z26;
    }

    void Test27(CL1 x27, CL1? y27, CL1 z27)
    {
        x27[x27] = y27;
        x27[x27] = z27;
    }

    void Test28(CL1 x28, CL1? y28, CL1 z28)
    {
        x28[y28] = z28;
    }

    void Test29(CL1 x29, CL1 y29, CL1 z29)
    {
        z29 = x29[y29];
        z29 = x29[1];
    }

    void Test30(CL1? x30, CL1 y30, CL1 z30)
    {
        z30 = x30[y30];
    }

    void Test31(CL1 x31)
    {
        x31 = default(CL1);
    }

    void Test32(CL1 x32)
    {
        var y32 = new CL1() ?? x32;
    }

    void Test33(object x33)
    {
        var y33 = new { p = (object)null } ?? x33;
    }
}

class CL1
{
    public CL1()
    {
        F1 = this;
    }

    public CL1 F1;
    public CL1? F2;

    public CL1 P1 { get; set; }
    public CL1? P2 { get; set; }

    public CL1 M1() { return new CL1(); }
    public CL1? M2() { return null; }

    public CL1 this[CL1 x]
    {
        get { return x; }
        set { }
    }

    public CL1? this[int x]
    {
        get { return null; }
        set { }
    }
}

struct S1
{
    public CL1 F3;
    public CL1? F4;
}

struct S2
{
    public S1 F5;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         string z1 = x1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(12, 21),
                // (24,21): error CS0165: Use of unassigned local variable 'x3'
                //         string z3 = x3;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x3").WithArguments("x3").WithLocation(24, 21),
                // (30,21): error CS0165: Use of unassigned local variable 'x4'
                //         string z4 = x4;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x4").WithArguments("x4").WithLocation(30, 21),
                // (40,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z5 = x5;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x5").WithLocation(40, 14),
                // (53,18): warning CS8602: Possible dereference of a null reference.
                //         CL1 y7 = x7.P1;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x7").WithLocation(53, 18),
                // (54,18): hidden CS8607: Expression is probably never null.
                //         CL1 z7 = x7?.P1;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x7").WithLocation(54, 18),
                // (64,18): warning CS8602: Possible dereference of a null reference.
                //         CL1 u8 = x8.M1();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x8").WithLocation(64, 18),
                // (65,18): hidden CS8607: Expression is probably never null.
                //         CL1 z8 = x8?.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x8").WithLocation(65, 18),
                // (71,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u9 = x9;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x9").WithLocation(71, 14),
                // (76,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y9 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(76, 14),
                // (83,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u10 = x10.P2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x10.P2").WithLocation(83, 15),
                // (85,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u10 = x10.M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x10.M2()").WithLocation(85, 15),
                // (95,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u11 = x11.F2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x11.F2").WithLocation(95, 15),
                // (101,15): warning CS8602: Possible dereference of a null reference.
                //         v11 = y11.F1;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y11").WithLocation(101, 15),
                // (108,15): error CS0170: Use of possibly unassigned field 'F3'
                //         u12 = y12.F3;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y12.F3").WithArguments("F3").WithLocation(108, 15),
                // (109,15): error CS0170: Use of possibly unassigned field 'F4'
                //         u12 = y12.F4;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y12.F4").WithArguments("F4").WithLocation(109, 15),
                // (116,15): error CS0170: Use of possibly unassigned field 'F3'
                //         u13 = y13.F3;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y13.F3").WithArguments("F3").WithLocation(116, 15),
                // (117,15): error CS0170: Use of possibly unassigned field 'F4'
                //         u13 = y13.F4;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y13.F4").WithArguments("F4").WithLocation(117, 15),
                // (123,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         y14.F3 = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(123, 18),
                // (133,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         y15.F3 = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(133, 18),
                // (135,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u15 = y15.F3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y15.F3").WithLocation(135, 15),
                // (136,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u15 = y15.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y15.F4").WithLocation(136, 15),
                // (149,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u16 = y16.F3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y16.F3").WithLocation(149, 15),
                // (150,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u16 = y16.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y16.F4").WithLocation(150, 15),
                // (161,15): error CS0165: Use of unassigned local variable 'x17'
                //         y17 = x17;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x17").WithArguments("x17").WithLocation(161, 15),
                // (159,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u17 = y17.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y17.F4").WithLocation(159, 15),
                // (170,18): error CS0165: Use of unassigned local variable 'x18'
                //         S1 y18 = x18;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x18").WithArguments("x18").WithLocation(170, 18),
                // (180,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u19 = y19.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y19.F4").WithLocation(180, 15),
                // (197,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         v20 = y20.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y20.F4").WithLocation(197, 15),
                // (213,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         v21 = y21.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y21.F4").WithLocation(213, 15),
                // (220,15): error CS0170: Use of possibly unassigned field 'F4'
                //         u22 = y22.F4;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y22.F4").WithArguments("F4").WithLocation(220, 15),
                // (224,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         v22 = y22.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y22.F4").WithLocation(224, 15),
                // (236,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         v23 = y23.F5.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y23.F5.F4").WithLocation(236, 15),
                // (248,15): error CS0170: Use of possibly unassigned field 'F4'
                //         u24 = y24.F5.F4; // 1
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y24.F5.F4").WithArguments("F4").WithLocation(248, 15),
                // (253,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         v24 = y24.F5.F4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y24.F5.F4").WithLocation(253, 15),
                // (268,18): warning CS8601: Possible null reference assignment.
                //         x26.P1 = y26;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y26").WithLocation(268, 18),
                // (274,20): warning CS8601: Possible null reference assignment.
                //         x27[x27] = y27;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y27").WithLocation(274, 20),
                // (280,13): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1 CL1.this[CL1 x]'.
                //         x28[y28] = z28;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y28").WithArguments("x", "CL1 CL1.this[CL1 x]").WithLocation(280, 13),
                // (286,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z29 = x29[1];
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x29[1]").WithLocation(286, 15),
                // (291,15): warning CS8602: Possible dereference of a null reference.
                //         z30 = x30[y30];
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x30").WithLocation(291, 15),
                // (296,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x31 = default(CL1);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(CL1)").WithLocation(296, 15),
                // (301,19): hidden CS8607: Expression is probably never null.
                //         var y32 = new CL1() ?? x32;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new CL1()").WithLocation(301, 19),
                // (306,29): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var y33 = new { p = (object)null } ?? x33;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)null").WithLocation(306, 29),
                // (306,19): hidden CS8607: Expression is probably never null.
                //         var y33 = new { p = (object)null } ?? x33;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new { p = (object)null }").WithLocation(306, 19));
        }

        [Fact]
        public void PassingParameters_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void M1(CL1 p) {}

    void Test1(CL1? x1, CL1 y1)
    {
        M1(x1);
        M1(y1);
    }

    void Test2()
    {
        CL1? x2;
        M1(x2);
    }

    void M2(ref CL1? p) {}

    void Test3()
    {
        CL1 x3;
        M2(ref x3);
    }

    void Test4(CL1 x4)
    {
        M2(ref x4);
    }

    void M3(out CL1? p) { p = null; }

    void Test5()
    {
        CL1 x5;
        M3(out x5);
    }

    void M4(ref CL1 p) {}

    void Test6()
    {
        CL1? x6 = null;
        M4(ref x6);
    }

    void M5(out CL1 p) { p = new CL1(); }

    void Test7()
    {
        CL1? x7 = null;
        CL1 u7 = x7;
        M5(out x7);
        CL1 v7 = x7;
    }

    void M6(CL1 p1, CL1? p2) {}

    void Test8(CL1? x8, CL1? y8)
    {
        M6(p2: x8, p1: y8);
    }

    void M7(params CL1[] p1) {}

    void Test9(CL1 x9, CL1? y9)
    {
        M7(x9, y9);
    }

    void Test10(CL1? x10, CL1 y10)
    {
        M7(x10, y10);
    }

    void M8(CL1 p1, params CL1[] p2) {}

    void Test11(CL1? x11, CL1 y11, CL1? z11)
    {
        M8(x11, y11, z11);
    }

    void Test12(CL1? x12, CL1 y12)
    {
        M8(p2: x12, p1: y12);
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (12,12): warning CS8604: Possible null reference argument for parameter 'p' in 'void C.M1(CL1 p)'.
                //         M1(x1);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("p", "void C.M1(CL1 p)").WithLocation(12, 12),
                // (19,12): error CS0165: Use of unassigned local variable 'x2'
                //         M1(x2);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x2").WithArguments("x2").WithLocation(19, 12),
                // (27,16): error CS0165: Use of unassigned local variable 'x3'
                //         M2(ref x3);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x3").WithArguments("x3").WithLocation(27, 16),
                // (32,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         M2(ref x4);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x4").WithLocation(32, 16),
                // (40,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         M3(out x5);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x5").WithLocation(40, 16),
                // (48,16): warning CS8604: Possible null reference argument for parameter 'p' in 'void C.M4(ref CL1 p)'.
                //         M4(ref x6);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x6").WithArguments("p", "void C.M4(ref CL1 p)").WithLocation(48, 16),
                // (56,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u7 = x7;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x7").WithLocation(56, 18),
                // (65,24): warning CS8604: Possible null reference argument for parameter 'p1' in 'void C.M6(CL1 p1, CL1? p2)'.
                //         M6(p2: x8, p1: y8);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y8").WithArguments("p1", "void C.M6(CL1 p1, CL1? p2)").WithLocation(65, 24),
                // (72,16): warning CS8604: Possible null reference argument for parameter 'p1' in 'void C.M7(params CL1[] p1)'.
                //         M7(x9, y9);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y9").WithArguments("p1", "void C.M7(params CL1[] p1)").WithLocation(72, 16),
                // (77,12): warning CS8604: Possible null reference argument for parameter 'p1' in 'void C.M7(params CL1[] p1)'.
                //         M7(x10, y10);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x10").WithArguments("p1", "void C.M7(params CL1[] p1)").WithLocation(77, 12),
                // (84,12): warning CS8604: Possible null reference argument for parameter 'p1' in 'void C.M8(CL1 p1, params CL1[] p2)'.
                //         M8(x11, y11, z11);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x11").WithArguments("p1", "void C.M8(CL1 p1, params CL1[] p2)").WithLocation(84, 12),
                // (84,22): warning CS8604: Possible null reference argument for parameter 'p2' in 'void C.M8(CL1 p1, params CL1[] p2)'.
                //         M8(x11, y11, z11);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "z11").WithArguments("p2", "void C.M8(CL1 p1, params CL1[] p2)").WithLocation(84, 22),
                // (89,16): warning CS8604: Possible null reference argument for parameter 'p2' in 'void C.M8(CL1 p1, params CL1[] p2)'.
                //         M8(p2: x12, p1: y12);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x12").WithArguments("p2", "void C.M8(CL1 p1, params CL1[] p2)").WithLocation(89, 16));
        }

        [Fact]
        public void PassingParameters_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0 x1)
    {
        var y1 = new CL0() { [null] = x1 };
    }
}

class CL0
{
    public CL0 this[CL0 x]
    {
        get { return x; }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         var y1 = new CL0() { [null] = x1 };
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(10, 31));
        }

        [Fact]
        public void PassingParameters_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0 x1)
    {
        var y1 = new CL0() { null };
    }
}

class CL0 : System.Collections.IEnumerable 
{
    public void Add(CL0 x)
    {
    }

    System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
    {
        throw new System.NotImplementedException();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,30): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         var y1 = new CL0() { null };
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(10, 30));
        }

        [Fact]
        public void PassingParameters_04()
        {
            var source =
@"interface I<T> { }
class C
{
    static void F(I<object> x, I<object?> y, I<object>? z, I<object?>? w, I<object?>[]? a)
    {
        G(x);
        G(y);
        G(x, x, x);
        G(x, y, y);
        G(x, x, y, z, w);
        G(y: x, x: y);
        G(y: y, x: x);
        G(x, a);
        G(x, new I<object?>[0]);
        G(x, new[] { x, x });
        G(x, new[] { y, y });
        G(x, new[] { x, y, z });
        G(y: new[] { x, x }, x: y);
        G(y: new[] { y, y }, x: x);
    }
    static void G(I<object> x, params I<object?>[] y)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,11): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("I<object?>", "I<object>", "x", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(7, 11),
                // (8,14): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, x, x);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(8, 14),
                // (8,17): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, x, x);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(8, 17),
                // (10,14): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, x, y, z, w);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(10, 14),
                // (10,20): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, x, y, z, w);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "z").WithArguments("y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(10, 20),
                // (10,20): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, x, y, z, w);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("I<object>", "I<object?>", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(10, 20),
                // (10,23): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, x, y, z, w);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "w").WithArguments("y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(10, 23),
                // (11,14): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(y: x, x: y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(11, 14),
                // (11,20): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(y: x, x: y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("I<object?>", "I<object>", "x", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(11, 20),
                // (13,14): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, a);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a").WithArguments("y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(13, 14),
                // (15,14): warning CS8620: Nullability of reference types in argument of type 'I<object>[]' doesn't match target type 'I<object?>[]' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, new[] { x, x });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new[] { x, x }").WithArguments("I<object>[]", "I<object?>[]", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(15, 14),
                // (17,14): warning CS8620: Nullability of reference types in argument of type 'I<object>?[]' doesn't match target type 'I<object?>[]' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(x, new[] { x, y, z });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new[] { x, y, z }").WithArguments("I<object>?[]", "I<object?>[]", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(17, 14),
                // (17,25): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         G(x, new[] { x, y, z });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(17, 25),
                // (18,14): warning CS8620: Nullability of reference types in argument of type 'I<object>[]' doesn't match target type 'I<object?>[]' for parameter 'y' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(y: new[] { x, x }, x: y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "new[] { x, x }").WithArguments("I<object>[]", "I<object?>[]", "y", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(18, 14),
                // (18,33): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.G(I<object> x, params I<object?>[] y)'.
                //         G(y: new[] { x, x }, x: y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("I<object?>", "I<object>", "x", "void C.G(I<object> x, params I<object?>[] y)").WithLocation(18, 33));
        }

        [Fact]
        public void PassingParameters_DifferentRefKinds()
        {
            var source = @"
class C
{
    void M(string xNone, ref string xRef, out string xOut)
    {
        xNone = null;
        xRef = null;
        xOut = null;
    }
}
";
            var c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (6,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         xNone = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(6, 17),
                // (7,16): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         xRef = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(7, 16),
                // (8,16): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         xOut = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(8, 16)
                );

            var source2 = @"
class C
{
    void M(in string xIn)
    {
        xIn = null;
    }
}
";
            var c2 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue());
            c2.VerifyDiagnostics(
                // (6,9): error CS8331: Cannot assign to variable 'in string' because it is a readonly variable
                //         xIn = null;
                Diagnostic(ErrorCode.ERR_AssignReadonlyNotField, "xIn").WithArguments("variable", "in string").WithLocation(6, 9)
                );
        }

        [Fact]
        [WorkItem(29916, "https://github.com/dotnet/roslyn/issues/29916")]
        public void PassingParameters_UnknownMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static int F(object x)
    {
        Missing(F(null)); // 1
        Missing(F(x = null)); // 2
        x.ToString(); // 3

        Missing(F(x = this)); // 4
        x.ToString();
        return 0;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,9): error CS0103: The name 'Missing' does not exist in the current context
                //         Missing(F(null)); // 1
                Diagnostic(ErrorCode.ERR_NameNotInContext, "Missing").WithArguments("Missing").WithLocation(6, 9),
                // (6,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         Missing(F(null)); // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 19),
                // (7,9): error CS0103: The name 'Missing' does not exist in the current context
                //         Missing(F(x = null)); // 2
                Diagnostic(ErrorCode.ERR_NameNotInContext, "Missing").WithArguments("Missing").WithLocation(7, 9),
                // (7,19): warning CS8604: Possible null reference argument for parameter 'x' in 'int C.F(object x)'.
                //         Missing(F(x = null)); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x = null").WithArguments("x", "int C.F(object x)").WithLocation(7, 19),
                // (7,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         Missing(F(x = null)); // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(7, 23),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 9),
                // (10,9): error CS0103: The name 'Missing' does not exist in the current context
                //         Missing(F(x = this)); // 4
                Diagnostic(ErrorCode.ERR_NameNotInContext, "Missing").WithArguments("Missing").WithLocation(10, 9),
                // (10,23): error CS0026: Keyword 'this' is not valid in a static property, static method, or static field initializer
                //         Missing(F(x = this)); // 4
                Diagnostic(ErrorCode.ERR_ThisInStaticMeth, "this").WithLocation(10, 23)
                );
        }

        [Fact]
        [WorkItem(29916, "https://github.com/dotnet/roslyn/issues/29916")]
        public void PassingParameters_UnknownMethod_UnknownReceiver()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static int F(object x)
    {
        bad.Missing(F(null)); // 1
        bad.Missing(F(x = null)); // 2
        x.ToString(); // 3

        bad.Missing(F(x = this)); // 4
        x.ToString();
        return 0;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,9): error CS0103: The name 'bad' does not exist in the current context
                //         bad.Missing(F(null)); // 1
                Diagnostic(ErrorCode.ERR_NameNotInContext, "bad").WithArguments("bad").WithLocation(6, 9),
                // (6,23): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         bad.Missing(F(null)); // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 23),
                // (7,9): error CS0103: The name 'bad' does not exist in the current context
                //         bad.Missing(F(x = null)); // 2
                Diagnostic(ErrorCode.ERR_NameNotInContext, "bad").WithArguments("bad").WithLocation(7, 9),
                // (7,23): warning CS8604: Possible null reference argument for parameter 'x' in 'int C.F(object x)'.
                //         bad.Missing(F(x = null)); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x = null").WithArguments("x", "int C.F(object x)").WithLocation(7, 23),
                // (7,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         bad.Missing(F(x = null)); // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(7, 27),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 9),
                // (10,9): error CS0103: The name 'bad' does not exist in the current context
                //         bad.Missing(F(x = this)); // 4
                Diagnostic(ErrorCode.ERR_NameNotInContext, "bad").WithArguments("bad").WithLocation(10, 9),
                // (10,27): error CS0026: Keyword 'this' is not valid in a static property, static method, or static field initializer
                //         bad.Missing(F(x = this)); // 4
                Diagnostic(ErrorCode.ERR_ThisInStaticMeth, "this").WithLocation(10, 27)
                );
        }

        [Fact]
        [WorkItem(29916, "https://github.com/dotnet/roslyn/issues/29916")]
        public void PassingParameters_UnknownMethod_AffectingState()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    object F(object x)
    {
        Missing(
            F(x = null) /*warn*/,
            x.ToString() /*warn*/,
            F(x = this),
            x.ToString());
        return x;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,9): error CS0103: The name 'Missing' does not exist in the current context
                //         Missing(
                Diagnostic(ErrorCode.ERR_NameNotInContext, "Missing").WithArguments("Missing").WithLocation(6, 9),
                // (7,15): warning CS8604: Possible null reference argument for parameter 'x' in 'object C.F(object x)'.
                //             F(x = null) /*warn*/,
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x = null").WithArguments("x", "object C.F(object x)").WithLocation(7, 15),
                // (7,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             F(x = null) /*warn*/,
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(7, 19),
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString() /*warn*/,
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13)
                );
        }

        [Fact]
        [WorkItem(29916, "https://github.com/dotnet/roslyn/issues/29916")]
        public void PassingParameters_UnknownMethod_AffectingConditionalState()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    int F(object x)
    {
        if (G(F(x = null)))
        {
            x.ToString(); // 1
        }
        else
        {
            x.ToString(); // 2
        }
        return 0;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,13): error CS0103: The name 'G' does not exist in the current context
                //         if (G(F(x = null)))
                Diagnostic(ErrorCode.ERR_NameNotInContext, "G").WithArguments("G").WithLocation(6, 13),
                // (6,17): warning CS8604: Possible null reference argument for parameter 'x' in 'int C.F(object x)'.
                //         if (G(F(x = null)))
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x = null").WithArguments("x", "int C.F(object x)").WithLocation(6, 17),
                // (6,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         if (G(F(x = null)))
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(6, 21),
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(12, 13)
                );
        }

        [Fact]
        [WorkItem(29916, "https://github.com/dotnet/roslyn/issues/29916")]
        public void PassingParameters_UnknownMethod_AffectingConditionalState2()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void F(object x)
    {
        if (Missing(x) && Missing(x = null))
        {
            x.ToString(); // 1
        }
        else
        {
            x.ToString(); // 2
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,13): error CS0103: The name 'Missing' does not exist in the current context
                //         if (Missing(x) && Missing(x = null))
                Diagnostic(ErrorCode.ERR_NameNotInContext, "Missing").WithArguments("Missing").WithLocation(6, 13),
                // (6,27): error CS0103: The name 'Missing' does not exist in the current context
                //         if (Missing(x) && Missing(x = null))
                Diagnostic(ErrorCode.ERR_NameNotInContext, "Missing").WithArguments("Missing").WithLocation(6, 27),
                // (6,39): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         if (Missing(x) && Missing(x = null))
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(6, 39),
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(12, 13)
                );
        }

        [Fact]
        public void DuplicateArguments()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        // Duplicate x
        G(x: x, x: y);
        G(x: y, x: x);
        G(x: x, x: y, y: y);
        G(x: y, x: x, y: y);
        G(y: y, x: x, x: y);
        G(y: y, x: y, x: x);
        // Duplicate y
        G(y: x, y: y);
        G(y: y, y: x);
        G(x, y: x, y: y);
        G(x, y: y, y: x);
        G(y: x, y: y, x: x);
        G(y: y, y: x, x: x);
    }
    static void G(object x, params object?[] y)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,17): error CS1740: Named argument 'x' cannot be specified multiple times
                //         G(x: x, x: y);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "x").WithArguments("x").WithLocation(6, 17),
                // (7,17): error CS1740: Named argument 'x' cannot be specified multiple times
                //         G(x: y, x: x);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "x").WithArguments("x").WithLocation(7, 17),
                // (8,17): error CS1740: Named argument 'x' cannot be specified multiple times
                //         G(x: x, x: y, y: y);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "x").WithArguments("x").WithLocation(8, 17),
                // (9,17): error CS1740: Named argument 'x' cannot be specified multiple times
                //         G(x: y, x: x, y: y);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "x").WithArguments("x").WithLocation(9, 17),
                // (10,23): error CS1740: Named argument 'x' cannot be specified multiple times
                //         G(y: y, x: x, x: y);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "x").WithArguments("x").WithLocation(10, 23),
                // (11,23): error CS1740: Named argument 'x' cannot be specified multiple times
                //         G(y: y, x: y, x: x);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "x").WithArguments("x").WithLocation(11, 23),
                // (13,9): error CS7036: There is no argument given that corresponds to the required formal parameter 'x' of 'C.G(object, params object?[])'
                //         G(y: x, y: y);
                Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "G").WithArguments("x", "C.G(object, params object?[])").WithLocation(13, 9),
                // (14,9): error CS7036: There is no argument given that corresponds to the required formal parameter 'x' of 'C.G(object, params object?[])'
                //         G(y: y, y: x);
                Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "G").WithArguments("x", "C.G(object, params object?[])").WithLocation(14, 9),
                // (15,20): error CS1740: Named argument 'y' cannot be specified multiple times
                //         G(x, y: x, y: y);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "y").WithArguments("y").WithLocation(15, 20),
                // (16,20): error CS1740: Named argument 'y' cannot be specified multiple times
                //         G(x, y: y, y: x);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "y").WithArguments("y").WithLocation(16, 20),
                // (17,17): error CS1740: Named argument 'y' cannot be specified multiple times
                //         G(y: x, y: y, x: x);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "y").WithArguments("y").WithLocation(17, 17),
                // (18,17): error CS1740: Named argument 'y' cannot be specified multiple times
                //         G(y: y, y: x, x: x);
                Diagnostic(ErrorCode.ERR_DuplicateNamedArgument, "y").WithArguments("y").WithLocation(18, 17));
        }

        [Fact]
        public void MissingArguments()
        {
            var source =
@"class C
{
    static void F(object? x)
    {
        G(y: x);
    }
    static void G(object? x = null, object y)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,45): error CS1737: Optional parameters must appear after all required parameters
                //     static void G(object? x = null, object y)
                Diagnostic(ErrorCode.ERR_DefaultValueBeforeRequiredValue, ")").WithLocation(7, 45),
                // (5,14): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(object? x = null, object y)'.
                //         G(y: x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("y", "void C.G(object? x = null, object y)").WithLocation(5, 14));
        }

        [Fact]
        public void ParamsArgument_NotLast()
        {
            var source =
@"class C
{
    static void F(object[]? a, object? b)
    {
        G(a, b, a);
    }
    static void G(params object[] x, params object[] y)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,19): error CS0231: A params parameter must be the last parameter in a formal parameter list
                //     static void G(params object[] x, params object[] y)
                Diagnostic(ErrorCode.ERR_ParamsLast, "params object[] x").WithLocation(7, 19),
                // (5,11): warning CS8604: Possible null reference argument for parameter 'x' in 'void C.G(params object[] x, params object[] y)'.
                //         G(a, b, a);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a").WithArguments("x", "void C.G(params object[] x, params object[] y)").WithLocation(5, 11),
                // (5,14): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(params object[] x, params object[] y)'.
                //         G(a, b, a);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b").WithArguments("y", "void C.G(params object[] x, params object[] y)").WithLocation(5, 14),
                // (5,17): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(params object[] x, params object[] y)'.
                //         G(a, b, a);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a").WithArguments("y", "void C.G(params object[] x, params object[] y)").WithLocation(5, 17));
        }

        [Fact]
        public void ParamsArgument_NotArray()
        {
            var source =
@"class C
{
    static void F1(object x, object? y)
    {
        F2(y);
        F2(x, y);
        F3(y, x);
        F3(x, y, x);
    }
    static void F2(params object x)
    {
    }
    static void F3(params object x, params object[] y)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,20): error CS0225: The params parameter must be a single dimensional array
                //     static void F2(params object x)
                Diagnostic(ErrorCode.ERR_ParamsMustBeArray, "params").WithLocation(10, 20),
                // (13,20): error CS0225: The params parameter must be a single dimensional array
                //     static void F3(params object x, params object[] y)
                Diagnostic(ErrorCode.ERR_ParamsMustBeArray, "params").WithLocation(13, 20),
                // (13,20): error CS0231: A params parameter must be the last parameter in a formal parameter list
                //     static void F3(params object x, params object[] y)
                Diagnostic(ErrorCode.ERR_ParamsLast, "params object x").WithLocation(13, 20),
                // (6,9): error CS1501: No overload for method 'F2' takes 2 arguments
                //         F2(x, y);
                Diagnostic(ErrorCode.ERR_BadArgCount, "F2").WithArguments("F2", "2").WithLocation(6, 9),
                // (5,12): warning CS8604: Possible null reference argument for parameter 'x' in 'void C.F2(params object x)'.
                //         F2(y);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void C.F2(params object x)").WithLocation(5, 12),
                // (7,12): warning CS8604: Possible null reference argument for parameter 'x' in 'void C.F3(params object x, params object[] y)'.
                //         F3(y, x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void C.F3(params object x, params object[] y)").WithLocation(7, 12),
                // (8,15): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.F3(params object x, params object[] y)'.
                //         F3(x, y, x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("y", "void C.F3(params object x, params object[] y)").WithLocation(8, 15));
        }

        [Fact]
        public void ParamsArgument_BinaryOperator()
        {
            var source =
@"class C
{
    public static object operator+(C x, params object?[] y) => x;
    static object F(C x, object[] y) => x + y;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,41): error CS1670: params is not valid in this context
                //     public static object operator+(C x, params object?[] y) => x;
                Diagnostic(ErrorCode.ERR_IllegalParams, "params").WithLocation(3, 41),
                // (4,45): warning CS8620: Nullability of reference types in argument of type 'object[]' doesn't match target type 'object?[]' for parameter 'y' in 'object C.operator +(C x, params object?[] y)'.
                //     static object F(C x, object[] y) => x + y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("object[]", "object?[]", "y", "object C.operator +(C x, params object?[] y)").WithLocation(4, 45));
        }

        [Fact]
        public void RefOutParameters_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(ref CL1 x1, CL1 y1)
    {
        y1 = x1;
    }

    void Test2(ref CL1? x2, CL1 y2)
    {
        y2 = x2;
    }

    void Test3(ref CL1? x3, CL1 y3)
    {
        x3 = y3;
        y3 = x3;
    }

    void Test4(out CL1 x4, CL1 y4)
    {
        y4 = x4;
        x4 = y4;
    }

    void Test5(out CL1? x5, CL1 y5)
    {
        y5 = x5;
        x5 = y5;
    }

    void Test6(out CL1? x6, CL1 y6)
    {
        x6 = y6;
        y6 = x6;
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         y2 = x2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(15, 14),
                 // (26,14): error CS0269: Use of unassigned out parameter 'x4'
                 //         y4 = x4;
                 Diagnostic(ErrorCode.ERR_UseDefViolationOut, "x4").WithArguments("x4").WithLocation(26, 14),
                 // (32,14): error CS0269: Use of unassigned out parameter 'x5'
                 //         y5 = x5;
                 Diagnostic(ErrorCode.ERR_UseDefViolationOut, "x5").WithArguments("x5").WithLocation(32, 14)
                );
        }

        [Fact]
        public void RefOutParameters_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(ref S1 x1, CL1 y1)
    {
        y1 = x1.F1;
    }

    void Test2(ref S1 x2, CL1 y2)
    {
        y2 = x2.F2;
    }

    void Test3(ref S1 x3, CL1 y3)
    {
        x3.F2 = y3;
        y3 = x3.F2;
    }

    void Test4(out S1 x4, CL1 y4)
    {
        y4 = x4.F1;
        x4.F1 = y4;
        x4.F2 = y4;
    }

    void Test5(out S1 x5, CL1 y5)
    {
        y5 = x5.F2;
        x5.F1 = y5;
        x5.F2 = y5;
    }

    void Test6(out S1 x6, CL1 y6)
    {
        x6.F1 = y6;
        x6.F2 = y6;
        y6 = x6.F2;
    }
}

class CL1
{
}

struct S1
{
    public CL1 F1;
    public CL1? F2;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         y2 = x2.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2.F2").WithLocation(15, 14),
                 // (26,14): error CS0170: Use of possibly unassigned field 'F1'
                 //         y4 = x4.F1;
                 Diagnostic(ErrorCode.ERR_UseDefViolationField, "x4.F1").WithArguments("F1").WithLocation(26, 14),
                 // (33,14): error CS0170: Use of possibly unassigned field 'F2'
                 //         y5 = x5.F2;
                 Diagnostic(ErrorCode.ERR_UseDefViolationField, "x5.F2").WithArguments("F2").WithLocation(33, 14)
                );
        }

        [Fact]
        public void RefOutParameters_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test3(ref S1 x3, CL1 y3)
    {
        S1 z3;
        z3.F1 = y3;
        z3.F2 = y3;
        x3 = z3;
        y3 = x3.F2;
    }

    void Test6(out S1 x6, CL1 y6)
    {
        S1 z6;
        z6.F1 = y6;
        z6.F2 = y6;
        x6 = z6;
        y6 = x6.F2;
    }
}

class CL1
{
}

struct S1
{
    public CL1 F1;
    public CL1? F2;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void RefOutParameters_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void M1(ref CL0<string> x) {}

    void Test1(CL0<string?> x1)
    {
        M1(ref x1);
    }

    void M2(out CL0<string?> x) { throw new System.NotImplementedException(); }

    void Test2(CL0<string> x2)
    {
        M2(out x2);
    }

    void M3(CL0<string> x) {}

    void Test3(CL0<string?> x3)
    {
        M3(x3);
    }
}

class CL0<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,16): warning CS8620: Nullability of reference types in argument of type 'CL0<string?>' doesn't match target type 'CL0<string>' for parameter 'x' in 'void C.M1(ref CL0<string> x)'.
                //         M1(ref x1);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x1").WithArguments("CL0<string?>", "CL0<string>", "x", "void C.M1(ref CL0<string> x)").WithLocation(12, 16),
                // (19,16): warning CS8620: Nullability of reference types in argument of type 'CL0<string>' doesn't match target type 'CL0<string?>' for parameter 'x' in 'void C.M2(out CL0<string?> x)'.
                //         M2(out x2);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x2").WithArguments("CL0<string>", "CL0<string?>", "x", "void C.M2(out CL0<string?> x)").WithLocation(19, 16),
                // (26,12): warning CS8620: Nullability of reference types in argument of type 'CL0<string?>' doesn't match target type 'CL0<string>' for parameter 'x' in 'void C.M3(CL0<string> x)'.
                //         M3(x3);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x3").WithArguments("CL0<string?>", "CL0<string>", "x", "void C.M3(CL0<string> x)").WithLocation(26, 12)
                );
        }

        [Fact]
        public void RefOutParameters_05()
        {
            var source =
@"class C
{
    static void F(object? x, object? y, object? z)
    {
        G(out x, ref y, in z);
        x.ToString();
        y.ToString();
        z.ToString();
    }
    static void G(out object x, ref object y, in object z)
    {
        x = new object();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,22): warning CS8604: Possible null reference argument for parameter 'y' in 'void C.G(out object x, ref object y, in object z)'.
                //         G(out x, ref y, in z);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("y", "void C.G(out object x, ref object y, in object z)").WithLocation(5, 22),
                // (5,28): warning CS8604: Possible null reference argument for parameter 'z' in 'void C.G(out object x, ref object y, in object z)'.
                //         G(out x, ref y, in z);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "z").WithArguments("z", "void C.G(out object x, ref object y, in object z)").WithLocation(5, 28),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(8, 9));
        }

        [Fact]
        public void RefOutParameters_06()
        {
            var source =
@"class C
{
    static void F(object x, object y, object z)
    {
        G(out x, ref y, in z);
        x.ToString();
        y.ToString();
        z.ToString();
    }
    static void G(out object? x, ref object? y, in object? z)
    {
        x = new object();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         G(out x, ref y, in z);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(5, 15),
                // (5,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         G(out x, ref y, in z);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(5, 22),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(7, 9));
        }

        [Fact]
        public void TargetingUnannotatedAPIs_01()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public object F1;

    public object P1 { get; set;}

    public object this[object x]
    {
        get { return null; }
        set { }
    }

    public S1 M1() { return new S1(); }
}

public struct S1
{
    public CL0 F1;
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    bool Test1(string? x1, string y1)
    {
        return string.Equals(x1, y1);
    }

    object Test2(ref object? x2, object? y2)
    {
        System.Threading.Interlocked.Exchange(ref x2, y2);
        return x2 ?? new object(); 
    }    

    object Test3(ref object? x3, object? y3)
    {
        return System.Threading.Interlocked.Exchange(ref x3, y3) ?? new object(); 
    }    

    object Test4(System.Delegate x4)
    {
        return x4.Target ?? new object(); 
    }    

    object Test5(CL0 x5)
    {
        return x5.F1 ?? new object(); 
    }    

    void Test6(CL0 x6, object? y6)
    {
        x6.F1 = y6;
    }    

    void Test7(CL0 x7, object? y7)
    {
        x7.P1 = y7;
    }    

    void Test8(CL0 x8, object? y8, object? z8)
    {
        x8[y8] = z8;
    }    

    object Test9(CL0 x9)
    {
        return x9[1] ?? new object(); 
    }    

    object Test10(CL0 x10)
    {
        return x10.M1().F1 ?? new object(); 
    }    

    object Test11(CL0 x11, CL0? z11)
    {
        S1 y11 = x11.M1();
        y11.F1 = z11;
        return y11.F1; 
    }    

    object Test12(CL0 x12)
    {
        S1 y12 = x12.M1();
        y12.F1 = x12;
        return y12.F1 ?? new object(); 
    }    

    void Test13(CL0 x13, object? y13)
    {
        y13 = x13.F1;
        object z13 = y13;
        z13 = y13 ?? new object();
    }    

    void Test14(CL0 x14)
    {
        object? y14 = x14.F1;
        object z14 = y14;
        z14 = y14 ?? new object();
    }    

    void Test15(CL0 x15)
    {
        S2 y15;
        y15.F2 = x15.F1;
        object z15 = y15.F2;
        z15 = y15.F2 ?? new object();
    }    

    struct Test16
    {
        object? y16 {get;}

        public Test16(CL0 x16)
        {
            y16 = x16.F1;
            object z16 = y16;
            z16 = y16 ?? new object();
        }    
    }

    void Test17(CL0 x17)
    {
        var y17 = new { F2 = x17.F1 };
        object z17 = y17.F2;
        z17 = y17.F2 ?? new object();
    }    
}

public struct S2
{
    public object? F2;
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                // (63,16): warning CS8603: Possible null reference return.
                //         return y11.F1;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y11.F1").WithLocation(63, 16),
                // (70,16): hidden CS8607: Expression is probably never null.
                //         return y12.F1 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y12.F1").WithLocation(70, 16));
        }

        [Fact]
        public void TargetingUnannotatedAPIs_02()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public static object M1() { return new object(); }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    public static object? M2() { return null; }
    public static object M3() { return new object(); }

    void Test1()
    {
        object? x1 = CL0.M1() ?? M2();
        object y1 = x1;
        object z1 = x1 ?? new object();
    }

    void Test2()
    {
        object? x2 = CL0.M1() ?? M3();
        object z2 = x2 ?? new object();
    }

    void Test3()
    {
        object? x3 = M3() ?? M2();
        object z3 = x3 ?? new object();
    }

    void Test4()
    {
        object? x4 = CL0.M1() ?? CL0.M1();
        object y4 = x4;
        object z4 = x4 ?? new object();
    }

    void Test5()
    {
        object x5 = M2() ?? M2();
    }

    void Test6()
    {
        object? x6 = M3() ?? M3();
        object z6 = x6 ?? new object();
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                // (14,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y1 = x1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(14, 21),
                // (21,21): hidden CS8607: Expression is probably never null.
                //         object z2 = x2 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(21, 21),
                // (26,22): hidden CS8607: Expression is probably never null.
                //         object? x3 = M3() ?? M2();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M3()").WithLocation(26, 22),
                // (27,21): hidden CS8607: Expression is probably never null.
                //         object z3 = x3 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x3").WithLocation(27, 21),
                // (39,21): warning CS8601: Possible null reference assignment.
                //         object x5 = M2() ?? M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M2() ?? M2()").WithLocation(39, 21),
                // (44,22): hidden CS8607: Expression is probably never null.
                //         object? x6 = M3() ?? M3();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M3()").WithLocation(44, 22),
                // (45,21): hidden CS8607: Expression is probably never null.
                //         object z6 = x6 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x6").WithLocation(45, 21)
                );
        }

        [Fact]
        public void TargetingUnannotatedAPIs_03()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public static object M1() { return new object(); }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    public static object? M2() { return null; }
    public static object M3() { return new object(); }

    void Test1()
    {
        object? x1 = M2() ?? CL0.M1();
        object y1 = x1;
        object z1 = x1 ?? new object();
    }

    void Test2()
    {
        object? x2 = M3() ?? CL0.M1();
        object z2 = x2 ?? new object();
    }

    void Test3()
    {
        object? x3 = M2() ?? M3();
        object z3 = x3 ?? new object();
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                 // (20,22): hidden CS8607: Expression is probably never null.
                 //         object? x2 = M3() ?? CL0.M1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M3()").WithLocation(20, 22),
                 // (21,21): hidden CS8607: Expression is probably never null.
                 //         object z2 = x2 ?? new object();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(21, 21),
                 // (27,21): hidden CS8607: Expression is probably never null.
                 //         object z3 = x3 ?? new object();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x3").WithLocation(27, 21)
                );
        }

        [Fact]
        public void TargetingUnannotatedAPIs_04()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public static object M1() { return new object(); }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    public static object? M2() { return null; }
    public static object M3() { return new object(); }
    public static bool M4() {return false;}

    void Test1()
    {
        object x1 = M4() ? CL0.M1() : M2();
    }

    void Test2()
    {
        object? x2 = M4() ? CL0.M1() : M3();
        object y2 = x2;
        object z2 = x2 ?? new object();
    }

    void Test3()
    {
        object x3 =  M4() ? M3() : M2();
    }

    void Test4()
    {
        object? x4 =  M4() ? CL0.M1() : CL0.M1();
        object y4 = x4;
        object z4 = x4 ?? new object();
    }

    void Test5()
    {
        object x5 =  M4() ? M2() : M2();
    }

    void Test6()
    {
        object? x6 =  M4() ? M3() : M3();
        object z6 = x6 ?? new object();
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                // (14,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object x1 = M4() ? CL0.M1() : M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M4() ? CL0.M1() : M2()").WithLocation(14, 21),
                // (26,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object x3 =  M4() ? M3() : M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M4() ? M3() : M2()").WithLocation(26, 22),
                // (38,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object x5 =  M4() ? M2() : M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M4() ? M2() : M2()").WithLocation(38, 22),
                // (44,21): hidden CS8607: Expression is probably never null.
                //         object z6 = x6 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x6").WithLocation(44, 21)
                );
        }

        [Fact]
        public void TargetingUnannotatedAPIs_05()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public static object M1() { return new object(); }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    public static object? M2() { return null; }
    public static object M3() { return new object(); }
    public static bool M4() {return false;}

    void Test1()
    {
        object x1 = M4() ? M2() : CL0.M1();
    }

    void Test2()
    {
        object? x2 = M4() ? M3() : CL0.M1();
        object y2 = x2;
        object z2 = x2 ?? new object();
    }

    void Test3()
    {
        object x3 =  M4() ? M2() : M3();
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                 // (14,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         object x1 = M4() ? M2() : CL0.M1();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M4() ? M2() : CL0.M1()").WithLocation(14, 21),
                 // (26,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         object x3 =  M4() ? M2() : M3();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M4() ? M2() : M3()").WithLocation(26, 22)
                );
        }

        [Fact]
        public void TargetingUnannotatedAPIs_06()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public static object M1() { return new object(); }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    public static object? M2() { return null; }
    public static object M3() { return new object(); }
    public static bool M4() {return false;}

    void Test1()
    {
        object? x1;
        if (M4()) x1 = CL0.M1(); else x1 = M2();
        object y1 = x1;
    }

    void Test2()
    {
        object? x2;
        if (M4()) x2 = CL0.M1(); else x2 = M3();
        object y2 = x2;
        object z2 = x2 ?? new object();
    }

    void Test3()
    {
        object? x3;
        if (M4()) x3 = M3(); else x3 = M2();
        object y3 = x3;
    }

    void Test4()
    {
        object? x4;
        if (M4()) x4 = CL0.M1(); else x4 = CL0.M1();
        object y4 = x4;
        object z4 = x4 ?? new object();
    }

    void Test5()
    {
        object? x5;
        if (M4()) x5 = M2(); else x5 = M2();
        object y5 = x5;
    }

    void Test6()
    {
        object? x6;
        if (M4()) x6 = M3(); else x6 = M3();
        object z6 = x6 ?? new object();
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                // (16,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y1 = x1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(16, 21),
                // (31,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(31, 21),
                // (46,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y5 = x5;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x5").WithLocation(46, 21),
                // (53,21): hidden CS8607: Expression is probably never null.
                //         object z6 = x6 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x6").WithLocation(53, 21)
                );
        }

        [Fact]
        public void TargetingUnannotatedAPIs_07()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public class CL0 
{
    public static object M1() { return new object(); }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main()
    {
    }

    public static object? M2() { return null; }
    public static object M3() { return new object(); }
    public static bool M4() {return false;}

    void Test1()
    {
        object? x1;
        if (M4()) x1 = M2(); else x1 = CL0.M1();
        object y1 = x1;
    }

    void Test2()
    {
        object? x2;
        if (M4()) x2 = M3(); else x2 = CL0.M1();
        object y2 = x2;
        object z2 = x2 ?? new object();
    }

    void Test3()
    {
        object? x3;
        if (M4()) x3 = M2(); else x3 = M3();
        object y3 = x3;
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics(
                // (16,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y1 = x1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(16, 21),
                // (31,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(31, 21)
                );
        }

        [Fact]
        public void TargetingUnannotatedAPIs_08()
        {
            CSharpCompilation c0 = CreateCompilation(@"
public abstract class A1
{
    public abstract event System.Action E1;
    public abstract string P2 { get; set; }
    public abstract string M3(string x);
    public abstract event System.Action E4;
    public abstract string this[string x] { get; set; }
}

public interface IA2
{
    event System.Action E5;
    string P6 { get; set; }
    string M7(string x);
    event System.Action E8;
    string this[string x] { get; set; }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class B1 : A1
{
    static void Main()
    {
    }

    public override string? P2 { get; set; }
    public override event System.Action? E1;
    public override string? M3(string? x)
    {
        var dummy = E1;
        throw new System.NotImplementedException();
    }
    public override event System.Action? E4
    {
        add { }
        remove { }
    }

    public override string? this[string? x]
    {
        get
        {
            throw new System.NotImplementedException();
        }

        set
        {
            throw new System.NotImplementedException();
        }
    }
}

class B2 : IA2
{
    public string? P6 { get; set; }
    public event System.Action? E5;
    public event System.Action? E8
    {
        add { }
        remove { }
    }

    public string? M7(string? x)
    {
        var dummy = E5;
        throw new System.NotImplementedException();
    }

    public string? this[string? x]
    {
        get
        {
            throw new System.NotImplementedException();
        }

        set
        {
            throw new System.NotImplementedException();
        }
    }
}

class B3 : IA2
{
    string? IA2.P6 { get; set; }

    event System.Action? IA2.E5
    {
        add { }
        remove { }
    }

    event System.Action? IA2.E8
    {
        add { }
        remove { }
    }

    string? IA2.M7(string? x)
    {
        throw new System.NotImplementedException();
    }
    
    string? IA2.this[string? x]
    {
        get
        {
            throw new System.NotImplementedException();
        }

        set
        {
            throw new System.NotImplementedException();
        }
    }

}
" }, options: WithNonNullTypesTrue(), references: new[] { c0.EmitToImageReference() });

            c.VerifyDiagnostics();
        }

        [Fact]
        public void ReturningValues_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1 Test1(CL1? x1)
    {
        return x1;
    }

    CL1? Test2(CL1? x2)
    {
        return x2;
    }

    CL1? Test3(CL1 x3)
    {
        return x3;
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,16): warning CS8603: Possible null reference return.
                 //         return x1;
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "x1").WithLocation(10, 16)
                );
        }

        [Fact]
        public void ReturningValues_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1<string?> Test1(CL1<string> x1)
    {
        return x1;
    }

    CL1<string> Test2(CL1<string?> x2)
    {
        return x2;
    }
}

class CL1<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,16): warning CS8619: Nullability of reference types in value of type 'CL1<string>' doesn't match target type 'CL1<string?>'.
                //         return x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("CL1<string>", "CL1<string?>").WithLocation(10, 16),
                // (15,16): warning CS8619: Nullability of reference types in value of type 'CL1<string?>' doesn't match target type 'CL1<string>'.
                //         return x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("CL1<string?>", "CL1<string>").WithLocation(15, 16)
                );
        }

        [Fact]
        public void ReturningValues_BadValue()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    string M()
    {
        return bad;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,16): error CS0103: The name 'bad' does not exist in the current context
                //         return bad;
                Diagnostic(ErrorCode.ERR_NameNotInContext, "bad").WithArguments("bad").WithLocation(6, 16)
                );
        }

        [Fact]
        public void IdentityConversion_Return_01()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static I<object?> F(I<object> x) => x;
    static IIn<object?> F(IIn<object> x) => x;
    static IOut<object?> F(IOut<object> x) => x;
    static I<object> G(I<object?> x) => x;
    static IIn<object> G(IIn<object?> x) => x;
    static IOut<object> G(IOut<object?> x) => x;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,41): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //     static I<object?> F(I<object> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("I<object>", "I<object?>").WithLocation(6, 41),
                // (7,45): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //     static IIn<object?> F(IIn<object> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IIn<object>", "IIn<object?>").WithLocation(7, 45),
                // (9,41): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //     static I<object> G(I<object?> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("I<object?>", "I<object>").WithLocation(9, 41),
                // (11,47): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //     static IOut<object> G(IOut<object?> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IOut<object?>", "IOut<object>").WithLocation(11, 47));
        }

        [Fact]
        public void IdentityConversion_Return_02()
        {
            var source =
@"#pragma warning disable 1998
using System.Threading.Tasks;
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static async Task<I<object?>> F(I<object> x) => x;
    static async Task<IIn<object?>> F(IIn<object> x) => x;
    static async Task<IOut<object?>> F(IOut<object> x) => x;
    static async Task<I<object>> G(I<object?> x) => x;
    static async Task<IIn<object>> G(IIn<object?> x) => x;
    static async Task<IOut<object>> G(IOut<object?> x) => x;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,53): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //     static async Task<I<object?>> F(I<object> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("I<object>", "I<object?>").WithLocation(8, 53),
                // (9,57): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //     static async Task<IIn<object?>> F(IIn<object> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IIn<object>", "IIn<object?>").WithLocation(9, 57),
                // (11,53): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //     static async Task<I<object>> G(I<object?> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("I<object?>", "I<object>").WithLocation(11, 53),
                // (13,59): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //     static async Task<IOut<object>> G(IOut<object?> x) => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IOut<object?>", "IOut<object>").WithLocation(13, 59));
        }

        [Fact]
        public void MakeMethodKeyForWhereMethod()
        {
            // this test verifies that a bad method symbol doesn't crash when generating a key for external annotations
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    public void SimpleWhere()
    {
        int[] numbers = { 1, 2, 3 };
        var lowNums = from n in numbers
                      where n < 5
                      select n;
    }
}" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,33): error CS1935: Could not find an implementation of the query pattern for source type 'int[]'.  'Where' not found.  Are you missing a reference to 'System.Core.dll' or a using directive for 'System.Linq'?
                //         var lowNums = from n in numbers
                Diagnostic(ErrorCode.ERR_QueryNoProviderStandard, "numbers").WithArguments("int[]", "Where").WithLocation(7, 33)
                );
        }

        [Fact]
        [WorkItem(29855, "https://github.com/dotnet/roslyn/issues/29855")]
        public void NotNullWhenFalse_EqualsTrue()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (MyIsNullOrEmpty(s) == true)
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }

        s.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29855: there should only be one diagnostic
            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // ok
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );
        }

        [Fact]
        public void NotNullWhenFalse_Nested()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (MyIsNullOrEmpty(s?.ToString()))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString();
        }
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );
        }

        [Fact]
        [WorkItem(29916, "https://github.com/dotnet/roslyn/issues/29916")]
        public void NotNullWhenFalse_EqualsTrue_InErrorInvocation()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (Missing(MyIsNullOrEmpty(s)))
        {
            s.ToString(); // 1
        }
        else
        {
            s.ToString(); // 2
        }

        s.ToString();
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,13): error CS0103: The name 'Missing' does not exist in the current context
                //         if (Missing(MyIsNullOrEmpty(s)))
                Diagnostic(ErrorCode.ERR_NameNotInContext, "Missing").WithArguments("Missing").WithLocation(7, 13),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );
        }

        [Fact]
        [WorkItem(29855, "https://github.com/dotnet/roslyn/issues/29855")]
        public void NotNullWhenFalse_EqualsFalse()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (false == MyIsNullOrEmpty(s))
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // warn
        }

        s.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29855: there should only be one diagnostic
            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // ok
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );
        }

        [Fact]
        [WorkItem(29855, "https://github.com/dotnet/roslyn/issues/29855")]
        public void NotNullWhenFalse_NotEqualsFalse()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (false != MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }

        s.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29855: there should only be one diagnostic
            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // ok
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );
        }

        [Fact]
        public void NotNullWhenFalse_RequiresBoolReturn()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public static object MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotations(c, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_RequiresBoolReturn_OnGenericMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s)
    {
        if (MyIsNullOrEmpty(s, true))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
    public static T MyIsNullOrEmpty<T>([NotNullWhenFalse] string? s, T t) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );
        }

        [Fact]
        public void MethodWithOutNullableParameter_AfterNotNullWhenTrue()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (M(s, out string? s2))
        {
            s.ToString(); // ok
            s2.ToString(); // warn
        }
        else
        {
            s.ToString(); // warn 2
            s2.ToString(); // warn 3
        }

        s.ToString(); // ok
        s2.ToString(); // ok
    }
    public static bool M([NotNullWhenTrue] string? s, out string? s2) => throw null;
}
", NotNullWhenTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(10, 13),
                // (14,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(14, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // warn 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(15, 13)
                );
        }

        [Fact]
        public void MethodWithOutNullableParameter_AfterEnsuresNotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (M(s, out string? s2))
        {
            s.ToString(); // ok
            s2.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
            s2.ToString(); // warn 2
        }

        s.ToString(); // ok
        s2.ToString(); // ok
    }
    public static bool M([EnsuresNotNull] string? s, out string? s2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(10, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(15, 13)
                );
        }

        [Fact]
        public void MethodWithOutNullableParameter_AfterEnsuresNotNull_InErrorInvocation()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (Missing(M(s, out string? s2)))
        {
            s.ToString();
            s2.ToString(); // 1
        }
        else
        {
            s.ToString();
            s2.ToString(); // 2
        }

        s.ToString();
        s2.ToString();
    }
    public static bool M([EnsuresNotNull] string? s, out string? s2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,13): error CS0103: The name 'Missing' does not exist in the current context
                //         if (Missing(M(s, out string? s2)))
                Diagnostic(ErrorCode.ERR_NameNotInContext, "Missing").WithArguments("Missing").WithLocation(7, 13),
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(10, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(15, 13)
                );
        }

        [Fact]
        public void MethodWithOutNonNullableParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        M(out string s);
        s.ToString(); // ok
    }
    public static void M(out string value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithOutNonNullableParameter_WithNullableOutArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        M(out string? s);
        s.ToString(); // ok
    }
    public static void M(out string value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithRefNonNullableParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        string s = ""hello"";
        M(ref s);
        s.ToString(); // ok
    }
    public static void M(ref string value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithRefNonNullableParameter_WithNullableRefArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? s)
    {
        M(ref s); // warn
        s.ToString();
    }
    public static void M(ref string value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,15): warning CS8604: Possible null reference argument for parameter 'value' in 'void C.M(ref string value)'.
                //         M(ref s); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "s").WithArguments("value", "void C.M(ref string value)").WithLocation(6, 15)
                );
        }

        [Fact]
        public void MethodWithRefNonNullableParameter_WithNonNullRefArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        string? s = ""hello"";
        M(ref s);
        s.ToString();
    }
    public static void M(ref string value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithRefNullableParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        string? s = ""hello"";
        M(ref s); // warn 1
        s.ToString(); // warn 2
    }
    public static void M(ref string? value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         M(ref s); // warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "s").WithLocation(7, 15),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void MethodWithRefNullableParameter_WithNonNullableRefArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s)
    {
        M(ref s); // warn 1
        s.ToString(); // warn 2
    }
    public static void M(ref string? value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         M(ref s); // warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "s").WithLocation(6, 15),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithRefNullableParameter_WithNonNullableLocal()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        string s = ""hello"";
        M(ref s); // warn 1
        s.ToString(); // warn 2
    }
    public static void M(ref string? value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         M(ref s); // warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "s").WithLocation(7, 15),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void MethodWithOutParameter_WithNullableOut()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        if (TryGetValue(key, out var s))
        {
            s/*T:string?*/.ToString(); // warn
        }
        else
        {
            s/*T:string?*/.ToString(); // warn 2
        }

        s.ToString(); // ok
    }
    public static bool TryGetValue(string key, out string? value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(12, 13)
                );
        }

        /// <summary>
        /// Check the inferred type of var from the semantic model, which currently means from initial binding.
        /// </summary>
        private static void VerifyOutVar(CSharpCompilation compilation, string expectedType)
        {
            if (SkipVerify(expectedType))
            {
                return;
            }
            var tree = compilation.SyntaxTrees.First();
            var model = compilation.GetSemanticModel(tree);
            var outVar = tree.GetRoot().DescendantNodes().OfType<DeclarationExpressionSyntax>().Single();
            var symbol = (LocalSymbol)model.GetSymbolInfo(outVar).Symbol;
            Assert.Equal(expectedType, symbol.Type.ToDisplayString(TypeSymbolWithAnnotations.TestDisplayFormat));
            Assert.Null(model.GetDeclaredSymbol(outVar));
        }

        /// <summary>
        /// Check the inferred type of var from the semantic model, which currently means from initial binding.
        /// </summary>
        private static void VerifyVarLocal(CSharpCompilation compilation, string expectedType)
        {
            if (SkipVerify(expectedType))
            {
                return;
            }
            var tree = compilation.SyntaxTrees.First();
            var model = compilation.GetSemanticModel(tree);
            var varDecl = tree.GetRoot().DescendantNodes().OfType<LocalDeclarationStatementSyntax>().Where(d => d.Declaration.Type.IsVar).Single();
            var variable = varDecl.Declaration.Variables.Single();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(variable);
            Assert.Equal(expectedType, symbol.Type.ToDisplayString(TypeSymbolWithAnnotations.TestDisplayFormat));
            Assert.Null(model.GetSymbolInfo(variable).Symbol);
        }

        // https://github.com/dotnet/roslyn/issues/30150: VerifyOutVar and VerifyVarLocal are currently
        // checking the type and nullability from initial binding, but there are many cases where initial binding
        // sets nullability to unknown - in particular, for method type inference which is used in many
        // of the existing callers of these methods. Re-enable these methods when we're checking the
        // nullability from NullableWalker instead of initial binding.
        private static bool SkipVerify(string expectedType)
        {
            return expectedType.Contains('?') || expectedType.Contains('!');
        }

        [Fact]
        public void MethodWithGenericOutParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        Copy(key, out var s);
        s/*T:string?*/.ToString(); // warn
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string!"); // https://github.com/dotnet/roslyn/issues/29856: expecting string?
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithUnnecessarySuppression()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        Copy(key!, out var s);
        s/*T:string!*/.ToString();
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void VarLocal_FromGenericMethod_WithUnnecessarySuppression()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        var s = Copy(key!);
        s/*T:string!*/.ToString();
    }
    public static T Copy<T>(T key) => throw null;
}
" }, options: WithNonNullTypesTrue());

            // Need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/32661

            VerifyVarLocal(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void VarLocal_FromGenericMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        var s = Copy(key);
        s/*T:string?*/.ToString(); // warn
    }
    public static T Copy<T>(T key) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string!"); // https://github.com/dotnet/roslyn/issues/29856: expecting string?
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithNonNullArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        key = ""hello"";
        CopyOrDefault(key, out var s);
        s/*T:string!*/.ToString(); // ok
    }
    public static void CopyOrDefault<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithGenericNullableOutParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        CopyOrDefault(key, out var s);
        s/*T:string?*/.ToString(); // warn
    }
    public static void CopyOrDefault<T>(T key, out T? value) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericNullableOutParameter_WithNullableArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        CopyOrDefault(key, out var s);
        s/*T:string?*/.ToString(); // warn
    }
    public static void CopyOrDefault<T>(T key, out T? value) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (6,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.CopyOrDefault<T>(T, out T?)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         CopyOrDefault(key, out var s);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "CopyOrDefault").WithArguments("C.CopyOrDefault<T>(T, out T?)", "T", "string?").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericNullableOutParameter_WithNonNullArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        key = ""hello"";
        CopyOrDefault(key, out var s);
        s/*T:string?*/.ToString(); // warn
    }
    public static void CopyOrDefault<T>(T key, out T? value) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void MethodWithGenericNullableArrayOutParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        CopyOrDefault(key, out var s);
        s/*T:string?[]!*/[0].ToString(); // warn
    }
    public static void CopyOrDefault<T>(T key, out T?[] value) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?[]!");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?[]!*/[0].ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s/*T:string?[]!*/[0]").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericNullableArrayOutParameter_WithNullableArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        CopyOrDefault(key, out var s);
        s/*T:string?[]!*/[0].ToString(); // warn
    }
    public static void CopyOrDefault<T>(T key, out T?[] value) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?[]!");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (6,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.CopyOrDefault<T>(T, out T?[])'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         CopyOrDefault(key, out var s);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "CopyOrDefault").WithArguments("C.CopyOrDefault<T>(T, out T?[])", "T", "string?").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?[]!*/[0].ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s/*T:string?[]!*/[0]").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericArrayOutParameter_WithNonNullableArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        CopyOrDefault(key, out var s);
        s/*T:string![]!*/[0].ToString(); // ok
    }
    public static void CopyOrDefault<T>(T key, out T[] value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string![]!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithGenericArrayOutParameter_WithNonNullArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        key = ""hello"";
        CopyOrDefault(key, out var s);
        s/*T:string![]!*/[0].ToString(); // ok
    }
    public static void CopyOrDefault<T>(T key, out T[] value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string![]!"); // https://github.com/dotnet/roslyn/issues/29856: expecting string?[]!
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithEnsuresNotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? key)
    {
        Copy(key, out var s); // ok
        s/*T:string!*/.ToString(); // ok
    }
    public static void Copy<T>(T key, [EnsuresNotNull] out T value) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string!"); // https://github.com/dotnet/roslyn/issues/29856: T is inferred to string! instead of string?, so the `var` gets `string!`
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void MethodWithGenericNullableOutParameter_WithEnsuresNotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? key)
    {
        Copy(key, out var s); // ok
        s/*T:string!*/.ToString(); // ok
    }
    public static void Copy<T>(T key, [EnsuresNotNull] out T? value) where T : class => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.Copy<T>(T, out T?)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         Copy(key, out var s); // ok
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "Copy").WithArguments("C.Copy<T>(T, out T?)", "T", "string?").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithNullLiteralArgument_WithNonNullableString()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main()
    {
        Copy(null, out string s); // warn
        s/*T:string!*/.ToString(); // ok
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (6,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         Copy(null, out string s); // warn
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 14)
                );
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithNonNullableArgument_WithNonNullableString()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        Copy(key, out string s);
        s/*T:string!*/.ToString();
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29857, "https://github.com/dotnet/roslyn/issues/29857")]
        public void MethodWithGenericOutParameter_WithNullableArgument_WithNonNullableString()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        Copy(key, out string s);
        s/*T:string?*/.ToString();
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (6,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         Copy(key, out string s);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "string s").WithLocation(6, 23),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithNonNullableArgument_WithNullableString()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        Copy(key, out string? s);
        s/*T:string?*/.ToString();
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void MethodWithGenericOutParameter_WithNullableArgument_WithNullableString()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        Copy(key, out string? s);
        s/*T:string?*/.ToString(); // warn
    }
    public static void Copy<T>(T key, out T value) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyOutVar(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void VarLocalFromGenericMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string key)
    {
        var s = Copy(key);
        s/*T:string!*/.ToString(); // ok
    }
    public T Copy<T>(T key) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void VarLocalFromGenericMethod_WithNullableArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        var s = Copy(key);
        s/*T:string?*/.ToString(); // warn
    }
    public T Copy<T>(T key) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string!"); // https://github.com/dotnet/roslyn/issues/29856: expecting string?
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void VarLocalFromGenericMethod_WithNonNullArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        key = ""hello"";
        var s = Copy(key);
        s/*T:string!*/.ToString(); // ok
    }
    public T Copy<T>(T key) => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void VarLocalFromGenericMethod_WithNullableReturn()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        var s = Copy(key);
        s/*T:string?*/.ToString(); // warn
    }
    public T? Copy<T>(T key) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (6,17): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.Copy<T>(T)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         var s = Copy(key);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "Copy").WithArguments("C.Copy<T>(T)", "T", "string?").WithLocation(6, 17),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void VarLocalFromGenericMethod_WithNullableReturn_WithNonNullArgument()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? key)
    {
        key = ""hello"";
        var s = Copy(key);
        s/*T:string?*/.ToString(); // warn
    }
    public T? Copy<T>(T key) where T : class => throw null;
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string?");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s/*T:string?*/.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        [WorkItem(29858, "https://github.com/dotnet/roslyn/issues/29858")]
        public void GenericMethod_WithEnsuresNotNullOnReturnType()
        {
            CSharpCompilation c = CreateCompilation(@"
using System.Runtime.CompilerServices;
public class C
{
    [EnsuresNotNull]
    public static T Copy<T>(T key) => throw null;
}
" + EnsuresNotNullAttributeDefinition);

            c.VerifyDiagnostics(
                // (5,6): error CS0592: Attribute 'EnsuresNotNull' is not valid on this declaration type. It is only valid on 'parameter' declarations.
                //     [EnsuresNotNull]
                Diagnostic(ErrorCode.ERR_AttributeOnBadSymbolType, "EnsuresNotNull").WithArguments("EnsuresNotNull", "parameter").WithLocation(5, 6)
                );
            // https://github.com/dotnet/roslyn/issues/29858: Need to confirm if this would be useful
        }

        [Fact]
        [WorkItem(29862, "https://github.com/dotnet/roslyn/issues/29862")]
        public void SuppressedNullGivesNonNullResult()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s)
    {
        s = null!;
        var s2 = s;
        s2 /*T:string!*/ .ToString(); // ok
        s2 = null; // warn
    }
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (9,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s2 = null; // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(9, 14)
                );
        }

        [Fact]
        [WorkItem(29862, "https://github.com/dotnet/roslyn/issues/29862")]
        public void SuppressedDefaultGivesNonNullResult()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s)
    {
        s = default!; // default! returns a non-null result
        var s2 = s;
        s2/*T:string!*/.ToString(); // ok
    }
}
" }, options: WithNonNullTypesTrue());

            VerifyVarLocal(c, "string!");
            c.VerifyTypes();
            c.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressedObliviousValueGivesNonNullResult()
        {
            var libComp = CreateCompilation(@"
public static class Static
{
    public static string Oblivious = null;
}
", parseOptions: TestOptions.Regular7);

            var comp = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s, string? ns)
    {
        s = Static.Oblivious!;
        var s2 = s;
        s2/*T:string!*/.ToString(); // ok
        ns = Static.Oblivious!;
        ns.ToString(); // ok
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { libComp.EmitToImageReference() });

            VerifyVarLocal(comp, "string!");
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressedValueGivesNonNullResult()
        {
            var comp = CreateCompilation(new[] { @"
public class C
{
    public void Main(string? ns, bool b)
    {
        var x1 = F(ns!);
        x1 /*T:string!*/ .ToString();

        var listNS = List.Create(ns);
        listNS /*T:List<string?>!*/ .ToString();
        var x2 = F2(listNS);
        x2 /*T:string!*/ .ToString();
    }
    public T F<T>(T? x) where T : class => throw null;
    public T F2<T>(List<T?> x) where T : class => throw null;
}
public class List { public static List<T> Create<T>(T t) => throw null; }
public class List<T> { }
" }, options: WithNonNullTypesTrue());

            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void NestedNullabilityMismatchIgnoresSuppression()
        {
            var obliviousComp = CreateCompilation(@"
public static class Static
{
    public static string Oblivious = null;
}
", parseOptions: TestOptions.Regular7);

            var comp = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s, string? ns)
    {
        var o = Static.Oblivious;

        {
            var listS = List.Create(s);
            var listNS = List.Create(ns);
            listS /*T:List<string!>!*/ .ToString();
            listNS /*T:List<string?>!*/ .ToString();
            listS = listNS!; // 1
        }

        {
            var listS = List.Create(s);
            var listO = List.Create(o);
            listO /*T:List<string>!*/ .ToString();
            listS = listO; // ok
        }

        {
            var listNS = List.Create(ns);
            var listS = List.Create(s);
            listNS = listS!; // 2
        }

        {
            var listNS = List.Create(ns);
            var listO = List.Create(o);
            listNS = listO; // ok
        }

        {
            var listO = List.Create(o);
            var listNS = List.Create(ns);
            listO = listNS; // ok
        }

        {
            var listO = List.Create(o);
            var listS = List.Create(s);
            listO = listS; // ok
        }
    }
}
public class List { public static List<T> Create<T>(T t) => throw null; }
public class List<T> { }
" }, options: WithNonNullTypesTrue(), references: new[] { obliviousComp.EmitToImageReference() });

            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void AssignNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s)
    {
        s = null; // warn
        s.ToString(); // warn 2
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s = null; // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void AssignDefault()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
public class C
{
    public void Main(string s)
    {
        s = default; // warn
        s.ToString(); // warn 2
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s = default; // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NotNullWhenTrue_Simple()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string key)
    {
        if (TryGetValue(key, out string? s))
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // warn
        }

        s.ToString(); // ok
    }
    public static bool TryGetValue(string key, [NotNullWhenTrue] out string? value) => throw null;
}
", NotNullWhenTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.Main", None);
            VerifyAnnotationsAndMetadata(c, "C.TryGetValue", None, NotNullWhenTrue);
        }

        [Fact]
        public void NotNullWhenTrue_Nested()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (IsNotNull(s?.ToString()))
        {
            s.ToString();
        }
        else
        {
            s.ToString(); // warn
        }
    }
    public static bool IsNotNull([NotNullWhenTrue] string? value) => throw null;
}
", NotNullWhenTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );
        }

        [Fact]
        public void NotNullWhenTrue_WithNotNullWhenFalse_WithVoidReturn()
        {
            // When both NotNullWhenTrue and NotNullWhenFalse are applied, it's the same as EnsuresNotNull,
            // even if the method doesn't return bool.
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main()
    {
        M(out string? s);
        s.ToString(); // ok
    }
    public static void M([NotNullWhenTrue, NotNullWhenFalse] out string? value) => throw null;
}
", NotNullWhenTrueAttributeDefinition, NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotationsAndMetadata(c, "C.M", EnsuresNotNull);
        }

        [Fact]
        public void AssertsTrue_NotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        MyAssert(c != null);
        c.ToString();
    }

    void MyAssert([AssertsTrue] bool condition) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_NotNull_Nested()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        MyAssert(c?.ToString() != null);
        c.ToString();
    }

    void MyAssert([AssertsTrue] bool condition) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29916, "https://github.com/dotnet/roslyn/issues/29916")]
        public void AssertsTrue_NotNull_InErrorInvocation()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        Missing(MyAssert(c != null));
        c.ToString();
    }

    void MyAssert([AssertsTrue] bool condition) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,9): error CS0103: The name 'Missing' does not exist in the current context
                //         Missing(MyAssert(c != null));
                Diagnostic(ErrorCode.ERR_NameNotInContext, "Missing").WithArguments("Missing").WithLocation(7, 9)
                );
        }

        [Fact]
        public void AssertsTrue_NotNull_NullConditionalAccess()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    object? _o = null;
    void Main(C? c)
    {
        MyAssert(c?._o != null);
        c.ToString();
        c._o.ToString();
    }

    void MyAssert([AssertsTrue] bool condition) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_Null()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        MyAssert(c == null);
        c.ToString();
    }

    void MyAssert([AssertsTrue] bool condition) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(8, 9)
                );
        }

        [Fact]
        [WorkItem(29916, "https://github.com/dotnet/roslyn/issues/29916")]
        public void AssertsTrue_Null_InErrorInvocation()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        Missing(MyAssert(c == null));
        c.ToString();
    }

    void MyAssert([AssertsTrue] bool condition) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,9): error CS0103: The name 'Missing' does not exist in the current context
                //         Missing(MyAssert(c == null));
                Diagnostic(ErrorCode.ERR_NameNotInContext, "Missing").WithArguments("Missing").WithLocation(7, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(8, 9)
                );
        }

        [Fact]
        public void AssertsTrue_RefOutInParameters()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(bool b)
    {
        MyAssert(ref b, out bool b2, in b);
    }

    void MyAssert([AssertsTrue] ref bool condition, [AssertsFalse] out bool condition2, [AssertsTrue] in bool condition3) => throw null;
}
", AssertsTrueAttributeDefinition, AssertsFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_MethodWithReturnType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        if (MyAssert(c != null))
        {
            c.ToString();
        }
        else
        {
            c.ToString();
        }
    }

    bool MyAssert([AssertsTrue] bool condition) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_Debug_Assert1_NotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(C? c)
    {
        System.Diagnostics.Debug.Assert(c != null);
        c.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_NotNullAndNotEmpty()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? c)
    {
        Assert(c != null && c != """");
        c.ToString();
    }
    static void Assert([AssertsTrue] bool b) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_Debug_Assert1_NotNullAndNotEmpty()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(string? c)
    {
        System.Diagnostics.Debug.Assert(c != null && c != """");
        c.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_NotNullOrUnknown()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? c, bool b)
    {
        Assert(c != null || b);
        c.ToString();
    }
    static void Assert([AssertsTrue] bool b) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(8, 9)
                );
        }

        [Fact]
        public void AssertsTrue_Debug_Assert2_NotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(C? c)
    {
        System.Diagnostics.Debug.Assert(c != null, ""hello"");
        c.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_Debug_Assert3_NotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(C? c)
    {
        System.Diagnostics.Debug.Assert(c != null, ""hello"", ""world"");
        c.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_Debug_Assert4_NotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(C? c)
    {
        System.Diagnostics.Debug.Assert(c != null, ""hello"", ""world"", new object[] { });
        c.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsTrue_IsNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C c)
    {
        Assert(c == null, ""hello"");
        c.ToString();
    }
    static void Assert([AssertsTrue] bool b, string message) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,16): hidden CS8606: Result of the comparison is possibly always false.
                //         Assert(c == null, "hello");
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "c == null").WithLocation(7, 16)
                );
        }

        [Fact]
        public void AssertsTrue_NoDuplicateDiagnostics()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        Assert(Method(null), ""hello"");
        c.ToString();
    }
    bool Method(string x) => throw null;
    static void Assert([AssertsTrue] bool b, string message) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,23): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         Assert(Method(null), "hello");
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(7, 23),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(8, 9)
                );
        }

        [Fact]
        public void AssertsTrue_InTry()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        try
        {
            Assert(c != null, ""hello"");
        }
        catch { }

        c.ToString();
    }
    static void Assert([AssertsTrue] bool b, string message) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(13, 9)
                );
        }

        [Fact]
        public void AssertsTrue_WithNotNullWhenFalse()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s, string? s2)
    {
        Assert(!string.IsNullOrEmpty(s));
        s.ToString(); // ok

        Assert(string.IsNullOrEmpty(s2));
        s2.ToString(); // warn
    }
    static void Assert([AssertsTrue] bool b) => throw null;
}
", AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         s2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(11, 9)
                );
        }

        [Fact]
        public void AssertsFalse_Null()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        MyAssert(c == null);
        c.ToString();
    }

    void MyAssert([AssertsFalse] bool condition) => throw null;
}
", AssertsFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void AssertsFalse_NotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(C? c)
    {
        MyAssert(c != null);
        c.ToString();
    }

    void MyAssert([AssertsFalse] bool condition) => throw null;
}
", AssertsFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NotNullWhenFalse_Simple()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public void Main(string? s)
    {
        if (MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }

        s.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.Main", None);
            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_BoolReturn()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    public static object MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotations(c, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_OnTwoParameters()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s, string? s2)
    {
        if (MyIsNullOrEmpty(s, s2))
        {
            s.ToString(); // warn 1
            s2.ToString(); // warn 2
        }
        else
        {
            s.ToString(); // ok
            s2.ToString(); // ok
        }

        s.ToString(); // ok
        s2.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s, [NotNullWhenFalse] string? s2) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(10, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", NotNullWhenFalse, NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_WithNotNullWhenTrueOnSecondParameter()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s, string? s2)
    {
        if (MyIsNullOrEmpty(s, s2))
        {
            s.ToString(); // warn 1
            s2.ToString(); // ok
        }
        else
        {
            s.ToString(); // ok
            s2.ToString(); // warn 2
        }

        s.ToString(); // ok
        s2.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s, [NotNullWhenTrue] string? s2) => throw null;
}
", NotNullWhenFalseAttributeDefinition, NotNullWhenTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             s2.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(15, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", NotNullWhenFalse, NotNullWhenTrue);
        }

        [Fact]
        public void NotNullWhenFalse_OnIndexer()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s, int x)
    {
        if (this[s, x])
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }

        s.ToString(); // ok
    }
    public bool this[[NotNullWhenFalse] string? s, int x] => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );
        }

        [Fact]
        public void NotNullWhenFalse_SecondArgumentDereferences()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        if (Method(s, s.ToString())) // warn 1
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // ok
        }
    }
    static bool Method([NotNullWhenFalse] string? s, string s2) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,23): warning CS8602: Possible dereference of a null reference.
                //         if (Method(s, s.ToString())) // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 23)
                );
        }

        [Fact]
        public void NotNullWhenFalse_SecondArgumentAssigns()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        if (Method(s, s = null))
        {
            s.ToString(); // warn 1
        }
        else
        {
            s.ToString(); // warn 2
        }
    }
    static bool Method([NotNullWhenFalse] string? s, string? s2) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );
        }

        [Fact]
        public void NotNullWhenFalse_MissingAttribute()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        if (MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // warn 2
        }

        s.ToString(); // ok
    }
    static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (17,34): error CS0246: The type or namespace name 'NotNullWhenFalseAttribute' could not be found (are you missing a using directive or an assembly reference?)
                //     static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "NotNullWhenFalse").WithArguments("NotNullWhenFalseAttribute").WithLocation(17, 34),
                // (17,34): error CS0246: The type or namespace name 'NotNullWhenFalse' could not be found (are you missing a using directive or an assembly reference?)
                //     static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "NotNullWhenFalse").WithArguments("NotNullWhenFalse").WithLocation(17, 34),
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(12, 13)
                );

            VerifyAnnotations(c, "C.MyIsNullOrEmpty", None);
        }

        private static void VerifyAnnotations(Compilation compilation, string memberName, params FlowAnalysisAnnotations[] expected)
        {
            var method = compilation.GetMember<MethodSymbol>(memberName);
            Assert.True((object)method != null, $"Could not find method '{memberName}'");
            var actual = method.Parameters.Select(p => p.FlowAnalysisAnnotations);
            Assert.Equal(expected, actual);
        }

        private void VerifyAnnotationsAndMetadata(Compilation compilation, string memberName, params FlowAnalysisAnnotations[] expected)
        {
            VerifyAnnotations(compilation, memberName, expected);

            // Also verify from metadata
            var compilation2 = CreateCompilation("", references: new[] { compilation.EmitToImageReference() });
            VerifyAnnotations(compilation2, memberName, expected);
        }

        [Fact]
        public void NotNullWhenFalse_BadAttribute()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn 1
        }
        else
        {
            s.ToString(); // warn 2
        }
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse(true)] string? s) => throw null;
}
namespace System.Runtime.CompilerServices
{
    [AttributeUsage(AttributeTargets.Parameter,
                   AllowMultiple = false)]
    public class NotNullWhenFalseAttribute : Attribute
    {
        public NotNullWhenFalseAttribute(bool bad) { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", None);
        }

        [Fact]
        public void NotNullWhenFalse_InvertIf()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (!MyIsNullOrEmpty(s))
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // warn
        }
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_WithNullLiteral()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        _ = MyIsNullOrEmpty(null);
    }
    static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void NotNullWhenFalse_InstanceMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (this.MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
    public bool MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_ExtensionMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (this.MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
}
public static class Extension
{
    public static bool MyIsNullOrEmpty(this C c, [NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );

            VerifyAnnotationsAndMetadata(c, "Extension.MyIsNullOrEmpty", None, NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_String_IsNullOrEmpty()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        if (string.IsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13)
                );

            VerifyAnnotationsAndMetadata(c, "System.String.IsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_String_IsNullOrEmpty_WithoutCorlib()
        {
            CSharpCompilation c = CreateEmptyCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        if (string.IsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
}
namespace System
{
    public class Object
    {
        public virtual string ToString() => throw null;
    }
    public class String
    {
        public static bool IsNullOrEmpty(string? s) => throw null;
    }
    public struct Void { }
    public struct Boolean { }
    public class ValueType { }
    public class Attribute { }
    public struct Enum { }
    public struct Int32 { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13)
                );

            VerifyAnnotations(c, "System.String.IsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_String_IsNullOrEmpty_WithoutCorlib_RemovingAnnotations()
        {
            CSharpCompilation c = CreateEmptyCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        if (string.IsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
}
namespace System
{
    public class Object
    {
        public virtual string ToString() => throw null;
    }
    public class String
    {
        public static bool IsNullOrEmpty([NotNullWhenTrue] string? s) => throw null;
    }
    public struct Void { }
    public struct Boolean { }
    public class ValueType { }
    public class Enum { }
    public struct Int32 { }
    public class Attribute { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}
", NotNullWhenTrueAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13)
                );

            VerifyAnnotations(c, "System.String.IsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void ExtraAnnotationsWin()
        {
            CSharpCompilation c = CreateEmptyCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        System.Diagnostics.Debug.Assert(s != null, ""message"");
        s.ToString(); // ok
    }
}
namespace System
{
    public class Object
    {
        public virtual string ToString() => throw null;
    }
    public class String { }
    public struct Void { }
    public struct Boolean { }
    public class ValueType { }
    public class Enum { }
    public struct Int32 { }
    public class Attribute { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}
namespace System.Diagnostics
{
    public static class Debug
    {
        public static void Assert(bool condition, [EnsuresNotNull] string message) => throw null;
    }
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotations(c, "System.Diagnostics.Debug.Assert", AssertsTrue, None);
        }

        [Fact]
        public void NotNullWhenFalse_String_IsNullOrWhiteSpace_WithoutCorlib()
        {
            CSharpCompilation c = CreateEmptyCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        if (string.IsNullOrWhiteSpace(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
}
namespace System
{
    public class Object
    {
        public virtual string ToString() => throw null;
    }
    public class String
    {
        public static bool IsNullOrWhiteSpace(string? s) => throw null;
    }
    public struct Void { }
    public struct Boolean { }
    public class ValueType { }
    public class Attribute { }
    public struct Int32 { }
    public struct Enum { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13)
                );

            VerifyAnnotations(c, "System.String.IsNullOrWhiteSpace", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_String_NotIsNullOrEmpty()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        if (!string.IsNullOrEmpty(s))
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(12, 13)
                );

            VerifyAnnotationsAndMetadata(c, "System.String.IsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_String_NotIsNullOrEmpty_NoDuplicateWarnings()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void M()
    {
        if (!string.IsNullOrEmpty(M2(null)))
        {
        }
    }
    string? M2(string s) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,38): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         if (!string.IsNullOrEmpty(M2(null)))
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 38)
                );
        }

        [Fact]
        public void NotNullWhenFalse_String_NotIsNullOrEmpty_NotAString()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void M()
    {
        if (!string.IsNullOrEmpty(M2(null)))
        {
        }
    }
    void M2(string s) => throw null;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,35): error CS1503: Argument 1: cannot convert from 'void' to 'string'
                //         if (!string.IsNullOrEmpty(M2(null)))
                Diagnostic(ErrorCode.ERR_BadArgType, "M2(null)").WithArguments("1", "void", "string").WithLocation(6, 35),
                // (6,38): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         if (!string.IsNullOrEmpty(M2(null)))
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 38)
                );
        }

        [Fact]
        public void NotNullWhenFalse_String_IsNullOrWhiteSpace()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        if (string.IsNullOrWhiteSpace(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // ok
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13)
                );

            VerifyAnnotationsAndMetadata(c, "System.String.IsNullOrWhiteSpace", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_PartialMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public partial class C
{
    partial void M1(string? s);
    partial void M1([NotNullWhenFalse] string? s) => throw null;

    partial void M2([NotNullWhenFalse] string? s);
    partial void M2(string? s) => throw null;

    partial void M3([NotNullWhenFalse] string? s);
    partial void M3([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (11,22): error CS0579: Duplicate 'NotNullWhenFalse' attribute
                //     partial void M3([NotNullWhenFalse] string? s);
                Diagnostic(ErrorCode.ERR_DuplicateAttribute, "NotNullWhenFalse").WithArguments("NotNullWhenFalse").WithLocation(11, 22)
                );

            VerifyAnnotations(c, "C.M1", NotNullWhenFalse);
            VerifyAnnotations(c, "C.M2", NotNullWhenFalse);
            VerifyAnnotations(c, "C.M3", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_ReturningDynamic()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString(); // warn 2
        }
    }
    public dynamic MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 13)
                );

            VerifyAnnotations(c, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_ReturningObject_FromMetadata()
        {
            string il = @"
.class private auto ansi sealed beforefieldinit System.Runtime.CompilerServices.NullableAttribute
    extends [mscorlib]System.Attribute
{
    .method public hidebysig specialname rtspecialname
        instance void .ctor () cil managed
    {
        IL_0000: ldnull
        IL_0001: throw
    }
}

.class public auto ansi beforefieldinit C
    extends [mscorlib]System.Object
{
    .method public hidebysig
        instance object MyIsNullOrEmpty (string s) cil managed
    {
        .param [1]
        .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = (
            01 00 00 00
        )
        .custom instance void System.Runtime.CompilerServices.NotNullWhenFalseAttribute::.ctor() = (
            01 00 00 00
        )

        IL_0000: ldnull
        IL_0001: throw
    }

    .method public hidebysig specialname rtspecialname
        instance void .ctor () cil managed
    {
        IL_0000: ldnull
        IL_0001: throw
    }
}

.class public auto ansi beforefieldinit System.Runtime.CompilerServices.NotNullWhenFalseAttribute
    extends [mscorlib]System.Attribute
{
    .custom instance void [mscorlib]System.AttributeUsageAttribute::.ctor(valuetype [mscorlib]System.AttributeTargets) = (
        01 00 00 08 00 00 01 00 54 02 0d 41 6c 6c 6f 77 4d 75 6c 74 69 70 6c 65 00
    )
    .method public hidebysig specialname rtspecialname
        instance void .ctor () cil managed
    {
        IL_0000: ldnull
        IL_0001: throw
    }
}
";
            string source = @"
public class D
{
    void Main(C c, string? s)
    {
        if ((bool)c.MyIsNullOrEmpty(s))
        {
            s.ToString(); // warn 1
        }
        else
        {
            s.ToString(); // warn 2
        }
    }
}
";
            var compilation = CreateCompilationWithIL(new[] { source }, il, options: WithNonNullTypesTrue());
            compilation.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 13),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(12, 13)
                );

            VerifyAnnotations(compilation, "C.MyIsNullOrEmpty", NotNullWhenFalse);
        }

        [Fact]
        public void NotNullWhenFalse_ReturningObject()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        MyIsNullOrEmpty(s);
        s.ToString(); // warn
    }
    object MyIsNullOrEmpty([NotNullWhenFalse] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NotNullWhenFalse_FollowedByEnsuresNotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (MyIsNullOrEmpty(s, s))
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // ok
        }

        s.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse] string? s, [EnsuresNotNull] string? s2) => throw null;
}
", NotNullWhenFalseAttributeDefinition, EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", NotNullWhenFalse, EnsuresNotNull);
        }

        [Fact]
        public void NotNullWhenFalse_AndEnsuresNotNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        if (MyIsNullOrEmpty(s))
        {
            s.ToString(); // ok
        }
        else
        {
            s.ToString(); // ok
        }

        s.ToString(); // ok
    }
    public static bool MyIsNullOrEmpty([NotNullWhenFalse, EnsuresNotNull] string? s) => throw null;
}
", NotNullWhenFalseAttributeDefinition, EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotationsAndMetadata(c, "C.MyIsNullOrEmpty", EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_Simple()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        ThrowIfNull(42, s);
        s.ToString(); // ok
    }
    public static void ThrowIfNull(int x, [EnsuresNotNull] string? s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotationsAndMetadata(c, "C.ThrowIfNull", None, EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_Nested()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        ThrowIfNull(s?.ToString());
        s.ToString(); // ok
    }
    public static void ThrowIfNull([EnsuresNotNull] string? s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_ResettingStateMatters()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s, string? s2)
    {
        ThrowIfNull(s = s2, s2 = ""hello"");
        s.ToString(); // warn
        s2.ToString(); // ok
    }
    public static void ThrowIfNull(string? s1, [EnsuresNotNull] string? s2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_ResettingStateMatters_InIndexer()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s, string? s2)
    {
        _ = this[s = s2, s2 = ""hello""];
        s.ToString(); // warn
        s2.ToString(); // ok
    }
    public int this[string? s1, [EnsuresNotNull] string? s2] { get { throw null; } }
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_NoDuplicateDiagnosticsWhenResettingState()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public interface I<T> { }
public class C
{
    void Main(string? s, I<object> i)
    {
        ThrowIfNull(i, s); // single warning on conversion failure
    }
    public static void ThrowIfNull(I<object?> x, [EnsuresNotNull] string? s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,21): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'x' in 'void C.ThrowIfNull(I<object?> x, string? s)'.
                //         ThrowIfNull(i, s); // single warning on conversion failure
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "i").WithArguments("I<object>", "I<object?>", "x", "void C.ThrowIfNull(I<object?> x, string? s)").WithLocation(8, 21)
                );
        }

        [Fact]
        public void EnsuresNotNull_Generic_WithRefType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        ThrowIfNull(s);
        s.ToString(); // ok
    }
    public static void ThrowIfNull<T>([EnsuresNotNull] T s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_Generic_WithValueType()
        {
            CSharpCompilation c = CreateCompilation(@"
using System.Runtime.CompilerServices;
public class C
{
    void Main(int s)
    {
        ThrowIfNull(s);
        s.ToString();
    }
    public static void ThrowIfNull<T>([EnsuresNotNull] T s) => throw null;
}
" + EnsuresNotNullAttributeDefinition);

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_Generic_WithUnconstrainedGenericType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M<U>(U u)
    {
        ThrowIfNull(u);
        u.ToString();
    }
    public static void ThrowIfNull<T>([EnsuresNotNull] T s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_OnInterface()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s, Interface i)
    {
        i.ThrowIfNull(42, s);
        s.ToString(); // ok
    }
}
public interface Interface
{
    void ThrowIfNull(int x, [EnsuresNotNull] string? s);
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotationsAndMetadata(c, "Interface.ThrowIfNull", None, EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_OnInterface_ImplementedWithoutAttribute()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C : Interface
{
    void Main(string? s)
    {
        this.ThrowIfNull(42, s);
        s.ToString(); // warn
        ((Interface)this).ThrowIfNull(42, s);
        s.ToString(); // ok
    }
    public void ThrowIfNull(int x, string? s) => throw null;
}
public interface Interface
{
    void ThrowIfNull(int x, [EnsuresNotNull] string? s);
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );

            VerifyAnnotationsAndMetadata(c, "Interface.ThrowIfNull", None, EnsuresNotNull);
            VerifyAnnotationsAndMetadata(c, "C.ThrowIfNull", None, None);
        }

        [Fact]
        public void EnsuresNotNull_OnInterface_ImplementedWithAttribute()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C : Interface
{
    void Main(string? s)
    {
        ((Interface)this).ThrowIfNull(42, s);
        s.ToString(); // warn
        this.ThrowIfNull(42, s);
        s.ToString(); // ok
    }
    public void ThrowIfNull(int x, [EnsuresNotNull] string? s) => throw null;
}
public interface Interface
{
    void ThrowIfNull(int x, string? s);
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );

            VerifyAnnotationsAndMetadata(c, "Interface.ThrowIfNull", None, None);
            VerifyAnnotationsAndMetadata(c, "C.ThrowIfNull", None, EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_OnDelegate()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
delegate void D([EnsuresNotNull] object? o);
public class C
{
    void Main(string? s, D d)
    {
        d(s);
        s.ToString(); // ok
    }
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_WithParams()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    static void EnsuresNotNull([EnsuresNotNull] params object?[]? args) { }
    static void F(object? x, object? y, object[]? a)
    {
        EnsuresNotNull();
        a.ToString(); // warn 1

        EnsuresNotNull(x, y);
        x.ToString(); // warn 2
        y.ToString(); // warn 3

        EnsuresNotNull(a);
        a.ToString(); // ok
    }
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(9, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // warn 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(13, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_WithParamsOnFirstParameter()
        {
            CSharpCompilation c = CreateCompilationWithIL(new[] { @"
public class D
{
    static void F(object[]? a, object? b, object? c)
    {
        C.EnsuresNotNull(a, b, c);
        a.ToString(); // ok
        b.ToString(); // warn 1
        c.ToString(); // warn 2
    }
}
" }, @"
.class private auto ansi sealed beforefieldinit System.Runtime.CompilerServices.NullableAttribute
    extends [mscorlib]System.Attribute
{
    .custom instance void [mscorlib]System.Runtime.CompilerServices.CompilerGeneratedAttribute::.ctor() = (
        01 00 00 00
    )
    .method public hidebysig specialname rtspecialname instance void .ctor () cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Attribute::.ctor()
        IL_0006: nop
        IL_0007: ret
    }

    .method public hidebysig specialname rtspecialname instance void .ctor ( bool[] '' ) cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Attribute::.ctor()
        IL_0006: nop
        IL_0007: ret
    }
}

.class public auto ansi beforefieldinit C
    extends [mscorlib]System.Object
{
    .method public hidebysig static void EnsuresNotNull ( object[] args, object[] args2 ) cil managed
    {
        .param [1]
        .custom instance void [mscorlib]System.ParamArrayAttribute::.ctor() = (
            01 00 00 00
        )
        .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(bool[]) = (
            01 00 02 00 00 00 01 01 00 00
        )
        .custom instance void System.Runtime.CompilerServices.EnsuresNotNullAttribute::.ctor() = (
            01 00 00 00
        )
        .param [2]
        .custom instance void [mscorlib]System.ParamArrayAttribute::.ctor() = (
            01 00 00 00
        )
        .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(bool[]) = (
            01 00 02 00 00 00 01 01 00 00
        )
        .custom instance void System.Runtime.CompilerServices.EnsuresNotNullAttribute::.ctor() = (
            01 00 00 00
        )

        IL_0000: nop
        IL_0001: ret
    }

    .method public hidebysig specialname rtspecialname instance void .ctor () cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Object::.ctor()
        IL_0006: nop
        IL_0007: ret
    }
}

.class public auto ansi beforefieldinit System.Runtime.CompilerServices.EnsuresNotNullAttribute
    extends [mscorlib]System.Attribute
{
    .custom instance void [mscorlib]System.AttributeUsageAttribute::.ctor(valuetype [mscorlib]System.AttributeTargets) = (
        01 00 00 08 00 00 01 00 54 02 0d 41 6c 6c 6f 77 4d 75 6c 74 69 70 6c 65 00
    )
    .method public hidebysig specialname rtspecialname instance void .ctor () cil managed
    {
        IL_0000: ldarg.0
        IL_0001: call instance void [mscorlib]System.Attribute::.ctor()
        IL_0006: nop
        IL_0007: nop
        IL_0008: ret
    }
}
", options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         b.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(9, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_WithNamedArguments()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    static void EnsuresNotNull1([EnsuresNotNull] object? x = null, object? y = null) { }
    static void EnsuresNotNull2(object? x = null, [EnsuresNotNull] object? y = null) { }
    static void F(object? x)
    {
        EnsuresNotNull1();
        EnsuresNotNull1(y: x);
        x.ToString(); // warn
        EnsuresNotNull2(y: x);
        x.ToString(); // ok
    }
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(11, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_OnDifferentTypes()
        {
            CSharpCompilation c = CreateCompilation(@"
using System.Runtime.CompilerServices;
public class C
{
    public static void Bad<T>([EnsuresNotNull] int i) => throw null;
    public static void ThrowIfNull<T>([EnsuresNotNull] T t) => throw null;
}
" + EnsuresNotNullAttributeDefinition);

            c.VerifyDiagnostics();

            VerifyAnnotations(c, "C.Bad", EnsuresNotNull);
            VerifyAnnotations(c, "C.ThrowIfNull", EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_GenericMethod()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
   void M<T>(T t)
    {
        t.ToString(); // warn
        ThrowIfNull(t);
        t.ToString(); // ok
    }
    public static void ThrowIfNull<T>([EnsuresNotNull] T s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(7, 9)
                );

            VerifyAnnotationsAndMetadata(c, "C.ThrowIfNull", EnsuresNotNull);
        }

        [Fact]
        [WorkItem(30079, "https://github.com/dotnet/roslyn/issues/30079")]
        public void EnsuresNotNull_BeginInvoke()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public delegate void Delegate([EnsuresNotNull] string? s);
public class C
{
   void M(Delegate d, string? s)
    {
        if (s != string.Empty) s.ToString(); // warn
        d.BeginInvoke(s, null, null);
        s.ToString(); // warn 2
    }
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,32): warning CS8602: Possible dereference of a null reference.
                //         if (s != string.Empty) s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 32),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(10, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_BackEffect()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s1, string? s2)
    {
        ThrowIfNull(s2 = s1, s1);
        s2.ToString(); // warn
    }
    public static void ThrowIfNull(string? x1, [EnsuresNotNull] string? x2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29865: Should we be able to trace that s2 was assigned a non-null value?
            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(8, 9)
                );
        }

        [Fact]
        [WorkItem(29916, "https://github.com/dotnet/roslyn/issues/29916")]
        public void EnsuresNotNull_InErrorInvocation()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s1, string? s2)
    {
        Missing(ThrowIfNull(s1, s2 = s1));
        s2.ToString();
    }
    public static void ThrowIfNull([EnsuresNotNull] string? x1, string? x2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,9): error CS0103: The name 'Missing' does not exist in the current context
                //         Missing(ThrowIfNull(s1, s2 = s1));
                Diagnostic(ErrorCode.ERR_NameNotInContext, "Missing").WithArguments("Missing").WithLocation(7, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_ForwardEffect()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s1, string? s2)
    {
        ThrowIfNull(s1, s2 = s1);
        s2.ToString(); // ok
    }
    public static void ThrowIfNull([EnsuresNotNull] string? x1, string? x2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_ForwardEffect2()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s1)
    {
        ThrowIfNull(s1, s1 = null);
        s1.ToString(); // warn
    }
    public static void ThrowIfNull([EnsuresNotNull] string? x1, string? x2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s1.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s1").WithLocation(8, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_ForwardEffect3()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s1, string? s2)
    {
        ThrowIfNull(s1 = null, s2 = s1, s1 = """", s1);
        s2.ToString(); // warn
    }
    public static void ThrowIfNull(string? x1, string? x2, string? x3, [EnsuresNotNull] string? x4) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s2.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(8, 9)
                );
        }

        [Fact]
        [WorkItem(29867, "https://github.com/dotnet/roslyn/issues/29867")]
        public void EnsuresNotNull_TypeInference()
        {
            // https://github.com/dotnet/roslyn/issues/29867: This test raises the question of flowing information from annotations into the inferred type
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void M(string? s1)
    {
        ThrowIfNull(s1, out var s2);
        s2/*T:string?*/.ToString();
    }
    public static void ThrowIfNull<T>([EnsuresNotNull] T x1, out T x2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s2/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(8, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_ConditionalMethodInReleaseMode()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        ThrowIfNull(42, s);
        s.ToString(); // ok
    }
    [System.Diagnostics.Conditional(""DEBUG"")]
    static void ThrowIfNull(int x, [EnsuresNotNull] string? s) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void EnsuresNotNull_SecondArgumentDereferences()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
public class C
{
    void Main(string? s)
    {
        ThrowIfNull(s, s.ToString()); // warn
        s.ToString(); // ok
    }
    public static void ThrowIfNull([EnsuresNotNull] string? s, string s2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,24): warning CS8602: Possible dereference of a null reference.
                //         ThrowIfNull(s, s.ToString()); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 24)
                );

            VerifyAnnotationsAndMetadata(c, "C.ThrowIfNull", EnsuresNotNull, None);
        }

        [Fact]
        public void EnsuresNotNull_SecondArgumentAssigns()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        ThrowIfNull(s, s = null);
        s.ToString(); // warn
    }
    static void ThrowIfNull([EnsuresNotNull] string? s, string? s2) => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9)
                );
        }

        [Fact]
        public void EnsuresNotNull_String_Contains()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Main(string? s)
    {
        ""hello"".Contains(s);
        s.ToString(); // ok
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();

            VerifyAnnotationsAndMetadata(c, "System.String.Contains", EnsuresNotNull);
        }

        [Fact]
        public void EnsuresNotNull_Indexer()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Runtime.CompilerServices;
class C
{
    void Main(string? s)
    {
        _ = this[42, s];
        s.ToString(); // ok
    }
    public int this[int x, [EnsuresNotNull] string? s] => throw null;
}
", EnsuresNotNullAttributeDefinition }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void ConditionalBranching_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 x1, CL1? y1, CL1 z1)
    {
        if (y1 != null)
        {
            x1 = y1;
        }
        else
        {
            z1 = y1;
        }
    }

    void Test2(CL1 x2, CL1? y2, CL1 z2)
    {
        if (y2 == null)
        {
            x2 = y2;
        }
        else
        {
            z2 = y2;
        }
    }

    void Test3(CL2 x3, CL2? y3, CL2 z3)
    {
        if (y3 != null)
        {
            x3 = y3;
        }
        else
        {
            z3 = y3;
        }
    }

    void Test4(CL2 x4, CL2? y4, CL2 z4)
    {
        if (y4 == null)
        {
            x4 = y4;
        }
        else
        {
            z4 = y4;
        }
    }

    void Test5(CL1 x5, CL1 y5, CL1 z5)
    {
        if (y5 != null)
        {
            x5 = y5;
        }
        else
        {
            z5 = y5;
        }
    }
}

class CL1
{
}

class CL2
{
    public static bool operator == (CL2? x, CL2? y) { return false; }
    public static bool operator != (CL2? x, CL2? y) { return false; }
    public override bool Equals(object obj) { return false; }
    public override int GetHashCode() { return 0; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             z1 = y1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1").WithLocation(16, 18),
                 // (24,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x2 = y2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2").WithLocation(24, 18),
                 // (40,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             z3 = y3;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y3").WithLocation(40, 18),
                 // (48,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x4 = y4;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y4").WithLocation(48, 18),
                 // (58,13): hidden CS8605: Result of the comparison is possibly always true.
                 //         if (y5 != null)
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "y5 != null").WithLocation(58, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 x1, CL1? y1, CL1 z1)
    {
        if (null != y1)
        {
            x1 = y1;
        }
        else
        {
            z1 = y1;
        }
    }

    void Test2(CL1 x2, CL1? y2, CL1 z2)
    {
        if (null == y2)
        {
            x2 = y2;
        }
        else
        {
            z2 = y2;
        }
    }

    void Test3(CL2 x3, CL2? y3, CL2 z3)
    {
        if (null != y3)
        {
            x3 = y3;
        }
        else
        {
            z3 = y3;
        }
    }

    void Test4(CL2 x4, CL2? y4, CL2 z4)
    {
        if (null == y4)
        {
            x4 = y4;
        }
        else
        {
            z4 = y4;
        }
    }

    void Test5(CL1 x5, CL1 y5, CL1 z5)
    {
        if (null == y5)
        {
            x5 = y5;
        }
        else
        {
            z5 = y5;
        }
    }
}

class CL1
{
}

class CL2
{
    public static bool operator == (CL2? x, CL2? y) { return false; }
    public static bool operator != (CL2? x, CL2? y) { return false; }
    public override bool Equals(object obj) { return false; }
    public override int GetHashCode() { return 0; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             z1 = y1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1").WithLocation(16, 18),
                 // (24,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x2 = y2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2").WithLocation(24, 18),
                 // (40,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             z3 = y3;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y3").WithLocation(40, 18),
                 // (48,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x4 = y4;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y4").WithLocation(48, 18),
                 // (58,13): hidden CS8606: Result of the comparison is possibly always false.
                 //         if (null == y5)
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "null == y5").WithLocation(58, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 x1, CL1? y1, CL1 z1, bool u1)
    {
        if (null != y1 || u1)
        {
            x1 = y1;
        }
        else
        {
            z1 = y1;
        }
    }

    void Test2(CL1 x2, CL1? y2, CL1 z2, bool u2)
    {
        if (y2 != null && u2)
        {
            x2 = y2;
        }
        else
        {
            z2 = y2;
        }
    }

    bool Test3(CL1? x3)
    {
        return x3.M1();
    }

    bool Test4(CL1? x4)
    {
        return x4 != null && x4.M1();
    }

    bool Test5(CL1? x5)
    {
        return x5 == null && x5.M1();
    }
}

class CL1
{
    public bool M1() { return true; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x1 = y1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1").WithLocation(12, 18),
                 // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             z1 = y1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1").WithLocation(16, 18),
                 // (28,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             z2 = y2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2").WithLocation(28, 18),
                 // (34,16): warning CS8602: Possible dereference of a null reference.
                 //         return x3.M1();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x3").WithLocation(34, 16),
                 // (44,30): warning CS8602: Possible dereference of a null reference.
                 //         return x5 == null && x5.M1();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x5").WithLocation(44, 30)
                );
        }

        [Fact]
        public void ConditionalBranching_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 x1, CL1? y1)
    {
        CL1 z1 = y1 ?? x1;
    }

    void Test2(CL1? x2, CL1? y2)
    {
        CL1 z2 = y2 ?? x2;
    }

    void Test3(CL1 x3, CL1? y3)
    {
        CL1 z3 = x3 ?? y3;
    }

    void Test4(CL1? x4, CL1 y4)
    {
        x4 = y4;
        CL1 z4 = x4 ?? x4.M1();
    }

    void Test5(CL1 x5)
    {
        const CL1? y5 = null;
        CL1 z5 = y5 ?? x5;
    }

    void Test6(CL1 x6)
    {
        const string? y6 = """";
        string z6 = y6 ?? x6.M2();
    }
}

class CL1
{
    public CL1 M1() { return new CL1(); }
    public string? M2() { return null; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (15,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 z2 = y2 ?? x2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2 ?? x2").WithLocation(15, 18),
                // (20,18): hidden CS8607: Expression is probably never null.
                //         CL1 z3 = x3 ?? y3;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x3").WithLocation(20, 18),
                // (26,18): hidden CS8607: Expression is probably never null.
                //         CL1 z4 = x4 ?? x4.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x4").WithLocation(26, 18),
                // (38,21): hidden CS8607: Expression is probably never null.
                //         string z6 = y6 ?? x6.M2();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y6").WithLocation(38, 21)
                );
        }

        [Fact]
        public void ConditionalBranching_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1? x1)
    {
        CL1 z1 = x1?.M1();
    }

    void Test2(CL1? x2, CL1 y2)
    {
        x2 = y2;
        CL1 z2 = x2?.M1();
    }

    void Test3(CL1? x3, CL1 y3)
    {
        x3 = y3;
        CL1 z3 = x3?.M2();
    }

    void Test4(CL1? x4)
    {
        x4?.M3(x4);
    }
}

class CL1
{
    public CL1 M1() { return new CL1(); }
    public CL1? M2() { return null; }
    public void M3(CL1 x) { }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL1 z1 = x1?.M1();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1?.M1()").WithLocation(10, 18),
                 // (16,18): hidden CS8607: Expression is probably never null.
                 //         CL1 z2 = x2?.M1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(16, 18),
                 // (22,18): hidden CS8607: Expression is probably never null.
                 //         CL1 z3 = x3?.M2();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x3").WithLocation(22, 18),
                 // (22,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL1 z3 = x3?.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3?.M2()").WithLocation(22, 18)
                );
        }

        [Fact]
        public void ConditionalBranching_06()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 x1, CL1? y1)
    {
        CL1 z1 = y1 != null ? y1 : x1;
    }

    void Test2(CL1? x2, CL1? y2)
    {
        CL1 z2 = y2 != null ? y2 : x2;
    }

    void Test3(CL1 x3, CL1? y3)
    {
        CL1 z3 = x3 != null ? x3 : y3;
    }

    void Test4(CL1? x4, CL1 y4)
    {
        x4 = y4;
        CL1 z4 = x4 != null ? x4 : x4.M1();
    }

    void Test5(CL1 x5)
    {
        const CL1? y5 = null;
        CL1 z5 = y5 != null ? y5 : x5;
    }

    void Test6(CL1 x6)
    {
        const string? y6 = """";
        string z6 = y6 != null ? y6 : x6.M2();
    }

    void Test7(CL1 x7)
    {
        const string? y7 = null;
        string z7 = y7 != null ? y7 : x7.M2();
    }
}

class CL1
{
    public CL1 M1() { return new CL1(); }
    public string? M2() { return null; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (15,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 z2 = y2 != null ? y2 : x2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2 != null ? y2 : x2").WithLocation(15, 18),
                // (20,18): hidden CS8605: Result of the comparison is possibly always true.
                //         CL1 z3 = x3 != null ? x3 : y3;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "x3 != null").WithLocation(20, 18),
                // (20,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 z3 = x3 != null ? x3 : y3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3 != null ? x3 : y3").WithLocation(20, 18),
                // (26,18): hidden CS8605: Result of the comparison is possibly always true.
                //         CL1 z4 = x4 != null ? x4 : x4.M1();
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "x4 != null").WithLocation(26, 18),
                // (38,21): hidden CS8605: Result of the comparison is possibly always true.
                //         string z6 = y6 != null ? y6 : x6.M2();
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "y6 != null").WithLocation(38, 21),
                // (44,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         string z7 = y7 != null ? y7 : x7.M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y7 != null ? y7 : x7.M2()").WithLocation(44, 21)
                );
        }

        [Fact]
        public void ConditionalBranching_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 x1, CL1? y1)
    {
        CL1 z1 = y1 == null ? x1 : y1;
    }

    void Test2(CL1? x2, CL1? y2)
    {
        CL1 z2 = y2 == null ? x2 : y2;
    }

    void Test3(CL1 x3, CL1? y3)
    {
        CL1 z3 = x3 == null ? y3 : x3;
    }

    void Test4(CL1? x4, CL1 y4)
    {
        x4 = y4;
        CL1 z4 = x4 == null ? x4.M1() : x4;
    }

    void Test5(CL1 x5)
    {
        const CL1? y5 = null;
        CL1 z5 = y5 == null ? x5 : y5;
    }

    void Test6(CL1 x6)
    {
        const string? y6 = """";
        string z6 = y6 == null ? x6.M2() : y6;
    }

    void Test7(CL1 x7)
    {
        const string? y7 = null;
        string z7 = y7 == null ? x7.M2() : y7;
    }
}

class CL1
{
    public CL1 M1() { return new CL1(); }
    public string? M2() { return null; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (15,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 z2 = y2 == null ? x2 : y2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2 == null ? x2 : y2").WithLocation(15, 18),
                // (20,18): hidden CS8606: Result of the comparison is possibly always false.
                //         CL1 z3 = x3 == null ? y3 : x3;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "x3 == null").WithLocation(20, 18),
                // (20,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 z3 = x3 == null ? y3 : x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3 == null ? y3 : x3").WithLocation(20, 18),
                // (26,18): hidden CS8606: Result of the comparison is possibly always false.
                //         CL1 z4 = x4 == null ? x4.M1() : x4;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "x4 == null").WithLocation(26, 18),
                // (38,21): hidden CS8606: Result of the comparison is possibly always false.
                //         string z6 = y6 == null ? x6.M2() : y6;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "y6 == null").WithLocation(38, 21),
                // (44,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         string z7 = y7 == null ? x7.M2() : y7;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y7 == null ? x7.M2() : y7").WithLocation(44, 21)
                );
        }

        [Fact]
        [WorkItem(26624, "https://github.com/dotnet/roslyn/issues/26624")]
        public void ConditionalBranching_08()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    bool Test1(CL1? x1)
    {
        if (x1?.P1 == true)
        {
            return x1.P2;
        }

        return false;
    }
}

class CL1
{
    public bool P1 { get { return true;} }
    public bool P2 { get { return true;} }
}
" }, options: WithNonNullTypesTrue());
            // Not tracking state of x?.P == expr
            // unless expr is `null`. See https://github.com/dotnet/roslyn/issues/26624.
            c.VerifyDiagnostics(
                // (12,20): warning CS8602: Possible dereference of a null reference.
                //             return x1.P2;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(12, 20)
                );
        }

        [Fact]
        public void ConditionalBranching_09()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(object x1, object? y1)
    {
        y1 = x1;
        y1.ToString();
        object z1 = y1 ?? x1;
        y1.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,21): hidden CS8607: Expression is probably never null.
                 //         object z1 = y1 ?? x1;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y1").WithLocation(12, 21)
                );
        }

        [Fact]
        public void ConditionalBranching_10()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(object x1, object? y1)
    {
        y1 = x1;
        y1.ToString();
        object z1 = y1 != null ? y1 : x1;
        y1.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,21): hidden CS8605: Result of the comparison is possibly always true.
                 //         object z1 = y1 != null ? y1 : x1;
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "y1 != null").WithLocation(12, 21)
                );
        }

        [Fact]
        public void ConditionalBranching_11()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(object x1, object? y1)
    {
        y1 = x1;
        y1.ToString();
        y1?.GetHashCode();
        y1.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,9): hidden CS8607: Expression is probably never null.
                 //         y1?.GetHashCode();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y1").WithLocation(12, 9)
                );
        }

        [Fact]
        public void ConditionalBranching_12()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(object x1, object? y1)
    {
        y1 = x1;
        y1.ToString();

        if (y1 == null)
        {
            System.Console.WriteLine(1);
        }
        else
        {
            System.Console.WriteLine(2);
        }

        y1.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (13,13): hidden CS8606: Result of the comparison is possibly always false.
                 //         if (y1 == null)
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "y1 == null").WithLocation(13, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_13()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(object x1, object? y1)
    {
        y1 = x1;
        y1.ToString();

        if (y1 != null)
        {
            System.Console.WriteLine(1);
        }
        else
        {
            System.Console.WriteLine(2);
        }

        y1.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (13,13): hidden CS8605: Result of the comparison is possibly always true.
                 //         if (y1 != null)
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "y1 != null").WithLocation(13, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_14()
        {
            var compilation = CreateCompilation(new[] { @"
class C
{
    C? _cField = null;
    C _nonNullCField = new C();
    C? GetC() => null;
    C? CProperty { get => null; }

    void Test1(C? c1)
    {
        if (c1?._cField != null)
        {
            c1._cField.ToString();
        }
        else
        {
            c1._cField.ToString(); // warn 1 2
        }
    }

    void Test2()
    {
        C? c2 = GetC();
        if (c2?._cField != null)
        {
            c2._cField.ToString();
        }
        else
        {
            c2._cField.ToString(); // warn 3 4
        }
    }

    void Test3(C? c3)
    {
        if (c3?._cField?._cField != null)
        {
            c3._cField._cField.ToString();
        }
        else if (c3?._cField != null)
        {
            c3._cField.ToString();
            c3._cField._cField.ToString(); // warn 5
        }
        else
        {
            c3.ToString(); // warn 6
        }
    }

    void Test4(C? c4)
    {
        if (c4?._nonNullCField._cField?._nonNullCField._cField != null)
        {
            c4._nonNullCField._cField._nonNullCField._cField.ToString();
        }
        else
        {
            c4._nonNullCField._cField._nonNullCField._cField.ToString(); // warn 7 8 9
        }
    }

    void Test5(C? c5)
    {
        if (c5?._cField == null)
        {
            c5._cField.ToString(); // warn 10 11
        }
        else
        {
            c5._cField.ToString();
        }
    }

    void Test6(C? c6)
    {
        if (c6?._cField?.GetC() != null)
        {
            c6._cField.GetC().ToString(); // warn 12
        }
    }

    void Test7(C? c7)
    {
        if (c7?._cField?.CProperty != null)
        {
            c7._cField.CProperty.ToString();
        }
    }
}
" }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //             c1._cField.ToString(); // warn 1 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1").WithLocation(17, 13),
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //             c1._cField.ToString(); // warn 1 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1._cField").WithLocation(17, 13),

                // (30,13): warning CS8602: Possible dereference of a null reference.
                //             c2._cField.ToString(); // warn 3 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(30, 13),
                // (30,13): warning CS8602: Possible dereference of a null reference.
                //             c2._cField.ToString(); // warn 3 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2._cField").WithLocation(30, 13),

                // (43,13): warning CS8602: Possible dereference of a null reference.
                //             c3._cField._cField.ToString(); // warn 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c3._cField._cField").WithLocation(43, 13),

                // (47,13): warning CS8602: Possible dereference of a null reference.
                //             c3.ToString(); // warn 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c3").WithLocation(47, 13),

                // (59,13): warning CS8602: Possible dereference of a null reference.
                //             c4._nonNullCField._cField._nonNullCField._cField.ToString(); // warn 7 8 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c4").WithLocation(59, 13),
                // (59,13): warning CS8602: Possible dereference of a null reference.
                //             c4._nonNullCField._cField._nonNullCField._cField.ToString(); // warn 7 8 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c4._nonNullCField._cField").WithLocation(59, 13),
                // (59,13): warning CS8602: Possible dereference of a null reference.
                //             c4._nonNullCField._cField._nonNullCField._cField.ToString(); // warn 7 8 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c4._nonNullCField._cField._nonNullCField._cField").WithLocation(59, 13),

                // (67,13): warning CS8602: Possible dereference of a null reference.
                //             c5._cField.ToString(); // warn 10 11
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c5").WithLocation(67, 13),
                // (67,13): warning CS8602: Possible dereference of a null reference.
                //             c5._cField.ToString(); // warn 10 11
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c5._cField").WithLocation(67, 13),

                // (79,13): warning CS8602: Possible dereference of a null reference.
                //             c6._cField.GetC().ToString(); // warn 12
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c6._cField.GetC()").WithLocation(79, 13)
            );
        }

        [Fact]
        public void ConditionalBranching_15()
        {
            var compilation = CreateCompilation(new[] { @"
class C
{
    void Test(C? c1)
    {
        if (c1?[0] != null)
        {
            c1.ToString();
            c1[0].ToString(); // warn 1
        }
        else
        {
            c1.ToString(); // warn 2
        }
    }

    object? this[int i] { get => null; }
}
" }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             c1[0].ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1[0]").WithLocation(9, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             c1.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1").WithLocation(13, 13)
            );
        }

        [Fact]
        public void ConditionalBranching_16()
        {
            var compilation = CreateCompilation(new[] { @"
class C
{
    void Test<T>(T t)
    {
        if (t?.ToString() != null)
        {
            t.ToString();
        }
        else
        {
            t.ToString(); // warn
        }
    }
}" }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             t.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_17()
        {
            var compilation = CreateCompilation(new[] { @"
class C
{
    object? Prop { get; }
    object? GetObj(bool val) => null;
    void Test(C? c1, C? c2)
    {
        if (c1?.GetObj(c2?.Prop != null) != null)
        {
            c2.Prop.ToString(); // warn 1 2
        }
    }
}" }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             c2.Prop.ToString(); // warn 1 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(10, 13),
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             c2.Prop.ToString(); // warn 1 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2.Prop").WithLocation(10, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_18()
        {
            var compilation = CreateCompilation(new[] { @"
class C
{
    void Test(C? x, C? y)
    {
        if ((x = y)?.GetHashCode() != null)
        {
            x.ToString();
            y.ToString(); // warn
        }
    }
}" }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             y.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_Is_ReferenceType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x is C)
        {
            x.ToString();
        }
        else
        {
            x.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_Is_GenericType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Base { }
class C : Base
{
    void Test<T>(C? x) where T : Base
    {
        if (x is T)
        {
            x.ToString();
        }
        else
        {
            x.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(13, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_Is_UnconstrainedGenericType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void F<T>(object? o)
    {
        if (o is T)
        {
            o.ToString();
        }
        else
        {
            o.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             o.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_Is_StructConstrainedGenericType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void F<T>(object? o) where T : struct
    {
        if (o is T)
        {
            o.ToString();
        }
        else
        {
            o.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             o.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_Is_ClassConstrainedGenericType()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void F<T>(object? o) where T : class
    {
        if (o is T)
        {
            o.ToString();
        }
        else
        {
            o.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             o.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_Is_UnconstrainedGenericOperand()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void F<T>(T t, object? o)
    {
        if (t is string) t.ToString();
        if (t is string s) { t.ToString(); s.ToString(); }
        if (t != null) t.ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics();
        }

        [Fact]
        public void ConditionalBranching_Is_NullOperand()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void F(object? o)
    {
        if (null is string) return;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (6,13): warning CS0184: The given expression is never of the provided ('string') type
                //         if (null is string) return;
                Diagnostic(ErrorCode.WRN_IsAlwaysFalse, "null is string").WithArguments("string").WithLocation(6, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsConstantPattern_Null()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x is null)
        {
            x.ToString(); // warn
        }
        else
        {
            x.ToString();
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsConstantPattern_NullInverted()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (!(x is null))
        {
            x.ToString();
        }
        else
        {
            x.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsConstantPattern_NonNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        const string nonNullConstant = ""hello"";
        if (x is nonNullConstant)
        {
            x.ToString();
        }
        else
        {
            x.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(13, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsConstantPattern_NullConstant()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        const string? nullConstant = null;
        if (x is nullConstant)
        {
            x.ToString(); // warn
        }
        else
        {
            x.ToString();
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(9, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsConstantPattern_NonConstant()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        string nonConstant = ""hello"";
        if (x is nonConstant)
        {
            x.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (7,18): error CS0150: A constant value is expected
                //         if (x is nonConstant)
                Diagnostic(ErrorCode.ERR_ConstantExpected, "nonConstant").WithLocation(7, 18),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(9, 13)
                );
        }

        [Fact]
        [WorkItem(29868, "https://github.com/dotnet/roslyn/issues/29868")]
        public void ConditionalBranching_IsConstantPattern_Null_AlreadyTestedAsNonNull()
        {
            // https://github.com/dotnet/roslyn/issues/29868: confirm that we want such hidden warnings
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x != null)
        {
            if (x is null) // hidden
            {
                x.ToString(); // warn
            }
            else
            {
                x.ToString();
            }
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,22): hidden CS8606: Result of the comparison is possibly always false.
                //             if (x is null) // hidden
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "null").WithLocation(8, 22),
                // (10,17): warning CS8602: Possible dereference of a null reference.
                //                 x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 17)
                );
        }

        [Fact]
        public void ConditionalBranching_IsConstantPattern_Null_AlreadyTestedAsNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x == null)
        {
            if (x is null)
            {
                x.ToString(); // warn
            }
            else
            {
                x.ToString();
            }
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,17): warning CS8602: Possible dereference of a null reference.
                //                 x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 17)
                );
        }

        [Fact]
        public void ConditionalBranching_IsDeclarationPattern()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x is C c)
        {
            x.ToString();
            c.ToString();
        }
        else
        {
            x.ToString(); // warn
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(13, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsVarDeclarationPattern()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x is var c)
        {
            x.ToString(); // warn 1
            c /*T:object?*/ .ToString(); // warn 2
        }
        else
        {
            x.ToString();
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             c /*T:object?*/ .ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(9, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsVarDeclarationPattern_Discard()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x is var _)
        {
            x.ToString(); // warn 1
        }
        else
        {
            x.ToString(); // warn 2
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString(); // warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(12, 13)
                );
        }

        [Fact]
        public void ConditionalBranching_IsVarDeclarationPattern_AlreadyTestedAsNonNull()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void Test(object? x)
    {
        if (x != null)
        {
            if (x is var c)
            {
                c /*T:object!*/ .ToString();
                c = null; // warn
            }
        }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyTypes();
            c.VerifyDiagnostics(
                // (11,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //                 c = null; // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(11, 21)
                );
        }

        [Fact]
        public void ConditionalOperator_01()
        {
            var source =
@"class C
{
    static void F(bool b, object x, object? y)
    {
        var z = b ? x : y;
        z.ToString();
        var w = b ? y : x;
        w.ToString();
        var v = true ? y : x;
        v.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(6, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         w.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w").WithLocation(8, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         v.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "v").WithLocation(10, 9));
        }

        [Fact]
        public void ConditionalOperator_02()
        {
            var source =
@"class C
{
    static void F(bool b, object x, object? y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
        if (y != null) (b ? x : y).ToString();
        if (y != null) (b ? y : x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : y").WithLocation(5, 10),
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y : x").WithLocation(6, 10));
        }

        [Fact]
        public void ConditionalOperator_03()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        (false ? x : y).ToString();
        (false ? y : x).ToString();
        (true ? x : y).ToString();
        (true ? y : x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (false ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "false ? x : y").WithLocation(5, 10),
                // (8,10): warning CS8602: Possible dereference of a null reference.
                //         (true ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "true ? y : x").WithLocation(8, 10));
        }

        [Fact]
        public void ConditionalOperator_04()
        {
            var source =
@"class C
{
    static void F(bool b, object x, string? y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
    static void G(bool b, object? x, string y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : y").WithLocation(5, 10),
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y : x").WithLocation(6, 10),
                // (10,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : y").WithLocation(10, 10),
                // (11,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y : x").WithLocation(11, 10));
        }

        [Fact]
        public void ConditionalOperator_05()
        {
            var source =
@"#pragma warning disable 0649
class A<T> { }
class B1 : A<object?> { }
class B2 : A<object> { }
class C
{
    static void F(bool b, A<object> x, A<object?> y, B1 z, B2 w)
    {
        object o;
        o = (b ? x : z)/*T:A<object!>!*/;
        o = (b ? x : w)/*T:A<object!>!*/;
        o = (b ? z : x)/*T:A<object!>!*/;
        o = (b ? w : x)/*T:A<object!>!*/;
        o = (b ? y : z)/*T:A<object?>!*/;
        o = (b ? y : w)/*T:A<object?>!*/;
        o = (b ? z : y)/*T:A<object?>!*/;
        o = (b ? w : y)/*T:A<object?>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (10,22): warning CS8619: Nullability of reference types in value of type 'B1' doesn't match target type 'A<object>'.
                //         o = (b ? x : z)/*T:A<object!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "z").WithArguments("B1", "A<object>").WithLocation(10, 22),
                // (12,18): warning CS8619: Nullability of reference types in value of type 'B1' doesn't match target type 'A<object>'.
                //         o = (b ? z : x)/*T:A<object!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "z").WithArguments("B1", "A<object>").WithLocation(12, 18),
                // (15,22): warning CS8619: Nullability of reference types in value of type 'B2' doesn't match target type 'A<object?>'.
                //         o = (b ? y : w)/*T:A<object?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w").WithArguments("B2", "A<object?>").WithLocation(15, 22),
                // (17,18): warning CS8619: Nullability of reference types in value of type 'B2' doesn't match target type 'A<object?>'.
                //         o = (b ? w : y)/*T:A<object?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w").WithArguments("B2", "A<object?>").WithLocation(17, 18));
        }

        [Fact]
        public void ConditionalOperator_06()
        {
            var source =
@"class C
{
    static void F(bool b, object x, string? y)
    {
        (b ? null : x).ToString();
        (b ? null : y).ToString();
        (b ? x: null).ToString();
        (b ? y: null).ToString();
        (b ? null: null).ToString();
        (b ? default : x).ToString();
        (b ? default : y).ToString();
        (b ? x: default).ToString();
        (b ? y: default).ToString();
        (b ? default: default).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between '<null>' and '<null>'
                //         (b ? null: null).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? null: null").WithArguments("<null>", "<null>").WithLocation(9, 10),
                // (14,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'default' and 'default'
                //         (b ? default: default).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? default: default").WithArguments("default", "default").WithLocation(14, 10),
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? null : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? null : x").WithLocation(5, 10),
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? null : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? null : y").WithLocation(6, 10),
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x: null).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x: null").WithLocation(7, 10),
                // (8,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y: null).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y: null").WithLocation(8, 10),
                // (9,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? null: null).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? null: null").WithLocation(9, 10),
                // (10,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? default : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? default : x").WithLocation(10, 10),
                // (11,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? default : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? default : y").WithLocation(11, 10),
                // (12,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x: default).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x: default").WithLocation(12, 10),
                // (13,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y: default).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y: default").WithLocation(13, 10),
                // (14,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? default: default).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? default: default").WithLocation(14, 10));
        }

        [Fact]
        public void ConditionalOperator_07()
        {
            var source =
@"class C
{
    static void F(bool b, Unknown x, Unknown? y)
    {
        (b ? null : x).ToString();
        (b ? null : y).ToString();
        (b ? x: null).ToString();
        (b ? y: null).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,27): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F(bool b, Unknown x, Unknown? y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(3, 27),
                // (3,38): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F(bool b, Unknown x, Unknown? y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(3, 38),
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? null : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? null : x").WithLocation(5, 10),
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x: null).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x: null").WithLocation(7, 10));
        }

        [Fact]
        public void ConditionalOperator_08()
        {
            var source =
@"class C
{
    static void F1(bool b, UnknownA x, UnknownB y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
    static void F2(bool b, UnknownA? x, UnknownB y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
    static void F3(bool b, UnknownA? x, UnknownB? y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,28): error CS0246: The type or namespace name 'UnknownA' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F1(bool b, UnknownA x, UnknownB y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "UnknownA").WithArguments("UnknownA").WithLocation(3, 28),
                // (3,40): error CS0246: The type or namespace name 'UnknownB' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F1(bool b, UnknownA x, UnknownB y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "UnknownB").WithArguments("UnknownB").WithLocation(3, 40),
                // (8,28): error CS0246: The type or namespace name 'UnknownA' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F2(bool b, UnknownA? x, UnknownB y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "UnknownA").WithArguments("UnknownA").WithLocation(8, 28),
                // (8,41): error CS0246: The type or namespace name 'UnknownB' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F2(bool b, UnknownA? x, UnknownB y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "UnknownB").WithArguments("UnknownB").WithLocation(8, 41),
                // (13,28): error CS0246: The type or namespace name 'UnknownA' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F3(bool b, UnknownA? x, UnknownB? y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "UnknownA").WithArguments("UnknownA").WithLocation(13, 28),
                // (13,41): error CS0246: The type or namespace name 'UnknownB' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F3(bool b, UnknownA? x, UnknownB? y)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "UnknownB").WithArguments("UnknownB").WithLocation(13, 41),
                // (10,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : y").WithLocation(10, 10),
                // (11,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y : x").WithLocation(11, 10),
                // (15,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'UnknownA?' and 'UnknownB?'
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? x : y").WithArguments("UnknownA?", "UnknownB?").WithLocation(15, 10),
                // (16,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'UnknownB?' and 'UnknownA?'
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? y : x").WithArguments("UnknownB?", "UnknownA?").WithLocation(16, 10),
                // (15,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : y").WithLocation(15, 10),
                // (16,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y : x").WithLocation(16, 10));
        }

        [Fact]
        public void ConditionalOperator_09()
        {
            var source =
@"struct A { }
struct B { }
class C
{
    static void F1(bool b, A x, B y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
    static void F2(bool b, A x, C y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
    static void F3(bool b, B x, C? y)
    {
        (b ? x : y).ToString();
        (b ? y : x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'A' and 'B'
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? x : y").WithArguments("A", "B").WithLocation(7, 10),
                // (8,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'B' and 'A'
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? y : x").WithArguments("B", "A").WithLocation(8, 10),
                // (12,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'A' and 'C'
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? x : y").WithArguments("A", "C").WithLocation(12, 10),
                // (13,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'C' and 'A'
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? y : x").WithArguments("C", "A").WithLocation(13, 10),
                // (17,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'B' and 'C'
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? x : y").WithArguments("B", "C").WithLocation(17, 10),
                // (18,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between 'C' and 'B'
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? y : x").WithArguments("C", "B").WithLocation(18, 10),
                // (17,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : y").WithLocation(17, 10),
                // (18,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? y : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? y : x").WithLocation(18, 10));
        }

        [Fact]
        public void ConditionalOperator_10()
        {
            var source =
@"using System;
class C
{
    static void F(bool b, object? x, object y)
    {
        (b ? x : throw new Exception()).ToString();
        (b ? y : throw new Exception()).ToString();
        (b ? throw new Exception() : x).ToString();
        (b ? throw new Exception() : y).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x : throw new Exception()).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x : throw new Exception()").WithLocation(6, 10),
                // (8,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? throw new Exception() : x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? throw new Exception() : x").WithLocation(8, 10));
        }

        [Fact]
        public void ConditionalOperator_11()
        {
            var source =
@"class C
{
    static void F(bool b, object x)
    {
        (b ? x : throw null).ToString();
        (b ? throw null : x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ConditionalOperator_12()
        {
            var source =
@"using System;
class C
{
    static void F(bool b)
    {
        (b ? throw new Exception() : throw new Exception()).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,10): error CS0173: Type of conditional expression cannot be determined because there is no implicit conversion between '<throw expression>' and '<throw expression>'
                //         (b ? throw new Exception() : throw new Exception()).ToString();
                Diagnostic(ErrorCode.ERR_InvalidQM, "b ? throw new Exception() : throw new Exception()").WithArguments("<throw expression>", "<throw expression>").WithLocation(6, 10));
        }

        [Fact]
        public void ConditionalOperator_13()
        {
            var source =
@"class C
{
    static bool F(object? x)
    {
        return true;
    }
    static void F1(bool c, bool b1, bool b2, object v1)
    {
        object x1;
        object y1;
        object? z1 = null;
        object? w1 = null;
        if (c ? b1 && F(x1 = v1) && F(z1 = v1) : b2 && F(y1 = v1) && F(w1 = v1))
        {
            x1.ToString(); // unassigned (if)
            y1.ToString(); // unassigned (if)
            z1.ToString(); // may be null (if)
            w1.ToString(); // may be null (if)
        }
        else
        {
            x1.ToString(); // unassigned (no error) (else)
            y1.ToString(); // unassigned (no error) (else)
            z1.ToString(); // may be null (else)
            w1.ToString(); // may be null (else)
        }
    }
    static void F2(bool b1, bool b2, object v2)
    {
        object x2;
        object y2;
        object? z2 = null;
        object? w2 = null;
        if (true ? b1 && F(x2 = v2) && F(z2 = v2) : b2 && F(y2 = v2) && F(w2 = v2))
        {
            x2.ToString(); // ok (if)
            y2.ToString(); // unassigned (if)
            z2.ToString(); // ok (if)
            w2.ToString(); // may be null (if)
        }
        else
        {
            x2.ToString(); // unassigned (else)
            y2.ToString(); // unassigned (no error) (else)
            z2.ToString(); // may be null (else)
            w2.ToString(); // may be null (else)
        }
    }
    static void F3(bool b1, bool b2, object v3)
    {
        object x3;
        object y3;
        object? z3 = null;
        object? w3 = null;
        if (false ? b1 && F(x3 = v3) && F(z3 = v3) : b2 && F(y3 = v3) && F(w3 = v3))
        {
            x3.ToString(); // unassigned (if)
            y3.ToString(); // ok (if)
            z3.ToString(); // may be null (if)
            w3.ToString(); // ok (if)
        }
        else
        {
            x3.ToString(); // unassigned (no error) (else)
            y3.ToString(); // unassigned (else)
            z3.ToString(); // may be null (else)
            w3.ToString(); // may be null (else)
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,13): error CS0165: Use of unassigned local variable 'x1'
                //             x1.ToString(); // unassigned (if)
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x1").WithArguments("x1").WithLocation(15, 13),
                // (16,13): error CS0165: Use of unassigned local variable 'y1'
                //             y1.ToString(); // unassigned (if)
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y1").WithArguments("y1").WithLocation(16, 13),
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //             z1.ToString(); // may be null (if)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z1").WithLocation(17, 13),
                // (18,13): warning CS8602: Possible dereference of a null reference.
                //             w1.ToString(); // may be null (if)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w1").WithLocation(18, 13),
                // (24,13): warning CS8602: Possible dereference of a null reference.
                //             z1.ToString(); // may be null (else)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z1").WithLocation(24, 13),
                // (25,13): warning CS8602: Possible dereference of a null reference.
                //             w1.ToString(); // may be null (else)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w1").WithLocation(25, 13),
                // (37,13): error CS0165: Use of unassigned local variable 'y2'
                //             y2.ToString(); // unassigned (if)
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y2").WithArguments("y2").WithLocation(37, 13),
                // (43,13): error CS0165: Use of unassigned local variable 'x2'
                //             x2.ToString(); // unassigned (else)
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x2").WithArguments("x2").WithLocation(43, 13),
                // (39,13): warning CS8602: Possible dereference of a null reference.
                //             w2.ToString(); // may be null (if)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w2").WithLocation(39, 13),
                // (45,13): warning CS8602: Possible dereference of a null reference.
                //             z2.ToString(); // may be null (else)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z2").WithLocation(45, 13),
                // (46,13): warning CS8602: Possible dereference of a null reference.
                //             w2.ToString(); // may be null (else)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w2").WithLocation(46, 13),
                // (57,13): error CS0165: Use of unassigned local variable 'x3'
                //             x3.ToString(); // unassigned (if)
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x3").WithArguments("x3").WithLocation(57, 13),
                // (65,13): error CS0165: Use of unassigned local variable 'y3'
                //             y3.ToString(); // unassigned (else)
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y3").WithArguments("y3").WithLocation(65, 13),
                // (59,13): warning CS8602: Possible dereference of a null reference.
                //             z3.ToString(); // may be null (if)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z3").WithLocation(59, 13),
                // (66,13): warning CS8602: Possible dereference of a null reference.
                //             z3.ToString(); // may be null (else)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z3").WithLocation(66, 13),
                // (67,13): warning CS8602: Possible dereference of a null reference.
                //             w3.ToString(); // may be null (else)
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w3").WithLocation(67, 13));
        }

        // https://github.com/dotnet/roslyn/issues/29869: Review /*T:...*/ and diagnostics.
        [Fact]
        public void ConditionalOperator_14()
        {
            var source =
@"interface I<T> { T P { get; } }
interface IIn<in T> { }
interface IOut<out T> { T P { get; } }
class C
{
    static void F1(bool b, ref string? x1, ref string y1)
    {
        (b ? ref x1 : ref x1)/*T:string?*/.ToString();
        (b ? ref x1 : ref y1)/*T:string?*/.ToString();
        (b ? ref y1 : ref x1)/*T:string?*/.ToString();
        (b ? ref y1 : ref y1)/*T:string!*/.ToString();
    }
    static void F2(bool b, ref I<string?> x2, ref I<string> y2)
    {
        (b ? ref x2 : ref x2)/*T:I<string?>!*/.P.ToString();
        (b ? ref y2 : ref x2)/*T:I<string!>!*/.P.ToString();
        (b ? ref x2 : ref y2)/*T:I<string!>!*/.P.ToString();
        (b ? ref y2 : ref y2)/*T:I<string!>!*/.P.ToString();
    }
    static void F3(bool b, ref IIn<string?> x3, ref IIn<string> y3)
    {
        (b ? ref x3 : ref x3)/*T:IIn<string?>!*/.ToString();
        (b ? ref y3 : ref x3)/*T:IIn<string!>!*/.ToString();
        (b ? ref x3 : ref y3)/*T:IIn<string!>!*/.ToString();
        (b ? ref y3 : ref y3)/*T:IIn<string!>!*/.ToString();
    }
    static void F4(bool b, ref IOut<string?> x4, ref IOut<string> y4)
    {
        (b ? ref x4 : ref x4)/*T:IOut<string?>!*/.P.ToString();
        (b ? ref y4 : ref x4)/*T:IOut<string?>!*/.P.ToString();
        (b ? ref x4 : ref y4)/*T:IOut<string?>!*/.P.ToString();
        (b ? ref y4 : ref y4)/*T:IOut<string!>!*/.P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (8,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref x1 : ref x1)/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? ref x1 : ref x1").WithLocation(8, 10),
                // (9,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref x1 : ref y1)/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? ref x1 : ref y1").WithLocation(9, 10),
                // (10,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref y1 : ref x1)/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? ref y1 : ref x1").WithLocation(10, 10),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref x2 : ref x2)/*T:I<string?>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(b ? ref x2 : ref x2)/*T:I<string?>!*/.P").WithLocation(15, 9),
                // (16,27): warning CS8619: Nullability of reference types in value of type 'I<string?>' doesn't match target type 'I<string>'.
                //         (b ? ref y2 : ref x2)/*T:I<string!>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("I<string?>", "I<string>").WithLocation(16, 27),
                // (17,18): warning CS8619: Nullability of reference types in value of type 'I<string?>' doesn't match target type 'I<string>'.
                //         (b ? ref x2 : ref y2)/*T:I<string!>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("I<string?>", "I<string>").WithLocation(17, 18),
                // (29,9): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref x4 : ref x4)/*T:IOut<string?>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(b ? ref x4 : ref x4)/*T:IOut<string?>!*/.P").WithLocation(29, 9),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref y4 : ref x4)/*T:IOut<string?>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(b ? ref y4 : ref x4)/*T:IOut<string?>!*/.P").WithLocation(30, 9),
                // (31,9): warning CS8602: Possible dereference of a null reference.
                //         (b ? ref x4 : ref y4)/*T:IOut<string?>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(b ? ref x4 : ref y4)/*T:IOut<string?>!*/.P").WithLocation(31, 9));
        }

        [Fact]
        public void ConditionalOperator_15()
        {
            var source =
@"class Program
{
    static void F(bool b)
    {
        var x = b ? new[] { x } : default;
        x[0].ToString(); // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,29): error CS0841: Cannot use local variable 'x' before it is declared
                //         var x = b ? new[] { x } : default;
                Diagnostic(ErrorCode.ERR_VariableUsedBeforeDeclaration, "x").WithArguments("x").WithLocation(5, 29),
                // (5,29): error CS0165: Use of unassigned local variable 'x'
                //         var x = b ? new[] { x } : default;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x").WithArguments("x").WithLocation(5, 29),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         x[0].ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 9));
        }

        [Fact]
        public void ConditionalOperator_TopLevelNullability()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static void F(bool b, object? x, object y)
    {
        var z = A.F/*T:object*/;
        object? o;
        o = (b ? x : x)/*T:object?*/;
        o = (b ? x : y)/*T:object?*/;
        o = (b ? x : z)/*T:object?*/;
        o = (b ? y : x)/*T:object?*/;
        o = (b ? y : y)/*T:object!*/;
        o = (b ? y : z)/*T:object*/;
        o = (b ? z : x)/*T:object?*/;
        o = (b ? z : y)/*T:object*/;
        o = (b ? z : z)/*T:object*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [WorkItem(27961, "https://github.com/dotnet/roslyn/issues/27961")]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        [Fact]
        public void ConditionalOperator_NestedNullability_Invariant()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T> { }
class C
{
    static B<T> CreateB<T>(T t)
    {
        throw null;
    }
    static void F(bool b, B<object?> x, B<object> y)
    {
        var z = CreateB(A.F)/*T:B<object>!*/;
        object o;
        o = (b ? x : x)/*T:B<object?>!*/;
        o = (b ? x : y)/*T:B<object!>!*/; // 1
        o = (b ? x : z)/*T:B<object?>!*/;
        o = (b ? y : x)/*T:B<object!>!*/; // 2
        o = (b ? y : y)/*T:B<object!>!*/;
        o = (b ? y : z)/*T:B<object!>!*/;
        o = (b ? z : x)/*T:B<object?>!*/;
        o = (b ? z : y)/*T:B<object!>!*/;
        o = (b ? z : z)/*T:B<object>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (13,18): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         o = (b ? x : y)/*T:B<object!>!*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(13, 18),
                // (15,22): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         o = (b ? y : x)/*T:B<object!>!*/; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(15, 22));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void ConditionalOperator_NestedNullability_Variant()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static I<T> CreateI<T>(T t) => throw null;
    static void F1(bool b, I<object> x, I<object?> y)
    {
        var z = CreateI(A.F)/*T:I<object>!*/;
        object o;
        o = (b ? x : x)/*T:I<object!>!*/;
        o = (b ? x : y)/*T:I<object!>!*/;
        o = (b ? x : z)/*T:I<object!>!*/;
        o = (b ? y : x)/*T:I<object!>!*/;
        o = (b ? y : y)/*T:I<object?>!*/;
        o = (b ? y : z)/*T:I<object?>!*/;
        o = (b ? z : x)/*T:I<object!>!*/;
        o = (b ? z : y)/*T:I<object?>!*/;
        o = (b ? z : z)/*T:I<object>!*/;
    }
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static void F2(bool b, IIn<object> x, IIn<object?> y)
    {
        var z = CreateIIn(A.F)/*T:IIn<object>!*/;
        object o;
        o = (b ? x : x)/*T:IIn<object!>!*/;
        o = (b ? x : y)/*T:IIn<object!>!*/;
        o = (b ? x : z)/*T:IIn<object!>!*/;
        o = (b ? y : x)/*T:IIn<object!>!*/;
        o = (b ? y : y)/*T:IIn<object?>!*/;
        o = (b ? y : z)/*T:IIn<object>!*/;
        o = (b ? z : x)/*T:IIn<object!>!*/;
        o = (b ? z : y)/*T:IIn<object>!*/;
        o = (b ? z : z)/*T:IIn<object>!*/;
    }
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void F3(bool b, IOut<object> x, IOut<object?> y)
    {
        var z = CreateIOut(A.F)/*T:IOut<object>!*/;
        object o;
        o = (b ? x : x)/*T:IOut<object!>!*/;
        o = (b ? x : y)/*T:IOut<object?>!*/;
        o = (b ? x : z)/*T:IOut<object>!*/;
        o = (b ? y : x)/*T:IOut<object?>!*/;
        o = (b ? y : y)/*T:IOut<object?>!*/;
        o = (b ? y : z)/*T:IOut<object?>!*/;
        o = (b ? z : x)/*T:IOut<object>!*/;
        o = (b ? z : y)/*T:IOut<object?>!*/;
        o = (b ? z : z)/*T:IOut<object>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (12,22): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         o = (b ? x : y)/*T:I<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(12, 22),
                // (14,18): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         o = (b ? y : x)/*T:I<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(14, 18)
);
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void ConditionalOperator_NestedNullability_VariantAndInvariant()
        {
            var source0 =
@"public class A
{
    public static object F1;
    public static string F2;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface IIn<in T, U> { }
interface IOut<T, out U> { }
class C
{
    static IIn<T, U> CreateIIn<T, U>(T t, U u) => throw null;
    static void F1(bool b, IIn<object, string> x1, IIn<object?, string?> y1)
    {
        var z1 = CreateIIn(A.F1, A.F2)/*T:IIn<object, string>!*/;
        object o;
        o = (b ? x1 : x1)/*T:IIn<object!, string!>!*/;
        o = (b ? x1 : y1)/*T:IIn<object!, string!>!*/;
        o = (b ? x1 : z1)/*T:IIn<object!, string!>!*/;
        o = (b ? y1 : x1)/*T:IIn<object!, string!>!*/;
        o = (b ? y1 : y1)/*T:IIn<object?, string?>!*/;
        o = (b ? y1 : z1)/*T:IIn<object, string?>!*/;
        o = (b ? z1 : x1)/*T:IIn<object!, string!>!*/;
        o = (b ? z1 : y1)/*T:IIn<object, string?>!*/;
        o = (b ? z1 : z1)/*T:IIn<object, string>!*/;
    }
    static IOut<T, U> CreateIOut<T, U>(T t, U u) => throw null;
    static void F2(bool b, IOut<object, string> x2, IOut<object?, string?> y2)
    {
        var z2 = CreateIOut(A.F1, A.F2)/*T:IOut<object, string>!*/;
        object o;
        o = (b ? x2 : x2)/*T:IOut<object!, string!>!*/;
        o = (b ? x2 : y2)/*T:IOut<object!, string?>!*/;
        o = (b ? x2 : z2)/*T:IOut<object!, string>!*/;
        o = (b ? y2 : x2)/*T:IOut<object!, string?>!*/;
        o = (b ? y2 : y2)/*T:IOut<object?, string?>!*/;
        o = (b ? y2 : z2)/*T:IOut<object?, string?>!*/;
        o = (b ? z2 : x2)/*T:IOut<object!, string>!*/;
        o = (b ? z2 : y2)/*T:IOut<object?, string?>!*/;
        o = (b ? z2 : z2)/*T:IOut<object, string>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,23): warning CS8619: Nullability of reference types in value of type 'IIn<object?, string?>' doesn't match target type 'IIn<object, string>'.
                //         o = (b ? x1 : y1)/*T:IIn<object!, string!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("IIn<object?, string?>", "IIn<object, string>").WithLocation(11, 23),
                // (13,18): warning CS8619: Nullability of reference types in value of type 'IIn<object?, string?>' doesn't match target type 'IIn<object, string>'.
                //         o = (b ? y1 : x1)/*T:IIn<object!, string!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("IIn<object?, string?>", "IIn<object, string>").WithLocation(13, 18),
                // (26,23): warning CS8619: Nullability of reference types in value of type 'IOut<object?, string?>' doesn't match target type 'IOut<object, string?>'.
                //         o = (b ? x2 : y2)/*T:IOut<object!, string?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y2").WithArguments("IOut<object?, string?>", "IOut<object, string?>").WithLocation(26, 23),
                // (28,18): warning CS8619: Nullability of reference types in value of type 'IOut<object?, string?>' doesn't match target type 'IOut<object, string?>'.
                //         o = (b ? y2 : x2)/*T:IOut<object!, string?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y2").WithArguments("IOut<object?, string?>", "IOut<object, string?>").WithLocation(28, 18)
                );
            comp.VerifyTypes();
        }

        [Fact]
        public void ConditionalOperator_NestedNullability_Tuples()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
class C
{
    static void F1(bool b, object x1, object? y1)
    {
        var z1 = A.F/*T:object*/;
        object o;
        o = (b ? (x1, x1) : (x1, y1))/*T:(object!, object?)*/;
        o = (b ? (z1, x1) : (x1, x1))/*T:(object, object!)*/;
        o = (b ? (y1, y1) : (y1, z1))/*T:(object?, object?)*/;
        o = (b ? (x1, y1) : (y1, y1))/*T:(object?, object?)*/;
        o = (b ? (z1, z1) : (z1, x1))/*T:(object, object)*/;
        o = (b ? (y1, z1) : (z1, z1))/*T:(object?, object)*/;
    }
    static I<T> CreateI<T>(T t) => throw null;
    static void F2(bool b, I<object> x2, I<object?> y2)
    {
        var z2 = CreateI(A.F)/*T:I<object>!*/;
        object o;
        o = (b ? (x2, x2) : (x2, y2))/*T:(I<object!>!, I<object!>!)*/;
        o = (b ? (z2, x2) : (x2, x2))/*T:(I<object!>!, I<object!>!)*/;
        o = (b ? (y2, y2) : (y2, z2))/*T:(I<object?>!, I<object?>!)*/;
        o = (b ? (x2, y2) : (y2, y2))/*T:(I<object!>!, I<object?>!)*/;
        o = (b ? (z2, z2) : (z2, x2))/*T:(I<object>!, I<object!>!)*/;
        o = (b ? (y2, z2) : (z2, z2))/*T:(I<object?>!, I<object>!)*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (20,29): warning CS8619: Nullability of reference types in value of type '(I<object> x2, I<object?> y2)' doesn't match target type '(I<object>, I<object>)'.
                //         o = (b ? (x2, x2) : (x2, y2))/*T:(I<object!>!, I<object!>!)*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x2, y2)").WithArguments("(I<object> x2, I<object?> y2)", "(I<object>, I<object>)").WithLocation(20, 29),
                // (23,29): warning CS8619: Nullability of reference types in value of type '(I<object?>, I<object?>)' doesn't match target type '(I<object>, I<object?>)'.
                //         o = (b ? (x2, y2) : (y2, y2))/*T:(I<object!>!, I<object?>!)*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(y2, y2)").WithArguments("(I<object?>, I<object?>)", "(I<object>, I<object?>)").WithLocation(23, 29));
            comp.VerifyTypes();
        }

        [WorkItem(30432, "https://github.com/dotnet/roslyn/issues/30432")]
        [Fact]
        public void ConditionalOperator_TopLevelNullability_Ref()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static void F(bool b, object? x, object y)
    {
        var z = A.F/*T:object*/;
        ref var xx = ref b ? ref x : ref x;
        ref var xy = ref b ? ref x : ref y;
        ref var xz = ref b ? ref x : ref z;
        ref var yx = ref b ? ref y : ref x;
        ref var yy = ref b ? ref y : ref y;
        ref var yz = ref b ? ref y : ref z;
        ref var zx = ref b ? ref z : ref x;
        ref var zy = ref b ? ref z : ref y;
        ref var zz = ref b ? ref z : ref z;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/30432: Report warnings for combinations of `object?` and `object!`.
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [WorkItem(30432, "https://github.com/dotnet/roslyn/issues/30432")]
        [Fact]
        public void ConditionalOperator_NestedNullability_Ref()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static I<T> CreateI<T>(T t) => throw null;
    static void F1(bool b, I<object> x1, I<object?> y1)
    {
        var z1 = CreateI(A.F)/*T:I<object>!*/;
        ref var xx = ref b ? ref x1 : ref x1;
        ref var xy = ref b ? ref x1 : ref y1;
        ref var xz = ref b ? ref x1 : ref z1;
        ref var yx = ref b ? ref y1 : ref x1;
        ref var yy = ref b ? ref y1 : ref y1;
        ref var yz = ref b ? ref y1 : ref z1;
        ref var zx = ref b ? ref z1 : ref x1;
        ref var zy = ref b ? ref z1 : ref y1;
        ref var zz = ref b ? ref z1 : ref z1;
    }
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static void F2(bool b, IIn<object> x2, IIn<object?> y2)
    {
        var z2 = CreateIIn(A.F)/*T:IIn<object>!*/;
        ref var xx = ref b ? ref x2 : ref x2;
        ref var xy = ref b ? ref x2 : ref y2;
        ref var xz = ref b ? ref x2 : ref z2;
        ref var yx = ref b ? ref y2 : ref x2;
        ref var yy = ref b ? ref y2 : ref y2;
        ref var yz = ref b ? ref y2 : ref z2;
        ref var zx = ref b ? ref z2 : ref x2;
        ref var zy = ref b ? ref z2 : ref y2;
        ref var zz = ref b ? ref z2 : ref z2;
    }
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void F3(bool b, IOut<object> x3, IOut<object?> y3)
    {
        var z3 = CreateIOut(A.F)/*T:IOut<object>!*/;
        ref var xx = ref b ? ref x3 : ref x3;
        ref var xy = ref b ? ref x3 : ref y3;
        ref var xz = ref b ? ref x3 : ref z3;
        ref var yx = ref b ? ref y3 : ref x3;
        ref var yy = ref b ? ref y3 : ref y3;
        ref var yz = ref b ? ref y3 : ref z3;
        ref var zx = ref b ? ref z3 : ref x3;
        ref var zy = ref b ? ref z3 : ref y3;
        ref var zz = ref b ? ref z3 : ref z3;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/30432: Report warnings for combinations of `IIn<object?>` and `IIn<object!>`
            // and combinations of  `IOut<object?>` and `IOut<object!>`.
            comp.VerifyDiagnostics(
                // (11,43): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         ref var xy = ref b ? ref x1 : ref y1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("I<object?>", "I<object>").WithLocation(11, 43),
                // (13,34): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         ref var yx = ref b ? ref y1 : ref x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("I<object?>", "I<object>").WithLocation(13, 34));
            comp.VerifyTypes();
        }

        [Fact]
        public void IdentityConversion_ConditionalOperator()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(bool c, I<object> x, I<object?> y)
    {
        I<object> a;
        a = c ? x : y;
        a = false ? x : y;
        a = true ? x : y; // ok
        I<object?> b;
        b = c ? x : y;
        b = false ? x : y;
        b = true ? x : y;
    }
    static void F(bool c, IIn<object> x, IIn<object?> y)
    {
        IIn<object> a;
        a = c ? x : y;
        a = false ? x : y;
        a = true ? x : y;
        IIn<object?> b;
        b = c ? x : y;
        b = false ? x : y;
        b = true ? x : y;
    }
    static void F(bool c, IOut<object> x, IOut<object?> y)
    {
        IOut<object> a;
        a = c ? x : y;
        a = false ? x : y;
        a = true ? x : y;
        IOut<object?> b;
        b = c ? x : y;
        b = false ? x : y;
        b = true ? x : y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,21): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         a = c ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(9, 21),
                // (10,25): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         a = false ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(10, 25),
                // (13,13): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         b = c ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c ? x : y").WithArguments("I<object>", "I<object?>").WithLocation(13, 13),
                // (13,21): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         b = c ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(13, 21),
                // (14,13): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         b = false ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "false ? x : y").WithArguments("I<object>", "I<object?>").WithLocation(14, 13),
                // (14,25): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         b = false ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(14, 25),
                // (15,13): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         b = true ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "true ? x : y").WithArguments("I<object>", "I<object?>").WithLocation(15, 13),
                // (24,13): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         b = c ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c ? x : y").WithArguments("IIn<object>", "IIn<object?>").WithLocation(24, 13),
                // (25,13): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         b = false ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "false ? x : y").WithArguments("IIn<object>", "IIn<object?>").WithLocation(25, 13),
                // (26,13): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         b = true ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "true ? x : y").WithArguments("IIn<object>", "IIn<object?>").WithLocation(26, 13),
                // (31,13): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         a = c ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c ? x : y").WithArguments("IOut<object?>", "IOut<object>").WithLocation(31, 13),
                // (32,13): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         a = false ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "false ? x : y").WithArguments("IOut<object?>", "IOut<object>").WithLocation(32, 13),
                // (33,13): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         a = true ? x : y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "true ? x : y").WithArguments("IOut<object?>", "IOut<object>").WithLocation(33, 13));
        }

        [Fact]
        public void NullCoalescingOperator_01()
        {
            var source =
@"class C
{
    static void F(object? x, object? y)
    {
        var z = x ?? y;
        z.ToString();
        if (y == null) return;
        var w = x ?? y;
        w.ToString();
        var v = null ?? x;
        v.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(6, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         v.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "v").WithLocation(11, 9));
        }

        [Fact]
        public void NullCoalescingOperator_02()
        {
            var source =
@"class C
{
    static void F(object? x, object? y)
    {
        (x ?? y).ToString();
        if (y != null) (x ?? y).ToString();
        if (y != null) (y ?? x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (x ?? y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x ?? y").WithLocation(5, 10),
                // (7,25): hidden CS8607: Expression is probably never null.
                //         if (y != null) (y ?? x).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(7, 25));
        }

        [Fact]
        public void NullCoalescingOperator_03()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        (null ?? null).ToString();
        (null ?? x).ToString();
        (null ?? y).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): error CS0019: Operator '??' cannot be applied to operands of type '<null>' and '<null>'
                //         (null ?? null).ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "null ?? null").WithArguments("??", "<null>", "<null>").WithLocation(5, 10),
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (null ?? null).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "null ?? null").WithLocation(5, 10),
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         (null ?? y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "null ?? y").WithLocation(7, 10));
        }

        [Fact]
        public void NullCoalescingOperator_04()
        {
            var source =
@"class C
{
    static void F(string x, string? y)
    {
        ("""" ?? x).ToString();
        ("""" ?? y).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): hidden CS8607: Expression is probably never null.
                //         ("" ?? x).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, @"""""").WithLocation(5, 10),
                // (6,10): hidden CS8607: Expression is probably never null.
                //         ("" ?? y).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, @"""""").WithLocation(6, 10));
        }

        [Fact]
        public void NullCoalescingOperator_05()
        {
            var source0 =
@"public class A { }
public class B { }
public class UnknownNull
{
    public A A;
    public B B;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source1 =
@"public class MaybeNull
{
    public A? A;
    public B? B;
}
public class NotNull
{
    public A A = new A();
    public B B = new B();
}";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp1.VerifyDiagnostics();
            var ref1 = comp1.EmitToImageReference();

            var source =
@"class C
{
    static void F1(UnknownNull x1, UnknownNull y1)
    {
        (x1.A ?? y1.B)/*T:*/.ToString();
    }
    static void F2(UnknownNull x2, MaybeNull y2)
    {
        (x2.A ?? y2.B)/*T:?*/.ToString();
    }
    static void F3(MaybeNull x3, UnknownNull y3)
    {
        (x3.A ?? y3.B)/*T:*/.ToString();
    }
    static void F4(MaybeNull x4, MaybeNull y4)
    {
        (x4.A ?? y4.B)/*T:?*/.ToString();
    }
    static void F5(UnknownNull x5, NotNull y5)
    {
        (x5.A ?? y5.B)/*T:!*/.ToString();
    }
    static void F6(NotNull x6, UnknownNull y6)
    {
        (x6.A ?? y6.B)/*T:!*/.ToString();
    }
    static void F7(MaybeNull x7, NotNull y7)
    {
        (x7.A ?? y7.B)/*T:!*/.ToString();
    }
    static void F8(NotNull x8, MaybeNull y8)
    {
        (x8.A ?? y8.B)/*T:!*/.ToString();
    }
    static void F9(NotNull x9, NotNull y9)
    {
        (x9.A ?? y9.B)/*T:!*/.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0, ref1 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (5,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x1.A ?? y1.B)/*T:*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x1.A ?? y1.B").WithArguments("??", "A", "B").WithLocation(5, 10),
                // (9,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x2.A ?? y2.B)/*T:?*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x2.A ?? y2.B").WithArguments("??", "A", "B").WithLocation(9, 10),
                // (9,10): warning CS8602: Possible dereference of a null reference.
                //         (x2.A ?? y2.B)/*T:?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2.A ?? y2.B").WithLocation(9, 10),
                // (13,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x3.A ?? y3.B)/*T:*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x3.A ?? y3.B").WithArguments("??", "A", "B").WithLocation(13, 10),
                // (17,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x4.A ?? y4.B)/*T:?*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x4.A ?? y4.B").WithArguments("??", "A", "B").WithLocation(17, 10),
                // (17,10): warning CS8602: Possible dereference of a null reference.
                //         (x4.A ?? y4.B)/*T:?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x4.A ?? y4.B").WithLocation(17, 10),
                // (21,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x5.A ?? y5.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x5.A ?? y5.B").WithArguments("??", "A", "B").WithLocation(21, 10),
                // (25,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x6.A ?? y6.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x6.A ?? y6.B").WithArguments("??", "A", "B").WithLocation(25, 10),
                // (25,10): hidden CS8607: Expression is probably never null.
                //         (x6.A ?? y6.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x6.A").WithLocation(25, 10),
                // (29,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x7.A ?? y7.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x7.A ?? y7.B").WithArguments("??", "A", "B").WithLocation(29, 10),
                // (33,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x8.A ?? y8.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x8.A ?? y8.B").WithArguments("??", "A", "B").WithLocation(33, 10),
                // (33,10): hidden CS8607: Expression is probably never null.
                //         (x8.A ?? y8.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x8.A").WithLocation(33, 10),
                // (37,10): error CS0019: Operator '??' cannot be applied to operands of type 'A' and 'B'
                //         (x9.A ?? y9.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x9.A ?? y9.B").WithArguments("??", "A", "B").WithLocation(37, 10),
                // (37,10): hidden CS8607: Expression is probably never null.
                //         (x9.A ?? y9.B)/*T:!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x9.A").WithLocation(37, 10));
        }

        [Fact]
        public void NullCoalescingOperator_06()
        {
            var source =
@"class C
{
    static void F1(C x1, Unknown? y1)
    {
        (x1 ?? y1)/*T:!*/.ToString();
        (y1 ?? x1)/*T:!*/.ToString();
        (null ?? y1)/*T:Unknown?*/.ToString();
        (y1 ?? null)/*T:Unknown?*/.ToString();
    }
    static void F2(C? x2, Unknown y2)
    {
        (x2 ?? y2)/*T:!*/.ToString();
        (y2 ?? x2)/*T:!*/.ToString();
        (null ?? y2)/*T:!*/.ToString();
        (y2 ?? null)/*T:!*/.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            // Note: Unknown type is treated as a value type
            comp.VerifyDiagnostics(
                // (3,26): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F1(C x1, Unknown? y1)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(3, 26),
                // (10,27): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F2(C? x2, Unknown y2)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(10, 27),
                // (5,10): error CS0019: Operator '??' cannot be applied to operands of type 'C' and 'Unknown?'
                //         (x1 ?? y1)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "x1 ?? y1").WithArguments("??", "C", "Unknown?").WithLocation(5, 10),
                // (6,10): error CS0019: Operator '??' cannot be applied to operands of type 'Unknown?' and 'C'
                //         (y1 ?? x1)/*T:!*/.ToString();
                Diagnostic(ErrorCode.ERR_BadBinaryOps, "y1 ?? x1").WithArguments("??", "Unknown?", "C").WithLocation(6, 10),
                // (5,10): hidden CS8607: Expression is probably never null.
                //         (x1 ?? y1)/*T:!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(5, 10),
                // (8,10): warning CS8602: Possible dereference of a null reference.
                //         (y1 ?? null)/*T:Unknown?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y1 ?? null").WithLocation(8, 10),
                // (13,10): hidden CS8607: Expression is probably never null.
                //         (y2 ?? x2)/*T:!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y2").WithLocation(13, 10),
                // (15,10): hidden CS8607: Expression is probably never null.
                //         (y2 ?? null)/*T:!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y2").WithLocation(15, 10));
        }

        [Fact]
        public void NullCoalescingOperator_07()
        {
            var source =
@"class C
{
    static void F(object? o, object[]? a, object?[]? b)
    {
        if (o == null)
        {
            var c = new[] { o };
            (a ?? c)[0].ToString();
            (b ?? c)[0].ToString();
        }
        else
        {
            var c = new[] { o };
            (a ?? c)[0].ToString();
            (b ?? c)[0].ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             (a ?? c)[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(a ?? c)[0]").WithLocation(8, 13),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             (b ?? c)[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(b ?? c)[0]").WithLocation(9, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             (b ?? c)[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(b ?? c)[0]").WithLocation(15, 13));
        }

        [Fact]
        public void NullCoalescingOperator_08()
        {
            var source =
@"interface I<T> { }
class C
{
    static object? F((I<object>, I<object?>)? x, (I<object?>, I<object>)? y)
    {
        return x ?? y;
    }
    static object F((I<object>, I<object?>)? x, (I<object?>, I<object>) y)
    {
        return x ?? y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,21): warning CS8619: Nullability of reference types in value of type '(I<object?>, I<object>)?' doesn't match target type '(I<object>, I<object?>)?'.
                //         return x ?? y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("(I<object?>, I<object>)?", "(I<object>, I<object?>)?").WithLocation(6, 21),
                // (10,21): warning CS8619: Nullability of reference types in value of type '(I<object?>, I<object>)' doesn't match target type '(I<object>, I<object?>)'.
                //         return x ?? y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("(I<object?>, I<object>)", "(I<object>, I<object?>)").WithLocation(10, 21));
        }

        [Fact]
        public void IdentityConversion_NullCoalescingOperator_01()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F1(I<object>? x1, I<object?> y1)
    {
        I<object> z1 = x1 ?? y1;
        I<object?> w1 = y1 ?? x1;
    }
    static void F2(IIn<object>? x2, IIn<object?> y2)
    {
        IIn<object> z2 = x2 ?? y2;
        IIn<object?> w2 = y2 ?? x2;
    }
    static void F3(IOut<object>? x3, IOut<object?> y3)
    {
        IOut<object> z3 = x3 ?? y3;
        IOut<object?> w3 = y3 ?? x3;
    }
    static void F4(IIn<object>? x4, IIn<object> y4)
    {
        IIn<object> z4;
        z4 = ((IIn<object?>)x4) ?? y4;
        z4 = x4 ?? (IIn<object?>)y4;
    }
    static void F5(IIn<object?>? x5, IIn<object?> y5)
    {
        IIn<object> z5;
        z5 = ((IIn<object>)x5) ?? y5;
        z5 = x5 ?? (IIn<object>)y5;
    }
    static void F6(IOut<object?>? x6, IOut<object?> y6)
    {
        IOut<object?> z6;
        z6 = ((IOut<object>)x6) ?? y6;
        z6 = x6 ?? (IOut<object>)y6;
    }
    static void F7(IOut<object>? x7, IOut<object> y7)
    {
        IOut<object?> z7;
        z7 = ((IOut<object?>)x7) ?? y7;
        z7 = x7 ?? (IOut<object?>)y7;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,30): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         I<object> z1 = x1 ?? y1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("I<object?>", "I<object>").WithLocation(8, 30),
                // (9,25): hidden CS8607: Expression is probably never null.
                //         I<object?> w1 = y1 ?? x1;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y1").WithLocation(9, 25),
                // (9,31): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         I<object?> w1 = y1 ?? x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("I<object>", "I<object?>").WithLocation(9, 31),
                // (14,27): hidden CS8607: Expression is probably never null.
                //         IIn<object?> w2 = y2 ?? x2;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y2").WithLocation(14, 27),
                // (14,27): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         IIn<object?> w2 = y2 ?? x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y2 ?? x2").WithArguments("IIn<object>", "IIn<object?>").WithLocation(14, 27),
                // (18,27): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         IOut<object> z3 = x3 ?? y3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3 ?? y3").WithArguments("IOut<object?>", "IOut<object>").WithLocation(18, 27),
                // (19,28): hidden CS8607: Expression is probably never null.
                //         IOut<object?> w3 = y3 ?? x3;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y3").WithLocation(19, 28),
                // (24,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z4 = ((IIn<object?>)x4) ?? y4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IIn<object?>)x4").WithLocation(24, 15),
                // (30,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z5 = ((IIn<object>)x5) ?? y5;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IIn<object>)x5").WithLocation(30, 15),
                // (36,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z6 = ((IOut<object>)x6) ?? y6;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IOut<object>)x6").WithLocation(36, 15),
                // (42,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z7 = ((IOut<object?>)x7) ?? y7;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IOut<object?>)x7").WithLocation(42, 15));
        }

        [Fact]
        public void IdentityConversion_NullCoalescingOperator_02()
        {
            var source =
@"interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static IIn<T>? FIn<T>(T x)
    {
        return null;
    }
    static IOut<T>? FOut<T>(T x)
    {
        return null;
    }
    static void FIn(IIn<object?>? x)
    {
    }
    static T FOut<T>(IOut<T>? x)
    {
        throw new System.Exception();
    }
    static void F1(IIn<object>? x1, IIn<object?>? y1)
    {
        FIn((x1 ?? y1)/*T:IIn<object!>?*/);
        FIn((y1 ?? x1)/*T:IIn<object!>?*/);
    }
    static void F2(IOut<object>? x2, IOut<object?>? y2)
    {
        FOut((x2 ?? y2)/*T:IOut<object?>?*/).ToString();
        FOut((y2 ?? x2)/*T:IOut<object?>?*/).ToString();
    }
    static void F3(object? x3, object? y3)
    {
        FIn((FIn(x3) ?? FIn(y3))/*T:IIn<object?>?*/); // A
        if (x3 == null) return;
        FIn((FIn(x3) ?? FIn(y3))/*T:IIn<object!>?*/); // B
        FIn((FIn(y3) ?? FIn(x3))/*T:IIn<object!>?*/); // C
        if (y3 == null) return;
        FIn((FIn(x3) ?? FIn(y3))/*T:IIn<object!>?*/); // D
    }
    static void F4(object? x4, object? y4)
    {
        FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object?>?*/).ToString(); // A
        if (x4 == null) return;
        FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object?>?*/).ToString(); // B
        FOut((FOut(y4) ?? FOut(x4))/*T:IOut<object?>?*/).ToString(); // C
        if (y4 == null) return;
        FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object!>?*/).ToString(); // D
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (22,14): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'x' in 'void C.FIn(IIn<object?>? x)'.
                //         FIn((x1 ?? y1)/*T:IIn<object!>?*/);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x1 ?? y1").WithArguments("IIn<object>", "IIn<object?>", "x", "void C.FIn(IIn<object?>? x)").WithLocation(22, 14),
                // (23,14): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'x' in 'void C.FIn(IIn<object?>? x)'.
                //         FIn((y1 ?? x1)/*T:IIn<object!>?*/);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1 ?? x1").WithArguments("IIn<object>", "IIn<object?>", "x", "void C.FIn(IIn<object?>? x)").WithLocation(23, 14),
                // (27,9): warning CS8602: Possible dereference of a null reference.
                //         FOut((x2 ?? y2)/*T:IOut<object?>?*/).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "FOut((x2 ?? y2)/*T:IOut<object?>?*/)").WithLocation(27, 9),
                // (28,9): warning CS8602: Possible dereference of a null reference.
                //         FOut((y2 ?? x2)/*T:IOut<object?>?*/).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "FOut((y2 ?? x2)/*T:IOut<object?>?*/)").WithLocation(28, 9),
                // (34,14): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'x' in 'void C.FIn(IIn<object?>? x)'.
                //         FIn((FIn(x3) ?? FIn(y3))/*T:IIn<object!>?*/); // B
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "FIn(x3) ?? FIn(y3)").WithArguments("IIn<object>", "IIn<object?>", "x", "void C.FIn(IIn<object?>? x)").WithLocation(34, 14),
                // (35,14): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'x' in 'void C.FIn(IIn<object?>? x)'.
                //         FIn((FIn(y3) ?? FIn(x3))/*T:IIn<object!>?*/); // C
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "FIn(y3) ?? FIn(x3)").WithArguments("IIn<object>", "IIn<object?>", "x", "void C.FIn(IIn<object?>? x)").WithLocation(35, 14),
                // (37,14): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'x' in 'void C.FIn(IIn<object?>? x)'.
                //         FIn((FIn(x3) ?? FIn(y3))/*T:IIn<object!>?*/); // D
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "FIn(x3) ?? FIn(y3)").WithArguments("IIn<object>", "IIn<object?>", "x", "void C.FIn(IIn<object?>? x)").WithLocation(37, 14),
                // (41,9): warning CS8602: Possible dereference of a null reference.
                //         FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object?>?*/).ToString(); // A
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object?>?*/)").WithLocation(41, 9),
                // (43,9): warning CS8602: Possible dereference of a null reference.
                //         FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object?>?*/).ToString(); // B
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "FOut((FOut(x4) ?? FOut(y4))/*T:IOut<object?>?*/)").WithLocation(43, 9),
                // (44,9): warning CS8602: Possible dereference of a null reference.
                //         FOut((FOut(y4) ?? FOut(x4))/*T:IOut<object?>?*/).ToString(); // C
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "FOut((FOut(y4) ?? FOut(x4))/*T:IOut<object?>?*/)").WithLocation(44, 9));
        }

        [Fact]
        public void IdentityConversion_NullCoalescingOperator_03()
        {
            var source =
@"class C
{
    static void F((object?, object?)? x, (object, object) y)
    {
        (x ?? y).Item1.ToString();
    }
    static void G((object, object)? x, (object?, object?) y)
    {
        (x ?? y).Item1.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         (x ?? y).Item1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(x ?? y).Item1").WithLocation(5, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         (x ?? y).Item1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(x ?? y).Item1").WithLocation(9, 9));
        }

        [Fact]
        public void IdentityConversion_NullCoalescingOperator_04()
        {
            var source =
@"#pragma warning disable 0649
struct A<T>
{
    public static implicit operator B<T>(A<T> a) => default;
}
struct B<T>
{
    internal T F;
}
class C
{
    static void F1(A<object>? x1, B<object?> y1)
    {
        (x1 ?? y1)/*T:B<object?>*/.F.ToString();
    }
    static void F2(A<object?>? x2, B<object> y2)
    {
        (x2 ?? y2)/*T:B<object!>*/.F.ToString();
    }
    static void F3(A<object> x3, B<object?>? y3)
    {
        (y3 ?? x3)/*T:B<object?>*/.F.ToString();
    }
    static void F4(A<object?> x4, B<object>? y4)
    {
        (y4 ?? x4)/*T:B<object!>*/.F.ToString();
    }
    static void F5(A<object>? x5, B<object?>? y5)
    {
        (x5 ?? y5)/*T:B<object?>?*/.Value.F.ToString();
        (y5 ?? x5)/*T:B<object?>?*/.Value.F.ToString();
    }
    static void F6(A<object?>? x6, B<object>? y6)
    {
        (x6 ?? y6)/*T:B<object!>?*/.Value.F.ToString();
        (y6 ?? x6)/*T:B<object!>?*/.Value.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (14,10): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'B<object?>'.
                //         (x1 ?? y1)/*T:B<object?>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("A<object>", "B<object?>").WithLocation(14, 10),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         (x1 ?? y1)/*T:B<object?>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(x1 ?? y1)/*T:B<object?>*/.F").WithLocation(14, 9),
                // (18,10): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'B<object>'.
                //         (x2 ?? y2)/*T:B<object!>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("A<object?>", "B<object>").WithLocation(18, 10),
                // (22,16): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'B<object?>'.
                //         (y3 ?? x3)/*T:B<object?>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3").WithArguments("B<object>", "B<object?>").WithLocation(22, 16),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         (y3 ?? x3)/*T:B<object?>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(y3 ?? x3)/*T:B<object?>*/.F").WithLocation(22, 9),
                // (26,16): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         (y4 ?? x4)/*T:B<object!>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x4").WithArguments("B<object?>", "B<object>").WithLocation(26, 16),
                // (30,10): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'B<object?>?'.
                //         (x5 ?? y5)/*T:B<object?>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x5").WithArguments("A<object>", "B<object?>?").WithLocation(30, 10),
                // (30,9): warning CS8629: Nullable value type may be null.
                //         (x5 ?? y5)/*T:B<object?>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(x5 ?? y5)/*T:B<object?>?*/.Value").WithLocation(30, 9),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         (x5 ?? y5)/*T:B<object?>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(x5 ?? y5)/*T:B<object?>?*/.Value.F").WithLocation(30, 9),
                // (31,16): warning CS8619: Nullability of reference types in value of type 'B<object>?' doesn't match target type 'B<object?>?'.
                //         (y5 ?? x5)/*T:B<object?>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x5").WithArguments("B<object>?", "B<object?>?").WithLocation(31, 16),
                // (31,9): warning CS8629: Nullable value type may be null.
                //         (y5 ?? x5)/*T:B<object?>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(y5 ?? x5)/*T:B<object?>?*/.Value").WithLocation(31, 9),
                // (31,9): warning CS8602: Possible dereference of a null reference.
                //         (y5 ?? x5)/*T:B<object?>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(y5 ?? x5)/*T:B<object?>?*/.Value.F").WithLocation(31, 9),
                // (35,10): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'B<object>?'.
                //         (x6 ?? y6)/*T:B<object!>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x6").WithArguments("A<object?>", "B<object>?").WithLocation(35, 10),
                // (35,9): warning CS8629: Nullable value type may be null.
                //         (x6 ?? y6)/*T:B<object!>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(x6 ?? y6)/*T:B<object!>?*/.Value").WithLocation(35, 9),
                // (36,16): warning CS8619: Nullability of reference types in value of type 'B<object?>?' doesn't match target type 'B<object>?'.
                //         (y6 ?? x6)/*T:B<object!>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x6").WithArguments("B<object?>?", "B<object>?").WithLocation(36, 16),
                // (36,9): warning CS8629: Nullable value type may be null.
                //         (y6 ?? x6)/*T:B<object!>?*/.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(y6 ?? x6)/*T:B<object!>?*/.Value").WithLocation(36, 9));
        }

        [Fact]
        [WorkItem(29871, "https://github.com/dotnet/roslyn/issues/29871")]
        public void IdentityConversion_NullCoalescingOperator_05()
        {
            var source =
@"#pragma warning disable 0649
struct A<T>
{
    public static implicit operator B<T>(A<T> a) => new B<T>();
}
class B<T>
{
    internal T F;
}
class C
{
    static void F1(A<object>? x1, B<object?> y1)
    {
        (x1 ?? y1)/*T:B<object?>!*/.F.ToString();
    }
    static void F2(A<object?>? x2, B<object> y2)
    {
        (x2 ?? y2)/*T:B<object!>!*/.F.ToString();
    }
    static void F3(A<object> x3, B<object?>? y3)
    {
        (y3 ?? x3)/*T:B<object?>!*/.F.ToString();
    }
    static void F4(A<object?> x4, B<object>? y4)
    {
        (y4 ?? x4)/*T:B<object!>!*/.F.ToString();
    }
    static void F5(A<object>? x5, B<object?>? y5)
    {
        (x5 ?? y5)/*T:B<object?>?*/.F.ToString();
        (y5 ?? x5)/*T:B<object?>?*/.F.ToString();
    }
    static void F6(A<object?>? x6, B<object>? y6)
    {
        (x6 ?? y6)/*T:B<object!>?*/.F.ToString();
        (y6 ?? x6)/*T:B<object!>?*/.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (6,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class B<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "B").WithArguments("field", "F").WithLocation(6, 7),
                // (14,10): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'B<object?>'.
                //         (x1 ?? y1)/*T:B<object?>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("A<object>", "B<object?>").WithLocation(14, 10),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         (x1 ?? y1)/*T:B<object?>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(x1 ?? y1)/*T:B<object?>!*/.F").WithLocation(14, 9),
                // (18,10): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'B<object>'.
                //         (x2 ?? y2)/*T:B<object!>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("A<object?>", "B<object>").WithLocation(18, 10),
                // (22,16): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'B<object?>'.
                //         (y3 ?? x3)/*T:B<object?>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3").WithArguments("B<object>", "B<object?>").WithLocation(22, 16),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         (y3 ?? x3)/*T:B<object?>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(y3 ?? x3)/*T:B<object?>!*/.F").WithLocation(22, 9),
                // (26,16): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         (y4 ?? x4)/*T:B<object!>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x4").WithArguments("B<object?>", "B<object>").WithLocation(26, 16),
                // (30,10): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'B<object?>'.
                //         (x5 ?? y5)/*T:B<object?>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x5").WithArguments("A<object>", "B<object?>").WithLocation(30, 10),
                // (30,10): warning CS8602: Possible dereference of a null reference.
                //         (x5 ?? y5)/*T:B<object?>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x5 ?? y5").WithLocation(30, 10),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         (x5 ?? y5)/*T:B<object?>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(x5 ?? y5)/*T:B<object?>?*/.F").WithLocation(30, 9),
                // (31,16): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'B<object?>'.
                //         (y5 ?? x5)/*T:B<object?>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x5").WithArguments("B<object>", "B<object?>").WithLocation(31, 16),
                // (31,10): warning CS8602: Possible dereference of a null reference.
                //         (y5 ?? x5)/*T:B<object?>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y5 ?? x5").WithLocation(31, 10),
                // (31,9): warning CS8602: Possible dereference of a null reference.
                //         (y5 ?? x5)/*T:B<object?>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(y5 ?? x5)/*T:B<object?>?*/.F").WithLocation(31, 9),
                // (35,10): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'B<object>'.
                //         (x6 ?? y6)/*T:B<object!>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x6").WithArguments("A<object?>", "B<object>").WithLocation(35, 10),
                // (35,10): warning CS8602: Possible dereference of a null reference.
                //         (x6 ?? y6)/*T:B<object!>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x6 ?? y6").WithLocation(35, 10),
                // (36,16): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         (y6 ?? x6)/*T:B<object!>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x6").WithArguments("B<object?>", "B<object>").WithLocation(36, 16),
                // (36,10): warning CS8602: Possible dereference of a null reference.
                //         (y6 ?? x6)/*T:B<object!>?*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y6 ?? x6").WithLocation(36, 10));
        }

        [Fact]
        public void IdentityConversion_NullCoalescingOperator_06()
        {
            var source =
@"class C
{
    static void F1(object? x, dynamic? y, dynamic z)
    {
        (x ?? y).ToString();
        (x ?? z).ToString(); // ok
        (y ?? x).ToString();
        (y ?? z).ToString(); // ok
        (z ?? x).ToString();
        (z ?? y).ToString();
    }
}";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): warning CS8602: Possible dereference of a null reference.
                //         (x ?? y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x ?? y").WithLocation(5, 10),
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         (y ?? x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y ?? x").WithLocation(7, 10),
                // (9,10): hidden CS8607: Expression is probably never null.
                //         (z ?? x).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z").WithLocation(9, 10),
                // (10,10): hidden CS8607: Expression is probably never null.
                //         (z ?? y).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z").WithLocation(10, 10));
        }

        [Fact]
        public void ImplicitConversion_NullCoalescingOperator_01()
        {
            var source0 =
@"public class UnknownNull
{
    public object Object;
    public string String;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source1 =
@"public class MaybeNull
{
    public object? Object;
    public string? String;
}
public class NotNull
{
    public object Object = new object();
    public string String = string.Empty;
}";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics();
            var ref1 = comp1.EmitToImageReference();

            var source =
@"class C
{
    static void F1(UnknownNull x1, UnknownNull y1)
    {
        (x1.Object ?? y1.String)/*T:object*/.ToString();
        (y1.String ?? x1.Object)/*T:object*/.ToString();
    }
    static void F2(UnknownNull x2, MaybeNull y2)
    {
        (x2.Object ?? y2.String)/*T:object?*/.ToString();
        (y2.String ?? x2.Object)/*T:object*/.ToString();
    }
    static void F3(MaybeNull x3, UnknownNull y3)
    {
        (x3.Object ?? y3.String)/*T:object*/.ToString();
        (y3.String ?? x3.Object)/*T:object?*/.ToString();
    }
    static void F4(MaybeNull x4, MaybeNull y4)
    {
        (x4.Object ?? y4.String)/*T:object?*/.ToString();
        (y4.String ?? x4.Object)/*T:object?*/.ToString();
    }
    static void F5(UnknownNull x5, NotNull y5)
    {
        (x5.Object ?? y5.String)/*T:object!*/.ToString();
        (y5.String ?? x5.Object)/*T:object!*/.ToString();
    }
    static void F6(NotNull x6, UnknownNull y6)
    {
        (x6.Object ?? y6.String)/*T:object!*/.ToString();
        (y6.String ?? x6.Object)/*T:object!*/.ToString();
    }
    static void F7(MaybeNull x7, NotNull y7)
    {
        (x7.Object ?? y7.String)/*T:object!*/.ToString();
        (y7.String ?? x7.Object)/*T:object!*/.ToString();
    }
    static void F8(NotNull x8, MaybeNull y8)
    {
        (x8.Object ?? y8.String)/*T:object!*/.ToString();
        (y8.String ?? x8.Object)/*T:object!*/.ToString();
    }
    static void F9(NotNull x9, NotNull y9)
    {
        (x9.Object ?? y9.String)/*T:object!*/.ToString();
        (y9.String ?? x9.Object)/*T:object!*/.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0, ref1 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (10,10): warning CS8602: Possible dereference of a null reference.
                //         (x2.Object ?? y2.String)/*T:object?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2.Object ?? y2.String").WithLocation(10, 10),
                // (16,10): warning CS8602: Possible dereference of a null reference.
                //         (y3.String ?? x3.Object)/*T:object?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y3.String ?? x3.Object").WithLocation(16, 10),
                // (20,10): warning CS8602: Possible dereference of a null reference.
                //         (x4.Object ?? y4.String)/*T:object?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x4.Object ?? y4.String").WithLocation(20, 10),
                // (21,10): warning CS8602: Possible dereference of a null reference.
                //         (y4.String ?? x4.Object)/*T:object?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y4.String ?? x4.Object").WithLocation(21, 10),
                // (26,10): hidden CS8607: Expression is probably never null.
                //         (y5.String ?? x5.Object)/*T:object*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y5.String").WithLocation(26, 10),
                // (30,10): hidden CS8607: Expression is probably never null.
                //         (x6.Object ?? y6.String)/*T:object*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x6.Object").WithLocation(30, 10),
                // (36,10): hidden CS8607: Expression is probably never null.
                //         (y7.String ?? x7.Object)/*T:object!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y7.String").WithLocation(36, 10),
                // (40,10): hidden CS8607: Expression is probably never null.
                //         (x8.Object ?? y8.String)/*T:object*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x8.Object").WithLocation(40, 10),
                // (45,10): hidden CS8607: Expression is probably never null.
                //         (x9.Object ?? y9.String)/*T:object!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x9.Object").WithLocation(45, 10),
                // (46,10): hidden CS8607: Expression is probably never null.
                //         (y9.String ?? x9.Object)/*T:object!*/.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y9.String").WithLocation(46, 10));
        }

        [Fact]
        public void ImplicitConversion_NullCoalescingOperator_02()
        {
            var source =
@"#pragma warning disable 0649
class A<T>
{
    internal T F;
}
class B<T> : A<T> { }
class C
{
    static void F(A<object>? x, B<object?> y)
    {
        (x ?? y).F.ToString(); // 1
        (y ?? x).F.ToString(); // 2
    }
    static void G(A<object?> z, B<object>? w)
    {
        (z ?? w).F.ToString(); // 3
        (w ?? z).F.ToString(); // 4
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class A<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "A").WithArguments("field", "F").WithLocation(2, 7),
                // (11,15): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         (x ?? y).F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("B<object?>", "A<object>").WithLocation(11, 15),
                // (12,10): hidden CS8607: Expression is probably never null.
                //         (y ?? x).F.ToString(); // 2
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(12, 10),
                // (12,10): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         (y ?? x).F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("B<object?>", "A<object>").WithLocation(12, 10),
                // (16,10): hidden CS8607: Expression is probably never null.
                //         (z ?? w).F.ToString(); // 3
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z").WithLocation(16, 10),
                // (16,15): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         (z ?? w).F.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w").WithArguments("B<object>", "A<object?>").WithLocation(16, 15),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         (z ?? w).F.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(z ?? w).F").WithLocation(16, 9),
                // (17,10): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         (w ?? z).F.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w").WithArguments("B<object>", "A<object?>").WithLocation(17, 10),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         (w ?? z).F.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(w ?? z).F").WithLocation(17, 9));
        }

        [Fact]
        public void ImplicitConversion_NullCoalescingOperator_03()
        {
            var source =
@"interface IIn<in T>
{
    void F(T x, T y);
}
class C
{
    static void F(IIn<object>? x, IIn<string?> y)
    {
        (x ?? y)/*T:IIn<string?>!*/.F(string.Empty, null);
        (y ?? x)/*T:IIn<string?>!*/.F(string.Empty, null);
    }
    static void G(IIn<object?> z, IIn<string>? w)
    {
        (z ?? w)/*T:IIn<string!>!*/.F(string.Empty, null);
        (w ?? z)/*T:IIn<string!>!*/.F(string.Empty, null);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (9,10): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<string?>'.
                //         (x ?? y)/*T:IIn<string?>!*/.F(string.Empty, null);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IIn<object>", "IIn<string?>").WithLocation(9, 10),
                // (10,10): hidden CS8607: Expression is probably never null.
                //         (y ?? x)/*T:IIn<string?>!*/.F(string.Empty, null);
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(10, 10),
                // (10,15): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<string?>'.
                //         (y ?? x)/*T:IIn<string?>!*/.F(string.Empty, null);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IIn<object>", "IIn<string?>").WithLocation(10, 15),
                // (14,10): hidden CS8607: Expression is probably never null.
                //         (z ?? w)/*T:IIn<string!>!*/.F(string.Empty, null);
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z").WithLocation(14, 10),
                // (14,53): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         (z ?? w)/*T:IIn<string!>!*/.F(string.Empty, null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(14, 53),
                // (15,53): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         (w ?? z)/*T:IIn<string!>!*/.F(string.Empty, null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(15, 53));
        }

        [Fact]
        public void ImplicitConversion_NullCoalescingOperator_04()
        {
            var source =
@"interface IOut<out T>
{
    T P { get; }
}
class C
{
    static void F(IOut<object>? x, IOut<string?> y)
    {
        (x ?? y)/*T:IOut<object!>!*/.P.ToString();
        (y ?? x)/*T:IOut<object!>!*/.P.ToString();
    }
    static void G(IOut<object?> z, IOut<string>? w)
    {
        (z ?? w)/*T:IOut<object?>!*/.P.ToString();
        (w ?? z)/*T:IOut<object?>!*/.P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (9,15): warning CS8619: Nullability of reference types in value of type 'IOut<string?>' doesn't match target type 'IOut<object>'.
                //         (x ?? y)/*T:IOut<object!>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("IOut<string?>", "IOut<object>").WithLocation(9, 15),
                // (10,10): hidden CS8607: Expression is probably never null.
                //         (y ?? x)/*T:IOut<object!>!*/.P.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(10, 10),
                // (10,10): warning CS8619: Nullability of reference types in value of type 'IOut<string?>' doesn't match target type 'IOut<object>'.
                //         (y ?? x)/*T:IOut<object!>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("IOut<string?>", "IOut<object>").WithLocation(10, 10),
                // (14,10): hidden CS8607: Expression is probably never null.
                //         (z ?? w)/*T:IOut<object?>!*/.P.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z").WithLocation(14, 10),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         (z ?? w)/*T:IOut<object?>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(z ?? w)/*T:IOut<object?>!*/.P").WithLocation(14, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         (w ?? z)/*T:IOut<object?>!*/.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(w ?? z)/*T:IOut<object?>!*/.P").WithLocation(15, 9));
        }

        [Fact]
        public void Loop_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1? x1, CL1 y1, CL1? z1)
    {
        x1 = y1;
        x1.M1(); // 1

        for (int i = 0; i < 2; i++)
        {
            x1.M1(); // 2
            x1 = z1;
        }
    }

    CL1 Test2(CL1? x2, CL1 y2, CL1? z2)
    {
        x2 = y2;
        x2.M1(); // 1

        for (int i = 0; i < 2; i++)
        {
            x2 = z2;
            x2.M1(); // 2
            y2 = z2;
            y2.M2(y2);

            if (i == 1)
            {
                return x2;
            }
        }

        return y2;
    }
}

class CL1
{
    public void M1() { }
    public void M2(CL1 x) { }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             x1.M1(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(15, 13),
                // (28,13): warning CS8602: Possible dereference of a null reference.
                //             x2.M1(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(28, 13),
                // (29,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             y2 = z2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "z2").WithLocation(29, 18),
                // (30,13): warning CS8602: Possible dereference of a null reference.
                //             y2.M2(y2);
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y2").WithLocation(30, 13));
        }

        [Fact]
        public void Loop_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1? x1, CL1 y1, CL1? z1)
    {
        x1 = y1;
        if (x1 == null) {} // 1

        for (int i = 0; i < 2; i++)
        {
            if (x1 == null) {} // 2
            x1 = z1;
        }
    }

    void Test2(CL1? x2, CL1 y2, CL1? z2)
    {
        x2 = y2;
        if (x2 == null) {} // 1

        for (int i = 0; i < 2; i++)
        {
            x2 = z2;
            if (x2 == null) {} // 2
        }
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (11,13): hidden CS8606: Result of the comparison is possibly always false.
                 //         if (x1 == null) {} // 1
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "x1 == null").WithLocation(11, 13),
                 // (23,13): hidden CS8606: Result of the comparison is possibly always false.
                 //         if (x2 == null) {} // 1
                 Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "x2 == null").WithLocation(23, 13)
                );
        }

        [Fact]
        public void Loop_03()
        {
            var source0 =
@"public class A
{
    public object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var source1 =
@"#pragma warning disable 8618
class B
{
    object G;
    static object F1(B b1, object? o)
    {
        for (int i = 0; i < 2; i++)
        {
            b1.G = o;
        }
        return b1.G;
    }
    static object F2(B b2, A a)
    {
        for (int i = 0; i < 2; i++)
        {
            b2.G = a.F;
        }
        return b2.G;
    }
    static object F3(B b3, object? o, A a)
    {
        for (int i = 0; i < 2; i++)
        {
            if (i % 2 == 0)
                b3.G = o;
            else
                b3.G = a.F;
        }
        return b3.G;
    }
}";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: new[] { comp0.EmitToImageReference() });
            comp1.VerifyDiagnostics(
                // (9,20): warning CS8601: Possible null reference assignment.
                //             b1.G = o;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "o").WithLocation(9, 20),
                // (11,16): warning CS8603: Possible null reference return.
                //         return b1.G;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "b1.G").WithLocation(11, 16),
                // (26,24): warning CS8601: Possible null reference assignment.
                //                 b3.G = o;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "o").WithLocation(26, 24),
                // (30,16): warning CS8603: Possible null reference return.
                //         return b3.G;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "b3.G").WithLocation(30, 16));
        }

        [Fact]
        public void Loop_04()
        {
            var source0 =
@"public class A
{
    public object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var source1 =
@"#pragma warning disable 8618
class C
{
    static object F1(A a1, object? o)
    {
        for (int i = 0; i < 2; i++)
        {
            a1.F = o;
        }
        return a1.F;
    }
    static object F2(A a2, object o)
    {
        for (int i = 0; i < 2; i++)
        {
            a2.F = o;
        }
        return a2.F;
    }
    static object F3(A a3, object? o, A a)
    {
        for (int i = 0; i < 2; i++)
        {
            if (i % 2 == 0)
                a3.F = o;
            else
                a3.F = a.F;
        }
        return a3.F;
    }
}";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: new[] { comp0.EmitToImageReference() });
            comp1.VerifyDiagnostics(
                // (10,16): warning CS8603: Possible null reference return.
                //         return a1.F;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "a1.F").WithLocation(10, 16),
                // (29,16): warning CS8603: Possible null reference return.
                //         return a3.F;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "a3.F").WithLocation(29, 16));
        }

        [Fact]
        public void Var_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? Test1()
    {
        var x1 = (CL1)null;
        return x1;
    }

    CL1? Test2(CL1 x2)
    {
        var y2 = x2;
        y2 = null;
        return y2;
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var x1 = (CL1)null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(CL1)null").WithLocation(10, 18),
                // (17,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y2 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(17, 14));
        }

        [Fact]
        public void Var_NonNull()
        {
            var source =
@"class C
{
    static void F(string str)
    {
        var s = str;
        s.ToString();
        s = null;
        s.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         s = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(7, 13),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String", symbol.Type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.NotAnnotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Var_NonNull_CSharp7()
        {
            var source =
@"class C
{
    static void Main()
    {
        var s = string.Empty;
        s.ToString();
        s = null;
        s.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String", symbol.Type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.Unknown, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Var_FlowAnalysis_01()
        {
            var source =
@"class C
{
    static void F(string? s)
    {
        var t = s;
        t.ToString();
        t = null;
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(6, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.Annotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Var_FlowAnalysis_02()
        {
            var source =
@"class C
{
    static void F(string? s)
    {
        t = null;
        var t = s;
        t.ToString();
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): error CS0841: Cannot use local variable 't' before it is declared
                //         t = null;
                Diagnostic(ErrorCode.ERR_VariableUsedBeforeDeclaration, "t").WithArguments("t").WithLocation(5, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(7, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.Annotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Var_FlowAnalysis_03()
        {
            var source =
@"class C
{
    static void F(string? s)
    {
        if (s == null)
        {
            return;
        }
        var t = s;
        t.ToString();
        t = null;
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(11, 13));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            // https://github.com/dotnet/roslyn/issues/29856: Type should be `string!`.
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            // https://github.com/dotnet/roslyn/issues/29856: IsNullable should be inferred nullable state: false.
            Assert.Equal(NullableAnnotation.Annotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Var_FlowAnalysis_04()
        {
            var source =
@"class C
{
    static void F(int n)
    {
        string? s = string.Empty;
        while (n-- > 0)
        {
            var t = s;
            t.ToString();
            t = null;
            s = null;
        }
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(9, 13));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.Annotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Var_FlowAnalysis_05()
        {
            var source =
@"class C
{
    static void F(int n, string? s)
    {
        while (n-- > 0)
        {
            var t = s;
            t.ToString();
            t = null;
            s = string.Empty;
        }
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(8, 13));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.Annotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Var_FlowAnalysis_06()
        {
            var source =
@"class C
{
    static void F(int n)
    {
        string? s = string.Empty;
        while (n-- > 0)
        {
            var t = s;
            t.ToString();
            t = null;
            if (n % 2 == 0) s = null;
        }
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(9, 13));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.Annotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Var_FlowAnalysis_07()
        {
            var source =
@"class C
{
    static void F(int n)
    {
        string? s = string.Empty;
        while (n-- > 0)
        {
            var t = s;
            t.ToString();
            t = null;
            if (n % 2 == 0) s = string.Empty;
            else s = null;
        }
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(9, 13));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.Annotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Var_FlowAnalysis_08()
        {
            var source =
@"class C
{
    static void F(string? s)
    {
        var t = s!;
        t/*T:string!*/.ToString();
        t = null;
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(7, 13));
            comp.VerifyTypes();

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();

            // Need to verify the semantic model
            // Tracked by https://github.com/dotnet/roslyn/issues/32661

            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.Annotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Var_Cycle()
        {
            var source =
@"class C
{
    static void Main()
    {
        var s = s;
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,17): error CS0841: Cannot use local variable 's' before it is declared
                //         var s = s;
                Diagnostic(ErrorCode.ERR_VariableUsedBeforeDeclaration, "s").WithArguments("s").WithLocation(5, 17));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            var type = symbol.Type;
            Assert.True(type.IsErrorType());
            Assert.Equal("var", type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.Unknown, type.NullableAnnotation);
        }

        [Fact]
        public void Var_ConditionalOperator()
        {
            var source =
@"class C
{
    static void F(bool b, string s)
    {
        var s0 = b ? s : s;
        var s1 = b ? s : null;
        var s2 = b ? null : s;
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();

            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("System.String", symbol.Type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.Unknown, symbol.Type.NullableAnnotation);  // https://github.com/dotnet/roslyn/issues/29856: Inferred nullability: false

            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("System.String", symbol.Type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.Unknown, symbol.Type.NullableAnnotation); // https://github.com/dotnet/roslyn/issues/29856: Inferred nullability: true

            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[2]);
            Assert.Equal("System.String", symbol.Type.ToTestDisplayString());
            Assert.Equal(NullableAnnotation.Unknown, symbol.Type.NullableAnnotation); // https://github.com/dotnet/roslyn/issues/29856: Inferred nullability: true
        }

        [Fact]
        public void Var_Array_01()
        {
            var source =
@"class C
{
    static void F(string str)
    {
        var s = new[] { str };
        s[0].ToString();
        var t = new[] { str, null };
        t[0].ToString();
        var u = new[] { 1, null };
        u[0].ToString();
        var v = new[] { null, (int?)2 };
        v[0].ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,28): error CS0037: Cannot convert null to 'int' because it is a non-nullable value type
                //         var u = new[] { 1, null };
                Diagnostic(ErrorCode.ERR_ValueCantBeNull, "null").WithArguments("int").WithLocation(9, 28),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t[0]").WithLocation(8, 9));
        }

        [Fact]
        public void Var_Array_02()
        {
            var source =
@"delegate void D();
class C
{
    static void Main()
    {
        var a = new[] { new D(Main), () => { } };
        a[0].ToString();
        var b = new[] { new D(Main), null };
        b[0].ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0]").WithLocation(9, 9));
        }

        [Fact]
        public void Array_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1? [] x1)
    {
        CL1? y1 = x1[0];
        CL1 z1 = x1[0];
    }

    void Test2(CL1 [] x2, CL1 y2, CL1? z2)
    {
        x2[0] = y2;
        x2[1] = z2;
    }

    void Test3(CL1 [] x3)
    {
        CL1? y3 = x3[0];
        CL1 z3 = x3[0];
    }

    void Test4(CL1? [] x4, CL1 y4, CL1? z4)
    {
        x4[0] = y4;
        x4[1] = z4;
    }

    void Test5(CL1 y5, CL1? z5)
    {
        var x5 = new CL1 [] { y5, z5 };
    }

    void Test6(CL1 y6, CL1? z6)
    {
        var x6 = new CL1 [,] { {y6}, {z6} };
    }

    void Test7(CL1 y7, CL1? z7)
    {
        var u7 = new CL1? [] { y7, z7 };
        var v7 = new CL1? [,] { {y7}, {z7} };
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (11,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 z1 = x1[0];
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1[0]").WithLocation(11, 18),
                // (17,17): warning CS8601: Possible null reference assignment.
                //         x2[1] = z2;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "z2").WithLocation(17, 17),
                // (34,35): warning CS8601: Possible null reference assignment.
                //         var x5 = new CL1 [] { y5, z5 };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "z5").WithLocation(34, 35),
                // (39,39): warning CS8601: Possible null reference assignment.
                //         var x6 = new CL1 [,] { {y6}, {z6} };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "z6").WithLocation(39, 39)
                );
        }

        [Fact]
        public void Array_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 y1, CL1? z1)
    {
        CL1? [] u1 = new [] { y1, z1 };
        CL1? [,] v1 = new [,] { {y1}, {z1} };
    }

    void Test2(CL1 y2, CL1? z2)
    {
        var u2 = new [] { y2, z2 };
        var v2 = new [,] { {y2}, {z2} };

        u2[0] = z2;
        v2[0,0] = z2;
    }

    void Test3(CL1 y3, CL1? z3)
    {
        CL1? [] u3;
        CL1? [,] v3;

        u3 = new [] { y3, z3 };
        v3 = new [,] { {y3}, {z3} };
    }

    void Test4(CL1 y4, CL1? z4)
    {
        var u4 = new [] { y4 };
        var v4 = new [,] {{y4}};

        u4[0] = z4;
        v4[0,0] = z4;
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (37,17): warning CS8601: Possible null reference assignment.
                //         u4[0] = z4;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "z4").WithLocation(37, 17),
                // (38,19): warning CS8601: Possible null reference assignment.
                //         v4[0,0] = z4;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "z4").WithLocation(38, 19)
                );
        }

        [Fact]
        public void Array_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1()
    {
        int[]? u1 = new [] { 1, 2 };
        u1 = null;
        var z1 = u1[0];
    }

    void Test2()
    {
        int[]? u1 = new [] { 1, 2 };
        u1 = null;
        var z1 = u1?[u1[0]];
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,18): warning CS8602: Possible dereference of a null reference.
                //         var z1 = u1[0];
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u1").WithLocation(12, 18)
                );
        }

        [Fact]
        public void Array_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL1 y1, CL1? z1)
    {
        CL1 [] u1;
        CL1 [,] v1;

        u1 = new [] { y1, z1 };
        v1 = new [,] { {y1}, {z1} };
    }

    void Test3(CL1 y2, CL1? z2)
    {
        CL1 [] u2;
        CL1 [,] v2;

        var a2 = new [] { y2, z2 };
        var b2 = new [,] { {y2}, {z2} };

        u2 = a2;
        v2 = b2;
    }

    void Test8(CL1 y8, CL1? z8)
    {
        CL1 [] x8 = new [] { y8, z8 };
    }

    void Test9(CL1 y9, CL1? z9)
    {
        CL1 [,] x9 = new [,] { {y9}, {z9} };
    }

    void Test11(CL1 y11, CL1? z11)
    {
        CL1? [] u11;
        CL1? [,] v11;

        u11 = new [] { y11, z11 };
        v11 = new [,] { {y11}, {z11} };
    }

    void Test13(CL1 y12, CL1? z12)
    {
        CL1? [] u12;
        CL1? [,] v12;

        var a12 = new [] { y12, z12 };
        var b12 = new [,] { {y12}, {z12} };

        u12 = a12;
        v12 = b12;
    }

    void Test18(CL1 y18, CL1? z18)
    {
        CL1? [] x18 = new [] { y18, z18 };
    }

    void Test19(CL1 y19, CL1? z19)
    {
        CL1? [,] x19 = new [,] { {y19}, {z19} };
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,14): warning CS8619: Nullability of reference types in value of type 'CL1?[]' doesn't match target type 'CL1[]'.
                //         u1 = new [] { y1, z1 };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new [] { y1, z1 }").WithArguments("CL1?[]", "CL1[]").WithLocation(13, 14),
                // (14,14): warning CS8619: Nullability of reference types in value of type 'CL1?[*,*]' doesn't match target type 'CL1[*,*]'.
                //         v1 = new [,] { {y1}, {z1} };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new [,] { {y1}, {z1} }").WithArguments("CL1?[*,*]", "CL1[*,*]").WithLocation(14, 14),
                // (25,14): warning CS8619: Nullability of reference types in value of type 'CL1?[]' doesn't match target type 'CL1[]'.
                //         u2 = a2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("CL1?[]", "CL1[]").WithLocation(25, 14),
                // (26,14): warning CS8619: Nullability of reference types in value of type 'CL1?[*,*]' doesn't match target type 'CL1[*,*]'.
                //         v2 = b2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b2").WithArguments("CL1?[*,*]", "CL1[*,*]").WithLocation(26, 14),
                // (31,21): warning CS8619: Nullability of reference types in value of type 'CL1?[]' doesn't match target type 'CL1[]'.
                //         CL1 [] x8 = new [] { y8, z8 };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new [] { y8, z8 }").WithArguments("CL1?[]", "CL1[]").WithLocation(31, 21),
                // (36,22): warning CS8619: Nullability of reference types in value of type 'CL1?[*,*]' doesn't match target type 'CL1[*,*]'.
                //         CL1 [,] x9 = new [,] { {y9}, {z9} };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new [,] { {y9}, {z9} }").WithArguments("CL1?[*,*]", "CL1[*,*]").WithLocation(36, 22)
                );
        }

        [Fact]
        public void Array_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1()
    {
        int[]? u1 = new [] { 1, 2 };
        var z1 = u1.Length;
    }

    void Test2()
    {
        int[]? u2 = new [] { 1, 2 };
        u2 = null;
        var z2 = u2.Length;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (18,18): warning CS8602: Possible dereference of a null reference.
                //         var z2 = u2.Length;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u2").WithLocation(18, 18)
                );
        }

        [Fact]
        public void Array_06()
        {
            const string source = @"
class C
{
    static void Main()
    {
    }

    object Test1()
    {
        object []? u1 = null;
        return u1;
    }
    object Test2()
    {
        object [][]? u2 = null;
        return u2;
    }
    object Test3()
    {
        object []?[]? u3 = null;
        return u3;
    }
}
";
            var expected = new[]
            {
                // (10,18): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         object []? u1 = null;
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(10, 18),
                // (15,20): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         object [][]? u2 = null;
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(15, 20),
                // (20,18): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         object []?[]? u3 = null;
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(20, 18),
                // (20,21): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         object []?[]? u3 = null;
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(20, 21)
            };

            var c = CreateCompilation(source, parseOptions: TestOptions.Regular7);
            c.VerifyDiagnostics(expected);

            c = CreateCompilation(source, parseOptions: TestOptions.RegularDefault);
            c.VerifyDiagnostics(expected);
        }

        [Fact]
        public void Array_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1()
    {
        object? [] u1 = new [] { null, new object() };
        u1 = null;
    }

    void Test2()
    {
        object [] u2 = new [] { null, new object() };
    }

    void Test3()
    {
        var u3 = new object [] { null, new object() };
    }

    object? Test4()
    {
        object []? u4 = null;
        return u4;
    }

    object Test5()
    {
        object? [] u5 = null;
        return u5;
    }

    void Test6()
    {
        object [][,]? u6 = null;
        u6[0] = null;
        u6[0][0,0] = null;
        u6[0][0,0].ToString();
    }

    void Test7()
    {
        object [][,] u7 = null;
        u7[0] = null;
        u7[0][0,0] = null;
    }

    void Test8()
    {
        object []?[,] u8 = null;
        u8[0,0] = null;
        u8[0,0].ToString();
        u8[0,0][0] = null;
        u8[0,0][0].ToString();
    }

    void Test9()
    {
        object []?[,]? u9 = null;
        u9[0,0] = null;
        u9[0,0][0] = null;
        u9[0,0][0].ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (11,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         u1 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(11, 14),
                // (16,24): warning CS8619: Nullability of reference types in value of type 'object?[]' doesn't match target type 'object[]'.
                //         object [] u2 = new [] { null, new object() };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new [] { null, new object() }").WithArguments("object?[]", "object[]").WithLocation(16, 24),
                // (21,34): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         var u3 = new object [] { null, new object() };
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(21, 34),
                // (32,25): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object? [] u5 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(32, 25),
                // (33,16): warning CS8603: Possible null reference return.
                //         return u5;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "u5").WithLocation(33, 16),
                // (39,9): warning CS8602: Possible dereference of a null reference.
                //         u6[0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u6").WithLocation(39, 9),
                // (39,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u6[0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(39, 17),
                // (40,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u6[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(40, 22),
                // (46,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object [][,] u7 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(46, 27),
                // (47,9): warning CS8602: Possible dereference of a null reference.
                //         u7[0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u7").WithLocation(47, 9),
                // (47,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u7[0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(47, 17),
                // (48,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u7[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(48, 22),
                // (53,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object []?[,] u8 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(53, 28),
                // (54,9): warning CS8602: Possible dereference of a null reference.
                //         u8[0,0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u8").WithLocation(54, 9),
                // (55,9): warning CS8602: Possible dereference of a null reference.
                //         u8[0,0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u8[0,0]").WithLocation(55, 9),
                // (56,9): warning CS8602: Possible dereference of a null reference.
                //         u8[0,0][0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u8[0,0]").WithLocation(56, 9),
                // (56,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u8[0,0][0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(56, 22),
                // (57,9): warning CS8602: Possible dereference of a null reference.
                //         u8[0,0][0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u8[0,0]").WithLocation(57, 9),
                // (63,9): warning CS8602: Possible dereference of a null reference.
                //         u9[0,0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u9").WithLocation(63, 9),
                // (64,9): warning CS8602: Possible dereference of a null reference.
                //         u9[0,0][0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u9[0,0]").WithLocation(64, 9),
                // (64,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u9[0,0][0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(64, 22),
                // (65,9): warning CS8602: Possible dereference of a null reference.
                //         u9[0,0][0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u9[0,0]").WithLocation(65, 9)
                );
        }

        [Fact]
        public void Array_08()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test3()
    {
        var u3 = new object? [] { null };
    }

    void Test6()
    {
        var u6 = new object [,]?[] {null, 
                                    new object[,] {{null}}};
        u6[0] = null;
        u6[0][0,0] = null;
        u6[0][0,0].ToString();
    }

    void Test7()
    {
        var u7 = new object [][,] {null, 
                                   new object[,] {{null}}};
        u7[0] = null;
        u7[0][0,0] = null;
    }

    void Test8()
    {
        object [][,]? u8 = new object [][,] {null, 
                                    new object[,] {{null}}};
        u8[0] = null;
        u8[0][0,0] = null;
        u8[0][0,0].ToString();
    }

    void Test9()
    {
        object [,]?[]? u9 = new object [,]?[] {null, 
                                     new object[,] {{null}}};
        u9[0] = null;
        u9[0][0,0] = null;
        u9[0][0,0].ToString();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(

                // (16,53): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //                                     new object[,] {{null}}};
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(16, 53),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         u6[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u6[0]").WithLocation(18, 9),
                // (18,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u6[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(18, 22),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         u6[0][0,0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u6[0]").WithLocation(19, 9),
                // (24,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         var u7 = new object [][,] {null,
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(24, 36),
                // (25,52): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //                                    new object[,] {{null}}};
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(25, 52),
                // (26,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u7[0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(26, 17),
                // (27,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u7[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(27, 22),
                // (32,46): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         object [][,]? u8 = new object [][,] {null, 
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(32, 46),
                // (33,53): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //                                     new object[,] {{null}}};
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(33, 53),
                // (34,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u8[0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(34, 17),
                // (35,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u8[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(35, 22),
                // (42,54): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //                                      new object[,] {{null}}};
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(42, 54),
                // (44,9): warning CS8602: Possible dereference of a null reference.
                //         u9[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u9[0]").WithLocation(44, 9),
                // (44,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         u9[0][0,0] = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(44, 22),
                // (45,9): warning CS8602: Possible dereference of a null reference.
                //         u9[0][0,0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u9[0]").WithLocation(45, 9)
                );
        }

        [Fact]
        public void Array_09()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0<string?> x1, CL0<string> y1)
    {
        var u1 = new [] { x1, y1 };
        var a1 = new [] { y1, x1 };
        var v1 = new CL0<string?>[] { x1, y1 };
        var w1 = new CL0<string>[] { x1, y1 };
    }
}

class CL0<T>
{}

" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,27): warning CS8619: Nullability of reference types in value of type 'CL0<string?>' doesn't match target type 'CL0<string>'.
                //         var u1 = new [] { x1, y1 };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("CL0<string?>", "CL0<string>").WithLocation(10, 27),
                // (11,31): warning CS8619: Nullability of reference types in value of type 'CL0<string?>' doesn't match target type 'CL0<string>'.
                //         var a1 = new [] { y1, x1 };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("CL0<string?>", "CL0<string>").WithLocation(11, 31),
                // (12,43): warning CS8619: Nullability of reference types in value of type 'CL0<string>' doesn't match target type 'CL0<string?>'.
                //         var v1 = new CL0<string?>[] { x1, y1 };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("CL0<string>", "CL0<string?>").WithLocation(12, 43),
                // (13,38): warning CS8619: Nullability of reference types in value of type 'CL0<string?>' doesn't match target type 'CL0<string>'.
                //         var w1 = new CL0<string>[] { x1, y1 };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("CL0<string?>", "CL0<string>").WithLocation(13, 38)
                );
        }

        [Fact]
        public void Array_10()
        {
            var source =
@"class C
{
    static void F1<T>()
    {
        T[] a1;
        a1 = new T[] { default }; // 1
        a1 = new T[] { default(T) }; // 2
    }
    static void F2<T>() where T : class
    {
        T[] a2;
        a2 = new T[] { null }; // 3
        a2 = new T[] { default }; // 4
        a2 = new T[] { default(T) }; // 5
    }
    static void F3<T>() where T : struct
    {
        T[] a3;
        a3 = new T[] { default };
        a3 = new T[] { default(T) };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,24): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         a1 = new T[] { default }; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(6, 24),
                // (7,24): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         a1 = new T[] { default(T) }; // 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(T)").WithLocation(7, 24),
                // (12,24): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         a2 = new T[] { null }; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(12, 24),
                // (13,24): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         a2 = new T[] { default }; // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(13, 24),
                // (14,24): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         a2 = new T[] { default(T) }; // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(T)").WithLocation(14, 24));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_01()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        var a = new[] { x, x };
        a.ToString();
        a[0].ToString();
        var b = new[] { x, y };
        b.ToString();
        b[0].ToString();
        var c = new[] { b };
        c[0].ToString();
        c[0][0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0]").WithLocation(10, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         c[0][0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c[0][0]").WithLocation(13, 9));
        }

        [Fact, WorkItem(30376, "https://github.com/dotnet/roslyn/issues/30376")]
        public void ImplicitlyTypedArrayCreation_02()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        var a = new[] { x };
        a[0].ToString();
        var b = new[] { y };
        b[0].ToString();
    }
    static void F(object[] a, object?[] b)
    {
        var c = new[] { a, b };
        c[0][0].ToString();
        var d = new[] { a, b! };
        d[0][0].ToString();
        var e = new[] { b!, a };
        e[0][0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0]").WithLocation(8, 9),
                // (12,28): warning CS8619: Nullability of reference types in value of type 'object?[]' doesn't match target type 'object[]'.
                //         var c = new[] { a, b };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b").WithArguments("object?[]", "object[]").WithLocation(12, 28)
                );
        }

        [Fact, WorkItem(30376, "https://github.com/dotnet/roslyn/issues/30376")]
        public void ImplicitlyTypedArrayCreation_02_TopLevelNullability()
        {
            var source =
@"class C
{
    static void F(object? y)
    {
        var b = new[] { y! };
        b[0].ToString();
    }
    static void F(object[]? a, object?[]? b)
    {
        var c = new[] { a, b };
        _ = c[0].Length;
        var d = new[] { a, b! };
        _ = d[0].Length;
        var e = new[] { b!, a };
        _ = e[0].Length;
        var f = new[] { b!, a! };
        _ = f[0].Length;
        var g = new[] { a!, b! };
        _ = g[0].Length;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,28): warning CS8619: Nullability of reference types in value of type 'object?[]' doesn't match target type 'object[]'.
                //         var c = new[] { a, b };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b").WithArguments("object?[]", "object[]").WithLocation(10, 28),
                // (11,13): warning CS8602: Possible dereference of a null reference.
                //         _ = c[0].Length;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c[0]").WithLocation(11, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //         _ = d[0].Length;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "d[0]").WithLocation(13, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //         _ = e[0].Length;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "e[0]").WithLocation(15, 13)
                );
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_03()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        (new[] { x, x })[1].ToString();
        (new[] { y, x })[1].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, x })[1].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, x })[1]").WithLocation(6, 9));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_04()
        {
            var source =
@"class C
{
    static void F()
    {
        object? o = new object();
        var a = new[] { o };
        a[0].ToString();
        var b = new[] { a };
        b[0][0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_05()
        {
            var source =
@"class C
{
    static void F(int n)
    {
        object? o = new object();
        while (n-- > 0)
        {
            var a = new[] { o };
            a[0].ToString();
            var b = new[] { a };
            b[0][0].ToString();
            o = null;
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             a[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a[0]").WithLocation(9, 13),
                // (11,13): warning CS8602: Possible dereference of a null reference.
                //             b[0][0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0][0]").WithLocation(11, 13));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_06()
        {
            var source =
@"class C
{
    static void F(string s)
    {
        var a = new[] { new object(), (string)null };
        a[0].ToString();
        var b = new[] { (object)null, s };
        b[0].ToString();
        var c = new[] { s, (object)null };
        c[0].ToString();
        var d = new[] { (string)null, new object() };
        d[0].ToString();
        var e = new[] { new object(), (string)null! };
        e[0].ToString();
        var f = new[] { (object)null!, s };
        f[0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,39): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var a = new[] { new object(), (string)null };
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)null").WithLocation(5, 39),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         a[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a[0]").WithLocation(6, 9),
                // (7,25): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var b = new[] { (object)null, s };
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)null").WithLocation(7, 25),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0]").WithLocation(8, 9),
                // (9,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var c = new[] { s, (object)null };
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)null").WithLocation(9, 28),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         c[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c[0]").WithLocation(10, 9),
                // (11,25): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var d = new[] { (string)null, new object() };
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)null").WithLocation(11, 25),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         d[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "d[0]").WithLocation(12, 9));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_NestedNullability_Derived()
        {
            var source0 =
@"public class A
{
    public static object F;
}
public class B<T>
{
}
public class C0 : B<object>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C1 : B<object?> { }
class C2 : B<object> { }
class Program
{
    static B<T> CreateB<T>(T t) => throw null;
    static void F(B<object?> x, B<object> y, C0 cz, C1 cx, C2 cy)
    {
        var z = CreateB(A.F)/*T:B<object>!*/;
        object o;
        o = (new[] { x, cx })[0]/*B<object?>*/;
        o = (new[] { x, cy })[0]/*B<object>*/;
        o = (new[] { x, cz })[0]/*B<object?>*/;
        o = (new[] { y, cx })[0]/*B<object>*/;
        o = (new[] { cy, y })[0]/*B<object!>*/;
        o = (new[] { cz, y })[0]/*B<object!>*/;
        o = (new[] { cx, z })[0]/*B<object?>*/;
        o = (new[] { cy, z })[0]/*B<object!>*/;
        o = (new[] { cz, z })[0]/*B<object>*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,25): warning CS8619: Nullability of reference types in value of type 'C2' doesn't match target type 'B<object?>'.
                //         o = (new[] { x, cy })[0]/*B<object>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "cy").WithArguments("C2", "B<object?>").WithLocation(11, 25),
                // (13,25): warning CS8619: Nullability of reference types in value of type 'C1' doesn't match target type 'B<object>'.
                //         o = (new[] { y, cx })[0]/*B<object>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "cx").WithArguments("C1", "B<object>").WithLocation(13, 25));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29888, "https://github.com/dotnet/roslyn/issues/29888")]
        public void ImplicitlyTypedArrayCreation_08()
        {
            var source =
@"class C<T> { }
class C
{
    static void F(C<object>? a, C<object?> b)
    {
        if (a == null)
        {
            var c = new[] { a, b };
            c[0].ToString();
            var d = new[] { b, a };
            d[0].ToString();
        }
        else
        {
            var c = new[] { a, b };
            c[0].ToString();
            var d = new[] { b, a };
            d[0].ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,32): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //             var c = new[] { a, b };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b").WithArguments("C<object?>", "C<object>").WithLocation(8, 32),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             c[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c[0]").WithLocation(9, 13),
                // (10,29): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //             var d = new[] { b, a };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b").WithArguments("C<object?>", "C<object>").WithLocation(10, 29),
                // (11,13): warning CS8602: Possible dereference of a null reference.
                //             d[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "d[0]").WithLocation(11, 13),
                // (15,32): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //             var c = new[] { a, b };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b").WithArguments("C<object?>", "C<object>").WithLocation(15, 32),
                // (17,29): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //             var d = new[] { b, a };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b").WithArguments("C<object?>", "C<object>").WithLocation(17, 29));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_09()
        {
            var source =
@"class C
{
    static void F(C x1, Unknown? y1)
    {
        var a1 = new[] { x1, y1 };
        a1[0].ToString();
        var b1 = new[] { y1, x1 };
        b1[0].ToString();
    }
    static void G(C? x2, Unknown y2)
    {
        var a2 = new[] { x2, y2 };
        a2[0].ToString();
        var b2 = new[] { y2, x2 };
        b2[0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,26): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     static void G(C? x2, Unknown y2)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(10, 26),
                // (3,25): error CS0246: The type or namespace name 'Unknown' could not be found (are you missing a using directive or an assembly reference?)
                //     static void F(C x1, Unknown? y1)
                Diagnostic(ErrorCode.ERR_SingleTypeNameNotFound, "Unknown").WithArguments("Unknown").WithLocation(3, 25),
                // (5,18): error CS0826: No best type found for implicitly-typed array
                //         var a1 = new[] { x1, y1 };
                Diagnostic(ErrorCode.ERR_ImplicitlyTypedArrayNoBestType, "new[] { x1, y1 }").WithLocation(5, 18),
                // (7,18): error CS0826: No best type found for implicitly-typed array
                //         var b1 = new[] { y1, x1 };
                Diagnostic(ErrorCode.ERR_ImplicitlyTypedArrayNoBestType, "new[] { y1, x1 }").WithLocation(7, 18));
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_TopLevelNullability_01()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static void F(object? x, object y)
    {
        var z = A.F/*T:object*/;
        object? o;
        o = (new[] { x, x })[0]/*T:object?*/;
        o = (new[] { x, y })[0]/*T:object?*/;
        o = (new[] { x, z })[0]/*T:object?*/;
        o = (new[] { y, x })[0]/*T:object?*/;
        o = (new[] { y, y })[0]/*T:object!*/;
        o = (new[] { y, z })[0]/*T:object*/;
        o = (new[] { z, x })[0]/*T:object?*/;
        o = (new[] { z, y })[0]/*T:object*/;
        o = (new[] { z, z })[0]/*T:object*/;
        o = (new[] { x, y, z })[0]/*T:object?*/;
        o = (new[] { z, y, x })[0]/*T:object?*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_TopLevelNullability_02()
        {
            var source =
@"class C
{
    static void F<T, U>(T t, U u)
        where T : class?
        where U : class, T
    {
        object? o;
        o = (new[] { t, t })[0]/*T:T*/;
        o = (new[] { t, u })[0]/*T:T*/;
        o = (new[] { u, t })[0]/*T:T*/;
        o = (new[] { u, u })[0]/*T:U!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [WorkItem(27961, "https://github.com/dotnet/roslyn/issues/27961")]
        [Fact]
        public void ImplicitlyTypedArrayCreation_NestedNullability_Invariant()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T> { }
class Program
{
    static B<T> Create<T>(T t)
    {
        throw null;
    }
    static void F(bool b, B<object?> x, B<object> y)
    {
        var z = Create(A.F); // B<object~>
        object o;
        o = (new[] { x, y })[0]/*T:B<object!>!*/;
        o = (new[] { x, z })[0]/*T:B<object?>!*/;
        o = (new[] { y, x })[0]/*T:B<object!>!*/;
        o = (new[] { y, z })[0]/*T:B<object!>!*/;
        o = (new[] { z, x })[0]/*T:B<object?>!*/;
        o = (new[] { z, y })[0]/*T:B<object!>!*/;
        o = (new[] { x, y, z })[0]/*T:B<object!>!*/;
        o = (new[] { z, y, x })[0]/*T:B<object!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (12,22): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         o = (new[] { x, y })[0]/*T:B<object!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(12, 22),
                // (14,25): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         o = (new[] { y, x })[0]/*T:B<object!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(14, 25),
                // (18,22): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         o = (new[] { x, y, z })[0]/*T:B<object!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(18, 22),
                // (19,28): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         o = (new[] { z, y, x })[0]/*T:B<object!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(19, 28));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void ImplicitlyTypedArrayCreation_NestedNullability_Variant_01()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static I<T> CreateI<T>(T t) => throw null;
    static void F(I<object> x, I<object?> y)
    {
        var z = CreateI(A.F)/*T:I<object>!*/;
        object o;
        o = (new[] { x, x })[0]/*T:I<object!>!*/;
        o = (new[] { x, y })[0]/*T:I<object!>!*/; // 1
        o = (new[] { x, z })[0]/*T:I<object!>!*/;
        o = (new[] { y, x })[0]/*T:I<object!>!*/; // 2
        o = (new[] { y, y })[0]/*T:I<object?>!*/;
        o = (new[] { y, z })[0]/*T:I<object?>!*/;
        o = (new[] { z, x })[0]/*T:I<object!>!*/;
        o = (new[] { z, y })[0]/*T:I<object?>!*/;
        o = (new[] { z, z })[0]/*T:I<object>!*/;
    }
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static void F(IIn<object> x, IIn<object?> y)
    {
        var z = CreateIIn(A.F)/*T:IIn<object>!*/;
        object o;
        o = (new[] { x, x })[0]/*T:IIn<object!>!*/;
        o = (new[] { x, y })[0]/*T:IIn<object!>!*/;
        o = (new[] { x, z })[0]/*T:IIn<object!>!*/;
        o = (new[] { y, x })[0]/*T:IIn<object!>!*/;
        o = (new[] { y, y })[0]/*T:IIn<object?>!*/;
        o = (new[] { y, z })[0]/*T:IIn<object>!*/;
        o = (new[] { z, x })[0]/*T:IIn<object!>!*/;
        o = (new[] { z, y })[0]/*T:IIn<object>!*/;
        o = (new[] { z, z })[0]/*T:IIn<object>!*/;
    }
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void F(IOut<object> x, IOut<object?> y)
    {
        var z = CreateIOut(A.F)/*T:IOut<object>!*/;
        object o;
        o = (new[] { x, x })[0]/*T:IOut<object!>!*/;
        o = (new[] { x, y })[0]/*T:IOut<object?>!*/;
        o = (new[] { x, z })[0]/*T:IOut<object>!*/;
        o = (new[] { y, x })[0]/*T:IOut<object?>!*/;
        o = (new[] { y, y })[0]/*T:IOut<object?>!*/;
        o = (new[] { y, z })[0]/*T:IOut<object?>!*/;
        o = (new[] { z, x })[0]/*T:IOut<object>!*/;
        o = (new[] { z, y })[0]/*T:IOut<object?>!*/;
        o = (new[] { z, z })[0]/*T:IOut<object>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (12,25): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         o = (new[] { x, y })[0]/*T:I<object!>!*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(12, 25),
                // (14,22): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         o = (new[] { y, x })[0]/*T:I<object!>!*/; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(14, 22));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void ImplicitlyTypedArrayCreation_NestedNullability_Variant_02()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static I<IOut<T>> Create1<T>(T t) => throw null;
    static void G1(I<IOut<string?>> x1, I<IOut<string>> y1)
    {
        var z1 = Create1(A.F)/*T:I<IOut<string>!>!*/;
        object o;
        o = (new [] { x1, x1 })[0]/*T:I<IOut<string?>!>!*/;
        o = (new [] { x1, y1 })[0]/*T:I<IOut<string!>!>!*/; // 1
        o = (new [] { x1, z1 })[0]/*T:I<IOut<string?>!>!*/;
        o = (new [] { y1, x1 })[0]/*T:I<IOut<string!>!>!*/; // 2
        o = (new [] { y1, y1 })[0]/*T:I<IOut<string!>!>!*/;
        o = (new [] { y1, z1 })[0]/*T:I<IOut<string!>!>!*/;
        o = (new [] { z1, x1 })[0]/*T:I<IOut<string?>!>!*/;
        o = (new [] { z1, y1 })[0]/*T:I<IOut<string!>!>!*/;
        o = (new [] { z1, z1 })[0]/*T:I<IOut<string>!>!*/;
    }
    static IOut<IIn<T>> Create2<T>(T t) => throw null;
    static void G2(IOut<IIn<string?>> x2, IOut<IIn<string>> y2)
    {
        var z2 = Create2(A.F)/*T:IOut<IIn<string>!>!*/;
        object o;
        o = (new [] { x2, x2 })[0]/*T:IOut<IIn<string?>!>!*/;
        o = (new [] { x2, y2 })[0]/*T:IOut<IIn<string!>!>!*/;
        o = (new [] { x2, z2 })[0]/*T:IOut<IIn<string>!>!*/;
        o = (new [] { y2, x2 })[0]/*T:IOut<IIn<string!>!>!*/;
        o = (new [] { y2, y2 })[0]/*T:IOut<IIn<string!>!>!*/;
        o = (new [] { y2, z2 })[0]/*T:IOut<IIn<string!>!>!*/;
        o = (new [] { z2, x2 })[0]/*T:IOut<IIn<string>!>!*/;
        o = (new [] { z2, y2 })[0]/*T:IOut<IIn<string!>!>!*/;
        o = (new [] { z2, z2 })[0]/*T:IOut<IIn<string>!>!*/;
    }
    static IIn<IOut<T>> Create3<T>(T t) => throw null;
    static void G3(IIn<IOut<string?>> x3, IIn<IOut<string>> y3)
    {
        var z3 = Create3(A.F)/*T:IIn<IOut<string>!>!*/;
        object o;
        o = (new [] { x3, x3 })[0]/*T:IIn<IOut<string?>!>!*/;
        o = (new [] { x3, y3 })[0]/*T:IIn<IOut<string!>!>!*/;
        o = (new [] { x3, z3 })[0]/*T:IIn<IOut<string>!>!*/;
        o = (new [] { y3, x3 })[0]/*T:IIn<IOut<string!>!>!*/;
        o = (new [] { y3, y3 })[0]/*T:IIn<IOut<string!>!>!*/;
        o = (new [] { y3, z3 })[0]/*T:IIn<IOut<string!>!>!*/;
        o = (new [] { z3, x3 })[0]/*T:IIn<IOut<string>!>!*/;
        o = (new [] { z3, y3 })[0]/*T:IIn<IOut<string!>!>!*/;
        o = (new [] { z3, z3 })[0]/*T:IIn<IOut<string>!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (13,23): warning CS8619: Nullability of reference types in value of type 'I<IOut<string?>>' doesn't match target type 'I<IOut<string>>'.
                //         o = (new [] { x1, y1 })[0]/*T:I<IOut<string!>!>!*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("I<IOut<string?>>", "I<IOut<string>>").WithLocation(13, 23),
                // (15,27): warning CS8619: Nullability of reference types in value of type 'I<IOut<string?>>' doesn't match target type 'I<IOut<string>>'.
                //         o = (new [] { y1, x1 })[0]/*T:I<IOut<string!>!>!*/; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("I<IOut<string?>>", "I<IOut<string>>").WithLocation(15, 27));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void ImplicitlyTypedArrayCreation_NestedNullability_Variant_03()
        {
            var source0 =
@"public class A
{
    public static object F1;
    public static string F2;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T>
{
    internal interface INone { }
    internal interface I<U> { }
    internal interface IIn<in U> { }
    internal interface IOut<out U> { }
}
class C
{
    static T F<T>(T x, T y) => throw null;
    static B<T>.INone CreateINone<T>(T t) => throw null;
    static void G0(B<object>.INone x0, B<object?>.INone y0)
    {
        var z0 = CreateINone(A.F1)/*T:B<object>.INone!*/;
        object o;
        o = (new[] { x0, x0 })[0]/*T:B<object!>.INone!*/;
        o = (new[] { x0, y0 })[0]/*T:B<object!>.INone!*/; // 1
        o = (new[] { x0, z0 })[0]/*T:B<object!>.INone!*/;
        o = (new[] { y0, x0 })[0]/*T:B<object!>.INone!*/; // 2
        o = (new[] { y0, y0 })[0]/*T:B<object?>.INone!*/;
        o = (new[] { y0, z0 })[0]/*T:B<object?>.INone!*/;
        o = (new[] { z0, x0 })[0]/*T:B<object!>.INone!*/;
        o = (new[] { z0, y0 })[0]/*T:B<object?>.INone!*/;
        o = (new[] { z0, z0 })[0]/*T:B<object>.INone!*/;
    }
    static B<T>.I<U> CreateI<T, U>(T t, U u) => throw null;
    static void G1(B<object>.I<string> x1, B<object?>.I<string?> y1)
    {
        var z1 = CreateI(A.F1, A.F2)/*T:B<object>.I<string>!*/;
        object o;
        o = (new[] { x1, x1 })[0]/*T:B<object!>.I<string!>!*/;
        o = (new[] { x1, y1 })[0]/*T:B<object!>.I<string!>!*/; // 3
        o = (new[] { x1, z1 })[0]/*T:B<object!>.I<string!>!*/;
        o = (new[] { y1, x1 })[0]/*T:B<object!>.I<string!>!*/; // 4
        o = (new[] { y1, y1 })[0]/*T:B<object?>.I<string?>!*/;
        o = (new[] { y1, z1 })[0]/*T:B<object?>.I<string?>!*/;
        o = (new[] { z1, x1 })[0]/*T:B<object!>.I<string!>!*/;
        o = (new[] { z1, y1 })[0]/*T:B<object?>.I<string?>!*/;
        o = (new[] { z1, z1 })[0]/*T:B<object>.I<string>!*/;
    }
    static B<T>.IIn<U> CreateIIn<T, U>(T t, U u) => throw null;
    static void G2(B<object>.IIn<string> x2, B<object?>.IIn<string?> y2)
    {
        var z2 = CreateIIn(A.F1, A.F2)/*T:B<object>.IIn<string>!*/;
        object o;
        o = (new[] { x2, x2 })[0]/*T:B<object!>.IIn<string!>!*/;
        o = (new[] { x2, y2 })[0]/*T:B<object!>.IIn<string!>!*/; // 5
        o = (new[] { x2, z2 })[0]/*T:B<object!>.IIn<string!>!*/;
        o = (new[] { y2, x2 })[0]/*T:B<object!>.IIn<string!>!*/; // 6
        o = (new[] { y2, y2 })[0]/*T:B<object?>.IIn<string?>!*/;
        o = (new[] { y2, z2 })[0]/*T:B<object?>.IIn<string>!*/;
        o = (new[] { z2, x2 })[0]/*T:B<object!>.IIn<string!>!*/;
        o = (new[] { z2, y2 })[0]/*T:B<object?>.IIn<string>!*/;
        o = (new[] { z2, z2 })[0]/*T:B<object>.IIn<string>!*/;
    }
    static B<T>.IOut<U> CreateIOut<T, U>(T t, U u) => throw null;
    static void G3(B<object>.IOut<string> x3, B<object?>.IOut<string?> y3)
    {
        var z3 = CreateIOut(A.F1, A.F2)/*T:B<object>.IOut<string>!*/;
        object o;
        o = (new[] { x3, x3 })[0]/*T:B<object!>.IOut<string!>!*/;
        o = (new[] { x3, y3 })[0]/*T:B<object!>.IOut<string?>!*/; // 7
        o = (new[] { x3, z3 })[0]/*T:B<object!>.IOut<string>!*/;
        o = (new[] { y3, x3 })[0]/*T:B<object!>.IOut<string?>!*/; // 8
        o = (new[] { y3, y3 })[0]/*T:B<object?>.IOut<string?>!*/;
        o = (new[] { y3, z3 })[0]/*T:B<object?>.IOut<string?>!*/;
        o = (new[] { z3, x3 })[0]/*T:B<object!>.IOut<string>!*/;
        o = (new[] { z3, y3 })[0]/*T:B<object?>.IOut<string?>!*/;
        o = (new[] { z3, z3 })[0]/*T:B<object>.IOut<string>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (17,26): warning CS8619: Nullability of reference types in value of type 'B<object?>.INone' doesn't match target type 'B<object>.INone'.
                //         o = (new[] { x0, y0 })[0]/*T:B<object!>.INone!*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y0").WithArguments("B<object?>.INone", "B<object>.INone").WithLocation(17, 26),
                // (19,22): warning CS8619: Nullability of reference types in value of type 'B<object?>.INone' doesn't match target type 'B<object>.INone'.
                //         o = (new[] { y0, x0 })[0]/*T:B<object!>.INone!*/; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y0").WithArguments("B<object?>.INone", "B<object>.INone").WithLocation(19, 22),
                // (32,26): warning CS8619: Nullability of reference types in value of type 'B<object?>.I<string?>' doesn't match target type 'B<object>.I<string>'.
                //         o = (new[] { x1, y1 })[0]/*T:B<object!>.I<string!>!*/; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("B<object?>.I<string?>", "B<object>.I<string>").WithLocation(32, 26),
                // (34,22): warning CS8619: Nullability of reference types in value of type 'B<object?>.I<string?>' doesn't match target type 'B<object>.I<string>'.
                //         o = (new[] { y1, x1 })[0]/*T:B<object!>.I<string!>!*/; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("B<object?>.I<string?>", "B<object>.I<string>").WithLocation(34, 22),
                // (47,26): warning CS8619: Nullability of reference types in value of type 'B<object?>.IIn<string?>' doesn't match target type 'B<object>.IIn<string>'.
                //         o = (new[] { x2, y2 })[0]/*T:B<object!>.IIn<string!>!*/; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y2").WithArguments("B<object?>.IIn<string?>", "B<object>.IIn<string>").WithLocation(47, 26),
                // (49,22): warning CS8619: Nullability of reference types in value of type 'B<object?>.IIn<string?>' doesn't match target type 'B<object>.IIn<string>'.
                //         o = (new[] { y2, x2 })[0]/*T:B<object!>.IIn<string!>!*/; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y2").WithArguments("B<object?>.IIn<string?>", "B<object>.IIn<string>").WithLocation(49, 22),
                // (62,26): warning CS8619: Nullability of reference types in value of type 'B<object?>.IOut<string?>' doesn't match target type 'B<object>.IOut<string?>'.
                //         o = (new[] { x3, y3 })[0]/*T:B<object!>.IOut<string?>!*/; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y3").WithArguments("B<object?>.IOut<string?>", "B<object>.IOut<string?>").WithLocation(62, 26),
                // (64,22): warning CS8619: Nullability of reference types in value of type 'B<object?>.IOut<string?>' doesn't match target type 'B<object>.IOut<string?>'.
                //         o = (new[] { y3, x3 })[0]/*T:B<object!>.IOut<string?>!*/; // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y3").WithArguments("B<object?>.IOut<string?>", "B<object>.IOut<string?>").WithLocation(64, 22));
            comp.VerifyTypes();
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_NestedNullability_Tuples()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
class C
{
    static void F1(bool b, object x1, object? y1)
    {
        var z1 = A.F/*T:object*/;
        object o;
        o = (new[] { (x1, x1), (x1, y1) })[0]/*T:(object!, object?)*/;
        o = (new[] { (z1, x1), (x1, x1) })[0]/*T:(object, object!)*/;
        o = (new[] { (y1, y1), (y1, z1) })[0]/*T:(object?, object?)*/;
        o = (new[] { (x1, y1), (y1, y1) })[0]/*T:(object?, object?)*/;
        o = (new[] { (z1, z1), (z1, x1) })[0]/*T:(object, object)*/;
        o = (new[] { (y1, z1), (z1, z1) })[0]/*T:(object?, object)*/;
    }
    static I<T> CreateI<T>(T t) => throw null;
    static void F2(bool b, I<object> x2, I<object?> y2)
    {
        var z2 = CreateI(A.F)/*T:I<object>!*/;
        object o;
        o = (new[] { (x2, x2), (x2, y2) })[0]/*T:(I<object!>!, I<object!>!)*/; // 1
        o = (new[] { (z2, x2), (x2, x2) })[0]/*T:(I<object!>!, I<object!>!)*/;
        o = (new[] { (y2, y2), (y2, z2) })[0]/*T:(I<object?>!, I<object?>!)*/;
        o = (new[] { (x2, y2), (y2, y2) })[0]/*T:(I<object!>!, I<object?>!)*/; // 2
        o = (new[] { (z2, z2), (z2, x2) })[0]/*T:(I<object>!, I<object!>!)*/;
        o = (new[] { (y2, z2), (z2, z2) })[0]/*T:(I<object?>!, I<object>!)*/;

        o = (new[] { (x2, x2)!, (x2, y2) })[0]/*T:(I<object!>!, I<object!>!)*/;
        o = (new[] { (x2, y2), (y2, y2)! })[0]/*T:(I<object!>!, I<object?>!)*/;
    }
}";
            // Last two diagnostics should be suppressed
            // Tracked by https://github.com/dotnet/roslyn/issues/32553

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (20,32): warning CS8619: Nullability of reference types in value of type '(I<object> x2, I<object?> y2)' doesn't match target type '(I<object>, I<object>)'.
                //         o = (new[] { (x2, x2), (x2, y2) })[0]/*T:(I<object!>!, I<object!>!)*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x2, y2)").WithArguments("(I<object> x2, I<object?> y2)", "(I<object>, I<object>)").WithLocation(20, 32),
                // (23,32): warning CS8619: Nullability of reference types in value of type '(I<object?>, I<object?>)' doesn't match target type '(I<object>, I<object?>)'.
                //         o = (new[] { (x2, y2), (y2, y2) })[0]/*T:(I<object!>!, I<object?>!)*/; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(y2, y2)").WithArguments("(I<object?>, I<object?>)", "(I<object>, I<object?>)").WithLocation(23, 32),
                // (27,33): warning CS8619: Nullability of reference types in value of type '(I<object> x2, I<object?> y2)' doesn't match target type '(I<object>, I<object>)'.
                //         o = (new[] { (x2, x2)!, (x2, y2) })[0]/*T:(I<object!>!, I<object!>!)*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x2, y2)").WithArguments("(I<object> x2, I<object?> y2)", "(I<object>, I<object>)").WithLocation(27, 33),
                // (28,32): warning CS8619: Nullability of reference types in value of type '(I<object?>, I<object?>)' doesn't match target type '(I<object>, I<object?>)'.
                //         o = (new[] { (x2, y2), (y2, y2)! })[0]/*T:(I<object!>!, I<object?>!)*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(y2, y2)").WithArguments("(I<object?>, I<object?>)", "(I<object>, I<object?>)").WithLocation(28, 32));
            comp.VerifyTypes();
        }

        [Fact]
        public void ImplicitlyTypedArrayCreation_Empty()
        {
            var source =
@"class Program
{
    static void Main()
    {
        var a = new[] { };
        var b = new[] { null };
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (5,17): error CS0826: No best type found for implicitly-typed array
                //         var a = new[] { };
                Diagnostic(ErrorCode.ERR_ImplicitlyTypedArrayNoBestType, "new[] { }").WithLocation(5, 17),
                // (6,17): error CS0826: No best type found for implicitly-typed array
                //         var b = new[] { null };
                Diagnostic(ErrorCode.ERR_ImplicitlyTypedArrayNoBestType, "new[] { null }").WithLocation(6, 17));
        }

        [Fact]
        public void ExplicitlyTypedArrayCreation()
        {
            var source =
@"class C
{
    static void F(object x, object? y)
    {
        var a = new object[] { x, y };
        a[0].ToString();
        var b = new object?[] { x, y };
        b[0].ToString();
        var c = new object[] { x, y! };
        c[0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,35): warning CS8601: Possible null reference assignment.
                //         var a = new object[] { x, y };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y").WithLocation(5, 35),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         b[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b[0]").WithLocation(8, 9));
        }

        [Fact]
        public void IdentityConversion_ArrayInitializer_02()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(I<object> x, I<object?> y, I<object>? z, I<object?>? w)
    {
        (new[] { x, y })[0].ToString(); // A1
        (new[] { x, z })[0].ToString(); // A2
        (new[] { x, w })[0].ToString(); // A3
        (new[] { y, z })[0].ToString(); // A4
        (new[] { y, w })[0].ToString(); // A5
        (new[] { w, z })[0].ToString(); // A6
    }
    static void F(IIn<object> x, IIn<object?> y, IIn<object>? z, IIn<object?>? w)
    {
        (new[] { x, y })[0].ToString(); // B1
        (new[] { x, z })[0].ToString(); // B2
        (new[] { x, w })[0].ToString(); // B3
        (new[] { y, z })[0].ToString(); // B4
        (new[] { y, w })[0].ToString(); // B5
        (new[] { w, z })[0].ToString(); // B6
    }
    static void F(IOut<object> x, IOut<object?> y, IOut<object>? z, IOut<object?>? w)
    {
        (new[] { x, y })[0].ToString(); // C1
        (new[] { x, z })[0].ToString(); // C2
        (new[] { x, w })[0].ToString(); // C3
        (new[] { y, z })[0].ToString(); // C4
        (new[] { y, w })[0].ToString(); // C5
        (new[] { w, z })[0].ToString(); // C6
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,21): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         (new[] { x, y })[0].ToString(); // A1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(8, 21),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, z })[0].ToString(); // A2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, z })[0]").WithLocation(9, 9),
                // (10,21): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         (new[] { x, w })[0].ToString(); // A3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w").WithArguments("I<object?>", "I<object>").WithLocation(10, 21),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, w })[0].ToString(); // A3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, w })[0]").WithLocation(10, 9),
                // (11,18): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         (new[] { y, z })[0].ToString(); // A4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(11, 18),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, z })[0].ToString(); // A4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, z })[0]").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, w })[0].ToString(); // A5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, w })[0]").WithLocation(12, 9),
                // (13,18): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         (new[] { w, z })[0].ToString(); // A6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w").WithArguments("I<object?>", "I<object>").WithLocation(13, 18),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { w, z })[0].ToString(); // A6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { w, z })[0]").WithLocation(13, 9),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, z })[0].ToString(); // B2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, z })[0]").WithLocation(18, 9),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, w })[0].ToString(); // B3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, w })[0]").WithLocation(19, 9),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, z })[0].ToString(); // B4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, z })[0]").WithLocation(20, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, w })[0].ToString(); // B5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, w })[0]").WithLocation(21, 9),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { w, z })[0].ToString(); // B6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { w, z })[0]").WithLocation(22, 9),
                // (27,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, z })[0].ToString(); // C2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, z })[0]").WithLocation(27, 9),
                // (28,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, w })[0].ToString(); // C3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, w })[0]").WithLocation(28, 9),
                // (29,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, z })[0].ToString(); // C4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, z })[0]").WithLocation(29, 9),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, w })[0].ToString(); // C5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, w })[0]").WithLocation(30, 9),
                // (31,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { w, z })[0].ToString(); // C6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { w, z })[0]").WithLocation(31, 9));
        }

        [Fact]
        public void IdentityConversion_ArrayInitializer_IsNullableNull()
        {
            var source0 =
@"#pragma warning disable 8618
public class A<T>
{
    public T F;
}
public class B : A<object>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static void F(object? x, B b)
    {
        var y = b.F/*T:object*/;
        (new[] { x, x! })[0].ToString(); // 1
        (new[] { x!, x })[0].ToString(); // 2
        (new[] { x!, x! })[0].ToString();
        (new[] { y, y! })[0].ToString();
        (new[] { y!, y })[0].ToString();
        (new[] { x, y })[0].ToString(); // 3
        (new[] { x, y! })[0].ToString(); // 4
        (new[] { x!, y })[0].ToString();
        (new[] { x!, y! })[0].ToString();
    }
    static void F(A<object?> z, B w)
    {
        (new[] { z, z! })[0].F.ToString(); // 5
        (new[] { z!, z })[0].F.ToString(); // 6
        (new[] { z!, z! })[0].F.ToString(); // 7
        (new[] { w, w! })[0].F.ToString();
        (new[] { w!, w })[0].F.ToString();
        (new[] { z, w })[0].F.ToString(); // 8
        (new[] { z, w! })[0].F.ToString(); // 9
        (new[] { z!, w })[0].F.ToString(); // 10
        (new[] { z!, w! })[0].F.ToString(); // 11
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            // https://github.com/dotnet/roslyn/issues/30376: `!` should suppress conversion warnings.
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, x! })[0].ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, x! })[0]").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x!, x })[0].ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x!, x })[0]").WithLocation(7, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, y })[0].ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, y })[0]").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, y! })[0].ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, y! })[0]").WithLocation(12, 9),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z, z! })[0].F.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z, z! })[0].F").WithLocation(18, 9),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z!, z })[0].F.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z!, z })[0].F").WithLocation(19, 9),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z!, z! })[0].F.ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z!, z! })[0].F").WithLocation(20, 9),
                // (23,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z, w })[0].F.ToString(); // 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z, w })[0].F").WithLocation(23, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z, w! })[0].F.ToString(); // 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z, w! })[0].F").WithLocation(24, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z!, w })[0].F.ToString(); // 10
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z!, w })[0].F").WithLocation(25, 9),
                // (26,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { z!, w! })[0].F.ToString(); // 11
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { z!, w! })[0].F").WithLocation(26, 9));
        }

        [Fact]
        public void IdentityConversion_ArrayInitializer_ExplicitType()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(I<object>? x, I<object?>? y)
    {
        I<object?>?[] a = new[] { x };
        I<object?>[] b = new[] { y };
        I<object>?[] c = new[] { y };
        I<object>[] d = new[] { x };
    }
    static void F(IIn<object>? x, IIn<object?>? y)
    {
        IIn<object?>?[] a = new[] { x };
        IIn<object?>[] b = new[] { y };
        IIn<object>?[] c = new[] { y };
        IIn<object>[] d = new[] { x };
    }
    static void F(IOut<object>? x, IOut<object?>? y)
    {
        IOut<object?>?[] a = new[] { x };
        IOut<object?>[] b = new[] { y };
        IOut<object>?[] c = new[] { y };
        IOut<object>[] d = new[] { x };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,27): warning CS8619: Nullability of reference types in value of type 'I<object>?[]' doesn't match target type 'I<object?>?[]'.
                //         I<object?>?[] a = new[] { x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { x }").WithArguments("I<object>?[]", "I<object?>?[]").WithLocation(8, 27),
                // (9,26): warning CS8619: Nullability of reference types in value of type 'I<object?>?[]' doesn't match target type 'I<object?>[]'.
                //         I<object?>[] b = new[] { y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { y }").WithArguments("I<object?>?[]", "I<object?>[]").WithLocation(9, 26),
                // (10,26): warning CS8619: Nullability of reference types in value of type 'I<object?>?[]' doesn't match target type 'I<object>?[]'.
                //         I<object>?[] c = new[] { y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { y }").WithArguments("I<object?>?[]", "I<object>?[]").WithLocation(10, 26),
                // (11,25): warning CS8619: Nullability of reference types in value of type 'I<object>?[]' doesn't match target type 'I<object>[]'.
                //         I<object>[] d = new[] { x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { x }").WithArguments("I<object>?[]", "I<object>[]").WithLocation(11, 25),
                // (15,29): warning CS8619: Nullability of reference types in value of type 'IIn<object>?[]' doesn't match target type 'IIn<object?>?[]'.
                //         IIn<object?>?[] a = new[] { x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { x }").WithArguments("IIn<object>?[]", "IIn<object?>?[]").WithLocation(15, 29),
                // (16,28): warning CS8619: Nullability of reference types in value of type 'IIn<object?>?[]' doesn't match target type 'IIn<object?>[]'.
                //         IIn<object?>[] b = new[] { y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { y }").WithArguments("IIn<object?>?[]", "IIn<object?>[]").WithLocation(16, 28),
                // (18,27): warning CS8619: Nullability of reference types in value of type 'IIn<object>?[]' doesn't match target type 'IIn<object>[]'.
                //         IIn<object>[] d = new[] { x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { x }").WithArguments("IIn<object>?[]", "IIn<object>[]").WithLocation(18, 27),
                // (23,29): warning CS8619: Nullability of reference types in value of type 'IOut<object?>?[]' doesn't match target type 'IOut<object?>[]'.
                //         IOut<object?>[] b = new[] { y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { y }").WithArguments("IOut<object?>?[]", "IOut<object?>[]").WithLocation(23, 29),
                // (24,29): warning CS8619: Nullability of reference types in value of type 'IOut<object?>?[]' doesn't match target type 'IOut<object>?[]'.
                //         IOut<object>?[] c = new[] { y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { y }").WithArguments("IOut<object?>?[]", "IOut<object>?[]").WithLocation(24, 29),
                // (25,28): warning CS8619: Nullability of reference types in value of type 'IOut<object>?[]' doesn't match target type 'IOut<object>[]'.
                //         IOut<object>[] d = new[] { x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new[] { x }").WithArguments("IOut<object>?[]", "IOut<object>[]").WithLocation(25, 28));
        }

        [Fact]
        public void ImplicitConversion_ArrayInitializer_ExplicitType_01()
        {
            var source =
@"class A<T> { }
class B<T> : A<T> { }
class C
{
    static void F(A<object> x, B<object?> y)
    {
        var z = new A<object>[] { x, y };
        var w = new A<object?>[] { x, y };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,38): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         var z = new A<object>[] { x, y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("B<object?>", "A<object>").WithLocation(7, 38),
                // (8,36): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'A<object?>'.
                //         var w = new A<object?>[] { x, y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "A<object?>").WithLocation(8, 36));
        }

        [Fact]
        public void ImplicitConversion_ArrayInitializer_ExplicitType_02()
        {
            var source =
@"interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(IIn<object> x, IIn<object?> y)
    {
        var a = new IIn<string?>[] { x };
        var b = new IIn<string>[] { y };
    }
    static void F(IOut<string> x, IOut<string?> y)
    {
        var a = new IOut<object?>[] { x };
        var b = new IOut<object>[] { y };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,38): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<string?>'.
                //         var a = new IIn<string?>[] { x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IIn<object>", "IIn<string?>").WithLocation(7, 38),
                // (13,38): warning CS8619: Nullability of reference types in value of type 'IOut<string?>' doesn't match target type 'IOut<object>'.
                //         var b = new IOut<object>[] { y };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("IOut<string?>", "IOut<object>").WithLocation(13, 38));
        }

        [Fact]
        public void MultipleConversions_ArrayInitializer()
        {
            var source =
@"class A
{
    public static implicit operator C(A a) => new C();
}
class B : A
{
}
class C
{
    static void F(B x, C? y)
    {
        (new[] { x, y })[0].ToString();
        (new[] { y, x })[0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, y })[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, y })[0]").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, x })[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, x })[0]").WithLocation(13, 9));
        }

        [Fact]
        public void MultipleConversions_ArrayInitializer_ConversionWithNullableOutput()
        {
            var source =
@"class A
{
    public static implicit operator C?(A a) => new C();
}
class B : A
{
}
class C
{
    static void F(B x, C y)
    {
        (new[] { x, y })[0].ToString();
        (new[] { y, x })[0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { x, y })[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { x, y })[0]").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         (new[] { y, x })[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new[] { y, x })[0]").WithLocation(13, 9));
        }

        [Fact]
        public void MultipleConversions_ArrayInitializer_ConversionWithNullableInput()
        {
            var source =
@"class A
{
    public static implicit operator C(A? a) => new C();
}
class B : A
{
}
class C
{
    static void F(B? x, C y)
    {
        (new[] { x, y })[0].ToString();
        (new[] { y, x })[0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ObjectInitializer_01()
        {
            CSharpCompilation c = CreateCompilation(
new[] { @"#pragma warning disable 8618
class C
{
    static void Main()
    {}

    void Test1(CL1? x1, CL1? y1)
    {
        var z1 = new CL1() { F1 = x1, F2 = y1 };
    }

    void Test2(CL1? x2, CL1? y2)
    {
        var z2 = new CL1() { P1 = x2, P2 = y2 };
    }

    void Test3(CL1 x3, CL1 y3)
    {
        var z31 = new CL1() { F1 = x3, F2 = y3 };
        var z32 = new CL1() { P1 = x3, P2 = y3 };
    }
}

class CL1
{
    public CL1 F1;
    public CL1? F2;

    public CL1 P1 {get; set;}
    public CL1? P2 {get; set;}
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,35): warning CS8601: Possible null reference assignment.
                //         var z1 = new CL1() { F1 = x1, F2 = y1 };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x1").WithLocation(9, 35),
                // (14,35): warning CS8601: Possible null reference assignment.
                //         var z2 = new CL1() { P1 = x2, P2 = y2 };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x2").WithLocation(14, 35)
                );
        }

        [Fact]
        public void ObjectInitializer_02()
        {
            var source =
@"class C
{
    C(object o) { }
    static void F(object? x)
    {
        var y = new C(x);
        if (x != null) y = new C(x);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,23): warning CS8604: Possible null reference argument for parameter 'o' in 'C.C(object o)'.
                //         var y = new C(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("o", "C.C(object o)").WithLocation(6, 23));
        }

        [Fact]
        public void ObjectInitializer_03()
        {
            var source =
@"class A
{
    internal B F = new B();
}
class B
{
    internal object? G;
}
class C
{
    static void Main()
    {
        var o = new A() { F = { G = new object() } };
        o.F.G.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void IdentityConversion_ObjectElementInitializerArgumentsOrder()
        {
            var source =
@"interface I<T> { }
class C
{
    static C F(I<string> x, I<object> y)
    {
        return new C() { [
            y: y, // warn 1
            x: x]
            = 1 };
    }
    static object G(C c, I<string?> x, I<object?> y)
    {
        return new C() { [
            y: y,
            x: x] // warn 2
            = 2 };
    }
    int this[I<string> x, I<object?> y]
    {
        get { return 0; }
        set { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,16): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'int C.this[I<string> x, I<object?> y]'.
                //             y: y, // warn 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("I<object>", "I<object?>", "y", "int C.this[I<string> x, I<object?> y]").WithLocation(7, 16),
                // (15,16): warning CS8620: Nullability of reference types in argument of type 'I<string?>' doesn't match target type 'I<string>' for parameter 'x' in 'int C.this[I<string> x, I<object?> y]'.
                //             x: x] // warn 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<string?>", "I<string>", "x", "int C.this[I<string> x, I<object?> y]").WithLocation(15, 16));
        }

        [Fact]
        public void ImplicitConversion_CollectionInitializer()
        {
            var source =
@"using System.Collections.Generic;
class A<T> { }
class B<T> : A<T> { }
class C
{
    static void M(B<object>? x, B<object?> y)
    {
        var c = new List<A<object>>
        {
            x, // 1
            y, // 2
        };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8604: Possible null reference argument for parameter 'item' in 'void List<A<object>>.Add(A<object> item)'.
                //             x, // 1
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("item", "void List<A<object>>.Add(A<object> item)").WithLocation(10, 13),
                // (11,13): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'A<object>' for parameter 'item' in 'void List<A<object>>.Add(A<object> item)'.
                //             y, // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("B<object?>", "A<object>", "item", "void List<A<object>>.Add(A<object> item)").WithLocation(11, 13));
        }

        [Fact]
        public void Structs_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL1 x1)
    {
        S1 y1 = new S1();
        y1.F1 = x1;
        y1 = new S1();
        x1 = y1.F1;
    }

    void M1(ref S1 x) {}

    void Test2(CL1 x2)
    {
        S1 y2 = new S1();
        y2.F1 = x2;
        M1(ref y2);
        x2 = y2.F1;
    }

    void Test3(CL1 x3)
    {
        S1 y3 = new S1() { F1 = x3 };
        x3 = y3.F1;
    }

    void Test4(CL1 x4, CL1? z4)
    {
        var y4 = new S2() { F2 = new S1() { F1 = x4, F3 = z4 } };
        x4 = y4.F2.F1 ?? x4;
        x4 = y4.F2.F3;
    }

    void Test5(CL1 x5, CL1? z5)
    {
        var y5 = new S2() { F2 = new S1() { F1 = x5, F3 = z5 } };
        var u5 = y5.F2;
        x5 = u5.F1 ?? x5;
        x5 = u5.F3;
    }
}

class CL1
{
}

struct S1
{
    public CL1? F1;
    public CL1? F3;
}

struct S2
{
    public S1 F2;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         x1 = y1.F1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1.F1").WithLocation(12, 14),
                 // (22,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         x2 = y2.F1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y2.F1").WithLocation(22, 14),
                 // (34,14): hidden CS8607: Expression is probably never null.
                 //         x4 = y4.F2.F1 ?? x4;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y4.F2.F1").WithLocation(34, 14),
                 // (35,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         x4 = y4.F2.F3;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y4.F2.F3").WithLocation(35, 14),
                 // (42,14): hidden CS8607: Expression is probably never null.
                 //         x5 = u5.F1 ?? x5;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u5.F1").WithLocation(42, 14),
                 // (43,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         x5 = u5.F3;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u5.F3").WithLocation(43, 14)
                );
        }

        [Fact]
        public void Structs_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL1 x1)
    {
        S1 y1;
        y1.F1 = x1;
        S1 z1 = y1;
        x1 = z1.F3;
        x1 = z1.F3 ?? x1;
        z1.F3 = null;
    }

    struct Test2
    {
        S1 z2 {get;}

        public Test2(CL1 x2)
        {
            S1 y2;
            y2.F1 = x2;
            z2 = y2;
            x2 = z2.F3;
            x2 = z2.F3 ?? x2;
        }
    }

    void Test3(CL1 x3)
    {
        S1 y3;
        CL1? z3 = y3.F3;
        x3 = z3;
        x3 = z3 ?? x3;
    }

    void Test4(CL1 x4, CL1? z4)
    {
        S1 y4;
        z4 = y4.F3;
        x4 = z4;
        x4 = z4 ?? x4;
    }

    void Test5(CL1 x5)
    {
        S1 y5;
        var z5 = new { F3 = y5.F3 };
        x5 = z5.F3;
        x5 = z5.F3 ?? x5;
    }

    void Test6(CL1 x6, S1 z6)
    {
        S1 y6;
        y6.F1 = x6;
        z6 = y6;
        x6 = z6.F3;
        x6 = z6.F3 ?? x6;
    }

    void Test7(CL1 x7)
    {
        S1 y7;
        y7.F1 = x7;
        var z7 = new { F3 = y7 };
        x7 = z7.F3.F3;
        x7 = z7.F3.F3 ?? x7;
    }

    struct Test8
    {
        CL1? z8 {get;}

        public Test8(CL1 x8)
        {
            S1 y8;
            y8.F1 = x8;
            z8 = y8.F3;
            x8 = z8;
            x8 = z8 ?? x8;
        }
    }
}

class CL1
{
}

struct S1
{
    public CL1? F1;
    public CL1? F3;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (11,17): error CS0165: Use of unassigned local variable 'y1'
                //         S1 z1 = y1;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y1").WithArguments("y1").WithLocation(11, 17),
                // (25,18): error CS0165: Use of unassigned local variable 'y2'
                //             z2 = y2;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y2").WithArguments("y2").WithLocation(25, 18),
                // (34,19): error CS0170: Use of possibly unassigned field 'F3'
                //         CL1? z3 = y3.F3;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y3.F3").WithArguments("F3").WithLocation(34, 19),
                // (42,14): error CS0170: Use of possibly unassigned field 'F3'
                //         z4 = y4.F3;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y4.F3").WithArguments("F3").WithLocation(42, 14),
                // (50,29): error CS0170: Use of possibly unassigned field 'F3'
                //         var z5 = new { F3 = y5.F3 };
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y5.F3").WithArguments("F3").WithLocation(50, 29),
                // (59,14): error CS0165: Use of unassigned local variable 'y6'
                //         z6 = y6;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y6").WithArguments("y6").WithLocation(59, 14),
                // (68,29): error CS0165: Use of unassigned local variable 'y7'
                //         var z7 = new { F3 = y7 };
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y7").WithArguments("y7").WithLocation(68, 29),
                // (81,18): error CS0170: Use of possibly unassigned field 'F3'
                //             z8 = y8.F3;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "y8.F3").WithArguments("F3").WithLocation(81, 18)
                );
        }

        [Fact]
        public void Structs_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL1 x1)
    {
        x1 = new S1().F1;
    }

    void Test2(CL1 x2)
    {
        x2 = new S1() {F1 = x2}.F1;
    }

    void Test3(CL1 x3)
    {
        x3 = new S1() {F1 = x3}.F1 ?? x3;
    }

    void Test4(CL1 x4)
    {
        x4 = new S2().F2;
    }

    void Test5(CL1 x5)
    {
        x5 = new S2().F2 ?? x5;
    }
}

class CL1
{
}

struct S1
{
    public CL1? F1;
}

struct S2
{
    public CL1 F2;

    S2(CL1 x) { F2 = x; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x1 = new S1().F1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "new S1().F1").WithLocation(9, 14),
                // (19,14): hidden CS8607: Expression is probably never null.
                //         x3 = new S1() {F1 = x3}.F1 ?? x3;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new S1() {F1 = x3}.F1").WithLocation(19, 14),
                // (24,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x4 = new S2().F2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "new S2().F2").WithLocation(24, 14)
                );
        }

        [Fact]
        public void Structs_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}
}

struct TS2
{
    System.Action? E2;

    TS2(System.Action x2)
    {
        this = new TS2();
        System.Action z2 = E2;
        System.Action y2 = E2 ?? x2;
    }

    void Dummy()
    {
        E2 = null;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         System.Action z2 = E2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(15, 28)
                );
        }

        [Fact]
        [WorkItem(29889, "https://github.com/dotnet/roslyn/issues/29889")]
        public void AnonymousTypes_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL1 x1, CL1? z1)
    {
        var y1 = new { p1 = x1, p2 = z1 };
        x1 = y1.p1 ?? x1;
        x1 = y1.p2;
    }

    void Test2(CL1 x2, CL1? z2)
    {
        var u2 = new { p1 = x2, p2 = z2 };
        var v2 = new { p1 = z2, p2 = x2 };
        u2 = v2;
        x2 = u2.p2 ?? x2;
        x2 = u2.p1;
        x2 = v2.p2 ?? x2;
        x2 = v2.p1;
    }

    void Test3(CL1 x3, CL1? z3)
    {
        var u3 = new { p1 = x3, p2 = z3 };
        var v3 = u3;
        x3 = v3.p1 ?? x3;
        x3 = v3.p2;
    }

    void Test4(CL1 x4, CL1? z4)
    {
        var u4 = new { p0 = new { p1 = x4, p2 = z4 } };
        var v4 = new { p0 = new { p1 = z4, p2 = x4 } };
        u4 = v4;
        x4 = u4.p0.p2 ?? x4;
        x4 = u4.p0.p1;
        x4 = v4.p0.p2 ?? x4;
        x4 = v4.p0.p1;
    }

    void Test5(CL1 x5, CL1? z5)
    {
        var u5 = new { p0 = new { p1 = x5, p2 = z5 } };
        var v5 = u5;
        x5 = v5.p0.p1 ?? x5;
        x5 = v5.p0.p2;
    }

    void Test6(CL1 x6, CL1? z6)
    {
        var u6 = new { p0 = new { p1 = x6, p2 = z6 } };
        var v6 = u6.p0;
        x6 = v6.p1 ?? x6;
        x6 = v6.p2;
    }

    void Test7(CL1 x7, CL1? z7)
    {
        var u7 = new { p0 = new S1() { p1 = x7, p2 = z7 } };
        var v7 = new { p0 = new S1() { p1 = z7, p2 = x7 } };
        u7 = v7;
        x7 = u7.p0.p2 ?? x7;
        x7 = u7.p0.p1;
        x7 = v7.p0.p2 ?? x7;
        x7 = v7.p0.p1;
    }

    void Test8(CL1 x8, CL1? z8)
    {
        var u8 = new { p0 = new S1() { p1 = x8, p2 = z8 } };
        var v8 = u8;
        x8 = v8.p0.p1 ?? x8;
        x8 = v8.p0.p2;
    }

    void Test9(CL1 x9, CL1? z9)
    {
        var u9 = new { p0 = new S1() { p1 = x9, p2 = z9 } };
        var v9 = u9.p0;
        x9 = v9.p1 ?? x9;
        x9 = v9.p2;
    }

    void M1<T>(ref T x) {}

    void Test10(CL1 x10)
    {
        var u10 = new { a0 = x10, a1 = new { p1 = x10 }, a2 = new S1() { p2 = x10 } };
        x10 = u10.a0; // 1
        x10 = u10.a1.p1; // 2
        x10 = u10.a2.p2; // 3 

        M1(ref u10);

        x10 = u10.a0; // 4
        x10 = u10.a1.p1; // 5
        x10 = u10.a2.p2; // 6 
    }
}

class CL1
{
}

struct S1
{
    public CL1? p1;
    public CL1? p2;
}" }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29889: Why isn't u2 = v2 causing a warning?
            c.VerifyDiagnostics(
                // (10,14): hidden CS8607: Expression is probably never null.
                //         x1 = y1.p1 ?? x1;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y1.p1").WithLocation(10, 14),
                // (11,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x1 = y1.p2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1.p2").WithLocation(11, 14),
                // (19,14): hidden CS8607: Expression is probably never null.
                //         x2 = u2.p2 ?? x2;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u2.p2").WithLocation(19, 14),
                // (20,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x2 = u2.p1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u2.p1").WithLocation(20, 14),
                // (21,14): hidden CS8607: Expression is probably never null.
                //         x2 = v2.p2 ?? x2;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v2.p2").WithLocation(21, 14),
                // (22,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x2 = v2.p1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v2.p1").WithLocation(22, 14),
                // (29,14): hidden CS8607: Expression is probably never null.
                //         x3 = v3.p1 ?? x3;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v3.p1").WithLocation(29, 14),
                // (30,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x3 = v3.p2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v3.p2").WithLocation(30, 14),
                // (38,14): hidden CS8607: Expression is probably never null.
                //         x4 = u4.p0.p2 ?? x4;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4.p0.p2").WithLocation(38, 14),
                // (39,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x4 = u4.p0.p1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u4.p0.p1").WithLocation(39, 14),
                // (40,14): hidden CS8607: Expression is probably never null.
                //         x4 = v4.p0.p2 ?? x4;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v4.p0.p2").WithLocation(40, 14),
                // (41,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x4 = v4.p0.p1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v4.p0.p1").WithLocation(41, 14),
                // (48,14): hidden CS8607: Expression is probably never null.
                //         x5 = v5.p0.p1 ?? x5;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v5.p0.p1").WithLocation(48, 14),
                // (49,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x5 = v5.p0.p2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v5.p0.p2").WithLocation(49, 14),
                // (56,14): hidden CS8607: Expression is probably never null.
                //         x6 = v6.p1 ?? x6;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v6.p1").WithLocation(56, 14),
                // (57,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x6 = v6.p2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v6.p2").WithLocation(57, 14),
                // (65,14): hidden CS8607: Expression is probably never null.
                //         x7 = u7.p0.p2 ?? x7;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u7.p0.p2").WithLocation(65, 14),
                // (66,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x7 = u7.p0.p1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u7.p0.p1").WithLocation(66, 14),
                // (67,14): hidden CS8607: Expression is probably never null.
                //         x7 = v7.p0.p2 ?? x7;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v7.p0.p2").WithLocation(67, 14),
                // (68,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x7 = v7.p0.p1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v7.p0.p1").WithLocation(68, 14),
                // (75,14): hidden CS8607: Expression is probably never null.
                //         x8 = v8.p0.p1 ?? x8;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v8.p0.p1").WithLocation(75, 14),
                // (76,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x8 = v8.p0.p2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v8.p0.p2").WithLocation(76, 14),
                // (83,14): hidden CS8607: Expression is probably never null.
                //         x9 = v9.p1 ?? x9;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "v9.p1").WithLocation(83, 14),
                // (84,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x9 = v9.p2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "v9.p2").WithLocation(84, 14),
                // (98,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x10 = u10.a0; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u10.a0").WithLocation(98, 15),
                // (99,15): warning CS8602: Possible dereference of a null reference.
                //         x10 = u10.a1.p1; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u10.a1").WithLocation(99, 15),
                // (99,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x10 = u10.a1.p1; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u10.a1.p1").WithLocation(99, 15),
                // (100,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x10 = u10.a2.p2; // 6
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u10.a2.p2").WithLocation(100, 15)
                );
        }

        [Fact]
        public void AnonymousTypes_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL1? x1)
    {
        var y1 = new { p1 = x1 };
        y1.p1?.
               M1(y1.p1);
    }

    void Test2(CL1? x2)
    {
        var y2 = new { p1 = x2 };
        if (y2.p1 != null)
        {
            y2.p1.M1(y2.p1);
        }
    }

    void Test3(out CL1? x3, CL1 z3)
    {
        var y3 = new { p1 = x3 };
        x3 = y3.p1 ?? 
                      z3.M1(y3.p1);
        CL1 v3 = y3.p1;
    }
}

class CL1
{
    public CL1? M1(CL1 x) { return null; }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (25,29): error CS0269: Use of unassigned out parameter 'x3'
                 //         var y3 = new { p1 = x3 };
                 Diagnostic(ErrorCode.ERR_UseDefViolationOut, "x3").WithArguments("x3").WithLocation(25, 29)
                );
        }

        [Fact]
        public void AnonymousTypes_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test2(CL1 x2)
    {
        x2 = new {F1 = x2}.F1;
    }

    void Test3(CL1 x3)
    {
        x3 = new {F1 = x3}.F1 ?? x3;
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x3 = new {F1 = x3}.F1 ?? x3;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new {F1 = x3}.F1").WithLocation(14, 14)
                );
        }

        [Fact]
        public void AnonymousTypes_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL1<string> x1, CL1<string?> y1)
    {
        var u1 = new { F1 = x1 };
        var v1 = new { F1 = y1 };

        u1 = v1;
        v1 = u1;
    }
}

class CL1<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: CL1<string?> F1>' doesn't match target type '<anonymous type: CL1<string> F1>'.
                 //         u1 = v1;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "v1").WithArguments("<anonymous type: CL1<string?> F1>", "<anonymous type: CL1<string> F1>").WithLocation(12, 14),
                 // (13,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: CL1<string> F1>' doesn't match target type '<anonymous type: CL1<string?> F1>'.
                 //         v1 = u1;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "u1").WithArguments("<anonymous type: CL1<string> F1>", "<anonymous type: CL1<string?> F1>").WithLocation(13, 14)
                );
        }

        [Fact]
        [WorkItem(29889, "https://github.com/dotnet/roslyn/issues/29889")]
        public void AnonymousTypes_05()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F0(string x0, string? y0)
    {
        var a0 = new { F = x0 };
        var b0 = new { F = y0 };
        a0 = b0;
        b0 = a0;
    }
    static void F1(I<string> x1, I<string?> y1)
    {
        var a1 = new { F = x1 };
        var b1 = new { F = y1 };
        a1 = b1;
        b1 = a1;
    }
    static void F2(IIn<string> x2, IIn<string?> y2)
    {
        var a2 = new { F = x2 };
        var b2 = new { F = y2 };
        a2 = b2;
        b2 = a2;
    }
    static void F3(IOut<string> x3, IOut<string?> y3)
    {
        var a3 = new { F = x3 };
        var b3 = new { F = y3 };
        a3 = b3;
        b3 = a3;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29889: Should report a warning for `a0 = b0`.
            // https://github.com/dotnet/roslyn/issues/29889: Should not report a warning for `b3 = a3`.
            comp.VerifyDiagnostics(
                // (17,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: I<string?> F>' doesn't match target type '<anonymous type: I<string> F>'.
                //         a1 = b1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b1").WithArguments("<anonymous type: I<string?> F>", "<anonymous type: I<string> F>").WithLocation(17, 14),
                // (18,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: I<string> F>' doesn't match target type '<anonymous type: I<string?> F>'.
                //         b1 = a1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a1").WithArguments("<anonymous type: I<string> F>", "<anonymous type: I<string?> F>").WithLocation(18, 14),
                // (24,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: IIn<string?> F>' doesn't match target type '<anonymous type: IIn<string> F>'.
                //         a2 = b2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b2").WithArguments("<anonymous type: IIn<string?> F>", "<anonymous type: IIn<string> F>").WithLocation(24, 14),
                // (25,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: IIn<string> F>' doesn't match target type '<anonymous type: IIn<string?> F>'.
                //         b2 = a2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("<anonymous type: IIn<string> F>", "<anonymous type: IIn<string?> F>").WithLocation(25, 14),
                // (31,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: IOut<string?> F>' doesn't match target type '<anonymous type: IOut<string> F>'.
                //         a3 = b3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b3").WithArguments("<anonymous type: IOut<string?> F>", "<anonymous type: IOut<string> F>").WithLocation(31, 14),
                // (32,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: IOut<string> F>' doesn't match target type '<anonymous type: IOut<string?> F>'.
                //         b3 = a3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a3").WithArguments("<anonymous type: IOut<string> F>", "<anonymous type: IOut<string?> F>").WithLocation(32, 14));
        }

        [Fact]
        [WorkItem(29890, "https://github.com/dotnet/roslyn/issues/29890")]
        public void AnonymousTypes_06()
        {
            var source =
@"class C
{
    static void F(string x, string y)
    {
        x = new { x, y }.x ?? x;
        y = new { x, y = y }.y ?? y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29890: Should report ErrorCode.HDN_ExpressionIsProbablyNeverNull.
            // See comment in DefiniteAssignment.VisitAnonymousObjectCreationExpression.
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void AnonymousObjectCreation_01()
        {
            var source =
@"class C
{
    static void F(object? o)
    {
        (new { P = o }).P.ToString();
        if (o == null) return;
        (new { Q = o }).Q.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         (new { P = o }).P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new { P = o }).P").WithLocation(5, 9));
        }

        // https://github.com/dotnet/roslyn/issues/29891: NullableWalker.VisitAnonymousObjectCreationExpression
        // should support initializers with inferred nullability.
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29891")]
        [WorkItem(29891, "https://github.com/dotnet/roslyn/issues/29891")]
        public void AnonymousObjectCreation_02()
        {
            var source =
@"class C
{
    static void F(object? o)
    {
        (new { P = new[] { o }}).P[0].ToString();
        if (o == null) return;
        (new { Q = new[] { o }}).Q[0].ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         (new { P = new[] { o }}).P[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(new { P = new[] { o }}).P[0]").WithLocation(5, 9));
        }

        [Fact]
        public void This()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1()
    {
        this.Test2();
    }

    void Test2()
    {
        this?.Test1();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,9): hidden CS8607: Expression is probably never null.
                 //         this?.Test1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "this").WithLocation(14, 9)
                );
        }

        [Fact]
        public void ReadonlyAutoProperties_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C1
{
    static void Main()
    {
    }

    C1 P1 {get;}

    public C1(C1? x1)
    {
        P1 = x1;
    }
}

class C2
{
    C2? P2 {get;}

    public C2(C2 x2)
    {
        x2 = P2;
    }
}

class C3
{
    C3? P3 {get;}

    public C3(C3 x3, C3? y3)
    {
        P3 = y3;
        x3 = P3;
    }
}

class C4
{
    C4? P4 {get;}

    public C4(C4 x4)
    {
        P4 = x4;
        x4 = P4;
    }
}

class C5
{
    S1 P5 {get;}

    public C5(C0 x5)
    {
        P5 = new S1() { F1 = x5 };
        x5 = P5.F1;
    }
}

class C0
{}

struct S1
{
    public C0? F1;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (22,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x2 = P2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "P2").WithLocation(22, 14),
                // (33,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x3 = P3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "P3").WithLocation(33, 14),
                // (12,14): warning CS8601: Possible null reference assignment.
                //         P1 = x1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x1").WithLocation(12, 14)
                );
        }

        [Fact]
        public void ReadonlyAutoProperties_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
struct C1
{
    static void Main()
    {
    }

    C0 P1 {get;}

    public C1(C0? x1)
    {
        P1 = x1;
    }
}

struct C2
{
    C0? P2 {get;}

    public C2(C0 x2)
    {
        x2 = P2;
        P2 = null;
    }
}

struct C3
{
    C0? P3 {get;}

    public C3(C0 x3, C0? y3)
    {
        P3 = y3;
        x3 = P3;
    }
}

struct C4
{
    C0? P4 {get;}

    public C4(C0 x4)
    {
        P4 = x4;
        x4 = P4;
    }
}

struct C5
{
    S1 P5 {get;}

    public C5(C0 x5)
    {
        P5 = new S1() { F1 = x5 };
        x5 = P5.F1 ?? x5;
    }
}

class C0
{}

struct S1
{
    public C0? F1;
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,14): warning CS8601: Possible null reference assignment.
                //         P1 = x1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x1").WithLocation(12, 14),
                // (34,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x3 = P3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "P3").WithLocation(34, 14),
                // (22,14): error CS8079: Use of possibly unassigned auto-implemented property 'P2'
                //         x2 = P2;
                Diagnostic(ErrorCode.ERR_UseDefViolationProperty, "P2").WithArguments("P2").WithLocation(22, 14),
                // (56,14): hidden CS8607: Expression is probably never null.
                //         x5 = P5.F1 ?? x5;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "P5.F1").WithLocation(56, 14)
                );
        }

        [Fact]
        public void NotAssigned()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(object? x1)
    {
        CL1? y1;

        if (x1 == null)
        {
            y1 = null;
            return;
        }

        CL1 z1 = y1;
    }

    void Test2(object? x2, out CL1? y2)
    {
        if (x2 == null)
        {
            y2 = null;
            return;
        }

        CL1 z2 = y2;
        y2 = null;
    }
}

class CL1
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (17,18): error CS0165: Use of unassigned local variable 'y1'
                 //         CL1 z1 = y1;
                 Diagnostic(ErrorCode.ERR_UseDefViolation, "y1").WithArguments("y1").WithLocation(17, 18),
                 // (28,18): error CS0269: Use of unassigned out parameter 'y2'
                 //         CL1 z2 = y2;
                 Diagnostic(ErrorCode.ERR_UseDefViolationOut, "y2").WithArguments("y2").WithLocation(28, 18)
                );
        }

        [Fact]
        public void Lambda_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Func<CL1?> x1 = () => M1();
    }

    void Test2()
    {
        System.Func<CL1?> x2 = delegate { return M1(); };
    }

    delegate CL1? D1();

    void Test3()
    {
        D1 x3 = () => M1();
    }

    void Test4()
    {
        D1 x4 = delegate { return M1(); };
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void Lambda_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Action<CL1?> x1 = (p1) => p1 = M1();
    }

    delegate void D1(CL1? p);

    void Test3()
    {
        D1 x3 = (p3) => p3 = M1();
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void Lambda_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Func<CL1> x1 = () => M1();
    }

    void Test2()
    {
        System.Func<CL1> x2 = delegate { return M1(); };
    }

    delegate CL1 D1();

    void Test3()
    {
        D1 x3 = () => M1();
    }

    void Test4()
    {
        D1 x4 = delegate { return M1(); };
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,37): warning CS8603: Possible null reference return.
                 //         System.Func<CL1> x1 = () => M1();
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(12, 37),
                 // (17,49): warning CS8603: Possible null reference return.
                 //         System.Func<CL1> x2 = delegate { return M1(); };
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(17, 49),
                 // (24,23): warning CS8603: Possible null reference return.
                 //         D1 x3 = () => M1();
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(24, 23),
                 // (29,35): warning CS8603: Possible null reference return.
                 //         D1 x4 = delegate { return M1(); };
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(29, 35)
                );
        }

        [Fact]
        public void Lambda_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Action<CL1> x1 = (p1) => p1 = M1();
    }

    delegate void D1(CL1 p);

    void Test3()
    {
        D1 x3 = (p3) => p3 = M1();
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,46): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         System.Action<CL1> x1 = (p1) => p1 = M1();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(12, 46),
                 // (19,30): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         D1 x3 = (p3) => p3 = M1();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(19, 30)
                );
        }

        [Fact]
        public void Lambda_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }
    delegate CL1 D1();
    delegate CL1? D2();

    void M2(int x, D1 y) {}
    void M2(long x, D2 y) {}

    void M3(long x, D2 y) {}
    void M3(int x, D1 y) {}

    void Test1(int x1)
    {
        M2(x1, () => M1());
    }

    void Test2(int x2)
    {
        M3(x2, () => M1());
    }

    void Test3(int x3)
    {
        M2(x3, delegate { return M1(); });
    }

    void Test4(int x4)
    {
        M3(x4, delegate { return M1(); });
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (20,22): warning CS8603: Possible null reference return.
                 //         M2(x1, () => M1());
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(20, 22),
                 // (25,22): warning CS8603: Possible null reference return.
                 //         M3(x2, () => M1());
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(25, 22),
                 // (30,34): warning CS8603: Possible null reference return.
                 //         M2(x3, delegate { return M1(); });
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(30, 34),
                 // (35,34): warning CS8603: Possible null reference return.
                 //         M3(x4, delegate { return M1(); });
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(35, 34)
                );
        }

        [Fact]
        public void Lambda_06()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }
    delegate CL1 D1();
    delegate CL1? D2();

    void M2(int x, D2 y) {}
    void M2(long x, D1 y) {}

    void M3(long x, D1 y) {}
    void M3(int x, D2 y) {}

    void Test1(int x1)
    {
        M2(x1, () => M1());
    }

    void Test2(int x2)
    {
        M3(x2, () => M1());
    }

    void Test3(int x3)
    {
        M2(x3, delegate { return M1(); });
    }

    void Test4(int x4)
    {
        M3(x4, delegate { return M1(); });
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void Lambda_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }
    delegate T D<T>();

    void M2(int x, D<CL1> y) {}
    void M2<T>(int x, D<T> y) {}

    void M3<T>(int x, D<T> y) {}
    void M3(int x, D<CL1> y) {}

    void Test1(int x1)
    {
        M2(x1, () => M1());
    }

    void Test2(int x2)
    {
        M3(x2, () => M1());
    }

    void Test3(int x3)
    {
        M2(x3, delegate { return M1(); });
    }

    void Test4(int x4)
    {
        M3(x4, delegate { return M1(); });
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (19,22): warning CS8603: Possible null reference return.
                 //         M2(x1, () => M1());
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(19, 22),
                 // (24,22): warning CS8603: Possible null reference return.
                 //         M3(x2, () => M1());
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(24, 22),
                 // (29,34): warning CS8603: Possible null reference return.
                 //         M2(x3, delegate { return M1(); });
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(29, 34),
                 // (34,34): warning CS8603: Possible null reference return.
                 //         M3(x4, delegate { return M1(); });
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "M1()").WithLocation(34, 34)
                );
        }

        [Fact]
        public void Lambda_08()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }
    delegate T D<T>();

    void M2(int x, D<CL1?> y) {}
    void M2<T>(int x, D<T> y) {}

    void M3<T>(int x, D<T> y) {}
    void M3(int x, D<CL1?> y) {}

    void Test1(int x1)
    {
        M2(x1, () => M1());
    }

    void Test2(int x2)
    {
        M3(x2, () => M1());
    }

    void Test3(int x3)
    {
        M2(x3, delegate { return M1(); });
    }

    void Test4(int x4)
    {
        M3(x4, delegate { return M1(); });
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void Lambda_09()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }
    delegate T1 D<T1, T2>(T2 y);

    void M2(int x, D<CL1, CL1> y) {}
    void M2<T>(int x, D<T, CL1> y) {}

    void M3<T>(int x, D<T, CL1> y) {}
    void M3(int x, D<CL1, CL1> y) {}

    void Test1(int x1)
    {
        M2(x1, (y1) => 
                {
                    y1 = M1();
                    return y1;
                });
    }

    void Test2(int x2)
    {
        M3(x2, (y2) => 
                {
                    y2 = M1();
                    return y2;
                });
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (21,26): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //                     y1 = M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(21, 26),
                // (22,28): warning CS8603: Possible null reference return.
                //                     return y1;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y1").WithLocation(22, 28),
                // (30,26): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //                     y2 = M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(30, 26),
                // (31,28): warning CS8603: Possible null reference return.
                //                     return y2;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y2").WithLocation(31, 28)
                );
        }

        [Fact]
        public void Lambda_10()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }
    delegate T1 D<T1, T2>(T2 y);

    void M2(int x, D<CL1, CL1?> y) {}
    void M2<T>(int x, D<T, CL1> y) {}

    void M3<T>(int x, D<T, CL1> y) {}
    void M3(int x, D<CL1, CL1?> y) {}

    void Test1(int x1)
    {
        M2(x1, (y1) => 
                {
                    y1 = M1();
                    return y1;
                });
    }

    void Test2(int x2)
    {
        M3(x2, (y2) => 
                {
                    y2 = M1();
                    return y2;
                });
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (22,28): warning CS8603: Possible null reference return.
                 //                     return y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y1").WithLocation(22, 28),
                 // (31,28): warning CS8603: Possible null reference return.
                 //                     return y2;
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y2").WithLocation(31, 28)
                );
        }

        [Fact]
        public void Lambda_11()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Action<CL1> x1 = (CL1 p1) => p1 = M1();
    }

    void Test2()
    {
        System.Action<CL1> x2 = delegate (CL1 p2) { p2 = M1(); };
    }

    delegate void D1(CL1 p);

    void Test3()
    {
        D1 x3 = (CL1 p3) => p3 = M1();
    }

    void Test4()
    {
        D1 x4 = delegate (CL1 p4) { p4 = M1(); };
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,50): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         System.Action<CL1> x1 = (CL1 p1) => p1 = M1();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(12, 50),
                 // (17,58): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         System.Action<CL1> x2 = delegate (CL1 p2) { p2 = M1(); };
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(17, 58),
                 // (24,34): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         D1 x3 = (CL1 p3) => p3 = M1();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(24, 34),
                 // (29,42): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         D1 x4 = delegate (CL1 p4) { p4 = M1(); };
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(29, 42)
                );
        }

        [Fact]
        public void Lambda_12()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Action<CL1?> x1 = (CL1 p1) => p1 = M1();
    }

    void Test2()
    {
        System.Action<CL1?> x2 = delegate (CL1 p2) { p2 = M1(); };
    }

    delegate void D1(CL1? p);

    void Test3()
    {
        D1 x3 = (CL1 p3) => p3 = M1();
    }

    void Test4()
    {
        D1 x4 = delegate (CL1 p4) { p4 = M1(); };
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,51): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         System.Action<CL1?> x1 = (CL1 p1) => p1 = M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(12, 51),
                // (12,34): warning CS8622: Nullability of reference types in type of parameter 'p1' of 'lambda expression' doesn't match the target delegate 'Action<CL1?>'.
                //         System.Action<CL1?> x1 = (CL1 p1) => p1 = M1();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1 p1) => p1 = M1()").WithArguments("p1", "lambda expression", "System.Action<CL1?>").WithLocation(12, 34),
                // (17,59): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         System.Action<CL1?> x2 = delegate (CL1 p2) { p2 = M1(); };
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(17, 59),
                // (17,34): warning CS8622: Nullability of reference types in type of parameter 'p2' of 'anonymous method' doesn't match the target delegate 'Action<CL1?>'.
                //         System.Action<CL1?> x2 = delegate (CL1 p2) { p2 = M1(); };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "delegate (CL1 p2) { p2 = M1(); }").WithArguments("p2", "anonymous method", "System.Action<CL1?>").WithLocation(17, 34),
                // (24,34): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         D1 x3 = (CL1 p3) => p3 = M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(24, 34),
                // (24,17): warning CS8622: Nullability of reference types in type of parameter 'p3' of 'lambda expression' doesn't match the target delegate 'C.D1'.
                //         D1 x3 = (CL1 p3) => p3 = M1();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1 p3) => p3 = M1()").WithArguments("p3", "lambda expression", "C.D1").WithLocation(24, 17),
                // (29,42): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         D1 x4 = delegate (CL1 p4) { p4 = M1(); };
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "M1()").WithLocation(29, 42),
                // (29,17): warning CS8622: Nullability of reference types in type of parameter 'p4' of 'anonymous method' doesn't match the target delegate 'C.D1'.
                //         D1 x4 = delegate (CL1 p4) { p4 = M1(); };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "delegate (CL1 p4) { p4 = M1(); }").WithArguments("p4", "anonymous method", "C.D1").WithLocation(29, 17)
                );
        }

        [Fact]
        public void Lambda_13()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Action<CL1> x1 = (CL1? p1) => p1 = M1();
    }

    void Test2()
    {
        System.Action<CL1> x2 = delegate (CL1? p2) { p2 = M1(); };
    }

    delegate void D1(CL1 p);

    void Test3()
    {
        D1 x3 = (CL1? p3) => p3 = M1();
    }

    void Test4()
    {
        D1 x4 = delegate (CL1? p4) { p4 = M1(); };
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,33): warning CS8622: Nullability of reference types in type of parameter 'p1' of 'lambda expression' doesn't match the target delegate 'Action<CL1>'.
                //         System.Action<CL1> x1 = (CL1? p1) => p1 = M1();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1? p1) => p1 = M1()").WithArguments("p1", "lambda expression", "System.Action<CL1>").WithLocation(12, 33),
                // (17,33): warning CS8622: Nullability of reference types in type of parameter 'p2' of 'anonymous method' doesn't match the target delegate 'Action<CL1>'.
                //         System.Action<CL1> x2 = delegate (CL1? p2) { p2 = M1(); };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "delegate (CL1? p2) { p2 = M1(); }").WithArguments("p2", "anonymous method", "System.Action<CL1>").WithLocation(17, 33),
                // (24,17): warning CS8622: Nullability of reference types in type of parameter 'p3' of 'lambda expression' doesn't match the target delegate 'C.D1'.
                //         D1 x3 = (CL1? p3) => p3 = M1();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1? p3) => p3 = M1()").WithArguments("p3", "lambda expression", "C.D1").WithLocation(24, 17),
                // (29,17): warning CS8622: Nullability of reference types in type of parameter 'p4' of 'anonymous method' doesn't match the target delegate 'C.D1'.
                //         D1 x4 = delegate (CL1? p4) { p4 = M1(); };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "delegate (CL1? p4) { p4 = M1(); }").WithArguments("p4", "anonymous method", "C.D1").WithLocation(29, 17)
                );
        }

        [Fact]
        public void Lambda_14()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL1? M1() { return null; }

    void Test1()
    {
        System.Action<CL1?> x1 = (CL1? p1) => p1 = M1();
    }

    void Test2()
    {
        System.Action<CL1?> x2 = delegate (CL1? p2) { p2 = M1(); };
    }

    delegate void D1(CL1? p);

    void Test3()
    {
        D1 x3 = (CL1? p3) => p3 = M1();
    }

    void Test4()
    {
        D1 x4 = delegate (CL1? p4) { p4 = M1(); };
    }
}

class CL1
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void Lambda_15()
        {
            CSharpCompilation notAnnotated = CreateCompilation(@"
public class CL0 
{
    public static void M1(System.Func<CL1<CL0>, CL0> x) {}
}

public class CL1<T>
{
    public T F1;

    public CL1()
    {
        F1 = default(T);
    }
}
", options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CSharpCompilation c = CreateCompilation(new[] { @"
class C 
{
    static void Main() {}

    static void Test1()
    {
        CL0.M1(p1 =>
                {
                    p1.F1 = null;
                    p1 = null;
                    return null;
                });
    }

    static void Test2()
    {
        System.Func<CL1<CL0>, CL0> l2 = p2 =>
                {
                    p2.F1 = null; // 1
                    p2 = null; // 2
                    return null; // 3
                };
    }
}
" }, options: WithNonNullTypesTrue(), references: new[] { notAnnotated.EmitToImageReference() });

            c.VerifyDiagnostics(
                // (20,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //                     p2.F1 = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(20, 29),
                // (21,26): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //                     p2 = null; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(21, 26),
                // (22,28): warning CS8603: Possible null reference return.
                //                     return null; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(22, 28)
                );
        }

        [Fact]
        public void Lambda_16()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1()
    {
        System.Action<CL1<string?>> x1 = (CL1<string> p1) => System.Console.WriteLine();
    }

    void Test2()
    {
        System.Action<CL1<string>> x2 = (CL1<string?> p2) => System.Console.WriteLine();
    }
}

class CL1<T>
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,42): warning CS8622: Nullability of reference types in type of parameter 'p1' of 'lambda expression' doesn't match the target delegate 'Action<CL1<string?>>'.
                 //         System.Action<CL1<string?>> x1 = (CL1<string> p1) => System.Console.WriteLine();
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1<string> p1) => System.Console.WriteLine()").WithArguments("p1", "lambda expression", "System.Action<CL1<string?>>").WithLocation(10, 42),
                 // (15,41): warning CS8622: Nullability of reference types in type of parameter 'p2' of 'lambda expression' doesn't match the target delegate 'Action<CL1<string>>'.
                 //         System.Action<CL1<string>> x2 = (CL1<string?> p2) => System.Console.WriteLine();
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1<string?> p2) => System.Console.WriteLine()").WithArguments("p2", "lambda expression", "System.Action<CL1<string>>").WithLocation(15, 41)
                );
        }

        [Fact]
        public void Lambda_17()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
using System.Linq.Expressions;

class C
{
    static void Main()
    {
    }

    void Test1()
    {
        Expression<System.Action<CL1<string?>>> x1 = (CL1<string> p1) => System.Console.WriteLine();
    }

    void Test2()
    {
        Expression<System.Action<CL1<string>>> x2 = (CL1<string?> p2) => System.Console.WriteLine();
    }
}

class CL1<T>
{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,54): warning CS8622: Nullability of reference types in type of parameter 'p1' of 'lambda expression' doesn't match the target delegate 'Action<CL1<string?>>'.
                 //         Expression<System.Action<CL1<string?>>> x1 = (CL1<string> p1) => System.Console.WriteLine();
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1<string> p1) => System.Console.WriteLine()").WithArguments("p1", "lambda expression", "System.Action<CL1<string?>>").WithLocation(12, 54),
                 // (17,53): warning CS8622: Nullability of reference types in type of parameter 'p2' of 'lambda expression' doesn't match the target delegate 'Action<CL1<string>>'.
                 //         Expression<System.Action<CL1<string>>> x2 = (CL1<string?> p2) => System.Console.WriteLine();
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(CL1<string?> p2) => System.Console.WriteLine()").WithArguments("p2", "lambda expression", "System.Action<CL1<string>>").WithLocation(17, 53)
                );
        }

        [Fact]
        public void Lambda_18()
        {
            var source =
@"delegate T D<T>(T t) where T : class;
class C
{
    static void F()
    {
        var d1 = (D<string?>)((string s1) => { s1 = null; return s1; });
        var d2 = (D<string>)((string? s2) => { s2.ToString(); return s2; });

        // suppressed
        var d3 = (D<string?>)((string s1) => { s1 = null; return s1; }!);
        var d4 = (D<string>)((string? s2) => { s2.ToString(); return s2; }!);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,18): warning CS8622: Nullability of reference types in type of parameter 's1' of 'lambda expression' doesn't match the target delegate 'D<string?>'.
                //         var d1 = (D<string?>)((string s1) => { s1 = null; return s1; });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(D<string?>)((string s1) => { s1 = null; return s1; })").WithArguments("s1", "lambda expression", "D<string?>").WithLocation(6, 18),
                // (6,21): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'D<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         var d1 = (D<string?>)((string s1) => { s1 = null; return s1; });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("D<T>", "T", "string?").WithLocation(6, 21),
                // (6,53): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var d1 = (D<string?>)((string s1) => { s1 = null; return s1; });
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(6, 53),
                // (7,18): warning CS8622: Nullability of reference types in type of parameter 's2' of 'lambda expression' doesn't match the target delegate 'D<string>'.
                //         var d2 = (D<string>)((string? s2) => { s2.ToString(); return s2; });
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(D<string>)((string? s2) => { s2.ToString(); return s2; })").WithArguments("s2", "lambda expression", "D<string>").WithLocation(7, 18),
                // (7,48): warning CS8602: Possible dereference of a null reference.
                //         var d2 = (D<string>)((string? s2) => { s2.ToString(); return s2; });
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(7, 48),
                // (10,21): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'D<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         var d3 = (D<string?>)((string s1) => { s1 = null; return s1; }!);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("D<T>", "T", "string?").WithLocation(10, 21),
                // (10,53): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var d3 = (D<string?>)((string s1) => { s1 = null; return s1; }!);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(10, 53),
                // (11,48): warning CS8602: Possible dereference of a null reference.
                //         var d4 = (D<string>)((string? s2) => { s2.ToString(); return s2; }!);
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2").WithLocation(11, 48)
                );
        }

        /// <summary>
        /// To track nullability of captured variables inside and outside a lambda,
        /// the lambda should be considered executed at the location the lambda
        /// is converted to a delegate.
        /// </summary>
        [Fact]
        public void Lambda_19()
        {
            var source =
@"using System;
class C
{
    static void F1(object? x1, object y1)
    {
        object z1 = y1;
        Action f = () =>
        {
            z1 = x1; // warning
        };
        f();
        z1.ToString();
    }
    static void F2(object? x2, object y2)
    {
        object z2 = x2; // warning
        Action f = () =>
        {
            z2 = y2;
        };
        f();
        z2.ToString(); // warning
    }
    static void F3(object? x3, object y3)
    {
        object z3 = y3;
        if (x3 == null) return;
        Action f = () =>
        {
            z3 = x3; // warning
        };
        f();
        z3.ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/29617: For captured variables, the lambda should be
            // considered executed at the location the lambda is converted to a delegate.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             z1 = x1; // warning
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(9, 18),
                // (16,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object z2 = x2; // warning
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(16, 21),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         z2.ToString(); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z2").WithLocation(22, 9),
                // (30,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             z3 = x3; // warning
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(30, 18));
        }

        [Fact]
        public void LambdaReturnValue_01()
        {
            var source =
@"using System;
class C
{
    static void F(Func<object> f)
    {
    }
    static void G(string x, object? y)
    {
        F(() => { if ((object)x == y) return x; return y; });
        F(() => { if (y == null) return x; return y; });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,56): warning CS8603: Possible null reference return.
                //         F(() => { if ((object)x == y) return x; return y; });
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y").WithLocation(9, 56));
        }

        [Fact]
        public void LambdaReturnValue_02()
        {
            var source =
@"using System;
class C
{
    static void F(Func<object> f)
    {
    }
    static void G(bool b, object x, string? y)
    {
        F(() => { if (b) return x; return y; });
        F(() => { if (b) return y; return x; });
    }
    static void H(bool b, object? x, string y)
    {
        F(() => { if (b) return x; return y; });
        F(() => { if (b) return y; return x; });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,43): warning CS8603: Possible null reference return.
                //         F(() => { if (b) return x; return y; });
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y").WithLocation(9, 43),
                // (10,33): warning CS8603: Possible null reference return.
                //         F(() => { if (b) return y; return x; });
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y").WithLocation(10, 33),
                // (14,33): warning CS8603: Possible null reference return.
                //         F(() => { if (b) return x; return y; });
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "x").WithLocation(14, 33),
                // (15,43): warning CS8603: Possible null reference return.
                //         F(() => { if (b) return y; return x; });
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "x").WithLocation(15, 43));
        }

        [Fact]
        public void LambdaReturnValue_03()
        {
            var source =
@"using System;
class C
{
    static T F<T>(Func<T> f)
    {
        throw null;
    }
    static void G(bool b, object x, string? y)
    {
        F(() => { if (b) return x; return y; }).ToString();
    }
    static void H(bool b, object? x, string y)
    {
        F(() => { if (b) return x; return y; }).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => { if (b) return x; return y; }).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => { if (b) return x; return y; })").WithLocation(10, 9),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => { if (b) return x; return y; }).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => { if (b) return x; return y; })").WithLocation(14, 9));
        }

        [Fact]
        public void LambdaReturnValue_04()
        {
            var source =
@"using System;
class C
{
    static T F<T>(Func<T> f)
    {
        throw null;
    }
    static void G(object? o)
    {
        F(() => o).ToString();
        if (o != null) F(() => o).ToString();
        F(() => { return o; }).ToString();
        if (o != null) F(() => { return o; }).ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/29617: For captured variables, the lambda should be
            // considered executed at the location the lambda is converted to a delegate.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => o).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => o)").WithLocation(10, 9),
                // (11,24): warning CS8602: Possible dereference of a null reference.
                //         if (o != null) F(() => o).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => o)").WithLocation(11, 24),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => { return o; }).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => { return o; })").WithLocation(12, 9),
                // (13,24): warning CS8602: Possible dereference of a null reference.
                //         if (o != null) F(() => { return o; }).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => { return o; })").WithLocation(13, 24));
        }

        [Fact]
        public void LambdaReturnValue_05()
        {
            var source =
@"using System;
class C
{
    static T F<T>(Func<object?, T> f)
    {
        throw null;
    }
    static void G()
    {
        F(o => { if (o == null) throw new ArgumentException(); return o; }).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void LambdaReturnValue_05_WithSuppression()
        {
            var source =
@"using System;
class C
{
    static T F<T>(Func<object?, T> f)
    {
        throw null;
    }
    static void G()
    {
        F(o => { if (o == null) throw new ArgumentException(); return o; }!).ToString();
    }
}";
            // covers suppression case in InferReturnType
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void LambdaReturnValue_06()
        {
            var source =
@"using System;
class C
{
    static U F<T, U>(Func<T, U> f, T t)
    {
        return f(t);
    }
    static void M(object? x)
    {
        F(y => F(z => z, y), x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(y => F(z => z, y), x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y => F(z => z, y), x)").WithLocation(10, 9));
        }

        [WorkItem(27961, "https://github.com/dotnet/roslyn/issues/27961")]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        [WorkItem(30480, "https://github.com/dotnet/roslyn/issues/30480")]
        [Fact]
        public void LambdaReturnValue_NestedNullability_Invariant()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"using System;
class B<T> { }
class C
{
    static T F<T>(Func<int, T> f) => throw null;
    static B<T> Create<T>(T t) => throw null;
    static void F(B<object?> x, B<object> y)
    {
        var z = Create(A.F)/*T:B<object>!*/;
        F(i => { switch (i) { case 0: return x; default: return x; }})/*T:B<object?>!*/;
        F(i => { switch (i) { case 0: return x; default: return y; }})/*T:B<object!>!*/; // 1
        F(i => { switch (i) { case 0: return x; default: return z; }})/*T:B<object?>*/;
        F(i => { switch (i) { case 0: return y; default: return x; }})/*T:B<object!>!*/; // 2
        F(i => { switch (i) { case 0: return y; default: return y; }})/*T:B<object!>!*/;
        F(i => { switch (i) { case 0: return y; default: return z; }})/*T:B<object!>*/;
        F(i => { switch (i) { case 0: return z; default: return x; }})/*T:B<object?>*/;
        F(i => { switch (i) { case 0: return z; default: return y; }})/*T:B<object!>*/;
        F(i => { switch (i) { case 0: return z; default: return z; }})/*T:B<object>*/;
        F(i => { switch (i) { case 0: return x; case 1: return y; default: return z; }})/*T:B<object!>*/; // 3
        F(i => { switch (i) { case 0: return z; case 1: return y; default: return x; }})/*T:B<object!>*/; // 4
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,46): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         F(i => { switch (i) { case 0: return x; default: return y; }})/*T:B<object>*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(11, 46),
                // (13,65): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         F(i => { switch (i) { case 0: return y; default: return x; }})/*T:B<object>*/; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(13, 65),
                // (19,46): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         F(i => { switch (i) { case 0: return x; case 1: return y; default: return z; }})/*T:B<object>*/; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(19, 46),
                // (20,83): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         F(i => { switch (i) { case 0: return z; case 1: return y; default: return x; }})/*T:B<object>*/; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(20, 83)
                );
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void LambdaReturnValue_NestedNullability_Variant_01()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"using System;
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(Func<bool, T> f) => throw null;
    static I<T> CreateI<T>(T t) => throw null;
    static void F1(I<object> x, I<object?> y)
    {
        var z = CreateI(A.F)/*T:I<object>!*/;
        F(b => { if (b) return x; else return x; })/*T:I<object!>!*/;
        F(b => { if (b) return x; else return y; })/*T:I<object!>!*/;
        F(b => { if (b) return x; else return z; })/*T:I<object!>*/;
        F(b => { if (b) return y; else return x; })/*T:I<object!>!*/;
        F(b => { if (b) return y; else return y; })/*T:I<object?>!*/;
        F(b => { if (b) return y; else return z; })/*T:I<object?>*/;
        F(b => { if (b) return z; else return x; })/*T:I<object!>*/;
        F(b => { if (b) return z; else return y; })/*T:I<object?>*/;
        F(b => { if (b) return z; else return z; })/*T:I<object>*/;
    }
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static void F2(IIn<object> x, IIn<object?> y)
    {
        var z = CreateIIn(A.F)/*T:IIn<object>!*/;
        F(b => { if (b) return x; else return x; })/*T:IIn<object!>!*/;
        F(b => { if (b) return x; else return y; })/*T:IIn<object!>!*/;
        F(b => { if (b) return x; else return z; })/*T:IIn<object!>*/;
        F(b => { if (b) return y; else return x; })/*T:IIn<object!>!*/;
        F(b => { if (b) return y; else return y; })/*T:IIn<object?>!*/;
        F(b => { if (b) return y; else return z; })/*T:IIn<object>*/;
        F(b => { if (b) return z; else return x; })/*T:IIn<object!>*/;
        F(b => { if (b) return z; else return y; })/*T:IIn<object>*/;
        F(b => { if (b) return z; else return z; })/*T:IIn<object>*/;
    }
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void F3(IOut<object> x, IOut<object?> y)
    {
        var z = CreateIOut(A.F)/*T:IOut<object>!*/;
        F(b => { if (b) return x; else return x; })/*T:IOut<object!>!*/;
        F(b => { if (b) return x; else return y; })/*T:IOut<object?>!*/;
        F(b => { if (b) return x; else return z; })/*T:IOut<object>*/;
        F(b => { if (b) return y; else return x; })/*T:IOut<object?>!*/;
        F(b => { if (b) return y; else return y; })/*T:IOut<object?>!*/;
        F(b => { if (b) return y; else return z; })/*T:IOut<object?>*/;
        F(b => { if (b) return z; else return x; })/*T:IOut<object>*/;
        F(b => { if (b) return z; else return y; })/*T:IOut<object?>*/;
        F(b => { if (b) return z; else return z; })/*T:IOut<object>*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (13,47): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         F(b => { if (b) return x; else return y; })/*T:I<object!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(13, 47),
                // (15,32): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         F(b => { if (b) return y; else return x; })/*T:I<object!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(15, 32)
                );
        }

        [WorkItem(27961, "https://github.com/dotnet/roslyn/issues/27961")]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        [Fact]
        public void LambdaReturnValue_NestedNullability_Variant_02()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"using System;
class B<T> { }
class C
{
    static B<T> CreateB<T>(T t) => throw null;
    static Func<int, T> CreateFunc<T>(T t) => throw null;
    static void F(B<object?> x, B<object> y)
    {
        var z = CreateB(A.F)/*T:B<object>!*/;
        var f = CreateFunc(y)/*Func<B<object!>>!*/;
        f = i => { switch (i) { case 0: return x; default: return x; }};
        f = i => { switch (i) { case 0: return x; default: return y; }};
        f = i => { switch (i) { case 0: return x; default: return z; }};
        f = i => { switch (i) { case 0: return y; default: return x; }};
        f = i => { switch (i) { case 0: return y; default: return y; }};
        f = i => { switch (i) { case 0: return y; default: return z; }};
        f = i => { switch (i) { case 0: return z; default: return x; }};
        f = i => { switch (i) { case 0: return z; default: return y; }};
        f = i => { switch (i) { case 0: return z; default: return z; }};
        f = i => { switch (i) { case 0: return x; case 1: return y; default: return z; }};
        f = i => { switch (i) { case 0: return z; case 1: return y; default: return x; }};
        var g = CreateFunc(z)/*Func<B<object>>*/;
        g = i => { switch (i) { case 0: return x; default: return x; }};
        g = i => { switch (i) { case 0: return x; default: return y; }};
        g = i => { switch (i) { case 0: return x; default: return z; }};
        g = i => { switch (i) { case 0: return y; default: return x; }};
        g = i => { switch (i) { case 0: return y; default: return y; }};
        g = i => { switch (i) { case 0: return y; default: return z; }};
        g = i => { switch (i) { case 0: return z; default: return x; }};
        g = i => { switch (i) { case 0: return z; default: return y; }};
        g = i => { switch (i) { case 0: return z; default: return z; }};
        g = i => { switch (i) { case 0: return x; case 1: return y; default: return z; }};
        g = i => { switch (i) { case 0: return z; case 1: return y; default: return x; }};
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,48): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return x; default: return x; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(11, 48),
                // (11,67): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return x; default: return x; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(11, 67),
                // (12,48): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return x; default: return y; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(12, 48),
                // (13,48): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return x; default: return z; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(13, 48),
                // (14,67): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return y; default: return x; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(14, 67),
                // (17,67): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return z; default: return x; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(17, 67),
                // (20,48): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return x; case 1: return y; default: return z; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(20, 48),
                // (21,85): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'B<object>'.
                //         f = i => { switch (i) { case 0: return z; case 1: return y; default: return x; }};
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object?>", "B<object>").WithLocation(21, 85));
            comp.VerifyTypes();
        }

        [WorkItem(30432, "https://github.com/dotnet/roslyn/issues/30432")]
        [Fact]
        public void LambdaReturnValue_TopLevelNullability_Ref()
        {
            var source =
@"delegate ref V D<T, U, V>(ref T t, ref U u);
class C
{
    static V F<T, U, V>(D<T, U, V> d) => throw null;
    static void G(bool b)
    {
        F((ref object? x1, ref object? y1) => { if (b) return ref x1; return ref y1; });
        F((ref object? x2, ref object y2) => { if (b) return ref x2; return ref y2; });
        F((ref object x3, ref object? y3) => { if (b) return ref x3; return ref y3; });
        F((ref object x4, ref object y4) => { if (b) return ref x4; return ref y4; });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30432: Report warnings for combinations of `object?` and `object!`.
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [WorkItem(30432, "https://github.com/dotnet/roslyn/issues/30432")]
        [WorkItem(30964, "https://github.com/dotnet/roslyn/issues/30964")]
        [Fact]
        public void LambdaReturnValue_NestedNullability_Ref()
        {
            var source =
@"delegate ref V D<T, U, V>(ref T t, ref U u);
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static V F<T, U, V>(D<T, U, V> d) => throw null;
    static void G(bool b)
    {
        // I<object>
        F((ref I<object?> a1, ref I<object?> b1) => { if (b) return ref a1; return ref b1; });
        F((ref I<object?> a2, ref I<object> b2) => { if (b) return ref a2; return ref b2; }); // 1
        F((ref I<object> a3, ref I<object?> b3) => { if (b) return ref a3; return ref b3; }); // 2
        F((ref I<object> a4, ref I<object> b4) => { if (b) return ref a4; return ref b4; });
        // IIn<object>
        F((ref IIn<object?> c1, ref IIn<object?> d1) => { if (b) return ref c1; return ref d1; });
        F((ref IIn<object?> c2, ref IIn<object> d2) => { if (b) return ref c2; return ref d2; });
        F((ref IIn<object> c3, ref IIn<object?> d3) => { if (b) return ref c3; return ref d3; });
        F((ref IIn<object> c4, ref IIn<object> d4) => { if (b) return ref c4; return ref d4; });
        // IOut<object>
        F((ref IOut<object?> e1, ref IOut<object?> f1) => { if (b) return ref e1; return ref f1; });
        F((ref IOut<object?> e2, ref IOut<object> f2) => { if (b) return ref e2; return ref f2; });
        F((ref IOut<object> e3, ref IOut<object?> f3) => { if (b) return ref e3; return ref f3; });
        F((ref IOut<object> e4, ref IOut<object> f4) => { if (b) return ref e4; return ref f4; });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30432: Report warnings for combinations of `IIn<object?>` and `IIn<object!>`
            // and combinations of  `IOut<object?>` and `IOut<object!>`.
            // https://github.com/dotnet/roslyn/issues/30964 - Report warnings about nullability mismatch in conditional operators for:
            //         F((ref I<object?> a2, ref I<object> b2) => { if (b) return ref a2; return ref b2; });
            //         F((ref I<object> a3, ref I<object?> b3) => { if (b) return ref a3; return ref b3; });
            comp.VerifyDiagnostics(
                // (12,72): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         F((ref I<object?> a2, ref I<object> b2) => { if (b) return ref a2; return ref b2; }); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("I<object?>", "I<object>").WithLocation(12, 72),
                // (13,87): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         F((ref I<object> a3, ref I<object?> b3) => { if (b) return ref a3; return ref b3; }); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b3").WithArguments("I<object?>", "I<object>").WithLocation(13, 87)
                );
            comp.VerifyTypes();
        }

        [Fact]
        public void LambdaParameterValue()
        {
            var source =
@"using System;
class C
{
    static void F<T>(T t, Action<T> f)
    {
    }
    static void G(object? x)
    {
        F(x, y => F(y, z => { y.ToString(); z.ToString(); }));
        if (x != null) F(x, y => F(y, z => { y.ToString(); z.ToString(); }));
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,31): warning CS8602: Possible dereference of a null reference.
                //         F(x, y => F(y, z => { y.ToString(); z.ToString(); }));
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 31),
                // (9,45): warning CS8602: Possible dereference of a null reference.
                //         F(x, y => F(y, z => { y.ToString(); z.ToString(); }));
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(9, 45));
        }

        [Fact]
        public void IdentityConversion_LambdaReturnType()
        {
            var source =
@"delegate T D<T>();
interface I<T> { }
class C
{
    static void F(object x, object? y)
    {
        D<object?> a = () => x;
        D<object> b = () => y;
        if (y == null) return;
        a = () => y;
        b = () => y;
        a = (D<object?>)(() => y);
        b = (D<object>)(() => y);
    }
    static void F(I<object> x, I<object?> y)
    {
        D<I<object?>> a = () => x;
        D<I<object>> b = () => y;
    }
}";
            // https://github.com/dotnet/roslyn/issues/29617: For captured variables, the lambda should be
            // considered executed at the location the lambda is converted to a delegate.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,29): warning CS8603: Possible null reference return.
                //         D<object> b = () => y;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y").WithLocation(8, 29),
                // (11,19): warning CS8603: Possible null reference return.
                //         b = () => y;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y").WithLocation(11, 19),
                // (13,31): warning CS8603: Possible null reference return.
                //         b = (D<object>)(() => y);
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "y").WithLocation(13, 31),
                // (17,33): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         D<I<object?>> a = () => x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("I<object>", "I<object?>").WithLocation(17, 33),
                // (18,32): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         D<I<object>> b = () => y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(18, 32));
        }

        [Fact]
        public void IdentityConversion_LambdaParameter()
        {
            var source =
@"delegate void D<T>(T t);
interface I<T> { }
class C
{
    static void F()
    {
        D<object?> a = (object o) => { };
        D<object> b = (object? o) => { };
        D<I<object?>> c = (I<object> o) => { };
        D<I<object>> d = (I<object?> o) => { };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,24): warning CS8622: Nullability of reference types in type of parameter 'o' of 'lambda expression' doesn't match the target delegate 'D<object?>'.
                //         D<object?> a = (object o) => { };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(object o) => { }").WithArguments("o", "lambda expression", "D<object?>").WithLocation(7, 24),
                // (8,23): warning CS8622: Nullability of reference types in type of parameter 'o' of 'lambda expression' doesn't match the target delegate 'D<object>'.
                //         D<object> b = (object? o) => { };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(object? o) => { }").WithArguments("o", "lambda expression", "D<object>").WithLocation(8, 23),
                // (9,27): warning CS8622: Nullability of reference types in type of parameter 'o' of 'lambda expression' doesn't match the target delegate 'D<I<object?>>'.
                //         D<I<object?>> c = (I<object> o) => { };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(I<object> o) => { }").WithArguments("o", "lambda expression", "D<I<object?>>").WithLocation(9, 27),
                // (10,26): warning CS8622: Nullability of reference types in type of parameter 'o' of 'lambda expression' doesn't match the target delegate 'D<I<object>>'.
                //         D<I<object>> d = (I<object?> o) => { };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(I<object?> o) => { }").WithArguments("o", "lambda expression", "D<I<object>>").WithLocation(10, 26));
        }

        [Fact]
        public void ReturnTypeInference_01()
        {
            var source =
@"class C
{
    static T F<T>(System.Func<T> f)
    {
        return f();
    }
    static void G(string x, string? y)
    {
        F(() => x).ToString();
        F(() => y).ToString();
        if (y != null) F(() => y).ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/29617: For captured variables, the lambda should be
            // considered executed at the location the lambda is converted to a delegate.
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => y)").WithLocation(10, 9),
                // (11,24): warning CS8602: Possible dereference of a null reference.
                //         if (y != null) F(() => y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => y)").WithLocation(11, 24));
        }

        // Multiple returns, one of which is null.
        [Fact]
        public void ReturnTypeInference_02()
        {
            var source =
@"class C
{
    static T F<T>(System.Func<T> f)
    {
        return f();
    }
    static void G(string x)
    {
        F(() => { if (x.Length > 0) return x; return null; }).ToString();
        F(() => { if (x.Length == 0) return null; return x; }).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => { if (x.Length > 0) return x; return null; }).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => { if (x.Length > 0) return x; return null; })").WithLocation(9, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(() => { if (x.Length == 0) return null; return x; }).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(() => { if (x.Length == 0) return null; return x; })").WithLocation(10, 9));
        }

        [Fact]
        public void ReturnTypeInference_CSharp7()
        {
            var source =
@"using System;
class C
{
    static void Main(string[] args)
    {
        args.F(arg => arg.Length);
    }
}
static class E
{
    internal static U[] F<T, U>(this T[] a, Func<T, U> f) => throw new Exception();
}";
            var comp = CreateCompilationWithMscorlib45(
                new[] { source },
                parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void UnboundLambda_01()
        {
            var source =
@"class C
{
    static void F()
    {
        var y = x => x;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,13): error CS0815: Cannot assign lambda expression to an implicitly-typed variable
                //         var y = x => x;
                Diagnostic(ErrorCode.ERR_ImplicitlyTypedVariableAssignedBadValue, "y = x => x").WithArguments("lambda expression").WithLocation(5, 13));
        }

        [Fact]
        public void UnboundLambda_02()
        {
            var source =
@"class C
{
    static void F(object? x)
    {
        var z = y => y ?? x.ToString();
        System.Func<object?, object> z2 = y => y ?? x.ToString();
        System.Func<object?, object> z3 = y => null;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,13): error CS0815: Cannot assign lambda expression to an implicitly-typed variable
                //         var z = y => y ?? x.ToString();
                Diagnostic(ErrorCode.ERR_ImplicitlyTypedVariableAssignedBadValue, "z = y => y ?? x.ToString()").WithArguments("lambda expression").WithLocation(5, 13),
                // (5,27): warning CS8602: Possible dereference of a null reference.
                //         var z = y => y ?? x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(5, 27),
                // (6,53): warning CS8602: Possible dereference of a null reference.
                //         System.Func<object?, object> z2 = y => y ?? x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 53),
                // (7,48): warning CS8603: Possible null reference return.
                //         System.Func<object?, object> z3 = y => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(7, 48));
        }

        /// <summary>
        /// Inferred nullability of captured variables should be tracked across
        /// local function invocations, as if the local function was inlined.
        /// </summary>
        [Fact]
        [WorkItem(29892, "https://github.com/dotnet/roslyn/issues/29892")]
        public void LocalFunction_01()
        {
            var source =
@"class C
{
    static void F1(object? x1, object y1)
    {
        object z1 = y1;
        f();
        z1.ToString(); // warning
        void f()
        {
            z1 = x1; // warning
        }
    }
    static void F2(object? x2, object y2)
    {
        object z2 = x2; // warning
        f();
        z2.ToString();
        void f()
        {
            z2 = y2;
        }
    }
    static void F3(object? x3, object y3)
    {
        object z3 = y3;
        void f()
        {
            z3 = x3;
        }
        if (x3 == null) return;
        f();
        z3.ToString();
    }
    static void F4(object? x4)
    {
        f().ToString(); // warning
        if (x4 != null) f().ToString();
        object? f() => x4;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29892: Should report warnings as indicated in source above.
            comp.VerifyDiagnostics(
                // (10,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             z1 = x1; // warning
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(10, 18),
                // (15,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object z2 = x2; // warning
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(15, 21),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         z2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z2").WithLocation(17, 9),
                // (28,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             z3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(28, 18),
                // (36,9): warning CS8602: Possible dereference of a null reference.
                //         f().ToString(); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "f()").WithLocation(36, 9),
                // (37,25): warning CS8602: Possible dereference of a null reference.
                //         if (x4 != null) f().ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "f()").WithLocation(37, 25));
        }

        /// <summary>
        /// Should report warnings within unused local functions.
        /// </summary>
        [Fact]
        [WorkItem(29892, "https://github.com/dotnet/roslyn/issues/29892")]
        public void LocalFunction_NoCallers()
        {
            var source =
@"#pragma warning disable 8321
class C
{
    static void F1(object? x1)
    {
        void f1()
        {
            x1.ToString(); // 1
        }
    }
    static void F2(object? x2)
    {
        if (x2 == null) return;
        void f2()
        {
            x2.ToString(); // 2
        }
    }
    static void F3(object? x3)
    {
        object? y3 = x3;
        void f3()
        {
            y3.ToString(); // 3
        }
        if (y3 == null) return;
        void g3()
        {
            y3.ToString(); // 4
        }
    }
    static void F4()
    {
        void f4(object? x4)
        {
            x4.ToString(); // 5
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29892: Should report warnings for `y3.ToString()`.
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(8, 13),
                // (16,13): warning CS8602: Possible dereference of a null reference.
                //             x2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(16, 13),
                // (36,13): warning CS8602: Possible dereference of a null reference.
                //             x4.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x4").WithLocation(36, 13));
        }

        [Fact]
        public void New_01()
        {
            var source =
@"class C
{
    static void F1()
    {
        object? x1;
        x1 = new object?(); // error 1
        x1 = new object? { }; // error 2
        x1 = (new object?[1])[0];
        x1 = new object[]? {};   // error 3
    }
    static void F2<T2>()
    {
        object? x2;
        x2 = new T2?(); // error 4
        x2 = new T2? { }; // error 5
        x2 = (new T2?[1])[0];
    }
    static void F3<T3>() where T3 : class, new()
    {
        object? x3;
        x3 = new T3?(); // error 6
        x3 = new T3? { }; // error 7
        x3 = (new T3?[1])[0];
    }
    static void F4<T4>() where T4 : new()
    {
        object? x4;
        x4 = new T4?(); // error 8
        x4 = new T4? { }; // error 9
        x4 = (new T4?[1])[0];
        x4 = new System.Nullable<int>? { }; // error 11
    }
    static void F5<T5>() where T5 : class
    {
        object? x5;
        x5 = new T5?(); // error 10
        x5 = new T5? { }; // error 11
        x5 = (new T5?[1])[0];
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,14): error CS8628: Cannot use a nullable reference type in object creation.
                //         x1 = new object?(); // error 1
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new object?()").WithArguments("object").WithLocation(6, 14),
                // (7,14): error CS8628: Cannot use a nullable reference type in object creation.
                //         x1 = new object? { }; // error 2
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new object? { }").WithArguments("object").WithLocation(7, 14),
                // (9,14): error CS8628: Cannot use a nullable reference type in object creation.
                //         x1 = new object[]? {};   // error 3
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new object[]? {}").WithArguments("object[]").WithLocation(9, 14),
                // (9,18): error CS8386: Invalid object creation
                //         x1 = new object[]? {};   // error 3
                Diagnostic(ErrorCode.ERR_InvalidObjectCreation, "object[]?").WithArguments("object[]").WithLocation(9, 18),
                // (14,18): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         x2 = new T2?(); // error 4
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(14, 18),
                // (14,14): error CS8628: Cannot use a nullable reference type in object creation.
                //         x2 = new T2?(); // error 4
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T2?()").WithArguments("T2").WithLocation(14, 14),
                // (14,14): error CS0304: Cannot create an instance of the variable type 'T2' because it does not have the new() constraint
                //         x2 = new T2?(); // error 4
                Diagnostic(ErrorCode.ERR_NoNewTyvar, "new T2?()").WithArguments("T2").WithLocation(14, 14),
                // (15,18): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         x2 = new T2? { }; // error 5
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(15, 18),
                // (15,14): error CS8628: Cannot use a nullable reference type in object creation.
                //         x2 = new T2? { }; // error 5
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T2? { }").WithArguments("T2").WithLocation(15, 14),
                // (15,14): error CS0304: Cannot create an instance of the variable type 'T2' because it does not have the new() constraint
                //         x2 = new T2? { }; // error 5
                Diagnostic(ErrorCode.ERR_NoNewTyvar, "new T2? { }").WithArguments("T2").WithLocation(15, 14),
                // (16,19): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         x2 = (new T2?[1])[0];
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(16, 19),
                // (21,14): error CS8628: Cannot use a nullable reference type in object creation.
                //         x3 = new T3?(); // error 6
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T3?()").WithArguments("T3").WithLocation(21, 14),
                // (22,14): error CS8628: Cannot use a nullable reference type in object creation.
                //         x3 = new T3? { }; // error 7
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T3? { }").WithArguments("T3").WithLocation(22, 14),
                // (28,18): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         x4 = new T4?(); // error 8
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T4?").WithLocation(28, 18),
                // (28,14): error CS8628: Cannot use a nullable reference type in object creation.
                //         x4 = new T4?(); // error 8
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T4?()").WithArguments("T4").WithLocation(28, 14),
                // (29,18): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         x4 = new T4? { }; // error 9
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T4?").WithLocation(29, 18),
                // (29,14): error CS8628: Cannot use a nullable reference type in object creation.
                //         x4 = new T4? { }; // error 9
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T4? { }").WithArguments("T4").WithLocation(29, 14),
                // (30,19): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         x4 = (new T4?[1])[0];
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T4?").WithLocation(30, 19),
                // (31,18): error CS0453: The type 'int?' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                //         x4 = new System.Nullable<int>? { }; // error 11
                Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "System.Nullable<int>?").WithArguments("System.Nullable<T>", "T", "int?").WithLocation(31, 18),
                // (36,14): error CS8628: Cannot use a nullable reference type in object creation.
                //         x5 = new T5?(); // error 10
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T5?()").WithArguments("T5").WithLocation(36, 14),
                // (36,14): error CS0304: Cannot create an instance of the variable type 'T5' because it does not have the new() constraint
                //         x5 = new T5?(); // error 10
                Diagnostic(ErrorCode.ERR_NoNewTyvar, "new T5?()").WithArguments("T5").WithLocation(36, 14),
                // (37,14): error CS8628: Cannot use a nullable reference type in object creation.
                //         x5 = new T5? { }; // error 11
                Diagnostic(ErrorCode.ERR_AnnotationDisallowedInObjectCreation, "new T5? { }").WithArguments("T5").WithLocation(37, 14),
                // (37,14): error CS0304: Cannot create an instance of the variable type 'T5' because it does not have the new() constraint
                //         x5 = new T5? { }; // error 11
                Diagnostic(ErrorCode.ERR_NoNewTyvar, "new T5? { }").WithArguments("T5").WithLocation(37, 14)
                );
        }

        [Fact]
        public void New_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1<T1>(T1 x1) where T1 : class, new()
    {
        x1 = new T1();
    }

    void Test2<T2>(T2 x2) where T2 : class, new()
    {
        x2 = new T2() ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = new T2() ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new T2()").WithLocation(14, 14)
                );
        }

        // `where T : new()` does not imply T is non-nullable.
        [Fact]
        public void New_03()
        {
            var source =
@"class C
{
    static void F1<T>() where T : new() { }
    static void F2<T>(T t) where T : new() { }
    static void G<U>() where U : class, new()
    {
        object? x = null;
        F1<object?>();
        F2(x);
        U? y = null;
        F1<U?>();
        F2(y);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void DynamicObjectCreation_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = new CL0((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        x2 = new CL0((dynamic)0) ?? x2;
    }
}

class CL0
{
    public CL0(int x) {}
    public CL0(long x) {}
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = new CL0((dynamic)0) ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new CL0((dynamic)0)").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicObjectCreation_02()
        {
            var source =
@"class C
{
    C(object x, object y)
    {
    }
    static void G(object? x, dynamic y)
    {
        var o = new C(x, y);
        if (x != null) o = new C(y, x);
    }
}";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29893: We should be able to report warnings
            // when all applicable methods agree on the nullability of particular parameters.
            // (For instance, x in F(x, y) above.)
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void DynamicObjectCreation_03()
        {
            var source =
@"class C
{
    C(object f)
    {
        F = f;
    }
    object? F;
    object? G;
    static void M(dynamic d)
    {
        var o = new C(d) { G = new object() };
        o.G.ToString();
    }
}";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void DynamicIndexerAccess_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = x1[(dynamic)0];
    }

    void Test2(CL0 x2)
    {
        x2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0
{
    public CL0 this[int x]
    {
        get { return new CL0(); }
        set { }
    }

    public CL0 this[long x]
    {
        get { return new CL0(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = x2[(dynamic)0] ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2[(dynamic)0]").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        dynamic y1 = x1[(dynamic)0];
    }

    void Test2(CL0 x2)
    {
        dynamic y2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0
{
    public CL0? this[int x]
    {
        get { return new CL0(); }
        set { }
    }

    public CL0 this[long x]
    {
        get { return new CL0(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         dynamic y1 = x1[(dynamic)0];
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1[(dynamic)0]").WithLocation(9, 22)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        dynamic y1 = x1[(dynamic)0];
    }

    void Test2(CL0 x2)
    {
        dynamic y2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0
{
    public CL0 this[int x]
    {
        get { return new CL0(); }
        set { }
    }

    public CL0? this[long x]
    {
        get { return new CL0(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         dynamic y1 = x1[(dynamic)0];
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1[(dynamic)0]").WithLocation(9, 22)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        dynamic y1 = x1[(dynamic)0];
    }

    void Test2(CL0 x2)
    {
        dynamic y2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0
{
    public CL0? this[int x]
    {
        get { return new CL0(); }
        set { }
    }

    public CL0? this[long x]
    {
        get { return new CL0(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         dynamic y1 = x1[(dynamic)0];
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1[(dynamic)0]").WithLocation(9, 22)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = x1[(dynamic)0];
    }

    void Test2(CL0 x2)
    {
        x2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0
{
    public int this[int x]
    {
        get { return x; }
        set { }
    }

    public int this[long x]
    {
        get { return (int)x; }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = x2[(dynamic)0] ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2[(dynamic)0]").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_06()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = x1[(dynamic)0];
    }

    void Test2(CL0 x2)
    {
        x2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0
{
    public int this[int x]
    {
        get { return x; }
        set { }
    }

    public long this[long x]
    {
        get { return x; }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = x2[(dynamic)0] ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2[(dynamic)0]").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(dynamic x1)
    {
        x1 = x1[0];
    }

    void Test2(dynamic x2)
    {
        x2 = x2[0] ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void DynamicIndexerAccess_08()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1<T>(CL0<T> x1)
    {
        x1 = x1[(dynamic)0];
    }

    void Test2<T>(CL0<T> x2)
    {
        x2 = x2[(dynamic)0] ?? x2;
    }
}

class CL0<T>
{
    public T this[int x]
    {
        get { return default(T); }
        set { }
    }

    public long this[long x]
    {
        get { return x; }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (22,22): warning CS8603: Possible null reference return.
                //         get { return default(T); }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(T)").WithLocation(22, 22)
            );
        }

        [Fact]
        public void DynamicIndexerAccess_09()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1, dynamic y1)
    {
        x1[(dynamic)0] = y1;
    }

    void Test2(CL0 x2, dynamic? y2, CL1 z2)
    {
        x2[(dynamic)0] = y2;
        z2[0] = y2;
    }
} 

class CL0
{
    public CL0 this[int x]
    {
        get { return new CL0(); }
        set { }
    }

    public CL0 this[long x]
    {
        get { return new CL0(); }
        set { }
    }
}

class CL1
{
    public dynamic this[int x]
    {
        get { return new CL0(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (14,26): warning CS8601: Possible null reference assignment.
                //         x2[(dynamic)0] = y2;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y2").WithLocation(14, 26),
                // (15,17): warning CS8601: Possible null reference assignment.
                //         z2[0] = y2;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y2").WithLocation(15, 17)
                );
        }

        [Fact]
        public void DynamicIndexerAccess_10()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0? x1)
    {
        x1 = x1[(dynamic)0];
    }

    void Test2(CL0? x2)
    {
        x2 = x2[0];
    }
}

class CL0
{
    public CL0 this[int x]
    {
        get { return new CL0(); }
        set { }
    }

    public CL0 this[long x]
    {
        get { return new CL0(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,14): warning CS8602: Possible dereference of a null reference.
                 //         x1 = x1[(dynamic)0];
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(9, 14),
                 // (14,14): warning CS8602: Possible dereference of a null reference.
                 //         x2 = x2[0];
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicInvocation_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = x1.M1((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        x2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0
{
    public CL0 M1(int x)
    {
        return new CL0(); 
    }

    public CL0 M1(long x)
    {
        return new CL0(); 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = x2.M1((dynamic)0) ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2.M1((dynamic)0)").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicInvocation_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        dynamic y1 = x1.M1((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        dynamic y2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0
{
    public CL0? M1(int x)
    {
        return new CL0(); 
    }

    public CL0  M1(long x)
    {
        return new CL0(); 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         dynamic y1 = x1.M1((dynamic)0);
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1.M1((dynamic)0)").WithLocation(9, 22)
                );
        }

        [Fact]
        public void DynamicInvocation_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        dynamic y1 = x1.M1((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        dynamic y2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0
{
    public CL0 M1(int x)
    {
        return new CL0(); 
    }

    public CL0? M1(long x)
    {
        return new CL0(); 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         dynamic y1 = x1.M1((dynamic)0);
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1.M1((dynamic)0)").WithLocation(9, 22)
                );
        }

        [Fact]
        public void DynamicInvocation_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        dynamic y1 = x1.M1((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        dynamic y2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0
{
    public CL0? M1(int x)
    {
        return new CL0(); 
    }

    public CL0? M1(long x)
    {
        return new CL0(); 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         dynamic y1 = x1.M1((dynamic)0);
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1.M1((dynamic)0)").WithLocation(9, 22)
                );
        }

        [Fact]
        public void DynamicInvocation_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = x1.M1((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        x2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0
{
    public int M1(int x)
    {
        return x; 
    }

    public int M1(long x)
    {
        return (int)x; 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = x2.M1((dynamic)0) ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2.M1((dynamic)0)").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicInvocation_06()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0 x1)
    {
        x1 = x1.M1((dynamic)0);
    }

    void Test2(CL0 x2)
    {
        x2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0
{
    public int M1(int x)
    {
        return x; 
    }

    public long M1(long x)
    {
        return x; 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (14,14): hidden CS8607: Expression is probably never null.
                 //         x2 = x2.M1((dynamic)0) ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2.M1((dynamic)0)").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicInvocation_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(dynamic x1)
    {
        x1 = x1.M1(0);
    }

    void Test2(dynamic x2)
    {
        x2 = x2.M1(0) ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void DynamicInvocation_08()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1<T>(CL0<T> x1)
    {
        x1 = x1.M1((dynamic)0);
    }

    void Test2<T>(CL0<T> x2)
    {
        x2 = x2.M1((dynamic)0) ?? x2;
    }
}

class CL0<T>
{
    public T M1(int x)
    {
        return default(T);
    }
    public long M1(long x)
    {
        return x;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (22,16): warning CS8603: Possible null reference return.
                //         return default(T);
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(T)").WithLocation(22, 16)
            );
        }

        [Fact]
        public void DynamicInvocation_09()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(CL0? x1)
    {
        x1 = x1.M1((dynamic)0);
    }

    void Test2(CL0? x2)
    {
        x2 = x2.M1(0);
    }
}

class CL0
{
    public CL0 M1(int x)
    {
        return new CL0(); 
    }

    public CL0 M1(long x)
    {
        return new CL0(); 
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (9,14): warning CS8602: Possible dereference of a null reference.
                 //         x1 = x1.M1((dynamic)0);
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(9, 14),
                 // (14,14): warning CS8602: Possible dereference of a null reference.
                 //         x2 = x2.M1(0);
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(14, 14)
                );
        }

        [Fact]
        public void DynamicMemberAccess_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1(dynamic x1)
    {
        x1 = x1.M1;
    }

    void Test2(dynamic x2)
    {
        x2 = x2.M1 ?? x2;
    }

    void Test3(dynamic? x3)
    {
        dynamic y3 = x3.M1;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (19,22): warning CS8602: Possible dereference of a null reference.
                 //         dynamic y3 = x3.M1;
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x3").WithLocation(19, 22)
                );
        }

        [Fact]
        public void DynamicMemberAccess_02()
        {
            var source =
@"class C
{
    static void M(dynamic x)
    {
        x.F/*T:dynamic*/.ToString();
        var y = x.F;
        y/*T:dynamic*/.ToString();
        y = null;
    }
}";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        public void DynamicObjectCreationExpression_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {}

    void Test1()
    {
        dynamic? x1 = null;
        CL0 y1 = new CL0(x1);
    }

    void Test2(CL0 y2)
    {
        dynamic? x2 = null;
        CL0 z2 = new CL0(x2) ?? y2;
    }
}

class CL0
{
    public CL0(int x)
    {
    }

    public CL0(long x)
    {
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (16,18): hidden CS8607: Expression is probably never null.
                 //         CL0 z2 = new CL0(x2) ?? y2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new CL0(x2)").WithLocation(16, 18)
                );
        }

        [Fact]
        public void DynamicInvocation()
        {
            var source =
@"class C
{
    static void F(object x, object y)
    {
    }
    static void G(object? x, dynamic y)
    {
        F(x, y);
        if (x != null) F(y, x);
    }
}";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29893: We should be able to report warnings
            // when all applicable methods agree on the nullability of particular parameters.
            // (For instance, x in F(x, y) above.)
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NameOf_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(string x1, string? y1)
    {
        x1 = nameof(y1);
    }

    void Test2(string x2, string? y2)
    {
        string? z2 = nameof(y2);
        x2 = z2 ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (16,14): hidden CS8607: Expression is probably never null.
                 //         x2 = z2 ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z2").WithLocation(16, 14)
                );
        }

        [Fact]
        public void StringInterpolation_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(string x1, string? y1)
    {
        x1 = $""{y1}"";
    }

    void Test2(string x2, string? y2)
    {
        x2 = $""{y2}"" ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,14): hidden CS8607: Expression is probably never null.
                 //         x2 = $"{y2}" ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, @"$""{y2}""").WithLocation(15, 14)
                );
        }

        [Fact]
        public void DelegateCreation_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(System.Action x1)
    {
        x1 = new System.Action(Main);
    }

    void Test2(System.Action x2)
    {
        x2 = new System.Action(Main) ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,14): hidden CS8607: Expression is probably never null.
                 //         x2 = new System.Action(Main) ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new System.Action(Main)").WithLocation(15, 14)
                );
        }

        // WRN_NullabilityMismatch* warnings should not be
        // reported for explicit delegate creation.
        [Fact]
        public void DelegateCreation_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    CL0<string?> M1(CL0<string> x) { throw new System.Exception(); }
    delegate CL0<string> D1(CL0<string?> x);

    void Test1()
    {
        D1 x1 = new D1(M1);
    }

    CL0<string> M2(CL0<string?> x) { throw new System.Exception(); }
    delegate CL0<string?> D2(CL0<string> x);

    void Test2()
    {
        D2 x2 = new D2(M2);
    }
}

class CL0<T>{}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void IdentityConversion_DelegateReturnType()
        {
            var source =
@"delegate T D<T>();
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>() => throw new System.Exception();
    static void G()
    {
        D<object> a = F<object?>;
        D<object?> b = F<object>;
        D<I<object>> c = F<I<object?>>;
        D<I<object?>> d = F<I<object>>;
        D<IIn<object>> e = F<IIn<object?>>;
        D<IIn<object?>> f = F<IIn<object>>;
        D<IOut<object>> g = F<IOut<object?>>;
        D<IOut<object?>> h = F<IOut<object>>;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,23): warning CS8621: Nullability of reference types in return type of 'object? C.F<object?>()' doesn't match the target delegate 'D<object>'.
                //         D<object> a = F<object?>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F<object?>").WithArguments("object? C.F<object?>()", "D<object>").WithLocation(10, 23),
                // (12,26): warning CS8621: Nullability of reference types in return type of 'I<object?> C.F<I<object?>>()' doesn't match the target delegate 'D<I<object>>'.
                //         D<I<object>> c = F<I<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F<I<object?>>").WithArguments("I<object?> C.F<I<object?>>()", "D<I<object>>").WithLocation(12, 26),
                // (13,27): warning CS8621: Nullability of reference types in return type of 'I<object> C.F<I<object>>()' doesn't match the target delegate 'D<I<object?>>'.
                //         D<I<object?>> d = F<I<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F<I<object>>").WithArguments("I<object> C.F<I<object>>()", "D<I<object?>>").WithLocation(13, 27),
                // (15,29): warning CS8621: Nullability of reference types in return type of 'IIn<object> C.F<IIn<object>>()' doesn't match the target delegate 'D<IIn<object?>>'.
                //         D<IIn<object?>> f = F<IIn<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F<IIn<object>>").WithArguments("IIn<object> C.F<IIn<object>>()", "D<IIn<object?>>").WithLocation(15, 29),
                // (16,29): warning CS8621: Nullability of reference types in return type of 'IOut<object?> C.F<IOut<object?>>()' doesn't match the target delegate 'D<IOut<object>>'.
                //         D<IOut<object>> g = F<IOut<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F<IOut<object?>>").WithArguments("IOut<object?> C.F<IOut<object?>>()", "D<IOut<object>>").WithLocation(16, 29));
        }

        [Fact]
        public void IdentityConversion_DelegateParameter_01()
        {
            var source =
@"delegate void D<T>(T t);
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F<T>(T t) { }
    static void G()
    {
        D<object> a = F<object?>;
        D<object?> b = F<object>;
        D<I<object>> c = F<I<object?>>;
        D<I<object?>> d = F<I<object>>;
        D<IIn<object>> e = F<IIn<object?>>;
        D<IIn<object?>> f = F<IIn<object>>;
        D<IOut<object>> g = F<IOut<object?>>;
        D<IOut<object?>> h = F<IOut<object>>;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,24): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<object>(object t)' doesn't match the target delegate 'D<object?>'.
                //         D<object?> b = F<object>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<object>").WithArguments("t", "void C.F<object>(object t)", "D<object?>").WithLocation(11, 24),
                // (12,26): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<I<object?>>(I<object?> t)' doesn't match the target delegate 'D<I<object>>'.
                //         D<I<object>> c = F<I<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<I<object?>>").WithArguments("t", "void C.F<I<object?>>(I<object?> t)", "D<I<object>>").WithLocation(12, 26),
                // (13,27): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<I<object>>(I<object> t)' doesn't match the target delegate 'D<I<object?>>'.
                //         D<I<object?>> d = F<I<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<I<object>>").WithArguments("t", "void C.F<I<object>>(I<object> t)", "D<I<object?>>").WithLocation(13, 27),
                // (14,28): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IIn<object?>>(IIn<object?> t)' doesn't match the target delegate 'D<IIn<object>>'.
                //         D<IIn<object>> e = F<IIn<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IIn<object?>>").WithArguments("t", "void C.F<IIn<object?>>(IIn<object?> t)", "D<IIn<object>>").WithLocation(14, 28),
                // (17,30): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IOut<object>>(IOut<object> t)' doesn't match the target delegate 'D<IOut<object?>>'.
                //         D<IOut<object?>> h = F<IOut<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IOut<object>>").WithArguments("t", "void C.F<IOut<object>>(IOut<object> t)", "D<IOut<object?>>").WithLocation(17, 30));
        }

        [Fact]
        [WorkItem(29844, "https://github.com/dotnet/roslyn/issues/29844")]
        public void IdentityConversion_DelegateParameter_02()
        {
            var source =
@"delegate T D<T>();
class A<T>
{
    internal T M() => throw new System.NotImplementedException();
}
class B
{
    static A<T> F<T>(T t) => throw null;
    static void G(object? o)
    {
        var x = F(o);
        D<object?> d = x.M;
        D<object> e = x.M;
        if (o == null) return;
        var y = F(o);
        d = y.M;
        e = y.M;
        d = (D<object?>)y.M;
        e = (D<object>)y.M;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29844: Should report WRN_NullabilityMismatchInReturnTypeOfTargetDelegate for `e = x.M`.
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29844, "https://github.com/dotnet/roslyn/issues/29844")]
        public void IdentityConversion_DelegateOutParameter()
        {
            var source =
@"delegate void D<T>(out T t);
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F<T>(out T t) { t = default; }
    static void G()
    {
        D<object> a = F<object?>;
        D<object?> b = F<object>;
        D<I<object>> c = F<I<object?>>;
        D<I<object?>> d = F<I<object>>;
        D<IIn<object>> e = F<IIn<object?>>;
        D<IIn<object?>> f = F<IIn<object>>;
        D<IOut<object>> g = F<IOut<object?>>;
        D<IOut<object?>> h = F<IOut<object>>;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29844: Should not warn for `b`, `e`, `h`.
            comp.VerifyDiagnostics(
                // (7,37): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F<T>(out T t) { t = default; }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(7, 37),
                // (10,23): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<object?>(out object? t)' doesn't match the target delegate 'D<object>'.
                //         D<object> a = F<object?>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<object?>").WithArguments("t", "void C.F<object?>(out object? t)", "D<object>").WithLocation(10, 23),
                // (11,24): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<object>(out object t)' doesn't match the target delegate 'D<object?>'.
                //         D<object?> b = F<object>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<object>").WithArguments("t", "void C.F<object>(out object t)", "D<object?>").WithLocation(11, 24),
                // (12,26): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<I<object?>>(out I<object?> t)' doesn't match the target delegate 'D<I<object>>'.
                //         D<I<object>> c = F<I<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<I<object?>>").WithArguments("t", "void C.F<I<object?>>(out I<object?> t)", "D<I<object>>").WithLocation(12, 26),
                // (13,27): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<I<object>>(out I<object> t)' doesn't match the target delegate 'D<I<object?>>'.
                //         D<I<object?>> d = F<I<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<I<object>>").WithArguments("t", "void C.F<I<object>>(out I<object> t)", "D<I<object?>>").WithLocation(13, 27),
                // (14,28): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IIn<object?>>(out IIn<object?> t)' doesn't match the target delegate 'D<IIn<object>>'.
                //         D<IIn<object>> e = F<IIn<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IIn<object?>>").WithArguments("t", "void C.F<IIn<object?>>(out IIn<object?> t)", "D<IIn<object>>").WithLocation(14, 28),
                // (15,29): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IIn<object>>(out IIn<object> t)' doesn't match the target delegate 'D<IIn<object?>>'.
                //         D<IIn<object?>> f = F<IIn<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IIn<object>>").WithArguments("t", "void C.F<IIn<object>>(out IIn<object> t)", "D<IIn<object?>>").WithLocation(15, 29),
                // (16,29): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IOut<object?>>(out IOut<object?> t)' doesn't match the target delegate 'D<IOut<object>>'.
                //         D<IOut<object>> g = F<IOut<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IOut<object?>>").WithArguments("t", "void C.F<IOut<object?>>(out IOut<object?> t)", "D<IOut<object>>").WithLocation(16, 29),
                // (17,30): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IOut<object>>(out IOut<object> t)' doesn't match the target delegate 'D<IOut<object?>>'.
                //         D<IOut<object?>> h = F<IOut<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IOut<object>>").WithArguments("t", "void C.F<IOut<object>>(out IOut<object> t)", "D<IOut<object?>>").WithLocation(17, 30));
        }

        [Fact]
        public void IdentityConversion_DelegateRefParameter()
        {
            var source =
@"delegate void D<T>(ref T t);
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F<T>(ref T t) { }
    static void G()
    {
        D<object> a = F<object?>;
        D<object?> b = F<object>;
        D<I<object>> c = F<I<object?>>;
        D<I<object?>> d = F<I<object>>;
        D<IIn<object>> e = F<IIn<object?>>;
        D<IIn<object?>> f = F<IIn<object>>;
        D<IOut<object>> g = F<IOut<object?>>;
        D<IOut<object?>> h = F<IOut<object>>;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,23): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<object?>(ref object? t)' doesn't match the target delegate 'D<object>'.
                //         D<object> a = F<object?>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<object?>").WithArguments("t", "void C.F<object?>(ref object? t)", "D<object>").WithLocation(10, 23),
                // (11,24): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<object>(ref object t)' doesn't match the target delegate 'D<object?>'.
                //         D<object?> b = F<object>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<object>").WithArguments("t", "void C.F<object>(ref object t)", "D<object?>").WithLocation(11, 24),
                // (12,26): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<I<object?>>(ref I<object?> t)' doesn't match the target delegate 'D<I<object>>'.
                //         D<I<object>> c = F<I<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<I<object?>>").WithArguments("t", "void C.F<I<object?>>(ref I<object?> t)", "D<I<object>>").WithLocation(12, 26),
                // (13,27): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<I<object>>(ref I<object> t)' doesn't match the target delegate 'D<I<object?>>'.
                //         D<I<object?>> d = F<I<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<I<object>>").WithArguments("t", "void C.F<I<object>>(ref I<object> t)", "D<I<object?>>").WithLocation(13, 27),
                // (14,28): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IIn<object?>>(ref IIn<object?> t)' doesn't match the target delegate 'D<IIn<object>>'.
                //         D<IIn<object>> e = F<IIn<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IIn<object?>>").WithArguments("t", "void C.F<IIn<object?>>(ref IIn<object?> t)", "D<IIn<object>>").WithLocation(14, 28),
                // (15,29): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IIn<object>>(ref IIn<object> t)' doesn't match the target delegate 'D<IIn<object?>>'.
                //         D<IIn<object?>> f = F<IIn<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IIn<object>>").WithArguments("t", "void C.F<IIn<object>>(ref IIn<object> t)", "D<IIn<object?>>").WithLocation(15, 29),
                // (16,29): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IOut<object?>>(ref IOut<object?> t)' doesn't match the target delegate 'D<IOut<object>>'.
                //         D<IOut<object>> g = F<IOut<object?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IOut<object?>>").WithArguments("t", "void C.F<IOut<object?>>(ref IOut<object?> t)", "D<IOut<object>>").WithLocation(16, 29),
                // (17,30): warning CS8622: Nullability of reference types in type of parameter 't' of 'void C.F<IOut<object>>(ref IOut<object> t)' doesn't match the target delegate 'D<IOut<object?>>'.
                //         D<IOut<object?>> h = F<IOut<object>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F<IOut<object>>").WithArguments("t", "void C.F<IOut<object>>(ref IOut<object> t)", "D<IOut<object?>>").WithLocation(17, 30));
        }

        [Fact]
        public void Base_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Base
{
    public virtual void Test() {}
}

class C : Base
{
    static void Main()
    {
    }

    public override void Test()
    {
        base.Test();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void TypeOf_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(System.Type x1)
    {
        x1 = typeof(C);
    }

    void Test2(System.Type x2)
    {
        x2 = typeof(C) ?? x2;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,14): hidden CS8607: Expression is probably never null.
                 //         x2 = typeof(C) ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "typeof(C)").WithLocation(15, 14)
                );
        }

        [Fact]
        [WorkItem(29894, "https://github.com/dotnet/roslyn/issues/29894")]
        public void TypeOf_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class List<T> { }
class C<T, TClass, TStruct>
    where TClass : class
    where TStruct : struct
{
    void M()
    {
        _ = typeof(C<int, object, int>?);
        _ = typeof(T?);
        _ = typeof(TClass?);
        _ = typeof(TStruct?);
        _ = typeof(List<T?>);
        _ = typeof(List<TClass?>);
        _ = typeof(List<TStruct?>);
    }
}
" }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29894: should nullable reference types be disallowed in `typeof`?
            c.VerifyDiagnostics(
                // (10,20): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         _ = typeof(T?);
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(10, 20),
                // (13,25): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         _ = typeof(List<T?>);
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(13, 25)
                );
        }

        [Fact]
        public void Default_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(C x1)
    {
        x1 = default(C);
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x1 = default(C);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(C)").WithLocation(10, 14)
                );
        }

        [Fact]
        public void Default_NonNullable()
        {
            var source =
@"class C
{
    static void Main()
    {
        var s = default(string);
        s.ToString();
        var i = default(int);
        i.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString(true));
            Assert.True(symbol.Type.NullableAnnotation.IsAnyNullable());
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("System.Int32", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(NullableAnnotation.Unknown, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Default_Nullable()
        {
            var source =
@"class C
{
    static void Main()
    {
        var s = default(string?);
        s.ToString();
        var i = default(int?);
        i.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString(true));
            Assert.True(symbol.Type.NullableAnnotation.IsAnyNullable());
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("System.Int32?", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(NullableAnnotation.Annotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Default_TUnconstrained()
        {
            var source =
@"class C
{
    static void F<T>()
    {
        var s = default(T);
        s.ToString();
        var t = default(T?);
        t.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9),
                // (7,25): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         var t = default(T?);
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 25),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(8, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("T", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(NullableAnnotation.Unknown, symbol.Type.NullableAnnotation);
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            // https://github.com/dotnet/roslyn/issues/29856: Is T correct?
            Assert.Equal("T", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(NullableAnnotation.Unknown, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void Default_TClass()
        {
            var source =
@"class C
{
    static void F<T>() where T : class
    {
        var s = default(T);
        s.ToString();
        var t = default(T?);
        t.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(8, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("T?", symbol.Type.ToTestDisplayString(true));
            Assert.True(symbol.Type.NullableAnnotation.IsAnyNullable());
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("T?", symbol.Type.ToTestDisplayString(true));
            Assert.True(symbol.Type.NullableAnnotation.IsAnyNullable());
        }

        [Fact]
        public void DefaultInferred_NonNullable()
        {
            var source =
@"class C
{
    static void Main()
    {
        string s = default;
        s.ToString();
        int i = default;
        i.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         string s = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(5, 20),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("System.String!", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(NullableAnnotation.NotAnnotated, symbol.Type.NullableAnnotation);
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("System.Int32", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(NullableAnnotation.NotAnnotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void DefaultInferred_Nullable()
        {
            var source =
@"class C
{
    static void Main()
    {
        string? s = default;
        s.ToString();
        int? i = default;
        i.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("System.String?", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(NullableAnnotation.Annotated, symbol.Type.NullableAnnotation);
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("System.Int32?", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(NullableAnnotation.Annotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void DefaultInferred_TUnconstrained()
        {
            var source =
@"class C
{
    static void F<T>()
    {
        T s = default;
        s.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            // https://github.com/dotnet/roslyn/issues/29895: Improve this diagnostic. default is the cause of the error, but is not mentioned in the diagnostic.
            comp.VerifyDiagnostics(
                // (5,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T s = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(5, 15),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("T", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(NullableAnnotation.NotAnnotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        public void DefaultInferred_TClass()
        {
            var source =
@"class C
{
    static void F<T>() where T : class
    {
        T s = default;
        s.ToString();
        T? t = default;
        t.ToString();
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T s = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(5, 15),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         s.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(6, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(8, 9));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarators = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().ToArray();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[0]);
            Assert.Equal("T!", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(NullableAnnotation.NotAnnotated, symbol.Type.NullableAnnotation);
            symbol = (LocalSymbol)model.GetDeclaredSymbol(declarators[1]);
            Assert.Equal("T?", symbol.Type.ToTestDisplayString(true));
            Assert.Equal(NullableAnnotation.Annotated, symbol.Type.NullableAnnotation);
        }

        [Fact]
        [WorkItem(29896, "https://github.com/dotnet/roslyn/issues/29618")]
        public void DeconstructionTypeInference()
        {
            var source =
@"class C
{
    static void F((object? a, object? b) t)
    {
        if (t.b == null) return;
        object? x;
        object? y;
        (x, y) = t;
        x.ToString();
        y.ToString();
    }
    static void F(object? a, object? b)
    {
        if (b == null) return;
        object? x;
        object? y;
        (x, y) = (a, b);
        x.ToString();
        y.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(9, 9),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(18, 9));
        }

        [Fact]
        public void IdentityConversion_DeconstructionAssignment()
        {
            var source =
@"interface IIn<in T> { }
interface IOut<out T> { }
class C<T>
{
    void Deconstruct(out IIn<T> x, out IOut<T> y)
    {
        throw new System.NotImplementedException();
    }
    static void F(C<object> c)
    {
        IIn<object?> x;
        IOut<object?> y;
        (x, y) = c;
    }
    static void G(C<object?> c)
    {
        IIn<object> x;
        IOut<object> y;
        (x, y) = c;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,10): warning CS8620: Nullability of reference types in argument of type 'IIn<object?>' doesn't match target type 'IIn<object>' for parameter 'x' in 'void C<object>.Deconstruct(out IIn<object> x, out IOut<object> y)'.
                //         (x, y) = c;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("IIn<object?>", "IIn<object>", "x", "void C<object>.Deconstruct(out IIn<object> x, out IOut<object> y)").WithLocation(13, 10),
                // (19,13): warning CS8620: Nullability of reference types in argument of type 'IOut<object>' doesn't match target type 'IOut<object?>' for parameter 'y' in 'void C<object?>.Deconstruct(out IIn<object?> x, out IOut<object?> y)'.
                //         (x, y) = c;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IOut<object>", "IOut<object?>", "y", "void C<object?>.Deconstruct(out IIn<object?> x, out IOut<object?> y)").WithLocation(19, 13));
        }

        [Fact]
        [WorkItem(29618, "https://github.com/dotnet/roslyn/issues/29618")]
        public void DeconstructionTypeInference_01()
        {
            var source =
@"class C
{
    static void M()
    {
        (var x, var y) = ((string?)null, string.Empty);
        x.ToString();
        y.ToString();
        x = null;
        y = null;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 9));
        }

        [Fact]
        [WorkItem(29618, "https://github.com/dotnet/roslyn/issues/29618")]
        public void DeconstructionTypeInference_02()
        {
            var source =
@"class C
{
    static (string?, string) F() => (string.Empty, string.Empty);
    static void G()
    {
        (var x, var y) = F();
        x.ToString();
        y.ToString();
        x = null;
        y = null;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9));
        }

        [Fact]
        [WorkItem(29618, "https://github.com/dotnet/roslyn/issues/29618")]
        public void DeconstructionTypeInference_03()
        {
            var source =
@"class C
{
    void Deconstruct(out string? x, out string y)
    {
        x = string.Empty;
        y = string.Empty;
    }
    static void M()
    {
        (var x, var y) = new C();
        x.ToString();
        y.ToString();
        x = null;
        y = null;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(11, 9),
                // (14,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(14, 13));
        }

        [Fact]
        public void DeconstructionTypeInference_04()
        {
            var source =
@"class C
{
    static (string?, string) F() => (null, string.Empty);
    static void G()
    {
        string x;
        string? y;
        var t = ((x, y) = F());
        _ = t/*T:(string! x, string? y)*/;
        t.x.ToString(); // 1
        t.y.ToString();
        t.x = null;
        t.y = null; // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29618: Deconstruction should infer string? for x,
            // string! for y, and (string?, string!) for t.
            comp.VerifyDiagnostics(
                // (8,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var t = ((x, y) = F());
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "F()").WithLocation(8, 27),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         t.y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.y").WithLocation(11, 9),
                // (12,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         t.x = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(12, 15));
            comp.VerifyTypes();
        }

        [Fact]
        public void DeconstructionTypeInference_05()
        {
            var source =
@"using System;
using System.Collections.Generic;
class C
{
    static IEnumerable<(string, string?)> F() => throw new Exception();
    static void G()
    {
        foreach ((var x, var y) in F())
        {
            x.ToString();
            y.ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29618: Deconstruction should infer `string?` for `var y`.
            comp.VerifyDiagnostics();
            //// (11,13): warning CS8602: Possible dereference of a null reference.
            ////             y.ToString();
            //Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(11, 13));
        }

        [Fact]
        public void Discard_01()
        {
            var source =
@"class C
{
    static void F((object, object?) t)
    {
        object? x;
        ((_, x) = t).Item1.ToString();
        ((x, _) = t).Item2.ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/29618: Should report WRN_NullReferenceReceiver.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            //// (7,9): warning CS8602: Possible dereference of a null reference.
            ////         ((x, _) = t).Item2.ToString();
            //Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((x, _) = t).Item2").WithLocation(7, 9));
        }

        [Fact]
        public void Discard_02()
        {
            // https://github.com/dotnet/roslyn/issues/29635 Need to re-infer discards
            var source =
@"class C<T>
{
" + NonNullTypesOn() + @"
    void F(object o1, object? o2, C<object> o3, C<object?> o4)
    {
        _ /*T:object*/ = o1;
        _ /*T:object*/ = o2;
        _ /*T:C<object!>*/ = o3;
        _ /*T:C<object?>*/ = o4;
    }
" + NonNullTypesOff() + @"
    void F(C<object> o)
    {
        _ /*T:C<object>*/ = o;
    }
}";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        public void BinaryOperator_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(string? x1, string? y1)
    {
        string z1 = x1 + y1;
    }

    void Test2(string? x2, string? y2)
    {
        string z2 = x2 + y2 ?? """";
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (15,21): hidden CS8607: Expression is probably never null.
                 //         string z2 = x2 + y2 ?? "";
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2 + y2").WithLocation(15, 21)
                );
        }

        [Fact]
        public void BinaryOperator_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(dynamic? x1, dynamic? y1)
    {
        dynamic z1 = x1 + y1;
    }

    void Test2(dynamic? x2, dynamic? y2)
    {
        dynamic z2 = x2 + y2 ?? """";
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void BinaryOperator_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(string? x1, CL0? y1)
    {
        CL0? z1 = x1 + y1;
        CL0 u1 = z1 ?? new CL0();
    }

    void Test2(string? x2, CL1? y2)
    {
        CL1 z2 = x2 + y2;
    }

    void Test3(string x3, CL0? y3, CL2 z3)
    {
        CL2 u3 = x3 + y3 + z3;
    }

    void Test4(string x4, CL1 y4, CL2 z4)
    {
        CL2 u4 = x4 + y4 + z4;
    }
}

class CL0 
{

    public static CL0 operator + (string? x, CL0 y)
    {
        return y;
    }
}

class CL1 
{

    public static CL1? operator + (string x, CL1? y)
    {
        return y;
    }
}

class CL2 
{

    public static CL2 operator + (CL0 x, CL2 y)
    {
        return y;
    }

    public static CL2 operator + (CL1 x, CL2 y)
    {
        return y;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,24): warning CS8604: Possible null reference argument for parameter 'y' in 'CL0 CL0.operator +(string? x, CL0 y)'.
                 //         CL0? z1 = x1 + y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y1").WithArguments("y", "CL0 CL0.operator +(string? x, CL0 y)").WithLocation(10, 24),
                 // (11,18): hidden CS8607: Expression is probably never null.
                 //         CL0 u1 = z1 ?? new CL0();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z1").WithLocation(11, 18),
                 // (16,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1? CL1.operator +(string x, CL1? y)'.
                 //         CL1 z2 = x2 + y2;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("x", "CL1? CL1.operator +(string x, CL1? y)").WithLocation(16, 18),
                 // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL1 z2 = x2 + y2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2 + y2").WithLocation(16, 18),
                 // (21,23): warning CS8604: Possible null reference argument for parameter 'y' in 'CL0 CL0.operator +(string? x, CL0 y)'.
                 //         CL2 u3 = x3 + y3 + z3;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y3").WithArguments("y", "CL0 CL0.operator +(string? x, CL0 y)").WithLocation(21, 23),
                 // (26,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL2 CL2.operator +(CL1 x, CL2 y)'.
                 //         CL2 u4 = x4 + y4 + z4;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x4 + y4").WithArguments("x", "CL2 CL2.operator +(CL1 x, CL2 y)").WithLocation(26, 18)
                );
        }

        [Fact]
        public void BinaryOperator_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1, CL0? y1)
    {
        CL0? z1 = x1 && y1;
        CL0 u1 = z1;
    }

    void Test2(CL0 x2, CL0? y2)
    {
        CL0? z2 = x2 && y2;
        CL0 u2 = z2 ?? new CL0();
    }
}

class CL0
{
    public static CL0 operator &(CL0 x, CL0? y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0 x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'bool CL0.operator false(CL0 x)'.
                 //         CL0? z1 = x1 && y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "bool CL0.operator false(CL0 x)").WithLocation(10, 19),
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator &(CL0 x, CL0? y)'.
                 //         CL0? z1 = x1 && y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL0 CL0.operator &(CL0 x, CL0? y)").WithLocation(10, 19),
                 // (17,18): hidden CS8607: Expression is probably never null.
                 //         CL0 u2 = z2 ?? new CL0();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z2").WithLocation(17, 18)
                );
        }

        [Fact]
        public void BinaryOperator_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1, CL0? y1)
    {
        CL0? z1 = x1 && y1;
    }
}

class CL0
{
    public static CL0 operator &(CL0? x, CL0 y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0 x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'bool CL0.operator false(CL0 x)'.
                 //         CL0? z1 = x1 && y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "bool CL0.operator false(CL0 x)").WithLocation(10, 19),
                 // (10,25): warning CS8604: Possible null reference argument for parameter 'y' in 'CL0 CL0.operator &(CL0? x, CL0 y)'.
                 //         CL0? z1 = x1 && y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y1").WithArguments("y", "CL0 CL0.operator &(CL0? x, CL0 y)").WithLocation(10, 25)
                );
        }

        [Fact]
        public void BinaryOperator_06()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1, CL0? y1)
    {
        CL0? z1 = x1 && y1;
    }
}

class CL0
{
    public static CL0 operator &(CL0? x, CL0? y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0? x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void BinaryOperator_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1, CL0? y1)
    {
        CL0? z1 = x1 || y1;
    }
}

class CL0
{
    public static CL0 operator |(CL0? x, CL0? y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0? x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'bool CL0.operator true(CL0 x)'.
                 //         CL0? z1 = x1 || y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "bool CL0.operator true(CL0 x)").WithLocation(10, 19)
                );
        }

        [Fact]
        public void BinaryOperator_08()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1, CL0? y1)
    {
        CL0? z1 = x1 || y1;
    }
}

class CL0
{
    public static CL0 operator |(CL0? x, CL0? y)
    {
        return new CL0();
    }

    public static bool operator true(CL0? x)
    {
        return false;
    }

    public static bool operator false(CL0 x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void BinaryOperator_09()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0 x1, CL0 y1, CL0 z1)
    {
        CL0? u1 = x1 && y1 || z1;
    }
}

class CL0
{
    public static CL0? operator &(CL0 x, CL0 y)
    {
        return new CL0();
    }

    public static CL0 operator |(CL0 x, CL0 y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0 x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'bool CL0.operator true(CL0 x)'.
                 //         CL0? u1 = x1 && y1 || z1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1 && y1").WithArguments("x", "bool CL0.operator true(CL0 x)").WithLocation(10, 19),
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator |(CL0 x, CL0 y)'.
                 //         CL0? u1 = x1 && y1 || z1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1 && y1").WithArguments("x", "CL0 CL0.operator |(CL0 x, CL0 y)").WithLocation(10, 19)
                );
        }

        [Fact]
        public void BinaryOperator_10()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1, CL0? y1, CL0? z1)
    {
        CL0? u1 = x1 && y1 || z1;
    }

    void Test2(CL0 x2, CL0? y2, CL0? z2)
    {
        CL0? u1 = x2 && y2 || z2;
    }
}

class CL0
{
    public static CL0 operator &(CL0? x, CL0? y)
    {
        return new CL0();
    }

    public static CL0 operator |(CL0 x, CL0? y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0? x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void BinaryOperator_11()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(System.Action x1, System.Action y1)
    {
        System.Action u1 = x1 + y1;
    }

    void Test2(System.Action x2, System.Action y2)
    {
        System.Action u2 = x2 + y2 ?? x2;
    }

    void Test3(System.Action? x3, System.Action y3)
    {
        System.Action u3 = x3 + y3;
    }

    void Test4(System.Action? x4, System.Action y4)
    {
        System.Action u4 = x4 + y4 ?? y4;
    }

    void Test5(System.Action x5, System.Action? y5)
    {
        System.Action u5 = x5 + y5;
    }

    void Test6(System.Action x6, System.Action? y6)
    {
        System.Action u6 = x6 + y6 ?? x6;
    }

    void Test7(System.Action? x7, System.Action? y7)
    {
        System.Action u7 = x7 + y7;
    }

    void Test8(System.Action x8, System.Action y8)
    {
        System.Action u8 = x8 - y8;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (15,28): hidden CS8607: Expression is probably never null.
                //         System.Action u2 = x2 + y2 ?? x2;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2 + y2").WithLocation(15, 28),
                // (25,28): hidden CS8607: Expression is probably never null.
                //         System.Action u4 = x4 + y4 ?? y4;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x4 + y4").WithLocation(25, 28),
                // (35,28): hidden CS8607: Expression is probably never null.
                //         System.Action u6 = x6 + y6 ?? x6;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x6 + y6").WithLocation(35, 28),
                // (40,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         System.Action u7 = x7 + y7;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x7 + y7").WithLocation(40, 28),
                // (45,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         System.Action u8 = x8 - y8;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x8 - y8").WithLocation(45, 28)
                );
        }

        [Fact]
        public void BinaryOperator_12()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0 x1, CL0 y1)
    {
        CL0? u1 = x1 && !y1;
    }

    void Test2(bool x2, bool y2)
    {
        bool u2 = x2 && !y2;
    }
}

class CL0
{
    public static CL0 operator &(CL0? x, CL0 y)
    {
        return new CL0();
    }

    public static bool operator true(CL0? x)
    {
        return false;
    }

    public static bool operator false(CL0? x)
    {
        return false;
    }

    public static CL0? operator !(CL0 x)
    {
        return null;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,25): warning CS8604: Possible null reference argument for parameter 'y' in 'CL0 CL0.operator &(CL0? x, CL0 y)'.
                 //         CL0? u1 = x1 && !y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "!y1").WithArguments("y", "CL0 CL0.operator &(CL0? x, CL0 y)").WithLocation(10, 25)
                );
        }

        [Fact]
        public void BinaryOperator_13()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0 x1, CL0 y1)
    {
        CL0 z1 = x1 && y1;
    }
}

class CL0
{
    public static CL0? operator &(CL0 x, CL0 y)
    {
        return new CL0();
    }

    public static bool operator true(CL0 x)
    {
        return false;
    }

    public static bool operator false(CL0? x)
    {
        return false;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL0 z1 = x1 && y1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1 && y1").WithLocation(10, 18)
                );
        }

        [Fact]
        public void BinaryOperator_14()
        {
            var source =
@"struct S
{
    public static S operator&(S a, S b) => a;
    public static S operator|(S a, S b) => b;
    public static bool operator true(S? s) => true;
    public static bool operator false(S? s) => false;
    static void And(S x, S? y)
    {
        if (x && x) { }
        if (x && y) { }
        if (y && x) { }
        if (y && y) { }
    }
    static void Or(S x, S? y)
    {
        if (x || x) { }
        if (x || y) { }
        if (y || x) { }
        if (y || y) { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void BinaryOperator_15()
        {
            var source =
@"struct S
{
    public static S operator+(S a, S b) => a;
    static void F(S x, S? y)
    {
        S? s;
        s = x + x;
        s = x + y;
        s = y + x;
        s = y + y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void BinaryOperator_16()
        {
            var source =
@"struct S
{
    public static bool operator<(S a, S b) => true;
    public static bool operator<=(S a, S b) => true;
    public static bool operator>(S a, S b) => true;
    public static bool operator>=(S a, S b) => true;
    public static bool operator==(S a, S b) => true;
    public static bool operator!=(S a, S b) => true;
    public override bool Equals(object other) => true;
    public override int GetHashCode() => 0;
    static void F(S x, S? y)
    {
        if (x < y) { }
        if (x <= y) { }
        if (x > y) { }
        if (x >= y) { }
        if (x == y) { }
        if (x != y) { }
        if (y < x) { }
        if (y <= x) { }
        if (y > x) { }
        if (y >= x) { }
        if (y == x) { }
        if (y != x) { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void MethodGroupConversion_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1)
    {
        System.Action u1 = x1.M1;
    }

    void Test2(CL0 x2)
    {
        System.Action u2 = x2.M1;
    }
}

class CL0
{
    public void M1() {}
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,28): warning CS8602: Possible dereference of a null reference.
                 //         System.Action u1 = x1.M1;
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(10, 28)
                );
        }

        [Fact]
        public void MethodGroupConversion_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void M1<T>(T x){}

    void Test1()
    {
        System.Action<string?> u1 = M1<string>;
    }

    void Test2()
    {
        System.Action<string> u2 = M1<string?>;
    }

    void Test3()
    {
        System.Action<CL0<string?>> u3 = M1<CL0<string>>;
    }

    void Test4()
    {
        System.Action<CL0<string>> u4 = M1<CL0<string?>>;
    }
}

class CL0<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,37): warning CS8622: Nullability of reference types in type of parameter 'x' of 'void C.M1<string>(string x)' doesn't match the target delegate 'Action<string?>'.
                //         System.Action<string?> u1 = M1<string>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "M1<string>").WithArguments("x", "void C.M1<string>(string x)", "System.Action<string?>").WithLocation(12, 37),
                // (22,42): warning CS8622: Nullability of reference types in type of parameter 'x' of 'void C.M1<CL0<string>>(CL0<string> x)' doesn't match the target delegate 'Action<CL0<string?>>'.
                //         System.Action<CL0<string?>> u3 = M1<CL0<string>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "M1<CL0<string>>").WithArguments("x", "void C.M1<CL0<string>>(CL0<string> x)", "System.Action<CL0<string?>>").WithLocation(22, 42),
                // (27,41): warning CS8622: Nullability of reference types in type of parameter 'x' of 'void C.M1<CL0<string?>>(CL0<string?> x)' doesn't match the target delegate 'Action<CL0<string>>'.
                //         System.Action<CL0<string>> u4 = M1<CL0<string?>>;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "M1<CL0<string?>>").WithArguments("x", "void C.M1<CL0<string?>>(CL0<string?> x)", "System.Action<CL0<string>>").WithLocation(27, 41)
                );
        }

        [Fact]
        public void MethodGroupConversion_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    void M1<T>(T x){}

    void Test1()
    {
        System.Action<string?> u1 = (System.Action<string?>)M1<string>; // 1
        System.Action<string> u2 = (System.Action<string>)M1<string?>;
        System.Action<CL0<string?>> u3 = (System.Action<CL0<string?>>)M1<CL0<string>>; // 2
        System.Action<CL0<string>> u4 = (System.Action<CL0<string>>)M1<CL0<string?>>; //3
    }
}

class CL0<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (8,37): warning CS8622: Nullability of reference types in type of parameter 'x' of 'void C.M1<string>(string x)' doesn't match the target delegate 'Action<string?>'.
                //         System.Action<string?> u1 = (System.Action<string?>)M1<string>; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(System.Action<string?>)M1<string>").WithArguments("x", "void C.M1<string>(string x)", "System.Action<string?>").WithLocation(8, 37),
                // (10,42): warning CS8622: Nullability of reference types in type of parameter 'x' of 'void C.M1<CL0<string>>(CL0<string> x)' doesn't match the target delegate 'Action<CL0<string?>>'.
                //         System.Action<CL0<string?>> u3 = (System.Action<CL0<string?>>)M1<CL0<string>>; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(System.Action<CL0<string?>>)M1<CL0<string>>").WithArguments("x", "void C.M1<CL0<string>>(CL0<string> x)", "System.Action<CL0<string?>>").WithLocation(10, 42),
                // (11,41): warning CS8622: Nullability of reference types in type of parameter 'x' of 'void C.M1<CL0<string?>>(CL0<string?> x)' doesn't match the target delegate 'Action<CL0<string>>'.
                //         System.Action<CL0<string>> u4 = (System.Action<CL0<string>>)M1<CL0<string?>>; //3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(System.Action<CL0<string>>)M1<CL0<string?>>").WithArguments("x", "void C.M1<CL0<string?>>(CL0<string?> x)", "System.Action<CL0<string>>").WithLocation(11, 41)
                );
        }

        [Fact]
        public void MethodGroupConversion_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    T M1<T>(){throw new System.Exception();}

    void Test1()
    {
        System.Func<string?> u1 = M1<string>;
    }

    void Test2()
    {
        System.Func<string> u2 = M1<string?>;
    }

    void Test3()
    {
        System.Func<CL0<string?>> u3 = M1<CL0<string>>;
    }

    void Test4()
    {
        System.Func<CL0<string>> u4 = M1<CL0<string?>>;
    }
}

class CL0<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (17,34): warning CS8621: Nullability of reference types in return type of 'string? C.M1<string?>()' doesn't match the target delegate 'Func<string>'.
                 //         System.Func<string> u2 = M1<string?>;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "M1<string?>").WithArguments("string? C.M1<string?>()", "System.Func<string>").WithLocation(17, 34),
                 // (22,40): warning CS8621: Nullability of reference types in return type of 'CL0<string> C.M1<CL0<string>>()' doesn't match the target delegate 'Func<CL0<string?>>'.
                 //         System.Func<CL0<string?>> u3 = M1<CL0<string>>;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "M1<CL0<string>>").WithArguments("CL0<string> C.M1<CL0<string>>()", "System.Func<CL0<string?>>").WithLocation(22, 40),
                 // (27,39): warning CS8621: Nullability of reference types in return type of 'CL0<string?> C.M1<CL0<string?>>()' doesn't match the target delegate 'Func<CL0<string>>'.
                 //         System.Func<CL0<string>> u4 = M1<CL0<string?>>;
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "M1<CL0<string?>>").WithArguments("CL0<string?> C.M1<CL0<string?>>()", "System.Func<CL0<string>>").WithLocation(27, 39)
                );
        }

        [Fact]
        public void MethodGroupConversion_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    T M1<T>(){throw new System.Exception();}

    void Test1()
    {
        System.Func<string?> u1 = (System.Func<string?>)M1<string>;
        System.Func<string> u2 = (System.Func<string>)M1<string?>; // 1
        System.Func<CL0<string?>> u3 = (System.Func<CL0<string?>>)M1<CL0<string>>; // 2
        System.Func<CL0<string>> u4 = (System.Func<CL0<string>>)M1<CL0<string?>>; // 3
    }
}

class CL0<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,34): warning CS8621: Nullability of reference types in return type of 'string? C.M1<string?>()' doesn't match the target delegate 'Func<string>'.
                //         System.Func<string> u2 = (System.Func<string>)M1<string?>; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "(System.Func<string>)M1<string?>").WithArguments("string? C.M1<string?>()", "System.Func<string>").WithLocation(13, 34),
                // (14,40): warning CS8621: Nullability of reference types in return type of 'CL0<string> C.M1<CL0<string>>()' doesn't match the target delegate 'Func<CL0<string?>>'.
                //         System.Func<CL0<string?>> u3 = (System.Func<CL0<string?>>)M1<CL0<string>>; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "(System.Func<CL0<string?>>)M1<CL0<string>>").WithArguments("CL0<string> C.M1<CL0<string>>()", "System.Func<CL0<string?>>").WithLocation(14, 40),
                // (15,39): warning CS8621: Nullability of reference types in return type of 'CL0<string?> C.M1<CL0<string?>>()' doesn't match the target delegate 'Func<CL0<string>>'.
                //         System.Func<CL0<string>> u4 = (System.Func<CL0<string>>)M1<CL0<string?>>; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "(System.Func<CL0<string>>)M1<CL0<string?>>").WithArguments("CL0<string?> C.M1<CL0<string?>>()", "System.Func<CL0<string>>").WithLocation(15, 39)
                );
        }

        [Fact]
        public void MethodGroupConversion_06()
        {
            var source =
@"delegate void D<T>(T t) where T : A;
class A { }
class B<T>
{
    internal void F(T t) { }
}
class C
{
    static B<T> Create<T>(T t) => new B<T>();
    static void G(A x, A? y)
    {
        D<A> d;
        d = Create(x).F;
        d = Create(y).F; // warning
        x = y;
        d = Create(x).F; // warning
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29844: Report conversion warnings.
            comp.VerifyDiagnostics(
                // (15,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = y;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(15, 13));
        }

        [Fact]
        public void UnaryOperator_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1)
    {
        CL0 u1 = !x1;
    }

    void Test2(CL1 x2)
    {
        CL1 u2 = !x2;
    }

    void Test3(CL2? x3)
    {
        CL2 u3 = !x3;
    }

    void Test4(CL1 x4)
    {
        dynamic y4 = x4; 
        CL1 u4 = !y4;
        dynamic v4 = !y4 ?? y4; 
    }

    void Test5(bool x5)
    {
        bool u5 = !x5;
    }
}

class CL0
{
    public static CL0 operator !(CL0 x)
    {
        return new CL0();
    }
}

class CL1
{
    public static CL1? operator !(CL1 x)
    {
        return new CL1();
    }
}

class CL2
{
    public static CL2 operator !(CL2? x)
    {
        return new CL2();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator !(CL0 x)'.
                //         CL0 u1 = !x1;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL0 CL0.operator !(CL0 x)").WithLocation(10, 19),
                // (15,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u2 = !x2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "!x2").WithLocation(15, 18)
                );
        }

        [Fact]
        public void UnaryOperator_02()
        {
            var source =
@"struct S
{
    public static S operator~(S s) => s;
    static void F(S? s)
    {
        s = ~s;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Conversion_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1)
    {
        CL1 u1 = x1;
    }

    void Test2(CL0? x2, CL0 y2)
    {
        int u2 = x2;
        long v2 = x2;
        int w2 = y2;
    }

    void Test3(CL0 x3)
    {
        CL2 u3 = x3;
    }

    void Test4(CL0 x4)
    {
        CL3? u4 = x4;
        CL3 v4 = u4 ?? new CL3();
    }

    void Test5(dynamic? x5)
    {
        CL3 u5 = x5;
    }

    void Test6(dynamic? x6)
    {
        CL3? u6 = x6;
        CL3 v6 = u6 ?? new CL3();
    }

    void Test7(CL0? x7)
    {
        dynamic u7 = x7;
    }

    void Test8(CL0 x8)
    {
        dynamic? u8 = x8;
        dynamic v8 = u8 ?? x8;
    }

    void Test9(dynamic? x9)
    {
        object u9 = x9;
    }

    void Test10(object? x10)
    {
        dynamic u10 = x10;
    }

    void Test11(CL4? x11)
    {
        CL3 u11 = x11;
    }

    void Test12(CL3? x12)
    {
        CL4 u12 = (CL4)x12;
    }

    void Test13(int x13)
    {
        object? u13 = x13;
        object v13 = u13 ?? new object();
    }

    void Test14<T>(T x14)
    {
        object u14 = x14;
        object v14 = ((object)x14) ?? new object();
    }

    void Test15(int? x15)
    {
        object u15 = x15;
    }

    void Test16()
    {
        System.IFormattable? u16 = $""{3}"";
        object v16 = u16 ?? new object();
    }
}

class CL0
{
    public static implicit operator CL1(CL0 x) { return new CL1(); }
    public static implicit operator int(CL0 x) { return 0; }
    public static implicit operator long(CL0? x) { return 0; }
    public static implicit operator CL2?(CL0 x) { return new CL2(); }
    public static implicit operator CL3(CL0? x) { return new CL3(); }
}

class CL1 {}
class CL2 {}
class CL3 {}
class CL4 : CL3 {}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0.implicit operator CL1(CL0 x)'.
                //         CL1 u1 = x1;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL0.implicit operator CL1(CL0 x)").WithLocation(10, 18),
                // (15,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0.implicit operator int(CL0 x)'.
                //         int u2 = x2;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("x", "CL0.implicit operator int(CL0 x)").WithLocation(15, 18),
                // (22,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL2 u3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(22, 18),
                // (28,18): hidden CS8607: Expression is probably never null.
                //         CL3 v4 = u4 ?? new CL3();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4").WithLocation(28, 18),
                // (33,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL3 u5 = x5;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x5").WithLocation(33, 18),
                // (44,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         dynamic u7 = x7;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x7").WithLocation(44, 22),
                // (50,22): hidden CS8607: Expression is probably never null.
                //         dynamic v8 = u8 ?? x8;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u8").WithLocation(50, 22),
                // (55,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object u9 = x9;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x9").WithLocation(55, 21),
                // (60,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         dynamic u10 = x10;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x10").WithLocation(60, 23),
                // (65,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL3 u11 = x11;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x11").WithLocation(65, 19),
                // (70,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL4 u12 = (CL4)x12;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(CL4)x12").WithLocation(70, 19),
                // (76,22): hidden CS8607: Expression is probably never null.
                //         object v13 = u13 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u13").WithLocation(76, 22),
                // (81,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object u14 = x14;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x14").WithLocation(81, 22),
                // (82,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object v14 = ((object)x14) ?? new object();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)x14").WithLocation(82, 23),
                // (87,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object u15 = x15;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x15").WithLocation(87, 22),
                // (93,22): hidden CS8607: Expression is probably never null.
                //         object v16 = u16 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u16").WithLocation(93, 22)
                );
        }

        [Fact]
        public void Conversion_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0<string?> x1)
    {
        CL0<string> u1 = x1;
        CL0<string> v1 = (CL0<string>)x1;
    }
}

class CL0<T>
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,26): warning CS8619: Nullability of reference types in value of type 'CL0<string?>' doesn't match target type 'CL0<string>'.
                //         CL0<string> u1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("CL0<string?>", "CL0<string>").WithLocation(10, 26),
                // (11,26): warning CS8619: Nullability of reference types in value of type 'CL0<string?>' doesn't match target type 'CL0<string>'.
                //         CL0<string> v1 = (CL0<string>)x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(CL0<string>)x1").WithArguments("CL0<string?>", "CL0<string>").WithLocation(11, 26)
                );
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void ImplicitConversions_01()
        {
            var source =
@"class A<T> { }
class B<T> : A<T> { }
class C
{
    static void F1(B<object> x1)
    {
        A<object?> y1 = x1;
        y1 = x1;
        y1 = x1!;
    }
    static void F2(B<object?> x2)
    {
        A<object> y2 = x2;
        y2 = x2;
        y2 = x2!;
    }
    static void F3(B<object>? x3)
    {
        A<object?> y3 = x3;
        y3 = x3;
        y3 = x3!;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,25): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         A<object?> y1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("B<object>", "A<object?>").WithLocation(7, 25),
                // (8,14): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         y1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("B<object>", "A<object?>").WithLocation(8, 14),
                // (13,24): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         A<object> y2 = x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("B<object?>", "A<object>").WithLocation(13, 24),
                // (14,14): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         y2 = x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("B<object?>", "A<object>").WithLocation(14, 14),
                // (19,25): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         A<object?> y3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(19, 25),
                // (19,25): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         A<object?> y3 = x3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3").WithArguments("B<object>", "A<object?>").WithLocation(19, 25),
                // (20,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(20, 14),
                // (20,14): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         y3 = x3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3").WithArguments("B<object>", "A<object?>").WithLocation(20, 14)
                );
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void ImplicitConversions_02()
        {
            var source =
@"interface IA<T> { }
interface IB<T> : IA<T> { }
class C
{
    static void F1(IB<object> x1)
    {
        IA<object?> y1 = x1;
        y1 = x1;
        y1 = x1!;
    }
    static void F2(IB<object?> x2)
    {
        IA<object> y2 = x2;
        y2 = x2;
        y2 = x2!;
    }
    static void F3(IB<object>? x3)
    {
        IA<object?> y3 = x3;
        y3 = x3;
        y3 = x3!;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,26): warning CS8619: Nullability of reference types in value of type 'IB<object>' doesn't match target type 'IA<object?>'.
                //         IA<object?> y1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("IB<object>", "IA<object?>").WithLocation(7, 26),
                // (8,14): warning CS8619: Nullability of reference types in value of type 'IB<object>' doesn't match target type 'IA<object?>'.
                //         y1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("IB<object>", "IA<object?>").WithLocation(8, 14),
                // (13,25): warning CS8619: Nullability of reference types in value of type 'IB<object?>' doesn't match target type 'IA<object>'.
                //         IA<object> y2 = x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("IB<object?>", "IA<object>").WithLocation(13, 25),
                // (14,14): warning CS8619: Nullability of reference types in value of type 'IB<object?>' doesn't match target type 'IA<object>'.
                //         y2 = x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("IB<object?>", "IA<object>").WithLocation(14, 14),
                // (19,26): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         IA<object?> y3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(19, 26),
                // (19,26): warning CS8619: Nullability of reference types in value of type 'IB<object>' doesn't match target type 'IA<object?>'.
                //         IA<object?> y3 = x3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3").WithArguments("IB<object>", "IA<object?>").WithLocation(19, 26),
                // (20,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(20, 14),
                // (20,14): warning CS8619: Nullability of reference types in value of type 'IB<object>' doesn't match target type 'IA<object?>'.
                //         y3 = x3;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x3").WithArguments("IB<object>", "IA<object?>").WithLocation(20, 14));
        }

        [Fact]
        public void ImplicitConversions_03()
        {
            var source =
@"interface IOut<out T> { }
class C
{
    static void F(IOut<object> x)
    {
        IOut<object?> y = x;
    }
    static void G(IOut<object?> x)
    {
        IOut<object> y = x;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,26): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         IOut<object> y = x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IOut<object?>", "IOut<object>").WithLocation(10, 26));
        }

        [Fact]
        public void ImplicitConversions_04()
        {
            var source =
@"interface IIn<in T> { }
class C
{
    static void F(IIn<object> x)
    {
        IIn<object?> y = x;
    }
    static void G(IIn<object?> x)
    {
        IIn<object> y = x;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,26): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         IIn<object?> y = x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("IIn<object>", "IIn<object?>").WithLocation(6, 26));
        }

        [Fact]
        public void ImplicitConversions_05()
        {
            var source =
@"interface IOut<out T> { }
class A<T> : IOut<T> { }
class C
{
    static void F(A<string> x)
    {
        IOut<object?> y = x;
    }
    static void G(A<string?> x)
    {
        IOut<object> y = x;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,26): warning CS8619: Nullability of reference types in value of type 'A<string?>' doesn't match target type 'IOut<object>'.
                //         IOut<object> y = x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<string?>", "IOut<object>").WithLocation(11, 26));
        }

        [Fact]
        public void ImplicitConversions_06()
        {
            var source =
@"interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : IIn<object>, IOut<object?> { }
class B : IIn<object>, IOut<object?> { }
class C
{
    static void F(A<string> a1, B b1)
    {
        IIn<object?> y = a1;
        y = b1;
        IOut<object?> z = a1;
        z = b1;
    }
    static void G(A<string> a2, B b2)
    {
        IIn<object> y = a2;
        y = b2;
        IOut<object> z = a2;
        z = b2;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29897: Report the base types that did not match
            // rather than the derived or implementing type. For instance, report `'IIn<object>'
            // doesn't match ... 'IIn<object?>'` rather than `'A<string>' doesn't match ...`.
            comp.VerifyDiagnostics(
                // (9,26): warning CS8619: Nullability of reference types in value of type 'A<string>' doesn't match target type 'IIn<object?>'.
                //         IIn<object?> y = a1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a1").WithArguments("A<string>", "IIn<object?>").WithLocation(9, 26),
                // (10,13): warning CS8619: Nullability of reference types in value of type 'B' doesn't match target type 'IIn<object?>'.
                //         y = b1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b1").WithArguments("B", "IIn<object?>").WithLocation(10, 13),
                // (18,26): warning CS8619: Nullability of reference types in value of type 'A<string>' doesn't match target type 'IOut<object>'.
                //         IOut<object> z = a2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("A<string>", "IOut<object>").WithLocation(18, 26),
                // (19,13): warning CS8619: Nullability of reference types in value of type 'B' doesn't match target type 'IOut<object>'.
                //         z = b2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b2").WithArguments("B", "IOut<object>").WithLocation(19, 13));
        }

        [Fact]
        public void ImplicitConversions_07()
        {
            var source =
@"class A<T>
{
}
class B<T>
{
    public static implicit operator A<T>(B<T> b) => throw null;
}
class C
{
    static B<T> F<T>(T t) => throw null;
    static void G(A<object?> a) => throw null;
    static void Main(object? x)
    {
        var y = F(x);
        G(y);
        if (x == null) return;
        var z =  F(x);
        G(z); // warning
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29898: Report warning for `G(z)`?
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void IdentityConversion_LocalDeclaration()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
interface IBoth<in T, out U> { }
class C
{
    static void F1(I<object> x1, IIn<object> y1, IOut<object> z1, IBoth<object, object> w1)
    {
        I<object?> a1 = x1;
        IIn<object?> b1 = y1;
        IOut<object?> c1 = z1;
        IBoth<object?, object?> d1 = w1;
    }
    static void F2(I<object?> x2, IIn<object?> y2, IOut<object?> z2, IBoth<object?, object?> w2)
    {
        I<object> a2 = x2;
        IIn<object> b2 = y2;
        IOut<object> c2 = z2;
        IBoth<object, object> d2 = w2;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,25): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         I<object?> a1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("I<object>", "I<object?>").WithLocation(9, 25),
                // (10,27): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         IIn<object?> b1 = y1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("IIn<object>", "IIn<object?>").WithLocation(10, 27),
                // (12,38): warning CS8619: Nullability of reference types in value of type 'IBoth<object, object>' doesn't match target type 'IBoth<object?, object?>'.
                //         IBoth<object?, object?> d1 = w1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w1").WithArguments("IBoth<object, object>", "IBoth<object?, object?>").WithLocation(12, 38),
                // (16,24): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         I<object> a2 = x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("I<object?>", "I<object>").WithLocation(16, 24),
                // (18,27): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         IOut<object> c2 = z2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "z2").WithArguments("IOut<object?>", "IOut<object>").WithLocation(18, 27),
                // (19,36): warning CS8619: Nullability of reference types in value of type 'IBoth<object?, object?>' doesn't match target type 'IBoth<object, object>'.
                //         IBoth<object, object> d2 = w2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w2").WithArguments("IBoth<object?, object?>", "IBoth<object, object>").WithLocation(19, 36));
        }

        [Fact]
        public void IdentityConversion_Assignment()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
interface IBoth<in T, out U> { }
class C
{
    static void F1(I<object> x1, IIn<object> y1, IOut<object> z1, IBoth<object, object> w1)
    {
        I<object?> a1;
        a1 = x1;
        IIn<object?> b1;
        b1 = y1;
        IOut<object?> c1;
        c1 = z1;
        IBoth<object?, object?> d1;
        d1 = w1;
    }
    static void F2(I<object?> x2, IIn<object?> y2, IOut<object?> z2, IBoth<object?, object?> w2)
    {
        I<object> a2;
        a2 = x2;
        IIn<object> b2;
        b2 = y2;
        IOut<object> c2;
        c2 = z2;
        IBoth<object, object> d2;
        d2 = w2;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,14): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         a1 = x1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x1").WithArguments("I<object>", "I<object?>").WithLocation(10, 14),
                // (12,14): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         b1 = y1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y1").WithArguments("IIn<object>", "IIn<object?>").WithLocation(12, 14),
                // (16,14): warning CS8619: Nullability of reference types in value of type 'IBoth<object, object>' doesn't match target type 'IBoth<object?, object?>'.
                //         d1 = w1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w1").WithArguments("IBoth<object, object>", "IBoth<object?, object?>").WithLocation(16, 14),
                // (21,14): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         a2 = x2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x2").WithArguments("I<object?>", "I<object>").WithLocation(21, 14),
                // (25,14): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         c2 = z2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "z2").WithArguments("IOut<object?>", "IOut<object>").WithLocation(25, 14),
                // (27,14): warning CS8619: Nullability of reference types in value of type 'IBoth<object?, object?>' doesn't match target type 'IBoth<object, object>'.
                //         d2 = w2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w2").WithArguments("IBoth<object?, object?>", "IBoth<object, object>").WithLocation(27, 14));
        }

        [Fact]
        public void IdentityConversion_Argument()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(I<object> x, IIn<object> y, IOut<object> z)
    {
        G(x, y, z);
    }
    static void G(I<object?> x, IIn<object?> y, IOut<object?> z)
    {
        F(x, y, z);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,11): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'x' in 'void C.G(I<object?> x, IIn<object?> y, IOut<object?> z)'.
                //         G(x, y, z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "x", "void C.G(I<object?> x, IIn<object?> y, IOut<object?> z)").WithLocation(8, 11),
                // (8,14): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'y' in 'void C.G(I<object?> x, IIn<object?> y, IOut<object?> z)'.
                //         G(x, y, z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IIn<object>", "IIn<object?>", "y", "void C.G(I<object?> x, IIn<object?> y, IOut<object?> z)").WithLocation(8, 14),
                // (12,11): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.F(I<object> x, IIn<object> y, IOut<object> z)'.
                //         F(x, y, z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object?>", "I<object>", "x", "void C.F(I<object> x, IIn<object> y, IOut<object> z)").WithLocation(12, 11),
                // (12,17): warning CS8620: Nullability of reference types in argument of type 'IOut<object?>' doesn't match target type 'IOut<object>' for parameter 'z' in 'void C.F(I<object> x, IIn<object> y, IOut<object> z)'.
                //         F(x, y, z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IOut<object?>", "IOut<object>", "z", "void C.F(I<object> x, IIn<object> y, IOut<object> z)").WithLocation(12, 17));
        }

        [Fact]
        public void IdentityConversion_OutArgument()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(out I<object> x, out IIn<object> y, out IOut<object> z)
    {
        G(out x, out y, out z);
    }
    static void G(out I<object?> x, out IIn<object?> y, out IOut<object?> z)
    {
        F(out x, out y, out z);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,15): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'x' in 'void C.G(out I<object?> x, out IIn<object?> y, out IOut<object?> z)'.
                //         G(out x, out y, out z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "x", "void C.G(out I<object?> x, out IIn<object?> y, out IOut<object?> z)").WithLocation(8, 15),
                // (8,29): warning CS8620: Nullability of reference types in argument of type 'IOut<object>' doesn't match target type 'IOut<object?>' for parameter 'z' in 'void C.G(out I<object?> x, out IIn<object?> y, out IOut<object?> z)'.
                //         G(out x, out y, out z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IOut<object>", "IOut<object?>", "z", "void C.G(out I<object?> x, out IIn<object?> y, out IOut<object?> z)").WithLocation(8, 29),
                // (12,15): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.F(out I<object> x, out IIn<object> y, out IOut<object> z)'.
                //         F(out x, out y, out z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object?>", "I<object>", "x", "void C.F(out I<object> x, out IIn<object> y, out IOut<object> z)").WithLocation(12, 15),
                // (12,22): warning CS8620: Nullability of reference types in argument of type 'IIn<object?>' doesn't match target type 'IIn<object>' for parameter 'y' in 'void C.F(out I<object> x, out IIn<object> y, out IOut<object> z)'.
                //         F(out x, out y, out z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IIn<object?>", "IIn<object>", "y", "void C.F(out I<object> x, out IIn<object> y, out IOut<object> z)").WithLocation(12, 22));
        }

        [Fact]
        public void IdentityConversion_RefArgument()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)
    {
        G(ref x, ref y, ref z);
    }
    static void G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)
    {
        F(ref x, ref y, ref z);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,15): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'x' in 'void C.G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)'.
                //         G(ref x, ref y, ref z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "x", "void C.G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)").WithLocation(8, 15),
                // (8,22): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'y' in 'void C.G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)'.
                //         G(ref x, ref y, ref z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IIn<object>", "IIn<object?>", "y", "void C.G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)").WithLocation(8, 22),
                // (8,29): warning CS8620: Nullability of reference types in argument of type 'IOut<object>' doesn't match target type 'IOut<object?>' for parameter 'z' in 'void C.G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)'.
                //         G(ref x, ref y, ref z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IOut<object>", "IOut<object?>", "z", "void C.G(ref I<object?> x, ref IIn<object?> y, ref IOut<object?> z)").WithLocation(8, 29),
                // (12,15): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)'.
                //         F(ref x, ref y, ref z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object?>", "I<object>", "x", "void C.F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)").WithLocation(12, 15),
                // (12,22): warning CS8620: Nullability of reference types in argument of type 'IIn<object?>' doesn't match target type 'IIn<object>' for parameter 'y' in 'void C.F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)'.
                //         F(ref x, ref y, ref z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IIn<object?>", "IIn<object>", "y", "void C.F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)").WithLocation(12, 22),
                // (12,29): warning CS8620: Nullability of reference types in argument of type 'IOut<object?>' doesn't match target type 'IOut<object>' for parameter 'z' in 'void C.F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)'.
                //         F(ref x, ref y, ref z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IOut<object?>", "IOut<object>", "z", "void C.F(ref I<object> x, ref IIn<object> y, ref IOut<object> z)").WithLocation(12, 29));
        }

        [Fact]
        public void IdentityConversion_InArgument()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static void F(in I<object> x, in IIn<object> y, in IOut<object> z)
    {
        G(in x, in y, in z);
    }
    static void G(in I<object?> x, in IIn<object?> y, in IOut<object?> z)
    {
        F(in x, in y, in z);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,14): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'x' in 'void C.G(in I<object?> x, in IIn<object?> y, in IOut<object?> z)'.
                //         G(in x, in y, in z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "x", "void C.G(in I<object?> x, in IIn<object?> y, in IOut<object?> z)").WithLocation(8, 14),
                // (8,20): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'y' in 'void C.G(in I<object?> x, in IIn<object?> y, in IOut<object?> z)'.
                //         G(in x, in y, in z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IIn<object>", "IIn<object?>", "y", "void C.G(in I<object?> x, in IIn<object?> y, in IOut<object?> z)").WithLocation(8, 20),
                // (12,14): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'x' in 'void C.F(in I<object> x, in IIn<object> y, in IOut<object> z)'.
                //         F(in x, in y, in z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object?>", "I<object>", "x", "void C.F(in I<object> x, in IIn<object> y, in IOut<object> z)").WithLocation(12, 14),
                // (12,26): warning CS8620: Nullability of reference types in argument of type 'IOut<object?>' doesn't match target type 'IOut<object>' for parameter 'z' in 'void C.F(in I<object> x, in IIn<object> y, in IOut<object> z)'.
                //         F(in x, in y, in z);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IOut<object?>", "IOut<object>", "z", "void C.F(in I<object> x, in IIn<object> y, in IOut<object> z)").WithLocation(12, 26));
        }

        [Fact]
        public void IdentityConversion_ExtensionThis()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
static class E
{
    static void F1(object x, object? y)
    {
        x.F1A();
        y.F1A();
        x.F1B();
        y.F1B(); // 1
    }
    static void F1A(this object? o) { }
    static void F1B(this object o) { }
    static void F2(I<object> x, I<object?> y)
    {
        x.F2A(); // 2
        y.F2A();
        x.F2B();
        y.F2B(); // 3
    }
    static void F2A(this I<object?> o) { }
    static void F2B(this I<object> o) { }
    static void F3(IIn<object> x, IIn<object?> y)
    {
        x.F3A(); // 4
        y.F3A();
        x.F3B();
        y.F3B();
    }
    static void F3A(this IIn<object?> o) { }
    static void F3B(this IIn<object> o) { }
    static void F4(IOut<object> x, IOut<object?> y)
    {
        x.F4A();
        y.F4A();
        x.F4B();
        y.F4B(); // 5
    }
    static void F4A(this IOut<object?> o) { }
    static void F4B(this IOut<object> o) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,9): warning CS8604: Possible null reference argument for parameter 'o' in 'void E.F1B(object o)'.
                //         y.F1B(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("o", "void E.F1B(object o)").WithLocation(11, 9),
                // (17,9): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'o' in 'void E.F2A(I<object?> o)'.
                //         x.F2A(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<object>", "I<object?>", "o", "void E.F2A(I<object?> o)").WithLocation(17, 9),
                // (20,9): warning CS8620: Nullability of reference types in argument of type 'I<object?>' doesn't match target type 'I<object>' for parameter 'o' in 'void E.F2B(I<object> o)'.
                //         y.F2B(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("I<object?>", "I<object>", "o", "void E.F2B(I<object> o)").WithLocation(20, 9),
                // (26,9): warning CS8620: Nullability of reference types in argument of type 'IIn<object>' doesn't match target type 'IIn<object?>' for parameter 'o' in 'void E.F3A(IIn<object?> o)'.
                //         x.F3A(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("IIn<object>", "IIn<object?>", "o", "void E.F3A(IIn<object?> o)").WithLocation(26, 9),
                // (38,9): warning CS8620: Nullability of reference types in argument of type 'IOut<object?>' doesn't match target type 'IOut<object>' for parameter 'o' in 'void E.F4B(IOut<object> o)'.
                //         y.F4B(); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IOut<object?>", "IOut<object>", "o", "void E.F4B(IOut<object> o)").WithLocation(38, 9));
        }

        // https://github.com/dotnet/roslyn/issues/29899: Clone this method using types from unannotated assemblies
        // rather than `x!`, particularly because `x!` results in IsNullable=false rather than IsNullable=null.
        [Fact]
        public void IdentityConversion_TypeInference_IsNullableNull()
        {
            var source =
@"class A<T>
{
}
class B
{
    static T F1<T>(T x, T y)
    {
        return x;
    }
    static void G1(object? x, object y)
    {
        F1(x, x!).ToString();
        F1(x!, x).ToString();
        F1(y, y!).ToString();
        F1(y!, y).ToString();
    }
    static T F2<T>(A<T> x, A<T> y)
    {
        throw new System.Exception();
    }
    static void G(A<object?> z, A<object> w)
    {
        F2(z, z!).ToString();
        F2(z!, z).ToString();
        F2(w, w!).ToString();
        F2(w!, w).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         F1(x, x!).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F1(x, x!)").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         F1(x!, x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F1(x!, x)").WithLocation(13, 9),
                // (23,9): warning CS8602: Possible dereference of a null reference.
                //         F2(z, z!).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F2(z, z!)").WithLocation(23, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         F2(z!, z).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F2(z!, z)").WithLocation(24, 9));
        }

        [Fact]
        public void IdentityConversion_IndexerArgumentsOrder()
        {
            var source =
@"interface I<T> { }
class C
{
    static object F(C c, I<string> x, I<object> y)
    {
        return c[
            y: y, // warn 1
            x: x];
    }
    static object G(C c, I<string?> x, I<object?> y)
    {
        return c[
            y: y,
            x: x]; // warn 2
    }
    object this[I<string> x, I<object?> y] => new object();
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,16): warning CS8620: Nullability of reference types in argument of type 'I<object>' doesn't match target type 'I<object?>' for parameter 'y' in 'object C.this[I<string> x, I<object?> y]'.
                //             y: y, // warn 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("I<object>", "I<object?>", "y", "object C.this[I<string> x, I<object?> y]").WithLocation(7, 16),
                // (14,16): warning CS8620: Nullability of reference types in argument of type 'I<string?>' doesn't match target type 'I<string>' for parameter 'x' in 'object C.this[I<string> x, I<object?> y]'.
                //             x: x]; // warn 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<string?>", "I<string>", "x", "object C.this[I<string> x, I<object?> y]").WithLocation(14, 16));
        }

        [Fact]
        public void IncrementOperator_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(CL0? x1)
    {
        CL0? u1 = ++x1;
        CL0 v1 = u1 ?? new CL0(); 
        CL0 w1 = x1 ?? new CL0(); 
    }
    void Test2(CL0? x2)
    {
        CL0 u2 = x2++;
        CL0 v2 = x2 ?? new CL0();
    }
    void Test3(CL1? x3)
    {
        CL1 u3 = --x3;
        CL1 v3 = x3;
    }
    void Test4(CL1 x4)
    {
        CL1? u4 = x4--; // Result of increment is nullable, storing it in not nullable parameter.
        CL1 v4 = u4 ?? new CL1(); 
        CL1 w4 = x4 ?? new CL1();
    }
    void Test5(CL1 x5)
    {
        CL1 u5 = --x5;
    }

    void Test6(CL1 x6)
    {
        x6--; 
    }

    void Test7()
    {
        CL1 x7;
        x7--; 
    }
}

class CL0
{
    public static CL0 operator ++(CL0 x)
    {
        return new CL0();
    }
}

class CL1
{
    public static CL1? operator --(CL1? x)
    {
        return new CL1();
    }
}
" }, options: WithNonNullTypesTrue());
            c.VerifyDiagnostics(
                // (10,21): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator ++(CL0 x)'.
                //         CL0? u1 = ++x1;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL0 CL0.operator ++(CL0 x)").WithLocation(10, 21),
                // (11,18): hidden CS8607: Expression is probably never null.
                //         CL0 v1 = u1 ?? new CL0();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                // (12,18): hidden CS8607: Expression is probably never null.
                //         CL0 w1 = x1 ?? new CL0();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(12, 18),
                // (16,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator ++(CL0 x)'.
                //         CL0 u2 = x2++;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("x", "CL0 CL0.operator ++(CL0 x)").WithLocation(16, 18),
                // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL0 u2 = x2++;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2++").WithLocation(16, 18),
                // (17,18): hidden CS8607: Expression is probably never null.
                //         CL0 v2 = x2 ?? new CL0();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(17, 18),
                // (21,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u3 = --x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x3").WithLocation(21, 18),
                // (22,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 v3 = x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(22, 18),
                // (26,19): warning CS8601: Possible null reference assignment.
                //         CL1? u4 = x4--; // Result of increment is nullable, storing it in not nullable parameter.
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x4--").WithLocation(26, 19),
                // (27,18): hidden CS8607: Expression is probably never null.
                //         CL1 v4 = u4 ?? new CL1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4").WithLocation(27, 18),
                // (32,18): warning CS8601: Possible null reference assignment.
                //         CL1 u5 = --x5;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "--x5").WithLocation(32, 18),
                // (32,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u5 = --x5;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x5").WithLocation(32, 18),
                // (37,9): warning CS8601: Possible null reference assignment.
                //         x6--;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x6--").WithLocation(37, 9),
                // (43,9): error CS0165: Use of unassigned local variable 'x7'
                //         x7--;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x7").WithArguments("x7").WithLocation(43, 9)
                );
        }

        [Fact]
        public void IncrementOperator_02()
        {
            CSharpCompilation c = CreateCompilation(
new[] { @"#pragma warning disable 8618
class C
{
    static void Main()
    {
    }

    void Test1()
    {
        CL0? u1 = ++x1;
        CL0 v1 = u1 ?? new CL0(); 
    }

    void Test2()
    {
        CL0 u2 = x2++;
    }

    void Test3()
    {
        CL1 u3 = --x3;
    }

    void Test4()
    {
        CL1? u4 = x4--; // Result of increment is nullable, storing it in not nullable property.
        CL1 v4 = u4 ?? new CL1(); 
    }

    void Test5(CL1 x5)
    {
        CL1 u5 = --x5;
    }

    CL0? x1 {get; set;}
    CL0? x2 {get; set;}
    CL1? x3 {get; set;}
    CL1 x4 {get; set;}
    CL1 x5 {get; set;}
}

class CL0
{
    public static CL0 operator ++(CL0 x)
    {
        return new CL0();
    }
}

class CL1
{
    public static CL1? operator --(CL1? x)
    {
        return new CL1();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,21): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator ++(CL0 x)'.
                //         CL0? u1 = ++x1;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL0 CL0.operator ++(CL0 x)").WithLocation(10, 21),
                // (11,18): hidden CS8607: Expression is probably never null.
                //         CL0 v1 = u1 ?? new CL0();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                // (16,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator ++(CL0 x)'.
                //         CL0 u2 = x2++;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("x", "CL0 CL0.operator ++(CL0 x)").WithLocation(16, 18),
                // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL0 u2 = x2++;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2++").WithLocation(16, 18),
                // (21,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u3 = --x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x3").WithLocation(21, 18),
                // (26,19): warning CS8601: Possible null reference assignment.
                //         CL1? u4 = x4--; // Result of increment is nullable, storing it in not nullable property.
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x4--").WithLocation(26, 19),
                // (27,18): hidden CS8607: Expression is probably never null.
                //         CL1 v4 = u4 ?? new CL1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4").WithLocation(27, 18),
                // (32,18): warning CS8601: Possible null reference assignment.
                //         CL1 u5 = --x5;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "--x5").WithLocation(32, 18),
                // (32,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u5 = --x5;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x5").WithLocation(32, 18)
                );
        }

        [Fact]
        public void IncrementOperator_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(X1 x1)
    {
        CL0? u1 = ++x1[0];
        CL0 v1 = u1 ?? new CL0(); 
    }

    void Test2(X1 x2)
    {
        CL0 u2 = x2[0]++;
    }

    void Test3(X3 x3)
    {
        CL1 u3 = --x3[0];
    }

    void Test4(X4 x4)
    {
        CL1? u4 = x4[0]--; // Result of increment is nullable, storing it in not nullable parameter.
        CL1 v4 = u4 ?? new CL1(); 
    }

    void Test5(X4 x5)
    {
        CL1 u5 = --x5[0];
    }
}

class CL0
{
    public static CL0 operator ++(CL0 x)
    {
        return new CL0();
    }
}

class CL1
{
    public static CL1? operator --(CL1? x)
    {
        return new CL1();
    }
}

class X1
{
    public CL0? this[int x]
    {
        get { return null; }
        set { }
    }
}

class X3
{
    public CL1? this[int x]
    {
        get { return null; }
        set { }
    }
}

class X4
{
    public CL1 this[int x]
    {
        get { return new CL1(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,21): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator ++(CL0 x)'.
                //         CL0? u1 = ++x1[0];
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1[0]").WithArguments("x", "CL0 CL0.operator ++(CL0 x)").WithLocation(10, 21),
                // (11,18): hidden CS8607: Expression is probably never null.
                //         CL0 v1 = u1 ?? new CL0();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                // (16,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL0 CL0.operator ++(CL0 x)'.
                //         CL0 u2 = x2[0]++;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2[0]").WithArguments("x", "CL0 CL0.operator ++(CL0 x)").WithLocation(16, 18),
                // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL0 u2 = x2[0]++;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2[0]++").WithLocation(16, 18),
                // (21,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u3 = --x3[0];
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x3[0]").WithLocation(21, 18),
                // (26,19): warning CS8601: Possible null reference assignment.
                //         CL1? u4 = x4[0]--; // Result of increment is nullable, storing it in not nullable parameter.
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x4[0]--").WithLocation(26, 19),
                // (27,18): hidden CS8607: Expression is probably never null.
                //         CL1 v4 = u4 ?? new CL1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4").WithLocation(27, 18),
                // (32,18): warning CS8601: Possible null reference assignment.
                //         CL1 u5 = --x5[0];
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "--x5[0]").WithLocation(32, 18),
                // (32,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u5 = --x5[0];
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x5[0]").WithLocation(32, 18)
                );
        }

        [Fact]
        public void IncrementOperator_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class C
{
    static void Main()
    {
    }

    void Test1(dynamic? x1)
    {
        dynamic? u1 = ++x1;
        dynamic v1 = u1 ?? new object(); 
    }

    void Test2(dynamic? x2)
    {
        dynamic u2 = x2++;
    }

    void Test3(dynamic? x3)
    {
        dynamic u3 = --x3;
    }

    void Test4(dynamic x4)
    {
        dynamic? u4 = x4--; 
        dynamic v4 = u4 ?? new object(); 
    }

    void Test5(dynamic x5)
    {
        dynamic u5 = --x5;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (16,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         dynamic u2 = x2++;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2++").WithLocation(16, 22),
                // (21,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         dynamic u3 = --x3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "--x3").WithLocation(21, 22),
                // (27,22): hidden CS8607: Expression is probably never null.
                //         dynamic v4 = u4 ?? new object();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4").WithLocation(27, 22)
                );
        }

        [Fact]
        public void IncrementOperator_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(B? x1)
    {
        B? u1 = ++x1;
        B v1 = u1 ?? new B(); 
    }
}

class A
{
    public static C? operator ++(A x)
    {
        return new C();
    }
}

class C : A
{
    public static implicit operator B(C x)
    {
        return new B();
    }
}

class B : A
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'C? A.operator ++(A x)'.
                 //         B? u1 = ++x1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "C? A.operator ++(A x)").WithLocation(10, 19),
                 // (10,17): warning CS8604: Possible null reference argument for parameter 'x' in 'C.implicit operator B(C x)'.
                 //         B? u1 = ++x1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "++x1").WithArguments("x", "C.implicit operator B(C x)").WithLocation(10, 17),
                 // (11,16): hidden CS8607: Expression is probably never null.
                 //         B v1 = u1 ?? new B();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 16)
                );
        }

        [Fact]
        public void IncrementOperator_06()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(B x1)
    {
        B u1 = ++x1;
    }
}

class A
{
    public static C operator ++(A x)
    {
        return new C();
    }
}

class C : A
{
    public static implicit operator B?(C x)
    {
        return new B();
    }
}

class B : A
{
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,16): warning CS8601: Possible null reference assignment.
                //         B u1 = ++x1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "++x1").WithLocation(10, 16),
                // (10,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         B u1 = ++x1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "++x1").WithLocation(10, 16)
                );
        }

        [Fact]
        public void IncrementOperator_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(Convertible? x1)
    {
        Convertible? u1 = ++x1;
        Convertible v1 = u1 ?? new Convertible(); 
    }

    void Test2(int? x2)
    {
        var u2 = ++x2;
    }

    void Test3(byte x3)
    {
        var u3 = ++x3;
    }
}

class Convertible
{
    public static implicit operator int(Convertible c)
    {
        return 0;
    }

    public static implicit operator Convertible(int i)
    {
        return new Convertible();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,29): warning CS8604: Possible null reference argument for parameter 'c' in 'Convertible.implicit operator int(Convertible c)'.
                 //         Convertible? u1 = ++x1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("c", "Convertible.implicit operator int(Convertible c)").WithLocation(10, 29),
                 // (11,26): hidden CS8607: Expression is probably never null.
                 //         Convertible v1 = u1 ?? new Convertible();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 26)
                );
        }

        [Fact]
        public void CompoundAssignment_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL1? x1, CL0 y1)
    {
        CL1? u1 = x1 += y1;
        CL1 v1 = u1 ?? new CL1(); 
        CL1 w1 = x1 ?? new CL1(); 
    }
}

class CL0
{
    public static CL1 operator +(CL0 x, CL0 y)
    {
        return new CL1();
    }
}

class CL1
{
    public static implicit operator CL0(CL1 x)
    {
        return new CL0();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1.implicit operator CL0(CL1 x)'.
                 //         CL1? u1 = x1 += y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL1.implicit operator CL0(CL1 x)").WithLocation(10, 19),
                 // (11,18): hidden CS8607: Expression is probably never null.
                 //         CL1 v1 = u1 ?? new CL1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                 // (12,18): hidden CS8607: Expression is probably never null.
                 //         CL1 w1 = x1 ?? new CL1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(12, 18)
                );
        }

        [Fact]
        public void CompoundAssignment_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL1? x1, CL0? y1)
    {
        CL1? u1 = x1 += y1;
        CL1 v1 = u1 ?? new CL1(); 
        CL1 w1 = x1 ?? new CL1(); 
    }
}

class CL0
{
    public static CL1 operator +(CL0 x, CL0 y)
    {
        return new CL1();
    }
}

class CL1
{
    public static implicit operator CL0(CL1? x)
    {
        return new CL0();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,25): warning CS8604: Possible null reference argument for parameter 'y' in 'CL1 CL0.operator +(CL0 x, CL0 y)'.
                 //         CL1? u1 = x1 += y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y1").WithArguments("y", "CL1 CL0.operator +(CL0 x, CL0 y)").WithLocation(10, 25),
                 // (11,18): hidden CS8607: Expression is probably never null.
                 //         CL1 v1 = u1 ?? new CL1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                 // (12,18): hidden CS8607: Expression is probably never null.
                 //         CL1 w1 = x1 ?? new CL1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(12, 18)
                );
        }

        [Fact]
        public void CompoundAssignment_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL1? x1, CL0? y1)
    {
        CL1? u1 = x1 += y1;
        CL1 v1 = u1 ?? new CL1(); 
        CL1 w1 = x1 ?? new CL1(); 
    }

    void Test2(CL0? x2, CL0 y2)
    {
        CL0 u2 = x2 += y2;
        CL0 w2 = x2; 
    }

    void Test3(CL0? x3, CL0 y3)
    {
        x3 = new CL0();
        CL0 u3 = x3 += y3;
        CL0 w3 = x3; 
    }

    void Test4(CL0? x4, CL0 y4)
    {
        x4 = new CL0();
        x4 += y4;
        CL0 w4 = x4; 
    }
}

class CL0
{
    public static CL1 operator +(CL0 x, CL0? y)
    {
        return new CL1();
    }
}

class CL1
{
    public static implicit operator CL0?(CL1? x)
    {
        return new CL0();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1 CL0.operator +(CL0 x, CL0? y)'.
                 //         CL1? u1 = x1 += y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL1 CL0.operator +(CL0 x, CL0? y)").WithLocation(10, 19),
                 // (11,18): hidden CS8607: Expression is probably never null.
                 //         CL1 v1 = u1 ?? new CL1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                 // (12,18): hidden CS8607: Expression is probably never null.
                 //         CL1 w1 = x1 ?? new CL1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(12, 18),
                 // (17,18): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1 CL0.operator +(CL0 x, CL0? y)'.
                 //         CL0 u2 = x2 += y2;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("x", "CL1 CL0.operator +(CL0 x, CL0? y)").WithLocation(17, 18),
                 // (17,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL0 u2 = x2 += y2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2 += y2").WithLocation(17, 18),
                 // (18,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL0 w2 = x2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(18, 18),
                 // (24,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL0 u3 = x3 += y3;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3 += y3").WithLocation(24, 18),
                 // (25,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL0 w3 = x3;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3").WithLocation(25, 18),
                 // (32,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL0 w4 = x4;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x4").WithLocation(32, 18)
                );
        }

        [Fact]
        public void CompoundAssignment_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL1? x1, CL0? y1)
    {
        x1 = new CL1();
        CL1? u1 = x1 += y1;
        CL1 w1 = x1;
        w1 = u1; 
    }

    void Test2(CL1 x2, CL0 y2)
    {
        CL1 u2 = x2 += y2;
        CL1 w2 = x2; 
    }

    void Test3(CL1 x3, CL0 y3)
    {
        x3 += y3;
    }

    void Test4(CL0? x4, CL0 y4)
    {
        CL0? u4 = x4 += y4;
        CL0 v4 = u4 ?? new CL0(); 
        CL0 w4 = x4 ?? new CL0(); 
    }

    void Test5(CL0 x5, CL0 y5)
    {
        x5 += y5;
    }

    void Test6(CL0 y6)
    {
        CL1 x6;
        x6 += y6;
    }
}

class CL0
{
    public static CL1? operator +(CL0 x, CL0? y)
    {
        return new CL1();
    }
}

class CL1
{
    public static implicit operator CL0(CL1 x)
    {
        return new CL0();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 w1 = x1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(12, 18),
                // (13,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         w1 = u1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u1").WithLocation(13, 14),
                // (18,18): warning CS8601: Possible null reference assignment.
                //         CL1 u2 = x2 += y2;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x2 += y2").WithLocation(18, 18),
                // (18,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 u2 = x2 += y2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2 += y2").WithLocation(18, 18),
                // (19,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         CL1 w2 = x2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(19, 18),
                // (24,9): warning CS8601: Possible null reference assignment.
                //         x3 += y3;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x3 += y3").WithLocation(24, 9),
                // (29,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1? CL0.operator +(CL0 x, CL0? y)'.
                //         CL0? u4 = x4 += y4;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x4").WithArguments("x", "CL1? CL0.operator +(CL0 x, CL0? y)").WithLocation(29, 19),
                // (29,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1.implicit operator CL0(CL1 x)'.
                //         CL0? u4 = x4 += y4;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x4 += y4").WithArguments("x", "CL1.implicit operator CL0(CL1 x)").WithLocation(29, 19),
                // (30,18): hidden CS8607: Expression is probably never null.
                //         CL0 v4 = u4 ?? new CL0();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u4").WithLocation(30, 18),
                // (31,18): hidden CS8607: Expression is probably never null.
                //         CL0 w4 = x4 ?? new CL0();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x4").WithLocation(31, 18),
                // (36,9): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1.implicit operator CL0(CL1 x)'.
                //         x5 += y5;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x5 += y5").WithArguments("x", "CL1.implicit operator CL0(CL1 x)").WithLocation(36, 9),
                // (42,9): error CS0165: Use of unassigned local variable 'x6'
                //         x6 += y6;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "x6").WithArguments("x6").WithLocation(42, 9),
                // (42,9): warning CS8601: Possible null reference assignment.
                //         x6 += y6;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x6 += y6").WithLocation(42, 9));
        }

        [Fact]
        public void CompoundAssignment_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(int x1, int y1)
    {
        var u1 = x1 += y1;
    }

    void Test2(int? x2, int y2)
    {
        var u2 = x2 += y2;
    }

    void Test3(dynamic? x3, dynamic? y3)
    {
        dynamic? u3 = x3 += y3;
        dynamic v3 = u3;
        dynamic w3 = u3 ?? v3;
    }

    void Test4(dynamic? x4, dynamic? y4)
    {
        dynamic u4 = x4 += y4;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                );
        }

        [Fact]
        public void CompoundAssignment_06()
        {
            CSharpCompilation c = CreateCompilation(
new[] { @"#pragma warning disable 8618
class Test
{
    static void Main()
    {
    }

    void Test1(CL0 y1)
    {
        CL1? u1 = x1 += y1;
        CL1 v1 = u1 ?? new CL1(); 
        CL1 w1 = x1 ?? new CL1(); 
    }

    void Test2(CL0 y2)
    {
        CL1? u2 = x2 += y2;
        CL1 v2 = u2 ?? new CL1(); 
        CL1 w2 = x2 ?? new CL1(); 
    }

    CL1? x1 {get; set;}
    CL1 x2 {get; set;}
}

class CL0
{
    public static CL1 operator +(CL0 x, CL0 y)
    {
        return new CL1();
    }
}

class CL1
{
    public static implicit operator CL0(CL1 x)
    {
        return new CL0();
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1.implicit operator CL0(CL1 x)'.
                //         CL1? u1 = x1 += y1;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1").WithArguments("x", "CL1.implicit operator CL0(CL1 x)").WithLocation(10, 19),
                // (11,18): hidden CS8607: Expression is probably never null.
                //         CL1 v1 = u1 ?? new CL1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                // (12,18): hidden CS8607: Expression is probably never null.
                //         CL1 w1 = x1 ?? new CL1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(12, 18),
                // (18,18): hidden CS8607: Expression is probably never null.
                //         CL1 v2 = u2 ?? new CL1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u2").WithLocation(18, 18),
                // (19,18): hidden CS8607: Expression is probably never null.
                //         CL1 w2 = x2 ?? new CL1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(19, 18)
                );
        }

        [Fact]
        public void CompoundAssignment_07()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL2 x1, CL0 y1)
    {
        CL1? u1 = x1[0] += y1;
        CL1 v1 = u1 ?? new CL1(); 
        CL1 w1 = x1[0] ?? new CL1(); 
    }

    void Test2(CL3 x2, CL0 y2)
    {
        CL1? u2 = x2[0] += y2;
        CL1 v2 = u2 ?? new CL1(); 
        CL1 w2 = x2[0] ?? new CL1(); 
    }
}

class CL0
{
    public static CL1 operator +(CL0 x, CL0 y)
    {
        return new CL1();
    }
}

class CL1
{
    public static implicit operator CL0(CL1 x)
    {
        return new CL0();
    }
}

class CL2
{
    public CL1? this[int x]
    {
        get { return new CL1(); }
        set { }
    }
}

class CL3
{
    public CL1 this[int x]
    {
        get { return new CL1(); }
        set { }
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,19): warning CS8604: Possible null reference argument for parameter 'x' in 'CL1.implicit operator CL0(CL1 x)'.
                 //         CL1? u1 = x1[0] += y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x1[0]").WithArguments("x", "CL1.implicit operator CL0(CL1 x)").WithLocation(10, 19),
                 // (11,18): hidden CS8607: Expression is probably never null.
                 //         CL1 v1 = u1 ?? new CL1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u1").WithLocation(11, 18),
                 // (18,18): hidden CS8607: Expression is probably never null.
                 //         CL1 v2 = u2 ?? new CL1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "u2").WithLocation(18, 18),
                 // (19,18): hidden CS8607: Expression is probably never null.
                 //         CL1 w2 = x2[0] ?? new CL1();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2[0]").WithLocation(19, 18)
                );
        }

        [Fact]
        public void IdentityConversion_CompoundAssignment()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    public static I<object> operator+(I<object> x, C y) => x;
    public static IIn<object> operator+(IIn<object> x, C y) => x;
    public static IOut<object> operator+(IOut<object> x, C y) => x;
    static void F(C c, I<object> x, I<object?> y)
    {
        x += c;
        y += c;
    }
    static void F(C c, IIn<object> x, IIn<object?> y)
    {
        x += c;
        y += c;
    }
    static void F(C c, IOut<object> x, IOut<object?> y)
    {
        x += c;
        y += c;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         y += c;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("I<object?>", "I<object>").WithLocation(12, 9),
                // (12,9): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         y += c;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y += c").WithArguments("I<object>", "I<object?>").WithLocation(12, 9),
                // (17,9): warning CS8619: Nullability of reference types in value of type 'IIn<object>' doesn't match target type 'IIn<object?>'.
                //         y += c;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y += c").WithArguments("IIn<object>", "IIn<object?>").WithLocation(17, 9),
                // (22,9): warning CS8619: Nullability of reference types in value of type 'IOut<object?>' doesn't match target type 'IOut<object>'.
                //         y += c;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("IOut<object?>", "IOut<object>").WithLocation(22, 9)
                );
        }

        [Fact]
        public void Events_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    event System.Action? E1;

    void Test1()
    {
        E1();
    }

    delegate void D2 (object x);
    event D2 E2;

    void Test2()
    {
        E2(null);
    }

    delegate object? D3 ();
    event D3 E3;

    void Test3()
    {
        object x3 = E3();
    }

    void Test4()
    {
                    //E1?();
        System.Action? x4 = E1;
                    //x4?();
    }

    void Test5()
    {
        System.Action x5 = E1;
    }

    void Test6(D2? x6)
    {
        E2 = x6;
    }

    void Test7(D2? x7)
    {
        E2 += x7;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         E1();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "E1").WithLocation(12, 9),
                // (20,12): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         E2(null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(20, 12),
                // (28,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object x3 = E3();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E3()").WithLocation(28, 21),
                // (40,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         System.Action x5 = E1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E1").WithLocation(40, 28),
                // (45,14): warning CS8601: Possible null reference assignment.
                //         E2 = x6;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x6").WithLocation(45, 14)
                );
        }

        // https://github.com/dotnet/roslyn/issues/29901: Events are not tracked for structs.
        // (This should be fixed if/when struct member state is populated lazily.)
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29901")]
        [WorkItem(29901, "https://github.com/dotnet/roslyn/issues/29901")]
        public void Events_02()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }
}

struct TS1
{
    event System.Action? E1;

    TS1(System.Action x1) 
    {
        E1 = x1;
        System.Action y1 = E1 ?? x1;

        E1 = x1;
        TS1 z1 = this;
        y1 = z1.E1 ?? x1;
    }

    void Test3(System.Action x3)
    {
        TS1 s3;
        s3.E1 = x3;
        System.Action y3 = s3.E1 ?? x3;

        s3.E1 = x3;
        TS1 z3 = s3;
        y3 = z3.E1 ?? x3;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (16,28): hidden CS8607: Expression is probably never null.
                 //         System.Action y1 = E1 ?? x1;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(16, 28),
                 // (20,14): hidden CS8607: Expression is probably never null.
                 //         y1 = z1.E1 ?? x1;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z1.E1").WithLocation(20, 14),
                 // (27,28): hidden CS8607: Expression is probably never null.
                 //         System.Action y3 = s3.E1 ?? x3;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "s3.E1").WithLocation(27, 28),
                 // (31,14): hidden CS8607: Expression is probably never null.
                 //         y3 = z3.E1 ?? x3;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z3.E1").WithLocation(31, 14)
                );
        }

        // https://github.com/dotnet/roslyn/issues/29901: Events are not tracked for structs.
        // (This should be fixed if/when struct member state is populated lazily.)
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29901")]
        [WorkItem(29901, "https://github.com/dotnet/roslyn/issues/29901")]
        public void Events_03()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }
}

struct TS2
{
    event System.Action? E2;

    TS2(System.Action x2) 
    {
        this = new TS2();
        System.Action z2 = E2;
        System.Action y2 = E2 ?? x2;
    }
}

" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (16,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         System.Action z2 = E2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(16, 28)
                );
        }

        [Fact]
        public void Events_04()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL0? x1, System.Action? y1)
    {
        System.Action v1 = x1.E1 += y1;
    }

    void Test2(CL0? x2, System.Action? y2)
    {
        System.Action v2 = x2.E1 -= y2;
    }
}

class CL0
{
    public event System.Action? E1;

    void Dummy()
    {
        var x = E1;
    }
}

" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,28): error CS0029: Cannot implicitly convert type 'void' to 'System.Action'
                 //         System.Action v1 = x1.E1 += y1;
                 Diagnostic(ErrorCode.ERR_NoImplicitConv, "x1.E1 += y1").WithArguments("void", "System.Action").WithLocation(10, 28),
                 // (10,28): warning CS8602: Possible dereference of a null reference.
                 //         System.Action v1 = x1.E1 += y1;
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(10, 28),
                 // (15,28): error CS0029: Cannot implicitly convert type 'void' to 'System.Action'
                 //         System.Action v2 = x2.E1 -= y2;
                 Diagnostic(ErrorCode.ERR_NoImplicitConv, "x2.E1 -= y2").WithArguments("void", "System.Action").WithLocation(15, 28),
                 // (15,28): warning CS8602: Possible dereference of a null reference.
                 //         System.Action v2 = x2.E1 -= y2;
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(15, 28)
                );
        }

        [Fact]
        public void Events_05()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    public event System.Action E1;

    void Test1(Test? x1)
    {
        System.Action v1 = x1.E1;
    }
}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (12,28): warning CS8602: Possible dereference of a null reference.
                 //         System.Action v1 = x1.E1;
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(12, 28)
                );
        }

        [WorkItem(31018, "https://github.com/dotnet/roslyn/issues/31018")]
        [Fact]
        public void EventAssignment()
        {
            var source =
@"#pragma warning disable 0067
using System;
class A<T> { }
class B
{
    event Action<A<object?>> E;
    static void M1()
    {
        var b1 = new B();
        b1.E += F1; // 1
        b1.E += F2; // 2
        b1.E += F3;
        b1.E += F4;
    }
    static void M2(Action<A<object>> f1, Action<A<object>?> f2, Action<A<object?>> f3, Action<A<object?>?> f4)
    {
        var b2 = new B();
        b2.E += f1; // 3
        b2.E += f2; // 4
        b2.E += f3;
        b2.E += f4;
    }
    static void M3()
    {
        var b3 = new B();
        b3.E += (A<object> a) => { }; // 5
        b3.E += (A<object>? a) => { }; // 6
        b3.E += (A<object?> a) => { };
        b3.E += (A<object?>? a) => { }; // 7
    }
    static void F1(A<object> a) { }
    static void F2(A<object>? a) { }
    static void F3(A<object?> a) { }
    static void F4(A<object?>? a) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/31018: Report warnings for // 3 and // 4.
            comp.VerifyDiagnostics(
                // (10,17): warning CS8622: Nullability of reference types in type of parameter 'a' of 'void B.F1(A<object> a)' doesn't match the target delegate 'Action<A<object?>>'.
                //         b1.E += F1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F1").WithArguments("a", "void B.F1(A<object> a)", "System.Action<A<object?>>").WithLocation(10, 17),
                // (11,17): warning CS8622: Nullability of reference types in type of parameter 'a' of 'void B.F2(A<object>? a)' doesn't match the target delegate 'Action<A<object?>>'.
                //         b1.E += F2; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F2").WithArguments("a", "void B.F2(A<object>? a)", "System.Action<A<object?>>").WithLocation(11, 17),
                // (26,17): warning CS8622: Nullability of reference types in type of parameter 'a' of 'lambda expression' doesn't match the target delegate 'Action<A<object?>>'.
                //         b3.E += (A<object> a) => { }; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(A<object> a) => { }").WithArguments("a", "lambda expression", "System.Action<A<object?>>").WithLocation(26, 17),
                // (27,17): warning CS8622: Nullability of reference types in type of parameter 'a' of 'lambda expression' doesn't match the target delegate 'Action<A<object?>>'.
                //         b3.E += (A<object>? a) => { }; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(A<object>? a) => { }").WithArguments("a", "lambda expression", "System.Action<A<object?>>").WithLocation(27, 17),
                // (29,17): warning CS8622: Nullability of reference types in type of parameter 'a' of 'lambda expression' doesn't match the target delegate 'Action<A<object?>>'.
                //         b3.E += (A<object?>? a) => { }; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "(A<object?>? a) => { }").WithArguments("a", "lambda expression", "System.Action<A<object?>>").WithLocation(29, 17));
        }

        [Fact]
        public void AsOperator_01()
        {
            CSharpCompilation c = CreateCompilation(new[] { @"
class Test
{
    static void Main()
    {
    }

    void Test1(CL1 x1)
    {
        object y1 = x1 as object ?? new object();
    }

    void Test2(int x2)
    {
        object y2 = x2 as object ?? new object();
    }

    void Test3(CL1? x3)
    {
        object y3 = x3 as object;
    }

    void Test4(int? x4)
    {
        object y4 = x4 as object;
    }

    void Test5(object x5)
    {
        CL1 y5 = x5 as CL1;
    }

    void Test6()
    {
        CL1 y6 = null as CL1;
    }

    void Test7<T>(T x7)
    {
        CL1 y7 = x7 as CL1;
    }
}

class CL1 {}
" }, options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                 // (10,21): hidden CS8607: Expression is probably never null.
                 //         object y1 = x1 as object ?? new object();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1 as object").WithLocation(10, 21),
                 // (15,21): hidden CS8607: Expression is probably never null.
                 //         object y2 = x2 as object ?? new object();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2 as object").WithLocation(15, 21),
                 // (20,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         object y3 = x3 as object;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x3 as object").WithLocation(20, 21),
                 // (25,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         object y4 = x4 as object;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x4 as object").WithLocation(25, 21),
                 // (30,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL1 y5 = x5 as CL1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x5 as CL1").WithLocation(30, 18),
                 // (35,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL1 y6 = null as CL1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null as CL1").WithLocation(35, 18),
                 // (40,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         CL1 y7 = x7 as CL1;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x7 as CL1").WithLocation(40, 18)
                );
        }

        [Fact]
        public void ReturningValues_IEnumerableT()
        {
            var source = @"
public class C
{
    System.Collections.Generic.IEnumerable<string> M()
    {
        return null; // 1
    }
    public System.Collections.Generic.IEnumerable<string>? M2()
    {
        return null;
    }
    System.Collections.Generic.IEnumerable<string> M3() => null; // 2
    System.Collections.Generic.IEnumerable<string>? M4() => null;
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,16): warning CS8603: Possible null reference return.
                //         return null; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(6, 16),
                // (12,60): warning CS8603: Possible null reference return.
                //     System.Collections.Generic.IEnumerable<string> M3() => null; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(12, 60)
                );

            var source2 = @"
class D
{
    void M(C c)
    {
        c.M2() /*T:System.Collections.Generic.IEnumerable<string!>?*/ ;
    }
}
";
            var comp2 = CreateCompilation(source2, references: new[] { comp.EmitToImageReference() });
            comp2.VerifyTypes();
        }

        [Fact]
        public void Yield_IEnumerableT()
        {
            var source = @"
public class C
{
    public System.Collections.Generic.IEnumerable<string> M()
    {
        yield return null; // 1
        yield return """";
        yield return null; // 2
        yield break;
    }
    public System.Collections.Generic.IEnumerable<string?> M2()
    {
        yield return null;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,22): warning CS8603: Possible null reference return.
                //         yield return null; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(6, 22),
                // (8,22): warning CS8603: Possible null reference return.
                //         yield return null; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(8, 22)
                );

            var source2 = @"
class D
{
    void M(C c)
    {
        c.M() /*T:System.Collections.Generic.IEnumerable<string!>!*/ ;
        c.M2() /*T:System.Collections.Generic.IEnumerable<string?>!*/ ;
    }
}
";
            var comp2 = CreateCompilation(source2, references: new[] { comp.EmitToImageReference() });
            comp2.VerifyTypes();
        }

        [Fact]
        public void Yield_IEnumerableT_LocalFunction()
        {
            var source = @"
class C
{
    void Method()
    {
        _ = M();
        _ = M2();

        System.Collections.Generic.IEnumerable<string> M()
        {
            yield return null; // 1
            yield return """";
            yield return null; // 2
            yield break;
        }
        System.Collections.Generic.IEnumerable<string?> M2()
        {
            yield return null;
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,26): warning CS8603: Possible null reference return.
                //             yield return null; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(11, 26),
                // (13,26): warning CS8603: Possible null reference return.
                //             yield return null; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(13, 26)
                );
        }

        [Fact]
        public void Yield_IEnumerableT_GenericT()
        {
            var source = @"
class C
{
    System.Collections.Generic.IEnumerable<T> M<T>()
    {
        yield return default; // 1
    }
    System.Collections.Generic.IEnumerable<T> M1<T>() where T : class
    {
        yield return default; // 2
    }
    System.Collections.Generic.IEnumerable<T> M2<T>() where T : class?
    {
        yield return default; // 3
    }
    System.Collections.Generic.IEnumerable<T?> M3<T>() where T : class
    {
        yield return default;
    }
}";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,22): warning CS8603: Possible null reference return.
                //         yield return default; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(6, 22),
                // (10,22): warning CS8603: Possible null reference return.
                //         yield return default; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(10, 22),
                // (14,22): warning CS8603: Possible null reference return.
                //         yield return default; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(14, 22)
                );
        }

        [Fact]
        public void Yield_IEnumerableT_ErrorValue()
        {
            var source = @"
class C
{
    System.Collections.Generic.IEnumerable<string> M()
    {
        yield return bad;
    }
}";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,22): error CS0103: The name 'bad' does not exist in the current context
                //         yield return bad;
                Diagnostic(ErrorCode.ERR_NameNotInContext, "bad").WithArguments("bad").WithLocation(6, 22)
                );
        }

        [Fact]
        public void Yield_IEnumerableT_ErrorValue2()
        {
            var source = @"
static class C
{
    static System.Collections.Generic.IEnumerable<object> M(object? x)
    {
        yield return (C)x;
    }
    static System.Collections.Generic.IEnumerable<object?> M(object? y)
    {
        yield return (C?)y;
    }
}";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,22): error CS0716: Cannot convert to static type 'C'
                //         yield return (C)x;
                Diagnostic(ErrorCode.ERR_ConvertToStaticClass, "(C)x").WithArguments("C").WithLocation(6, 22),
                // (6,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         yield return (C)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)x").WithLocation(6, 22),
                // (6,22): warning CS8603: Possible null reference return.
                //         yield return (C)x;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(C)x").WithLocation(6, 22),
                // (8,60): error CS0111: Type 'C' already defines a member called 'M' with the same parameter types
                //     static System.Collections.Generic.IEnumerable<object?> M(object? y)
                Diagnostic(ErrorCode.ERR_MemberAlreadyExists, "M").WithArguments("M", "C").WithLocation(8, 60),
                // (10,22): error CS0716: Cannot convert to static type 'C'
                //         yield return (C?)y;
                Diagnostic(ErrorCode.ERR_ConvertToStaticClass, "(C?)y").WithArguments("C").WithLocation(10, 22)
                );
        }

        [Fact]
        public void Yield_IEnumerableT_NoValue()
        {
            var source = @"
class C
{
    System.Collections.Generic.IEnumerable<string> M()
    {
        yield return;
    }
}";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,15): error CS1627: Expression expected after yield return
                //         yield return;
                Diagnostic(ErrorCode.ERR_EmptyYield, "return").WithLocation(6, 15)
                );
        }

        [Fact]
        public void Yield_IEnumeratorT()
        {
            var source = @"
class C
{
    System.Collections.Generic.IEnumerator<string> M()
    {
        yield return null; // 1
        yield return """";
    }
    System.Collections.Generic.IEnumerator<string?> M2()
    {
        yield return null;
    }
}";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,22): warning CS8603: Possible null reference return.
                //         yield return null; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(6, 22)
                );
        }

        [Fact]
        public void Yield_IEnumeratorT_LocalFunction()
        {
            var source = @"
class C
{
    void Method()
    {
        _ = M();
        _ = M2();

        System.Collections.Generic.IEnumerator<string> M()
        {
            yield return null; // 1
            yield return """";
        }
        System.Collections.Generic.IEnumerator<string?> M2()
        {
            yield return null;
        }
    }
}";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (11,26): warning CS8603: Possible null reference return.
                //             yield return null; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(11, 26)
                );
        }

        [Fact]
        public void Yield_IEnumerable()
        {
            var source = @"
class C
{
    System.Collections.IEnumerable M()
    {
        yield return null;
    }
}";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void Yield_IEnumerator()
        {
            var source = @"
class C
{
    System.Collections.IEnumerator M()
    {
        yield return null;
        yield return null;
    }
}";
            CreateCompilation(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact, CompilerTrait(CompilerFeature.AsyncStreams)]
        public void Yield_IAsyncEnumerable()
        {
            var source = @"
using System.Collections.Generic;
using System.Threading.Tasks;
class C
{
    public static async IAsyncEnumerable<string> M()
    {
        yield return null; // 1
        yield return null; // 2
        await Task.Delay(1);
        yield break;
    }
    public static async IAsyncEnumerable<string?> M2()
    {
        yield return null;
        yield return null;
        await Task.Delay(1);
    }
    void Method()
    {
        _ = local();
        _ = local2();

        async IAsyncEnumerable<string> local()
        {
            yield return null; // 3
            await Task.Delay(1);
            yield break;
        }
        async IAsyncEnumerable<string?> local2()
        {
            yield return null;
            await Task.Delay(1);
        }
    }
}";
            CreateCompilationWithTasksExtensions(new[] { source, AsyncStreamsTypes }, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,22): warning CS8603: Possible null reference return.
                //         yield return null; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(8, 22),
                // (9,22): warning CS8603: Possible null reference return.
                //         yield return null; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(9, 22),
                // (26,26): warning CS8603: Possible null reference return.
                //             yield return null; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(26, 26)
                );
        }

        [Fact, CompilerTrait(CompilerFeature.AsyncStreams)]
        public void Yield_IAsyncEnumerator()
        {
            var source = @"
using System.Collections.Generic;
using System.Threading.Tasks;
class C
{
    async IAsyncEnumerator<string> M()
    {
        yield return null; // 1
        yield return null; // 2
        await Task.Delay(1);
        yield break;
    }
    async IAsyncEnumerator<string?> M2()
    {
        yield return null;
        yield return null;
        await Task.Delay(1);
    }
    void Method()
    {
        _ = local();
        _ = local2();

        async IAsyncEnumerator<string> local()
        {
            yield return null; // 3
            await Task.Delay(1);
        }
        async IAsyncEnumerator<string?> local2()
        {
            yield return null;
            await Task.Delay(1);
            yield break;
        }
    }
}";
            var comp = CreateCompilationWithTasksExtensions(new[] { source, AsyncStreamsTypes }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,22): warning CS8603: Possible null reference return.
                //         yield return null; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(8, 22),
                // (9,22): warning CS8603: Possible null reference return.
                //         yield return null; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(9, 22),
                // (26,26): warning CS8603: Possible null reference return.
                //             yield return null; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(26, 26)
                );
        }

        [Fact]
        public void Await_01()
        {
            var source = @"
using System;

static class Program
{
    static void Main() { }

    static async void f()
    {
        object x = await new D() ?? new object();
    }
}

class D
{
    public Awaiter GetAwaiter() { return new Awaiter(); }
}

class Awaiter : System.Runtime.CompilerServices.INotifyCompletion
{
    public void OnCompleted(Action x) { }

    public object GetResult() { throw new Exception(); }

    public bool IsCompleted { get { return true; } }
}";
            CreateCompilationWithMscorlib45(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                 // (10,20): hidden CS8607: Expression is probably never null.
                 //         object x = await new D() ?? new object();
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "await new D()").WithLocation(10, 20)
                );
        }

        [Fact]
        public void Await_02()
        {
            var source = @"
using System;

static class Program
{
    static void Main() { }

    static async void f()
    {
        object x = await new D();
    }
}

class D
{
    public Awaiter GetAwaiter() { return new Awaiter(); }
}

class Awaiter : System.Runtime.CompilerServices.INotifyCompletion
{
    public void OnCompleted(Action x) { }

    public object? GetResult() { throw new Exception(); }

    public bool IsCompleted { get { return true; } }
}";
            CreateCompilationWithMscorlib45(new[] { source }, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                 // (10,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         object x = await new D();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "await new D()").WithLocation(10, 20)
                );
        }

        [Fact]
        public void Await_ProduceResultTypeFromTask()
        {
            var source = @"
class C
{
    async void M()
    {
        var x = await Async();
        x.ToString();
    }
    System.Threading.Tasks.Task<string?> Async() => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void Await_CheckNullReceiver()
        {
            var source = @"
class C
{
    async void M()
    {
        await Async();
    }
    System.Threading.Tasks.Task<string>? Async() => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,15): warning CS8602: Possible dereference of a null reference.
                //         await Async();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "Async()").WithLocation(6, 15)
                );
        }

        [Fact]
        public void Await_ExtensionGetAwaiter()
        {
            var source = @"
public class Awaitable
{
    async void M()
    {
        await Async();
    }
    Awaitable? Async() => throw null;
}
public static class Extensions
{
    public static System.Runtime.CompilerServices.TaskAwaiter GetAwaiter(this Awaitable? x) => throw null;
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,15): warning CS8602: Possible dereference of a null reference.
                //         await Async();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "Async()").WithLocation(6, 15)
                );
        }

        [Fact]
        public void Await_UpdateExpression()
        {
            var source = @"
class C
{
    async void M(System.Threading.Tasks.Task<string>? task)
    {
        await task; // warn
        await task;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,15): warning CS8602: Possible dereference of a null reference.
                //         await task; // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "task").WithLocation(6, 15)
                );
        }

        [Fact]
        public void Await_LearnFromNullTest()
        {
            var source = @"
class C
{
    System.Threading.Tasks.Task<string>? M() => throw null;
    async System.Threading.Tasks.Task M2(C? c)
    {
        await c?.M(); // warn
        c.ToString(); // no cascade
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,15): warning CS8602: Possible dereference of a null reference.
                //         await c?.M(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c?.M()").WithLocation(7, 15)
                );
        }

        [Fact]
        public void ArrayAccess_LearnFromNullTest()
        {
            var source = @"
class C
{
    string[] field = null!;
    void M2(C? c)
    {
        _ = (c?.field)[0]; // warn
        c.ToString(); // no cascade
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,14): warning CS8602: Possible dereference of a null reference.
                //         _ = (c?.field)[0]; // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c?.field").WithLocation(7, 14)
                );
        }

        [Fact]
        public void Call_LearnFromNullTest()
        {
            var source = @"
class C
{
    string M() => throw null;
    C field = null!;
    void M2(C? c)
    {
        _ = (c?.field).M(); // warn
        c.ToString(); // no cascade
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,14): warning CS8602: Possible dereference of a null reference.
                //         _ = (c?.field).M(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c?.field").WithLocation(8, 14)
                );
        }

        [Fact]
        public void Indexer_LearnFromNullTest()
        {
            var source = @"
class C
{
    string this[int i] => throw null;
    C field = null!;
    void M(C? c)
    {
        _ = (c?.field)[0]; // warn
        c.ToString(); // no cascade
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,14): warning CS8602: Possible dereference of a null reference.
                //         _ = (c?.field)[0]; // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c?.field").WithLocation(8, 14)
                );
        }

        [Fact]
        public void MemberAccess_LearnFromNullTest()
        {
            var source = @"
class C
{
    string this[int i] => throw null;
    C field = null!;
    void M(C? c)
    {
        _ = (c?.field).field; // warn
        c.ToString(); // no cascade
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,14): warning CS8602: Possible dereference of a null reference.
                //         _ = (c?.field).field; // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c?.field").WithLocation(8, 14)
                );
        }

        [Fact]
        public void NoPiaObjectCreation_01()
        {
            string pia = @"
using System;
using System.Runtime.InteropServices;

[assembly: ImportedFromTypeLib(""GeneralPIA.dll"")]
[assembly: Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58257"")]

[ComImport()]
[Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58277"")]
[CoClass(typeof(ClassITest28))]
public interface ITest28
{
}

[Guid(""f9c2d51d-4f44-45f0-9eda-c9d599b58278"")]
public abstract class ClassITest28 //: ITest28
{
    public ClassITest28(int x){}
}
";

            var piaCompilation = CreateCompilationWithMscorlib45(pia, options: TestOptions.DebugDll, parseOptions: TestOptions.Regular7);

            CompileAndVerify(piaCompilation);

            string source = @"
class UsePia
{
    public static void Main()
    {
    }

    void Test1(ITest28 x1)
    {
        x1 = new ITest28();
    }

    void Test2(ITest28 x2)
    {
        x2 = new ITest28() ?? x2;
    }
}";

            var compilation = CreateCompilationWithMscorlib45(new[] { source },
                                                new MetadataReference[] { new CSharpCompilationReference(piaCompilation, embedInteropTypes: true) },
                                                options: WithNonNullTypesTrue(TestOptions.DebugExe));

            compilation.VerifyDiagnostics(
                 // (15,14): hidden CS8607: Expression is probably never null.
                 //         x2 = new ITest28() ?? x2;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "new ITest28()").WithLocation(15, 14)
                );
        }

        [Fact]
        public void SymbolDisplay_01()
        {
            var source = @"
abstract class B
{
    string? F1; 
    event System.Action? E1;
    string? P1 {get; set;}
    string?[][,] P2 {get; set;}
    System.Action<string?> M1(string? x) {return null;}
    string[]?[,] M2(string[][,]? x) {return null;}
    void M3(string?* x) {}
    public abstract string? this[System.Action? x] {get; set;} 

    public static implicit operator B?(int x) { return null; }
}

delegate string? D1();

interface I1<T>{}
interface I2<T>{}

class C<T> {}

class F : C<F?>, I1<C<B?>>, I2<C<B>?>
{}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var b = compilation.GetTypeByMetadataName("B");
            Assert.Equal("System.String? B.F1", b.GetMember("F1").ToTestDisplayString());
            Assert.Equal("event System.Action? B.E1", b.GetMember("E1").ToTestDisplayString());
            Assert.Equal("System.String? B.P1 { get; set; }", b.GetMember("P1").ToTestDisplayString());
            Assert.Equal("System.String?[][,] B.P2 { get; set; }", b.GetMember("P2").ToTestDisplayString());
            Assert.Equal("System.Action<System.String?> B.M1(System.String? x)", b.GetMember("M1").ToTestDisplayString());
            Assert.Equal("System.String[]?[,] B.M2(System.String[][,]? x)", b.GetMember("M2").ToTestDisplayString());
            Assert.Equal("void B.M3(System.String?* x)", b.GetMember("M3").ToTestDisplayString());
            Assert.Equal("System.String? B.this[System.Action? x] { get; set; }", b.GetMember("this[]").ToTestDisplayString());
            Assert.Equal("B.implicit operator B?(int)", b.GetMember("op_Implicit").ToDisplayString());

            Assert.Equal("String? D1()", compilation.GetTypeByMetadataName("D1")
                .ToDisplayString(new SymbolDisplayFormat(delegateStyle: SymbolDisplayDelegateStyle.NameAndSignature,
                    miscellaneousOptions: SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier)));

            var f = compilation.GetTypeByMetadataName("F");
            Assert.Equal("C<F?>", f.BaseType().ToTestDisplayString());
            Assert.Equal("I1<C<B?>>", f.Interfaces()[0].ToTestDisplayString());
            Assert.Equal("I2<C<B>?>", f.Interfaces()[1].ToTestDisplayString());
        }

        [Fact]
        public void NullableAttribute_01()
        {
            var source =
@"#pragma warning disable 8618
public abstract class B
{
    public string? F1; 
    public event System.Action? E1;
    public string? P1 {get; set;}
    public string?[][,] P2 {get; set;}
    public System.Action<string?> M1(string? x) {throw new System.NotImplementedException();}
    public string[]?[,] M2(string[][,]? x) {throw new System.NotImplementedException();}
    public abstract string? this[System.Action? x] {get; set;} 

    public static implicit operator B?(int x) {throw new System.NotImplementedException();}
    public event System.Action? E2
    {
        add { }
        remove { }
    }
}

public delegate string? D1();

public interface I1<T>{}
public interface I2<T>{}

public class C<T> {}

public class F : C<F?>, I1<C<B?>>, I2<C<B>?>
{}
";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (5,33): warning CS0067: The event 'B.E1' is never used
                //     public event System.Action? E1;
                Diagnostic(ErrorCode.WRN_UnreferencedEvent, "E1").WithArguments("B.E1").WithLocation(5, 33)
                );

            CompileAndVerify(compilation,
                             symbolValidator: m =>
                                {
                                    var b = ((PEModuleSymbol)m).GlobalNamespace.GetTypeMember("B");
                                    Assert.Equal("System.String? B.F1", b.GetMember("F1").ToTestDisplayString());
                                    Assert.Equal("event System.Action? B.E1", b.GetMember("E1").ToTestDisplayString());
                                    Assert.Equal("System.String? B.P1 { get; set; }", b.GetMember("P1").ToTestDisplayString());
                                    Assert.Equal("System.String?[][,] B.P2 { get; set; }", b.GetMember("P2").ToTestDisplayString());
                                    Assert.Equal("System.Action<System.String?> B.M1(System.String? x)", b.GetMember("M1").ToTestDisplayString());
                                    Assert.Equal("System.String[]?[,] B.M2(System.String[][,]? x)", b.GetMember("M2").ToTestDisplayString());
                                    Assert.Equal("System.String? B.this[System.Action? x] { get; set; }", b.GetMember("this[]").ToTestDisplayString());
                                    Assert.Equal("B.implicit operator B?(int)", b.GetMember("op_Implicit").ToDisplayString());
                                    Assert.Equal("event System.Action? B.E2", b.GetMember("E2").ToTestDisplayString());

                                    Assert.Equal("String? D1()", compilation.GetTypeByMetadataName("D1")
                                        .ToDisplayString(new SymbolDisplayFormat(delegateStyle: SymbolDisplayDelegateStyle.NameAndSignature,
                                            miscellaneousOptions: SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier)));

                                    var f = ((PEModuleSymbol)m).GlobalNamespace.GetTypeMember("F");
                                    Assert.Equal("C<F?>", f.BaseType().ToTestDisplayString());

                                    Assert.Equal("I1<C<B?>>", f.Interfaces()[0].ToTestDisplayString());
                                    Assert.Equal("I2<C<B>?>", f.Interfaces()[1].ToTestDisplayString());
                                });
        }

        [Fact]
        public void NullableAttribute_02()
        {
            CSharpCompilation c0 = CreateCompilation(new[] { @"
public class CL0 
{
    public object F1;

    public object? P1 { get; set;}
}
" }, options: WithNonNullTypesTrue(TestOptions.DebugDll));

            string source = @"
class C 
{
    static void Main()
    {
    }

    void Test1(CL0 x1, object? y1)
    {
        x1.F1 = y1;
    }

    void Test2(CL0 x2, object y2)
    {
        y2 = x2.P1;
    }
}
";
            var expected = new[]
            {
                // (10,17): warning CS8601: Possible null reference assignment.
                //         x1.F1 = y1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y1").WithLocation(10, 17),
                // (15,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y2 = x2.P1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2.P1").WithLocation(15, 14)
            };

            CSharpCompilation c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                                                                parseOptions: TestOptions.Regular8,
                                                                references: new[] { c0.EmitToImageReference() });
            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                                                                parseOptions: TestOptions.Regular8,
                                                                references: new[] { c0.ToMetadataReference() });
            c.VerifyDiagnostics(expected);
        }

        [Fact]
        public void NullableAttribute_03()
        {
            CSharpCompilation c0 = CreateCompilation(new[] { @"
public class CL0 
{
    public object F1;
}
" }, options: WithNonNullTypesTrue(TestOptions.DebugDll));

            string source = @"
class C 
{
    static void Main()
    {
    }

    void Test1(CL0 x1, object? y1)
    {
        x1.F1 = y1;
    }
}
";
            var expected = new[]
            {
                // (10,17): warning CS8601: Possible null reference assignment.
                //         x1.F1 = y1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y1").WithLocation(10, 17)
            };

            CSharpCompilation c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                                                                parseOptions: TestOptions.Regular8,
                                                                references: new[] { c0.EmitToImageReference() });
            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                                                                parseOptions: TestOptions.Regular8,
                                                                references: new[] { c0.ToMetadataReference() });
            c.VerifyDiagnostics(expected);
        }

        [Fact]
        public void NullableAttribute_04()
        {
            var source =
@"#pragma warning disable 8618
using System.Runtime.CompilerServices;

public abstract class B
{
    [Nullable(0)] public string F1; 
    [Nullable(1)] public event System.Action E1;
    [Nullable(2)] public string[][,] P2 {get; set;}
    [return:Nullable(0)] public System.Action<string?> M1(string? x) 
    {throw new System.NotImplementedException();}
    public string[][,] M2([Nullable(new byte[] {0})] string[][,] x) 
    {throw new System.NotImplementedException();}
}

public class C<T> {}

[Nullable(2)] public class F : C<F>
{}
";
            var compilation = CreateCompilation(new[] { source, NullableAttributeDefinition }, options: WithNonNullTypesTrue());

            compilation.VerifyDiagnostics(
                // (7,6): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //     [Nullable(1)] public event System.Action E1;
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "Nullable(1)").WithLocation(7, 6),
                // (8,6): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //     [Nullable(2)] public string[][,] P2 {get; set;}
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "Nullable(2)").WithLocation(8, 6),
                // (9,13): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //     [return:Nullable(0)] public System.Action<string?> M1(string? x)
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "Nullable(0)").WithLocation(9, 13),
                // (11,28): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //     public string[][,] M2([Nullable(new byte[] {0})] string[][,] x)
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "Nullable(new byte[] {0})").WithLocation(11, 28),
                // (6,6): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //     [Nullable(0)] public string F1;
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "Nullable(0)").WithLocation(6, 6),
                // (17,2): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                // [Nullable(2)] public class F : C<F>
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "Nullable(2)").WithLocation(17, 2),
                // (7,46): warning CS0067: The event 'B.E1' is never used
                //     [Nullable(1)] public event System.Action E1;
                Diagnostic(ErrorCode.WRN_UnreferencedEvent, "E1").WithArguments("B.E1").WithLocation(7, 46)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_01()
        {
            string lib = @"
using System;

public class CL0 
{
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

partial class C 
{
    partial class B 
    {
        public event Action E1;
        public event Action? E2;

" + NonNullTypesOff() + @"
        void Test11(Action? x11)
        {
            E1 = x11;
        }

" + NonNullTypesOff() + @"
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

" + NonNullTypesOff() + @"
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

partial class C 
{
    partial class B 
    {
" + NonNullTypesOff() + @"
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

" + NonNullTypesOff() + @"
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

" + NonNullTypesOff() + @"
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            CSharpCompilation c1 = CreateCompilation(new[] { lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_02()
        {
            string lib =
@"#pragma warning disable 8618
using System;

" + NonNullTypesOff() + @"
public class CL0
{
" + NonNullTypesOff() + @"
    public class CL1
    {
" + NonNullTypesOn() + @"
        public Action F1;
" + NonNullTypesOn() + @"
        public Action? F2;

" + NonNullTypesOn() + @"
        public Action P1 { get; set; }
" + NonNullTypesOn() + @"
        public Action? P2 { get; set; }

" + NonNullTypesOn() + @"
        public Action M1() { throw new System.NotImplementedException(); }
" + NonNullTypesOn() + @"
        public Action? M2() { return null; }
" + NonNullTypesOn() + @"
        public void M3(Action x3) {}
    }
}
";

            string source1 =
@"#pragma warning disable 8618
using System;


partial class C 
{

    partial class B 
    {
" + NonNullTypesOn() + @"
        public event Action E1;
" + NonNullTypesOn() + @"
        public event Action? E2;

" + NonNullTypesOn() + @"
        void Test11(Action? x11)
        {
            E1 = x11;
        }

" + NonNullTypesOn() + @"
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

" + NonNullTypesOn() + @"
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 =
@"#pragma warning disable 8618
using System;

" + NonNullTypesOff() + @"
partial class C
{
" + NonNullTypesOff() + @"
    partial class B
    {
" + NonNullTypesOn() + @"
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

" + NonNullTypesOn() + @"
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

" + NonNullTypesOn() + @"
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesFalse());

            c.VerifyDiagnostics(
                // (18,18): warning CS8601: Possible null reference assignment.
                //             E1 = x11;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x11").WithLocation(18, 18),
                // (24,19): hidden CS8607: Expression is probably never null.
                //             x12 = E1 ?? x12;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(24, 19),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x13 = E2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(30, 19),
                // (13,20): warning CS8601: Possible null reference assignment.
                //             c.F1 = x21;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x21").WithLocation(13, 20),
                // (14,20): warning CS8601: Possible null reference assignment.
                //             c.P1 = x21;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x21").WithLocation(14, 20),
                // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                //             c.M3(x21);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                // (21,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.F1 ?? x22;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                // (22,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.P1 ?? x22;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                // (23,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.M1() ?? x22;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesFalse());

            c1.VerifyDiagnostics();

            var expected = new[] {
                // (13,20): warning CS8601: Possible null reference assignment.
                //             c.F1 = x21;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x21").WithLocation(13, 20),
                // (14,20): warning CS8601: Possible null reference assignment.
                //             c.P1 = x21;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x21").WithLocation(14, 20),
                // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                //             c.M3(x21);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                // (21,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.F1 ?? x22;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                // (22,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.P1 ?? x22;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                // (23,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.M1() ?? x22;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                };

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesFalse());

            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesFalse());

            c.VerifyDiagnostics(expected);
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void NonNullTypes_03()
        {
            string lib = @"
using System;

public class CL0
{
    public class CL1
    {
" + NonNullTypesOn() + @"
        public Action F1 = null!;
" + NonNullTypesOn() + @"
        public Action? F2;

" + NonNullTypesOn() + @"
        public Action P1 { get; set; } = null!;
" + NonNullTypesOn() + @"
        public Action? P2 { get; set; }

" + NonNullTypesOn() + @"
        public Action M1() { throw new System.NotImplementedException(); }
" + NonNullTypesOn() + @"
        public Action? M2() { return null; }
" + NonNullTypesOn() + @"
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;


partial class C
{

    partial class B
    {
" + NonNullTypesOn() + @"
        public event Action E1;
" + NonNullTypesOn() + @"
        public event Action? E2;
" + NonNullTypesOff() + @"
        void Test11(Action? x11) // 1
        {
            E1 = x11; // 2
        }

        void Test12(Action x12)
        {
            x12 = E1 ?? x12; // 3
        }

        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

partial class C
{
    partial class B
    {
        void Test21(CL0.CL1 c, Action? x21) // 4
        {
            c.F1 = x21; // 5
            c.P1 = x21; // 6
            c.M3(x21); // 7
        }

        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22; // 8
            x22 = c.P1 ?? x22; // 9
            x22 = c.M1() ?? x22; // 10
        }

        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesFalse());

            c.VerifyDiagnostics(
                // (15,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test11(Action? x11) // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(15, 27),
                // (8,38): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test21(CL0.CL1 c, Action? x21) // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 38)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesFalse());

            c1.VerifyDiagnostics();

            var expectedDiagnostics = new[] {
                // (8,38): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test21(CL0.CL1 c, Action? x21) // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 38)
                };

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesFalse());

            c.VerifyDiagnostics(expectedDiagnostics);

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesFalse());

            c.VerifyDiagnostics(expectedDiagnostics);

            expectedDiagnostics = new[] {
                // (10,20): warning CS8601: Possible null reference assignment.
                //             c.F1 = x21; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x21").WithLocation(10, 20),
                // (11,20): warning CS8601: Possible null reference assignment.
                //             c.P1 = x21; // 6
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x21").WithLocation(11, 20),
                // (12,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                //             c.M3(x21); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(12, 18),
                // (17,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.F1 ?? x22; // 8
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(17, 19),
                // (18,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.P1 ?? x22; // 9
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(18, 19),
                // (19,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.M1() ?? x22; // 10
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(19, 19),
                // (24,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(24, 19),
                // (25,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(25, 19),
                // (26,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(26, 19)
                };

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(expectedDiagnostics);

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(expectedDiagnostics);
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void NonNullTypes_04()
        {
            string lib = @"
using System;

" + NonNullTypesOff() + @"
public class CL0
{
    public class CL1
    {
" + NonNullTypesOn() + @"
        public Action F1 = null!;
" + NonNullTypesOn() + @"
        public Action? F2;

" + NonNullTypesOn() + @"
        public Action P1 { get; set; } = null!;
" + NonNullTypesOn() + @"
        public Action? P2 { get; set; }

" + NonNullTypesOn() + @"
        public Action M1() { throw new System.NotImplementedException(); }
" + NonNullTypesOn() + @"
        public Action? M2() { return null; }
" + NonNullTypesOn() + @"
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

partial class C 
{
    partial class B 
    {
" + NonNullTypesOn() + @"
        public event Action E1;
" + NonNullTypesOn() + @"
        public event Action? E2;

        void Test11(Action? x11) // 1
        {
            E1 = x11; // 2
        }

        void Test12(Action x12)
        {
            x12 = E1 ?? x12; // 3
        }

        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

" + NonNullTypesOff() + @"
partial class C
{
    partial class B
    {
        void Test21(CL0.CL1 c, Action? x21) // 4
        {
            c.F1 = x21; // 5
            c.P1 = x21; // 6
            c.M3(x21); // 7
        }

        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22; // 8
            x22 = c.P1 ?? x22; // 9
            x22 = c.M1() ?? x22; // 10
        }

        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (9,38): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test21(CL0.CL1 c, Action? x21) // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 38),
                // (15,18): warning CS8601: Possible null reference assignment.
                //             E1 = x11; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x11").WithLocation(15, 18),
                // (20,19): hidden CS8607: Expression is probably never null.
                //             x12 = E1 ?? x12; // 3
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(20, 19),
                // (25,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x13 = E2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(25, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c1.VerifyDiagnostics();

            var expected = new[]
            {
                // (9,38): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test21(CL0.CL1 c, Action? x21) // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 38)
            };

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(expected);
        }

        [WorkItem(30840, "https://github.com/dotnet/roslyn/issues/30840")]
        [Fact]
        public void NonNullTypes_05()
        {
            string lib = @"
using System;

" + NonNullTypesOn() + @"
public class CL0
{
" + NonNullTypesOff() + @"
    public class CL1
    {
" + NonNullTypesOn() + @"
        public Action F1 = null!;
" + NonNullTypesOn() + @"
        public Action? F2;

" + NonNullTypesOn() + @"
        public Action P1 { get; set; } = null!;
" + NonNullTypesOn() + @"
        public Action? P2 { get; set; }

" + NonNullTypesOn() + @"
        public Action M1() { throw new System.NotImplementedException(); }
" + NonNullTypesOn() + @"
        public Action? M2() { return null; }
" + NonNullTypesOn() + @"
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

partial class C 
{
    partial class B 
    {
" + NonNullTypesOn() + @"
        public event Action E1;
" + NonNullTypesOn() + @"
        public event Action? E2;

        void Test11(Action? x11) // 1
        {
            E1 = x11; // 2
        }

        void Test12(Action x12)
        {
            x12 = E1 ?? x12; // 3
        }

        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

" + NonNullTypesOn() + @"
partial class C
{
" + NonNullTypesOff() + @"
    partial class B
    {
        void Test21(CL0.CL1 c, Action? x21) // 4
        {
            c.F1 = x21; // 5
            c.P1 = x21; // 6
            c.M3(x21); // 7
        }

        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22; // 8
            x22 = c.P1 ?? x22; // 9
            x22 = c.M1() ?? x22; // 10
        }

        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (10,38): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test21(CL0.CL1 c, Action? x21) // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 38),
                // (15,18): warning CS8601: Possible null reference assignment.
                //             E1 = x11; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x11").WithLocation(15, 18),
                // (20,19): hidden CS8607: Expression is probably never null.
                //             x12 = E1 ?? x12; // 3
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(20, 19),
                // (25,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x13 = E2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(25, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c1.VerifyDiagnostics();

            var expected = new[]
            {
                // (10,38): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void Test21(CL0.CL1 c, Action? x21) // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(10, 38)
            };

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(expected);
        }

        [Fact]
        public void NonNullTypes_06()
        {
            string lib = @"
using System;

" + NonNullTypesOn() + @"
public class CL0
{
" + NonNullTypesOn() + @"
    public class CL1
    {
" + NonNullTypesOff() + @"
        public Action F1 = null!;
" + NonNullTypesOff() + @"
        public Action? F2;

" + NonNullTypesOff() + @"
        public Action P1 { get; set; } = null!;
" + NonNullTypesOff() + @"
        public Action? P2 { get; set; }

" + NonNullTypesOff() + @"
        public Action M1() { throw new System.NotImplementedException(); }
" + NonNullTypesOff() + @"
        public Action? M2() { return null; }
" + NonNullTypesOff() + @"
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

" + NonNullTypesOn() + @"
partial class C
{
" + NonNullTypesOn() + @"
    partial class B
    {
" + NonNullTypesOff() + @"
        public event Action E1;
" + NonNullTypesOff() + @"
        public event Action? E2;

" + NonNullTypesOn() + @"
        void Test11(Action? x11)
        {
            E1 = x11;
        }

" + NonNullTypesOn() + @"
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

" + NonNullTypesOn() + @"
        void Test13(Action x13)
        {
            x13 = E2; // warn 1
        }
    }
}
";

            string source2 = @"
using System;

partial class C 
{
    partial class B 
    {
" + NonNullTypesOn() + @"
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

" + NonNullTypesOn() + @"
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

" + NonNullTypesOn() + @"
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2; // warn 2
            x23 = c.P2; // warn 3
            x23 = c.M2(); // warn 4
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (13,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public Action? F2;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 22),
                // (18,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public Action? P2 { get; set; }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 22),
                // (23,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public Action? M2() { return null; }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(23, 22),
                // (13,28): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public event Action? E2;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 28),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x13 = E2; // warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(30, 19),
                // (27,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2; // warn 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(27, 19),
                // (28,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2; // warn 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(28, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2(); // warn 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(29, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c1.VerifyDiagnostics(
                // (13,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public Action? F2;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 22),
                // (18,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public Action? P2 { get; set; }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 22),
                // (23,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public Action? M2() { return null; }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(23, 22)
                );

            c = CreateCompilation(new[] { source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (27,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2; // warn 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(27, 19),
                // (28,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2; // warn 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(28, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2(); // warn 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(29, 19)
                );

            c = CreateCompilation(new[] { source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (27,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2; // warn 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(27, 19),
                // (28,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2; // warn 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(28, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2(); // warn 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(29, 19)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_07()
        {
            string moduleAttributes = @"
[module:System.Runtime.CompilerServices.NonNullTypes(true)]
";

            string lib = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(true)]
public class CL0 
{
    [System.Runtime.CompilerServices.NonNullTypes(false)]
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(true)]
partial class C 
{
    [System.Runtime.CompilerServices.NonNullTypes(false)]
    partial class B 
    {
        public event Action E1;
        public event Action? E2;

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test11(Action? x11)
        {
            E1 = x11;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

partial class C 
{
    partial class B 
    {
        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { moduleAttributes, lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            CSharpCompilation c1 = CreateCompilation(new[] { moduleAttributes, lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_08()
        {
            string moduleAttributes = @"
[module:System.Runtime.CompilerServices.NonNullTypes(true)]
";

            string lib = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(false)]
public class CL0 
{
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(false)]
partial class C 
{
    partial class B 
    {
        public event Action E1;
        public event Action? E2;

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test11(Action? x11)
        {
            E1 = x11;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

partial class C 
{
    partial class B 
    {
        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { moduleAttributes, lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            CSharpCompilation c1 = CreateCompilation(new[] { moduleAttributes, lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_09()
        {
            string moduleAttributes = @"
[module:System.Runtime.CompilerServices.NonNullTypes(false)]
";

            string lib = @"
using System;

public class CL0 
{
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;

partial class C 
{
    partial class B 
    {
        public event Action E1;
        public event Action? E2;

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test11(Action? x11)
        {
            E1 = x11;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

partial class C 
{
    partial class B 
    {
        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

        [System.Runtime.CompilerServices.NonNullTypes(true)]
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { moduleAttributes, lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            CSharpCompilation c1 = CreateCompilation(new[] { moduleAttributes, lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics();
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_10()
        {
            string moduleAttributes = @"
[module:System.Runtime.CompilerServices.NonNullTypes(false)]
";

            string lib = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(false)]
public class CL0 
{
    [System.Runtime.CompilerServices.NonNullTypes(true)]
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;


partial class C 
{

    partial class B 
    {
        
        public event Action E1;
        
        public event Action? E2;

        
        void Test11(Action? x11)
        {
            E1 = x11;
        }

        
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

        
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(false)]
partial class C 
{
    [System.Runtime.CompilerServices.NonNullTypes(true)]
    partial class B 
    {
        
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

        
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

        
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { moduleAttributes, lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (18,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             E1 = x11;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x11").WithLocation(18, 18),
                 // (24,19): hidden CS8607: Expression is probably never null.
                 //             x12 = E1 ?? x12;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(24, 19),
                 // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x13 = E2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(30, 19),
                 // (13,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             c.F1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(13, 20),
                 // (14,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             c.P1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(14, 20),
                 // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                 //             c.M3(x21);
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                 // (21,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.F1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                 // (22,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.P1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                 // (23,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.M1() ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                 // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                 // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.P2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                 // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { moduleAttributes, lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            var expected = new[] {
                // (13,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             c.F1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(13, 20),
                // (14,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             c.P1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(14, 20),
                // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                //             c.M3(x21);
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                // (21,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.F1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                // (22,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.P1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                // (23,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.M1() ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                };

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(expected);
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_11()
        {
            string moduleAttributes = @"
[module:System.Runtime.CompilerServices.NonNullTypes(false)]
";

            string lib = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(true)]
public class CL0 
{
    
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;


partial class C 
{

    partial class B 
    {
        
        public event Action E1;
        
        public event Action? E2;

        
        void Test11(Action? x11)
        {
            E1 = x11;
        }

        
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

        
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;

[System.Runtime.CompilerServices.NonNullTypes(true)]
partial class C 
{
    
    partial class B 
    {
        
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

        
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

        
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { moduleAttributes, lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (18,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             E1 = x11;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x11").WithLocation(18, 18),
                 // (24,19): hidden CS8607: Expression is probably never null.
                 //             x12 = E1 ?? x12;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(24, 19),
                 // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x13 = E2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(30, 19),
                 // (13,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             c.F1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(13, 20),
                 // (14,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             c.P1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(14, 20),
                 // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                 //             c.M3(x21);
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                 // (21,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.F1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                 // (22,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.P1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                 // (23,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.M1() ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                 // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                 // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.P2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                 // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { moduleAttributes, lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            var expected = new[] {
                // (13,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             c.F1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(13, 20),
                // (14,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             c.P1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(14, 20),
                // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                //             c.M3(x21);
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                // (21,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.F1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                // (22,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.P1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                // (23,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.M1() ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                };

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(expected);
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_12()
        {
            string moduleAttributes = @"
[module:System.Runtime.CompilerServices.NonNullTypes(true)]
";

            string lib = @"
using System;


public class CL0 
{
    
    public class CL1 
    {
        public Action F1;
        public Action? F2;

        public Action P1 { get; set; }
        public Action? P2 { get; set; }

        public Action M1() { throw new System.NotImplementedException(); }
        public Action? M2() { return null; }
        public void M3(Action x3) {}
    }
}
";

            string source1 = @"
using System;


partial class C 
{

    partial class B 
    {
        
        public event Action E1;
        
        public event Action? E2;

        
        void Test11(Action? x11)
        {
            E1 = x11;
        }

        
        void Test12(Action x12)
        {
            x12 = E1 ?? x12;
        }

        
        void Test13(Action x13)
        {
            x13 = E2;
        }
    }
}
";

            string source2 = @"
using System;


partial class C 
{
    
    partial class B 
    {
        
        void Test21(CL0.CL1 c, Action? x21)
        {
            c.F1 = x21;
            c.P1 = x21;
            c.M3(x21);
        }

        
        void Test22(CL0.CL1 c, Action x22)
        {
            x22 = c.F1 ?? x22;
            x22 = c.P1 ?? x22;
            x22 = c.M1() ?? x22;
        }

        
        void Test23(CL0.CL1 c, Action x23)
        {
            x23 = c.F2;
            x23 = c.P2;
            x23 = c.M2();
        }
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { moduleAttributes, lib, source1, source2 },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (18,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             E1 = x11;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x11").WithLocation(18, 18),
                 // (24,19): hidden CS8607: Expression is probably never null.
                 //             x12 = E1 ?? x12;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "E1").WithLocation(24, 19),
                 // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x13 = E2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "E2").WithLocation(30, 19),
                 // (13,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             c.F1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(13, 20),
                 // (14,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             c.P1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(14, 20),
                 // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                 //             c.M3(x21);
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                 // (21,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.F1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                 // (22,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.P1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                 // (23,19): hidden CS8607: Expression is probably never null.
                 //             x22 = c.M1() ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                 // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                 // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.P2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                 // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //             x23 = c.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                );

            CSharpCompilation c1 = CreateCompilation(new[] { moduleAttributes, lib },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c1.VerifyDiagnostics();

            var expected = new[] {
                // (13,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             c.F1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(13, 20),
                // (14,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             c.P1 = x21;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x21").WithLocation(14, 20),
                // (15,18): warning CS8604: Possible null reference argument for parameter 'x3' in 'void CL1.M3(Action x3)'.
                //             c.M3(x21);
                 Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x21").WithArguments("x3", "void CL1.M3(Action x3)").WithLocation(15, 18),
                // (21,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.F1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.F1").WithLocation(21, 19),
                // (22,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.P1 ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.P1").WithLocation(22, 19),
                // (23,19): hidden CS8607: Expression is probably never null.
                //             x22 = c.M1() ?? x22;
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c.M1()").WithLocation(23, 19),
                // (29,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.F2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F2").WithLocation(29, 19),
                // (30,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.P2;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.P2").WithLocation(30, 19),
                // (31,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x23 = c.M2();
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.M2()").WithLocation(31, 19)
                };

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.ToMetadataReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(expected);

            c = CreateCompilation(new[] { moduleAttributes, source2 }, new[] { c1.EmitToImageReference() },
                                              parseOptions: TestOptions.Regular8,
                                              options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(expected);
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_13()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    string?[]? M1()
    {
        return null;
    }

    void Test1()
    {
        M1().ToString();
        M1()[0].ToString();
        var x1 = M1()[0] ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    string[] M2()
    {
        return null;
    }

    void Test2()
    {
        M2()[0] = null;
        var x2 = M2()[0] ?? """";
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_14()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    CL1<string?>? M1()
    {
        return null;
    }

    void Test1()
    {
        M1().ToString();
        M1().P1.ToString();
        var x1 = M1().P1 ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    CL1<string> M2()
    {
        return null;
    }

    void Test2()
    {
        M2().P1 = null;
        var x2 = M2().P1 ?? """";
    }

    CL1<string?> M3()
    {
         return new CL1<string?>();
    }

    void Test3()
    {
        M3().ToString();
        M3().P1.ToString();
        var x3 = M3().P1 ?? """";
    }

    CL1<string> M4()
    {
        return new CL1<string>();
    }

    void Test4()
    {
        M4().P1 = null;
        var x4 = M4().P1 ?? """";
    }
}

class CL1<T>
{
    public T P1;
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (39,9): warning CS8602: Possible dereference of a null reference.
                 //         M3().P1.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M3().P1").WithLocation(39, 9),
                 // (50,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         M4().P1 = null;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(50, 19),
                 // (51,18): hidden CS8607: Expression is probably never null.
                 //         var x4 = M4().P1 ?? "";
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M4().P1").WithLocation(51, 18)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_15()
        {
            string source = @"
class C 
{
    void Main() {}
}

class CL1<T>
{
    public virtual CL1<T> M1()
    {
        return new CL1<T>();
    }
}

class CL2 : CL1<string>
{
    public override CL1<string?> M1() // 2
    {
        return base.M1();
    }
}

class CL3 : CL1<string?>
{
    public override CL1<string?> M1()
    {
        return base.M1();
    }
}

class CL4<T> where T : class
{
    [System.Runtime.CompilerServices.NonNullTypes(false)]
    public virtual CL4<T?> M4()
    {
        return new CL4<T?>();
    }
}

class CL5 : CL4<string>
{
    public override CL4<string> M4()
    {
        return base.M4();
    }
}

class CL6 : CL4<string?>
{
    public override CL4<string> M4() // 6
    {
        return base.M4();
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (17,34): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override CL1<string?> M1() // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M1").WithLocation(17, 34),
                 // (19,16): warning CS8619: Nullability of reference types in value of type 'CL1<string>' doesn't match target type 'CL1<string?>'.
                 //         return base.M1();
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "base.M1()").WithArguments("CL1<string>", "CL1<string?>").WithLocation(19, 16),
                 // (50,33): warning CS8609: Nullability of reference types in return type doesn't match overridden member.
                 //     public override CL4<string> M4() // 6
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnOverride, "M4").WithLocation(50, 33),
                 // (52,16): warning CS8619: Nullability of reference types in value of type 'CL4<string?>' doesn't match target type 'CL4<string>'.
                 //         return base.M4();
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "base.M4()").WithArguments("CL4<string?>", "CL4<string>").WithLocation(52, 16)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_16()
        {
            string source = @"
class C 
{
    void Main() {}
}

class CL1<T>
{
    public virtual void M1(CL1<T> x1)
    {
    }
}

class CL2 : CL1<string>
{
    public override void M1(CL1<string?> x2) // 2
    {
    }
}

class CL3 : CL1<string?>
{
    public override void M1(CL1<string?> x3)
    {
    }
}

class CL4<T> where T : class
{
    [System.Runtime.CompilerServices.NonNullTypes(false)]
    public virtual void M4(CL4<T?> x4)
    {
    }
}

class CL5 : CL4<string>
{
    public override void M4(CL4<string> x5)
    {
    }
}

class CL6 : CL4<string?>
{
    public override void M4(CL4<string> x6) // 6
    {
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (16,26): warning CS8610: Nullability of reference types in type of parameter 'x2' doesn't match overridden member.
                 //     public override void M1(CL1<string?> x2) // 2
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M1").WithArguments("x2").WithLocation(16, 26),
                 // (45,26): warning CS8610: Nullability of reference types in type of parameter 'x6' doesn't match overridden member.
                 //     public override void M4(CL4<string> x6) // 6
                 Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOnOverride, "M4").WithArguments("x6").WithLocation(45, 26)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_17()
        {
            string source = @"
class C 
{
    void Main() {}

    void Test1()
    {
        CL0<string?>.M1().ToString();
        var x1 = CL0<string?>.M1() ?? """";
    }
}

[System.Runtime.CompilerServices.NonNullTypes(false)]
class CL0<T>
{
    public static T M1()
    {
        return default(T);
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (8,9): warning CS8602: Possible dereference of a null reference.
                 //         CL0<string?>.M1().ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "CL0<string?>.M1()").WithLocation(8, 9)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_18()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    CL1<string?>? M1 { get; set; }

    void Test1()
    {
        M1.ToString();
        M1.P1.ToString();
        var x1 = M1.P1 ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    CL1<string> M2 { get; set; }

    void Test2()
    {
        M2.P1 = null;
        var x2 = M2.P1 ?? """";
    }

    CL1<string?> M3 { get; set; }

    void Test3()
    {
        M3.ToString();
        M3.P1.ToString();
        var x3 = M3.P1 ?? """";
    }

    CL1<string> M4 { get; set; }

    void Test4()
    {
        M4.P1 = null;
        var x4 = M4.P1 ?? """";
    }
}

class CL1<T>
{
    public T P1;
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (30,9): warning CS8602: Possible dereference of a null reference.
                 //         M3.P1.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M3.P1").WithLocation(30, 9),
                 // (38,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         M4.P1 = null;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(38, 17),
                 // (39,18): hidden CS8607: Expression is probably never null.
                 //         var x4 = M4.P1 ?? "";
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M4.P1").WithLocation(39, 18)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_19()
        {
            string source = @"
class C 
{
    void Main() {}

    void Test1()
    {
        CL0<string?>.M1.ToString();
        var x1 = CL0<string?>.M1 ?? """";
    }
}

[System.Runtime.CompilerServices.NonNullTypes(false)]
class CL0<T>
{
    public static T M1 { get; set; }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (8,9): warning CS8602: Possible dereference of a null reference.
                 //         CL0<string?>.M1.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "CL0<string?>.M1").WithLocation(8, 9)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_20()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    CL1<string?>? M1;

    void Test1()
    {
        M1.ToString();
        M1.P1.ToString();
        var x1 = M1.P1 ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    CL1<string> M2;

    void Test2()
    {
        M2.P1 = null;
        var x2 = M2.P1 ?? """";
    }

    CL1<string?> M3;

    void Test3()
    {
        M3.ToString();
        M3.P1.ToString();
        var x3 = M3.P1 ?? """";
    }

    CL1<string> M4;

    void Test4()
    {
        M4.P1 = null;
        var x4 = M4.P1 ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void Assign()
    {
        M1 = null;
        M2 = null;
        M3 = null;
        M4 = null;
    }
}

class CL1<T>
{
    public T P1;
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (30,9): warning CS8602: Possible dereference of a null reference.
                 //         M3.P1.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M3.P1").WithLocation(30, 9),
                 // (38,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         M4.P1 = null;
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(38, 17),
                 // (39,18): hidden CS8607: Expression is probably never null.
                 //         var x4 = M4.P1 ?? "";
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M4.P1").WithLocation(39, 18)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_21()
        {
            string source = @"
class C 
{
    void Main() {}

    void Test1()
    {
        CL0<string?>.M1.ToString();
        var x1 = CL0<string?>.M1 ?? """";
    }
}

[System.Runtime.CompilerServices.NonNullTypes(false)]
class CL0<T>
{
    public static T M1 = default(T);
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (8,9): warning CS8602: Possible dereference of a null reference.
                 //         CL0<string?>.M1.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "CL0<string?>.M1").WithLocation(8, 9)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_22()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    event System.Func<string?>? M1;

    void Test1()
    {
        M1.ToString();
        M1().ToString();
        var x1 = M1() ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    event System.Func<string> M2;

    void Test2()
    {
        var x2 = M2() ?? """";
    }

    event System.Func<string?> M3;

    void Test3()
    {
        M3.ToString();
        M3().ToString();
        var x3 = M3() ?? """";
    }

    event System.Func<string> M4;

    void Test4()
    {
        var x4 = M4() ?? """";
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void Assign()
    {
        M1 = null;
        M2 = null;
        M3 = null;
        M4 = null;
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (29,9): warning CS8602: Possible dereference of a null reference.
                 //         M3().ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M3()").WithLocation(29, 9),
                 // (37,18): hidden CS8607: Expression is probably never null.
                 //         var x4 = M4() ?? "";
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M4()").WithLocation(37, 18)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_23()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    delegate void D1 (CL1<string?>? x1);

    void M1(D1 x1) {}

    void Test1()
    {
        M1(a1 => a1.ToString());
        M1(b1 => b1.P1.ToString());
        M1(c1 => {var x1 = c1.P1 ?? """";});
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    delegate void D2(CL1<string> x2);

    void M2(D2 x2) {}

    void Test2()
    {
        M2(a2 => {a2.P1 = null;});
        M2(b2 => {var x2 = b2.P1 ?? """";});
    }

    delegate void D3 (CL1<string?> x3);
    void M3(D3 x3) {}

    void Test3()
    {
        M3(a3 => a3.ToString());
        M3(b3 => b3.P1.ToString());
        M3(c3 => {var x3 = c3.P1 ?? """";});
    }

    delegate void D4(CL1<string> x4);
    void M4(D4 x4) {}

    void Test4()
    {
        M4(a4 => {a4.P1 = null;});
        M4(b4 => {var x4 = b4.P1 ?? """";});
    }

    void Test11()
    {
        D1 u11 = a11 => a11.ToString();
        D1 v11 = b11 => b11.P1.ToString();
        D1 w11 = c11 => {var x11 = c11.P1 ?? """";};
    }

    void Test21()
    {
        D2 u21 = a21 => {a21.P1 = null;};
        D2 v21 = b21 => {var x21 = b21.P1 ?? """";};
    }

    void Test31()
    {
        D3 u31 = a31 => a31.ToString();
        D3 v31 = b31 => b31.P1.ToString();
        D3 w31 = c31 => {var x31 = c31.P1 ?? """";};
    }

    void Test41()
    {
        D4 u41 = a41 => {a41.P1 = null;};
        D4 v41 = b41 => {var x41 = b41.P1 ?? """";};
    }
}

class CL1<T>
{
    public T P1;
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (35,18): warning CS8602: Possible dereference of a null reference.
                 //         M3(b3 => b3.P1.ToString());
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b3.P1").WithLocation(35, 18),
                 // (44,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         M4(a4 => {a4.P1 = null;});
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(44, 27),
                 // (45,28): hidden CS8607: Expression is probably never null.
                 //         M4(b4 => {var x4 = b4.P1 ?? "";});
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "b4.P1").WithLocation(45, 28),
                 // (64,25): warning CS8602: Possible dereference of a null reference.
                 //         D3 v31 = b31 => b31.P1.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b31.P1").WithLocation(64, 25),
                 // (70,35): warning CS8600: Converting null literal or possible null value to non-nullable type.
                 //         D4 u41 = a41 => {a41.P1 = null;};
                 Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(70, 35),
                 // (71,36): hidden CS8607: Expression is probably never null.
                 //         D4 v41 = b41 => {var x41 = b41.P1 ?? "";};
                 Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "b41.P1").WithLocation(71, 36)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_24()
        {
            string source = @"
class C 
{
    void Main() {}

    void M1(CL0<string?> x1) {}

    void Test1()
    {
        M1(a1 => a1.ToString());
        M1(b1 => {var x1 = b1 ?? """";});
    }

    void Test2()
    {
        CL0<string?> u2 = a2 => a2.ToString();
        CL0<string?> v2 = b2 => {var x2 = b2 ?? """";};
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void M2(CL0<string?> x1) {}

    void Test3()
    {
        M2(a3 => a3.ToString());
        M2(b3 => {var x3 = b3 ?? """";});
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void M3(CL1<string?> x1) {}

    void Test4()
    {
        M3(a4 => a4.ToString());
        M3(b4 => {var x4 = b4 ?? """";});
    }

    void M4(CL1<string?> x1) {}

    void Test5()
    {
        M4(a5 => a5.ToString());
        M4(b5 => {var x5 = b5 ?? """";});
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void M5(CL2<string?> x1) {}

    void Test6()
    {
        M5(a6 => a6.ToString());
        M5(b6 => {var x6 = b6 ?? """";});
    }
}

[System.Runtime.CompilerServices.NonNullTypes(false)]
delegate void CL0<T>(T x);

[System.Runtime.CompilerServices.NonNullTypes(false)]
delegate void CL1<T>(T? x) where T : class;

delegate void CL2<T>(T? x) where T : class;
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (10,18): warning CS8602: Possible dereference of a null reference.
                 //         M1(a1 => a1.ToString());
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a1").WithLocation(10, 18),
                 // (16,33): warning CS8602: Possible dereference of a null reference.
                 //         CL0<string?> u2 = a2 => a2.ToString();
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a2").WithLocation(16, 33),
                 // (42,18): warning CS8602: Possible dereference of a null reference.
                 //         M4(a5 => a5.ToString());
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a5").WithLocation(42, 18),
                 // (51,18): warning CS8602: Possible dereference of a null reference.
                 //         M5(a6 => a6.ToString());
                 Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a6").WithLocation(51, 18)
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_25()
        {
            string source = @"
class C 
{
    void Main() {}

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    delegate string D1 ();

    void M1(D1 x1) {}

    void Test1()
    {
        M1(() => null);
    }

    void Test2()
    {
        D1 x2 = () => null;
    }

    delegate T D3<T> ();

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void M3(D3<string> x3) {}

    void Test3()
    {
        M3(() => null);
    }
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                );
        }

        [WorkItem(29616, "https://github.com/dotnet/roslyn/issues/29616")]
        [Fact(Skip = "NonNullTypes does not control warnings")]
        public void NonNullTypes_26()
        {
            string source = @"
class C 
{
    void Main() {}

    void M1(CL0<string> x1) {}

    void Test1()
    {
        M1(() => null);
    }

    void Test2()
    {
        CL0<string> x2 =() => null;
    }

    [System.Runtime.CompilerServices.NonNullTypes(false)]
    void M2(D2 x2) {}

    void Test3()
    {
        M2(() => null);
    }
}

[System.Runtime.CompilerServices.NonNullTypes(false)]
delegate T CL0<T>(); 

delegate string D2();
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: TestOptions.ReleaseDll);

            c.VerifyDiagnostics(
                 // (10,18): warning CS8603: Possible null reference return.
                 //         M1(() => null);
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(10, 18),
                 // (15,31): warning CS8603: Possible null reference return.
                 //         CL0<string> x2 =() => null;
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(15, 31),
                 // (23,18): warning CS8603: Possible null reference return.
                 //         M2(() => null);
                 Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(23, 18)
                );
        }

        [Fact]
        public void Covariance_Interface()
        {
            var source =
@"interface I<out T> { }
class C
{
    static I<string?> F1(I<string> i) => i;
    static I<object?> F2(I<string> i) => i;
    static I<string> F3(I<string?> i) => i;
    static I<object> F4(I<string?> i) => i;
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,42): warning CS8619: Nullability of reference types in value of type 'I<string?>' doesn't match target type 'I<string>'.
                //     static I<string> F3(I<string?> i) => i;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "i").WithArguments("I<string?>", "I<string>").WithLocation(6, 42),
                // (7,42): warning CS8619: Nullability of reference types in value of type 'I<string?>' doesn't match target type 'I<object>'.
                //     static I<object> F4(I<string?> i) => i;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "i").WithArguments("I<string?>", "I<object>").WithLocation(7, 42));
        }

        [Fact]
        public void Contravariance_Interface()
        {
            var source =
@"interface I<in T> { }
class C
{
    static I<string?> F1(I<string> i) => i;
    static I<string?> F2(I<object> i) => i;
    static I<string> F3(I<string?> i) => i;
    static I<string> F4(I<object?> i) => i;
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (4,42): warning CS8619: Nullability of reference types in value of type 'I<string>' doesn't match target type 'I<string?>'.
                //     static I<string?> F1(I<string> i) => i;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "i").WithArguments("I<string>", "I<string?>").WithLocation(4, 42),
                // (5,42): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<string?>'.
                //     static I<string?> F2(I<object> i) => i;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "i").WithArguments("I<object>", "I<string?>").WithLocation(5, 42));
        }

        [Fact]
        public void Covariance_Delegate()
        {
            var source =
@"delegate void D<in T>(T t);
class C
{
    static void F1(string s) { }
    static void F2(string? s) { }
    static void F3(object o) { }
    static void F4(object? o) { }
    static void F<T>(D<T> d) { }
    static void Main()
    {
        F<string>(F1);
        F<string>(F2);
        F<string>(F3);
        F<string>(F4);
        F<string?>(F1); // warning
        F<string?>(F2);
        F<string?>(F3); // warning
        F<string?>(F4);
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (15,20): warning CS8622: Nullability of reference types in type of parameter 's' of 'void C.F1(string s)' doesn't match the target delegate 'D<string?>'.
                //         F<string?>(F1); // warning
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F1").WithArguments("s", "void C.F1(string s)", "D<string?>").WithLocation(15, 20),
                // (17,20): warning CS8622: Nullability of reference types in type of parameter 'o' of 'void C.F3(object o)' doesn't match the target delegate 'D<string?>'.
                //         F<string?>(F3); // warning
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInParameterTypeOfTargetDelegate, "F3").WithArguments("o", "void C.F3(object o)", "D<string?>").WithLocation(17, 20));
        }

        [Fact]
        public void Contravariance_Delegate()
        {
            var source =
@"delegate T D<out T>();
class C
{
    static string F1() => string.Empty;
    static string? F2() => string.Empty;
    static object F3() => string.Empty;
    static object? F4() => string.Empty;
    static T F<T>(D<T> d) => d();
    static void Main()
    {
        F<object>(F1);
        F<object>(F2); // warning
        F<object>(F3);
        F<object>(F4); // warning
        F<object?>(F1);
        F<object?>(F2);
        F<object?>(F3);
        F<object?>(F4);
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (12,19): warning CS8621: Nullability of reference types in return type of 'string? C.F2()' doesn't match the target delegate 'D<object>'.
                //         F<object>(F2); // warning
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F2").WithArguments("string? C.F2()", "D<object>").WithLocation(12, 19),
                // (14,19): warning CS8621: Nullability of reference types in return type of 'object? C.F4()' doesn't match the target delegate 'D<object>'.
                //         F<object>(F4); // warning
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOfTargetDelegate, "F4").WithArguments("object? C.F4()", "D<object>").WithLocation(14, 19));
        }

        [Fact]
        public void TypeArgumentInference_01()
        {
            string source = @"
class C 
{
    void Main() {}

    T M1<T>(T? x) where T: class {throw new System.NotImplementedException();}

    void Test1(string? x1)
    {
        M1(x1).ToString();
    }

    void Test2(string?[] x2)
    {
        M1(x2)[0].ToString();
    }

    void Test3(CL0<string?>? x3)
    {
        M1(x3).P1.ToString();
    }

    void Test11(string? x11)
    {
        M1<string?>(x11).ToString();
    }

    void Test12(string?[] x12)
    {
        M1<string?[]>(x12)[0].ToString();
    }

    void Test13(CL0<string?>? x13)
    {
        M1<CL0<string?>?>(x13).P1.ToString();
    }
}

class CL0<T>
{
    public T P1 {get;set;}
}
";

            CSharpCompilation c = CreateCompilation(new[] { source },
                                                                parseOptions: TestOptions.Regular8,
                                                                options: WithNonNullTypesTrue());

            c.VerifyDiagnostics(
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         M1(x2)[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(x2)[0]").WithLocation(15, 9),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         M1(x3).P1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(x3).P1").WithLocation(20, 9),
                // (25,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.M1<T>(T?)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         M1<string?>(x11).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<string?>").WithArguments("C.M1<T>(T?)", "T", "string?").WithLocation(25, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         M1<string?>(x11).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1<string?>(x11)").WithLocation(25, 9),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         M1<string?[]>(x12)[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1<string?[]>(x12)[0]").WithLocation(30, 9),
                // (35,9): warning CS8634: The type 'CL0<string?>?' cannot be used as type parameter 'T' in the generic type or method 'C.M1<T>(T?)'. Nullability of type argument 'CL0<string?>?' doesn't match 'class' constraint.
                //         M1<CL0<string?>?>(x13).P1.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<CL0<string?>?>").WithArguments("C.M1<T>(T?)", "T", "CL0<string?>?").WithLocation(35, 9),
                // (35,9): warning CS8602: Possible dereference of a null reference.
                //         M1<CL0<string?>?>(x13).P1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1<CL0<string?>?>(x13)").WithLocation(35, 9),
                // (35,9): warning CS8602: Possible dereference of a null reference.
                //         M1<CL0<string?>?>(x13).P1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1<CL0<string?>?>(x13).P1").WithLocation(35, 9),
                // (39,7): warning CS8618: Non-nullable property 'P1' is uninitialized.
                // class CL0<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "CL0").WithArguments("property", "P1").WithLocation(39, 7)
                );
        }

        [Fact]
        public void ExplicitImplementations_LazyMethodChecks()
        {
            var source =
@"interface I
{
    void M<T>(T? x) where T : class;
}
class C : I
{
    void I.M<T>(T? x) { }
}";
            var compilation = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            var method = compilation.GetMember<NamedTypeSymbol>("C").GetMethod("I.M");
            var implementations = method.ExplicitInterfaceImplementations;
            Assert.Equal(new[] { "void I.M<T>(T? x)" }, implementations.SelectAsArray(m => m.ToTestDisplayString()));
        }

        [Fact]
        public void EmptyStructDifferentAssembly()
        {
            var sourceA =
@"using System.Collections;
public struct S
{
    public S(string f, IEnumerable g)
    {
        F = f;
        G = g;
    }
    private string F { get; }
    private IEnumerable G { get; }
}";
            var compA = CreateCompilation(sourceA, parseOptions: TestOptions.Regular7);
            var sourceB =
@"using System.Collections.Generic;
class C
{
    static void Main()
    {
        var c = new List<object>();
        c.Add(new S(string.Empty, new object[0]));
    }
}";
            var compB = CreateCompilation(
                sourceB,
                options: TestOptions.ReleaseExe,
                parseOptions: TestOptions.Regular8,
                references: new[] { compA.EmitToImageReference() });
            CompileAndVerify(compB, expectedOutput: "");
        }

        [Fact]
        public void EmptyStructField()
        {
            var source =
@"#pragma warning disable 8618
class A { }
struct B { }
struct S
{
    public readonly A A;
    public readonly B B;
    public S(B b) : this(null, b)
    {
    }
    public S(A a, B b)
    {
        this.A = a;
        this.B = b;
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (8,26): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     public S(B b) : this(null, b)
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(8, 26));
        }

        [Fact]
        public void WarningOnConversion_Assignment()
        {
            var source =
@"#pragma warning disable 8618
class Person
{
    internal string FirstName { get; set; }
    internal string LastName { get; set; }
    internal string? MiddleName { get; set; }
}
class Program
{
    static void F(Person p)
    {
        p.LastName = null;
        p.LastName = (string)null;
        p.LastName = (string?)null;
        p.LastName = null as string;
        p.LastName = null as string?;
        p.LastName = default(string);
        p.LastName = default;
        p.FirstName = p.MiddleName;
        p.LastName = p.MiddleName ?? null;
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (12,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         p.LastName = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(12, 22),
                // (13,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         p.LastName = (string)null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)null").WithLocation(13, 22),
                // (13,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         p.LastName = (string)null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string)null").WithLocation(13, 22),
                // (14,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         p.LastName = (string?)null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string?)null").WithLocation(14, 22),
                // (15,22): warning CS8601: Possible null reference assignment.
                //         p.LastName = null as string;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "null as string").WithLocation(15, 22),
                // (16,22): warning CS8601: Possible null reference assignment.
                //         p.LastName = null as string?;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "null as string?").WithLocation(16, 22),
                // (16,30): error CS8651: It is not legal to use nullable type 'string?' in an as expression; use the underlying type 'string' instead.
                //         p.LastName = null as string?;
                Diagnostic(ErrorCode.ERR_AsNullableType, "string?").WithArguments("string").WithLocation(16, 30),
                // (17,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         p.LastName = default(string);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(string)").WithLocation(17, 22),
                // (18,22): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         p.LastName = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(18, 22),
                // (19,23): warning CS8601: Possible null reference assignment.
                //         p.FirstName = p.MiddleName;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "p.MiddleName").WithLocation(19, 23),
                // (20,22): warning CS8601: Possible null reference assignment.
                //         p.LastName = p.MiddleName ?? null;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "p.MiddleName ?? null").WithLocation(20, 22)
                );
        }

        [Fact]
        public void WarningOnConversion_Receiver()
        {
            var source =
@"#pragma warning disable 8618
class Person
{
    internal string FirstName { get; set; }
    internal string LastName { get; set; }
    internal string? MiddleName { get; set; }
}
class Program
{
    static void F(Person p)
    {
        ((string)null).F();
        ((string?)null).F();
        (null as string).F();
        (null as string?).F();
        default(string).F();
        ((p != null) ? p.MiddleName : null).F();
        (p.MiddleName ?? null).F();
    }
}
static class Extensions
{
    internal static void F(this string s)
    {
    }
}";

            var comp = CreateCompilationWithMscorlib45(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (15,18): error CS8651: It is not legal to use nullable type 'string?' in an as expression; use the underlying type 'string' instead.
                //         (null as string?).F();
                Diagnostic(ErrorCode.ERR_AsNullableType, "string?").WithArguments("string").WithLocation(15, 18),
                // (12,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((string)null).F();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)null").WithLocation(12, 10),
                // (12,10): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         ((string)null).F();
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string)null").WithLocation(12, 10),
                // (13,10): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         ((string?)null).F();
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string?)null").WithLocation(13, 10),
                // (14,10): warning CS8604: Possible null reference argument for parameter 's' in 'void Extensions.F(string s)'.
                //         (null as string).F();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "null as string").WithArguments("s", "void Extensions.F(string s)").WithLocation(14, 10),
                // (16,9): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         default(string).F();
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(string)").WithLocation(16, 9),
                // (17,11): hidden CS8605: Result of the comparison is possibly always true.
                //         ((p != null) ? p.MiddleName : null).F();
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "p != null").WithLocation(17, 11),
                // (17,10): warning CS8604: Possible null reference argument for parameter 's' in 'void Extensions.F(string s)'.
                //         ((p != null) ? p.MiddleName : null).F();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "(p != null) ? p.MiddleName : null").WithArguments("s", "void Extensions.F(string s)").WithLocation(17, 10),
                // (18,10): warning CS8604: Possible null reference argument for parameter 's' in 'void Extensions.F(string s)'.
                //         (p.MiddleName ?? null).F();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "p.MiddleName ?? null").WithArguments("s", "void Extensions.F(string s)").WithLocation(18, 10)
                );
        }

        [Fact]
        public void WarningOnConversion_Argument()
        {
            var source =
@"#pragma warning disable 8618
class Person
{
    internal string FirstName { get; set; }
    internal string LastName { get; set; }
    internal string? MiddleName { get; set; }
}
class Program
{
    static void F(Person p)
    {
        G(null);
        G((string)null);
        G((string?)null);
        G(null as string);
        G(null as string?);
        G(default(string));
        G(default);
        G((p != null) ? p.MiddleName : null);
        G(p.MiddleName ?? null);
    }
    static void G(string name)
    {
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (16,19): error CS8651: It is not legal to use nullable type 'string?' in an as expression; use the underlying type 'string' instead.
                //         G(null as string?);
                Diagnostic(ErrorCode.ERR_AsNullableType, "string?").WithArguments("string").WithLocation(16, 19),
                // (12,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         G(null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(12, 11),
                // (13,11): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         G((string)null);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)null").WithLocation(13, 11),
                // (13,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         G((string)null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string)null").WithLocation(13, 11),
                // (14,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         G((string?)null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string?)null").WithLocation(14, 11),
                // (15,11): warning CS8604: Possible null reference argument for parameter 'name' in 'void Program.G(string name)'.
                //         G(null as string);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "null as string").WithArguments("name", "void Program.G(string name)").WithLocation(15, 11),
                // (17,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         G(default(string));
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(string)").WithLocation(17, 11),
                // (18,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         G(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(18, 11),
                // (19,12): hidden CS8605: Result of the comparison is possibly always true.
                //         G((p != null) ? p.MiddleName : null);
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "p != null").WithLocation(19, 12),
                // (19,11): warning CS8604: Possible null reference argument for parameter 'name' in 'void Program.G(string name)'.
                //         G((p != null) ? p.MiddleName : null);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "(p != null) ? p.MiddleName : null").WithArguments("name", "void Program.G(string name)").WithLocation(19, 11),
                // (20,11): warning CS8604: Possible null reference argument for parameter 'name' in 'void Program.G(string name)'.
                //         G(p.MiddleName ?? null);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "p.MiddleName ?? null").WithArguments("name", "void Program.G(string name)").WithLocation(20, 11)
                );
        }

        [Fact]
        public void WarningOnConversion_Return()
        {
            var source =
@"#pragma warning disable 8618
class Person
{
    internal string FirstName { get; set; }
    internal string LastName { get; set; }
    internal string? MiddleName { get; set; }
}
class Program
{
    static string F1() => null;
    static string F2() => (string)null;
    static string F3() => (string?)null;
    static string F4() => null as string;
    static string F5() => null as string?;
    static string F6() => default(string);
    static string F7() => default;
    static string F8(Person p) => (p != null) ? p.MiddleName : null;
    static string F9(Person p) => p.MiddleName ?? null;
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (10,27): warning CS8603: Possible null reference return.
                //     static string F1() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(10, 27),
                // (11,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static string F2() => (string)null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(string)null").WithLocation(11, 27),
                // (11,27): warning CS8603: Possible null reference return.
                //     static string F2() => (string)null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(string)null").WithLocation(11, 27),
                // (12,27): warning CS8603: Possible null reference return.
                //     static string F3() => (string?)null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(string?)null").WithLocation(12, 27),
                // (13,27): warning CS8603: Possible null reference return.
                //     static string F4() => null as string;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null as string").WithLocation(13, 27),
                // (14,35): error CS8651: It is not legal to use nullable type 'string?' in an as expression; use the underlying type 'string' instead.
                //     static string F5() => null as string?;
                Diagnostic(ErrorCode.ERR_AsNullableType, "string?").WithArguments("string").WithLocation(14, 35),
                // (14,27): warning CS8603: Possible null reference return.
                //     static string F5() => null as string?;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null as string?").WithLocation(14, 27),
                // (15,27): warning CS8603: Possible null reference return.
                //     static string F6() => default(string);
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(string)").WithLocation(15, 27),
                // (16,27): warning CS8603: Possible null reference return.
                //     static string F7() => default;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(16, 27),
                // (17,36): hidden CS8605: Result of the comparison is possibly always true.
                //     static string F8(Person p) => (p != null) ? p.MiddleName : null;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "p != null").WithLocation(17, 36),
                // (17,35): warning CS8603: Possible null reference return.
                //     static string F8(Person p) => (p != null) ? p.MiddleName : null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(p != null) ? p.MiddleName : null").WithLocation(17, 35),
                // (18,35): warning CS8603: Possible null reference return.
                //     static string F9(Person p) => p.MiddleName ?? null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "p.MiddleName ?? null").WithLocation(18, 35)
                );
        }

        [Fact]
        public void SuppressNullableWarning()
        {
            var source =
@"class C
{
    static void F(string? s) // 1
    {
        G(null!); // 2, 3
        G((null as string)!); // 4, 5
        G(default(string)!); // 6, 7
        G(default!); // 8, 9, 10
        G(s!); // 11, 12
    }
    static void G(string s)
    {
    }
}";

            var comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular7, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(
                // (5,11): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         G(null!); // 2, 3
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "null!").WithArguments("nullable reference types").WithLocation(5, 11),
                // (6,11): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         G((null as string)!); // 4, 5
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "(null as string)!").WithArguments("nullable reference types").WithLocation(6, 11),
                // (7,11): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         G(default(string)!); // 6, 7
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "default(string)!").WithArguments("nullable reference types").WithLocation(7, 11),
                // (8,11): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         G(default!); // 8, 9, 10
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "default!").WithArguments("nullable reference types").WithLocation(8, 11),
                // (8,11): error CS8107: Feature 'default literal' is not available in C# 7.0. Please use language version 7.1 or greater.
                //         G(default!); // 8, 9, 10
                Diagnostic(ErrorCode.ERR_FeatureNotAvailableInVersion7, "default").WithArguments("default literal", "7.1").WithLocation(8, 11),
                // (9,11): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         G(s!); // 11, 12
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "s!").WithArguments("nullable reference types").WithLocation(9, 11),
                // (3,25): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //     static void F(string? s) // 1
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(3, 25)
                );

            comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressNullableWarning_ReferenceType()
        {
            var source =
@"class C
{
    static C F(C? o)
    {
        C other;
        other = o!;
        o = other;
        o!.F();
        G(o!);
        return o!;
    }
    void F() { }
    static void G(C o) { }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_Array()
        {
            var source =
@"class C
{
    static object[] F(object?[] o)
    {
        object[] other;
        other = o!;
        o = other!;
        o!.F();
        G(o!);
        return o!;
    }
    static void G(object[] o) { }
}
static class E
{
    internal static void F(this object[] o) { }
}";
            var comp = CreateCompilationWithMscorlib45(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_ConstructedType()
        {
            var source =
@"class C
{
    static C<object> F(C<object?> o)
    {
        C<object> other;
        other = o!; // 1
        o = other!; // 2
        o!.F();
        G(o!); // 3
        return o!; // 4
    }
    static void G(C<object> o) { }
}
class C<T>
{
    internal void F() { }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29902, "https://github.com/dotnet/roslyn/issues/29902")]
        public void SuppressNullableWarning_Multiple()
        {
            var source =
@"class C
{
    static void F(string? s)
    {
        G(default!!);
        G(s!!);
        G((s!)!);
    }
    static void G(string s)
    {
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressNullableWarning_Nested()
        {
            var source =
@"class C<T> where T : class
{
    static T? F(T t) => t;
    static T? G(T t) => t;
    static void M(T? t)
    {
        F(G(t!));
        F(G(t)!);
        F(G(t!)!);
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (7,11): warning CS8604: Possible null reference argument for parameter 't' in 'T? C<T>.F(T t)'.
                //         F(G(t!));
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "G(t!)").WithArguments("t", "T? C<T>.F(T t)").WithLocation(7, 11),
                // (8,13): warning CS8604: Possible null reference argument for parameter 't' in 'T? C<T>.G(T t)'.
                //         F(G(t)!);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "t").WithArguments("t", "T? C<T>.G(T t)").WithLocation(8, 13));
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_Conditional()
        {
            var source =
@"class C<T> { }
class C
{
    static void F(C<object>? x, C<object?> y, bool c)
    {
        C<object> a;
        a = c ? x : y; // 1
        a = c ? y : x; // 2
        a = c ? x : y!; // 3
        a = c ? x! : y; // 4
        a = c ? x! : y!;
        C<object?> b;
        b = c ? x : y; // 5
        b = c ? x : y!; // 6
        b = c ? x! : y; // 7
        b = c ? x! : y!; // 8
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         a = c ? x : y; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c ? x : y").WithLocation(7, 13),
                // (7,21): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         a = c ? x : y; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(7, 21),
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         a = c ? y : x; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c ? y : x").WithLocation(8, 13),
                // (8,17): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         a = c ? y : x; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(8, 17),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         a = c ? x : y!; // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c ? x : y!").WithLocation(9, 13),
                // (10,22): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         a = c ? x! : y; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(10, 22),
                // (13,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         b = c ? x : y; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c ? x : y").WithLocation(13, 13),
                // (13,13): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         b = c ? x : y; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c ? x : y").WithArguments("C<object>", "C<object?>").WithLocation(13, 13),
                // (13,21): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         b = c ? x : y; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(13, 21),
                // (14,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         b = c ? x : y!; // 6
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c ? x : y!").WithLocation(14, 13),
                // (14,13): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         b = c ? x : y!; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c ? x : y!").WithArguments("C<object>", "C<object?>").WithLocation(14, 13),
                // (15,13): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         b = c ? x! : y; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c ? x! : y").WithArguments("C<object>", "C<object?>").WithLocation(15, 13),
                // (15,22): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         b = c ? x! : y; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(15, 22),
                // (16,13): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         b = c ? x! : y!; // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c ? x! : y!").WithArguments("C<object>", "C<object?>").WithLocation(16, 13)
                );
        }

        [Fact]
        public void SuppressNullableWarning_NullCoalescing()
        {
            var source =
@"
class C<T>
{
    static void F(C<object>? x, C<object?> y)
    {
        var t1 = x ?? y; // 1
        var t2 = y ?? x; // 2 and 3
        var t3 = x! ?? y; // 4 and 5
        var t4 = y! ?? x; // 6 and 7
        var t5 = x ?? y!;
        var t6 = y ?? x!; // 8
        var t7 = x! ?? y!;
        var t8 = y! ?? x!;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,23): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         var t1 = x ?? y; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(6, 23),
                // (7,18): hidden CS8607: Expression is probably never null.
                //         var t2 = y ?? x; // 2 and 3
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(7, 18),
                // (7,23): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         var t2 = y ?? x; // 2 and 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object>", "C<object?>").WithLocation(7, 23),
                // (8,18): hidden CS8607: Expression is probably never null.
                //         var t3 = x! ?? y; // 4 and 5
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x").WithLocation(8, 18),
                // (8,24): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         var t3 = x! ?? y; // 4 and 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(8, 24),
                // (9,18): hidden CS8607: Expression is probably never null.
                //         var t4 = y! ?? x; // 6 and 7
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(9, 18),
                // (9,24): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         var t4 = y! ?? x; // 6 and 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object>", "C<object?>").WithLocation(9, 24),
                // (11,18): hidden CS8607: Expression is probably never null.
                //         var t6 = y ?? x!; // 8
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(11, 18),
                // (12,18): hidden CS8607: Expression is probably never null.
                //         var t7 = x! ?? y!;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x").WithLocation(12, 18),
                // (13,18): hidden CS8607: Expression is probably never null.
                //         var t8 = y! ?? x!;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y").WithLocation(13, 18)
                );
        }

        [Fact, WorkItem(30151, "https://github.com/dotnet/roslyn/issues/30151")]
        public void SuppressNullableWarning_ArrayInitializer()
        {
            var source =
@"
class C<T>
{
    static void F(C<object>? x, C<object?> y)
    {
        var a1 = new[] { x, y }; // 1
        _ = a1 /*T:C<object!>?[]!*/;
        var a2 = new[] { x!, y }; // 2
        _ = a2 /*T:C<object!>![]!*/;
        var a3 = new[] { x, y! };
        _ = a3 /*T:C<object!>?[]!*/;
        var a4 = new[] { x!, y! };
        _ = a4 /*T:C<object!>![]!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (6,29): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         var a1 = new[] { x, y }; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(6, 29),
                // (8,30): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         var a2 = new[] { x!, y }; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(8, 30)
                );
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_LocalDeclaration()
        {
            var source =
@"
class C<T>
{
    static void F(C<object>? x, C<object?> y)
    {
        C<object>? c1 = y; // 1
        C<object?> c2 = x; // 2 and 3
        C<object>? c3 = y!; // 4
        C<object?> c4 = x!; // 5
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,25): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         C<object>? c1 = y; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(6, 25),
                // (7,25): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         C<object?> c2 = x; // 2 and 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 25),
                // (7,25): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         C<object?> c2 = x; // 2 and 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object>", "C<object?>").WithLocation(7, 25)
                );
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_Cast()
        {
            var source =
@"
class C<T>
{
    static void F(C<object>? x, C<object?> y)
    {
        var c1 = (C<object>?)y;
        var c2 = (C<object?>)x; // warn
        var c3 = (C<object>?)y!;
        var c4 = (C<object?>)x!;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,18): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         var c1 = (C<object>?)y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(C<object>?)y").WithArguments("C<object?>", "C<object>").WithLocation(6, 18),
                // (7,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var c2 = (C<object?>)x; // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C<object?>)x").WithLocation(7, 18),
                // (7,18): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         var c2 = (C<object?>)x; // warn
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(C<object?>)x").WithArguments("C<object>", "C<object?>").WithLocation(7, 18)
                );
        }

        [Fact]
        public void SuppressNullableWarning_ObjectInitializer()
        {
            var source =
@"
class C<T>
{
    public C<object>? X = null!;
    public C<object?> Y = null!;
    static void F(C<object>? x, C<object?> y)
    {
        _ = new C<int>() { X = y, Y = x };
        _ = new C<int>() { X = y!, Y = x! };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,32): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         _ = new C<int>() { X = y, Y = x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(8, 32),
                // (8,39): warning CS8601: Possible null reference assignment.
                //         _ = new C<int>() { X = y, Y = x };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x").WithLocation(8, 39),
                // (8,39): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         _ = new C<int>() { X = y, Y = x };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object>", "C<object?>").WithLocation(8, 39),
                // (9,32): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         _ = new C<int>() { X = y!, Y = x! };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "C<object>").WithLocation(9, 32),
                // (9,40): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         _ = new C<int>() { X = y!, Y = x! };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object>", "C<object?>").WithLocation(9, 40)
                );
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_CollectionInitializer()
        {
            var source =
@"
using System.Collections;
class C<T> : IEnumerable
{
    IEnumerator IEnumerable.GetEnumerator() => throw null;
    void Add(C<object?> key, params C<object?>[] value) => throw null;
    static void F(C<object>? x)
    {
        _ = new C<int>() { x, x }; // warn 1 and 2
        _ = new C<int>() { x!, x! }; // warn 3 and 4
    }
}
class D<T> : IEnumerable
{
    IEnumerator IEnumerable.GetEnumerator() => throw null;
    void Add(D<object>? key, params D<object>?[] value) => throw null;
    static void F(D<object?> y)
    {
        _ = new D<int>() { y,  y }; // warn 5 and 6 
        _ = new D<int>() { y!,  y! }; // warn 7 and 8
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,28): warning CS8620: Nullability of reference types in argument of type 'D<object?>' doesn't match target type 'D<object>' for parameter 'key' in 'void D<int>.Add(D<object>? key, params D<object>?[] value)'.
                //         _ = new D<int>() { y,  y }; // warn 5 and 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("D<object?>", "D<object>", "key", "void D<int>.Add(D<object>? key, params D<object>?[] value)").WithLocation(19, 28),
                // (19,32): warning CS8620: Nullability of reference types in argument of type 'D<object?>' doesn't match target type 'D<object>' for parameter 'key' in 'void D<int>.Add(D<object>? key, params D<object>?[] value)'.
                //         _ = new D<int>() { y,  y }; // warn 5 and 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("D<object?>", "D<object>", "key", "void D<int>.Add(D<object>? key, params D<object>?[] value)").WithLocation(19, 32),
                // (9,28): warning CS8604: Possible null reference argument for parameter 'key' in 'void C<int>.Add(C<object?> key, params C<object?>[] value)'.
                //         _ = new C<int>() { x, x }; // warn 1 and 2
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("key", "void C<int>.Add(C<object?> key, params C<object?>[] value)").WithLocation(9, 28),
                // (9,28): warning CS8620: Nullability of reference types in argument of type 'C<object>' doesn't match target type 'C<object?>' for parameter 'key' in 'void C<int>.Add(C<object?> key, params C<object?>[] value)'.
                //         _ = new C<int>() { x, x }; // warn 1 and 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("C<object>", "C<object?>", "key", "void C<int>.Add(C<object?> key, params C<object?>[] value)").WithLocation(9, 28),
                // (9,31): warning CS8604: Possible null reference argument for parameter 'key' in 'void C<int>.Add(C<object?> key, params C<object?>[] value)'.
                //         _ = new C<int>() { x, x }; // warn 1 and 2
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("key", "void C<int>.Add(C<object?> key, params C<object?>[] value)").WithLocation(9, 31),
                // (9,31): warning CS8620: Nullability of reference types in argument of type 'C<object>' doesn't match target type 'C<object?>' for parameter 'key' in 'void C<int>.Add(C<object?> key, params C<object?>[] value)'.
                //         _ = new C<int>() { x, x }; // warn 1 and 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("C<object>", "C<object?>", "key", "void C<int>.Add(C<object?> key, params C<object?>[] value)").WithLocation(9, 31)
                );
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_IdentityConversion()
        {
            var source =
@"class C<T> { }
class C
{
    static void F(C<object?> x, C<object> y)
    {
        C<object> a;
        a = x; // 1
        a = x!; // 2
        C<object?> b;
        b = y; // 3
        b = y!; // 4
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (7,13): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         a = x; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object?>", "C<object>").WithLocation(7, 13),
                // (10,13): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         b = y; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object>", "C<object?>").WithLocation(10, 13)
                );
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_ImplicitConversion()
        {
            var source =
@"interface I<T> { }
class C<T> : I<T> { }
class C
{
    static void F(C<object?> x, C<object> y)
    {
        I<object> a;
        a = x;
        a = x!;
        I<object?> b;
        b = y;
        b = y!;
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (8,13): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'I<object>'.
                //         a = x;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("C<object?>", "I<object>").WithLocation(8, 13),
                // (11,13): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'I<object?>'.
                //         b = y;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object>", "I<object?>").WithLocation(11, 13)
                );
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_ImplicitExtensionMethodThisConversion()
        {
            var source =
@"interface I<T> { }
class C<T> : I<T> { }
class C
{
    static void F(C<object?> x, C<object> y)
    {
        x.F1();
        x!.F1();
        y.F2();
        y!.F2();
    }
}
static class E
{
    internal static void F1(this I<object> o) { }
    internal static void F2(this I<object?> o) { }
}";
            var comp = CreateCompilationWithMscorlib45(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (7,9): warning CS8620: Nullability of reference types in argument of type 'C<object?>' doesn't match target type 'I<object>' for parameter 'o' in 'void E.F1(I<object> o)'.
                //         x.F1();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("C<object?>", "I<object>", "o", "void E.F1(I<object> o)").WithLocation(7, 9),
                // (9,9): warning CS8620: Nullability of reference types in argument of type 'C<object>' doesn't match target type 'I<object?>' for parameter 'o' in 'void E.F2(I<object?> o)'.
                //         y.F2();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("C<object>", "I<object?>", "o", "void E.F2(I<object?> o)").WithLocation(9, 9)
                );
        }

        [Fact]
        public void SuppressNullableWarning_ImplicitUserDefinedConversion()
        {
            var source =
@"class A<T> { }
class B<T>
{
    public static implicit operator A<T>(B<T> b) => new A<T>();
}
class C
{
    static void F(B<object?> b1, B<object> b2)
    {
        A<object> a1;
        a1 = b1; // 1
        a1 = b1!; // 2
        A<object?> a2;
        a2 = b2; // 3
        a2 = b2!; // 4
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (11,14): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'A<object>'.
                //         a1 = b1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b1").WithArguments("A<object?>", "A<object>").WithLocation(11, 14),
                // (14,14): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'A<object?>'.
                //         a2 = b2; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b2").WithArguments("A<object>", "A<object?>").WithLocation(14, 14)
                );
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_ExplicitConversion()
        {
            var source =
@"interface I<T> { }
class C<T> { }
class C
{
    static void F(C<object?> x, C<object> y)
    {
        I<object> a;
        a = (I<object?>)x; // 1
        a = ((I<object?>)x)!; // 2
        I<object?> b;
        b = (I<object>)y; // 3
        b = ((I<object>)y)!; // 4
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (8,13): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'I<object>'.
                //         a = (I<object?>)x; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(I<object?>)x").WithArguments("I<object?>", "I<object>").WithLocation(8, 13),
                // (11,13): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'I<object?>'.
                //         b = (I<object>)y; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(I<object>)y").WithArguments("I<object>", "I<object?>").WithLocation(11, 13)
                );
        }

        [Fact]
        public void SuppressNullableWarning_Ref()
        {
            var source =
@"class C
{
    static void F(ref string s, ref string? t)
    {
    }
    static void Main()
    {
        string? s = null;
        string t = """";
        F(ref s, ref t);
        F(ref s!, ref t!);
    }
}";
            var comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular8,
                options: WithNonNullTypesTrue(TestOptions.ReleaseExe));
            comp.VerifyDiagnostics(
                // (10,15): warning CS8604: Possible null reference argument for parameter 's' in 'void C.F(ref string s, ref string? t)'.
                //         F(ref s, ref t);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "s").WithArguments("s", "void C.F(ref string s, ref string? t)").WithLocation(10, 15),
                // (10,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F(ref s, ref t);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(10, 22));
        }

        [Fact]
        public void SuppressNullableWarning_Ref_WithNestedDifferences()
        {
            var source =
@"
class List<T> { }
class C
{
    static void F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)
    {
    }
    static void F1(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)
    {
        F(ref b, ref c, ref d, ref a); // warn 1, 2, 3 and 4
    }
    static void F2(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)
    {
        F(ref b!, ref c!, ref d!, ref a!); // warn 5 and 6
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (10,15): warning CS8604: Possible null reference argument for parameter 'a' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b, ref c, ref d, ref a); // warn 1, 2, 3 and 4
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b").WithArguments("a", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(10, 15),
                // (10,22): warning CS8601: Possible null reference assignment.
                //         F(ref b, ref c, ref d, ref a); // warn 1, 2, 3 and 4
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "c").WithLocation(10, 22),
                // (10,29): warning CS8604: Possible null reference argument for parameter 'c' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b, ref c, ref d, ref a); // warn 1, 2, 3 and 4
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "d").WithArguments("c", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(10, 29),
                // (10,36): warning CS8601: Possible null reference assignment.
                //         F(ref b, ref c, ref d, ref a); // warn 1, 2, 3 and 4
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "a").WithLocation(10, 36),
                // (14,23): warning CS8620: Nullability of reference types in argument of type 'List<string?>' doesn't match target type 'List<string>' for parameter 'b' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b!, ref c!, ref d!, ref a!); // warn 5 and 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "c").WithArguments("List<string?>", "List<string>", "b", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(14, 23),
                // (14,39): warning CS8620: Nullability of reference types in argument of type 'List<string>' doesn't match target type 'List<string?>' for parameter 'd' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b!, ref c!, ref d!, ref a!); // warn 5 and 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "a").WithArguments("List<string>", "List<string?>", "d", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(14, 39)
                );
        }

        [Fact]
        public void SuppressNullableWarning_Ref_WithUnassignedLocals()
        {
            var source =
@"
class List<T> { }
class C
{
    static void F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)
    {
        throw null;
    }
    static void F1()
    {
        List<string> a;
        List<string>? b;
        List<string?> c;
        List<string?>? d;
        F(ref b, ref c, ref d, ref a);
    }
    static void F2()
    {
        List<string> a;
        List<string>? b;
        List<string?> c;
        List<string?>? d;
        F(ref b!, ref c!, ref d!, ref a!);
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (15,15): error CS0165: Use of unassigned local variable 'b'
                //         F(ref b, ref c, ref d, ref a);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "b").WithArguments("b").WithLocation(15, 15),
                // (15,22): error CS0165: Use of unassigned local variable 'c'
                //         F(ref b, ref c, ref d, ref a);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "c").WithArguments("c").WithLocation(15, 22),
                // (15,29): error CS0165: Use of unassigned local variable 'd'
                //         F(ref b, ref c, ref d, ref a);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "d").WithArguments("d").WithLocation(15, 29),
                // (15,36): error CS0165: Use of unassigned local variable 'a'
                //         F(ref b, ref c, ref d, ref a);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "a").WithArguments("a").WithLocation(15, 36),
                // (15,22): warning CS8620: Nullability of reference types in argument of type 'List<string?>' doesn't match target type 'List<string>' for parameter 'b' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b, ref c, ref d, ref a);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "c").WithArguments("List<string?>", "List<string>", "b", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(15, 22),
                // (15,36): warning CS8620: Nullability of reference types in argument of type 'List<string>' doesn't match target type 'List<string?>' for parameter 'd' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b, ref c, ref d, ref a);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "a").WithArguments("List<string>", "List<string?>", "d", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(15, 36),
                // (23,15): error CS0165: Use of unassigned local variable 'b'
                //         F(ref b!, ref c!, ref d!, ref a!);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "b").WithArguments("b").WithLocation(23, 15),
                // (23,23): error CS0165: Use of unassigned local variable 'c'
                //         F(ref b!, ref c!, ref d!, ref a!);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "c").WithArguments("c").WithLocation(23, 23),
                // (23,31): error CS0165: Use of unassigned local variable 'd'
                //         F(ref b!, ref c!, ref d!, ref a!);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "d").WithArguments("d").WithLocation(23, 31),
                // (23,39): error CS0165: Use of unassigned local variable 'a'
                //         F(ref b!, ref c!, ref d!, ref a!);
                Diagnostic(ErrorCode.ERR_UseDefViolation, "a").WithArguments("a").WithLocation(23, 39),
                // (23,23): warning CS8620: Nullability of reference types in argument of type 'List<string?>' doesn't match target type 'List<string>' for parameter 'b' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b!, ref c!, ref d!, ref a!);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "c").WithArguments("List<string?>", "List<string>", "b", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(23, 23),
                // (23,39): warning CS8620: Nullability of reference types in argument of type 'List<string>' doesn't match target type 'List<string?>' for parameter 'd' in 'void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)'.
                //         F(ref b!, ref c!, ref d!, ref a!);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "a").WithArguments("List<string>", "List<string?>", "d", "void C.F(ref List<string> a, ref List<string>? b, ref List<string?> c, ref List<string?>? d)").WithLocation(23, 39)
                );
        }

        [Fact]
        public void SuppressNullableWarning_Out_WithNestedDifferences()
        {
            var source =
@"
class List<T> { }
class C
{
    static void F(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)
    {
        throw null;
    }
    static void F1(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)
    {
        F(out b, out c, out d, out a); // warn on `c` and `a`
    }
    static void F2(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)
    {
        F(out b!, out c!, out d!, out a!); // warn on `c!` and `a!`
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (11,22): warning CS8601: Possible null reference assignment.
                //         F(out b, out c, out d, out a); // warn on `c` and `a`
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "c").WithLocation(11, 22),
                // (11,36): warning CS8601: Possible null reference assignment.
                //         F(out b, out c, out d, out a); // warn on `c` and `a`
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "a").WithLocation(11, 36),
                // (15,23): warning CS8620: Nullability of reference types in argument of type 'List<string?>' doesn't match target type 'List<string>' for parameter 'b' in 'void C.F(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)'.
                //         F(out b!, out c!, out d!, out a!); // warn on `c!` and `a!`
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "c").WithArguments("List<string?>", "List<string>", "b", "void C.F(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)").WithLocation(15, 23),
                // (15,39): warning CS8620: Nullability of reference types in argument of type 'List<string>' doesn't match target type 'List<string?>' for parameter 'd' in 'void C.F(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)'.
                //         F(out b!, out c!, out d!, out a!); // warn on `c!` and `a!`
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "a").WithArguments("List<string>", "List<string?>", "d", "void C.F(out List<string> a, out List<string>? b, out List<string?> c, out List<string?>? d)").WithLocation(15, 39)
                );
        }

        [Fact]
        public void SuppressNullableWarning_Out()
        {
            var source =
@"class C
{
    static void F(out string s, out string? t)
    {
        s = string.Empty;
        t = string.Empty;
    }
    static void Main()
    {
        string? s;
        string t;
        F(out s, out t); // warn
        F(out s!, out t!); // ok
        F(out (s!), out (t!)); // errors
        F(out (s)!, out (t)!); // errors
    }
}";
            var comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular8,
                options: WithNonNullTypesTrue(TestOptions.ReleaseExe));
            comp.VerifyDiagnostics(
                // (15,19): error CS1525: Invalid expression term ','
                //         F(out (s)!, out (t)!); // errors
                Diagnostic(ErrorCode.ERR_InvalidExprTerm, ",").WithArguments(",").WithLocation(15, 19),
                // (15,29): error CS1525: Invalid expression term ')'
                //         F(out (s)!, out (t)!); // errors
                Diagnostic(ErrorCode.ERR_InvalidExprTerm, ")").WithArguments(")").WithLocation(15, 29),
                // (15,16): error CS0118: 's' is a variable but is used like a type
                //         F(out (s)!, out (t)!); // errors
                Diagnostic(ErrorCode.ERR_BadSKknown, "s").WithArguments("s", "variable", "type").WithLocation(15, 16),
                // (15,26): error CS0118: 't' is a variable but is used like a type
                //         F(out (s)!, out (t)!); // errors
                Diagnostic(ErrorCode.ERR_BadSKknown, "t").WithArguments("t", "variable", "type").WithLocation(15, 26),
                // (12,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F(out s, out t); // warn
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(12, 22)
                );
        }

        [Fact]
        [WorkItem(29903, "https://github.com/dotnet/roslyn/issues/29903")]
        public void SuppressNullableWarning_Assignment()
        {
            var source =
@"class C
{
    static void Main()
    {
        string? s = null;
        string t = string.Empty;
        t! = s;
        t! += s;
        (t!) = s;
    }
}";
            var comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular8,
                options: WithNonNullTypesTrue(TestOptions.ReleaseExe));
            comp.VerifyDiagnostics(
                // (7,9): error CS8598: The suppression operator is not allowed in this context
                //         t! = s;
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "t").WithLocation(7, 9),
                // (8,9): error CS8598: The suppression operator is not allowed in this context
                //         t! += s;
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "t").WithLocation(8, 9),
                // (9,10): error CS8598: The suppression operator is not allowed in this context
                //         (t!) = s;
                Diagnostic(ErrorCode.ERR_IllegalSuppression, "t").WithLocation(9, 10)
                );
        }

        [Fact]
        public void SuppressNullableWarning_Conversion()
        {
            var source =
@"class A
{
    public static implicit operator B(A a) => new B();
}
class B
{
}
class C
{
    static void F(A? a)
    {
        G((B)a);
        G((B)a!);
    }
    static void G(B b)
    {
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (12,14): warning CS8604: Possible null reference argument for parameter 'a' in 'A.implicit operator B(A a)'.
                //         G((B)a);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a").WithArguments("a", "A.implicit operator B(A a)").WithLocation(12, 14));
        }

        [Fact]
        [WorkItem(29906, "https://github.com/dotnet/roslyn/issues/29906")]
        public void SuppressNullableWarning_Condition()
        {
            var source =
@"class C
{
    static object? F(bool b)
    {
        return (b && G(out var o))! ? o : null;
    }
    static bool G(out object o)
    {
        o = new object();
        return true;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressNullableWarning_ValueType_01()
        {
            var source =
@"struct S
{
    static void F()
    {
        G(1!);
        G(((int?)null)!);
        G(default(S)!);
        _ = new S2<object>()!;
    }
    static void G(object o)
    {
    }
    static void G<T>(T? t) where T : struct
    {
    }
}
struct S2<T>
{
}";

            // Feature enabled.
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            // Feature disabled.
            comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            // Feature disabled (C# 7).
            comp = CreateCompilation(
                new[] { source },
                parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics(
                // (5,11): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         G(1!);
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "1!").WithArguments("nullable reference types").WithLocation(5, 11),
                // (6,11): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         G(((int?)null)!);
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "((int?)null)!").WithArguments("nullable reference types").WithLocation(6, 11),
                // (7,11): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         G(default(S)!);
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "default(S)!").WithArguments("nullable reference types").WithLocation(7, 11),
                // (8,13): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = new S2<object>()!;
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "new S2<object>()!").WithArguments("nullable reference types").WithLocation(8, 13));
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_ValueType_02()
        {
            var source =
@"struct S<T> where T : class
{
    static S<object> F(S<object?> s) => s /*T:S<object?>*/ !;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_UserDefinedConversion()
        {
            var source = @"
struct S
{
    public static implicit operator C?(S s) => new C();
}
class C
{
    void M()
    {
        C c = new S()!;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact, WorkItem(29642, "https://github.com/dotnet/roslyn/issues/29642")]
        public void SuppressNullableWarning_UserDefinedConversion_InArrayInitializer()
        {
            var source = @"
struct S
{
    public static implicit operator C?(S s) => new C();
}
class C
{
    void M(C c)
    {
        var a = new[] { c, new S()! };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressNullableWarning_GenericType()
        {
            var source =
@"struct S
{
    static void F<TStruct, TRef, TUnconstrained>(TStruct tStruct, TRef tRef, TUnconstrained tUnconstrained)
        where TStruct : struct where TRef : class
    {
        _ = tStruct!;
        _ = tRef!;
        _ = tUnconstrained!;
    }
}";

            // Feature enabled.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            // Feature disabled.
            comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();

            // Feature disabled (C# 7).
            comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics(
                // (6,13): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = tStruct!;
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "tStruct!").WithArguments("nullable reference types").WithLocation(6, 13),
                // (7,13): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = tRef!;
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "tRef!").WithArguments("nullable reference types").WithLocation(7, 13),
                // (8,13): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         _ = tUnconstrained!;
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "tUnconstrained!").WithArguments("nullable reference types").WithLocation(8, 13)
                );
        }

        [Fact]
        public void SuppressNullableWarning_TypeParameters_01()
        {
            var source =
@"class C
{
    static void F1<T1>(T1 t1)
    {
        default(T1).ToString(); // 1
        default(T1)!.ToString();
        t1.ToString(); // 2
        t1!.ToString();
    }
    static void F2<T2>(T2 t2) where T2 : class
    {
        default(T2).ToString(); // 3
        default(T2)!.ToString(); // 4
        t2.ToString();
        t2!.ToString();
    }
    static void F3<T3>(T3 t3) where T3 : struct
    {
        default(T3).ToString();
        default(T3)!.ToString();
        t3.ToString();
        t3!.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         default(T1).ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "default(T1)").WithLocation(5, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         t1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(7, 9),
                // (12,9): warning CS1720: Expression will always cause a System.NullReferenceException because the default value of 'T2' is null
                //         default(T2).ToString(); // 3
                Diagnostic(ErrorCode.WRN_DotOnDefault, "default(T2).ToString").WithArguments("T2").WithLocation(12, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         default(T2).ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "default(T2)").WithLocation(12, 9),
                // (13,9): warning CS1720: Expression will always cause a System.NullReferenceException because the default value of 'T2' is null
                //         default(T2)!.ToString(); // 4
                Diagnostic(ErrorCode.WRN_DotOnDefault, "default(T2)!.ToString").WithArguments("T2").WithLocation(13, 9)
                );
        }

        [Fact]
        public void SuppressNullableWarning_TypeParameters_02()
        {
            var source =
@"abstract class A<T>
{
    internal abstract void F<U>(out T t, out U u) where U : T;
}
class B1<T> : A<T> where T : class
{
    internal override void F<U>(out T t1, out U u1)
    {
        t1 = default(T)!;
        t1 = default!;
        u1 = default(U)!;
        u1 = default!;
    }
}
class B2<T> : A<T> where T : struct
{
    internal override void F<U>(out T t2, out U u2)
    {
        t2 = default(T)!; // 1
        t2 = default!; // 2
        u2 = default(U)!; // 3
        u2 = default!; // 4
    }
}
class B3<T> : A<T>
{
    internal override void F<U>(out T t3, out U u3)
    {
        t3 = default(T)!;
        t3 = default!;
        u3 = default(U)!;
        u3 = default!;
    }
}
class B4 : A<object>
{
    internal override void F<U>(out object t4, out U u4)
    {
        t4 = default(object)!;
        t4 = default!;
        u4 = default(U)!;
        u4 = default!;
    }
}
class B5 : A<int>
{
    internal override void F<U>(out int t5, out U u5)
    {
        t5 = default(int)!; // 5
        t5 = default!; // 6
        u5 = default(U)!; // 7
        u5 = default!; // 8
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            // https://github.com/dotnet/roslyn/issues/29907: Report error for `default!`.
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressNullableWarning_NonNullOperand()
        {
            var source =
@"class C
{
    static void F(string? s)
    {
        G(""""!);
        G((new string('a', 1))!);
        G((s ?? """")!);
    }
    static void G(string s)
    {
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void SuppressNullableWarning_InvalidOperand()
        {
            var source =
@"class C
{
    static void F(C c)
    {
        G(F!);
        G(c.P!);
    }
    static void G(object o)
    {
    }
    object P { set { } }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,11): error CS1503: Argument 1: cannot convert from 'method group' to 'object'
                //         G(F!);
                Diagnostic(ErrorCode.ERR_BadArgType, "F").WithArguments("1", "method group", "object").WithLocation(5, 11),
                // (6,11): error CS0154: The property or indexer 'C.P' cannot be used in this context because it lacks the get accessor
                //         G(c.P!);
                Diagnostic(ErrorCode.ERR_PropertyLacksGet, "c.P").WithArguments("C.P").WithLocation(6, 11)
                );
        }

        [Fact]
        public void SuppressNullableWarning_InvalidArrayInitializer()
        {
            var source =
@"class C
{
    static void F()
    {
        var a = new object[] { new object(), F! };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,46): error CS0428: Cannot convert method group 'F' to non-delegate type 'object'. Did you intend to invoke the method?
                //         var a = new object[] { new object(), F! };
                Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "F").WithArguments("F", "object").WithLocation(5, 46));
        }

        [Fact, WorkItem(31370, "https://github.com/dotnet/roslyn/issues/31370")]
        public void SuppressNullableWarning_IndexedProperty()
        {
            var source0 =
@"Imports System
Imports System.Runtime.InteropServices
<Assembly: PrimaryInteropAssembly(0, 0)> 
<Assembly: Guid(""165F752D-E9C4-4F7E-B0D0-CDFD7A36E210"")>
<ComImport()>
<Guid(""165F752D-E9C4-4F7E-B0D0-CDFD7A36E211"")>
Public Class A
    Public ReadOnly Property P(i As Integer) As Object
        Get
            Return Nothing
        End Get
    End Property
    Public ReadOnly Property Q(Optional i As Integer = 0) As Object
        Get
            Return Nothing
        End Get
    End Property
End Class";
            var ref0 = BasicCompilationUtils.CompileToMetadata(source0);
            var source =
@"class B
{
    static object F(A a, int i)
    {
        if (i > 0)
        {
            return a.P!;
        }
        return a.Q!;
    }
}";
            var comp = CreateCompilation(
                new[] { source },
                new[] { ref0 },
                parseOptions: TestOptions.Regular8, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,20): error CS0856: Indexed property 'A.P' has non-optional arguments which must be provided
                //             return a.P!;
                Diagnostic(ErrorCode.ERR_IndexedPropertyRequiresParams, "a.P").WithArguments("A.P").WithLocation(7, 20));
        }

        [Fact]
        public void LocalTypeInference()
        {
            var source =
@"class C
{
    static void F(string? s, string? t)
    {
        if (s != null)
        {
            var x = s;
            G(x); // no warning
            x = t;
        }
        else
        {
            var y = s;
            G(y); // warning
            y = t;
        }
    }
    static void G(string s)
    {
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             x = t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(9, 17),
                // (14,15): warning CS8604: Possible null reference argument for parameter 's' in 'void C.G(string s)'.
                //             G(y); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("s", "void C.G(string s)").WithLocation(14, 15));
        }

        [Fact]
        public void AssignmentInCondition_01()
        {
            var source =
@"class C
{
    object P => null;
    static void F(object o)
    {
        C? c;
        while ((c = o as C) != null)
        {
            o = c.P;
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,17): warning CS8603: Possible null reference return.
                //     object P => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(3, 17));
        }

        [Fact]
        public void AssignmentInCondition_02()
        {
            var source =
@"class C
{
    object? P => null;
    static void F(object? o)
    {
        C? c;
        while ((c = o as C) != null)
        {
            o = c.P;
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void StructAsNullableInterface()
        {
            var source =
@"interface I
{
    void F();
}
struct S : I
{
    void I.F()
    {
    }
}
class C
{
    static void F(I? i)
    {
        i.F();
    }
    static void Main()
    {
        F(new S());
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         i.F();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "i").WithLocation(15, 9));
        }

        [Fact]
        public void IsNull()
        {
            var source =
@"class C
{
    static void F1(object o) { }
    static void F2(object o) { }
    static void G(object? o)
    {
        if (o is null)
        {
            F1(o);
        }
        else
        {
            F2(o);
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);

            comp.VerifyDiagnostics(
                // (9,16): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F1(object o)'.
                //             F1(o);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "o").WithArguments("o", "void C.F1(object o)").WithLocation(9, 16));
        }

        [Fact]
        public void IsInvalidConstant()
        {
            var source =
@"class C
{
    static void F(object o) { }
    static void G(object? o)
    {
        if (o is F)
        {
            F(o);
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,18): error CS0428: Cannot convert method group 'F' to non-delegate type 'object'. Did you intend to invoke the method?
                //         if (o is F)
                Diagnostic(ErrorCode.ERR_MethGrpToNonDel, "F").WithArguments("F", "object").WithLocation(6, 18),
                // (8,15): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //             F(o);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "o").WithArguments("o", "void C.F(object o)").WithLocation(8, 15));
        }

        [Fact]
        public void IsPattern_01()
        {
            var source =
@"class C
{
    static void F(object x) { }
    static void G(string s)
    {
        F(s is var o);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29909, "https://github.com/dotnet/roslyn/issues/29909")]
        public void IsPattern_02()
        {
            var source =
@"class C
{
    static void F(string s) { }
    static void G(string? s)
    {
        if (s is string t)
        {
            F(t);
            F(s);
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void IsPattern_AffectsNullConditionalOperator_DeclarationPattern()
        {
            var source =
@"class C
{
    static void G(string? s)
    {
        if (s?.ToString() is string t)
        {
            s.ToString();
        }
        else
        {
            s.ToString(); // warn
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(11, 13)
                );
        }

        [Fact]
        public void IsPattern_AffectsNullConditionalOperator_NullableValueType()
        {
            var source =
@"class C
{
    static void G(int? i)
    {
        if (i?.ToString() is string t)
        {
            i.Value.ToString();
        }
        else
        {
            i.Value.ToString(); // warn
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8629: Nullable value type may be null.
                //             i.Value.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "i.Value").WithLocation(11, 13)
                );
        }

        [Fact]
        public void IsPattern_AffectsNullConditionalOperator_NullableValueType_Nested()
        {
            var source = @"
public struct S
{
    public int? field;
}
class C
{
    static void G(S? s)
    {
        if (s?.field?.ToString() is string t)
        {
            s.Value.ToString();
            s.Value.field.Value.ToString();
        }
        else
        {
            s.Value.ToString(); // warn
            s.Value.field.Value.ToString(); // warn
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,13): warning CS8629: Nullable value type may be null.
                //             s.Value.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s.Value").WithLocation(17, 13),
                // (18,13): warning CS8629: Nullable value type may be null.
                //             s.Value.field.Value.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s.Value.field.Value").WithLocation(18, 13)
                );
        }

        [Fact]
        public void IsPattern_AffectsNullConditionalOperator_VarPattern()
        {
            var source =
@"class C
{
    static void G(string? s)
    {
        if (s?.ToString() is var t)
        {
            s.ToString(); // 1
        }
        else
        {
            s.ToString();
        }
    }
}";
            // Should also warn on unreachable code
            // https://github.com/dotnet/roslyn/issues/28798
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 13)
                );
        }

        [Fact]
        public void IsPattern_AffectsNullConditionalOperator_NullConstantPattern()
        {
            var source =
@"class C
{
    static void G(string? s)
    {
        if (s?.ToString() is null)
        {
            s.ToString(); // warn
        }
        else
        {
            s.ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): warning CS8602: Possible dereference of a null reference.
                //             s.ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(7, 13)
                );
        }

        // https://github.com/dotnet/roslyn/issues/29909: Should only warn on F(x) in `case null`.
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29909")]
        [WorkItem(29909, "https://github.com/dotnet/roslyn/issues/29909")]
        public void PatternSwitch()
        {
            var source =
@"class C
{
    static void F(object o) { }
    static void G(object? x)
    {
        switch (x)
        {
            case string s:
                F(s);
                F(x); // string s
                break;
            case object y when y is string t:
                F(y);
                F(t);
                F(x); // object y
                break;
            case null:
                F(x); // null
                break;
            default:
                F(x); // default
                break;
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (18,19): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //                 F(x); // null
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("o", "void C.F(object o)").WithLocation(18, 19));
        }

        [Fact]
        public void IsDeclarationPattern_01()
        {
            // https://github.com/dotnet/roslyn/issues/30952: `is` declaration does not set not nullable for declared local.
            var source =
@"class Program
{
    static void F1(object x1)
    {
        if (x1 is string y1)
        {
            x1/*T:object!*/.ToString();
            y1/*T:string*/.ToString();
        }
        x1/*T:object!*/.ToString();
    }
    static void F2(object? x2)
    {
        if (x2 is string y2)
        {
            x2/*T:object!*/.ToString();
            y2/*T:string*/.ToString();
        }
        x2/*T:object?*/.ToString(); // 1
    }
    static void F3(object x3)
    {
        x3 = null; // 2
        if (x3 is string y3)
        {
            x3/*T:object!*/.ToString();
            y3/*T:string*/.ToString();
        }
        x3/*T:object?*/.ToString(); // 3
    }
    static void F4(object? x4)
    {
        if (x4 == null) return;
        if (x4 is string y4)
        {
            x4/*T:object!*/.ToString();
            y4/*T:string*/.ToString();
        }
        x4/*T:object!*/.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         x2.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(19, 9),
                // (23,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x3 = null; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(23, 14),
                // (29,9): warning CS8602: Possible dereference of a null reference.
                //         x3.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x3").WithLocation(29, 9));
            comp.VerifyTypes();
        }

        [Fact]
        public void IsDeclarationPattern_02()
        {
            var source =
@"class Program
{
    static void F1<T, U>(T t1)
        where T : class
        where U : class
    {
        if (t1 is U u1)
        {
            t1.ToString();
            u1.ToString();
        }
        t1.ToString();
    }
    static void F2<T, U>(T t2)
        where T : class?
        where U : class
    {
        if (t2 is U u2)
        {
            t2.ToString();
            u2.ToString();
        }
        t2.ToString(); // 1
    }
    static void F3<T, U>(T t3)
        where T : class
        where U : class
    {
        t3 = null; // 2
        if (t3 is U u3)
        {
            t3.ToString();
            u3.ToString();
        }
        t3.ToString(); // 3
    }
    static void F4<T, U>(T t4)
        where T : class?
        where U : class
    {
        if (t4 == null) return;
        if (t4 is U u4)
        {
            t4.ToString();
            u4.ToString();
        }
        t4.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (23,9): warning CS8602: Possible dereference of a null reference.
                //         t2.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2").WithLocation(23, 9),
                // (29,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t3 = null; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(29, 14),
                // (35,9): warning CS8602: Possible dereference of a null reference.
                //         t3.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t3").WithLocation(35, 9));
        }

        [Fact]
        public void IsDeclarationPattern_03()
        {
            var source =
@"class Program
{
    static void F1<T, U>(T t1)
    {
        if (t1 is U u1)
        {
            t1.ToString();
            u1.ToString();
        }
        t1.ToString(); // 1
    }
    static void F2<T, U>(T t2)
    {
        if (t2 == null) return;
        if (t2 is U u2)
        {
            t2.ToString();
            u2.ToString();
        }
        t2.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         t1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(10, 9));
        }

        [Fact]
        public void IsDeclarationPattern_NeverNull_01()
        {
            var source =
@"class Program
{
    static void F1(object x1)
    {
        if (x1 is string y1)
        {
            x1?.ToString(); // 1
            y1?.ToString(); // 2
        }
        x1?.ToString(); // 3
    }
    static void F2(object? x2)
    {
        if (x2 is string y2)
        {
            x2?.ToString(); // 4
            y2?.ToString(); // 5
        }
        x2?.ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/30952: `is` declaration does not set not nullable for declared local.
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): hidden CS8607: Expression is probably never null.
                //             x1?.ToString(); // 1
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(7, 13),
                // (10,9): hidden CS8607: Expression is probably never null.
                //         x1?.ToString(); // 3
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(10, 9),
                // (16,13): hidden CS8607: Expression is probably never null.
                //             x2?.ToString(); // 4
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(16, 13));
        }

        [Fact]
        public void IsDeclarationPattern_NeverNull_02()
        {
            var source =
@"class Program
{
    static void F1<T, U>(T t1)
        where T : class
        where U : class
    {
        if (t1 is U u1)
        {
            t1?.ToString(); // 1
            u1?.ToString(); // 2
        }
        t1?.ToString(); // 3
    }
    static void F2<T, U>(T t2)
        where T : class?
        where U : class
    {
        if (t2 is U u2)
        {
            t2?.ToString(); // 4
            u2?.ToString(); // 5
        }
        t2?.ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/30952: `is` declaration does not set not nullable for declared local.
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): hidden CS8607: Expression is probably never null.
                //             t1?.ToString(); // 1
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "t1").WithLocation(9, 13),
                // (12,9): hidden CS8607: Expression is probably never null.
                //         t1?.ToString(); // 3
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "t1").WithLocation(12, 9),
                // (20,13): hidden CS8607: Expression is probably never null.
                //             t2?.ToString(); // 4
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "t2").WithLocation(20, 13));
        }

        [Fact]
        public void IsDeclarationPattern_Unassigned_01()
        {
            var source =
@"class Program
{
    static void F1(object x1)
    {
        if (x1 is string y1)
        {
        }
        else
        {
            x1.ToString();
            y1.ToString(); // 1
        }
    }
    static void F2(object? x2)
    {
        if (x2 is string y2)
        {
        }
        else
        {
            x2.ToString(); // 2
            y2.ToString(); // 3
        }
    }
    static void F3(object x3)
    {
        x3 = null; // 4
        if (x3 is string y3)
        {
        }
        else
        {
            x3.ToString(); // 5
            y3.ToString(); // 6
        }
    }
    static void F4(object? x4)
    {
        if (x4 == null) return;
        if (x4 is string y4)
        {
        }
        else
        {
            x4.ToString();
            y4.ToString(); // 7
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): error CS0165: Use of unassigned local variable 'y1'
                //             y1.ToString(); // 1
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y1").WithArguments("y1").WithLocation(11, 13),
                // (21,13): warning CS8602: Possible dereference of a null reference.
                //             x2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(21, 13),
                // (22,13): error CS0165: Use of unassigned local variable 'y2'
                //             y2.ToString(); // 3
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y2").WithArguments("y2").WithLocation(22, 13),
                // (27,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x3 = null; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(27, 14),
                // (33,13): warning CS8602: Possible dereference of a null reference.
                //             x3.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x3").WithLocation(33, 13),
                // (34,13): error CS0165: Use of unassigned local variable 'y3'
                //             y3.ToString(); // 6
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y3").WithArguments("y3").WithLocation(34, 13),
                // (46,13): error CS0165: Use of unassigned local variable 'y4'
                //             y4.ToString(); // 7
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y4").WithArguments("y4").WithLocation(46, 13));
        }

        [Fact]
        public void IsDeclarationPattern_Unassigned_02()
        {
            var source =
@"class Program
{
    static void F1(object x1)
    {
        if (x1 is string y1) { }
        x1.ToString();
        y1.ToString(); // 1
    }
    static void F2(object? x2)
    {
        if (x2 is string y2) { }
        x2.ToString(); // 2
        y2.ToString(); // 3
    }
    static void F3(object x3)
    {
        x3 = null; // 4
        if (x3 is string y3) { }
        x3.ToString(); // 5
        y3.ToString(); // 6
    }
    static void F4(object? x4)
    {
        if (x4 == null) return;
        if (x4 is string y4) { }
        x4.ToString();
        y4.ToString(); // 7
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): error CS0165: Use of unassigned local variable 'y1'
                //         y1.ToString(); // 1
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y1").WithArguments("y1").WithLocation(7, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         x2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(12, 9),
                // (13,9): error CS0165: Use of unassigned local variable 'y2'
                //         y2.ToString(); // 3
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y2").WithArguments("y2").WithLocation(13, 9),
                // (17,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x3 = null; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(17, 14),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         x3.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x3").WithLocation(19, 9),
                // (20,9): error CS0165: Use of unassigned local variable 'y3'
                //         y3.ToString(); // 6
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y3").WithArguments("y3").WithLocation(20, 9),
                // (27,9): error CS0165: Use of unassigned local variable 'y4'
                //         y4.ToString(); // 7
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y4").WithArguments("y4").WithLocation(27, 9));
        }

        [Fact]
        public void Feature()
        {
            var source =
@"class C
{
    static object F() => null;
    static object F(object? o) => o;
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8.WithFeature("staticNullChecking"));
            comp.VerifyDiagnostics(
                // (3,26): warning CS8603: Possible null reference return.
                //     static object F() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(3, 26),
                // (4,35): warning CS8603: Possible null reference return.
                //     static object F(object? o) => o;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "o").WithLocation(4, 35));

            comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8.WithFeature("staticNullChecking", "0"));
            comp.VerifyDiagnostics(
                // (3,26): warning CS8603: Possible null reference return.
                //     static object F() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(3, 26),
                // (4,35): warning CS8603: Possible null reference return.
                //     static object F(object? o) => o;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "o").WithLocation(4, 35));

            comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8.WithFeature("staticNullChecking", "1"));
            comp.VerifyDiagnostics(
                // (3,26): warning CS8603: Possible null reference return.
                //     static object F() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(3, 26),
                // (4,35): warning CS8603: Possible null reference return.
                //     static object F(object? o) => o;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "o").WithLocation(4, 35));
        }

        [Fact]
        public void AllowMemberOptOut()
        {
            var source1 =
@"partial class C
{
" + NonNullTypesOff() + @"
    static void F(object o) { }
}";
            var source2 =
@"partial class C
{


    static void G(object o) { }
    static void M(object? o)
    {
        F(o);
        G(o);
    }
}";

            var comp = CreateCompilation(
                new[] { source1, source2 },
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,25): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     static void M(object? o)
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 25)
                );

            comp = CreateCompilation(
                new[] { source1, source2 }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.G(object o)'.
                //         G(o);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "o").WithArguments("o", "void C.G(object o)").WithLocation(9, 11));
        }

        [Fact]
        public void InferLocalNullability()
        {
            var source =
@"class C
{
    static string? F(string s) => s;
    static void G(string s)
    {
        string x;
        x = F(s);
        F(x);
        string? y = s;
        y = F(y);
        F(y);
    }
}";

            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = F(s);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "F(s)").WithLocation(7, 13),
                // (8,11): warning CS8604: Possible null reference argument for parameter 's' in 'string? C.F(string s)'.
                //         F(x);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("s", "string? C.F(string s)").WithLocation(8, 11),
                // (11,11): warning CS8604: Possible null reference argument for parameter 's' in 'string? C.F(string s)'.
                //         F(y);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("s", "string? C.F(string s)").WithLocation(11, 11));

            var tree = comp.SyntaxTrees[0];
            var model = comp.GetSemanticModel(tree);
            var declarator = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().First();
            var symbol = (LocalSymbol)model.GetDeclaredSymbol(declarator);
            Assert.Equal("System.String!", symbol.Type.ToTestDisplayString(true));
        }

        [Fact]
        public void InferLocalType_UsedInDeclaration()
        {
            var source =
@"using System;
using System.Collections.Generic;
class C
{
    static T F<T>(IEnumerable<T> e)
    {
        throw new NotImplementedException();
    }
    static void G()
    {
        var a = new[] { F(a) };
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,27): error CS0841: Cannot use local variable 'a' before it is declared
                //         var a = new[] { F(a) };
                Diagnostic(ErrorCode.ERR_VariableUsedBeforeDeclaration, "a").WithArguments("a").WithLocation(11, 27),
                // (11,27): error CS0165: Use of unassigned local variable 'a'
                //         var a = new[] { F(a) };
                Diagnostic(ErrorCode.ERR_UseDefViolation, "a").WithArguments("a").WithLocation(11, 27));
        }

        [Fact]
        public void InferLocalType_UsedInDeclaration_Script()
        {
            var source =
@"using System;
using System.Collections.Generic;
static T F<T>(IEnumerable<T> e)
{
    throw new NotImplementedException();
}
var a = new[] { F(a) };";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Script.WithLanguageVersion(LanguageVersion.CSharp8));
            comp.VerifyDiagnostics(
                // (7,5): error CS7019: Type of 'a' cannot be inferred since its initializer directly or indirectly refers to the definition.
                // var a = new[] { F(a) };
                Diagnostic(ErrorCode.ERR_RecursivelyTypedVariable, "a").WithArguments("a").WithLocation(7, 5));
        }

        [Fact]
        public void InferLocalType_UsedBeforeDeclaration()
        {
            var source =
@"using System;
using System.Collections.Generic;
class C
{
    static T F<T>(IEnumerable<T> e)
    {
        throw new NotImplementedException();
    }
    static void G()
    {
        var a = new[] { F(b) };
        var b = a;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,27): error CS0841: Cannot use local variable 'b' before it is declared
                //         var a = new[] { F(b) };
                Diagnostic(ErrorCode.ERR_VariableUsedBeforeDeclaration, "b").WithArguments("b").WithLocation(11, 27));
        }

        [Fact]
        public void InferLocalType_OutVarError()
        {
            var source =
@"using System;
using System.Collections.Generic;
class C
{
    static T F<T>(IEnumerable<T> e)
    {
        throw new NotImplementedException();
    }
    static void G()
    {
        dynamic d = null!;
        d.F(out var v);
        F(v).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,21): error CS8197: Cannot infer the type of implicitly-typed out variable 'v'.
                //         d.F(out var v);
                Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedOutVariable, "v").WithArguments("v").WithLocation(12, 21));
        }

        [Fact]
        public void InferLocalType_OutVarError_Script()
        {
            var source =
@"using System;
using System.Collections.Generic;
static T F<T>(IEnumerable<T> e)
{
    throw new NotImplementedException();
}
dynamic d = null!;
d.F(out var v);
F(v).ToString();";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, parseOptions: TestOptions.Script.WithLanguageVersion(LanguageVersion.CSharp8));
            comp.VerifyDiagnostics(
                // (8,13): error CS8197: Cannot infer the type of implicitly-typed out variable 'v'.
                // d.F(out var v);
                Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedOutVariable, "v").WithArguments("v").WithLocation(8, 13)
                );
        }

        /// <summary>
        /// Default value for non-nullable parameter
        /// should not result in a warning at the call site.
        /// </summary>
        [WorkItem(26626, "https://github.com/dotnet/roslyn/issues/26626")]
        [Fact]
        public void ParameterDefaultValue_FromMetadata()
        {
            var source0 =
@"public class C
{
    public static void F(object o = null)
    {
    }
}";
            var comp0 = CreateCompilation(
                new[] { source0 }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp0.VerifyDiagnostics(
                // (3,37): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     public static void F(object o = null)
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(3, 37));
            var ref0 = comp0.EmitToImageReference();

            var source1 =
@"class Program
{
    static void Main()
    {
        C.F();
        C.F(null);
    }
}";
            var comp1 = CreateCompilation(
                new[] { source1 }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8,
                references: new[] { ref0 });
            comp1.VerifyDiagnostics(
                // (6,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         C.F(null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 13));
        }

        [Fact]
        public void ParameterDefaultValue_WithSuppression()
        {
            var source0 =
@"class C
{
    void F(object o = null!)
    {
    }
}";
            var comp = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [WorkItem(26626, "https://github.com/dotnet/roslyn/issues/26626")]
        [Fact]
        public void ParameterDefaultValue_01()
        {
            var source =
@"class C
{
    const string? S0 = null;
    const string? S1 = """";
    static string? F() => string.Empty;
    static void F0(string s = null) { }
    static void F1(string s = default) { }
    static void F2(string s = default(string)) { }
    static void F3(string x = (string)null, string y = (string?)null) { }
    static void F4(string s = S0) { }
    static void F5(string s = S1) { }
    static void F6(string s = F()) { }
    static void M()
    {
        F0();
        F1();
        F2();
        F3();
        F4();
        F5();
        F6();
        F0(null);
        F0(string.Empty);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F0(string s = null) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 31),
                // (7,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F1(string s = default) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(7, 31),
                // (8,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F2(string s = default(string)) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(string)").WithLocation(8, 31),
                // (9,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F3(string x = (string)null, string y = (string?)null) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string)null").WithLocation(9, 31),
                // (9,56): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F3(string x = (string)null, string y = (string?)null) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "(string?)null").WithLocation(9, 56),
                // (10,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F4(string s = S0) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "S0").WithLocation(10, 31),
                // (12,31): error CS1736: Default parameter value for 's' must be a compile-time constant
                //     static void F6(string s = F()) { }
                Diagnostic(ErrorCode.ERR_DefaultValueMustBeConstant, "F()").WithArguments("s").WithLocation(12, 31),
                // (22,12): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0(null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(22, 12));
        }

        [WorkItem(26626, "https://github.com/dotnet/roslyn/issues/26626")]
        [Fact]
        public void ParameterDefaultValue_02()
        {
            var source =
@"class C
{
    const string? S0 = null;
    static void F0(string s = null!) { }
    static void F1(string x = (string)null!, string y = ((string)null)!) { }
    static void F2(string x = default!, string y = default(string)!) { }
    static void F3(string s = (S0!)!) { }
    static void M()
    {
        F0();
        F1();
        F2();
        F3();
        F1(x: null);
        F1(y: null);
        F2(null!, null);
    }
}";
            // we should warn on the conversion of `null` to `string` in `(string)null`
            // Tracked by https://github.com/dotnet/roslyn/issues/32844

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F1(x: null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(14, 15),
                // (15,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F1(y: null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(15, 15),
                // (16,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F2(null!, null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(16, 19)
                );
        }

        [WorkItem(26626, "https://github.com/dotnet/roslyn/issues/26626")]
        [WorkItem(29910, "https://github.com/dotnet/roslyn/issues/29910")]
        [Fact]
        public void ParameterDefaultValue_03()
        {
            var source =
@"interface I { }
class C : I { }
class P
{
    static void F0<T>(T t = default) { }
    static void F1<T>(T t = null) where T : class { }
    static void F2<T>(T t = default) where T : struct { }
    static void F3<T>(T t = default) where T : new() { }
    static void F4<T>(T t = null) where T : C { }
    static void F5<T>(T t = default) where T : I { }
    static void F6<T, U>(T t = default) where T : U { }
    static void G0()
    {
        F0<object>();
        F0<object>(default);
        F0(new object());
        F1<object>();
        F1<object>(default);
        F1(new object());
        F2<int>();
        F2<int>(default);
        F2(2);
        F3<object>();
        F3<object>(default);
        F3(new object());
        F4<C>();
        F4<C>(default);
        F4(new C());
        F5<I>();
        F5<I>(default);
        F5(new C());
        F6<object, object>();
        F6<object, object>(default);
        F6<object, object>(new object());
    }
    static void G0<T>()
    {
        F0<T>(); // 0
        F0<T>(default); // 0
        F6<T, T>(); // 0
        F6<T, T>(default); // 0
    }
    static void G1<T>() where T : class
    {
        F0<T>(); // 1
        F0<T>(default); // 1
        F1<T>(); // 1
        F1<T>(default); // 1
        F6<T, T>(); // 1
        F6<T, T>(default); // 1
    }
    static void G2<T>() where T : struct
    {
        F0<T>(); // 2
        F0<T>(default); // 2
        F2<T>(); // 2
        F2<T>(default); // 2
        F3<T>(); // 2
        F3<T>(default); // 2
        F6<T, T>(); // 2
        F6<T, T>(default); // 2
    }
    static void G3<T>() where T : new()
    {
        F0<T>(); // 3
        F0<T>(default); // 3
        F0<T>(new T()); // 3
        F3<T>(); // 3
        F3<T>(default); // 3
        F3<T>(new T()); // 3
        F6<T, T>(); // 3
        F6<T, T>(default); // 3
        F6<T, T>(new T()); // 3
    }
    static void G4<T>() where T : C
    {
        F0<T>(); // 4
        F0<T>(default); // 4
        F1<T>(); // 4
        F1<T>(default); // 4
        F4<T>(); // 4
        F4<T>(default); // 4
        F5<T>(); // 4
        F5<T>(default); // 4
        F6<T, T>(); // 4
        F6<T, T>(default); // 4
    }
    static void G5<T>() where T : I
    {
        F0<T>(); // 5
        F0<T>(default); // 5
        F5<T>(); // 5
        F5<T>(default); // 5
        F6<T, T>(); // 5
        F6<T, T>(default); // 5
    }
    static void G6<T, U>() where T : U
    {
        F0<T>(); // 6
        F0<T>(default); // 6
        F6<T, U>(); // 6
        F6<T, U>(default); // 6
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29910: Duplicate WRN_NullAsNonNullable diagnostics at some locations
            comp.VerifyDiagnostics(
                // (6,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F1<T>(T t = null) where T : class { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 29),
                // (9,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F4<T>(T t = null) where T : C { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(9, 29),
                // (15,20): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<object>(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(15, 20),
                // (18,20): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F1<object>(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(18, 20),
                // (24,20): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F3<object>(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(24, 20),
                // (27,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F4<C>(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(27, 15),
                // (30,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F5<I>(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(30, 15),
                // (33,28): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<object, object>(default);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(33, 28),
                // (39,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 0
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(39, 15),
                // (41,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, T>(default); // 0
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(41, 18),
                // (46,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(46, 15),
                // (48,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F1<T>(default); // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(48, 15),
                // (50,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, T>(default); // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(50, 18),
                // (66,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(66, 15),
                // (69,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F3<T>(default); // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(69, 15),
                // (72,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, T>(default); // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(72, 18),
                // (78,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(78, 15),
                // (80,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F1<T>(default); // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(80, 15),
                // (82,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F4<T>(default); // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(82, 15),
                // (84,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F5<T>(default); // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(84, 15),
                // (86,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, T>(default); // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(86, 18),
                // (91,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(91, 15),
                // (93,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F5<T>(default); // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(93, 15),
                // (95,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, T>(default); // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(95, 18),
                // (100,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F0<T>(default); // 6
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(100, 15),
                // (102,18): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F6<T, U>(default); // 6
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(102, 18)
                );

            // No warnings with C#7.3.
            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'NullableContextOptions' value: 'Enable' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("NullableContextOptions", "Enable", "7.3", "8.0").WithLocation(1, 1)
                );
        }

        [Fact]
        public void NonNullTypesInCSharp7_InSource()
        {
            var source = @"
" + NonNullTypesOn() + @"
public class C
{
    public static string field;
}
public class D
{
" + NonNullTypesOn() + @"
    public static string field;

" + NonNullTypesOn() + @"
    public static string Method(string s) => throw null;

" + NonNullTypesOn() + @"
    public static string Property { get; set; }

" + NonNullTypesOn() + @"
    public static event System.Action Event;
" + NonNullTypesOff() + @"
    void M()
    {
        C.field = null;
        D.field = null;
        D.Method(null);
        D.Property = null;
        D.Event();
    }
}
";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(
                // (2,2): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                // #nullable enable
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "nullable").WithArguments("nullable reference types").WithLocation(2, 2),
                // (9,2): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                // #nullable enable
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "nullable").WithArguments("nullable reference types").WithLocation(9, 2),
                // (12,2): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                // #nullable enable
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "nullable").WithArguments("nullable reference types").WithLocation(12, 2),
                // (15,2): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                // #nullable enable
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "nullable").WithArguments("nullable reference types").WithLocation(15, 2),
                // (18,2): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                // #nullable enable
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "nullable").WithArguments("nullable reference types").WithLocation(18, 2),
                // (20,2): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                // #nullable disable
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "nullable").WithArguments("nullable reference types").WithLocation(20, 2)
                );
        }

        [Fact]
        public void NonNullTypesInCSharp7_FromMetadata()
        {
            var libSource = @"
" + NonNullTypesOn() + @"
public class C
{
    public static string field;
}
public class D
{
" + NonNullTypesOn() + @"
    public static string field;

" + NonNullTypesOn() + @"
    public static string Method(string s) => throw null;

" + NonNullTypesOn() + @"
    public static string Property { get; set; }

" + NonNullTypesOn() + @"
    public static event System.Action Event;
}
";
            var libComp = CreateCompilation(new[] { libSource });
            libComp.VerifyDiagnostics(
                // (19,39): warning CS0067: The event 'D.Event' is never used
                //     public static event System.Action Event;
                Diagnostic(ErrorCode.WRN_UnreferencedEvent, "Event").WithArguments("D.Event").WithLocation(19, 39)
                );

            var source = @"
class Client
{
    void M()
    {
        C.field = null;
        D.field = null;
        D.Method(null);
        D.Property = null;
        D.Event();
    }
}
";
            var comp = CreateCompilation(source, references: new[] { libComp.EmitToImageReference() }, parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics(
                // (10,11): error CS0079: The event 'D.Event' can only appear on the left hand side of += or -=
                //         D.Event();
                Diagnostic(ErrorCode.ERR_BadEventUsageNoField, "Event").WithArguments("D.Event").WithLocation(10, 11)
                );

            var comp2 = CreateCompilation(source, references: new[] { libComp.EmitToImageReference() });
            comp2.VerifyDiagnostics(
                // (10,11): error CS0079: The event 'D.Event' can only appear on the left hand side of += or -=
                //         D.Event();
                Diagnostic(ErrorCode.ERR_BadEventUsageNoField, "Event").WithArguments("D.Event").WithLocation(10, 11)
                );
        }

        [WorkItem(26626, "https://github.com/dotnet/roslyn/issues/26626")]
        [Fact]
        public void ParameterDefaultValue_04()
        {
            var source =
@"partial class C
{
    static partial void F(object? x = null, object y = null);
    static partial void F(object? x, object y) { }
    static partial void G(object x, object? y);
    static partial void G(object x = null, object? y = null) { }
    static void M()
    {
        F();
        G();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,34): warning CS1066: The default value specified for parameter 'x' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments
                //     static partial void G(object x = null, object? y = null) { }
                Diagnostic(ErrorCode.WRN_DefaultValueForUnconsumedLocation, "x").WithArguments("x").WithLocation(6, 34),
                // (6,38): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static partial void G(object x = null, object? y = null) { }
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 38),
                // (6,52): warning CS1066: The default value specified for parameter 'y' will have no effect because it applies to a member that is used in contexts that do not allow optional arguments
                //     static partial void G(object x = null, object? y = null) { }
                Diagnostic(ErrorCode.WRN_DefaultValueForUnconsumedLocation, "y").WithArguments("y").WithLocation(6, 52),
                // (3,56): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static partial void F(object? x = null, object y = null);
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(3, 56),
                // (10,9): error CS7036: There is no argument given that corresponds to the required formal parameter 'x' of 'C.G(object, object)'
                //         G();
                Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "G").WithArguments("x", "C.G(object, object?)").WithLocation(10, 9));
        }

        [Fact]
        public void InvalidThrowTerm()
        {
            var source =
@"class C
{
    static string F(string s) => s + throw new System.Exception();
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (3,38): error CS1525: Invalid expression term 'throw'
                //     static string F(string s) => s + throw new System.Exception();
                Diagnostic(ErrorCode.ERR_InvalidExprTerm, "throw new System.Exception()").WithArguments("throw").WithLocation(3, 38));
        }

        [Fact]
        public void UnboxingConversion()
        {
            var source =
@"using System.Collections.Generic;
class Program
{
    static IEnumerator<T> M<T>() => default(T);
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (4,37): error CS0266: Cannot implicitly convert type 'T' to 'System.Collections.Generic.IEnumerator<T>'. An explicit conversion exists (are you missing a cast?)
                //     static IEnumerator<T> M<T>() => default(T);
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "default(T)").WithArguments("T", "System.Collections.Generic.IEnumerator<T>").WithLocation(4, 37));
        }

        [Fact]
        public void DeconstructionConversion_NoDeconstructMethod()
        {
            var source =
@"class C
{
    static void F(C c)
    {
        var (x, y) = c;
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (5,22): error CS1061: 'C' does not contain a definition for 'Deconstruct' and no extension method 'Deconstruct' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
                //         var (x, y) = c;
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "c").WithArguments("C", "Deconstruct").WithLocation(5, 22),
                // (5,22): error CS8129: No suitable Deconstruct instance or extension method was found for type 'C', with 2 out parameters and a void return type.
                //         var (x, y) = c;
                Diagnostic(ErrorCode.ERR_MissingDeconstruct, "c").WithArguments("C", "2").WithLocation(5, 22),
                // (5,14): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'x'.
                //         var (x, y) = c;
                Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "x").WithArguments("x").WithLocation(5, 14),
                // (5,17): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'y'.
                //         var (x, y) = c;
                Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "y").WithArguments("y").WithLocation(5, 17));
        }

        [Fact]
        [WorkItem(29916, "https://github.com/dotnet/roslyn/issues/29916")]
        public void ConditionalAccessDelegateInvoke()
        {
            var source =
@"using System;
class C<T>
{
    static T F(Func<T>? f)
    {
        return f?.Invoke();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,17): error CS0023: Operator '?' cannot be applied to operand of type 'T'
                //         return f?.Invoke();
                Diagnostic(ErrorCode.ERR_BadUnaryOp, "?").WithArguments("?", "T").WithLocation(6, 17)
                );
        }

        [Fact]
        public void NonNullTypes_DecodeAttributeCycle_01()
        {
            var source =
@"using System.Runtime.InteropServices;
interface I
{
    int P { get; }
}
[StructLayout(LayoutKind.Auto)]
struct S : I
{
    int I.P => 0;
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_DecodeAttributeCycle_01_WithEvent()
        {
            var source =
@"using System;
using System.Runtime.InteropServices;
interface I
{
    event Func<int> E;
}
[StructLayout(LayoutKind.Auto)]
struct S : I
{
    event Func<int> I.E { add => throw null; remove => throw null; }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypes_DecodeAttributeCycle_02()
        {
            var source =
@"[A(P)]
class A : System.Attribute
{
    string P => null;
}";
            var comp = CreateCompilation(
                 new[] { source }, options: WithNonNullTypesTrue(),
                 parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (1,4): error CS0120: An object reference is required for the non-static field, method, or property 'A.P'
                // [A(P)]
                Diagnostic(ErrorCode.ERR_ObjectRequired, "P").WithArguments("A.P").WithLocation(1, 4),
                // (1,2): error CS1729: 'A' does not contain a constructor that takes 1 arguments
                // [A(P)]
                Diagnostic(ErrorCode.ERR_BadCtorArgCount, "A(P)").WithArguments("A", "1").WithLocation(1, 2),
                // (4,17): warning CS8603: Possible null reference return.
                //     string P => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(4, 17));
        }

        [Fact]
        [WorkItem(29954, "https://github.com/dotnet/roslyn/issues/29954")]
        public void UnassignedOutParameterClass()
        {
            var source =
@"class C
{
    static void G(out C? c)
    {
        c.ToString(); // 1
        c = null;
        c.ToString(); // 2
        c = new C();
        c.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): error CS0269: Use of unassigned out parameter 'c'
                //         c.ToString(); // 1
                Diagnostic(ErrorCode.ERR_UseDefViolationOut, "c").WithArguments("c").WithLocation(5, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(7, 9));
        }

        [Fact]
        public void UnassignedOutParameterClassField()
        {
            var source =
@"class C
{
#pragma warning disable 0649
    object? F;
    static void G(out C c)
    {
        object o = c.F;
        c.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,20): error CS0269: Use of unassigned out parameter 'c'
                //         object o = c.F;
                Diagnostic(ErrorCode.ERR_UseDefViolationOut, "c").WithArguments("c").WithLocation(7, 20),
                // (5,17): error CS0177: The out parameter 'c' must be assigned to before control leaves the current method
                //     static void G(out C c)
                Diagnostic(ErrorCode.ERR_ParamUnassigned, "G").WithArguments("c").WithLocation(5, 17),
                // (7,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object o = c.F;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.F").WithLocation(7, 20),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.F").WithLocation(8, 9));
        }

        [Fact]
        public void UnassignedOutParameterStructField()
        {
            var source =
@"struct S
{
#pragma warning disable 0649
    object? F;
    static void G(out S s)
    {
        object o = s.F;
        s.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,20): error CS0170: Use of possibly unassigned field 'F'
                //         object o = s.F;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "s.F").WithArguments("F").WithLocation(7, 20),
                // (5,17): error CS0177: The out parameter 's' must be assigned to before control leaves the current method
                //     static void G(out S s)
                Diagnostic(ErrorCode.ERR_ParamUnassigned, "G").WithArguments("s").WithLocation(5, 17));
        }

        [Fact]
        public void UnassignedLocalField()
        {
            var source =
@"class C
{
    static void F()
    {
        S s;
        C c;
        c = s.F;
        s.F.ToString();
    }
}
struct S
{
    internal C? F;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): error CS0170: Use of possibly unassigned field 'F'
                //         c = s.F;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "s.F").WithArguments("F").WithLocation(7, 13),
                // (13,17): warning CS0649: Field 'S.F' is never assigned to, and will always have its default value null
                //     internal C? F;
                Diagnostic(ErrorCode.WRN_UnassignedInternalField, "F").WithArguments("S.F", "null").WithLocation(13, 17));
        }

        [Fact]
        public void UnassignedLocalField_Conditional()
        {
            var source =
@"class C
{
    static void F(bool b)
    {
        S s;
        object o;
        if (b)
        {
            s.F = new object();
            s.G = new object();
        }
        else
        {
            o = s.F;
        }
        o = s.G;
    }
}
struct S
{
    internal object? F;
    internal object? G;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,17): error CS0170: Use of possibly unassigned field 'F'
                //             o = s.F;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "s.F").WithArguments("F").WithLocation(14, 17),
                // (16,13): error CS0170: Use of possibly unassigned field 'G'
                //         o = s.G;
                Diagnostic(ErrorCode.ERR_UseDefViolationField, "s.G").WithArguments("G").WithLocation(16, 13));
        }

        [Fact]
        public void UnassignedLocalProperty()
        {
            var source =
@"class C
{
    static void F()
    {
        S s;
        C c;
        c = s.P;
        s.P.ToString();
    }
}
struct S
{
    internal C? P { get => null; }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = s.P;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "s.P").WithLocation(7, 13),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         s.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s.P").WithLocation(8, 9));
        }

        [Fact]
        public void UnassignedClassAutoProperty()
        {
            var source =
@"class C
{
    object? P { get; }
    void M(out object o)
    {
        o = P;
        P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8601: Possible null reference assignment.
                //         o = P;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "P").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "P").WithLocation(7, 9));
        }

        [Fact]
        public void UnassignedClassAutoProperty_Constructor()
        {
            var source =
@"class C
{
    object? P { get; }
    C(out object o)
    {
        o = P;
        P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8601: Possible null reference assignment.
                //         o = P;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "P").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "P").WithLocation(7, 9));
        }

        [Fact]
        public void UnassignedStructAutoProperty()
        {
            var source =
@"struct S
{
    object? P { get; }
    void M(out object o)
    {
        o = P;
        P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8601: Possible null reference assignment.
                //         o = P;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "P").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "P").WithLocation(7, 9));
        }

        [Fact]
        public void UnassignedStructAutoProperty_Constructor()
        {
            var source =
@"struct S
{
    object? P { get; }
    S(out object o)
    {
        o = P;
        P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): error CS8079: Use of possibly unassigned auto-implemented property 'P'
                //         o = P;
                Diagnostic(ErrorCode.ERR_UseDefViolationProperty, "P").WithArguments("P").WithLocation(6, 13),
                // (4,5): error CS0843: Auto-implemented property 'S.P' must be fully assigned before control is returned to the caller.
                //     S(out object o)
                Diagnostic(ErrorCode.ERR_UnassignedThisAutoProperty, "S").WithArguments("S.P").WithLocation(4, 5));
        }

        [Fact]
        public void ParameterField_Class()
        {
            var source =
@"class C
{
#pragma warning disable 0649
    object? F;
    static void M(C x)
    {
        C y = x;
        object z = y.F;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object z = y.F;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y.F").WithLocation(8, 20));
        }

        [Fact]
        public void ParameterField_Struct()
        {
            var source =
@"struct S
{
#pragma warning disable 0649
    object? F;
    static void M(S x)
    {
        S y = x;
        object z = y.F;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object z = y.F;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y.F").WithLocation(8, 20));
        }

        [Fact]
        public void InstanceFieldStructTypeExpressionReceiver()
        {
            var source =
@"struct S
{
#pragma warning disable 0649
    object? F;
    void M()
    {
        S.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): error CS0120: An object reference is required for the non-static field, method, or property 'S.F'
                //         S.F.ToString();
                Diagnostic(ErrorCode.ERR_ObjectRequired, "S.F").WithArguments("S.F").WithLocation(7, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         S.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "S.F").WithLocation(7, 9));
        }

        [Fact]
        public void InstanceFieldPrimitiveRecursiveStruct()
        {
            var source =
@"#pragma warning disable 0649
namespace System
{
    public class Object
    {
        public int GetHashCode() => 0;
    }
    public abstract class ValueType { }
    public struct Void { }
    public struct Int32
    {
        Int32 _value;
        object? _f;
        void M()
        {
            _value = _f.GetHashCode();
        }
    }
    public class String { }
    public struct Boolean { }
    public struct Enum { }
    public class Attribute { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}";
            var comp = CreateEmptyCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (16,22): warning CS8602: Possible dereference of a null reference.
                //             _value = _f.GetHashCode();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "_f").WithLocation(16, 22)
                );
        }

        [Fact]
        public void Pointer()
        {
            var source =
@"class C
{
    static unsafe void F(int* p)
    {
        *p = 0;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(TestOptions.UnsafeReleaseDll));
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TaskMethodReturningNull()
        {
            var source =
@"using System.Threading.Tasks;
class C
{
    static Task F0() => null;
    static Task<string> F1() => null;
    static Task<string?> F2() { return null; }
    static Task<T> F3<T>() { return default; }
    static Task<T> F4<T>() { return default(Task<T>); }
    static Task<T> F5<T>() where T : class { return null; }
    static Task<T?> F6<T>() where T : class => null;
    static Task? G0() => null;
    static Task<string>? G1() => null;
    static Task<T>? G3<T>() { return default; }
    static Task<T?>? G6<T>() where T : class => null;
}";
            var comp = CreateCompilationWithMscorlib46(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,25): warning CS8603: Possible null reference return.
                //     static Task F0() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(4, 25),
                // (5,33): warning CS8603: Possible null reference return.
                //     static Task<string> F1() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(5, 33),
                // (6,40): warning CS8603: Possible null reference return.
                //     static Task<string?> F2() { return null; }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(6, 40),
                // (7,37): warning CS8603: Possible null reference return.
                //     static Task<T> F3<T>() { return default; }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(7, 37),
                // (8,37): warning CS8603: Possible null reference return.
                //     static Task<T> F4<T>() { return default(Task<T>); }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(Task<T>)").WithLocation(8, 37),
                // (9,53): warning CS8603: Possible null reference return.
                //     static Task<T> F5<T>() where T : class { return null; }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(9, 53),
                // (10,48): warning CS8603: Possible null reference return.
                //     static Task<T?> F6<T>() where T : class => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(10, 48));
        }

        // https://github.com/dotnet/roslyn/issues/29957: Should not report WRN_NullReferenceReturn for F0.
        [WorkItem(23275, "https://github.com/dotnet/roslyn/issues/23275")]
        [WorkItem(29957, "https://github.com/dotnet/roslyn/issues/29957")]
        [Fact]
        public void AsyncTaskMethodReturningNull()
        {
            var source =
@"#pragma warning disable 1998
using System.Threading.Tasks;
class C
{
    static async Task F0() { return null; }
    static async Task<string> F1() => null;
    static async Task<string?> F2() { return null; }
    static async Task<T> F3<T>() { return default; }
    static async Task<T> F4<T>() { return default(T); }
    static async Task<T> F5<T>() where T : class { return null; }
    static async Task<T?> F6<T>() where T : class => null;
    static async Task? G0() { return null; }
    static async Task<string>? G1() => null;
    static async Task<T>? G3<T>() { return default; }
    static async Task<T?>? G6<T>() where T : class => null;
}";
            var comp = CreateCompilationWithMscorlib46(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,30): error CS1997: Since 'C.F0()' is an async method that returns 'Task', a return keyword must not be followed by an object expression. Did you intend to return 'Task<T>'?
                //     static async Task F0() { return null; }
                Diagnostic(ErrorCode.ERR_TaskRetNoObjectRequired, "return").WithArguments("C.F0()").WithLocation(5, 30),
                // (5,37): warning CS8603: Possible null reference return.
                //     static async Task F0() { return null; }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(5, 37),
                // (6,39): warning CS8603: Possible null reference return.
                //     static async Task<string> F1() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(6, 39),
                // (8,43): warning CS8603: Possible null reference return.
                //     static async Task<T> F3<T>() { return default; }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(8, 43),
                // (9,43): warning CS8603: Possible null reference return.
                //     static async Task<T> F4<T>() { return default(T); }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(T)").WithLocation(9, 43),
                // (10,59): warning CS8603: Possible null reference return.
                //     static async Task<T> F5<T>() where T : class { return null; }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(10, 59),
                // (12,31): error CS1997: Since 'C.G0()' is an async method that returns 'Task', a return keyword must not be followed by an object expression. Did you intend to return 'Task<T>'?
                //     static async Task? G0() { return null; }
                Diagnostic(ErrorCode.ERR_TaskRetNoObjectRequired, "return").WithArguments("C.G0()").WithLocation(12, 31),
                // (13,40): warning CS8603: Possible null reference return.
                //     static async Task<string>? G1() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(13, 40),
                // (14,44): warning CS8603: Possible null reference return.
                //     static async Task<T>? G3<T>() { return default; }
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(14, 44)
                );
        }

        [Fact]
        public void IncrementWithErrors()
        {
            var source =
@"using System.Threading.Tasks;
class C
{
    static async Task<int> F(ref int i)
    {
        return await Task.Run(() => i++);
    }
}";
            var comp = CreateCompilationWithMscorlib46(source);
            comp.VerifyDiagnostics(
                // (4,38): error CS1988: Async methods cannot have ref or out parameters
                //     static async Task<int> F(ref int i)
                Diagnostic(ErrorCode.ERR_BadAsyncArgType, "i").WithLocation(4, 38),
                // (6,37): error CS1628: Cannot use ref or out parameter 'i' inside an anonymous method, lambda expression, or query expression
                //         return await Task.Run(() => i++);
                Diagnostic(ErrorCode.ERR_AnonDelegateCantUse, "i").WithArguments("i").WithLocation(6, 37));
        }

        [Fact]
        public void NullCastToValueType()
        {
            var source =
@"struct S { }
class C
{
    static void M()
    {
        S s = (S)null;
        s.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,15): error CS0037: Cannot convert null to 'S' because it is a non-nullable value type
                //         S s = (S)null;
                Diagnostic(ErrorCode.ERR_ValueCantBeNull, "(S)null").WithArguments("S").WithLocation(6, 15));
        }

        [Fact]
        public void LiftedUserDefinedConversion()
        {
            var source =
@"#pragma warning disable 0649
struct A<T>
{
    public static implicit operator B<T>(A<T> a) => new B<T>();
}
struct B<T>
{
    internal T F;
}
class C
{
    static void F(A<object>? x, A<object?>? y)
    {
        B<object>? z = x;
        z?.F.ToString();
        B<object?>? w = y;
        w?.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,11): warning CS8602: Possible dereference of a null reference.
                //         w?.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, ".F").WithLocation(17, 11));
        }

        [Fact]
        public void GroupBy()
        {
            var source =
@"using System.Linq;
class Program
{
    static void Main()
    {
        var items = from i in Enumerable.Range(0, 3) group (long)i by i;
    }
}";
            var comp = CreateCompilationWithMscorlib40AndSystemCore(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        // Tests for NullableWalker.HasImplicitTypeArguments.
        [Fact]
        public void ExplicitTypeArguments()
        {
            var source =
@"interface I<T> { }
class C
{
    C P => throw new System.Exception();
    I<T> F<T>(T t)
    {
        throw new System.Exception();
    }
    static void M(C c)
    {
        c.P.F<object>(string.Empty);
        (new[]{ c })[0].F<object>(string.Empty);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void MultipleConversions_01()
        {
            var source =
@"class A
{
    public static implicit operator C(A a) => new C();
}
class B : A
{
}
class C
{
    static void F(B? x, B y)
    {
        C c;
        c = x; // (ImplicitUserDefined)(ImplicitReference)
        c = y; // (ImplicitUserDefined)(ImplicitReference)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8604: Possible null reference argument for parameter 'a' in 'A.implicit operator C(A a)'.
                //         c = x; // (ImplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("a", "A.implicit operator C(A a)").WithLocation(13, 13));
        }

        [Fact]
        public void MultipleConversions_02()
        {
            var source =
@"class A
{
}
class B : A
{
}
class C
{
    public static implicit operator B?(C c) => null;
    static void F(C c)
    {
        A a = c; // (ImplicitReference)(ImplicitUserDefined)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         A a = c; // (ImplicitReference)(ImplicitUserDefined)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c").WithLocation(12, 15));
        }

        [Fact]
        public void MultipleConversions_03()
        {
            var source =
@"struct S<T>
{
    public static implicit operator S<T>(T t) => default;
    static void M()
    {
        S<object> s = true; // (ImplicitUserDefined)(Boxing)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void MultipleConversions_04()
        {
            var source =
@"struct S<T>
{
    public static implicit operator T(S<T> s) => throw new System.Exception();
    static void M()
    {
        bool b = new S<object>(); // (Unboxing)(ExplicitUserDefined)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,18): error CS0266: Cannot implicitly convert type 'S<object>' to 'bool'. An explicit conversion exists (are you missing a cast?)
                //         bool b = new S<object>(); // (Unboxing)(ExplicitUserDefined)
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "new S<object>()").WithArguments("S<object>", "bool").WithLocation(6, 18));
        }

        [Fact]
        public void MultipleConversions_Explicit_01()
        {
            var source =
@"class A
{
    public static explicit operator C(A a) => new C();
}
class B : A
{
}
class C
{
    static void F1(B b1)
    {
        C? c;
        c = (C)b1; // (ExplicitUserDefined)(ImplicitReference)
        c = (C?)b1; // (ExplicitUserDefined)(ImplicitReference)
    }
    static void F2(B? b2)
    {
        C? c;
        c = (C)b2; // (ExplicitUserDefined)(ImplicitReference)
        c = (C?)b2; // (ExplicitUserDefined)(ImplicitReference)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,16): warning CS8604: Possible null reference argument for parameter 'a' in 'A.explicit operator C(A a)'.
                //         c = (C)b2; // (ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b2").WithArguments("a", "A.explicit operator C(A a)").WithLocation(19, 16),
                // (20,17): warning CS8604: Possible null reference argument for parameter 'a' in 'A.explicit operator C(A a)'.
                //         c = (C?)b2; // (ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b2").WithArguments("a", "A.explicit operator C(A a)").WithLocation(20, 17));
        }

        [Fact]
        public void MultipleConversions_Explicit_02()
        {
            var source =
@"class A
{
    public static explicit operator C?(A? a) => new D();
}
class B : A { }
class C { }
class D : C { }
class P
{
    static void F1(A a1, B b1)
    {
        C? c;
        c = (C)a1; // (ExplicitUserDefined)
        c = (C?)a1; // (ExplicitUserDefined)
        c = (C)b1; // (ExplicitUserDefined)(ImplicitReference)
        c = (C?)b1; // (ExplicitUserDefined)(ImplicitReference)
        c = (C)(B)a1;
        c = (C)(B?)a1;
        c = (C?)(B)a1;
        c = (C?)(B?)a1;
        D? d;
        d = (D)a1; // (ExplicitReference)(ExplicitUserDefined)
        d = (D?)a1; // (ExplicitReference)(ExplicitUserDefined)
        d = (D)b1; // (ExplicitReference)(ExplicitUserDefined)(ImplicitReference)
        d = (D?)b1; // (ExplicitReference)(ExplicitUserDefined)(ImplicitReference)
    }
    static void F2(A? a2, B? b2)
    {
        C? c;
        c = (C)a2; // (ExplicitUserDefined)
        c = (C?)a2; // (ExplicitUserDefined)
        c = (C)b2; // (ExplicitUserDefined)(ImplicitReference)
        c = (C?)b2; // (ExplicitUserDefined)(ImplicitReference)
        D? d;
        d = (D)a2; // (ExplicitReference)(ExplicitUserDefined)
        d = (D?)a2; // (ExplicitReference)(ExplicitUserDefined)
        d = (D)b2; // (ExplicitReference)(ExplicitUserDefined)(ImplicitReference)
        d = (D?)b2; // (ExplicitReference)(ExplicitUserDefined)(ImplicitReference)
        d = (D)(A)b2;
        d = (D)(A?)b2;
        d = (D?)(A)b2;
        d = (D?)(A?)b2;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = (C)a1; // (ExplicitUserDefined)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)a1").WithLocation(13, 13),
                // (15,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = (C)b1; // (ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)b1").WithLocation(15, 13),
                // (17,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = (C)(B)a1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)(B)a1").WithLocation(17, 13),
                // (18,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = (C)(B?)a1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)(B?)a1").WithLocation(18, 13),
                // (22,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)a1; // (ExplicitReference)(ExplicitUserDefined)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(D)a1").WithLocation(22, 13),
                // (24,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)b1; // (ExplicitReference)(ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(D)b1").WithLocation(24, 13),
                // (30,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = (C)a2; // (ExplicitUserDefined)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)a2").WithLocation(30, 13),
                // (32,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c = (C)b2; // (ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)b2").WithLocation(32, 13),
                // (35,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)a2; // (ExplicitReference)(ExplicitUserDefined)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(D)a2").WithLocation(35, 13),
                // (37,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)b2; // (ExplicitReference)(ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(D)b2").WithLocation(37, 13),
                // (39,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)(A)b2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(A)b2").WithLocation(39, 16),
                // (39,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)(A)b2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(D)(A)b2").WithLocation(39, 13),
                // (40,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D)(A?)b2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(D)(A?)b2").WithLocation(40, 13),
                // (41,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         d = (D?)(A)b2;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(A)b2").WithLocation(41, 17));
        }

        [Fact]
        public void MultipleConversions_Explicit_03()
        {
            var source =
@"class A
{
    public static explicit operator S(A a) => new S();
}
class B : A { }
struct S { }
class C
{
    static void F(B? b)
    {
        S? s;
        s = (S)b; // (ExplicitUserDefined)(ImplicitReference)
        s = (S?)b; // (ImplicitNullable)(ExplicitUserDefined)(ImplicitReference)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,16): warning CS8604: Possible null reference argument for parameter 'a' in 'A.explicit operator S(A a)'.
                //         s = (S)b; // (ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b").WithArguments("a", "A.explicit operator S(A a)").WithLocation(12, 16),
                // (13,17): warning CS8604: Possible null reference argument for parameter 'a' in 'A.explicit operator S(A a)'.
                //         s = (S?)b; // (ImplicitNullable)(ExplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b").WithArguments("a", "A.explicit operator S(A a)").WithLocation(13, 17));
        }

        [Fact]
        [WorkItem(29960, "https://github.com/dotnet/roslyn/issues/29960")]
        public void MultipleConversions_Explicit_04()
        {
            var source =
@"struct S
{
    public static explicit operator A?(S s) => throw null;
}
class A
{
    internal void F() { }
}
class B : A
{
}
class C
{
    static void F(S s)
    {
        var b1 = (B)s;
        b1.F();
        B b2 = (B)s;
        b2.F();
        A a = (B)s;
        a.F();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29960: Should only report one WRN_ConvertingNullableToNonNullable
            // warning for `B b2 = (B)s;` and `A a = (B)s;`.
            comp.VerifyDiagnostics(
                // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var b1 = (B)s;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)s").WithLocation(16, 18),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         b1.F();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b1").WithLocation(17, 9),
                // (18,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         B b2 = (B)s;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)s").WithLocation(18, 16),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         b2.F();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b2").WithLocation(19, 9),
                // (20,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         A a = (B)s;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)s").WithLocation(20, 15),
                // (20,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         A a = (B)s;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)s").WithLocation(20, 15),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         a.F();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(21, 9));
        }

        [Fact]
        [WorkItem(29699, "https://github.com/dotnet/roslyn/issues/29699")]
        public void MultipleTupleConversions_01()
        {
            var source =
@"class A
{
    public static implicit operator C(A a) => new C();
}
class B : A
{
}
class C
{
    static void F((B?, B) x, (B, B?) y, (B, B) z)
    {
        (C, C?) c;
        c = x; // (ImplicitTuple)(ImplicitUserDefined)(ImplicitReference)
        c = y; // (ImplicitTuple)(ImplicitUserDefined)(ImplicitReference)
        c = z; // (ImplicitTuple)(ImplicitUserDefined)(ImplicitReference)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29699: Report warnings for user-defined conversions on tuple elements.
            comp.VerifyDiagnostics(
                // (13,13): warning CS8619: Nullability of reference types in value of type '(B?, B)' doesn't match target type '(C, C?)'.
                //         c = x; // (ImplicitTuple)(ImplicitUserDefined)(ImplicitReference)
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("(B?, B)", "(C, C?)").WithLocation(13, 13));
        }

        [Fact]
        public void MultipleTupleConversions_02()
        {
            var source =
@"class A
{
}
class B : A
{
}
class C
{
    public static implicit operator B(C c) => new C();
    static void F(C? x, C y)
    {
        (A, A?) t = (x, y); // (ImplicitTuple)(ImplicitReference)(ImplicitUserDefined)
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,17): warning CS0219: The variable 't' is assigned but its value is never used
                //         (A, A?) t = (x, y); // (ImplicitTuple)(ImplicitReference)(ImplicitUserDefined)
                Diagnostic(ErrorCode.WRN_UnreferencedVarAssg, "t").WithArguments("t").WithLocation(12, 17),
                // (12,22): warning CS8604: Possible null reference argument for parameter 'c' in 'C.implicit operator B(C c)'.
                //         (A, A?) t = (x, y); // (ImplicitTuple)(ImplicitReference)(ImplicitUserDefined)
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("c", "C.implicit operator B(C c)").WithLocation(12, 22));
        }

        [Fact]
        [WorkItem(29966, "https://github.com/dotnet/roslyn/issues/29966")]
        public void Conversions_ImplicitTupleLiteral_01()
        {
            var source =
@"#pragma warning disable 0219
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : I<T> { }
class B<T> : IIn<T> { }
class C<T> : IOut<T> { }
static class E
{
    static void F1(string x, string? y)
    {
        (string, string) t1 = (x, y); // 1
        (string?, string?) u1 = (x, y);
        (object, object) v1 = (x, y); // 2
        (object?, object?) w1 = (x, y);
        F1A((x, y)); // 3
        F1B((x, y));
        F1C((x, y)); // 4
        F1D((x, y));
    }
    static void F1A((string, string) t) { }
    static void F1B((string?, string?) t) { }
    static void F1C((object, object) t) { }
    static void F1D((object?, object?) t) { }
    static void F2(A<object> x, A<object?> y)
    {
        (A<object>, A<object>) t2 = (x, y); // 5
        (A<object?>, A<object?>) u2 = (x, y); // 6
        (I<object>, I<object>) v2 = (x, y); // 7
        (I<object?>, I<object?>) w2 = (x, y); // 8
        F2A((x, y)); // 9
        F2B((x, y)); // 10
        F2C((x, y)); // 11
        F2D((x, y)); // 12
    }
    static void F2A((A<object>, A<object>) t) { }
    static void F2B((A<object?>, A<object?>) t) { }
    static void F2C((I<object>, I<object>) t) { }
    static void F2D((I<object?>, I<object?>) t) { }
    static void F3(B<object> x, B<object?> y)
    {
        (B<object>, B<object>) t3 = (x, y); // 13
        (B<object?>, B<object?>) u3 = (x, y); // 14
        (IIn<object>, IIn<object>) v3 = (x, y);
        (IIn<object?>, IIn<object?>) w3 = (x, y); // 15
        F3A((x, y));
        F3B((x, y)); // 16
    }
    static void F3A((IIn<object>, IIn<object>) t) { }
    static void F3B((IIn<object?>, IIn<object?>) t) { }
    static void F4(C<object> x, C<object?> y)
    {
        (C<object>, C<object>) t4 = (x, y); // 17
        (C<object?>, C<object?>) u4 = (x, y); // 18
        (IOut<object>, IOut<object>) v4 = (x, y); // 19
        (IOut<object?>, IOut<object?>) w4 = (x, y);
        F4A((x, y)); // 20
        F4B((x, y));
    }
    static void F4A((IOut<object>, IOut<object>) t) { }
    static void F4B((IOut<object?>, IOut<object?>) t) { }
    static void F5<T, U>(U u) where U : T
    {
        (T,  T) t5 = (u, default(T));
        (object, object) v5 = (default(T), u); // 21
        (object?, object?) w5 = (default(T), u);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29966: Report WRN_NullabilityMismatchInArgument rather than ...Assignment.
            comp.VerifyDiagnostics(
                // (12,31): warning CS8619: Nullability of reference types in value of type '(string x, string? y)' doesn't match target type '(string, string)'.
                //         (string, string) t1 = (x, y); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(string x, string? y)", "(string, string)").WithLocation(12, 31),
                // (14,31): warning CS8619: Nullability of reference types in value of type '(object x, object? y)' doesn't match target type '(object, object)'.
                //         (object, object) v1 = (x, y); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(object x, object? y)", "(object, object)").WithLocation(14, 31),
                // (16,13): warning CS8620: Nullability of reference types in argument of type '(string x, string? y)' doesn't match target type '(string, string)' for parameter 't' in 'void E.F1A((string, string) t)'.
                //         F1A((x, y)); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(x, y)").WithArguments("(string x, string? y)", "(string, string)", "t", "void E.F1A((string, string) t)").WithLocation(16, 13),
                // (18,13): warning CS8620: Nullability of reference types in argument of type '(object x, object? y)' doesn't match target type '(object, object)' for parameter 't' in 'void E.F1C((object, object) t)'.
                //         F1C((x, y)); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(x, y)").WithArguments("(object x, object? y)", "(object, object)", "t", "void E.F1C((object, object) t)").WithLocation(18, 13),
                // (27,37): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object>, A<object>)'.
                //         (A<object>, A<object>) t2 = (x, y); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object>, A<object>)").WithLocation(27, 37),
                // (28,39): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object?>, A<object?>)'.
                //         (A<object?>, A<object?>) u2 = (x, y); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object?>, A<object?>)").WithLocation(28, 39),
                // (29,41): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         (I<object>, I<object>) v2 = (x, y); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "I<object>").WithLocation(29, 41),
                // (30,40): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         (I<object?>, I<object?>) w2 = (x, y); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "I<object?>").WithLocation(30, 40),
                // (31,13): warning CS8620: Nullability of reference types in argument of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object>, A<object>)' for parameter 't' in 'void E.F2A((A<object>, A<object>) t)'.
                //         F2A((x, y)); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object>, A<object>)", "t", "void E.F2A((A<object>, A<object>) t)").WithLocation(31, 13),
                // (32,13): warning CS8620: Nullability of reference types in argument of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object?>, A<object?>)' for parameter 't' in 'void E.F2B((A<object?>, A<object?>) t)'.
                //         F2B((x, y)); // 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object?>, A<object?>)", "t", "void E.F2B((A<object?>, A<object?>) t)").WithLocation(32, 13),
                // (33,17): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         F2C((x, y)); // 11
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "I<object>").WithLocation(33, 17),
                // (34,14): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         F2D((x, y)); // 12
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "I<object?>").WithLocation(34, 14),
                // (42,37): warning CS8619: Nullability of reference types in value of type '(B<object> x, B<object?> y)' doesn't match target type '(B<object>, B<object>)'.
                //         (B<object>, B<object>) t3 = (x, y); // 13
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(B<object> x, B<object?> y)", "(B<object>, B<object>)").WithLocation(42, 37),
                // (43,39): warning CS8619: Nullability of reference types in value of type '(B<object> x, B<object?> y)' doesn't match target type '(B<object?>, B<object?>)'.
                //         (B<object?>, B<object?>) u3 = (x, y); // 14
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(B<object> x, B<object?> y)", "(B<object?>, B<object?>)").WithLocation(43, 39),
                // (45,44): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         (IIn<object?>, IIn<object?>) w3 = (x, y); // 15
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object>", "IIn<object?>").WithLocation(45, 44),
                // (47,14): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         F3B((x, y)); // 16
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object>", "IIn<object?>").WithLocation(47, 14),
                // (53,37): warning CS8619: Nullability of reference types in value of type '(C<object> x, C<object?> y)' doesn't match target type '(C<object>, C<object>)'.
                //         (C<object>, C<object>) t4 = (x, y); // 17
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(C<object> x, C<object?> y)", "(C<object>, C<object>)").WithLocation(53, 37),
                // (54,39): warning CS8619: Nullability of reference types in value of type '(C<object> x, C<object?> y)' doesn't match target type '(C<object?>, C<object?>)'.
                //         (C<object?>, C<object?>) u4 = (x, y); // 18
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(C<object> x, C<object?> y)", "(C<object?>, C<object?>)").WithLocation(54, 39),
                // (55,47): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         (IOut<object>, IOut<object>) v4 = (x, y); // 19
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "IOut<object>").WithLocation(55, 47),
                // (57,17): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         F4A((x, y)); // 20
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "IOut<object>").WithLocation(57, 17),
                // (64,22): warning CS8619: Nullability of reference types in value of type '(T u, T)' doesn't match target type '(T, T)'.
                //         (T,  T) t5 = (u, default(T));
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(u, default(T))").WithArguments("(T u, T)", "(T, T)").WithLocation(64, 22),
                // (65,31): warning CS8619: Nullability of reference types in value of type '(object?, object? u)' doesn't match target type '(object, object)'.
                //         (object, object) v5 = (default(T), u); // 21
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(default(T), u)").WithArguments("(object?, object? u)", "(object, object)").WithLocation(65, 31));
        }

        [Fact]
        public void Conversions_ImplicitTupleLiteral_02()
        {
            var source =
@"#pragma warning disable 0219
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : I<T> { }
class B<T> : IIn<T> { }
class C<T> : IOut<T> { }
static class E
{
    static void F1(string x, string? y)
    {
        (string, string)? t1 = (x, y); // 1
        (string?, string?)? u1 = (x, y);
        (object, object)? v1 = (x, y); // 2
        (object?, object?)? w1 = (x, y);
    }
    static void F2(A<object> x, A<object?> y)
    {
        (A<object>, A<object>)? t2 = (x, y); // 3
        (A<object?>, A<object?>)? u2 = (x, y); // 4
        (I<object>, I<object>)? v2 = (x, y); // 5
        (I<object?>, I<object?>)? w2 = (x, y); // 6
    }
    static void F3(B<object> x, B<object?> y)
    {
        (IIn<object>, IIn<object>)? v3 = (x, y);
        (IIn<object?>, IIn<object?>)? w3 = (x, y); // 7
    }
    static void F4(C<object> x, C<object?> y)
    {
        (IOut<object>, IOut<object>)? v4 = (x, y); // 8
        (IOut<object?>, IOut<object?>)? w4 = (x, y);
    }
    static void F5<T, U>(U u) where U : T
    {
        (T,  T)? t5 = (u, default(T)); // 9
        (object, object)? v5 = (default(T), u); // 10
        (object?, object?)? w5 = (default(T), u);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,32): warning CS8619: Nullability of reference types in value of type '(string x, string? y)' doesn't match target type '(string, string)?'.
                //         (string, string)? t1 = (x, y); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(string x, string? y)", "(string, string)?").WithLocation(12, 32),
                // (14,32): warning CS8619: Nullability of reference types in value of type '(object x, object? y)' doesn't match target type '(object, object)?'.
                //         (object, object)? v1 = (x, y); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(object x, object? y)", "(object, object)?").WithLocation(14, 32),
                // (19,38): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object>, A<object>)?'.
                //         (A<object>, A<object>)? t2 = (x, y); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object>, A<object>)?").WithLocation(19, 38),
                // (20,40): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object?>, A<object?>)?'.
                //         (A<object?>, A<object?>)? u2 = (x, y); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object?>, A<object?>)?").WithLocation(20, 40),
                // (21,42): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         (I<object>, I<object>)? v2 = (x, y); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "I<object>").WithLocation(21, 42),
                // (22,41): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         (I<object?>, I<object?>)? w2 = (x, y); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "I<object?>").WithLocation(22, 41),
                // (27,45): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         (IIn<object?>, IIn<object?>)? w3 = (x, y); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object>", "IIn<object?>").WithLocation(27, 45),
                // (31,48): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         (IOut<object>, IOut<object>)? v4 = (x, y); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "IOut<object>").WithLocation(31, 48),
                // (36,23): warning CS8619: Nullability of reference types in value of type '(T u, T)' doesn't match target type '(T, T)?'.
                //         (T,  T)? t5 = (u, default(T)); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(u, default(T))").WithArguments("(T u, T)", "(T, T)?").WithLocation(36, 23),
                // (37,32): warning CS8619: Nullability of reference types in value of type '(object?, object? u)' doesn't match target type '(object, object)?'.
                //         (object, object)? v5 = (default(T), u); // 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(default(T), u)").WithArguments("(object?, object? u)", "(object, object)?").WithLocation(37, 32));
        }

        [Fact]
        public void Conversions_ImplicitTuple()
        {
            var source =
@"#pragma warning disable 0219
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : I<T> { }
class B<T> : IIn<T> { }
class C<T> : IOut<T> { }
class D
{
    static void F1((string x, string?) a1)
    {
        (string, string) t1 = a1; // 1
        (string?, string?) u1 = a1;
        (object, object) v1 = a1; // 2
        (object?, object?) w1 = a1;
    }
    static void F2((A<object> x, A<object?>) a2)
    {
        (A<object>, A<object>) t2 = a2; // 3
        (A<object?>, A<object?>) u2 = a2; // 4
        (I<object>, I<object>) v2 = a2; // 5
        (I<object?>, I<object?>) w2 = a2; // 6
    }
    static void F3((B<object> x, B<object?>) a3)
    {
        (IIn<object>, IIn<object>) v3 = a3;
        (IIn<object?>, IIn<object?>) w3 = a3; // 7
    }
    static void F4((C<object> x, C<object?>) a4)
    {
        (IOut<object>, IOut<object>) v4 = a4; // 8
        (IOut<object?>, IOut<object?>) w4 = a4;
    }
    static void F5<T, U>((U, U) a5) where U : T
    {
        (U, T) t5 = a5;
        (object, object) v5 = a5; // 9
        (object?, object?) w5 = a5;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,31): warning CS8619: Nullability of reference types in value of type '(string x, string?)' doesn't match target type '(string, string)'.
                //         (string, string) t1 = a1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a1").WithArguments("(string x, string?)", "(string, string)").WithLocation(12, 31),
                // (14,31): warning CS8619: Nullability of reference types in value of type '(string x, string?)' doesn't match target type '(object, object)'.
                //         (object, object) v1 = a1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a1").WithArguments("(string x, string?)", "(object, object)").WithLocation(14, 31),
                // (19,37): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(A<object>, A<object>)'.
                //         (A<object>, A<object>) t2 = a2; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("(A<object> x, A<object?>)", "(A<object>, A<object>)").WithLocation(19, 37),
                // (20,39): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(A<object?>, A<object?>)'.
                //         (A<object?>, A<object?>) u2 = a2; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("(A<object> x, A<object?>)", "(A<object?>, A<object?>)").WithLocation(20, 39),
                // (21,37): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(I<object>, I<object>)'.
                //         (I<object>, I<object>) v2 = a2; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("(A<object> x, A<object?>)", "(I<object>, I<object>)").WithLocation(21, 37),
                // (22,39): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(I<object?>, I<object?>)'.
                //         (I<object?>, I<object?>) w2 = a2; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a2").WithArguments("(A<object> x, A<object?>)", "(I<object?>, I<object?>)").WithLocation(22, 39),
                // (27,43): warning CS8619: Nullability of reference types in value of type '(B<object> x, B<object?>)' doesn't match target type '(IIn<object?>, IIn<object?>)'.
                //         (IIn<object?>, IIn<object?>) w3 = a3; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a3").WithArguments("(B<object> x, B<object?>)", "(IIn<object?>, IIn<object?>)").WithLocation(27, 43),
                // (31,43): warning CS8619: Nullability of reference types in value of type '(C<object> x, C<object?>)' doesn't match target type '(IOut<object>, IOut<object>)'.
                //         (IOut<object>, IOut<object>) v4 = a4; // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a4").WithArguments("(C<object> x, C<object?>)", "(IOut<object>, IOut<object>)").WithLocation(31, 43),
                // (37,31): warning CS8619: Nullability of reference types in value of type '(U, U)' doesn't match target type '(object, object)'.
                //         (object, object) v5 = a5; // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a5").WithArguments("(U, U)", "(object, object)").WithLocation(37, 31));
        }

        [Fact]
        public void Conversions_ExplicitTupleLiteral_01()
        {
            var source =
@"#pragma warning disable 0219
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
sealed class A<T> : I<T> { }
sealed class B<T> : IIn<T> { }
sealed class C<T> : IOut<T> { }
class D
{
    static void F1(string x, string? y)
    {
        var t1 = ((string, string))(x, y); // 1
        var u1 = ((string?, string?))(x, y);
        var v1 = ((object, object))(x, y); // 2
        var w1 = ((object?, object?))(x, y);
    }
    static void F2(A<object> x, A<object?> y)
    {
        var t2 = ((A<object>, A<object>))(x, y); // 3
        var u2 = ((A<object?>, A<object?>))(x, y); // 4
        var v2 = ((I<object>, I<object>))(x, y); // 5
        var w2 = ((I<object?>, I<object?>))(x, y); // 6
    }
    static void F3(B<object> x, B<object?> y)
    {
        var v3 = ((IIn<object>, IIn<object>))(x, y);
        var w3 = ((IIn<object?>, IIn<object?>))(x, y); // 7
    }
    static void F4(C<object> x, C<object?> y)
    {
        var v4 = ((IOut<object>, IOut<object>))(x, y); // 8
        var w4 = ((IOut<object?>, IOut<object?>))(x, y);
    }
    static void F5<T, U>(T t) where U : T
    {
        var t5 = ((U, U))(t, default(T)); // 9
        var v5 = ((object, object))(default(T), t); // 10
        var w5 = ((object?, object?))(default(T), t);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,18): warning CS8619: Nullability of reference types in value of type '(string x, string? y)' doesn't match target type '(string, string)'.
                //         var t1 = ((string, string))(x, y); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((string, string))(x, y)").WithArguments("(string x, string? y)", "(string, string)").WithLocation(12, 18),
                // (14,18): warning CS8619: Nullability of reference types in value of type '(object x, object? y)' doesn't match target type '(object, object)'.
                //         var v1 = ((object, object))(x, y); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, object))(x, y)").WithArguments("(object x, object? y)", "(object, object)").WithLocation(14, 18),
                // (14,40): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var v1 = ((object, object))(x, y); // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(14, 40),
                // (19,18): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object>, A<object>)'.
                //         var t2 = ((A<object>, A<object>))(x, y); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((A<object>, A<object>))(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object>, A<object>)").WithLocation(19, 18),
                // (20,18): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?> y)' doesn't match target type '(A<object?>, A<object?>)'.
                //         var u2 = ((A<object?>, A<object?>))(x, y); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((A<object?>, A<object?>))(x, y)").WithArguments("(A<object> x, A<object?> y)", "(A<object?>, A<object?>)").WithLocation(20, 18),
                // (21,46): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         var v2 = ((I<object>, I<object>))(x, y); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "I<object>").WithLocation(21, 46),
                // (22,45): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         var w2 = ((I<object?>, I<object?>))(x, y); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "I<object?>").WithLocation(22, 45),
                // (27,49): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         var w3 = ((IIn<object?>, IIn<object?>))(x, y); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object>", "IIn<object?>").WithLocation(27, 49),
                // (31,52): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         var v4 = ((IOut<object>, IOut<object>))(x, y); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "IOut<object>").WithLocation(31, 52),
                // (36,18): warning CS8619: Nullability of reference types in value of type '(U t, U)' doesn't match target type '(U, U)'.
                //         var t5 = ((U, U))(t, default(T)); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((U, U))(t, default(T))").WithArguments("(U t, U)", "(U, U)").WithLocation(36, 18),
                // (36,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var t5 = ((U, U))(t, default(T)); // 9
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(36, 27),
                // (36,30): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var t5 = ((U, U))(t, default(T)); // 9
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(T)").WithLocation(36, 30),
                // (37,18): warning CS8619: Nullability of reference types in value of type '(object?, object? t)' doesn't match target type '(object, object)'.
                //         var v5 = ((object, object))(default(T), t); // 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, object))(default(T), t)").WithArguments("(object?, object? t)", "(object, object)").WithLocation(37, 18),
                // (37,37): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var v5 = ((object, object))(default(T), t); // 10
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(T)").WithLocation(37, 37),
                // (37,49): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var v5 = ((object, object))(default(T), t); // 10
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(37, 49));
        }

        [Fact]
        public void Conversions_ExplicitTupleLiteral_02()
        {
            var source =
@"#pragma warning disable 0219
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
sealed class A<T> : I<T> { }
sealed class B<T> : IIn<T> { }
sealed class C<T> : IOut<T> { }
class D
{
    static void F1(string x, string? y)
    {
        var t1 = ((string, string)?)(x, y); // 1
        var u1 = ((string?, string?)?)(x, y);
        var v1 = ((object, object)?)(x, y); // 2
        var w1 = ((object?, object?)?)(x, y);
    }
    static void F2(A<object> x, A<object?> y)
    {
        var t2 = ((A<object>, A<object>)?)(x, y); // 3
        var u2 = ((A<object?>, A<object?>)?)(x, y); // 4
        var v2 = ((I<object>, I<object>)?)(x, y); // 5
        var w2 = ((I<object?>, I<object?>)?)(x, y); // 6
    }
    static void F3(B<object> x, B<object?> y)
    {
        var v3 = ((IIn<object>, IIn<object>)?)(x, y);
        var w3 = ((IIn<object?>, IIn<object?>)?)(x, y); // 7
    }
    static void F4(C<object> x, C<object?> y)
    {
        var v4 = ((IOut<object>, IOut<object>)?)(x, y); // 8
        var w4 = ((IOut<object?>, IOut<object?>)?)(x, y);
    }
    static void F5<T, U>(T t) where U : T
    {
        var t5 = ((U, U)?)(t, default(T)); // 9
        var v5 = ((object, object)?)(default(T), t); // 10
        var w5 = ((object?, object?)?)(default(T), t);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,18): warning CS8619: Nullability of reference types in value of type '(string x, string? y)' doesn't match target type '(string, string)?'.
                //         var t1 = ((string, string)?)(x, y); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((string, string)?)(x, y)").WithArguments("(string x, string? y)", "(string, string)?").WithLocation(12, 18),
                // (12,41): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var t1 = ((string, string)?)(x, y); // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(12, 41),
                // (14,18): warning CS8619: Nullability of reference types in value of type '(object x, object? y)' doesn't match target type '(object, object)?'.
                //         var v1 = ((object, object)?)(x, y); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, object)?)(x, y)").WithArguments("(object x, object? y)", "(object, object)?").WithLocation(14, 18),
                // (14,41): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var v1 = ((object, object)?)(x, y); // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(14, 41),
                // (19,47): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'A<object>'.
                //         var t2 = ((A<object>, A<object>)?)(x, y); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "A<object>").WithLocation(19, 47),
                // (20,46): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'A<object?>'.
                //         var u2 = ((A<object?>, A<object?>)?)(x, y); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "A<object?>").WithLocation(20, 46),
                // (21,47): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         var v2 = ((I<object>, I<object>)?)(x, y); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "I<object>").WithLocation(21, 47),
                // (22,46): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         var w2 = ((I<object?>, I<object?>)?)(x, y); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "I<object?>").WithLocation(22, 46),
                // (27,50): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         var w3 = ((IIn<object?>, IIn<object?>)?)(x, y); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object>", "IIn<object?>").WithLocation(27, 50),
                // (31,53): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         var v4 = ((IOut<object>, IOut<object>)?)(x, y); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "IOut<object>").WithLocation(31, 53),
                // (36,18): warning CS8619: Nullability of reference types in value of type '(U t, U)' doesn't match target type '(U, U)?'.
                //         var t5 = ((U, U)?)(t, default(T)); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((U, U)?)(t, default(T))").WithArguments("(U t, U)", "(U, U)?").WithLocation(36, 18),
                // (36,28): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var t5 = ((U, U)?)(t, default(T)); // 9
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(36, 28),
                // (36,31): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var t5 = ((U, U)?)(t, default(T)); // 9
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(T)").WithLocation(36, 31),
                // (37,18): warning CS8619: Nullability of reference types in value of type '(object?, object? t)' doesn't match target type '(object, object)?'.
                //         var v5 = ((object, object)?)(default(T), t); // 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, object)?)(default(T), t)").WithArguments("(object?, object? t)", "(object, object)?").WithLocation(37, 18),
                // (37,38): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var v5 = ((object, object)?)(default(T), t); // 10
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(T)").WithLocation(37, 38),
                // (37,50): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         var v5 = ((object, object)?)(default(T), t); // 10
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(37, 50));
        }

        [Fact]
        public void Conversions_ExplicitTuple()
        {
            var source =
@"#pragma warning disable 0219
interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
sealed class A<T> : I<T> { }
sealed class B<T> : IIn<T> { }
sealed class C<T> : IOut<T> { }
class D
{
    static void F1((string x, string?) a1)
    {
        var t1 = ((string, string))a1; // 1
        var u1 = ((string?, string?))a1;
        var v1 = ((object, object))a1; // 2
        var w1 = ((object?, object?))a1;
    }
    static void F2((A<object> x, A<object?>) a2)
    {
        var t2 = ((A<object>, A<object>))a2; // 3
        var u2 = ((A<object?>, A<object?>))a2; // 4
        var v2 = ((I<object>, I<object>))a2; // 5
        var w2 = ((I<object?>, I<object?>))a2; // 6
    }
    static void F3((B<object> x, B<object?>) a3)
    {
        var v3 = ((IIn<object>, IIn<object>))a3;
        var w3 = ((IIn<object?>, IIn<object?>))a3; // 7
    }
    static void F4((C<object> x, C<object?>) a4)
    {
        var v4 = ((IOut<object>, IOut<object>))a4; // 8
        var w4 = ((IOut<object?>, IOut<object?>))a4;
    }
    static void F5<T, U>((T, T) a5) where U : T
    {
        var t5 = ((U, U))a5;
        var v5 = ((object, object))default((T, T)); // 9
        var w5 = ((object?, object?))default((T, T));
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,18): warning CS8619: Nullability of reference types in value of type '(string x, string?)' doesn't match target type '(string, string)'.
                //         var t1 = ((string, string))a1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((string, string))a1").WithArguments("(string x, string?)", "(string, string)").WithLocation(12, 18),
                // (14,18): warning CS8619: Nullability of reference types in value of type '(string x, string?)' doesn't match target type '(object, object)'.
                //         var v1 = ((object, object))a1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, object))a1").WithArguments("(string x, string?)", "(object, object)").WithLocation(14, 18),
                // (19,18): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(A<object>, A<object>)'.
                //         var t2 = ((A<object>, A<object>))a2; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((A<object>, A<object>))a2").WithArguments("(A<object> x, A<object?>)", "(A<object>, A<object>)").WithLocation(19, 18),
                // (20,18): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(A<object?>, A<object?>)'.
                //         var u2 = ((A<object?>, A<object?>))a2; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((A<object?>, A<object?>))a2").WithArguments("(A<object> x, A<object?>)", "(A<object?>, A<object?>)").WithLocation(20, 18),
                // (21,18): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(I<object>, I<object>)'.
                //         var v2 = ((I<object>, I<object>))a2; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((I<object>, I<object>))a2").WithArguments("(A<object> x, A<object?>)", "(I<object>, I<object>)").WithLocation(21, 18),
                // (22,18): warning CS8619: Nullability of reference types in value of type '(A<object> x, A<object?>)' doesn't match target type '(I<object?>, I<object?>)'.
                //         var w2 = ((I<object?>, I<object?>))a2; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((I<object?>, I<object?>))a2").WithArguments("(A<object> x, A<object?>)", "(I<object?>, I<object?>)").WithLocation(22, 18),
                // (27,18): warning CS8619: Nullability of reference types in value of type '(B<object> x, B<object?>)' doesn't match target type '(IIn<object?>, IIn<object?>)'.
                //         var w3 = ((IIn<object?>, IIn<object?>))a3; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((IIn<object?>, IIn<object?>))a3").WithArguments("(B<object> x, B<object?>)", "(IIn<object?>, IIn<object?>)").WithLocation(27, 18),
                // (31,18): warning CS8619: Nullability of reference types in value of type '(C<object> x, C<object?>)' doesn't match target type '(IOut<object>, IOut<object>)'.
                //         var v4 = ((IOut<object>, IOut<object>))a4; // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((IOut<object>, IOut<object>))a4").WithArguments("(C<object> x, C<object?>)", "(IOut<object>, IOut<object>)").WithLocation(31, 18),
                // (37,18): warning CS8619: Nullability of reference types in value of type '(T, T)' doesn't match target type '(object, object)'.
                //         var v5 = ((object, object))default((T, T)); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, object))default((T, T))").WithArguments("(T, T)", "(object, object)").WithLocation(37, 18));
        }

        [Fact]
        [WorkItem(29966, "https://github.com/dotnet/roslyn/issues/29966")]
        public void Conversions_ImplicitTupleLiteral_ExtensionThis()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : I<T> { }
class B<T> : IIn<T> { }
class C<T> : IOut<T> { }
static class E
{
    static void F1(string x, string? y)
    {
        (x, y).F1A(); // 1
        (x, y).F1B();
    }
    static void F1A(this (object, object) t) { }
    static void F1B(this (object?, object?) t) { }
    static void F2(A<object> x, A<object?> y)
    {
        (x, y).F2A(); // 2
        (x, y).F2B(); // 3
    }
    static void F2A(this (I<object>, I<object>) t) { }
    static void F2B(this (I<object?>, I<object?>) t) { }
    static void F3(B<object> x, B<object?> y)
    {
        (x, y).F3A();
        (x, y).F3B(); // 4
    }
    static void F3A(this (IIn<object>, IIn<object>) t) { }
    static void F3B(this (IIn<object?>, IIn<object?>) t) { }
    static void F4(C<object> x, C<object?> y)
    {
        (x, y).F4A(); // 5
        (x, y).F4B();
    }
    static void F4A(this (IOut<object>, IOut<object>) t) { }
    static void F4B(this (IOut<object?>, IOut<object?>) t) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29966: Report WRN_NullabilityMismatchInArgument rather than ...Assignment.
            comp.VerifyDiagnostics(
                // (11,9): warning CS8620: Nullability of reference types in argument of type '(object x, object? y)' doesn't match target type '(object, object)' for parameter 't' in 'void E.F1A((object, object) t)'.
                //         (x, y).F1A(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(x, y)").WithArguments("(object x, object? y)", "(object, object)", "t", "void E.F1A((object, object) t)").WithLocation(11, 9),
                // (18,13): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         (x, y).F2A(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object?>", "I<object>").WithLocation(18, 13),
                // (19,10): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         (x, y).F2B(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("A<object>", "I<object?>").WithLocation(19, 10),
                // (26,10): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         (x, y).F3B(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "x").WithArguments("B<object>", "IIn<object?>").WithLocation(26, 10),
                // (32,13): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         (x, y).F4A(); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("C<object?>", "IOut<object>").WithLocation(32, 13));
        }

        [Fact]
        public void Conversions_ImplicitTuple_ExtensionThis_01()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : I<T> { }
class B<T> : IIn<T> { }
class C<T> : IOut<T> { }
static class E
{
    static void F1((string x, string?) t1)
    {
        t1.F1A(); // 1
        t1.F1B();
    }
    static void F1A(this (object, object) t) { }
    static void F1B(this (object?, object?) t) { }
    static void F2((A<object>, A<object?>) t2)
    {
        t2.F2A(); // 2
        t2.F2B(); // 3
    }
    static void F2A(this (I<object>, I<object>) t) { }
    static void F2B(this (I<object?>, I<object?>) t) { }
    static void F3((B<object>, B<object?>) t3)
    {
        t3.F3A();
        t3.F3B(); // 4
    }
    static void F3A(this (IIn<object>, IIn<object>) t) { }
    static void F3B(this (IIn<object?>, IIn<object?>) t) { }
    static void F4((C<object>, C<object?>) t4)
    {
        t4.F4A(); // 5
        t4.F4B();
    }
    static void F4A(this (IOut<object>, IOut<object>) t) { }
    static void F4B(this (IOut<object?>, IOut<object?>) t) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,9): warning CS8620: Nullability of reference types in argument of type '(string x, string?)' doesn't match target type '(object, object)' for parameter 't' in 'void E.F1A((object, object) t)'.
                //         t1.F1A(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t1").WithArguments("(string x, string?)", "(object, object)", "t", "void E.F1A((object, object) t)").WithLocation(11, 9),
                // (18,9): warning CS8620: Nullability of reference types in argument of type '(A<object>, A<object?>)' doesn't match target type '(I<object>, I<object>)' for parameter 't' in 'void E.F2A((I<object>, I<object>) t)'.
                //         t2.F2A(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t2").WithArguments("(A<object>, A<object?>)", "(I<object>, I<object>)", "t", "void E.F2A((I<object>, I<object>) t)").WithLocation(18, 9),
                // (19,9): warning CS8620: Nullability of reference types in argument of type '(A<object>, A<object?>)' doesn't match target type '(I<object?>, I<object?>)' for parameter 't' in 'void E.F2B((I<object?>, I<object?>) t)'.
                //         t2.F2B(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t2").WithArguments("(A<object>, A<object?>)", "(I<object?>, I<object?>)", "t", "void E.F2B((I<object?>, I<object?>) t)").WithLocation(19, 9),
                // (26,9): warning CS8620: Nullability of reference types in argument of type '(B<object>, B<object?>)' doesn't match target type '(IIn<object?>, IIn<object?>)' for parameter 't' in 'void E.F3B((IIn<object?>, IIn<object?>) t)'.
                //         t3.F3B(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t3").WithArguments("(B<object>, B<object?>)", "(IIn<object?>, IIn<object?>)", "t", "void E.F3B((IIn<object?>, IIn<object?>) t)").WithLocation(26, 9),
                // (32,9): warning CS8620: Nullability of reference types in argument of type '(C<object>, C<object?>)' doesn't match target type '(IOut<object>, IOut<object>)' for parameter 't' in 'void E.F4A((IOut<object>, IOut<object>) t)'.
                //         t4.F4A(); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t4").WithArguments("(C<object>, C<object?>)", "(IOut<object>, IOut<object>)", "t", "void E.F4A((IOut<object>, IOut<object>) t)").WithLocation(32, 9));
        }

        [Fact]
        public void Conversions_ImplicitTuple_ExtensionThis_02()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
static class E
{
    static void F1((string, string)? t1)
    {
        t1.F1A(); // 1
        t1.F1B();
    }
    static void F1A(this (string?, string?)? t) { }
    static void F1B(this (string, string)? t) { }
    static void F2((I<object?>, I<object?>)? t2)
    {
        t2.F2A();
        t2.F2B(); // 2
    }
    static void F2A(this (I<object?>, I<object?>)? t) { }
    static void F2B(this (I<object>, I<object>)? t) { }
    static void F3((IIn<object?>, IIn<object?>)? t3)
    {
        t3.F3A();
        t3.F3B(); // 3
    }
    static void F3A(this (IIn<object?>, IIn<object?>)? t) { }
    static void F3B(this (IIn<object>, IIn<object>)? t) { }
    static void F4((IOut<object?>, IOut<object?>)? t4)
    {
        t4.F4A();
        t4.F4B(); // 4
    }
    static void F4A(this (IOut<object?>, IOut<object?>)? t) { }
    static void F4B(this (IOut<object>, IOut<object>)? t) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8620: Nullability of reference types in argument of type '(string, string)?' doesn't match target type '(string?, string?)?' for parameter 't' in 'void E.F1A((string?, string?)? t)'.
                //         t1.F1A(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t1").WithArguments("(string, string)?", "(string?, string?)?", "t", "void E.F1A((string?, string?)? t)").WithLocation(8, 9),
                // (16,9): warning CS8620: Nullability of reference types in argument of type '(I<object?>, I<object?>)?' doesn't match target type '(I<object>, I<object>)?' for parameter 't' in 'void E.F2B((I<object>, I<object>)? t)'.
                //         t2.F2B(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t2").WithArguments("(I<object?>, I<object?>)?", "(I<object>, I<object>)?", "t", "void E.F2B((I<object>, I<object>)? t)").WithLocation(16, 9),
                // (23,9): warning CS8620: Nullability of reference types in argument of type '(IIn<object?>, IIn<object?>)?' doesn't match target type '(IIn<object>, IIn<object>)?' for parameter 't' in 'void E.F3B((IIn<object>, IIn<object>)? t)'.
                //         t3.F3B(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t3").WithArguments("(IIn<object?>, IIn<object?>)?", "(IIn<object>, IIn<object>)?", "t", "void E.F3B((IIn<object>, IIn<object>)? t)").WithLocation(23, 9),
                // (30,9): warning CS8620: Nullability of reference types in argument of type '(IOut<object?>, IOut<object?>)?' doesn't match target type '(IOut<object>, IOut<object>)?' for parameter 't' in 'void E.F4B((IOut<object>, IOut<object>)? t)'.
                //         t4.F4B(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t4").WithArguments("(IOut<object?>, IOut<object?>)?", "(IOut<object>, IOut<object>)?", "t", "void E.F4B((IOut<object>, IOut<object>)? t)").WithLocation(30, 9));
        }

        [Fact]
        public void Conversions_ImplicitTuple_ExtensionThis_03()
        {
            var source =
@"static class E
{
    static void F((string, (string, string)?) t)
    {
        t.FA(); // 1
        t.FB();
        FA(t);
        FB(t);
    }
    static void FA(this (object, (string?, string?)?) t) { }
    static void FB(this (object, (string, string)?) t) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8620: Nullability of reference types in argument of type '(string, (string, string)?)' doesn't match target type '(object, (string?, string?)?)' for parameter 't' in 'void E.FA((object, (string?, string?)?) t)'.
                //         t.FA(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t").WithArguments("(string, (string, string)?)", "(object, (string?, string?)?)", "t", "void E.FA((object, (string?, string?)?) t)").WithLocation(5, 9));
        }

        [Fact]
        public void TupleTypeInference_01()
        {
            var source =
@"class C
{
    static (T, T) F<T>((T, T) t) => t;
    static void G(string x, string? y)
    {
        F((x, x)).Item2.ToString();
        F((x, y)).Item2.ToString();
        F((y, x)).Item2.ToString();
        F((y, y)).Item2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         F((x, y)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F((x, y)).Item2").WithLocation(7, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F((y, x)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F((y, x)).Item2").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F((y, y)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F((y, y)).Item2").WithLocation(9, 9));
        }

        [Fact]
        public void TupleTypeInference_02()
        {
            var source =
@"class C
{
    static (T, T) F<T>((T, T?) t) where T : class => (t.Item1, t.Item1);
    static void G(string x, string? y)
    {
        F((x, x)).Item2.ToString();
        F((x, y)).Item2.ToString();
        F((y, x)).Item2.ToString();
        F((y, y)).Item2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>((T, T?))'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         F((y, x)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>((T, T?))", "T", "string?").WithLocation(8, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F((y, x)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F((y, x)).Item2").WithLocation(8, 9),
                // (9,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>((T, T?))'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         F((y, y)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>((T, T?))", "T", "string?").WithLocation(9, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F((y, y)).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F((y, y)).Item2").WithLocation(9, 9));
        }

        [Fact]
        public void TupleTypeInference_03()
        {
            var source =
@"class C
{
    static T F<T>((T, T?) t) where T : class => t.Item1;
    static void G((string, string) x, (string, string?) y, (string?, string) z, (string?, string?) w)
    {
        F(x).ToString();
        F(y).ToString();
        F(z).ToString();
        F(w).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>((T, T?))'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>((T, T?))", "T", "string?").WithLocation(8, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(z)").WithLocation(8, 9),
                // (9,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>((T, T?))'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>((T, T?))", "T", "string?").WithLocation(9, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(w)").WithLocation(9, 9));
        }

        [Fact]
        public void TupleTypeInference_04_Ref()
        {
            var source =
@"class C
{
    static T F<T>(ref (T, T?) t) where T : class => throw new System.Exception();
    static void G(string x, string? y)
    {
        (string, string) t1 = (x, x);
        F(ref t1).ToString();
        (string, string?) t2 = (x, y);
        F(ref t2).ToString();
        (string?, string) t3 = (y, x);
        F(ref t3).ToString();
        (string?, string?) t4 = (y, y);
        F(ref t4).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,15): warning CS8620: Nullability of reference types in argument of type '(string, string)' doesn't match target type '(string, string?)' for parameter 't' in 'string C.F<string>(ref (string, string?) t)'.
                //         F(ref t1).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t1").WithArguments("(string, string)", "(string, string?)", "t", "string C.F<string>(ref (string, string?) t)").WithLocation(7, 15),
                // (11,15): warning CS8620: Nullability of reference types in argument of type '(string?, string)' doesn't match target type '(string, string?)' for parameter 't' in 'string C.F<string>(ref (string, string?) t)'.
                //         F(ref t3).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t3").WithArguments("(string?, string)", "(string, string?)", "t", "string C.F<string>(ref (string, string?) t)").WithLocation(11, 15),
                // (13,15): warning CS8620: Nullability of reference types in argument of type '(string?, string?)' doesn't match target type '(string, string?)' for parameter 't' in 'string C.F<string>(ref (string, string?) t)'.
                //         F(ref t4).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t4").WithArguments("(string?, string?)", "(string, string?)", "t", "string C.F<string>(ref (string, string?) t)").WithLocation(13, 15)
                );
        }

        [Fact]
        public void TupleTypeInference_04_Out()
        {
            var source =
@"class C
{
    static T F<T>(out (T, T?) t) where T : class => throw new System.Exception();
    static void G()
    {
        F(out (string, string) t1).ToString();
        F(out (string, string?) t2).ToString();
        F(out (string?, string) t3).ToString();
        F(out (string?, string?) t4).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,15): warning CS8620: Nullability of reference types in argument of type '(string, string)' doesn't match target type '(string, string?)' for parameter 't' in 'string C.F<string>(out (string, string?) t)'.
                //         F(out (string, string) t1).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(string, string) t1").WithArguments("(string, string)", "(string, string?)", "t", "string C.F<string>(out (string, string?) t)").WithLocation(6, 15),
                // (8,15): warning CS8620: Nullability of reference types in argument of type '(string?, string)' doesn't match target type '(string, string?)' for parameter 't' in 'string C.F<string>(out (string, string?) t)'.
                //         F(out (string?, string) t3).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(string?, string) t3").WithArguments("(string?, string)", "(string, string?)", "t", "string C.F<string>(out (string, string?) t)").WithLocation(8, 15),
                // (9,15): warning CS8620: Nullability of reference types in argument of type '(string?, string?)' doesn't match target type '(string, string?)' for parameter 't' in 'string C.F<string>(out (string, string?) t)'.
                //         F(out (string?, string?) t4).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(string?, string?) t4").WithArguments("(string?, string?)", "(string, string?)", "t", "string C.F<string>(out (string, string?) t)").WithLocation(9, 15)
                );
        }

        [Fact]
        public void TupleTypeInference_05()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(I<(T, T?)> t) where T : class => throw new System.Exception();
    static void G(I<(string, string)> x, I<(string, string?)> y, I<(string?, string)> z, I<(string?, string?)> w)
    {
        F(x).ToString();
        F(y).ToString();
        F(z).ToString();
        F(w).ToString();
    }
    static T F<T>(IIn<(T, T?)> t) where T : class => throw new System.Exception();
    static void G(IIn<(string, string)> x, IIn<(string, string?)> y, IIn<(string?, string)> z, IIn<(string?, string?)> w)
    {
        F(x).ToString();
        F(y).ToString();
        F(z).ToString();
        F(w).ToString();
    }
    static T F<T>(IOut<(T, T?)> t) where T : class => throw new System.Exception();
    static void G(IOut<(string, string)> x, IOut<(string, string?)> y, IOut<(string?, string)> z, IOut<(string?, string?)> w)
    {
        F(x).ToString();
        F(y).ToString();
        F(z).ToString();
        F(w).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,11): warning CS8620: Nullability of reference types in argument of type 'I<(string, string)>' doesn't match target type 'I<(string, string?)>' for parameter 't' in 'string C.F<string>(I<(string, string?)> t)'.
                //         F(x).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("I<(string, string)>", "I<(string, string?)>", "t", "string C.F<string>(I<(string, string?)> t)").WithLocation(9, 11),
                // (11,11): warning CS8620: Nullability of reference types in argument of type 'I<(string?, string)>' doesn't match target type 'I<(string, string?)>' for parameter 't' in 'string C.F<string>(I<(string, string?)> t)'.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("I<(string?, string)>", "I<(string, string?)>", "t", "string C.F<string>(I<(string, string?)> t)").WithLocation(11, 11),
                // (12,11): warning CS8620: Nullability of reference types in argument of type 'I<(string?, string?)>' doesn't match target type 'I<(string, string?)>' for parameter 't' in 'string C.F<string>(I<(string, string?)> t)'.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "w").WithArguments("I<(string?, string?)>", "I<(string, string?)>", "t", "string C.F<string>(I<(string, string?)> t)").WithLocation(12, 11),
                // (17,11): warning CS8620: Nullability of reference types in argument of type 'IIn<(string, string)>' doesn't match target type 'IIn<(string, string?)>' for parameter 't' in 'string C.F<string>(IIn<(string, string?)> t)'.
                //         F(x).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("IIn<(string, string)>", "IIn<(string, string?)>", "t", "string C.F<string>(IIn<(string, string?)> t)").WithLocation(17, 11),
                // (19,11): warning CS8620: Nullability of reference types in argument of type 'IIn<(string?, string)>' doesn't match target type 'IIn<(string, string?)>' for parameter 't' in 'string C.F<string>(IIn<(string, string?)> t)'.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IIn<(string?, string)>", "IIn<(string, string?)>", "t", "string C.F<string>(IIn<(string, string?)> t)").WithLocation(19, 11),
                // (20,11): warning CS8620: Nullability of reference types in argument of type 'IIn<(string?, string?)>' doesn't match target type 'IIn<(string, string?)>' for parameter 't' in 'string C.F<string>(IIn<(string, string?)> t)'.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "w").WithArguments("IIn<(string?, string?)>", "IIn<(string, string?)>", "t", "string C.F<string>(IIn<(string, string?)> t)").WithLocation(20, 11),
                // (25,11): warning CS8620: Nullability of reference types in argument of type 'IOut<(string, string)>' doesn't match target type 'IOut<(string, string?)>' for parameter 't' in 'string C.F<string>(IOut<(string, string?)> t)'.
                //         F(x).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("IOut<(string, string)>", "IOut<(string, string?)>", "t", "string C.F<string>(IOut<(string, string?)> t)").WithLocation(25, 11),
                // (27,11): warning CS8620: Nullability of reference types in argument of type 'IOut<(string?, string)>' doesn't match target type 'IOut<(string, string?)>' for parameter 't' in 'string C.F<string>(IOut<(string, string?)> t)'.
                //         F(z).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IOut<(string?, string)>", "IOut<(string, string?)>", "t", "string C.F<string>(IOut<(string, string?)> t)").WithLocation(27, 11),
                // (28,11): warning CS8620: Nullability of reference types in argument of type 'IOut<(string?, string?)>' doesn't match target type 'IOut<(string, string?)>' for parameter 't' in 'string C.F<string>(IOut<(string, string?)> t)'.
                //         F(w).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "w").WithArguments("IOut<(string?, string?)>", "IOut<(string, string?)>", "t", "string C.F<string>(IOut<(string, string?)> t)").WithLocation(28, 11)
                );
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void TupleTypeInference_06()
        {
            var source =
@"class C
{
    static void F(object? x, object? y)
    {
        if (y != null)
        {
            ((object? x, object? y), object? z) t = ((x, y), y);
            t.Item1.Item1.ToString();
            t.Item1.Item2.ToString();
            t.Item2.ToString();
            t.Item1.x.ToString(); // warning already reported for t.Item1.Item1
            t.Item1.y.ToString(); // warning already reported for t.Item1.Item2
            t.z.ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item1.Item1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item1.Item1").WithLocation(8, 13));
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void TupleTypeInference_07()
        {
            var source =
@"class C
{
    static void F(object? x, object? y)
    {
        if (y != null)
        {
            (object? _1, object? _2, object? _3, object? _4, object? _5, object? _6, object? _7, object? _8, object? _9, object? _10) t = (null, null, null, null, null, null, null, x, null, y);
            t._7.ToString();
            t._8.ToString();
            t.Rest.Item1.ToString(); // warning already reported for t._8
            t.Rest.Item2.ToString();
            t._9.ToString(); // warning already reported for t.Rest.Item2
            t._10.ToString();
            t.Rest.Item3.ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             t._7.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t._7").WithLocation(8, 13),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             t._8.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t._8").WithLocation(9, 13),
                // (11,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item2").WithLocation(11, 13));
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_01()
        {
            var source =
@"class Program
{
    static void F()
    {
        (object? a, string) t = (default, default)/*T:(object?, string?)*/; // 1
        (object, string? b) u = t; // 2
        _ = t/*T:(object? a, string!)*/;
        _ = u/*T:(object!, string? b)*/;
        t.Item1.ToString(); // 3
        t.Item2.ToString(); // 4
        u.Item1.ToString(); // 5
        u.Item2.ToString(); // 6
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,33): warning CS8619: Nullability of reference types in value of type '(object?, string?)' doesn't match target type '(object? a, string)'.
                //         (object? a, string) t = (default, default)/*T:(object?, string?)*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(default, default)").WithArguments("(object?, string?)", "(object? a, string)").WithLocation(5, 33),
                // (6,33): warning CS8619: Nullability of reference types in value of type '(object? a, string)' doesn't match target type '(object, string? b)'.
                //         (object, string? b) u = t; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "t").WithArguments("(object? a, string)", "(object, string? b)").WithLocation(6, 33),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item1").WithLocation(9, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item2.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item2").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item1.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item1").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item2.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item2").WithLocation(12, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_02()
        {
            var source =
@"class Program
{
    static void F(object? x, object y)
    {
        (object x, object? y, object? z) t = (null, x, y)/*T:(object?, object? x, object! y)*/; // 1
        _ = t/*T:(object! x, object? y, object? z)*/;
        t.x.ToString(); // 2
        t.y.ToString(); // 3
        t.z.ToString();
        if (x == null) return;
        (object x, object y) u = (x, default)/*T:(object! x, object?)*/; // 4
        _ = u/*T:(object! x, object! y)*/;
        u.x.ToString();
        u.y.ToString(); // 5
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,46): warning CS8619: Nullability of reference types in value of type '(object?, object? x, object y)' doesn't match target type '(object x, object? y, object? z)'.
                //         (object x, object? y, object? z) t = (null, x, y)/*T:(object?, object? x, object! y)*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(null, x, y)").WithArguments("(object?, object? x, object y)", "(object x, object? y, object? z)").WithLocation(5, 46),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         t.x.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.x").WithLocation(7, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.y.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.y").WithLocation(8, 9),
                // (11,34): warning CS8619: Nullability of reference types in value of type '(object x, object?)' doesn't match target type '(object x, object y)'.
                //         (object x, object y) u = (x, default)/*T:(object! x, object?)*/; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, default)").WithArguments("(object x, object?)", "(object x, object y)").WithLocation(11, 34),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         u.y.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.y").WithLocation(14, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_03()
        {
            var source =
@"class A
{
    internal object? F;
}
class B : A
{
}
class Program
{
    static void F1()
    {
        (A, A?) t1 = (null, new A() { F = 1 }); // 1
        (A x, A? y) u1 = t1;
        u1.x.ToString(); // 2
        u1.y.ToString();
        u1.y.F.ToString();
    }
    static void F2()
    {
        (A, A?) t2 = (null, new B() { F = 2 }); // 3
        (A x, A? y) u2 = t2;
        u2.x.ToString(); // 4
        u2.y.ToString();
        u2.y.F.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29968 Allow conversion to base
            // type to avoid the warning for `u2.y.F.ToString();`.
            comp.VerifyDiagnostics(
                // (12,22): warning CS8619: Nullability of reference types in value of type '(A?, A)' doesn't match target type '(A, A?)'.
                //         (A, A?) t1 = (null, new A() { F = 1 }); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(null, new A() { F = 1 })").WithArguments("(A?, A)", "(A, A?)").WithLocation(12, 22),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         u1.x.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u1.x").WithLocation(14, 9),
                // (20,22): warning CS8619: Nullability of reference types in value of type '(A?, A)' doesn't match target type '(A, A?)'.
                //         (A, A?) t2 = (null, new B() { F = 2 }); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(null, new B() { F = 2 })").WithArguments("(A?, A)", "(A, A?)").WithLocation(20, 22),
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         u2.x.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u2.x").WithLocation(22, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         u2.y.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u2.y.F").WithLocation(24, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_04()
        {
            var source =
@"class Program
{
    static void F(object? x, string? y)
    {
        (object?, string) t = (x, y)/*T:(object? x, string? y)*/; // 1
        (object, string?) u = t; // 2
        t.Item1.ToString(); // 3
        t.Item2.ToString(); // 4
        u.Item1.ToString(); // 5
        u.Item2.ToString(); // 6
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,31): warning CS8619: Nullability of reference types in value of type '(object? x, string? y)' doesn't match target type '(object?, string)'.
                //         (object?, string) t = (x, y)/*T:(object? x, string? y)*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(object? x, string? y)", "(object?, string)").WithLocation(5, 31),
                // (6,31): warning CS8619: Nullability of reference types in value of type '(object?, string)' doesn't match target type '(object, string?)'.
                //         (object, string?) u = t; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "t").WithArguments("(object?, string)", "(object, string?)").WithLocation(6, 31),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item1").WithLocation(7, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item2.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item2").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item1.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item1").WithLocation(9, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item2.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item2").WithLocation(10, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_05()
        {
            var source =
@"class Program
{
    static void F(object x, string? y)
    {
        (object?, string) t = (x, y)/*T:(object! x, string? y)*/; // 1
        (object a, string? b) u = t; // 2
        t.Item1.ToString();
        t.Item2.ToString(); // 3
        u.Item1.ToString();
        u.Item2.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,31): warning CS8619: Nullability of reference types in value of type '(object x, string? y)' doesn't match target type '(object?, string)'.
                //         (object?, string) t = (x, y)/*T:(object! x, string? y)*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(object x, string? y)", "(object?, string)").WithLocation(5, 31),
                // (6,35): warning CS8619: Nullability of reference types in value of type '(object?, string)' doesn't match target type '(object a, string? b)'.
                //         (object a, string? b) u = t; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "t").WithArguments("(object?, string)", "(object a, string? b)").WithLocation(6, 35),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item2.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item2").WithLocation(8, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item2.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item2").WithLocation(10, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_06()
        {
            var source =
@"class Program
{
    static void F(string x, string? y)
    {
        (object, string) t = ((object, string))(x, y)/*T:(object! x, string? y)*/; // 1
        (object a, string?) u = ((string, string?))t;
        (object?, object b) v = ((object?, object))t;
        t.Item1.ToString();
        t.Item2.ToString(); // 2
        u.Item1.ToString();
        u.Item2.ToString(); // 3
        v.Item1.ToString(); // 4
        v.Item2.ToString(); // 5
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/32599: Support explicit conversions (see // 5).
            comp.VerifyDiagnostics(
                // (5,30): warning CS8619: Nullability of reference types in value of type '(object x, string? y)' doesn't match target type '(object, string)'.
                //         (object, string) t = ((object, string))(x, y)/*T:(object! x, string? y)*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "((object, string))(x, y)").WithArguments("(object x, string? y)", "(object, string)").WithLocation(5, 30),
                // (5,52): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (object, string) t = ((object, string))(x, y)/*T:(string? x, string? y)*/; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(5, 52),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item2.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item2").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         v.Item1.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "v.Item1").WithLocation(12, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_07()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class C<T>
{
    internal T F;
}
class Program
{
    static void F<T>(C<T> x, C<T> y)
    {
        if (y.F == null) return;
        var t = (x, y);
        var u = t;
        t.Item1.F.ToString(); // 1
        t.Item2.F.ToString();
        u.Item1.F.ToString(); // 2
        u.Item2.F.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/31395: Nullability of class fields
            // are not inherited on assignment (see t.Item2.F and u.Item2.F).
            comp.VerifyDiagnostics(
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item1.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item1.F").WithLocation(14, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item2.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item2.F").WithLocation(15, 9),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item1.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item1.F").WithLocation(16, 9),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item2.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item2.F").WithLocation(17, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_08()
        {
            var source =
@"class Program
{
    static void F(bool b, object x, object? y)
    {
        (object?, object, object?, object, object?, (object, object?), object, object, object?, object) t =
            (x, x, x, y, y, (y, x), x, x, y, y)/*T:(object!, object!, object!, object?, object?, (object? y, object! x), object!, object!, object?, object?)*/; // 1
        t.Item1.ToString();
        t.Item2.ToString();
        t.Item3.ToString();
        t.Item4.ToString(); // 2
        t.Item5.ToString(); // 3
        t.Item6.Item1.ToString(); // 4
        t.Item6.Item2.ToString();
        t.Item7.ToString();
        if (b)
        {
            t.Item8.ToString();
            t.Item9.ToString(); // 5
            t.Item10.ToString(); // 6
        }
        else
        {
            t.Rest.Item1.ToString();
            t.Rest.Item2.ToString(); // 7
            t.Rest.Item3.ToString(); // 8
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8619: Nullability of reference types in value of type '(object, object, object, object?, object?, (object? y, object x), object, object, object?, object?)' doesn't match target type '(object?, object, object?, object, object?, (object, object?), object, object, object?, object)'.
                //             (x, x, x, y, y, (y, x), x, x, y, y)/*T:(object!, object!, object!, object?, object?, (object? y, object! x), object!, object!, object?, object?)*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, x, x, y, y, (y, x), x, x, y, y)").WithArguments("(object, object, object, object?, object?, (object? y, object x), object, object, object?, object?)", "(object?, object, object?, object, object?, (object, object?), object, object, object?, object)").WithLocation(6, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item4.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item4").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item5.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item5").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item6.Item1.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item6.Item1").WithLocation(12, 9),
                // (18,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item9.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item9").WithLocation(18, 13),
                // (19,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item10.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item10").WithLocation(19, 13),
                // (24,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item2.ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item2").WithLocation(24, 13),
                // (25,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item3.ToString(); // 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item3").WithLocation(25, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_09()
        {
            var source =
@"class Program
{
    static void F(bool b, object x)
    {
        (object?, object, object?, object, object?, (object, object?), object, object, object?, object) t =
            (x, x, x, default, default, default, x, x, default, default)/*T:(object!, object!, object!, object?, object?, (object!, object?), object!, object!, object?, object?)*/; // 1
        t.Item1.ToString();
        t.Item2.ToString();
        t.Item3.ToString();
        t.Item4.ToString(); // 2
        t.Item5.ToString(); // 3
        t.Item6.Item1.ToString(); // 4
        t.Item6.Item2.ToString(); // 5
        t.Item7.ToString();
        if (b)
        {
            t.Item8.ToString();
            t.Item9.ToString(); // 6
            t.Item10.ToString(); // 7
        }
        else
        {
            t.Rest.Item1.ToString();
            t.Rest.Item2.ToString(); // 8
            t.Rest.Item3.ToString(); // 9
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8619: Nullability of reference types in value of type '(object, object, object, object?, object?, (object, object?), object, object, object?, object?)' doesn't match target type '(object?, object, object?, object, object?, (object, object?), object, object, object?, object)'.
                //             (x, x, x, default, default, default, x, x, default, default)/*T:(object!, object!, object!, object?, object?, (object!, object?), object!, object!, object?, object?)*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, x, x, default, default, default, x, x, default, default)").WithArguments("(object, object, object, object?, object?, (object, object?), object, object, object?, object?)", "(object?, object, object?, object, object?, (object, object?), object, object, object?, object)").WithLocation(6, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item4.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item4").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item5.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item5").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item6.Item1.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item6.Item1").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item6.Item2.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item6.Item2").WithLocation(13, 9),
                // (18,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item9.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item9").WithLocation(18, 13),
                // (19,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item10.ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item10").WithLocation(19, 13),
                // (24,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item2.ToString(); // 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item2").WithLocation(24, 13),
                // (25,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item3.ToString(); // 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item3").WithLocation(25, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_10()
        {
            var source =
@"using System;
class Program
{
    static void F(object x, string y)
    {
        (object, string?) t = new ValueTuple<object?, string>(null, """") { Item1 = x }; // 1
        (object?, string) u = new ValueTuple<object?, string>() { Item2 = y };
        t.Item1.ToString();
        t.Item2.ToString();
        u.Item1.ToString(); // 2
        u.Item1.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,31): warning CS8619: Nullability of reference types in value of type '(object?, string)' doesn't match target type '(object, string?)'.
                //         (object, string?) t = new ValueTuple<object?, string>(null, "") { Item1 = x }; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, @"new ValueTuple<object?, string>(null, """") { Item1 = x }").WithArguments("(object?, string)", "(object, string?)").WithLocation(6, 31),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item1").WithLocation(10, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_11()
        {
            var source =
@"using System;
class Program
{
    static void F(bool b, object x, object? y)
    {
        var t = new ValueTuple<object?, object, object?, object, object?, ValueTuple<object, object?>, object, ValueTuple<object, object?, object>>(
            x,
            x,
            x,
            y, // 1
            y,
            new ValueTuple<object, object?>(y, x), // 2
            x,
            new ValueTuple<object, object?, object>(x, y, y))/*T:(object?, object!, object?, object!, object?, (object!, object?), object!, object!, object?, object!)*/; // 3
        t.Item1.ToString();
        t.Item2.ToString();
        t.Item3.ToString();
        t.Item4.ToString(); // 4
        t.Item5.ToString(); // 5
        t.Item6.Item1.ToString(); // 6
        t.Item6.Item2.ToString();
        t.Item7.ToString();
        if (b)
        {
            t.Item8.ToString();
            t.Item9.ToString(); // 7
            t.Item10.ToString(); // 8
        }
        else
        {
            t.Rest.Item1.ToString();
            t.Rest.Item2.ToString(); // 9
            t.Rest.Item3.ToString(); // 10
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8604: Possible null reference argument for parameter 'item4' in '(object?, object, object?, object, object?, (object, object?), object, object, object?, object).(object? item1, object item2, object? item3, object item4, object? item5, (object, object?) item6, object item7, (object, object?, object) rest)'.
                //             y, // 1
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("item4", "(object?, object, object?, object, object?, (object, object?), object, object, object?, object).(object? item1, object item2, object? item3, object item4, object? item5, (object, object?) item6, object item7, (object, object?, object) rest)").WithLocation(10, 13),
                // (12,45): warning CS8604: Possible null reference argument for parameter 'item1' in '(object, object?).(object item1, object? item2)'.
                //             new ValueTuple<object, object?>(y, x), // 2
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("item1", "(object, object?).(object item1, object? item2)").WithLocation(12, 45),
                // (14,59): warning CS8604: Possible null reference argument for parameter 'item3' in '(object, object?, object).(object item1, object? item2, object item3)'.
                //             new ValueTuple<object, object?, object>(x, y, y))/*T:(object?, object!, object?, object!, object?, (object!, object?), object!, object!, object?, object!)*/; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("item3", "(object, object?, object).(object item1, object? item2, object item3)").WithLocation(14, 59),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item4.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item4").WithLocation(18, 9),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item5.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item5").WithLocation(19, 9),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item6.Item1.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item6.Item1").WithLocation(20, 9),
                // (26,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item9.ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item9").WithLocation(26, 13),
                // (27,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item10.ToString(); // 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item10").WithLocation(27, 13),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item2.ToString(); // 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item2").WithLocation(32, 13),
                // (33,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item3.ToString(); // 10
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item3").WithLocation(33, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_12()
        {
            var source =
@"using System;
class Program
{
    static void F(bool b, object x)
    {
        var t = new ValueTuple<object?, object, object?, object, object?, ValueTuple<object, object?>, object, ValueTuple<object, object?, object>>(
            x,
            x,
            x,
            default, // 1
            default,
            default,
            x,
            default)/*T:(object?, object!, object?, object!, object?, (object!, object?), object!, object!, object?, object!)*/;
        t.Item1.ToString();
        t.Item2.ToString();
        t.Item3.ToString();
        t.Item4.ToString(); // 2
        t.Item5.ToString(); // 3
        t.Item6.Item1.ToString(); // 4
        t.Item6.Item2.ToString(); // 5
        t.Item7.ToString();
        if (b)
        {
            t.Item8.ToString(); // 6
            t.Item9.ToString(); // 7
            t.Item10.ToString(); // 8
        }
        else
        {
            t.Rest.Item1.ToString(); // 9
            t.Rest.Item2.ToString(); // 10
            t.Rest.Item3.ToString(); // 11
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             default, // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(10, 13),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item4.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item4").WithLocation(18, 9),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item5.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item5").WithLocation(19, 9),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item6.Item1.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item6.Item1").WithLocation(20, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item6.Item2.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item6.Item2").WithLocation(21, 9),
                // (25,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item8.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item8").WithLocation(25, 13),
                // (26,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item9.ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item9").WithLocation(26, 13),
                // (27,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item10.ToString(); // 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item10").WithLocation(27, 13),
                // (31,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item1.ToString(); // 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item1").WithLocation(31, 13),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item2.ToString(); // 10
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item2").WithLocation(32, 13),
                // (33,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item3.ToString(); // 11
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item3").WithLocation(33, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_13()
        {
            var source =
@"using System;
class Program
{
    static void F(bool b, object x, object? y)
    {
        var t = new ValueTuple<object?, object, object?, object, object?, (object, object?), object, (object, object?, object)>(
            x,
            x,
            x,
            y, // 1
            y,
            (y, x), // 2
            x,
            (x, y, y))/*T:(object?, object!, object?, object!, object?, (object!, object?), object!, object!, object?, object!)*/; // 3
        t.Item1.ToString();
        t.Item2.ToString();
        t.Item3.ToString();
        t.Item4.ToString(); // 4
        t.Item5.ToString(); // 5
        t.Item6.Item1.ToString(); // 6
        t.Item6.Item2.ToString();
        t.Item7.ToString();
        if (b)
        {
            t.Item8.ToString();
            t.Item9.ToString(); // 7
            t.Item10.ToString(); // 8
        }
        else
        {
            t.Rest.Item1.ToString();
            t.Rest.Item2.ToString(); // 9
            t.Rest.Item3.ToString(); // 10
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8604: Possible null reference argument for parameter 'item4' in '(object?, object, object?, object, object?, (object, object?), object, object, object?, object).(object? item1, object item2, object? item3, object item4, object? item5, (object, object?) item6, object item7, (object, object?, object) rest)'.
                //             y, // 1
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("item4", "(object?, object, object?, object, object?, (object, object?), object, object, object?, object).(object? item1, object item2, object? item3, object item4, object? item5, (object, object?) item6, object item7, (object, object?, object) rest)").WithLocation(10, 13),
                // (12,13): warning CS8620: Nullability of reference types in argument of type '(object? y, object x)' doesn't match target type '(object, object?)' for parameter 'item6' in '(object?, object, object?, object, object?, (object, object?), object, object, object?, object).(object? item1, object item2, object? item3, object item4, object? item5, (object, object?) item6, object item7, (object, object?, object) rest)'.
                //             (y, x), // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, x)").WithArguments("(object? y, object x)", "(object, object?)", "item6", "(object?, object, object?, object, object?, (object, object?), object, object, object?, object).(object? item1, object item2, object? item3, object item4, object? item5, (object, object?) item6, object item7, (object, object?, object) rest)").WithLocation(12, 13),
                // (14,13): warning CS8620: Nullability of reference types in argument of type '(object x, object?, object?)' doesn't match target type '(object, object?, object)' for parameter 'rest' in '(object?, object, object?, object, object?, (object, object?), object, object, object?, object).(object? item1, object item2, object? item3, object item4, object? item5, (object, object?) item6, object item7, (object, object?, object) rest)'.
                //             (x, y, y))/*T:(object?, object!, object?, object!, object?, (object!, object?), object!, object!, object?, object!)*/; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(x, y, y)").WithArguments("(object x, object?, object?)", "(object, object?, object)", "rest", "(object?, object, object?, object, object?, (object, object?), object, object, object?, object).(object? item1, object item2, object? item3, object item4, object? item5, (object, object?) item6, object item7, (object, object?, object) rest)").WithLocation(14, 13),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item4.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item4").WithLocation(18, 9),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item5.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item5").WithLocation(19, 9),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item6.Item1.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item6.Item1").WithLocation(20, 9),
                // (26,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item9.ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item9").WithLocation(26, 13),
                // (27,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item10.ToString(); // 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item10").WithLocation(27, 13),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item2.ToString(); // 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item2").WithLocation(32, 13),
                // (33,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item3.ToString(); // 10
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item3").WithLocation(33, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_14()
        {
            var source =
@"using System;
class Program
{
    static void F(bool b, object x)
    {
        var t = new ValueTuple<object?, object, object?, object, object?, (object, object?), object, (object, object?, object)>(
            x,
            x,
            x,
            default, // 1
            default,
            default,
            x,
            default)/*T:(object?, object!, object?, object!, object?, (object!, object?), object!, object!, object?, object!)*/;
        t.Item1.ToString();
        t.Item2.ToString();
        t.Item3.ToString();
        t.Item4.ToString(); // 2
        t.Item5.ToString(); // 3
        t.Item6.Item1.ToString(); // 4
        t.Item6.Item2.ToString(); // 5
        t.Item7.ToString();
        if (b)
        {
            t.Item8.ToString(); // 6
            t.Item9.ToString(); // 7
            t.Item10.ToString(); // 8
        }
        else
        {
            t.Rest.Item1.ToString(); // 9
            t.Rest.Item2.ToString(); // 10
            t.Rest.Item3.ToString(); // 11
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             default, // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(10, 13),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item4.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item4").WithLocation(18, 9),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item5.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item5").WithLocation(19, 9),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item6.Item1.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item6.Item1").WithLocation(20, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item6.Item2.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item6.Item2").WithLocation(21, 9),
                // (25,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item8.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item8").WithLocation(25, 13),
                // (26,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item9.ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item9").WithLocation(26, 13),
                // (27,13): warning CS8602: Possible dereference of a null reference.
                //             t.Item10.ToString(); // 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item10").WithLocation(27, 13),
                // (31,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item1.ToString(); // 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item1").WithLocation(31, 13),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item2.ToString(); // 10
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item2").WithLocation(32, 13),
                // (33,13): warning CS8602: Possible dereference of a null reference.
                //             t.Rest.Item3.ToString(); // 11
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Rest.Item3").WithLocation(33, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_15()
        {
            var source =
@"using System;
class Program
{
    static void F(object x, string? y)
    {
        var t = new ValueTuple<object?, string>(1);
        var u = new ValueTuple<object?, string>(null, null, 3);
        t.Item1.ToString(); // 1
        t.Item2.ToString();
        u.Item1.ToString(); // 2
        u.Item1.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,21): error CS7036: There is no argument given that corresponds to the required formal parameter 'item2' of '(object?, string).(object?, string)'
                //         var t = new ValueTuple<object?, string>(1);
                Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "ValueTuple<object?, string>").WithArguments("item2", "(object?, string).(object?, string)").WithLocation(6, 21),
                // (7,21): error CS1729: '(object?, string)' does not contain a constructor that takes 3 arguments
                //         var u = new ValueTuple<object?, string>(null, null, 3);
                Diagnostic(ErrorCode.ERR_BadCtorArgCount, "ValueTuple<object?, string>").WithArguments("(object?, string)", "3").WithLocation(7, 21),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item1").WithLocation(8, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item1").WithLocation(10, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_16()
        {
            var source =
@"class Program
{
    static object F(object? x, object y, string z, string w)
    {
        throw null;
    }
    static void G(bool b, string s, (string?, string?) t)
    {
        (string? x, string? y) u;
        (string? x, string? y) v;
        _ = b ?
            F(
                t.Item1 = s,
                u = t,
                u.x.ToString(),
                u.y.ToString()) : // 1
            F(
                t.Item2 = s,
                v = t,
                v.x.ToString(), // 2
                v.y.ToString());
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (16,17): warning CS8602: Possible dereference of a null reference.
                //                 u.y.ToString()) : // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.y").WithLocation(16, 17),
                // (20,17): warning CS8602: Possible dereference of a null reference.
                //                 v.x.ToString(), // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "v.x").WithLocation(20, 17));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_17()
        {
            var source =
@"class C
{
    (object x, (string? z, object w) y) F;
    static void M(C c, (object? x, (string z, object? w) y) t)
    {
        c.F = t; // 1
        (object, (string?, object)) u = c.F/*T:(object! x, (string? z, object! w) y)*/;
        c.F.x.ToString(); // 2
        c.F.y.z.ToString();
        c.F.y.w.ToString(); // 3
        u.Item1.ToString(); // 4
        u.Item2.Item1.ToString();
        u.Item2.Item2.ToString(); // 5
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,15): warning CS8619: Nullability of reference types in value of type '(object? x, (string z, object? w) y)' doesn't match target type '(object x, (string? z, object w) y)'.
                //         c.F = t; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "t").WithArguments("(object? x, (string z, object? w) y)", "(object x, (string? z, object w) y)").WithLocation(6, 15),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.F.x.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.F.x").WithLocation(8, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         c.F.y.w.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.F.y.w").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item1.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item1").WithLocation(11, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item2.Item2.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item2.Item2").WithLocation(13, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(32531, "https://github.com/dotnet/roslyn/issues/32531")]
        public void Tuple_Assignment_18()
        {
            var source =
@"class Program
{
    static void F(string s)
    {
        (object, object?)? t = (null, s); // 1
        (object?, object?) u = t.Value;
        t.Value.Item1.ToString(); // 2
        t.Value.Item2.ToString();
        u.Item1.ToString(); // 3
        u.Item2.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,32): warning CS8619: Nullability of reference types in value of type '(object?, object s)' doesn't match target type '(object, object?)?'.
                //         (object, object?)? t = (null, s); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(null, s)").WithArguments("(object?, object s)", "(object, object?)?").WithLocation(5, 32),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         t.Value.Item1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Value.Item1").WithLocation(7, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item1").WithLocation(9, 9));
        }

        [Fact]
        public void Tuple_Assignment_19()
        {
            var source =
@"class C
{
    static void F()
    {
        (string, string?) t = t;
        t.Item1.ToString();
        t.Item2.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,31): error CS0165: Use of unassigned local variable 't'
                //         (string, string?) t = t;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "t").WithArguments("t").WithLocation(5, 31));
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        public void Tuple_Assignment_20()
        {
            var source =
@"class C
{
    static void G(object? x, object? y)
    {
        F = (x, y);
    }
    static (object?, object?) G()
    {
        return ((object?, object?))F;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): error CS0103: The name 'F' does not exist in the current context
                //         F = (x, y);
                Diagnostic(ErrorCode.ERR_NameNotInContext, "F").WithArguments("F").WithLocation(5, 9),
                // (9,36): error CS0103: The name 'F' does not exist in the current context
                //         return ((object?, object?))F;
                Diagnostic(ErrorCode.ERR_NameNotInContext, "F").WithArguments("F").WithLocation(9, 36));
        }

        [Fact]
        [WorkItem(32338, "https://github.com/dotnet/roslyn/issues/32338")]
        public void CopyStructUnconstrainedFieldNullability_01()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
}
class Program
{
    static void M<T>(T t)
    {
        var x = new S<T>() { F = t };
        var y = x;
        y.F.ToString(); // 1
        if (t == null) return;
        x = new S<T>() { F = t };
        var z = x;
        z.F.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(12, 9));
        }

        [Fact]
        [WorkItem(32338, "https://github.com/dotnet/roslyn/issues/32338")]
        public void CopyStructUnconstrainedFieldNullability_02()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
}
class Program
{
    static void M<T>(S<T> x)
    {
        var y = x;
        y.F.ToString(); // 1
        if (x.F == null) return;
        var z = x;
        z.F.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(11, 9));
        }

        [Fact]
        [WorkItem(29970, "https://github.com/dotnet/roslyn/issues/29970")]
        [WorkItem(32338, "https://github.com/dotnet/roslyn/issues/32338")]
        public void CopyTupleUnconstrainedElementNullability_01()
        {
            var source =
@"class Program
{
    static void M<T, U>(T t, U u)
    {
        var x = (t, u);
        var y = x;
        y.Item1.ToString(); // 1
        if (t == null) return;
        x = (t, u);
        var z = x;
        z.Item1.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         y.Item1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.Item1").WithLocation(7, 9));
        }

        [Fact]
        [WorkItem(32338, "https://github.com/dotnet/roslyn/issues/32338")]
        public void CopyTupleUnconstrainedElementNullability_02()
        {
            var source =
@"class Program
{
    static void M<T, U>((T, U) x)
    {
        var y = x;
        y.Item1.ToString(); // 1
        if (x.Item1 == null) return;
        var z = x;
        z.Item1.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         y.Item1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.Item1").WithLocation(6, 9));
        }

        [Fact]
        [WorkItem(32703, "https://github.com/dotnet/roslyn/issues/32703")]
        [WorkItem(31395, "https://github.com/dotnet/roslyn/issues/31395")]
        public void CopyClassFields()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class C
{
    internal object? F;
    internal object G;
}
class Program
{
    static void F(C x)
    {
        if (x.F == null) return;
        if (x.G != null) return;
        C y = x;
        x.F.ToString();
        x.G.ToString(); // 1
        y.F.ToString();
        y.G.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/32703: Not inferring nullability of non-nullable value compared to null (see // 1).
            // https://github.com/dotnet/roslyn/issues/31395: Nullability of class members should be copied on assignment (see // 2).
            comp.VerifyDiagnostics(
                // (13,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (x.G != null) return;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "x.G != null").WithLocation(13, 13),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(17, 9));
        }

        [Fact]
        [WorkItem(32703, "https://github.com/dotnet/roslyn/issues/32703")]
        public void CopyStructFields()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    internal object? F;
    internal object G;
}
class Program
{
    static void F(S x)
    {
        if (x.F == null) return;
        if (x.G != null) return;
        S y = x;
        x.F.ToString();
        x.G.ToString(); // 1
        y.F.ToString();
        y.G.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/32703: Not inferring nullability of non-nullable value compared to null (see // 1, 2).
            comp.VerifyDiagnostics(
                // (12,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (x.G != null) return;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "x.G != null").WithLocation(12, 13));
        }

        [Fact]
        [WorkItem(32703, "https://github.com/dotnet/roslyn/issues/32703")]
        public void CopyNullableStructFields()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    internal object? F;
    internal object G;
}
class Program
{
    static void F(S? x)
    {
        if (x == null) return;
        if (x.Value.F == null) return;
        if (x.Value.G != null) return;
        S? y = x;
        x.Value.F.ToString();
        x.Value.G.ToString(); // 1
        y.Value.F.ToString();
        y.Value.G.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/32703: Not inferring nullability of non-nullable value compared to null (see //1, 2).
            comp.VerifyDiagnostics(
                // (13,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (x.Value.G != null) return;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "x.Value.G != null").WithLocation(13, 13));
        }

        [Fact]
        [WorkItem(32531, "https://github.com/dotnet/roslyn/issues/32531")]
        public void Conversions_ImplicitNullable_01()
        {
            var source =
@"struct S
{
    internal object? F;
    internal object G;
}
class Program
{
    static void F()
    {
        S? x = new S() { F = 1, G = null }; // 1
        S? y = x;
        x.Value.F.ToString();
        x.Value.G.ToString(); // 2
        y.Value.F.ToString();
        y.Value.G.ToString(); // 3
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,37): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         S? x = new S() { F = 1, G = null }; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(10, 37),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         x.Value.G.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.Value.G").WithLocation(13, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         y.Value.G.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.Value.G").WithLocation(15, 9));
        }

        [Fact]
        [WorkItem(32531, "https://github.com/dotnet/roslyn/issues/32531")]
        public void Conversions_ImplicitNullable_02()
        {
            var source =
@"class Program
{
    static void F(int? x)
    {
        long? y = x;
        if (x == null) return;
        long? z = x;
        x.Value.ToString();
        y.Value.ToString(); // 1
        z.Value.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,9): warning CS8629: Nullable value type may be null.
                //         y.Value.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Value").WithLocation(9, 9));
        }

        [Fact]
        [WorkItem(32531, "https://github.com/dotnet/roslyn/issues/32531")]
        public void Conversions_ImplicitNullable_03()
        {
            var source =
@"class Program
{
    static void F(int x)
    {
        int? y = x;
        long? z = x;
        y.Value.ToString();
        z.Value.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(32531, "https://github.com/dotnet/roslyn/issues/32531")]
        public void Conversions_ImplicitNullable_04()
        {
            var source =
@"class Program
{
    static void F1(long x1)
    {
        int? y1 = x1; // 1
        y1.Value.ToString();
    }
    static void F2(long? x2)
    {
        int? y2 = x2; // 2
        y2.Value.ToString(); // 3
    }
    static void F3(long? x3)
    {
        if (x3 == null) return;
        int? y3 = x3; // 4
        y3.Value.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,19): error CS0266: Cannot implicitly convert type 'long' to 'int?'. An explicit conversion exists (are you missing a cast?)
                //         int? y1 = x1; // 1
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x1").WithArguments("long", "int?").WithLocation(5, 19),
                // (10,19): error CS0266: Cannot implicitly convert type 'long?' to 'int?'. An explicit conversion exists (are you missing a cast?)
                //         int? y2 = x2; // 2
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x2").WithArguments("long?", "int?").WithLocation(10, 19),
                // (11,9): warning CS8629: Nullable value type may be null.
                //         y2.Value.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y2.Value").WithLocation(11, 9),
                // (16,19): error CS0266: Cannot implicitly convert type 'long?' to 'int?'. An explicit conversion exists (are you missing a cast?)
                //         int? y3 = x3; // 4
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x3").WithArguments("long?", "int?").WithLocation(16, 19));
        }

        [Fact]
        [WorkItem(32531, "https://github.com/dotnet/roslyn/issues/32531")]
        public void Conversions_ImplicitNullable_05()
        {
            var source =
@"#pragma warning disable 0649
struct A
{
    internal object? F;
}
struct B
{
    internal object? F;
}
class Program
{
    static void F1()
    {
        A a1 = new A();
        B? b1 = a1; // 1
        _ = b1.Value;
        b1.Value.F.ToString(); // 2
    }
    static void F2()
    {
        A? a2 = new A() { F = 2 };
        B? b2 = a2; // 3
        _ = b2.Value;
        b2.Value.F.ToString(); // 4
    }
    static void F3(A? a3)
    {
        B? b3 = a3; // 5
        _ = b3.Value; // 6
        b3.Value.F.ToString(); // 7
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,17): error CS0029: Cannot implicitly convert type 'A' to 'B?'
                //         B? b1 = a1; // 1
                Diagnostic(ErrorCode.ERR_NoImplicitConv, "a1").WithArguments("A", "B?").WithLocation(15, 17),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         b1.Value.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b1.Value.F").WithLocation(17, 9),
                // (22,17): error CS0029: Cannot implicitly convert type 'A?' to 'B?'
                //         B? b2 = a2; // 3
                Diagnostic(ErrorCode.ERR_NoImplicitConv, "a2").WithArguments("A?", "B?").WithLocation(22, 17),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         b2.Value.F.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b2.Value.F").WithLocation(24, 9),
                // (28,17): error CS0029: Cannot implicitly convert type 'A?' to 'B?'
                //         B? b3 = a3; // 5
                Diagnostic(ErrorCode.ERR_NoImplicitConv, "a3").WithArguments("A?", "B?").WithLocation(28, 17),
                // (29,13): warning CS8629: Nullable value type may be null.
                //         _ = b3.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "b3.Value").WithLocation(29, 13),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         b3.Value.F.ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b3.Value.F").WithLocation(30, 9));
        }

        [Fact]
        [WorkItem(32531, "https://github.com/dotnet/roslyn/issues/32531")]
        public void Conversions_ExplicitNullable_01()
        {
            var source =
@"struct S
{
    internal object? F;
    internal object G;
}
class Program
{
    static void F()
    {
        S x = new S() { F = 1, G = null }; // 1
        var y = (S?)x;
        y.Value.F.ToString();
        y.Value.G.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,36): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         S x = new S() { F = 1, G = null }; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(10, 36),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.Value.G.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.Value.G").WithLocation(13, 9));
        }

        [Fact]
        [WorkItem(32531, "https://github.com/dotnet/roslyn/issues/32531")]
        public void Conversions_ExplicitNullable_02()
        {
            var source =
@"struct S
{
    internal object? F;
    internal object G;
}
class Program
{
    static void F()
    {
        S? x = new S() { F = 1, G = null }; // 1
        S y = (S)x;
        y.F.ToString();
        y.G.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,37): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         S? x = new S() { F = 1, G = null }; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(10, 37),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.G.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.G").WithLocation(13, 9));
        }

        [Fact]
        [WorkItem(32531, "https://github.com/dotnet/roslyn/issues/32531")]
        public void Conversions_ExplicitNullable_03()
        {
            var source =
@"class Program
{
    static void F(int? x)
    {
        long? y = (long?)x;
        if (x == null) return;
        long? z = (long?)x;
        x.Value.ToString();
        y.Value.ToString(); // 1
        z.Value.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,9): warning CS8629: Nullable value type may be null.
                //         y.Value.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Value").WithLocation(9, 9));
        }

        [Fact]
        [WorkItem(32531, "https://github.com/dotnet/roslyn/issues/32531")]
        public void Conversions_ExplicitNullable_04()
        {
            var source =
@"class Program
{
    static void F(long? x)
    {
        int? y = (int?)x;
        if (x == null) return;
        int? z = (int?)x;
        x.Value.ToString();
        y.Value.ToString(); // 1
        z.Value.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,9): warning CS8629: Nullable value type may be null.
                //         y.Value.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Value").WithLocation(9, 9));
        }

        [Fact]
        [WorkItem(32531, "https://github.com/dotnet/roslyn/issues/32531")]
        public void Conversions_ExplicitNullable_05()
        {
            var source =
@"class Program
{
    static void F1(int? x1)
    {
        int y1 = (int)x1; // 1
    }
    static void F2(int? x2)
    {
        if (x2 == null) return;
        int y2 = (int)x2;
    }
    static void F3(int? x3)
    {
        long y3 = (long)x3; // 2
    }
    static void F4(int? x4)
    {
        if (x4 == null) return;
        long y4 = (long)x4;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,18): warning CS8629: Nullable value type may be null.
                //         int y1 = (int)x1; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(int)x1").WithLocation(5, 18),
                // (14,19): warning CS8629: Nullable value type may be null.
                //         long y3 = (long)x3; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(long)x3").WithLocation(14, 19));
        }

        [Fact]
        [WorkItem(32531, "https://github.com/dotnet/roslyn/issues/32531")]
        public void Tuple_Conversions_ImplicitNullable_01()
        {
            var source =
@"struct S
{
    internal object? F;
}
class Program
{
    static void F()
    {
        S x = new S();
        S y = new S() { F = 1 };
        (S, S) t = (x, y);
        (S? x, S? y) u = t;
        (S?, S?) v = (x, y);
        t.Item1.F.ToString(); // 1
        t.Item2.F.ToString();
        u.x.Value.F.ToString(); // 2
        u.y.Value.F.ToString();
        v.Item1.Value.F.ToString(); // 3
        v.Item2.Value.F.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/32599: Support implicit tuple conversions
            // (should report warnings for dereferences of F in // 1, 2, 3 only).
            comp.VerifyDiagnostics(
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item1.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item1.F").WithLocation(14, 9),
                // (16,9): warning CS8629: Nullable value type may be null.
                //         u.x.Value.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "u.x.Value").WithLocation(16, 9),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         u.x.Value.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.x.Value.F").WithLocation(16, 9),
                // (17,9): warning CS8629: Nullable value type may be null.
                //         u.y.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "u.y.Value").WithLocation(17, 9),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         u.y.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.y.Value.F").WithLocation(17, 9),
                // (18,9): warning CS8629: Nullable value type may be null.
                //         v.Item1.Value.F.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "v.Item1.Value").WithLocation(18, 9),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         v.Item1.Value.F.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "v.Item1.Value.F").WithLocation(18, 9),
                // (19,9): warning CS8629: Nullable value type may be null.
                //         v.Item2.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "v.Item2.Value").WithLocation(19, 9),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         v.Item2.Value.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "v.Item2.Value.F").WithLocation(19, 9));
        }

        [Fact]
        [WorkItem(32599, "https://github.com/dotnet/roslyn/issues/32599")]
        public void Tuple_Conversions_ImplicitNullable_02()
        {
            var source =
@"struct S
{
    internal object? F;
}
class Program
{
    static void F()
    {
        S x = new S();
        S y = new S() { F = 1 };
        (S, S) t = (x, y);
        (S a, S b)? u = t;
        t.Item1.F.ToString(); // 1
        t.Item2.F.ToString();
        u.Value.a.F.ToString(); // 2
        u.Value.b.F.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item1.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item1.F").WithLocation(13, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         u.Value.a.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Value.a.F").WithLocation(15, 9));
        }

        [Fact]
        [WorkItem(32599, "https://github.com/dotnet/roslyn/issues/32599")]
        public void Tuple_Conversions_ImplicitReference()
        {
            var source =
@"class Program
{
    static void F(string x, string? y)
    {
        (object?, string?) t = (x, y);
        (object? a, object? b) u = t;
        t.Item1.ToString();
        t.Item2.ToString(); // 1
        u.a.ToString();
        u.b.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item2").WithLocation(8, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         u.b.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.b").WithLocation(10, 9));
        }

        [Fact]
        [WorkItem(32599, "https://github.com/dotnet/roslyn/issues/32599")]
        public void Tuple_Conversions_ImplicitDynamic()
        {
            var source =
@"class Program
{
    static void F(object x, object? y)
    {
        (object?, dynamic?) t = (x, y);
        (dynamic? a, object? b) u = t;
        t.Item1.ToString();
        t.Item2.ToString(); // 1
        u.a.ToString();
        u.b.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item2").WithLocation(8, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         u.b.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.b").WithLocation(10, 9));
        }

        [Fact]
        [WorkItem(32599, "https://github.com/dotnet/roslyn/issues/32599")]
        public void Tuple_Conversions_Boxing()
        {
            var source =
@"class Program
{
    static void F<T, U, V>(T x, U y, V? z)
        where U : struct
        where V : struct
    {
        (object, object, object) t = (x, y, z); // 1
        t.Item1.ToString(); // 2
        t.Item2.ToString();
        t.Item3.ToString(); // 3
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/32599: Support implicit tuple conversions
            comp.VerifyDiagnostics(
                // (7,38): warning CS8619: Nullability of reference types in value of type '(object? x, object y, object? z)' doesn't match target type '(object, object, object)'.
                //         (object, object, object) t = (x, y, z); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y, z)").WithArguments("(object? x, object y, object? z)", "(object, object, object)").WithLocation(7, 38));
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void StructField_Default_01()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
}
class Program
{
    static void F<T, U, V>()
        where U : class
        where V : struct
    {
        default(S<T>).F/*T:T*/.ToString(); // 1
        default(S<U>).F/*T:U?*/.ToString(); // 2
        _ = default(S<V?>).F/*T:V?*/.Value; // 3
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         default(S<T>).F/*T:T*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "default(S<T>).F").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         default(S<U>).F/*T:U?*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "default(S<U>).F").WithLocation(13, 9),
                // (14,13): warning CS8629: Nullable value type may be null.
                //         _ = default(S<V?>).F/*T:V?*/.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "default(S<V?>).F/*T:V?*/.Value").WithLocation(14, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void StructField_Default_02()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
}
class Program
{
    static void F<T, U, V>()
        where U : class
        where V : struct
    {
        new S<T>().F/*T:T*/.ToString(); // 1
        new S<U>().F/*T:U?*/.ToString(); // 2
        _ = new S<V?>().F/*T:V?*/.Value; // 3
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         new S<T>().F/*T:T*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "new S<T>().F").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         new S<U>().F/*T:U?*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "new S<U>().F").WithLocation(13, 9),
                // (14,13): warning CS8629: Nullable value type may be null.
                //         _ = new S<V?>().F/*T:V?*/.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "new S<V?>().F/*T:V?*/.Value").WithLocation(14, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void StructField_Default_03()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
}
class Program
{
    static void F()
    {
        S<object> x = default;
        S<object> y = x;
        x.F/*T:object?*/.ToString(); // 1
        y.F/*T:object?*/.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         x.F/*T:object?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.F").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.F/*T:object?*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(13, 9));
            comp.VerifyTypes();
        }

        [Fact]
        public void StructField_Default_04()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
}
class Program
{
    static void F()
    {
        S<int?> x = default;
        S<int?> y = x;
        _ = x.F.Value; // 1
        _ = y.F.Value; // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,13): warning CS8629: Nullable value type may be null.
                //         _ = x.F.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "x.F.Value").WithLocation(12, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = y.F.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.F.Value").WithLocation(13, 13));
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void StructField_Default_05()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
}
class Program
{
    static void F()
    {
        var x = new S<object>();
        var y = x;
        x.F/*T:object?*/.ToString(); // 1
        y.F/*T:object?*/.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         x.F/*T:object?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.F").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.F/*T:object?*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(13, 9));
            comp.VerifyTypes();
        }

        [Fact]
        public void StructField_Default_06()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
}
class Program
{
    static void F()
    {
        var x = new S<int?>();
        var y = x;
        _ = x.F.Value; // 1
        _ = y.F.Value; // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,13): warning CS8629: Nullable value type may be null.
                //         _ = x.F.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "x.F.Value").WithLocation(12, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = y.F.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.F.Value").WithLocation(13, 13));
        }

        [Fact]
        public void StructField_Default_07()
        {
            var source =
@"#pragma warning disable 649
struct S<T, U>
{
    internal T F;
    internal U G;
}
class Program
{
    static void F(object a, string b)
    {
        var x = new S<object, string>() { F = a };
        x.F/*T:object!*/.ToString();
        x.G/*T:string?*/.ToString(); // 1
        var y = new S<object, string>() { G = b };
        y.F/*T:object?*/.ToString(); // 2
        y.G/*T:string!*/.ToString();
        var z = new S<object, string>() { F = default, G = default }; // 3, 4
        z.F/*T:object?*/.ToString(); // 5
        z.G/*T:string?*/.ToString(); // 6
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         x.G/*T:string?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.G").WithLocation(13, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         y.F/*T:object?*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(15, 9),
                // (17,47): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         var z = new S<object, string>() { F = default, G = default }; // 3, 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(17, 47),
                // (17,60): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         var z = new S<object, string>() { F = default, G = default }; // 3, 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(17, 60),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         z.F/*T:object?*/.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z.F").WithLocation(18, 9),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         z.G/*T:string?*/.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z.G").WithLocation(19, 9));
            comp.VerifyTypes();
        }

        [Fact]
        public void StructField_Default_ParameterlessConstructor()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
    internal S() { F = default!; }
    internal S(T t) { F = t; }
}
class Program
{
    static void F()
    {
        var x = default(S<object>);
        x.F/*T:object?*/.ToString(); // 1
        var y = new S<object>();
        y.F/*T:object!*/.ToString();
        var z = new S<object>(1);
        z.F/*T:object!*/.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,14): error CS0568: Structs cannot contain explicit parameterless constructors
                //     internal S() { F = default!; }
                Diagnostic(ErrorCode.ERR_StructsCantContainDefaultConstructor, "S").WithLocation(5, 14),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         x.F/*T:object?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.F").WithLocation(13, 9));
            comp.VerifyTypes();
        }

        [Fact]
        public void StructField_Default_NoType()
        {
            var source =
@"class Program
{
    static void F()
    {
        _ = default/*T:<null>*/.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,32): error CS0023: Operator '.' cannot be applied to operand of type 'default'
                //         _ = default/*T:<null>*/.ToString();
                Diagnostic(ErrorCode.ERR_BadUnaryOp, ".").WithArguments(".", "default").WithLocation(5, 32));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void StructField_ParameterDefaultValue_01()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
}
class Program
{
    static void F1<T1>(S<T1> x1 = default)
    {
        var y1 = x1;
        x1.F/*T:T1*/.ToString(); // 1
        y1.F/*T:T1*/.ToString(); // 2
    }
    static void F2<T2>(S<T2> x2 = default) where T2 : class
    {
        var y2 = x2;
        x2.F/*T:T2?*/.ToString(); // 3
        y2.F/*T:T2?*/.ToString(); // 4
    }
    static void F3<T3>(S<T3?> x3 = default) where T3 : struct
    {
        var y3 = x3;
        _ = x3.F/*T:T3?*/.Value; // 5
        _ = y3.F/*T:T3?*/.Value; // 6
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x1.F/*T:T1*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1.F").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         y1.F/*T:T1*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y1.F").WithLocation(12, 9),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         x2.F/*T:T2?*/.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2.F").WithLocation(17, 9),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         y2.F/*T:T2?*/.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y2.F").WithLocation(18, 9),
                // (23,13): warning CS8629: Nullable value type may be null.
                //         _ = x3.F/*T:T3?*/.Value; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "x3.F/*T:T3?*/.Value").WithLocation(23, 13),
                // (24,13): warning CS8629: Nullable value type may be null.
                //         _ = y3.F/*T:T3?*/.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y3.F/*T:T3?*/.Value").WithLocation(24, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void StructField_ParameterDefaultValue_02()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
    internal S(T t) { F = t; }
}
class Program
{
    static void F<T>(S<T> x = new S<T>(), S<T> y = null, S<T> z = new S<T>(default)) where T : class
    {
        x.F/*T:T?*/.ToString(); // 1
        y.F/*T:T!*/.ToString();
        z.F/*T:T!*/.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,48): error CS1750: A value of type '<null>' cannot be used as a default parameter because there are no standard conversions to type 'S<T>'
                //     static void F<T>(S<T> x = new S<T>(), S<T> y = null, S<T> z = new S<T>(default)) where T : class
                Diagnostic(ErrorCode.ERR_NoConversionForDefaultParam, "y").WithArguments("<null>", "S<T>").WithLocation(9, 48),
                // (9,67): error CS1736: Default parameter value for 'z' must be a compile-time constant
                //     static void F<T>(S<T> x = new S<T>(), S<T> y = null, S<T> z = new S<T>(default)) where T : class
                Diagnostic(ErrorCode.ERR_DefaultValueMustBeConstant, "new S<T>(default)").WithArguments("z").WithLocation(9, 67),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x.F/*T:T?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.F").WithLocation(11, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void StructField_ParameterDefaultValue_03()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
}
class Program
{
    static void F<T>(S<T> x = /*missing*/, S<T> y = default) where T : class
    {
        x.F/*T:T!*/.ToString();
        y.F/*T:T?*/.ToString(); // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,42): error CS1525: Invalid expression term ','
                //     static void F<T>(S<T> x = /*missing*/, S<T> y = default) where T : class
                Diagnostic(ErrorCode.ERR_InvalidExprTerm, ",").WithArguments(",").WithLocation(8, 42),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         y.F/*T:T?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(11, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void StructField_ParameterDefaultValue_04()
        {
            var source =
@"#pragma warning disable 649
struct S<T>
{
    internal T F;
}
class Program
{
    static void F<T>(S<T>? x = default(S<T>)) where T : class
    {
        if (x == null) return;
        var y = x.Value;
        y.F/*T:T*/.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,28): error CS1770: A value of type 'S<T>' cannot be used as default parameter for nullable parameter 'x' because 'S<T>' is not a simple type
                //     static void F<T>(S<T>? x = default(S<T>)) where T : class
                Diagnostic(ErrorCode.ERR_NoConversionForNubDefaultParam, "x").WithArguments("S<T>", "x").WithLocation(8, 28));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void StructField_Default_Nested()
        {
            var source =
@"#pragma warning disable 649
struct S
{
    internal S(int i)
    {
        S1 = null!;
        T = default;
    }
    internal object S1;
    internal T T;
}
struct T
{
    internal object T1;
}
class Program
{
    static void F1()
    {
        // default
        S s1 = default;
        s1.S1.ToString(); // 1
        s1.T.T1.ToString(); // 2
    }
    static void F2()
    {
        // default constructor
        S s2 = new S();
        s2.S1.ToString(); // 3
        s2.T.T1.ToString(); // 4
    }
    static void F3()
    {
        // explicit constructor
        S s3 = new S(0);
        s3.S1.ToString();
        s3.T.T1.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         s1.S1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s1.S1").WithLocation(22, 9),
                // (23,9): warning CS8602: Possible dereference of a null reference.
                //         s1.T.T1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s1.T.T1").WithLocation(23, 9),
                // (29,9): warning CS8602: Possible dereference of a null reference.
                //         s2.S1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2.S1").WithLocation(29, 9),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         s2.T.T1.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s2.T.T1").WithLocation(30, 9));
        }

        [Fact]
        public void StructField_Cycle_Default()
        {
            // Nullability of F is treated as object!, even for default instances, because a struct with cycles
            // is not a "trackable" struct type (see EmptyStructTypeCache.IsTrackableStructType).
            var source =
@"#pragma warning disable 649
struct S
{
    internal S Next;
    internal object F;
}
class Program
{
    static void F()
    {
        default(S).F/*T:object!*/.ToString();
        S x = default;
        S y = x;
        x.F/*T:object!*/.ToString();
        x.Next.F/*T:object!*/.ToString();
        y.F/*T:object!*/.ToString();
        y.Next.F/*T:object!*/.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,16): error CS0523: Struct member 'S.Next' of type 'S' causes a cycle in the struct layout
                //     internal S Next;
                Diagnostic(ErrorCode.ERR_StructLayoutCycle, "Next").WithArguments("S.Next", "S").WithLocation(4, 16));
            comp.VerifyTypes();
        }

        [Fact]
        public void StructProperty_Cycle_Default()
        {
            // Nullability of Next.F is treated as object!, even for default instances, because only
            // auto -properties are tracked (see https://github.com/dotnet/roslyn/issues/29619).
            var source =
@"#pragma warning disable 649
struct S
{
    internal S Next
    {
        get => throw null;
        set { }
    }
    internal object F;
}
class Program
{
    static void F()
    {
        S x = default;
        S y = x;
        x.F/*T:object?*/.ToString(); // 1
        x.Next.F/*T:object!*/.ToString(); // 2
        y.F/*T:object?*/.ToString(); // 3
        y.Next.F/*T:object!*/.ToString(); // 4
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         x.F/*T:object?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.F").WithLocation(17, 9),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         y.F/*T:object?*/.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(19, 9));
            comp.VerifyTypes();
        }

        // `default` expression in a split state.
        [Fact]
        public void IsPattern_DefaultTrackableStruct()
        {
            var source =
@"#pragma warning disable 649
struct S
{
    internal object F;
}
class Program
{
    static void F()
    {
        if (default(S) is default) { }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,27): error CS8505: A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.
                //         if (default(S) is default) { }
                Diagnostic(ErrorCode.ERR_DefaultPattern, "default").WithLocation(10, 27),
                // (10,27): error CS0150: A constant value is expected
                //         if (default(S) is default) { }
                Diagnostic(ErrorCode.ERR_ConstantExpected, "default").WithLocation(10, 27));
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void Tuple_Default_01()
        {
            var source =
@"class Program
{
    static void F()
    {
        default((object?, string))/*T:(object?, string!)*/.Item2.ToString(); // 1
        _ = default((int, int?))/*T:(int, int?)*/.Item2.Value; // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         default((object?, string))/*T:(object?, string!)*/.Item2.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "default((object?, string))/*T:(object?, string!)*/.Item2").WithLocation(5, 9),
                // (6,13): warning CS8629: Nullable value type may be null.
                //         _ = default((int, int?))/*T:(int, int?)*/.Item2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "default((int, int?))/*T:(int, int?)*/.Item2.Value").WithLocation(6, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void Tuple_Default_02()
        {
            var source =
@"using System;
class Program
{
    static void F1()
    {
        new ValueTuple<object?, string>()/*T:(object?, string!)*/.Item2.ToString(); // 1
        _ = new ValueTuple<int, int?>()/*T:(int, int?)*/.Item2.Value; // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         new ValueTuple<object?, string>()/*T:(object?, string!)*/.Item2.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "new ValueTuple<object?, string>()/*T:(object?, string!)*/.Item2").WithLocation(6, 9),
                // (7,13): warning CS8629: Nullable value type may be null.
                //         _ = new ValueTuple<int, int?>()/*T:(int, int?)*/.Item2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "new ValueTuple<int, int?>()/*T:(int, int?)*/.Item2.Value").WithLocation(7, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void Tuple_Default_03()
        {
            var source =
@"class Program
{
    static void F()
    {
        (object, (object?, string)) t = default/*T:(object!, (object?, string!))*/;
        (object, (object?, string)) u = t;
        t.Item1/*T:object?*/.ToString(); // 1
        t.Item2.Item2/*T:string?*/.ToString(); // 2
        u.Item1/*T:object?*/.ToString(); // 3
        u.Item2.Item2/*T:string?*/.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item1/*T:object?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item1").WithLocation(7, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item2.Item2/*T:string?*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item2.Item2").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item1/*T:object?*/.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item1").WithLocation(9, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item2.Item2/*T:string?*/.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item2.Item2").WithLocation(10, 9));
            comp.VerifyTypes();
        }

        [Fact]
        public void Tuple_Default_04()
        {
            var source =
@"class Program
{
    static void F()
    {
        (int, int?) t = default/*T:(int, int?)*/;
        (int, int?) u = t;
        _ = t.Item2.Value; // 1
        _ = u.Item2.Value; // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): warning CS8629: Nullable value type may be null.
                //         _ = t.Item2.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t.Item2.Value").WithLocation(7, 13),
                // (8,13): warning CS8629: Nullable value type may be null.
                //         _ = u.Item2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "u.Item2.Value").WithLocation(8, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void Tuple_Default_05()
        {
            var source =
@"using System;
class Program
{
    static void F1()
    {
        var t = new ValueTuple<object, ValueTuple<object?, string>>()/*T:(object!, (object?, string!))*/;
        var u = t;
        t.Item1/*T:object?*/.ToString(); // 1
        t.Item2.Item2/*T:string?*/.ToString(); // 2
        u.Item1/*T:object?*/.ToString(); // 3
        u.Item2.Item2/*T:string?*/.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item1/*T:object?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item1").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item2.Item2/*T:string?*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item2.Item2").WithLocation(9, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item1/*T:object?*/.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item1").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         u.Item2.Item2/*T:string?*/.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.Item2.Item2").WithLocation(11, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void Tuple_Default_06()
        {
            var source =
@"using System;
class Program
{
    static void F1()
    {
        var t = new ValueTuple<int, int?>()/*T:(int, int?)*/;
        var u = t;
        _ = t.Item2.Value; // 1
        _ = u.Item2.Value; // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8629: Nullable value type may be null.
                //         _ = t.Item2.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t.Item2.Value").WithLocation(8, 13),
                // (9,13): warning CS8629: Nullable value type may be null.
                //         _ = u.Item2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "u.Item2.Value").WithLocation(9, 13));
            comp.VerifyTypes();
        }

        [Fact]
        public void Tuple_Default_NoType()
        {
            var source =
@"class Program
{
    static void F(object? x)
    {
        _ = (default, default)/*T:<null>*/.Item1.ToString();
        _ = (x, default)/*T:<null>*/.Item2.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,44): error CS0117: '(default, default)' does not contain a definition for 'Item1'
                //         _ = (default, default)/*T:<null>*/.Item1.ToString();
                Diagnostic(ErrorCode.ERR_NoSuchMember, "Item1").WithArguments("(default, default)", "Item1").WithLocation(5, 44),
                // (6,38): error CS0117: '(object, default)' does not contain a definition for 'Item2'
                //         _ = (x, default)/*T:<null>*/.Item2.ToString();
                Diagnostic(ErrorCode.ERR_NoSuchMember, "Item2").WithArguments("(object, default)", "Item2").WithLocation(6, 38));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void Tuple_ParameterDefaultValue_01()
        {
            var source =
@"class Program
{
    static void F<T, U, V>((T x, U y, V? z) t = default)
        where U : class
        where V : struct
    {
        var u = t/*T:(T x, U! y, V? z)*/;
        t.x/*T:T*/.ToString(); // 1
        t.y/*T:U?*/.ToString(); // 2
        _ = t.z/*T:V?*/.Value; // 3
        u.x/*T:T*/.ToString(); // 4
        u.y/*T:U?*/.ToString(); // 5
        _ = u.z/*T:V?*/.Value; // 6
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.x/*T:T*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.x").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         t.y/*T:U?*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.y").WithLocation(9, 9),
                // (10,13): warning CS8629: Nullable value type may be null.
                //         _ = t.z/*T:V?*/.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t.z/*T:V?*/.Value").WithLocation(10, 13),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         u.x/*T:T*/.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.x").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         u.y/*T:U?*/.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.y").WithLocation(12, 9),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = u.z/*T:V?*/.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "u.z/*T:V?*/.Value").WithLocation(13, 13));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(30731, "https://github.com/dotnet/roslyn/issues/30731")]
        public void Tuple_ParameterDefaultValue_02()
        {
            var source =
@"class Program
{
    static void F<T, U, V>(
        (T, U, V?) x = new System.ValueTuple<T, U, V?>(),
        (T, U, V?) y = null,
        (T, U, V?) z = (default(T), new U(), new V()))
        where U : class, new()
        where V : struct
    {
        x.Item1/*T:T*/.ToString(); // 1
        x.Item2/*T:U?*/.ToString(); // 2
        _ = x.Item3/*T:V?*/.Value; // 3
        y.Item1/*T:T*/.ToString(); // 4
        y.Item2/*T:U!*/.ToString();
        _ = y.Item3/*T:V?*/.Value; // 5
        z.Item1/*T:T*/.ToString(); // 6
        z.Item2/*T:U!*/.ToString();
        _ = z.Item3/*T:V?*/.Value; // 7
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,20): error CS1750: A value of type '<null>' cannot be used as a default parameter because there are no standard conversions to type '(T, U, V?)'
                //         (T, U, V?) y = null,
                Diagnostic(ErrorCode.ERR_NoConversionForDefaultParam, "y").WithArguments("<null>", "(T, U, V?)").WithLocation(5, 20),
                // (6,24): error CS1736: Default parameter value for 'z' must be a compile-time constant
                //         (T, U, V?) z = (default(T), new U(), new V()))
                Diagnostic(ErrorCode.ERR_DefaultValueMustBeConstant, "(default(T), new U(), new V())").WithArguments("z").WithLocation(6, 24),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         x.Item1/*T:T*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.Item1").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x.Item2/*T:U?*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.Item2").WithLocation(11, 9),
                // (12,13): warning CS8629: Nullable value type may be null.
                //         _ = x.Item3/*T:V?*/.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "x.Item3/*T:V?*/.Value").WithLocation(12, 13),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.Item1/*T:T*/.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.Item1").WithLocation(13, 9),
                // (15,13): warning CS8629: Nullable value type may be null.
                //         _ = y.Item3/*T:V?*/.Value; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Item3/*T:V?*/.Value").WithLocation(15, 13),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         z.Item1/*T:T*/.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z.Item1").WithLocation(16, 9),
                // (18,13): warning CS8629: Nullable value type may be null.
                //         _ = z.Item3/*T:V?*/.Value; // 7
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "z.Item3/*T:V?*/.Value").WithLocation(18, 13));
            comp.VerifyTypes();
        }

        [Fact]
        public void Tuple_Constructor()
        {
            var source =
@"class C
{
    C((string x, string? y) t) { }
    static void M(string x, string? y)
    {
        C c;
        c = new C((x, x));
        c = new C((x, y));
        c = new C((y, x)); // 1
        c = new C((y, y)); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,19): warning CS8620: Nullability of reference types in argument of type '(string? y, string x)' doesn't match target type '(string x, string? y)' for parameter 't' in 'C.C((string x, string? y) t)'.
                //         c = new C((y, x)); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, x)").WithArguments("(string? y, string x)", "(string x, string? y)", "t", "C.C((string x, string? y) t)").WithLocation(9, 19),
                // (10,19): warning CS8620: Nullability of reference types in argument of type '(string?, string?)' doesn't match target type '(string x, string? y)' for parameter 't' in 'C.C((string x, string? y) t)'.
                //         c = new C((y, y)); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, y)").WithArguments("(string?, string?)", "(string x, string? y)", "t", "C.C((string x, string? y) t)").WithLocation(10, 19));
        }

        [Fact]
        public void Tuple_Indexer()
        {
            var source =
@"class C
{
    object? this[(string x, string? y) t] => null;
    static void M(string x, string? y)
    {
        var c = new C();
        object? o;
        o = c[(x, x)];
        o = c[(x, y)];
        o = c[(y, x)]; // 1
        o = c[(y, y)]; // 2
        var t = (y, x);
        o = c[t]; // 3
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,15): warning CS8620: Nullability of reference types in argument of type '(string? y, string x)' doesn't match target type '(string x, string? y)' for parameter 't' in 'object? C.this[(string x, string? y) t]'.
                //         o = c[(y, x)]; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, x)").WithArguments("(string? y, string x)", "(string x, string? y)", "t", "object? C.this[(string x, string? y) t]").WithLocation(10, 15),
                // (11,15): warning CS8620: Nullability of reference types in argument of type '(string?, string?)' doesn't match target type '(string x, string? y)' for parameter 't' in 'object? C.this[(string x, string? y) t]'.
                //         o = c[(y, y)]; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, y)").WithArguments("(string?, string?)", "(string x, string? y)", "t", "object? C.this[(string x, string? y) t]").WithLocation(11, 15),
                // (13,15): warning CS8620: Nullability of reference types in argument of type '(string? y, string x)' doesn't match target type '(string x, string? y)' for parameter 't' in 'object? C.this[(string x, string? y) t]'.
                //         o = c[t]; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "t").WithArguments("(string? y, string x)", "(string x, string? y)", "t", "object? C.this[(string x, string? y) t]").WithLocation(13, 15));
        }

        [Fact]
        public void Tuple_CollectionInitializer()
        {
            var source =
@"using System.Collections.Generic;
class C
{
    static void M(string x, string? y)
    {
        var c = new List<(string, string?)>
        {
            (x, x),
            (x, y),
            (y, x), // 1
            (y, y), // 2
        };
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8620: Nullability of reference types in argument of type '(string? y, string x)' doesn't match target type '(string, string?)' for parameter 'item' in 'void List<(string, string?)>.Add((string, string?) item)'.
                //             (y, x), // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, x)").WithArguments("(string? y, string x)", "(string, string?)", "item", "void List<(string, string?)>.Add((string, string?) item)").WithLocation(10, 13),
                // (11,13): warning CS8620: Nullability of reference types in argument of type '(string?, string?)' doesn't match target type '(string, string?)' for parameter 'item' in 'void List<(string, string?)>.Add((string, string?) item)'.
                //             (y, y), // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "(y, y)").WithArguments("(string?, string?)", "(string, string?)", "item", "void List<(string, string?)>.Add((string, string?) item)").WithLocation(11, 13));
        }

        [Fact]
        public void Tuple_Method()
        {
            var source =
@"class C
{
    static void F(object? x, object? y)
    {
        if (x == null) return;
        (x, y).ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Tuple_OtherMembers_01()
        {
            var source =
@"internal delegate T D<T>();
namespace System
{
    public struct ValueTuple<T1, T2>
    {
        public ValueTuple(T1 item1, T2 item2)
        {
            Item1 = item1;
            Item2 = item2;
            F1 = item1;
            E2 = null;
        }
        public T1 Item1;
        public T2 Item2;
        internal T1 F1;
        internal T1 P1 => Item1;
        internal event D<T2>? E2;
    }
}
class C
{
    static void F(object? x)
    {
        var y = (x, x);
        y.F1.ToString(); // 1
        y.P1.ToString(); // 2
        y.E2?.Invoke().ToString(); // 3
        if (x == null) return;
        var z = (x, x);
        z.F1.ToString();
        z.P1.ToString();
        z.E2?.Invoke().ToString();
    }
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), targetFramework: TargetFramework.Mscorlib46);
            // NullableWalker.VisitTupleExpression tracks tuple elements but not
            // other (unexpected) fields of tuples (see y.F1.ToString()).
            comp.VerifyDiagnostics(
                // (27,11): error CS0070: The event '(object, object).E2' can only appear on the left hand side of += or -= (except when used from within the type '(object, object)')
                //         y.E2?.Invoke().ToString(); // 3
                Diagnostic(ErrorCode.ERR_BadEventUsage, "E2").WithArguments("(object, object).E2", "(object, object)").WithLocation(27, 11),
                // (32,11): error CS0070: The event '(object, object).E2' can only appear on the left hand side of += or -= (except when used from within the type '(object, object)')
                //         z.E2?.Invoke().ToString();
                Diagnostic(ErrorCode.ERR_BadEventUsage, "E2").WithArguments("(object, object).E2", "(object, object)").WithLocation(32, 11),
                // (26,9): warning CS8602: Possible dereference of a null reference.
                //         y.P1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.P1").WithLocation(26, 9),
                // (17,31): warning CS0414: The field 'ValueTuple<T1, T2>.E2' is assigned but its value is never used
                //         internal event D<T2>? E2;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "E2").WithArguments("System.ValueTuple<T1, T2>.E2").WithLocation(17, 31));
        }

        [Fact]
        public void Tuple_OtherMembers_02()
        {
            // Cannot test Derived<T> since tuple types are considered sealed and the base type
            // is dropped: "error CS0509: 'Derived<T>': cannot derive from sealed type '(T, T)'".
            var source =
@"namespace System
{
    public class Base<T>
    {
        public Base(T t) { F = t; }
        public T F;
    }
    public class ValueTuple<T1, T2> : Base<T1>
    {
        public ValueTuple(T1 item1, T2 item2) : base(item1)
        {
            Item1 = item1;
            Item2 = item2;
        }
        public T1 Item1;
        public T2 Item2;
    }
    //public class Derived<T> : ValueTuple<T, T>
    //{
    //    public Derived(T t) : base(t, t) { }
    //    public T P { get; set; }
    //}
}
class C
{
    static void F(object? x)
    {
        var y = (x, x);
        y.F.ToString();
        y.Item2.ToString();
        if (x == null) return;
        var z = (x, x);
        z.F.ToString();
        z.Item2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), targetFramework: TargetFramework.Mscorlib46);
            comp.VerifyDiagnostics(
                // (29,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(29, 9),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         y.Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.Item2").WithLocation(30, 9));
        }

        [Fact]
        public void Tuple_OtherMembers_03()
        {
            var source =
@"namespace System
{
    public class Object
    {
        public string ToString() => throw null;
        public object? F;
    }
    public class String { }
    public abstract class ValueType
    {
        public object? P { get; set; }
    }
    public struct Void { }
    public struct Boolean { }
    public struct Enum { }
    public class Attribute { }
    public struct Int32 { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }

    public struct ValueTuple<T1, T2>
    {
        public ValueTuple(T1 item1, T2 item2)
        {
        }
    }
}
class C
{
    static void M(object x)
    {
        var y = (x, x);
        y.F.ToString();
        y.P.ToString();
    }
}";
            var comp = CreateEmptyCompilation(source);
            comp.VerifyDiagnostics(
                // (6,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public object? F;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 22),
                // (11,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         public object? P { get; set; }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 22)
                );

            var comp2 = CreateEmptyCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp2.VerifyDiagnostics(
                // (44,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(44, 9),
                // (45,9): warning CS8602: Possible dereference of a null reference.
                //         y.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.P").WithLocation(45, 9));
        }

        [Fact]
        public void TypeInference_TupleNameDifferences_01()
        {
            var source =
@"class C<T>
{
}
static class E
{
    public static T F<T>(this C<T> c, T t) => t;
}
class C
{
    static void F(object o)
    {
        var c = new C<(object x, int y)>();
        c.F((o, -1)).x.ToString();
    }
}";

            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics(
                // (13,22): error CS1061: '(object, int)' does not contain a definition for 'x' and no extension method 'x' accepting a first argument of type '(object, int)' could be found (are you missing a using directive or an assembly reference?)
                //         c.F((o, -1)).x.ToString();
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "x").WithArguments("(object, int)", "x").WithLocation(13, 22));

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,22): error CS1061: '(object, int)' does not contain a definition for 'x' and no extension method 'x' accepting a first argument of type '(object, int)' could be found (are you missing a using directive or an assembly reference?)
                //         c.F((o, -1)).x.ToString();
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "x").WithArguments("(object, int)", "x").WithLocation(13, 22));
        }

        [Fact]
        public void TypeInference_TupleNameDifferences_02()
        {
            var source =
@"class C<T>
{
}
static class E
{
    public static T F<T>(this C<T> c, T t) => t;
}
class C
{
    static void F(object o)
    {
        var c = new C<(object? x, int y)>();
        c.F((o, -1))/*T:(object?, int)*/.x.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,42): error CS1061: '(object, int)' does not contain a definition for 'x' and no accessible extension method 'x' accepting a first argument of type '(object, int)' could be found (are you missing a using directive or an assembly reference?)
                //         c.F((o, -1))/*T:(object?, int)*/.x.ToString();
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "x").WithArguments("(object, int)", "x").WithLocation(13, 42));
            comp.VerifyTypes();
        }

        [Fact]
        public void TypeInference_DynamicDifferences_01()
        {
            var source =
@"class C<T>
{
}
static class E
{
    public static T F<T>(this C<T> c, T t) => t;
}
class C
{
    static void F(dynamic x, object y)
    {
        var c = new C<(object, object)>();
        c.F((x, y))/*T:(dynamic!, object!)*/.Item1.G();
    }
}";

            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        public void TypeInference_DynamicDifferences_02()
        {
            var source =
@"class C<T>
{
}
static class E
{
    public static T F<T>(this C<T> c, T t) => t;
}
class C
{
    static void F(dynamic x, object y)
    {
        var c = new C<(object, object?)>();
        c.F((x, y))/*T:(dynamic!, object?)*/.Item1.G();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        // Assert failure in ConversionsBase.IsValidExtensionMethodThisArgConversion.
        [WorkItem(22317, "https://github.com/dotnet/roslyn/issues/22317")]
        [Fact(Skip = "22317")]
        public void TypeInference_DynamicDifferences_03()
        {
            var source =
@"interface I<T>
{
}
static class E
{
    public static T F<T>(this I<T> i, T t) => t;
}
class C
{
    static void F(I<object> i, dynamic? d)
    {
        i.F(d).G();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,9): error CS1929: 'I<object>' does not contain a definition for 'F' and the best extension method overload 'E.F<T>(I<T>, T)' requires a receiver of type 'I<T>'
                //         i.F(d).G();
                Diagnostic(ErrorCode.ERR_BadInstanceArgType, "i").WithArguments("I<object>", "F", "E.F<T>(I<T>, T)", "I<T>").WithLocation(12, 9));
        }

        [Fact]
        public void NullableConversionAndNullCoalescingOperator_01()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    short F;
    static ushort G(S? s)
    {
        return (ushort)(s?.F ?? 0);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableConversionAndNullCoalescingOperator_02()
        {
            var source =
@"struct S
{
    public static implicit operator int(S s) => 0;
}
class P
{
    static int F(S? x, int y) => x ?? y;
    static int G(S x, int? y) => y ?? x;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ConstrainedToTypeParameter_01()
        {
            var source =
@"class C<T, U> where U : T
{
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ConstrainedToTypeParameter_02()
        {
            var source =
@"class C<T> where T : C<T>
{
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ArrayElementConversion()
        {
            var source =
@"class C
{
    static object F() => new sbyte[] { -1 };
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TrackNonNullableLocals()
        {
            var source =
@"class C
{
    static void F(object x)
    {
        object y = x;
        x.ToString(); // 1
        y.ToString(); // 2
        x = null;
        y = x;
        x.ToString(); // 3
        y.ToString(); // 4
        x = null;
        y = x;
        if (x == null) return;
        if (y == null) return;
        x.ToString(); // 5
        y.ToString(); // 6
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(8, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(9, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(11, 9),
                // (12,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(12, 13),
                // (13,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(13, 13));
        }

        [Fact]
        public void TrackNonNullableFieldsAndProperties()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    object F;
    object P { get; set; }
    static void M(C c)
    {
        c.F.ToString(); // 1
        c.P.ToString(); // 2
        c.F = null;
        c.P = null;
        c.F.ToString(); // 3
        c.P.ToString(); // 4
        if (c.F == null) return;
        if (c.P == null) return;
        c.F.ToString(); // 5
        c.P.ToString(); // 6
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         c.F = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(10, 15),
                // (11,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         c.P = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(11, 15),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         c.F.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.F").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         c.P.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.P").WithLocation(13, 9),
                // (14,13): hidden CS8606: Result of the comparison is possibly always false.
                //         if (c.F == null) return;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "c.F == null").WithLocation(14, 13),
                // (15,13): hidden CS8606: Result of the comparison is possibly always false.
                //         if (c.P == null) return;
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "c.P == null").WithLocation(15, 13));
        }

        [Fact]
        public void TrackNonNullableFields_ObjectInitializer()
        {
            var source =
@"class C<T>
{
    internal T F = default!;
}
class Program
{
    static void F1(object? x1)
    {
        C<object> c1;
        c1 = new C<object>() { F = x1 }; // 1
        c1 = new C<object>() { F = c1.F }; // 2
        c1.F.ToString(); // 3
    }
    static void F2<T>()
    {
        C<T> c2;
        c2 = new C<T>() { F = default }; // 3
        c2 = new C<T>() { F = c2.F }; // 4
        c2.F.ToString(); // 5
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,36): warning CS8601: Possible null reference assignment.
                //         c1 = new C<object>() { F = x1 }; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x1").WithLocation(10, 36),
                // (11,36): warning CS8601: Possible null reference assignment.
                //         c1 = new C<object>() { F = c1.F }; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "c1.F").WithLocation(11, 36),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         c1.F.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1.F").WithLocation(12, 9),
                // (17,31): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         c2 = new C<T>() { F = default }; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(17, 31),
                // (18,31): warning CS8601: Possible null reference assignment.
                //         c2 = new C<T>() { F = c2.F }; // 4
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "c2.F").WithLocation(18, 31),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         c2.F.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2.F").WithLocation(19, 9));
        }

        [Fact]
        public void TrackUnannotatedFieldsAndProperties()
        {
            var source0 =
@"public class C
{
    public object F;
    public object P { get; set; }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();

            var source1 =
@"class P
{
    static void M(C c, object? o)
    {
        c.F.ToString();
        c.P.ToString();
        c.F = o;
        c.P = o;
        c.F.ToString(); // 1
        c.P.ToString(); // 2
        c.F = o;
        c.P = o;
        if (c.F == null) return;
        if (c.P == null) return;
        c.F.ToString();
        c.P.ToString();
    }
}";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: new[] { comp0.EmitToImageReference() });
            comp1.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         c.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.F").WithLocation(9, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         c.P.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.P").WithLocation(10, 9));
        }

        /// <summary>
        /// Assignment warnings for local and parameters should be distinct from
        /// fields and properties because the former may be warnings from legacy
        /// method bodies and it should be possible to disable those warnings separately.
        /// </summary>
        [Fact]
        public void AssignmentWarningsDistinctForLocalsAndParameters()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class C
{
    internal object F;
    internal object P { get; set; }
}
class P
{
    static void F(out object? x)
    {
        x = null;
    }
    static void Local()
    {
        object? y = null;
        object x1 = null;
        x1 = y;
        F(out x1);
    }
    static void Parameter(object x2)
    {
        object? y = null;
        x2 = null;
        x2 = y;
        F(out x2);
    }
    static void OutParameter(out object x3)
    {
        object? y = null;
        x3 = null;
        x3 = y;
        F(out x3);
    }
    static void RefParameter(ref object x4)
    {
        object? y = null;
        x4 = null;
        x4 = y;
        F(out x4);
    }
    static void Field()
    {
        var c = new C();
        object? y = null;
        c.F = null;
        c.F = y;
        F(out c.F);
    }
    static void Property()
    {
        var c = new C();
        object? y = null;
        c.P = null;
        c.P = y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object x1 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(17, 21),
                // (18,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x1 = y;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(18, 14),
                // (19,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F(out x1);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x1").WithLocation(19, 15),
                // (24,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x2 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(24, 14),
                // (25,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x2 = y;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(25, 14),
                // (26,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F(out x2);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(26, 15),
                // (31,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         x3 = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(31, 14),
                // (32,14): warning CS8601: Possible null reference assignment.
                //         x3 = y;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y").WithLocation(32, 14),
                // (33,15): warning CS8601: Possible null reference assignment.
                //         F(out x3);
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x3").WithLocation(33, 15),
                // (38,14): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         x4 = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(38, 14),
                // (39,14): warning CS8601: Possible null reference assignment.
                //         x4 = y;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y").WithLocation(39, 14),
                // (40,15): warning CS8601: Possible null reference assignment.
                //         F(out x4);
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "x4").WithLocation(40, 15),
                // (46,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         c.F = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(46, 15),
                // (47,15): warning CS8601: Possible null reference assignment.
                //         c.F = y;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y").WithLocation(47, 15),
                // (48,15): warning CS8601: Possible null reference assignment.
                //         F(out c.F);
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "c.F").WithLocation(48, 15),
                // (54,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         c.P = null;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(54, 15),
                // (55,15): warning CS8601: Possible null reference assignment.
                //         c.P = y;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y").WithLocation(55, 15));
        }

        /// <summary>
        /// Explicit cast does not cast away top-level nullability.
        /// </summary>
        [Fact]
        public void ExplicitCast()
        {
            var source =
@"#pragma warning disable 0649
class A<T>
{
    internal T F;
}
class B1 : A<string> { }
class B2 : A<string?> { }
class C
{
    static void F0()
    {
        ((A<string>)null).F.ToString();
        ((A<string>?)null).F.ToString();
        ((A<string?>)default).F.ToString();
        ((A<string?>?)default).F.ToString();
    }
    static void F1(A<string> x1, A<string>? y1)
    {
        ((B2?)x1).F.ToString();
        ((B2)y1).F.ToString();
    }
    static void F2(B1 x2, B1? y2)
    {
        ((A<string?>?)x2).F.ToString();
        ((A<string?>)y2).F.ToString();
    }
    static void F3(A<string?> x3, A<string?>? y3)
    {
        ((B2?)x3).F.ToString();
        ((B2)y3).F.ToString();
    }
    static void F4(B2 x4, B2? y4)
    {
        ((A<string>?)x4).F.ToString();
        ((A<string>)y4).F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class A<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "A").WithArguments("field", "F").WithLocation(2, 7),
                // (12,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((A<string>)null).F.ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(A<string>)null").WithLocation(12, 10),
                // (12,10): warning CS8602: Possible dereference of a null reference.
                //         ((A<string>)null).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(A<string>)null").WithLocation(12, 10),
                // (13,10): warning CS8602: Possible dereference of a null reference.
                //         ((A<string>?)null).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(A<string>?)null").WithLocation(13, 10),
                // (14,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((A<string?>)default).F.ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(A<string?>)default").WithLocation(14, 10),
                // (14,10): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>)default).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(A<string?>)default").WithLocation(14, 10),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>)default).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((A<string?>)default).F").WithLocation(14, 9),
                // (15,10): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>?)default).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(A<string?>?)default").WithLocation(15, 10),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>?)default).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((A<string?>?)default).F").WithLocation(15, 9),
                // (19,10): warning CS8619: Nullability of reference types in value of type 'A<string>' doesn't match target type 'B2'.
                //         ((B2?)x1).F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B2?)x1").WithArguments("A<string>", "B2").WithLocation(19, 10),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         ((B2?)x1).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((B2?)x1).F").WithLocation(19, 9),
                // (20,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((B2)y1).F.ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B2)y1").WithLocation(20, 10),
                // (20,10): warning CS8619: Nullability of reference types in value of type 'A<string>' doesn't match target type 'B2'.
                //         ((B2)y1).F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B2)y1").WithArguments("A<string>", "B2").WithLocation(20, 10),
                // (20,10): warning CS8602: Possible dereference of a null reference.
                //         ((B2)y1).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(B2)y1").WithLocation(20, 10),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         ((B2)y1).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((B2)y1).F").WithLocation(20, 9),
                // (24,10): warning CS8619: Nullability of reference types in value of type 'B1' doesn't match target type 'A<string?>'.
                //         ((A<string?>?)x2).F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<string?>?)x2").WithArguments("B1", "A<string?>").WithLocation(24, 10),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>?)x2).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((A<string?>?)x2).F").WithLocation(24, 9),
                // (25,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((A<string?>)y2).F.ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(A<string?>)y2").WithLocation(25, 10),
                // (25,10): warning CS8619: Nullability of reference types in value of type 'B1' doesn't match target type 'A<string?>'.
                //         ((A<string?>)y2).F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<string?>)y2").WithArguments("B1", "A<string?>").WithLocation(25, 10),
                // (25,10): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>)y2).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(A<string?>)y2").WithLocation(25, 10),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         ((A<string?>)y2).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((A<string?>)y2).F").WithLocation(25, 9),
                // (29,9): warning CS8602: Possible dereference of a null reference.
                //         ((B2?)x3).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((B2?)x3).F").WithLocation(29, 9),
                // (30,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((B2)y3).F.ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B2)y3").WithLocation(30, 10),
                // (30,10): warning CS8602: Possible dereference of a null reference.
                //         ((B2)y3).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(B2)y3").WithLocation(30, 10),
                // (30,9): warning CS8602: Possible dereference of a null reference.
                //         ((B2)y3).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "((B2)y3).F").WithLocation(30, 9),
                // (34,10): warning CS8619: Nullability of reference types in value of type 'B2' doesn't match target type 'A<string>'.
                //         ((A<string>?)x4).F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<string>?)x4").WithArguments("B2", "A<string>").WithLocation(34, 10),
                // (35,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((A<string>)y4).F.ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(A<string>)y4").WithLocation(35, 10),
                // (35,10): warning CS8619: Nullability of reference types in value of type 'B2' doesn't match target type 'A<string>'.
                //         ((A<string>)y4).F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<string>)y4").WithArguments("B2", "A<string>").WithLocation(35, 10),
                // (35,10): warning CS8602: Possible dereference of a null reference.
                //         ((A<string>)y4).F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(A<string>)y4").WithLocation(35, 10));
        }

        [Fact]
        public void ExplicitCast_NestedNullability_01()
        {
            var source =
@"class A<T> { }
class B<T> : A<T> { }
class C
{
    static void F1(A<object> x1, A<object?> y1)
    {
        object o;
        o = (B<object>)x1;
        o = (B<object?>)x1; // 1
        o = (B<object>)y1; // 2
        o = (B<object?>)y1;
    }
    static void F2(B<object> x2, B<object?> y2)
    {
        object o;
        o = (A<object>)x2;
        o = (A<object?>)x2; // 3
        o = (A<object>)y2; // 4
        o = (A<object?>)y2;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'B<object?>'.
                //         o = (B<object?>)x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<object?>)x1").WithArguments("A<object>", "B<object?>").WithLocation(9, 13),
                // (10,13): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'B<object>'.
                //         o = (B<object>)y1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<object>)y1").WithArguments("A<object?>", "B<object>").WithLocation(10, 13),
                // (17,13): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'A<object?>'.
                //         o = (A<object?>)x2; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<object?>)x2").WithArguments("B<object>", "A<object?>").WithLocation(17, 13),
                // (18,13): warning CS8619: Nullability of reference types in value of type 'B<object?>' doesn't match target type 'A<object>'.
                //         o = (A<object>)y2; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<object>)y2").WithArguments("B<object?>", "A<object>").WithLocation(18, 13));
        }

        [Fact]
        public void ExplicitCast_NestedNullability_02()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class A<T> : I<T> { }
class B<T> : IIn<T> { }
class C<T> : IOut<T> { }
class D
{
    static void F1(A<object> x1, A<object?> y1)
    {
        object o;
        o = (I<object>)x1;
        o = (I<object?>)x1;
        o = (I<object>)y1;
        o = (I<object?>)y1;
    }
    static void F2(I<object> x2, I<object?> y2)
    {
        object o;
        o = (A<object>)x2;
        o = (A<object?>)x2;
        o = (A<object>)y2;
        o = (A<object?>)y2;
    }
    static void F3(B<object> x3, B<object?> y3)
    {
        object o;
        o = (IIn<object>)x3;
        o = (IIn<object?>)x3;
        o = (IIn<object>)y3;
        o = (IIn<object?>)y3;
    }
    static void F4(IIn<object> x4, IIn<object?> y4)
    {
        object o;
        o = (B<object>)x4;
        o = (B<object?>)x4;
        o = (B<object>)y4;
        o = (B<object?>)y4;
    }
    static void F5(C<object> x5, C<object?> y5)
    {
        object o;
        o = (IOut<object>)x5;
        o = (IOut<object?>)x5;
        o = (IOut<object>)y5;
        o = (IOut<object?>)y5;
    }
    static void F6(IOut<object> x6, IOut<object?> y6)
    {
        object o;
        o = (C<object>)x6;
        o = (C<object?>)x6;
        o = (C<object>)y6;
        o = (C<object?>)y6;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ExplicitCast_NestedNullability_03()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
sealed class A<T> : I<T> { }
sealed class B<T> : IIn<T> { }
sealed class C<T> : IOut<T> { }
class D
{
    static void F1(A<object> x1, A<object?> y1)
    {
        object o;
        o = (I<object>)x1;
        o = (I<object?>)x1; // 1
        o = (I<object>)y1; // 2
        o = (I<object?>)y1;
    }
    static void F2(I<object> x2, I<object?> y2)
    {
        object o;
        o = (A<object>)x2;
        o = (A<object?>)x2; // 3
        o = (A<object>)y2; // 4
        o = (A<object?>)y2;
    }
    static void F3(B<object> x3, B<object?> y3)
    {
        object o;
        o = (IIn<object>)x3;
        o = (IIn<object?>)x3; // 5
        o = (IIn<object>)y3;
        o = (IIn<object?>)y3;
    }
    static void F4(IIn<object> x4, IIn<object?> y4)
    {
        object o;
        o = (B<object>)x4;
        o = (B<object?>)x4;
        o = (B<object>)y4; // 6
        o = (B<object?>)y4;
    }
    static void F5(C<object> x5, C<object?> y5)
    {
        object o;
        o = (IOut<object>)x5;
        o = (IOut<object?>)x5;
        o = (IOut<object>)y5; // 7
        o = (IOut<object?>)y5;
    }
    static void F6(IOut<object> x6, IOut<object?> y6)
    {
        object o;
        o = (C<object>)x6;
        o = (C<object?>)x6; // 8
        o = (C<object>)y6;
        o = (C<object?>)y6;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'I<object?>'.
                //         o = (I<object?>)x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(I<object?>)x1").WithArguments("A<object>", "I<object?>").WithLocation(13, 13),
                // (14,13): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'I<object>'.
                //         o = (I<object>)y1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(I<object>)y1").WithArguments("A<object?>", "I<object>").WithLocation(14, 13),
                // (21,13): warning CS8619: Nullability of reference types in value of type 'I<object>' doesn't match target type 'A<object?>'.
                //         o = (A<object?>)x2; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<object?>)x2").WithArguments("I<object>", "A<object?>").WithLocation(21, 13),
                // (22,13): warning CS8619: Nullability of reference types in value of type 'I<object?>' doesn't match target type 'A<object>'.
                //         o = (A<object>)y2; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<object>)y2").WithArguments("I<object?>", "A<object>").WithLocation(22, 13),
                // (29,13): warning CS8619: Nullability of reference types in value of type 'B<object>' doesn't match target type 'IIn<object?>'.
                //         o = (IIn<object?>)x3; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(IIn<object?>)x3").WithArguments("B<object>", "IIn<object?>").WithLocation(29, 13),
                // (38,13): warning CS8619: Nullability of reference types in value of type 'IIn<object?>' doesn't match target type 'B<object>'.
                //         o = (B<object>)y4; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<object>)y4").WithArguments("IIn<object?>", "B<object>").WithLocation(38, 13),
                // (46,13): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'IOut<object>'.
                //         o = (IOut<object>)y5; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(IOut<object>)y5").WithArguments("C<object?>", "IOut<object>").WithLocation(46, 13),
                // (53,13): warning CS8619: Nullability of reference types in value of type 'IOut<object>' doesn't match target type 'C<object?>'.
                //         o = (C<object?>)x6; // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(C<object?>)x6").WithArguments("IOut<object>", "C<object?>").WithLocation(53, 13));
        }

        [Fact]
        public void ExplicitCast_UserDefined_01()
        {
            var source =
@"class A1
{
    public static implicit operator B?(A1? a) => new B();
}
class A2
{
    public static implicit operator B?(A2 a) => new B();
}
class A3
{
    public static implicit operator B(A3? a) => new B();
}
class A4
{
    public static implicit operator B(A4 a) => new B();
}
class B { }
class C
{
    static void F1(A1? x1, A1 y1)
    {
        B? b;
        b = ((B)x1)/*T:B?*/;
        b = ((B?)x1)/*T:B?*/;
        b = ((B)y1)/*T:B?*/;
        b = ((B?)y1)/*T:B?*/;
    }
    static void F2(A2? x2, A2 y2)
    {
        B? b;
        b = ((B)x2)/*T:B?*/;
        b = ((B?)x2)/*T:B?*/;
        b = ((B)y2)/*T:B?*/;
        b = ((B?)y2)/*T:B?*/;
    }
    static void F3(A3? x3, A3 y3)
    {
        B? b;
        b = ((B)x3)/*T:B!*/;
        b = ((B?)x3)/*T:B!*/;
        b = ((B)y3)/*T:B!*/;
        b = ((B?)y3)/*T:B!*/;
    }
    static void F4(A4? x4, A4 y4)
    {
        B? b;
        b = ((B)x4)/*T:B!*/;
        b = ((B?)x4)/*T:B!*/;
        b = ((B)y4)/*T:B!*/;
        b = ((B?)y4)/*T:B!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (23,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         b = ((B)x1)/*T:B?*/;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)x1").WithLocation(23, 14),
                // (25,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         b = ((B)y1)/*T:B?*/;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)y1").WithLocation(25, 14),
                // (31,17): warning CS8604: Possible null reference argument for parameter 'a' in 'A2.implicit operator B?(A2 a)'.
                //         b = ((B)x2)/*T:B?*/;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("a", "A2.implicit operator B?(A2 a)").WithLocation(31, 17),
                // (31,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         b = ((B)x2)/*T:B?*/;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)x2").WithLocation(31, 14),
                // (32,18): warning CS8604: Possible null reference argument for parameter 'a' in 'A2.implicit operator B?(A2 a)'.
                //         b = ((B?)x2)/*T:B?*/;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x2").WithArguments("a", "A2.implicit operator B?(A2 a)").WithLocation(32, 18),
                // (33,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         b = ((B)y2)/*T:B?*/;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(B)y2").WithLocation(33, 14),
                // (47,17): warning CS8604: Possible null reference argument for parameter 'a' in 'A4.implicit operator B(A4 a)'.
                //         b = ((B)x4)/*T:B!*/;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x4").WithArguments("a", "A4.implicit operator B(A4 a)").WithLocation(47, 17),
                // (48,18): warning CS8604: Possible null reference argument for parameter 'a' in 'A4.implicit operator B(A4 a)'.
                //         b = ((B?)x4)/*T:B!*/;
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x4").WithArguments("a", "A4.implicit operator B(A4 a)").WithLocation(48, 18));
            comp.VerifyTypes();
        }

        [Fact]
        public void ExplicitCast_UserDefined_02()
        {
            var source =
@"class A<T> where T : class?
{
}
class B
{
    public static implicit operator A<string?>(B b) => throw null;
}
class C
{
    public static implicit operator A<string>(C c) => throw null;
    static void F1(B x1)
    {
        var y1 = (A<string?>)x1;
        var z1 = (A<string>)x1; // 1
    }
    static void F2(C x2)
    {
        var y2 = (A<string?>)x2; // 2
        var z2 = (A<string>)x2;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,18): warning CS8619: Nullability of reference types in value of type 'A<string?>' doesn't match target type 'A<string>'.
                //         var z1 = (A<string>)x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<string>)x1").WithArguments("A<string?>", "A<string>").WithLocation(14, 18),
                // (18,18): warning CS8619: Nullability of reference types in value of type 'A<string>' doesn't match target type 'A<string?>'.
                //         var y2 = (A<string?>)x2; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(A<string?>)x2").WithArguments("A<string>", "A<string?>").WithLocation(18, 18));
        }

        [Fact]
        public void ExplicitCast_UserDefined_03()
        {
            var source =
@"class A1<T> where T : class
{
    public static implicit operator B<T?>(A1<T> a) => throw null;
}
class A2<T> where T : class
{
    public static implicit operator B<T>(A2<T> a) => throw null;
}
class B<T> { }
class C<T> where T : class
{
    static void F1(A1<T?> x1, A1<T> y1)
    {
        B<T?> x;
        B<T> y;
        x = ((B<T?>)x1)/*T:B<T?>!*/;
        y = ((B<T>)x1)/*T:B<T!>!*/;
        x = ((B<T?>)y1)/*T:B<T?>!*/;
        y = ((B<T>)y1)/*T:B<T!>!*/;
    }
    static void F2(A2<T?> x2, A2<T> y2)
    {
        B<T?> x;
        B<T> y;
        x = ((B<T?>)x2)/*T:B<T?>!*/;
        y = ((B<T>)x2)/*T:B<T!>!*/;
        x = ((B<T?>)y2)/*T:B<T?>!*/;
        y = ((B<T>)y2)/*T:B<T!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,14): warning CS8619: Nullability of reference types in value of type 'B<T?>' doesn't match target type 'B<T>'.
                //         y = ((B<T>)x1)/*T:B<T!>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<T>)x1").WithArguments("B<T?>", "B<T>").WithLocation(17, 14),
                // (19,14): warning CS8619: Nullability of reference types in value of type 'B<T?>' doesn't match target type 'B<T>'.
                //         y = ((B<T>)y1)/*T:B<T!>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<T>)y1").WithArguments("B<T?>", "B<T>").WithLocation(19, 14),
                // (26,14): warning CS8619: Nullability of reference types in value of type 'B<T?>' doesn't match target type 'B<T>'.
                //         y = ((B<T>)x2)/*T:B<T!>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<T>)x2").WithArguments("B<T?>", "B<T>").WithLocation(26, 14),
                // (27,14): warning CS8619: Nullability of reference types in value of type 'B<T>' doesn't match target type 'B<T?>'.
                //         x = ((B<T?>)y2)/*T:B<T?>*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(B<T?>)y2").WithArguments("B<T>", "B<T?>").WithLocation(27, 14));
            comp.VerifyTypes();
        }

        [Fact]
        public void ExplicitCast_StaticType()
        {
            var source =
@"static class C
{
    static object F(object? x) => (C)x;
    static object? G(object? y) => (C?)y;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,35): error CS0716: Cannot convert to static type 'C'
                //     static object F(object? x) => (C)x;
                Diagnostic(ErrorCode.ERR_ConvertToStaticClass, "(C)x").WithArguments("C").WithLocation(3, 35),
                // (3,35): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static object F(object? x) => (C)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)x").WithLocation(3, 35),
                // (3,35): warning CS8603: Possible null reference return.
                //     static object F(object? x) => (C)x;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(C)x").WithLocation(3, 35),
                // (4,36): error CS0716: Cannot convert to static type 'C'
                //     static object? G(object? y) => (C?)y;
                Diagnostic(ErrorCode.ERR_ConvertToStaticClass, "(C?)y").WithArguments("C").WithLocation(4, 36));
        }

        [Fact]
        public void ForEach_01()
        {
            var source =
@"class Enumerable
{
    public Enumerator GetEnumerator() => new Enumerator();
}
class Enumerator
{
    public object Current => throw null;
    public bool MoveNext() => false;
}
class C
{
    static void F(Enumerable e)
    {
        foreach (var x in e)
            x.ToString();
        foreach (string y in e)
            y.ToString();
        foreach (string? z in e)
            z.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ForEach_02()
        {
            var source =
@"class Enumerable
{
    public Enumerator GetEnumerator() => new Enumerator();
}
class Enumerator
{
    public object? Current => throw null;
    public bool MoveNext() => false;
}
class C
{
    static void F(Enumerable e)
    {
        foreach (var x in e)
            x.ToString();
        foreach (object y in e)
            y.ToString();
        foreach (object? z in e)
            z.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(15, 13),
                // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (object y in e)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "object").WithLocation(16, 18),
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //             y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(17, 13),
                // (19,13): warning CS8602: Possible dereference of a null reference.
                //             z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(19, 13));
        }

        [Fact]
        public void ForEach_03()
        {
            var source =
@"using System.Collections;
namespace System
{
    public class Object
    {
        public string ToString() => throw null;
    }
    public abstract class ValueType { }
    public struct Void { }
    public struct Boolean { }
    public class String { }
    public struct Enum { }
    public class Attribute { }
    public struct Int32 { }
    public class AttributeUsageAttribute : Attribute
    {
        public AttributeUsageAttribute(AttributeTargets validOn) => throw null;
        public bool AllowMultiple { get; set; }
    }
    public enum AttributeTargets { Assembly = 1, Module = 2, Class = 4, Struct = 8,
        Enum = 16, Constructor = 32, Method = 64, Property = 128, Field = 256,
        Event = 512, Interface = 1024, Parameter = 2048, Delegate = 4096, ReturnValue = 8192,
        GenericParameter = 16384, All = 32767 }
    public class ObsoleteAttribute : Attribute
    {
        public ObsoleteAttribute(string message) => throw null;
    }
}
namespace System.Collections
{
    public interface IEnumerable
    {
        IEnumerator GetEnumerator();
    }
    public interface IEnumerator
    {
        object? Current { get; }
        bool MoveNext();
    }
}
class Enumerable : IEnumerable
{
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
class C
{
    static void F(Enumerable e)
    {
        foreach (var x in e)
            x.ToString();
        foreach (object y in e)
            y.ToString();
    }
    static void G(IEnumerable e)
    {
        foreach (var z in e)
            z.ToString();
        foreach (object w in e)
            w.ToString();
    }
}";
            var comp = CreateEmptyCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (50,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(50, 13),
                // (51,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (object y in e)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "object").WithLocation(51, 18),
                // (52,13): warning CS8602: Possible dereference of a null reference.
                //             y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(52, 13),
                // (57,13): warning CS8602: Possible dereference of a null reference.
                //             z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(57, 13),
                // (58,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (object w in e)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "object").WithLocation(58, 18),
                // (59,13): warning CS8602: Possible dereference of a null reference.
                //             w.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w").WithLocation(59, 13));
        }

        // z.ToString() should warn if IEnumerator.Current is annotated as `object?`.
        [Fact]
        public void ForEach_04()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
class C
{
    static void F(IEnumerable<object?> cx, object?[] cy)
    {
        foreach (var x in cx)
            x.ToString();
        foreach (object? y in cy)
            y.ToString();
        foreach (object? z in (IEnumerable)cx)
            z.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13),
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(10, 13));
        }

        [Fact]
        public void ForEach_05()
        {
            var source =
@"class C
{
    static void F1(dynamic c)
    {
        foreach (var x in c)
            x.ToString();
        foreach (object? y in c)
            y.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ForEach_06()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
class C<T> : IEnumerable<T> where T : class
{
    IEnumerator<T> IEnumerable<T>.GetEnumerator() => throw null;
    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
class P
{
    static void F<T>(C<T?> c) where T : class
    {
        foreach (var x in c)
            x.ToString();
        foreach (T? y in c)
            y.ToString();
        foreach (T z in c)
            z.ToString();
        foreach (object w in c)
            w.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(13, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(15, 13),
                // (16,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (T z in c)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "T").WithLocation(16, 18),
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //             z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(17, 13),
                // (18,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (object w in c)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "object").WithLocation(18, 18),
                // (19,13): warning CS8602: Possible dereference of a null reference.
                //             w.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w").WithLocation(19, 13));
        }

        [Fact]
        public void ForEach_07()
        {
            var source =
@"struct S<T> where T : class
{
    public E<T> GetEnumerator() => new E<T>();
}
struct E<T> where T : class
{
    public T Current => throw null;
    public bool MoveNext() => false;
}
class P
{
    static void F1<T>() where T : class
    {
        foreach (var x1 in new S<T>())
            x1.ToString();
        foreach (T y1 in new S<T>())
            y1.ToString();
        foreach (T? z1 in new S<T>())
            z1.ToString();
        foreach (object? w1 in new S<T>())
            w1.ToString();
    }
    static void F2<T>() where T : class
    {
        foreach (var x2 in new S<T?>())
            x2.ToString();
        foreach (T y2 in new S<T?>())
            y2.ToString();
        foreach (T? z2 in new S<T?>())
            z2.ToString();
        foreach (object? w2 in new S<T?>())
            w2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (25,34): warning CS8634: The type 'T?' cannot be used as type parameter 'T' in the generic type or method 'S<T>'. Nullability of type argument 'T?' doesn't match 'class' constraint.
                //         foreach (var x2 in new S<T?>())
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "T?").WithArguments("S<T>", "T", "T?").WithLocation(25, 34),
                // (26,13): warning CS8602: Possible dereference of a null reference.
                //             x2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(26, 13),
                // (27,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (T y2 in new S<T?>())
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "T").WithLocation(27, 18),
                // (27,32): warning CS8634: The type 'T?' cannot be used as type parameter 'T' in the generic type or method 'S<T>'. Nullability of type argument 'T?' doesn't match 'class' constraint.
                //         foreach (T y2 in new S<T?>())
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "T?").WithArguments("S<T>", "T", "T?").WithLocation(27, 32),
                // (28,13): warning CS8602: Possible dereference of a null reference.
                //             y2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y2").WithLocation(28, 13),
                // (29,33): warning CS8634: The type 'T?' cannot be used as type parameter 'T' in the generic type or method 'S<T>'. Nullability of type argument 'T?' doesn't match 'class' constraint.
                //         foreach (T? z2 in new S<T?>())
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "T?").WithArguments("S<T>", "T", "T?").WithLocation(29, 33),
                // (30,13): warning CS8602: Possible dereference of a null reference.
                //             z2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z2").WithLocation(30, 13),
                // (31,38): warning CS8634: The type 'T?' cannot be used as type parameter 'T' in the generic type or method 'S<T>'. Nullability of type argument 'T?' doesn't match 'class' constraint.
                //         foreach (object? w2 in new S<T?>())
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "T?").WithArguments("S<T>", "T", "T?").WithLocation(31, 38),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //             w2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w2").WithLocation(32, 13));
        }

        [Fact]
        public void ForEach_08()
        {
            var source =
@"using System.Collections.Generic;
interface I<T> { T P { get; } }
interface IIn<in T> { }
interface IOut<out T> { T P { get; } }
static class C
{
    static void F1(IEnumerable<I<object>> x1, IEnumerable<I<object?>> y1)
    {
        foreach (I<object?> a1 in x1)
            a1.P.ToString();
        foreach (I<object> b1 in y1)
            b1.P.ToString();
    }
    static void F2(IEnumerable<IIn<object>> x2, IEnumerable<IIn<object?>> y2)
    {
        foreach (IIn<object?> a2 in x2)
            ;
        foreach (IIn<object> b2 in y2)
            ;
    }
    static void F3(IEnumerable<IOut<object>> x3, IEnumerable<IOut<object?>> y3)
    {
        foreach (IOut<object?> a3 in x3)
            a3.P.ToString();
        foreach (IOut<object> b3 in y3)
            b3.P.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             a1.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a1.P").WithLocation(10, 13),
                // (24,13): warning CS8602: Possible dereference of a null reference.
                //             a3.P.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a3.P").WithLocation(24, 13));
        }

        [Fact]
        public void ForEach_09()
        {
            var source =
@"class A { }
class B : A { }
class C
{
    static void F(A?[] c)
    {
        foreach (var a1 in c)
            a1.ToString();
        foreach (A? a2 in c)
            a2.ToString();
        foreach (A a3 in c)
            a3.ToString();
        foreach (B? b1 in c)
            b1.ToString();
        foreach (B b2 in c)
            b2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //             a1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a1").WithLocation(8, 13),
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             a2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a2").WithLocation(10, 13),
                // (11,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (A a3 in c)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "A").WithLocation(11, 18),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             a3.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a3").WithLocation(12, 13),
                // (14,13): warning CS8602: Possible dereference of a null reference.
                //             b1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b1").WithLocation(14, 13),
                // (15,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (B b2 in c)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "B").WithLocation(15, 18),
                // (16,13): warning CS8602: Possible dereference of a null reference.
                //             b2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b2").WithLocation(16, 13));
        }

        [Fact]
        [WorkItem(29971, "https://github.com/dotnet/roslyn/issues/29971")]
        public void ForEach_10()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class A<T>
{
    internal T F;
}
class B : A<object> { }
class C
{
    static void F(A<object?>[] c)
    {
        foreach (var a1 in c)
            a1.F.ToString();
        foreach (A<object?> a2 in c)
            a2.F.ToString();
        foreach (A<object> a3 in c)
            a3.F.ToString();
        foreach (B b1 in c)
            b1.ToString();
    }
}";
            // https://github.com/dotnet/roslyn/issues/29971: Should report WRN_NullabilityMismatchInAssignment
            // for `A<object> a3 in c` and `B b1 in c`.
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //             a1.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a1.F").WithLocation(13, 13),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             a2.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a2.F").WithLocation(15, 13));
        }

        [Fact]
        public void ForEach_11()
        {
            var source =
@"using System.Collections.Generic;
class A
{
    public static implicit operator B?(A a) => null;
}
class B
{
}
class C
{
    static void F(IEnumerable<A> e)
    {
        foreach (var x in e)
            x.ToString();
        foreach (B y in e)
            y.ToString();
        foreach (B? z in e)
        {
            z.ToString();
            if (z != null) z.ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29971: Location of WRN_ConvertingNullableToNonNullable should be `y` rather than `B`.
            comp.VerifyDiagnostics(
                // (15,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (B y in e)
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "B").WithLocation(15, 18),
                // (16,13): warning CS8602: Possible dereference of a null reference.
                //             y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(16, 13),
                // (19,13): warning CS8602: Possible dereference of a null reference.
                //             z.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(19, 13),
                // (20,17): hidden CS8605: Result of the comparison is possibly always true.
                //             if (z != null) z.ToString();
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "z != null").WithLocation(20, 17));
        }

        [WorkItem(23493, "https://github.com/dotnet/roslyn/issues/23493")]
        [Fact]
        public void ForEach_12()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
class C
{
    static void F()
    {
        foreach (var x in (IEnumerable?)null) // 1
        {
        }
        foreach (var y in (IEnumerable<object>)default) // 2
        {
        }
        foreach (var z in default(IEnumerable)) // 3
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,27): error CS0186: Use of null is not valid in this context
                //         foreach (var x in (IEnumerable?)null) // 1
                Diagnostic(ErrorCode.ERR_NullNotValid, "(IEnumerable?)null").WithLocation(7, 27),
                // (10,27): error CS0186: Use of null is not valid in this context
                //         foreach (var y in (IEnumerable<object>)default) // 2
                Diagnostic(ErrorCode.ERR_NullNotValid, "(IEnumerable<object>)default").WithLocation(10, 27),
                // (13,27): error CS0186: Use of null is not valid in this context
                //         foreach (var z in default(IEnumerable)) // 3
                Diagnostic(ErrorCode.ERR_NullNotValid, "default(IEnumerable)").WithLocation(13, 27),
                // (7,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in (IEnumerable?)null) // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable?)null").WithLocation(7, 27),
                // (10,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (var y in (IEnumerable<object>)default) // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IEnumerable<object>)default").WithLocation(10, 27),
                // (10,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var y in (IEnumerable<object>)default) // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable<object>)default").WithLocation(10, 27),
                // (13,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var z in default(IEnumerable)) // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "default(IEnumerable)").WithLocation(13, 27));
        }

        [WorkItem(23493, "https://github.com/dotnet/roslyn/issues/23493")]
        [Fact]
        public void ForEach_13()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
class C
{
    static void F1(object[]? c1)
    {
        foreach (var x in c1) // 1
        {
        }
        foreach (var z in c1) // no cascade
        {
        }
    }
    static void F2(object[]? c1)
    {
        foreach (var y in (IEnumerable)c1) // 2
        {
        }
    }
    static void F3(object[]? c1)
    {
        if (c1 == null) return;
        foreach (var z in c1)
        {
        }
    }
    static void F4(IList<object>? c2)
    {
        foreach (var x in c2) // 3
        {
        }
    }
    static void F5(IList<object>? c2)
    {
        foreach (var y in (IEnumerable?)c2) // 4
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in c1) // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1").WithLocation(7, 27),
                // (16,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (var y in (IEnumerable)c1) // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IEnumerable)c1").WithLocation(16, 27),
                // (16,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var y in (IEnumerable)c1) // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable)c1").WithLocation(16, 27),
                // (29,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in c2) // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(29, 27),
                // (35,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var y in (IEnumerable?)c2) // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable?)c2").WithLocation(35, 27));
        }

        [WorkItem(23493, "https://github.com/dotnet/roslyn/issues/23493")]
        [Fact]
        public void ForEach_14()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
class C
{
    static void F1<T>(T t1) where T : class?, IEnumerable<object>?
    {
        foreach (var x in t1) // 1
        {
        }
    }
    static void F2<T>(T t1) where T : class?, IEnumerable<object>?
    {
        foreach (var y in (IEnumerable<object>?)t1) // 2
        {
        }
    }
    static void F3<T>(T t1) where T : class?, IEnumerable<object>?
    {
        foreach (var z in (IEnumerable<object>)t1) // 3
        {
        }
    }
    static void F4<T>(T t2) where T : class?
    {
        foreach (var w in (IEnumerable?)t2) // 4
        {
        }
    }
    static void F5<T>(T t2) where T : class?
    {
        foreach (var v in (IEnumerable)t2) // 5
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in t1) // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(7, 27),
                // (13,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var y in (IEnumerable<object>?)t1) // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable<object>?)t1").WithLocation(13, 27),
                // (19,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (var z in (IEnumerable<object>)t1) // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IEnumerable<object>)t1").WithLocation(19, 27),
                // (19,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var z in (IEnumerable<object>)t1) // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable<object>)t1").WithLocation(19, 27),
                // (25,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var w in (IEnumerable?)t2) // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable?)t2").WithLocation(25, 27),
                // (31,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (var v in (IEnumerable)t2) // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IEnumerable)t2").WithLocation(31, 27),
                // (31,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var v in (IEnumerable)t2) // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable)t2").WithLocation(31, 27));
        }

        [WorkItem(23493, "https://github.com/dotnet/roslyn/issues/23493")]
        [Fact]
        public void ForEach_15()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
class C
{
    static void F1<T>(T t1) where T : IEnumerable?
    {
        foreach (var x in t1) // 1
        {
        }
        foreach (var x in t1) // no cascade
        {
        }
    }
    static void F2<T>(T t1) where T : IEnumerable?
    {
        foreach (var w in (IEnumerable?)t1) // 2
        {
        }
    }
    static void F3<T>(T t1) where T : IEnumerable?
    {
        foreach (var v in (IEnumerable)t1) // 3
        {
        }
    }
    static void F4<T>(T t2)
    {
        foreach (var y in (IEnumerable<object>?)t2) // 4
        {
        }
    }
    static void F5<T>(T t2)
    {
        foreach (var z in (IEnumerable<object>)t2) // 5
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in t1) // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(7, 27),
                // (16,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var w in (IEnumerable?)t1) // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable?)t1").WithLocation(16, 27),
                // (22,27): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         foreach (var v in (IEnumerable)t1) // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(IEnumerable)t1").WithLocation(22, 27),
                // (22,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var v in (IEnumerable)t1) // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(IEnumerable)t1").WithLocation(22, 27));
        }

        [Fact]
        [WorkItem(29972, "https://github.com/dotnet/roslyn/issues/29972")]
        public void ForEach_16()
        {
            var source =
@"using System.Collections;
class Enumerable : IEnumerable
{
    public IEnumerator? GetEnumerator() => null;
}
class C
{
    static void F(Enumerable e)
    {
        foreach (var x in e) // 1
        {
        }
        foreach (var y in (IEnumerable?)e)
        {
        }
        foreach (var z in (IEnumerable)e)
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29972: Should report WRN_NullReferenceReceiver using Enumerable.GetEnumerator.
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void ForEach_UnconstrainedTypeParameter()
        {
            var source =
@"class C<T>
{
    void M(T parameter)
    {
        foreach (T local in new[] { parameter })
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_01()
        {
            var source =
@"class A { }
class B { }
class C
{
    static void F<T>(T? t) where T : A { }
    static void G(B? b)
    {
        F(b);
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (8,9): error CS0311: The type 'B' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>(T?)'. There is no implicit reference conversion from 'B' to 'A'.
                //         F(b);
                Diagnostic(ErrorCode.ERR_GenericConstraintNotSatisfiedRefType, "F").WithArguments("C.F<T>(T?)", "A", "T", "B").WithLocation(8, 9));
        }

        [Fact]
        public void TypeInference_02()
        {
            var source =
@"interface I<T> { }
class C
{
    static T F<T>(I<T> t)
    {
        throw new System.Exception();
    }
    static void G(I<string> x, I<string?> y)
    {
        F(x).ToString();
        F(y).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         F(y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y)").WithLocation(11, 9));
        }

        [Fact]
        public void TypeInference_03()
        {
            var source =
@"interface I<T> { }
class C
{
    static T F1<T>(I<T?> t)
    {
        throw new System.Exception();
    }
    static void G1(I<string> x1, I<string?> y1)
    {
        F1(x1).ToString(); // 1
        F1(y1).ToString(); // 2
    }
    static T F2<T>(I<T?> t) where T : class
    {
        throw new System.Exception();
    }
    static void G2(I<string> x2, I<string?> y2)
    {
        F2(x2).ToString(); // 3
        F2(y2).ToString(); // 4
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (4,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static T F1<T>(I<T?> t)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 22),
                // (10,12): warning CS8620: Nullability of reference types in argument of type 'I<string>' doesn't match target type 'I<string?>' for parameter 't' in 'string C.F1<string>(I<string?> t)'.
                //         F1(x1).ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x1").WithArguments("I<string>", "I<string?>", "t", "string C.F1<string>(I<string?> t)").WithLocation(10, 12),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         F1(y1).ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F1(y1)").WithLocation(11, 9),
                // (19,12): warning CS8620: Nullability of reference types in argument of type 'I<string>' doesn't match target type 'I<string?>' for parameter 't' in 'string C.F2<string>(I<string?> t)'.
                //         F2(x2).ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x2").WithArguments("I<string>", "I<string?>", "t", "string C.F2<string>(I<string?> t)").WithLocation(19, 12));
        }

        [WorkItem(27961, "https://github.com/dotnet/roslyn/issues/27961")]
        [Fact]
        public void TypeInference_LowerBounds_TopLevelNullability_01()
        {
            var source0 =
@"public class A
{
    public static A F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static T F<T>(T x, T y) => throw null;
    static void G(A? x, A y)
    {
        var z = A.F;
        F(x, x)/*T:A?*/;
        F(x, y)/*T:A?*/;
        F(x, z)/*T:A?*/;
        F(y, x)/*T:A?*/;
        F(y, y)/*T:A!*/;
        F(y, z)/*T:A*/;
        F(z, x)/*T:A?*/;
        F(z, y)/*T:A*/;
        F(z, z)/*T:A*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_LowerBounds_TopLevelNullability_02()
        {
            var source =
@"class C
{
    static T F<T>(T x, T y) => throw null;
    static void G<T, U>(T t, U u)
        where T : class?
        where U : class, T
    {
        F(t, t)/*T:T*/;
        F(t, u)/*T:T*/;
        F(u, t)/*T:T*/;
        F(u, u)/*T:U!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [WorkItem(27961, "https://github.com/dotnet/roslyn/issues/27961")]
        [Fact]
        public void TypeInference_ExactBounds_TopLevelNullability_01()
        {
            var source0 =
@"public class A
{
    public static A F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static T F<T>(out T x, out T y) => throw null;
    static void G(A? x, A y)
    {
        var z = A.F;
        F(out x, out x)/*T:A?*/;
        F(out x, out y)/*T:A!*/; // 1
        F(out x, out z)/*T:A?*/;
        F(out y, out x)/*T:A!*/; // 2
        F(out y, out y)/*T:A!*/;
        F(out y, out z)/*T:A!*/;
        F(out z, out x)/*T:A?*/;
        F(out z, out y)/*T:A!*/;
        F(out z, out z)/*T:A*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();

            // Missing conversion diagnostics
            // Tracked by https://github.com/dotnet/roslyn/issues/29958

            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void TypeInference_LowerBounds_NestedNullability_Variant_01()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static I<T> CreateI<T>(T t) => throw null;
    static void G1(I<string> x1, I<string?> y1)
    {
        var z1 = CreateI(A.F)/*T:I<string>!*/;
        F(x1, x1)/*T:I<string!>!*/;
        F(x1, y1)/*T:I<string!>!*/; // 1
        F(x1, z1)/*T:I<string!>!*/;
        F(y1, x1)/*T:I<string!>!*/; // 2
        F(y1, y1)/*T:I<string?>!*/;
        F(y1, z1)/*T:I<string?>!*/;
        F(z1, x1)/*T:I<string!>!*/;
        F(z1, y1)/*T:I<string?>!*/;
        F(z1, z1)/*T:I<string>!*/;
    }
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static void G2(IIn<string> x2, IIn<string?> y2)
    {
        var z2 = CreateIIn(A.F)/*T:IIn<string>!*/;
        F(x2, x2)/*T:IIn<string!>!*/;
        F(x2, y2)/*T:IIn<string!>!*/;
        F(x2, z2)/*T:IIn<string!>!*/;
        F(y2, x2)/*T:IIn<string!>!*/;
        F(y2, y2)/*T:IIn<string?>!*/;
        F(y2, z2)/*T:IIn<string>!*/;
        F(z2, x2)/*T:IIn<string!>!*/;
        F(z2, y2)/*T:IIn<string>!*/;
        F(z2, z2)/*T:IIn<string>!*/;
    }
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void G3(IOut<string> x3, IOut<string?> y3)
    {
        var z3 = CreateIOut(A.F)/*T:IOut<string>!*/;
        F(x3, x3)/*T:IOut<string!>!*/;
        F(x3, y3)/*T:IOut<string?>!*/;
        F(x3, z3)/*T:IOut<string>!*/;
        F(y3, x3)/*T:IOut<string?>!*/;
        F(y3, y3)/*T:IOut<string?>!*/;
        F(y3, z3)/*T:IOut<string?>!*/;
        F(z3, x3)/*T:IOut<string>!*/;
        F(z3, y3)/*T:IOut<string?>!*/;
        F(z3, z3)/*T:IOut<string>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (12,15): warning CS8620: Nullability of reference types in argument of type 'I<string?>' doesn't match target type 'I<string>' for parameter 'y' in 'I<string> C.F<I<string>>(I<string> x, I<string> y)'.
                //         F(x1, y1)/*T:I<string!>!*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("I<string?>", "I<string>", "y", "I<string> C.F<I<string>>(I<string> x, I<string> y)").WithLocation(12, 15),
                // (14,11): warning CS8620: Nullability of reference types in argument of type 'I<string?>' doesn't match target type 'I<string>' for parameter 'x' in 'I<string> C.F<I<string>>(I<string> x, I<string> y)'.
                //         F(y1, x1)/*T:I<string!>!*/; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("I<string?>", "I<string>", "x", "I<string> C.F<I<string>>(I<string> x, I<string> y)").WithLocation(14, 11));
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void TypeInference_LowerBounds_NestedNullability_Variant_02()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface IOut<out T, out U> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static T F<T>(T x, T y, T z) => throw null;
    static IOut<T, U> CreateIOut<T, U>(T t, U u) => throw null;
    static void G(string x, string? y)
    {
        var z = A.F/*T:string*/;
        F(CreateIOut(x, x), CreateIOut(x, y))/*T:IOut<string!, string?>!*/;
        F(CreateIOut(x, x), CreateIOut(x, z))/*T:IOut<string!, string>!*/;
        F(CreateIOut(y, x), CreateIOut(x, x))/*T:IOut<string?, string!>!*/;
        F(CreateIOut(y, z), CreateIOut(z, x))/*T:IOut<string?, string>!*/;
        F(CreateIOut(x, x), CreateIOut(x, y), CreateIOut(x, z))/*T:IOut<string!, string?>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void TypeInference_LowerBounds_NestedNullability_Variant_03()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static I<IOut<T>> Create1<T>(T t) => throw null;
    static void G1(I<IOut<string?>> x1, I<IOut<string>> y1)
    {
        var z1 = Create1(A.F)/*T:I<IOut<string>!>!*/;
        F(x1, x1)/*T:I<IOut<string?>!>!*/;
        F(x1, y1)/*T:I<IOut<string!>!>!*/; // 1
        F(x1, z1)/*T:I<IOut<string?>!>!*/;
        F(y1, x1)/*T:I<IOut<string!>!>!*/; // 2
        F(y1, y1)/*T:I<IOut<string!>!>!*/;
        F(y1, z1)/*T:I<IOut<string!>!>!*/;
        F(z1, x1)/*T:I<IOut<string?>!>!*/;
        F(z1, y1)/*T:I<IOut<string!>!>!*/;
        F(z1, z1)/*T:I<IOut<string>!>!*/;
    }
    static IOut<IIn<T>> Create2<T>(T t) => throw null;
    static void G2(IOut<IIn<string?>> x2, IOut<IIn<string>> y2)
    {
        var z2 = Create2(A.F)/*T:IOut<IIn<string>!>!*/;
        F(x2, x2)/*T:IOut<IIn<string?>!>!*/;
        F(x2, y2)/*T:IOut<IIn<string!>!>!*/;
        F(x2, z2)/*T:IOut<IIn<string>!>!*/;
        F(y2, x2)/*T:IOut<IIn<string!>!>!*/;
        F(y2, y2)/*T:IOut<IIn<string!>!>!*/;
        F(y2, z2)/*T:IOut<IIn<string!>!>!*/;
        F(z2, x2)/*T:IOut<IIn<string>!>!*/;
        F(z2, y2)/*T:IOut<IIn<string!>!>!*/;
        F(z2, z2)/*T:IOut<IIn<string>!>!*/;
    }
    static IIn<IOut<T>> Create3<T>(T t) => throw null;
    static void G3(IIn<IOut<string?>> x3, IIn<IOut<string>> y3)
    {
        var z3 = Create3(A.F)/*T:IIn<IOut<string>!>!*/;
        F(x3, x3)/*T:IIn<IOut<string?>!>!*/;
        F(x3, y3)/*T:IIn<IOut<string!>!>!*/;
        F(x3, z3)/*T:IIn<IOut<string>!>!*/;
        F(y3, x3)/*T:IIn<IOut<string!>!>!*/;
        F(y3, y3)/*T:IIn<IOut<string!>!>!*/;
        F(y3, z3)/*T:IIn<IOut<string!>!>!*/;
        F(z3, x3)/*T:IIn<IOut<string>!>!*/;
        F(z3, y3)/*T:IIn<IOut<string!>!>!*/;
        F(z3, z3)/*T:IIn<IOut<string>!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (12,11): warning CS8620: Nullability of reference types in argument of type 'I<IOut<string?>>' doesn't match target type 'I<IOut<string>>' for parameter 'x' in 'I<IOut<string>> C.F<I<IOut<string>>>(I<IOut<string>> x, I<IOut<string>> y)'.
                //         F(x1, y1)/*T:I<IOut<string>!>!*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x1").WithArguments("I<IOut<string?>>", "I<IOut<string>>", "x", "I<IOut<string>> C.F<I<IOut<string>>>(I<IOut<string>> x, I<IOut<string>> y)").WithLocation(12, 11),
                // (14,15): warning CS8620: Nullability of reference types in argument of type 'I<IOut<string?>>' doesn't match target type 'I<IOut<string>>' for parameter 'y' in 'I<IOut<string>> C.F<I<IOut<string>>>(I<IOut<string>> x, I<IOut<string>> y)'.
                //         F(y1, x1)/*T:I<IOut<string>!>!*/; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x1").WithArguments("I<IOut<string?>>", "I<IOut<string>>", "y", "I<IOut<string>> C.F<I<IOut<string>>>(I<IOut<string>> x, I<IOut<string>> y)").WithLocation(14, 15));
            comp.VerifyTypes();
        }

        [Fact]
        public void TypeInference_ExactBounds_TopLevelNullability_02()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T> { }
class C
{
    static T F<T>(B<T> x, B<T> y) => throw null;
    static B<T> CreateB<T>(T t) => throw null;
    static void G(B<string?> x, B<string> y)
    {
        var z = CreateB(A.F)/*T:B<string>!*/;
        F(x, x)/*T:string?*/;
        F(x, y)/*T:string!*/; // 1
        F(x, z)/*T:string?*/;
        F(y, x)/*T:string!*/; // 2
        F(y, y)/*T:string!*/;
        F(y, z)/*T:string!*/;
        F(z, x)/*T:string?*/;
        F(z, y)/*T:string!*/;
        F(z, z)/*T:string*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (10,11): warning CS8620: Nullability of reference types in argument of type 'B<string?>' doesn't match target type 'B<string>' for parameter 'x' in 'string C.F<string>(B<string> x, B<string> y)'.
                //         F(x, y)/*T:string!*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<string?>", "B<string>", "x", "string C.F<string>(B<string> x, B<string> y)").WithLocation(10, 11),
                // (12,14): warning CS8620: Nullability of reference types in argument of type 'B<string?>' doesn't match target type 'B<string>' for parameter 'y' in 'string C.F<string>(B<string> x, B<string> y)'.
                //         F(y, x)/*T:string!*/; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<string?>", "B<string>", "y", "string C.F<string>(B<string> x, B<string> y)").WithLocation(12, 14));
        }

        [Fact]
        public void TypeInference_ExactBounds_NestedNullability()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T> { }
class Program
{
    static T F<T>(T x, T y, T z) => throw null;
    static B<T> CreateB<T>(T t) => throw null;
    static void G(B<object?> x, B<object> y)
    {
        var z = CreateB(A.F)/*T:B<object>!*/;
        F(x, x, x)/*T:B<object?>!*/;
        F(x, x, y)/*T:B<object!>!*/;
        F(x, x, z)/*T:B<object?>!*/;
        F(x, y, x)/*T:B<object!>!*/;
        F(x, y, y)/*T:B<object!>!*/;
        F(x, y, z)/*T:B<object!>!*/;
        F(x, z, x)/*T:B<object?>!*/;
        F(x, z, y)/*T:B<object!>!*/;
        F(x, z, z)/*T:B<object?>!*/;
        F(y, x, x)/*T:B<object!>!*/;
        F(y, x, y)/*T:B<object!>!*/;
        F(y, x, z)/*T:B<object!>!*/;
        F(y, y, x)/*T:B<object!>!*/;
        F(y, y, y)/*T:B<object!>!*/;
        F(y, y, z)/*T:B<object!>!*/;
        F(y, z, x)/*T:B<object!>!*/;
        F(y, z, y)/*T:B<object!>!*/;
        F(y, z, z)/*T:B<object!>!*/;
        F(z, x, x)/*T:B<object?>!*/;
        F(z, x, y)/*T:B<object!>!*/;
        F(z, x, z)/*T:B<object?>!*/;
        F(z, y, x)/*T:B<object!>!*/;
        F(z, y, y)/*T:B<object!>!*/;
        F(z, y, z)/*T:B<object!>!*/;
        F(z, z, x)/*T:B<object?>!*/;
        F(z, z, y)/*T:B<object!>!*/;
        F(z, z, z)/*T:B<object>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (10,11): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'x' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(x, x, y)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "x", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(10, 11),
                // (10,14): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'y' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(x, x, y)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "y", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(10, 14),
                // (12,11): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'x' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(x, y, x)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "x", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(12, 11),
                // (12,17): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'z' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(x, y, x)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "z", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(12, 17),
                // (13,11): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'x' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(x, y, y)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "x", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(13, 11),
                // (14,11): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'x' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(x, y, z)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "x", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(14, 11),
                // (16,11): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'x' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(x, z, y)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "x", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(16, 11),
                // (18,14): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'y' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(y, x, x)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "y", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(18, 14),
                // (18,17): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'z' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(y, x, x)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "z", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(18, 17),
                // (19,14): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'y' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(y, x, y)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "y", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(19, 14),
                // (20,14): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'y' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(y, x, z)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "y", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(20, 14),
                // (21,17): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'z' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(y, y, x)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "z", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(21, 17),
                // (24,17): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'z' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(y, z, x)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "z", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(24, 17),
                // (28,14): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'y' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(z, x, y)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "y", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(28, 14),
                // (30,17): warning CS8620: Nullability of reference types in argument of type 'B<object?>' doesn't match target type 'B<object>' for parameter 'z' in 'B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)'.
                //         F(z, y, x)/*T:B<object>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?>", "B<object>", "z", "B<object> Program.F<B<object>>(B<object> x, B<object> y, B<object> z)").WithLocation(30, 17));
            comp.VerifyTypes();
        }

        [Fact]
        public void TypeInference_ExactAndLowerBounds_TopLevelNullability()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T> { }
class C
{
    static T F<T>(T x, B<T> y) => throw null;
    static B<T> CreateB<T>(T t) => throw null;
    static void G(string? x, string y)
    {
        var z = A.F/*T:string*/;
        F(x, CreateB(x))/*T:string?*/;
        F(x, CreateB(y))/*T:string?*/; // 1
        F(x, CreateB(z))/*T:string?*/;
        F(y, CreateB(x))/*T:string?*/;
        F(y, CreateB(y))/*T:string!*/;
        F(y, CreateB(z))/*T:string*/;
        F(z, CreateB(x))/*T:string?*/;
        F(z, CreateB(y))/*T:string*/;
        F(z, CreateB(z))/*T:string*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (10,14): warning CS8620: Nullability of reference types in argument of type 'B<string>' doesn't match target type 'B<string?>' for parameter 'y' in 'string? C.F<string?>(string? x, B<string?> y)'.
                //         F(x, CreateB(y))/*T:string?*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "CreateB(y)").WithArguments("B<string>", "B<string?>", "y", "string? C.F<string?>(string? x, B<string?> y)").WithLocation(10, 14));
        }

        [Fact]
        public void TypeInference_ExactAndUpperBounds_TopLevelNullability()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface IIn<in T> { }
class B<T> { }
class C
{
    static T F<T>(IIn<T> x, B<T> y) => throw null;
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static B<T> CreateB<T>(T t) => throw null;
    static void G(string? x, string y)
    {
        var z = A.F/*T:string*/;
        F(CreateIIn(x), CreateB(x))/*T:string?*/;
        F(CreateIIn(x), CreateB(y))/*T:string!*/;
        F(CreateIIn(x), CreateB(z))/*T:string*/;
        F(CreateIIn(y), CreateB(x))/*T:string!*/; // 1
        F(CreateIIn(y), CreateB(y))/*T:string!*/;
        F(CreateIIn(y), CreateB(z))/*T:string!*/;
        F(CreateIIn(z), CreateB(x))/*T:string*/;
        F(CreateIIn(z), CreateB(y))/*T:string!*/;
        F(CreateIIn(z), CreateB(z))/*T:string*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (14,25): warning CS8620: Nullability of reference types in argument of type 'B<string?>' doesn't match target type 'B<string>' for parameter 'y' in 'string C.F<string>(IIn<string> x, B<string> y)'.
                //         F(CreateIIn(y), CreateB(x))/*T:string*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "CreateB(x)").WithArguments("B<string?>", "B<string>", "y", "string C.F<string>(IIn<string> x, B<string> y)").WithLocation(14, 25));
        }

        [Fact]
        [WorkItem(29837, "https://github.com/dotnet/roslyn/issues/29837")]
        public void TypeInference_MixedBounds_NestedNullability()
        {
            var source0 =
@"public class A
{
    public static object F1;
    public static string F2;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface IIn<in T, U> { }
interface IOut<T, out U> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static IIn<T, U> CreateIIn<T, U>(T t, U u) => throw null;
    static void F1(bool b, IIn<object, string> x1, IIn<object?, string?> y1)
    {
        var z1 = CreateIIn(A.F1, A.F2)/*T:IIn<object, string>!*/;
        F(x1, x1)/*T:IIn<object!, string!>!*/;
        F(x1, y1)/*T:IIn<object!, string!>!*/;
        F(x1, z1)/*T:IIn<object!, string!>!*/;
        F(y1, x1)/*T:IIn<object!, string!>!*/;
        F(y1, y1)/*T:IIn<object?, string?>!*/;
        F(y1, z1)/*T:IIn<object, string?>!*/;
        F(z1, x1)/*T:IIn<object!, string!>!*/;
        F(z1, y1)/*T:IIn<object, string?>!*/;
        F(z1, z1)/*T:IIn<object, string>!*/;
    }
    static IOut<T, U> CreateIOut<T, U>(T t, U u) => throw null;
    static void F2(bool b, IOut<object, string> x2, IOut<object?, string?> y2)
    {
        var z2 = CreateIOut(A.F1, A.F2)/*T:IOut<object, string>!*/;
        F(x2, x2)/*T:IOut<object!, string!>!*/;
        F(x2, y2)/*T:IOut<object!, string?>!*/;
        F(x2, z2)/*T:IOut<object!, string>!*/;
        F(y2, x2)/*T:IOut<object!, string?>!*/;
        F(y2, y2)/*T:IOut<object?, string?>!*/;
        F(y2, z2)/*T:IOut<object?, string?>!*/;
        F(z2, x2)/*T:IOut<object!, string>!*/;
        F(z2, y2)/*T:IOut<object?, string?>!*/;
        F(z2, z2)/*T:IOut<object, string>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,15): warning CS8620: Nullability of reference types in argument of type 'IIn<object?, string?>' doesn't match target type 'IIn<object, string>' for parameter 'y' in 'IIn<object, string> C.F<IIn<object, string>>(IIn<object, string> x, IIn<object, string> y)'.
                //         F(x1, y1)/*T:IIn<object!, string!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("IIn<object?, string?>", "IIn<object, string>", "y", "IIn<object, string> C.F<IIn<object, string>>(IIn<object, string> x, IIn<object, string> y)").WithLocation(11, 15),
                // (13,11): warning CS8620: Nullability of reference types in argument of type 'IIn<object?, string?>' doesn't match target type 'IIn<object, string>' for parameter 'x' in 'IIn<object, string> C.F<IIn<object, string>>(IIn<object, string> x, IIn<object, string> y)'.
                //         F(y1, x1)/*T:IIn<object!, string!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("IIn<object?, string?>", "IIn<object, string>", "x", "IIn<object, string> C.F<IIn<object, string>>(IIn<object, string> x, IIn<object, string> y)").WithLocation(13, 11),
                // (25,15): warning CS8620: Nullability of reference types in argument of type 'IOut<object?, string?>' doesn't match target type 'IOut<object, string?>' for parameter 'y' in 'IOut<object, string?> C.F<IOut<object, string?>>(IOut<object, string?> x, IOut<object, string?> y)'.
                //         F(x2, y2)/*T:IOut<object!, string?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y2").WithArguments("IOut<object?, string?>", "IOut<object, string?>", "y", "IOut<object, string?> C.F<IOut<object, string?>>(IOut<object, string?> x, IOut<object, string?> y)").WithLocation(25, 15),
                // (27,11): warning CS8620: Nullability of reference types in argument of type 'IOut<object?, string?>' doesn't match target type 'IOut<object, string?>' for parameter 'x' in 'IOut<object, string?> C.F<IOut<object, string?>>(IOut<object, string?> x, IOut<object, string?> y)'.
                //         F(y2, x2)/*T:IOut<object!, string?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y2").WithArguments("IOut<object?, string?>", "IOut<object, string?>", "x", "IOut<object, string?> C.F<IOut<object, string?>>(IOut<object, string?> x, IOut<object, string?> y)").WithLocation(27, 11)

                );
            comp.VerifyTypes();
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_MismatchedTypes()
        {
            var source =
@"interface IOut<out T> { }
class Program
{
    static T F<T>(T x, T y) => throw null;
    static void G(IOut<object> x, IOut<string?> y)
    {
        F(x, y)/*T:IOut<object!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // Ideally we'd infer IOut<object?> but the spec doesn't require merging nullability
            // across distinct types (in this case, the lower bounds IOut<object!> and IOut<string?>).
            // Instead, method type inference infers IOut<object!> and a warning is reported
            // converting the second argument to the inferred parameter type.
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (7,14): warning CS8620: Nullability of reference types in argument of type 'IOut<string?>' doesn't match target type 'IOut<object>' for parameter 'y' in 'IOut<object> Program.F<IOut<object>>(IOut<object> x, IOut<object> y)'.
                //         F(x, y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IOut<string?>", "IOut<object>", "y", "IOut<object> Program.F<IOut<object>>(IOut<object> x, IOut<object> y)").WithLocation(7, 14));
        }

        [Fact]
        public void TypeInference_LowerAndUpperBounds_NestedNullability()
        {
            var source =
@"interface IIn<in T> { }
interface IOut<out T> { }
class Program
{
    static T FIn<T>(T x, T y, IIn<T> z) => throw null;
    static T FOut<T>(T x, T y, IOut<T> z) => throw null;
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void G1(IIn<string?> x1, IIn<string> y1)
    {
        FIn(x1, y1, CreateIIn(x1))/*T:IIn<string!>!*/; // 1
        FIn(x1, y1, CreateIIn(y1))/*T:IIn<string!>!*/;
        FOut(x1, y1, CreateIOut(x1))/*T:IIn<string!>!*/;
        FOut(x1, y1, CreateIOut(y1))/*T:IIn<string!>!*/;
    }
    static void G2(IOut<string?> x2, IOut<string> y2)
    {
        FIn(x2, y2, CreateIIn(x2))/*T:IOut<string?>!*/;
        FIn(x2, y2, CreateIIn(y2))/*T:IOut<string?>!*/; // 2
        FOut(x2, y2, CreateIOut(x2))/*T:IOut<string?>!*/;
        FOut(x2, y2, CreateIOut(y2))/*T:IOut<string?>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // Ideally we'd fail to infer nullability for // 1 and // 2 rather than inferring the
            // wrong nullability and then reporting a warning converting the arguments.
            // (See MethodTypeInferrer.TryMergeAndReplaceIfStillCandidate which ignores
            // the variance used merging earlier candidates when merging later candidates.)
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (11,21): warning CS8620: Nullability of reference types in argument of type 'IIn<IIn<string?>>' doesn't match target type 'IIn<IIn<string>>' for parameter 'z' in 'IIn<string> Program.FIn<IIn<string>>(IIn<string> x, IIn<string> y, IIn<IIn<string>> z)'.
                //         FIn(x1, y1, CreateIIn(x1))/*T:IIn<string!>!*/; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "CreateIIn(x1)").WithArguments("IIn<IIn<string?>>", "IIn<IIn<string>>", "z", "IIn<string> Program.FIn<IIn<string>>(IIn<string> x, IIn<string> y, IIn<IIn<string>> z)").WithLocation(11, 21),
                // (19,21): warning CS8620: Nullability of reference types in argument of type 'IIn<IOut<string>>' doesn't match target type 'IIn<IOut<string?>>' for parameter 'z' in 'IOut<string?> Program.FIn<IOut<string?>>(IOut<string?> x, IOut<string?> y, IIn<IOut<string?>> z)'.
                //         FIn(x2, y2, CreateIIn(y2))/*T:IOut<string?>!*/; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "CreateIIn(y2)").WithArguments("IIn<IOut<string>>", "IIn<IOut<string?>>", "z", "IOut<string?> Program.FIn<IOut<string?>>(IOut<string?> x, IOut<string?> y, IIn<IOut<string?>> z)").WithLocation(19, 21));
        }

        [Fact]
        public void TypeInference_05()
        {
            var source =
@"class C
{
    static T F<T>(T x, T? y) where T : class => x;
    static void G(C? x, C y)
    {
        F(x, x).ToString();
        F(x, y).ToString();
        F(y, x).ToString();
        F(y, y).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8634: The type 'C?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>(T, T?)'. Nullability of type argument 'C?' doesn't match 'class' constraint.
                //         F(x, x).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>(T, T?)", "T", "C?").WithLocation(6, 9),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         F(x, x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x, x)").WithLocation(6, 9),
                // (7,9): warning CS8634: The type 'C?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>(T, T?)'. Nullability of type argument 'C?' doesn't match 'class' constraint.
                //         F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>(T, T?)", "T", "C?").WithLocation(7, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         F(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x, y)").WithLocation(7, 9));
        }

        [Fact]
        public void TypeInference_06()
        {
            var source =
@"class C
{
    static T F<T, U>(T t, U u) where U : T => t;
    static void G(C? x, C y)
    {
        F(x, x).ToString(); // warning: may be null
        F(x, y).ToString(); // warning may be null
        F(y, x).ToString(); // warning: x does not satisfy U constraint
        F(y, y).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         F(x, x).ToString(); // warning: may be null
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x, x)").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         F(x, y).ToString(); // warning may be null
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x, y)").WithLocation(7, 9),
                // (8,9): warning CS8631: The type 'C?' cannot be used as type parameter 'U' in the generic type or method 'C.F<T, U>(T, U)'. Nullability of type argument 'C?' doesn't match constraint type 'C'.
                //         F(y, x).ToString(); // warning: x does not satisfy U constraint
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F").WithArguments("C.F<T, U>(T, U)", "C", "U", "C?").WithLocation(8, 9));
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_MismatchedNullability()
        {
            var source0 =
@"public class A
{
    public static object F;
    public static string G;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T, U> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static B<T, U> CreateB<T, U>(T t, U u) => throw null;
    static void G(object? t1, object t2, string? u1, string u2)
    {
        var t3 = A.F/*T:object*/;
        var u3 = A.G/*T:string*/;
        var x = CreateB(t1, u2)/*T:B<object?, string!>!*/;
        var y = CreateB(t2, u1)/*T:B<object!, string?>!*/;
        var z = CreateB(t1, u3)/*T:B<object?, string>!*/;
        var w = CreateB(t3, u2)/*T:B<object, string!>!*/;
        F(x, y)/*T:B<object!, string!>!*/;
        F(x, z)/*T:B<object?, string!>!*/;
        F(x, w)/*T:B<object?, string!>!*/;
        F(y, z)/*T:B<object!, string?>!*/;
        F(y, w)/*T:B<object!, string!>!*/;
        F(w, z)/*T:B<object?, string!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (14,11): warning CS8620: Nullability of reference types in argument of type 'B<object?, string>' doesn't match target type 'B<object, string>' for parameter 'x' in 'B<object, string> C.F<B<object, string>>(B<object, string> x, B<object, string> y)'.
                //         F(x, y)/*T:B<object!, string!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("B<object?, string>", "B<object, string>", "x", "B<object, string> C.F<B<object, string>>(B<object, string> x, B<object, string> y)").WithLocation(14, 11),
                // (14,14): warning CS8620: Nullability of reference types in argument of type 'B<object, string?>' doesn't match target type 'B<object, string>' for parameter 'y' in 'B<object, string> C.F<B<object, string>>(B<object, string> x, B<object, string> y)'.
                //         F(x, y)/*T:B<object!, string!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("B<object, string?>", "B<object, string>", "y", "B<object, string> C.F<B<object, string>>(B<object, string> x, B<object, string> y)").WithLocation(14, 14),
                // (17,14): warning CS8620: Nullability of reference types in argument of type 'B<object?, string>' doesn't match target type 'B<object, string?>' for parameter 'y' in 'B<object, string?> C.F<B<object, string?>>(B<object, string?> x, B<object, string?> y)'.
                //         F(y, z)/*T:B<object!, string?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("B<object?, string>", "B<object, string?>", "y", "B<object, string?> C.F<B<object, string?>>(B<object, string?> x, B<object, string?> y)").WithLocation(17, 14),
                // (18,11): warning CS8620: Nullability of reference types in argument of type 'B<object, string?>' doesn't match target type 'B<object, string>' for parameter 'x' in 'B<object, string> C.F<B<object, string>>(B<object, string> x, B<object, string> y)'.
                //         F(y, w)/*T:B<object!, string!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("B<object, string?>", "B<object, string>", "x", "B<object, string> C.F<B<object, string>>(B<object, string> x, B<object, string> y)").WithLocation(18, 11));
        }

        [Fact]
        public void TypeInference_UpperBounds_NestedNullability_MismatchedNullability()
        {
            var source0 =
@"public class A
{
    public static object F;
    public static string G;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface IIn<in T> { }
class B<T, U> { }
class C
{
    static T F<T>(IIn<T> x, IIn<T> y) => throw null;
    static IIn<B<T, U>> CreateB<T, U>(T t, U u) => throw null;
    static void G(object? t1, object t2, string? u1, string u2)
    {
        var t3 = A.F/*T:object*/;
        var u3 = A.G/*T:string*/;
        var x = CreateB(t1, u2)/*T:IIn<B<object?, string!>!>!*/;
        var y = CreateB(t2, u1)/*T:IIn<B<object!, string?>!>!*/;
        var z = CreateB(t1, u3)/*T:IIn<B<object?, string>!>!*/;
        var w = CreateB(t3, u2)/*T:IIn<B<object, string!>!>!*/;
        F(x, y)/*T:B<object!, string!>!*/;
        F(x, z)/*T:B<object?, string!>!*/;
        F(x, w)/*T:B<object?, string!>!*/;
        F(y, z)/*T:B<object!, string?>!*/;
        F(y, w)/*T:B<object!, string!>!*/;
        F(w, z)/*T:B<object?, string!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (15,11): warning CS8620: Nullability of reference types in argument of type 'IIn<B<object?, string>>' doesn't match target type 'IIn<B<object, string>>' for parameter 'x' in 'B<object, string> C.F<B<object, string>>(IIn<B<object, string>> x, IIn<B<object, string>> y)'.
                //         F(x, y)/*T:B<object!, string!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("IIn<B<object?, string>>", "IIn<B<object, string>>", "x", "B<object, string> C.F<B<object, string>>(IIn<B<object, string>> x, IIn<B<object, string>> y)").WithLocation(15, 11),
                // (15,14): warning CS8620: Nullability of reference types in argument of type 'IIn<B<object, string?>>' doesn't match target type 'IIn<B<object, string>>' for parameter 'y' in 'B<object, string> C.F<B<object, string>>(IIn<B<object, string>> x, IIn<B<object, string>> y)'.
                //         F(x, y)/*T:B<object!, string!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IIn<B<object, string?>>", "IIn<B<object, string>>", "y", "B<object, string> C.F<B<object, string>>(IIn<B<object, string>> x, IIn<B<object, string>> y)").WithLocation(15, 14),
                // (18,14): warning CS8620: Nullability of reference types in argument of type 'IIn<B<object?, string>>' doesn't match target type 'IIn<B<object, string?>>' for parameter 'y' in 'B<object, string?> C.F<B<object, string?>>(IIn<B<object, string?>> x, IIn<B<object, string?>> y)'.
                //         F(y, z)/*T:B<object!, string?>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "z").WithArguments("IIn<B<object?, string>>", "IIn<B<object, string?>>", "y", "B<object, string?> C.F<B<object, string?>>(IIn<B<object, string?>> x, IIn<B<object, string?>> y)").WithLocation(18, 14),
                // (19,11): warning CS8620: Nullability of reference types in argument of type 'IIn<B<object, string?>>' doesn't match target type 'IIn<B<object, string>>' for parameter 'x' in 'B<object, string> C.F<B<object, string>>(IIn<B<object, string>> x, IIn<B<object, string>> y)'.
                //         F(y, w)/*T:B<object!, string!>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y").WithArguments("IIn<B<object, string?>>", "IIn<B<object, string>>", "x", "B<object, string> C.F<B<object, string>>(IIn<B<object, string>> x, IIn<B<object, string>> y)").WithLocation(19, 11));
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_TypeParameters()
        {
            var source =
@"interface IOut<out T> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static void G<T>(IOut<T?> x, IOut<T> y) where T : class
    {
        F(x, x)/*T:IOut<T?>!*/;
        F(x, y)/*T:IOut<T?>!*/;
        F(y, x)/*T:IOut<T?>!*/;
        F(y, y)/*T:IOut<T!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_Arrays()
        {
            var source0 =
@"public class A
{
    public static string F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static T F<T>(T x, T y) => throw null;
    static void G(string?[] x, string[] y)
    {
        var z = (new[] { A.F })/*T:string[]!*/;
        F(x, x)/*T:string?[]!*/;
        F(x, y)/*T:string![]!*/;
        F(x, z)/*T:string?[]!*/;
        F(y, x)/*T:string![]!*/;
        F(y, y)/*T:string![]!*/;
        F(y, z)/*T:string![]!*/;
        F(z, x)/*T:string?[]!*/;
        F(z, y)/*T:string![]!*/;
        F(z, z)/*T:string[]!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (8,11): warning CS8620: Nullability of reference types in argument of type 'string?[]' doesn't match target type 'string[]' for parameter 'x' in 'string[] C.F<string[]>(string[] x, string[] y)'.
                //         F(x, y)/*T:string![]!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("string?[]", "string[]", "x", "string[] C.F<string[]>(string[] x, string[] y)").WithLocation(8, 11),
                // (10,14): warning CS8620: Nullability of reference types in argument of type 'string?[]' doesn't match target type 'string[]' for parameter 'y' in 'string[] C.F<string[]>(string[] x, string[] y)'.
                //         F(y, x)/*T:string![]!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x").WithArguments("string?[]", "string[]", "y", "string[] C.F<string[]>(string[] x, string[] y)").WithLocation(10, 14));
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_Dynamic()
        {
            var source =
@"interface IOut<out T> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static void G(IOut<dynamic?> x, IOut<dynamic> y)
    {
        F(x, x)/*T:IOut<dynamic?>!*/;
        F(x, y)/*T:IOut<dynamic?>!*/;
        F(y, x)/*T:IOut<dynamic?>!*/;
        F(y, y)/*T:IOut<dynamic!>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_Pointers()
        {
            var source0 =
@"public class A
{
    public static object F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"unsafe class C
{
    static T F<T>(T x, T y) => throw null;
    static T* CreatePointer<T>(T t) => throw null;
    static void G(object?* x, object* y)
    {
        var z = CreatePointer(A.F)/*T:object**/;
        F(x, x)/*T:object?**/;
        F(x, y)/*T:object!**/;
        F(x, z)/*T:object?**/;
        F(y, x)/*T:object!**/;
        F(y, y)/*T:object!**/;
        F(y, z)/*T:object!**/;
        F(z, x)/*T:object?**/;
        F(z, y)/*T:object!**/;
        F(z, z)/*T:object**/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(TestOptions.UnsafeDebugDll), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (4,12): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('T')
                //     static T* CreatePointer<T>(T t) => throw null;
                Diagnostic(ErrorCode.ERR_ManagedAddr, "T*").WithArguments("T").WithLocation(4, 12),
                // (5,19): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('object')
                //     static void G(object?* x, object* y)
                Diagnostic(ErrorCode.ERR_ManagedAddr, "object?*").WithArguments("object").WithLocation(5, 19),
                // (5,31): error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('object')
                //     static void G(object?* x, object* y)
                Diagnostic(ErrorCode.ERR_ManagedAddr, "object*").WithArguments("object").WithLocation(5, 31),
                // (8,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(x, x)/*T:object?**/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(8, 9),
                // (9,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(x, y)/*T:object!**/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(9, 9),
                // (10,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(x, z)/*T:object?**/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(10, 9),
                // (11,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(y, x)/*T:object!**/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(11, 9),
                // (12,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(y, y)/*T:object!**/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(12, 9),
                // (13,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(y, z)/*T:object!**/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(13, 9),
                // (14,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(z, x)/*T:object?**/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(14, 9),
                // (15,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(z, y)/*T:object!**/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(15, 9),
                // (16,9): error CS0306: The type 'object*' may not be used as a type argument
                //         F(z, z)/*T:object**/;
                Diagnostic(ErrorCode.ERR_BadTypeArgument, "F").WithArguments("object*").WithLocation(16, 9));
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_Tuples()
        {
            var source0 =
@"public class A
{
    public static object F;
    public static string G;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C
{
    static T F<T>(T x, T y) => throw null;
    static void G(object? t1, object t2, string? u1, string u2)
    {
        var t3 = A.F/*T:object*/;
        var u3 = A.G/*T:string*/;
        var x = (t1, u2)/*T:(object? t1, string! u2)*/;
        var y = (t2, u1)/*T:(object! t2, string? u1)*/;
        var z = (t1, u3)/*T:(object? t1, string u3)*/;
        var w = (t3, u2)/*T:(object t3, string! u2)*/;
        F(x, y)/*T:(object?, string?)*/;
        F(x, z)/*T:(object? t1, string)*/;
        F(x, w)/*T:(object?, string! u2)*/;
        F(y, z)/*T:(object?, string?)*/;
        F(y, w)/*T:(object, string?)*/;
        F(w, z)/*T:(object?, string)*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_LowerBounds_NestedNullability_Tuples_Variant()
        {
            var source0 =
@"public class A
{
    public static (object, string) F;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(T x, T y) => throw null;
    static I<T> CreateI<T>(T t) => throw null;
    static void G1(I<(object, string)> x1, I<(object?, string?)> y1)
    {
        var z1 = CreateI(A.F)/*T:I<(object, string)>!*/;
        F(x1, x1)/*T:I<(object!, string!)>!*/;
        F(x1, y1)/*T:I<(object!, string!)>!*/;
        F(x1, z1)/*T:I<(object!, string!)>!*/;
        F(y1, x1)/*T:I<(object!, string!)>!*/;
        F(y1, y1)/*T:I<(object?, string?)>!*/;
        F(y1, z1)/*T:I<(object?, string?)>!*/;
        F(z1, x1)/*T:I<(object!, string!)>!*/;
        F(z1, y1)/*T:I<(object?, string?)>!*/;
        F(z1, z1)/*T:I<(object, string)>!*/;
    }
    static IIn<T> CreateIIn<T>(T t) => throw null;
    static void G2(IIn<(object, string)> x2, IIn<(object?, string?)> y2)
    {
        var z2 = CreateIIn(A.F)/*T:IIn<(object, string)>!*/;
        F(x2, x2)/*T:IIn<(object!, string!)>!*/;
        F(x2, y2)/*T:IIn<(object!, string!)>!*/;
        F(x2, z2)/*T:IIn<(object!, string!)>!*/;
        F(y2, x2)/*T:IIn<(object!, string!)>!*/;
        F(y2, y2)/*T:IIn<(object?, string?)>!*/;
        F(y2, z2)/*T:IIn<(object, string)>!*/;
        F(z2, x2)/*T:IIn<(object!, string!)>!*/;
        F(z2, y2)/*T:IIn<(object, string)>!*/;
        F(z2, z2)/*T:IIn<(object, string)>!*/;
    }
    static IOut<T> CreateIOut<T>(T t) => throw null;
    static void G3(IOut<(object, string)> x3, IOut<(object?, string?)> y3)
    {
        var z3 = CreateIOut(A.F)/*T:IOut<(object, string)>!*/;
        F(x3, x3)/*T:IOut<(object!, string!)>!*/;
        F(x3, y3)/*T:IOut<(object?, string?)>!*/;
        F(x3, z3)/*T:IOut<(object, string)>!*/;
        F(y3, x3)/*T:IOut<(object?, string?)>!*/;
        F(y3, y3)/*T:IOut<(object?, string?)>!*/;
        F(y3, z3)/*T:IOut<(object?, string?)>!*/;
        F(z3, x3)/*T:IOut<(object, string)>!*/;
        F(z3, y3)/*T:IOut<(object?, string?)>!*/;
        F(z3, z3)/*T:IOut<(object, string)>!*/;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (12,15): warning CS8620: Nullability of reference types in argument of type 'I<(object?, string?)>' doesn't match target type 'I<(object, string)>' for parameter 'y' in 'I<(object, string)> C.F<I<(object, string)>>(I<(object, string)> x, I<(object, string)> y)'.
                //         F(x1, y1)/*T:I<(object, string)>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("I<(object?, string?)>", "I<(object, string)>", "y", "I<(object, string)> C.F<I<(object, string)>>(I<(object, string)> x, I<(object, string)> y)").WithLocation(12, 15),
                // (14,11): warning CS8620: Nullability of reference types in argument of type 'I<(object?, string?)>' doesn't match target type 'I<(object, string)>' for parameter 'x' in 'I<(object, string)> C.F<I<(object, string)>>(I<(object, string)> x, I<(object, string)> y)'.
                //         F(y1, x1)/*T:I<(object, string)>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("I<(object?, string?)>", "I<(object, string)>", "x", "I<(object, string)> C.F<I<(object, string)>>(I<(object, string)> x, I<(object, string)> y)").WithLocation(14, 11),
                // (26,15): warning CS8620: Nullability of reference types in argument of type 'IIn<(object?, string?)>' doesn't match target type 'IIn<(object, string)>' for parameter 'y' in 'IIn<(object, string)> C.F<IIn<(object, string)>>(IIn<(object, string)> x, IIn<(object, string)> y)'.
                //         F(x2, y2)/*T:IIn<(object!, string!)>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y2").WithArguments("IIn<(object?, string?)>", "IIn<(object, string)>", "y", "IIn<(object, string)> C.F<IIn<(object, string)>>(IIn<(object, string)> x, IIn<(object, string)> y)").WithLocation(26, 15),
                // (28,11): warning CS8620: Nullability of reference types in argument of type 'IIn<(object?, string?)>' doesn't match target type 'IIn<(object, string)>' for parameter 'x' in 'IIn<(object, string)> C.F<IIn<(object, string)>>(IIn<(object, string)> x, IIn<(object, string)> y)'.
                //         F(y2, x2)/*T:IIn<(object!, string!)>!*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y2").WithArguments("IIn<(object?, string?)>", "IIn<(object, string)>", "x", "IIn<(object, string)> C.F<IIn<(object, string)>>(IIn<(object, string)> x, IIn<(object, string)> y)").WithLocation(28, 11),
                // (40,11): warning CS8620: Nullability of reference types in argument of type 'IOut<(object, string)>' doesn't match target type 'IOut<(object?, string?)>' for parameter 'x' in 'IOut<(object?, string?)> C.F<IOut<(object?, string?)>>(IOut<(object?, string?)> x, IOut<(object?, string?)> y)'.
                //         F(x3, y3)/*T:IOut<(object?, string?)>?*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x3").WithArguments("IOut<(object, string)>", "IOut<(object?, string?)>", "x", "IOut<(object?, string?)> C.F<IOut<(object?, string?)>>(IOut<(object?, string?)> x, IOut<(object?, string?)> y)").WithLocation(40, 11),
                // (42,15): warning CS8620: Nullability of reference types in argument of type 'IOut<(object, string)>' doesn't match target type 'IOut<(object?, string?)>' for parameter 'y' in 'IOut<(object?, string?)> C.F<IOut<(object?, string?)>>(IOut<(object?, string?)> x, IOut<(object?, string?)> y)'.
                //         F(y3, x3)/*T:IOut<(object?, string?)>?*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x3").WithArguments("IOut<(object, string)>", "IOut<(object?, string?)>", "y", "IOut<(object?, string?)> C.F<IOut<(object?, string?)>>(IOut<(object?, string?)> x, IOut<(object?, string?)> y)").WithLocation(42, 15));
        }

        [Fact]
        public void Assignment_NestedNullability_MismatchedNullability()
        {
            var source0 =
@"public class A
{
    public static object F;
    public static string G;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B<T, U> { }
class C
{
    static B<T, U> CreateB<T, U>(T t, U u) => throw null;
    static void G(object? t1, object t2, string? u1, string u2)
    {
        var t3 = A.F/*T:object*/;
        var u3 = A.G/*T:string*/;
        var x0 = CreateB(t1, u2)/*T:B<object?, string!>!*/;
        var y0 = CreateB(t2, u1)/*T:B<object!, string?>!*/;
        var z0 = CreateB(t1, u3)/*T:B<object?, string>!*/;
        var w0 = CreateB(t3, u2)/*T:B<object, string!>!*/;
        var x = x0;
        var y = y0;
        var z = z0;
        var w = w0;
        x = y0; // 1
        x = z0;
        x = w0;
        y = z0; // 2
        y = w0; // 3
        w = z0;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (17,13): warning CS8619: Nullability of reference types in value of type 'B<object, string?>' doesn't match target type 'B<object?, string>'.
                //         x = y0; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y0").WithArguments("B<object, string?>", "B<object?, string>").WithLocation(17, 13),
                // (20,13): warning CS8619: Nullability of reference types in value of type 'B<object?, string>' doesn't match target type 'B<object, string?>'.
                //         y = z0; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "z0").WithArguments("B<object?, string>", "B<object, string?>").WithLocation(20, 13),
                // (21,13): warning CS8619: Nullability of reference types in value of type 'B<object, string>' doesn't match target type 'B<object, string?>'.
                //         y = w0; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "w0").WithArguments("B<object, string>", "B<object, string?>").WithLocation(21, 13));
        }

        [Fact]
        public void TypeInference_09()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(I<T> x, I<T> y)
    {
        throw new System.Exception();
    }
    static void G1(I<string> x1, I<string?> y1)
    {
        F(x1, x1)/*T:string!*/.ToString();
        F(x1, y1)/*T:string!*/.ToString();
        F(y1, x1)/*T:string!*/.ToString();
        F(y1, y1)/*T:string?*/.ToString();
    }
    static T F<T>(IIn<T> x, IIn<T> y)
    {
        throw new System.Exception();
    }
    static void G2(IIn<string> x2, IIn<string?> y2)
    {
        F(x2, x2)/*T:string!*/.ToString();
        F(x2, y2)/*T:string!*/.ToString();
        F(y2, x2)/*T:string!*/.ToString();
        F(y2, y2)/*T:string?*/.ToString();
    }
    static T F<T>(IOut<T> x, IOut<T> y)
    {
        throw new System.Exception();
    }
    static void G3(IOut<string> x3, IOut<string?> y3)
    {
        F(x3, x3)/*T:string!*/.ToString();
        F(x3, y3)/*T:string?*/.ToString();
        F(y3, x3)/*T:string?*/.ToString();
        F(y3, y3)/*T:string?*/.ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (13,15): warning CS8620: Nullability of reference types in argument of type 'I<string?>' doesn't match target type 'I<string>' for parameter 'y' in 'string C.F<string>(I<string> x, I<string> y)'.
                //         F(x1, y1)/*T:string!*/.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("I<string?>", "I<string>", "y", "string C.F<string>(I<string> x, I<string> y)").WithLocation(13, 15),
                // (14,11): warning CS8620: Nullability of reference types in argument of type 'I<string?>' doesn't match target type 'I<string>' for parameter 'x' in 'string C.F<string>(I<string> x, I<string> y)'.
                //         F(y1, x1)/*T:string!*/.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("I<string?>", "I<string>", "x", "string C.F<string>(I<string> x, I<string> y)").WithLocation(14, 11),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         F(y1, y1)/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y1, y1)").WithLocation(15, 9),
                // (26,9): warning CS8602: Possible dereference of a null reference.
                //         F(y2, y2)/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y2, y2)").WithLocation(26, 9),
                // (35,9): warning CS8602: Possible dereference of a null reference.
                //         F(x3, y3)/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x3, y3)").WithLocation(35, 9),
                // (36,9): warning CS8602: Possible dereference of a null reference.
                //         F(y3, x3)/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y3, x3)").WithLocation(36, 9),
                // (37,9): warning CS8602: Possible dereference of a null reference.
                //         F(y3, y3)/*T:string?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y3, y3)").WithLocation(37, 9));
        }

        [Fact]
        public void TypeInference_10()
        {
            var source =
@"interface I<T> { }
interface IIn<in T> { }
interface IOut<out T> { }
class C
{
    static T F<T>(I<T> x, I<T?> y) where T : class
    {
        throw new System.Exception();
    }
    static void G1(I<string> x1, I<string?> y1)
    {
        F(x1, x1).ToString(); // 1
        F(x1, y1).ToString();
        F(y1, x1).ToString(); // 2 and 3
        F(y1, y1).ToString(); // 4
    }
    static T F<T>(IIn<T> x, IIn<T?> y) where T : class
    {
        throw new System.Exception();
    }
    static void G2(IIn<string> x2, IIn<string?> y2)
    {
        F(x2, x2).ToString(); // 5
        F(x2, y2).ToString();
        F(y2, x2).ToString(); // 6
        F(y2, y2).ToString();
    }
    static T F<T>(IOut<T> x, IOut<T?> y) where T : class
    {
        throw new System.Exception();
    }
    static void G3(IOut<string> x3, IOut<string?> y3)
    {
        F(x3, x3).ToString();
        F(x3, y3).ToString();
        F(y3, x3).ToString(); // 7
        F(y3, y3).ToString(); // 8
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (12,15): warning CS8620: Nullability of reference types in argument of type 'I<string>' doesn't match target type 'I<string?>' for parameter 'y' in 'string C.F<string>(I<string> x, I<string?> y)'.
                //         F(x1, x1).ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x1").WithArguments("I<string>", "I<string?>", "y", "string C.F<string>(I<string> x, I<string?> y)").WithLocation(12, 15),
                // (14,11): warning CS8620: Nullability of reference types in argument of type 'I<string?>' doesn't match target type 'I<string>' for parameter 'x' in 'string C.F<string>(I<string> x, I<string?> y)'.
                //         F(y1, x1).ToString(); // 2 and 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("I<string?>", "I<string>", "x", "string C.F<string>(I<string> x, I<string?> y)").WithLocation(14, 11),
                // (14,15): warning CS8620: Nullability of reference types in argument of type 'I<string>' doesn't match target type 'I<string?>' for parameter 'y' in 'string C.F<string>(I<string> x, I<string?> y)'.
                //         F(y1, x1).ToString(); // 2 and 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x1").WithArguments("I<string>", "I<string?>", "y", "string C.F<string>(I<string> x, I<string?> y)").WithLocation(14, 15),
                // (15,11): warning CS8620: Nullability of reference types in argument of type 'I<string?>' doesn't match target type 'I<string>' for parameter 'x' in 'string C.F<string>(I<string> x, I<string?> y)'.
                //         F(y1, y1).ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y1").WithArguments("I<string?>", "I<string>", "x", "string C.F<string>(I<string> x, I<string?> y)").WithLocation(15, 11),
                // (23,15): warning CS8620: Nullability of reference types in argument of type 'IIn<string>' doesn't match target type 'IIn<string?>' for parameter 'y' in 'string C.F<string>(IIn<string> x, IIn<string?> y)'.
                //         F(x2, x2).ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x2").WithArguments("IIn<string>", "IIn<string?>", "y", "string C.F<string>(IIn<string> x, IIn<string?> y)").WithLocation(23, 15),
                // (25,15): warning CS8620: Nullability of reference types in argument of type 'IIn<string>' doesn't match target type 'IIn<string?>' for parameter 'y' in 'string C.F<string>(IIn<string> x, IIn<string?> y)'.
                //         F(y2, x2).ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x2").WithArguments("IIn<string>", "IIn<string?>", "y", "string C.F<string>(IIn<string> x, IIn<string?> y)").WithLocation(25, 15),
                // (36,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>(IOut<T>, IOut<T?>)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         F(y3, x3).ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>(IOut<T>, IOut<T?>)", "T", "string?").WithLocation(36, 9),
                // (36,9): warning CS8602: Possible dereference of a null reference.
                //         F(y3, x3).ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y3, x3)").WithLocation(36, 9),
                // (37,9): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'C.F<T>(IOut<T>, IOut<T?>)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         F(y3, y3).ToString(); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "F").WithArguments("C.F<T>(IOut<T>, IOut<T?>)", "T", "string?").WithLocation(37, 9),
                // (37,9): warning CS8602: Possible dereference of a null reference.
                //         F(y3, y3).ToString(); // 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y3, y3)").WithLocation(37, 9));
        }

        [Fact]
        public void TypeInference_11()
        {
            var source0 =
@"public class A<T>
{
    public T F;
}
public class UnknownNull
{
    public A<object> A1;
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source1 =
@"#pragma warning disable 8618
public class MaybeNull
{
    public A<object?> A2;
}
public class NotNull
{
    public A<object> A3;
}";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp1.VerifyDiagnostics();
            var ref1 = comp1.EmitToImageReference();

            var source =
@"class C
{
    static T F<T>(T x, T y) => throw null;
    static void F1(UnknownNull x1, UnknownNull y1)
    {
        F(x1.A1, y1.A1)/*T:A<object>*/.F.ToString();
    }
    static void F2(UnknownNull x2, MaybeNull y2)
    {
        F(x2.A1, y2.A2)/*T:A<object?>*/.F.ToString();
    }
    static void F3(MaybeNull x3, UnknownNull y3)
    {
        F(x3.A2, y3.A1)/*T:A<object?>*/.F.ToString();
    }
    static void F4(MaybeNull x4, MaybeNull y4)
    {
        F(x4.A2, y4.A2)/*T:A<object?>!*/.F.ToString();
    }
    static void F5(UnknownNull x5, NotNull y5)
    {
        F(x5.A1, y5.A3)/*T:A<object!>*/.F.ToString();
    }
    static void F6(NotNull x6, UnknownNull y6)
    {
        F(x6.A3, y6.A1)/*T:A<object!>*/.F.ToString();
    }
    static void F7(MaybeNull x7, NotNull y7)
    {
        F(x7.A2, y7.A3)/*T:A<object!>!*/.F.ToString();
    }
    static void F8(NotNull x8, MaybeNull y8)
    {
        F(x8.A3, y8.A2)/*T:A<object!>!*/.F.ToString();
    }
    static void F9(NotNull x9, NotNull y9)
    {
        F(x9.A3, y9.A3)/*T:A<object!>!*/.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0, ref1 });
            comp.VerifyTypes();
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(x2.A1, y2.A2)/*T:A<object?>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x2.A1, y2.A2)/*T:A<object?>*/.F").WithLocation(10, 9),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         F(x3.A2, y3.A1)/*T:A<object?>*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x3.A2, y3.A1)/*T:A<object?>*/.F").WithLocation(14, 9),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         F(x4.A2, y4.A2)/*T:A<object?>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(x4.A2, y4.A2)/*T:A<object?>!*/.F").WithLocation(18, 9),
                // (30,11): warning CS8620: Nullability of reference types in argument of type 'A<object?>' doesn't match target type 'A<object>' for parameter 'x' in 'A<object> C.F<A<object>>(A<object> x, A<object> y)'.
                //         F(x7.A2, y7.A3)/*T:A<object!>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "x7.A2").WithArguments("A<object?>", "A<object>", "x", "A<object> C.F<A<object>>(A<object> x, A<object> y)").WithLocation(30, 11),
                // (34,18): warning CS8620: Nullability of reference types in argument of type 'A<object?>' doesn't match target type 'A<object>' for parameter 'y' in 'A<object> C.F<A<object>>(A<object> x, A<object> y)'.
                //         F(x8.A3, y8.A2)/*T:A<object!>!*/.F.ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "y8.A2").WithArguments("A<object?>", "A<object>", "y", "A<object> C.F<A<object>>(A<object> x, A<object> y)").WithLocation(34, 18));
        }

        [Fact]
        public void TypeInference_12()
        {
            var source =
@"class C<T>
{
    internal T F;
}
class C
{
    static C<T> Create<T>(T t)
    {
        return new C<T>();
    }
    static void F(object? x)
    {
        if (x == null)
        {
            Create(x).F = null;
            var y = Create(x);
            y.F = null;
        }
        else
        {
            Create(x).F = null; // warn
            var y = Create(x);
            y.F = null; // warn
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (1,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class C<T>
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "C").WithArguments("field", "F").WithLocation(1, 7),
                // (21,27): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             Create(x).F = null; // warn
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(21, 27),
                // (23,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             y.F = null; // warn
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(23, 19));
        }

        [Fact]
        public void TypeInference_ArgumentOrder()
        {
            var source =
@"interface I<T>
{
     T P { get; }
}
class C
{
    static T F<T, U>(I<T> x, I<U> y) => x.P;
    static void M(I<object?> x, I<string> y)
    {
        F(y: y, x: x).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(y: y, x: x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y: y, x: x)").WithLocation(10, 9));
        }

        [Fact]
        public void TypeInference_Local()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G()
    {
        object x = new object();
        object? y = x;
        F(x).ToString();
        F(y).ToString();
        y = null;
        F(y).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         F(y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y)").WithLocation(11, 9));
        }

        [Fact]
        public void TypeInference_Call()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static object F1() => new object();
    static object? F2() => null;
    static void G()
    {
        F(F1()).ToString();
        F(F2()).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F(F2()).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(F2())").WithLocation(9, 9));
        }

        [Fact]
        public void TypeInference_Property()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static object P => new object();
    static object? Q => null;
    static void G()
    {
        F(P).ToString();
        F(Q).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F(Q).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(Q)").WithLocation(9, 9));
        }

        [Fact]
        public void TypeInference_FieldAccess()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static object F1 = new object();
    static object? F2 = null;
    static void G()
    {
        F(F1).ToString();
        F(F2).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F(F2).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(F2)").WithLocation(9, 9));
        }

        [Fact]
        public void TypeInference_Literal()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G()
    {
        F(0).ToString();
        F('A').ToString();
        F(""B"").ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_Default()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G()
    {
        F(default(object)).ToString();
        F(default(int)).ToString();
        F(default(string)).ToString();
        F(default).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (9,9): error CS0411: The type arguments for method 'C.F<T>(T)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         F(default).ToString();
                Diagnostic(ErrorCode.ERR_CantInferMethTypeArgs, "F").WithArguments("C.F<T>(T)").WithLocation(9, 9),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         F(default(object)).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(default(object))").WithLocation(6, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F(default(string)).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(default(string))").WithLocation(8, 9));
        }

        [Fact]
        public void TypeInference_Tuple_01()
        {
            var source =
@"class C
{
    static (T, U) F<T, U>((T, U) t) => t;
    static void G(string x, string? y)
    {
        var t = (x, y);
        F(t).Item1.ToString();
        F(t).Item2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F(t).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(t).Item2").WithLocation(8, 9));
        }

        [Fact]
        public void TypeInference_Tuple_02()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G(string x, string? y)
    {
        var t = (x, y);
        F(t).Item1.ToString();
        F(t).Item2.ToString();
        F(t).x.ToString();
        F(t).y.ToString();
        var u = (a: x, b: y);
        F(u).Item1.ToString();
        F(u).Item2.ToString();
        F(u).a.ToString();
        F(u).b.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F(t).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(t).Item2").WithLocation(8, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         F(t).y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(t).y").WithLocation(10, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         F(u).Item2.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(u).Item2").WithLocation(13, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         F(u).b.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(u).b").WithLocation(15, 9));
        }

        [Fact]
        public void TypeInference_Tuple_03()
        {
            var source =
@"class C
{
    static void F(object? x, object? y)
    {
        if (x == null) return;
        var t = (x, y);
        t.x.ToString();
        t.y.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.y").WithLocation(8, 9));
        }

        [Fact]
        public void TypeInference_ObjectCreation()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G()
    {
        F(new C { }).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_DelegateCreation()
        {
            var source =
@"delegate void D();
class C
{
    static T F<T>(T t) => t;
    static void G()
    {
        F(new D(G)).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_BinaryOperator()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G(string x, string? y)
    {
        F(x + x).ToString();
        F(x + y).ToString();
        F(y + x).ToString();
        F(y + y).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void TypeInference_NullCoalescingOperator()
        {
            var source =
@"class C
{
    static T F<T>(T t) => t;
    static void G(object x, object? y)
    {
        F(x ?? x).ToString();
        F(x ?? y).ToString();
        F(y ?? x).ToString();
        F(y ?? y).ToString();
    }
}";
            var comp = CreateCompilation(
                new[] { source }, options: WithNonNullTypesTrue(),
                parseOptions: TestOptions.Regular8);
            comp.VerifyDiagnostics(
                // (6,11): hidden CS8607: Expression is probably never null.
                //         F(x ?? x).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x").WithLocation(6, 11),
                // (7,11): hidden CS8607: Expression is probably never null.
                //         F(x ?? y).ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x").WithLocation(7, 11),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         F(y ?? y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F(y ?? y)").WithLocation(9, 9));
        }

        [Fact]
        public void Members_Fields()
        {
            var source =
@"#pragma warning disable 0649
class C
{
    internal string? F;
}
class Program
{
    static void F(C a)
    {
        G(a.F);
        if (a.F != null) G(a.F);
        C b = new C();
        G(b.F);
        if (b.F != null) G(b.F);
    }
    static void G(string s)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,11): warning CS8604: Possible null reference argument for parameter 's' in 'void Program.G(string s)'.
                //         G(a.F);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a.F").WithArguments("s", "void Program.G(string s)").WithLocation(10, 11),
                // (13,11): warning CS8604: Possible null reference argument for parameter 's' in 'void Program.G(string s)'.
                //         G(b.F);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b.F").WithArguments("s", "void Program.G(string s)").WithLocation(13, 11));
        }

        [Fact]
        public void Members_Fields_UnconstrainedType()
        {
            var source =
@"
class C<T>
{
    internal T field = default;

    static void F(C<T> a, bool c)
    {
        if (c) a.field.ToString();
        else if (a.field != null) a.field.ToString();
        C<T> b = new C<T>();
        if (c) b.field.ToString();
        else if (b.field != null) b.field.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,24): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     internal T field = default;
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(4, 24),
                // (8,16): warning CS8602: Possible dereference of a null reference.
                //         if (c) a.field.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.field").WithLocation(8, 16),
                // (11,16): warning CS8602: Possible dereference of a null reference.
                //         if (c) b.field.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.field").WithLocation(11, 16)
                );
        }

        [Fact]
        public void Members_AutoProperties()
        {
            var source =
@"class C
{
    internal string? P { get; set; }
}
class Program
{
    static void F(C a)
    {
        G(a.P);
        if (a.P != null) G(a.P);
        C b = new C();
        G(b.P);
        if (b.P != null) G(b.P);
    }
    static void G(string s)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,11): warning CS8604: Possible null reference argument for parameter 's' in 'void Program.G(string s)'.
                //         G(a.P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a.P").WithArguments("s", "void Program.G(string s)").WithLocation(9, 11),
                // (12,11): warning CS8604: Possible null reference argument for parameter 's' in 'void Program.G(string s)'.
                //         G(b.P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b.P").WithArguments("s", "void Program.G(string s)").WithLocation(12, 11));
        }

        [Fact]
        public void Members_Properties()
        {
            var source =
@"class C
{
    internal string? P { get { throw new System.Exception(); } set { } }
}
class Program
{
    static void F(C a)
    {
        G(a.P);
        if (a.P != null) G(a.P);
        C b = new C();
        G(b.P);
        if (b.P != null) G(b.P);
    }
    static void G(string s)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,11): warning CS8604: Possible null reference argument for parameter 's' in 'void Program.G(string s)'.
                //         G(a.P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a.P").WithArguments("s", "void Program.G(string s)").WithLocation(9, 11),
                // (12,11): warning CS8604: Possible null reference argument for parameter 's' in 'void Program.G(string s)'.
                //         G(b.P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b.P").WithArguments("s", "void Program.G(string s)").WithLocation(12, 11));
        }

        [Fact]
        public void Members_AutoPropertyFromConstructor()
        {
            var source =
@"class A
{
    protected static void F(string s)
    {
    }
    protected string? P { get; set; }
    protected A()
    {
        F(P);
        if (P != null) F(P);
    }
}
class B : A
{
    B()
    {
        F(this.P);
        if (this.P != null) F(this.P);
        F(base.P);
        if (base.P != null) F(base.P);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,11): warning CS8604: Possible null reference argument for parameter 's' in 'void A.F(string s)'.
                //         F(this.P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "this.P").WithArguments("s", "void A.F(string s)").WithLocation(17, 11),
                // (19,11): warning CS8604: Possible null reference argument for parameter 's' in 'void A.F(string s)'.
                //         F(base.P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "base.P").WithArguments("s", "void A.F(string s)").WithLocation(19, 11),
                // (9,11): warning CS8604: Possible null reference argument for parameter 's' in 'void A.F(string s)'.
                //         F(P);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "P").WithArguments("s", "void A.F(string s)").WithLocation(9, 11));
        }

        [Fact]
        public void ModifyMembers_01()
        {
            var source =
@"#pragma warning disable 0649
class C
{
    object? F;
    static void M(C c)
    {
        if (c.F == null) return;
        c = new C();
        c.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         c.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.F").WithLocation(9, 9));
        }

        [Fact]
        public void ModifyMembers_02()
        {
            var source =
@"#pragma warning disable 0649
class A
{
    internal C? C;
}
class B
{
    internal A? A;
}
class C
{
    internal B? B;
}
class Program
{
    static void F()
    {
        object o;
        C? c = new C();
        c.B = new B();
        c.B.A = new A();
        o = c.B.A; // 1
        c.B.A = null;
        o = c.B.A; // 2
        c.B = new B();
        o = c.B.A; // 3
        c.B = null;
        o = c.B.A; // 4
        c = new C();
        o = c.B.A; // 5
        c = null;
        o = c.B.A; // 6
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (24,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.A; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.A").WithLocation(24, 13),
                // (26,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.A; // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.A").WithLocation(26, 13),
                // (28,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.B.A; // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.B").WithLocation(28, 13),
                // (28,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.A; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.A").WithLocation(28, 13),
                // (30,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.B.A; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.B").WithLocation(30, 13),
                // (30,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.A; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.A").WithLocation(30, 13),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.B.A; // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(32, 13),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.B.A; // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.B").WithLocation(32, 13),
                // (32,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.A; // 6
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.A").WithLocation(32, 13));
        }

        [Fact]
        public void ModifyMembers_03()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    internal object? F;
}
class C
{
    internal C? A;
    internal S B;
}
class Program
{
    static void M()
    {
        object o;
        C c = new C();
        o = c.A.A; // 1
        o = c.B.F; // 1
        c.A = new C();
        c.B = new S();
        o = c.A.A; // 2
        o = c.B.F; // 2
        c.A.A = new C();
        c.B.F = new C();
        o = c.A.A; // 3
        o = c.B.F; // 3
        c.A = new C();
        c.B = new S();
        o = c.A.A; // 4
        o = c.B.F; // 4
        c = new C();
        o = c.A.A; // 5
        o = c.B.F; // 5
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.A.A; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.A").WithLocation(17, 13),
                // (17,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(17, 13),
                // (18,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.F; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.F").WithLocation(18, 13),
                // (21,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(21, 13),
                // (22,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.F; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.F").WithLocation(22, 13),
                // (29,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(29, 13),
                // (30,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.F; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.F").WithLocation(30, 13),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.A.A; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.A").WithLocation(32, 13),
                // (32,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(32, 13),
                // (33,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.F; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.F").WithLocation(33, 13));
        }

        [Fact]
        public void ModifyMembers_Properties()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    internal object? P { get; set; }
}
class C
{
    internal C? A { get; set; }
    internal S B;
}
class Program
{
    static void M()
    {
        object o;
        C c = new C();
        o = c.A.A; // 1
        o = c.B.P; // 1
        c.A = new C();
        c.B = new S();
        o = c.A.A; // 2
        o = c.B.P; // 2
        c.A.A = new C();
        c.B.P = new C();
        o = c.A.A; // 3
        o = c.B.P; // 3
        c.A = new C();
        c.B = new S();
        o = c.A.A; // 4
        o = c.B.P; // 4
        c = new C();
        o = c.A.A; // 5
        o = c.B.P; // 5
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.A.A; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.A").WithLocation(17, 13),
                // (17,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(17, 13),
                // (18,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.P; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.P").WithLocation(18, 13),
                // (21,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(21, 13),
                // (22,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.P; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.P").WithLocation(22, 13),
                // (29,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(29, 13),
                // (30,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.P; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.P").WithLocation(30, 13),
                // (32,13): warning CS8602: Possible dereference of a null reference.
                //         o = c.A.A; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.A").WithLocation(32, 13),
                // (32,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.A.A; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.A.A").WithLocation(32, 13),
                // (33,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = c.B.P; // 5
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c.B.P").WithLocation(33, 13));
        }

        [Fact]
        public void ModifyMembers_Struct()
        {
            var source =
@"#pragma warning disable 0649
struct A
{
    internal object? F;
}
struct B
{
    internal A A;
    internal object? G;
}
class Program
{
    static void F()
    {
        object o;
        B b = new B();
        b.G = new object();
        b.A.F = new object();
        o = b.G; // 1
        o = b.A.F; // 1
        b.A = default(A);
        o = b.G; // 2
        o = b.A.F; // 2
        b = default(B);
        o = b.G; // 3
        o = b.A.F; // 3
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (23,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = b.A.F; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "b.A.F").WithLocation(23, 13),
                // (25,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = b.G; // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "b.G").WithLocation(25, 13),
                // (26,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = b.A.F; // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "b.A.F").WithLocation(26, 13));
        }

        // https://github.com/dotnet/roslyn/issues/29619: Handle struct properties that are not auto-properties.
        [Fact(Skip = "Struct property not auto-property")]
        public void ModifyMembers_StructPropertyExplicitAccessors()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    private object? _p;
    internal object? P { get { return _p; } set { _p = value; } }
}
class C
{
    S F;
    void M()
    {
        object o;
        o = F.P; // 1
        F.P = new object();
        o = F.P; // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = F.P; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "F.P").WithLocation(13, 13));
        }

        [Fact]
        public void ModifyMembers_StructProperty()
        {
            var source =
@"#pragma warning disable 0649
public struct S
{
    public object? P { get; set; }
}
class C
{
    S F;
    void M()
    {
        object o;
        o = F.P; // 1
        F.P = new object();
        o = F.P; // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = F.P; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "F.P").WithLocation(12, 13));
        }

        [Fact]
        public void ModifyMembers_StructPropertyFromMetadata()
        {
            var source0 =
@"public struct S
{
    public object? P { get; set; }
}";
            var comp0 = CreateCompilation(source0);
            var ref0 = comp0.EmitToImageReference();

            var source =
@"#pragma warning disable 0649
class C
{
    S F;
    void M()
    {
        object o;
        o = F.P; // 1
        F.P = new object();
        o = F.P; // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = F.P; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "F.P").WithLocation(8, 13));
        }

        [Fact]
        public void ModifyMembers_ClassPropertyNoBackingField()
        {
            var source =
@"#pragma warning disable 0649
class C
{
    object? P { get { return null; } set { } }
    void M()
    {
        object o;
        o = P; // 1
        P = new object();
        o = P; // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = P; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "P").WithLocation(8, 13));
        }

        // https://github.com/dotnet/roslyn/issues/29619: Handle struct properties that are not auto-properties.
        [Fact(Skip = "Struct property not auto-property")]
        public void ModifyMembers_StructPropertyNoBackingField()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    internal object? P { get { return null; } set { } }
}
class C
{
    S F;
    void M()
    {
        object o;
        o = F.P; // 1
        F.P = new object();
        o = F.P; // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         o = F.P; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "F.P").WithLocation(12, 13));
        }

        // Calling a method should reset the state for members.
        [Fact]
        [WorkItem(29975, "https://github.com/dotnet/roslyn/issues/29975")]
        public void Members_CallMethod()
        {
            var source =
@"#pragma warning disable 0649
class A
{
    internal object? P { get; set; }
}
class B
{
    internal A? Q { get; set; }
}
class Program
{
    static void M()
    {
        object o;
        B b = new B() { Q = new A() { P = new object() } };
        o = b.Q.P; // 1
        b.Q.P.ToString();
        o = b.Q.P; // 2
        b.Q.ToString();
        o = b.Q.P; // 3
        b = new B() { Q = new A() { P = new object() } };
        o = b.Q.P; // 4
        b.ToString();
        o = b.Q.P; // 5
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29975: Should report warnings.
            comp.VerifyDiagnostics(/*...*/);
        }

        [Fact]
        public void Members_ObjectInitializer()
        {
            var source =
@"#pragma warning disable 0649
class A
{
    internal object? F1;
    internal object? F2;
}
class B
{
    internal A? G;
}
class Program
{
    static void F()
    {
        (new B() { G = new A() { F1 = new object() } }).G.F1.ToString();
        B b;
        b = new B() { G = new A() { F1 = new object() } };
        b.G.F1.ToString(); // 1
        b.G.F2.ToString(); // 1
        b = new B() { G = new A() { F2 = new object() } };
        b.G.F1.ToString(); // 2
        b.G.F2.ToString(); // 2
        b = new B() { G = new A() };
        b.G.F1.ToString(); // 3
        b.G.F2.ToString(); // 3
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F2.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F2").WithLocation(19, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F1").WithLocation(21, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F1").WithLocation(24, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F2.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F2").WithLocation(25, 9));
        }

        [Fact]
        public void Members_ObjectInitializer_Struct()
        {
            var source =
@"#pragma warning disable 0649
struct A
{
    internal object? F1;
    internal object? F2;
}
struct B
{
    internal A G;
}
class Program
{
    static void F()
    {
        (new B() { G = new A() { F1 = new object() } }).G.F1.ToString();
        B b;
        b = new B() { G = new A() { F1 = new object() } };
        b.G.F1.ToString(); // 1
        b.G.F2.ToString(); // 1
        b = new B() { G = new A() { F2 = new object() } };
        b.G.F1.ToString(); // 2
        b.G.F2.ToString(); // 2
        b = new B() { G = new A() };
        b.G.F1.ToString(); // 3
        b.G.F2.ToString(); // 3
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F2.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F2").WithLocation(19, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F1").WithLocation(21, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F1").WithLocation(24, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         b.G.F2.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.G.F2").WithLocation(25, 9));
        }

        [Fact]
        public void Members_ObjectInitializer_Properties()
        {
            var source =
@"#pragma warning disable 0649
class A
{
    internal object? P1 { get; set; }
    internal object? P2 { get; set; }
}
class B
{
    internal A? Q { get; set; }
}
class Program
{
    static void F()
    {
        (new B() { Q = new A() { P1 = new object() } }).Q.P1.ToString();
        B b;
        b = new B() { Q = new A() { P1 = new object() } };
        b.Q.P1.ToString(); // 1
        b.Q.P2.ToString(); // 1
        b = new B() { Q = new A() { P2 = new object() } };
        b.Q.P1.ToString(); // 2
        b.Q.P2.ToString(); // 2
        b = new B() { Q = new A() };
        b.Q.P1.ToString(); // 3
        b.Q.P2.ToString(); // 3
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         b.Q.P2.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.Q.P2").WithLocation(19, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         b.Q.P1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.Q.P1").WithLocation(21, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         b.Q.P1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.Q.P1").WithLocation(24, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         b.Q.P2.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.Q.P2").WithLocation(25, 9));
        }

        [Fact]
        public void Members_ObjectInitializer_Events()
        {
            var source =
@"delegate void D();
class C
{
    event D? E;
    static void F()
    {
        C c;
        c = new C() { };
        c.E.Invoke(); // warning
        c = new C() { E = F };
        c.E.Invoke();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         c.E.Invoke(); // warning
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.E").WithLocation(9, 9));
        }

        // https://github.com/dotnet/roslyn/issues/29977: Support assignment of derived type instances.
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29977")]
        [WorkItem(29977, "https://github.com/dotnet/roslyn/issues/29977")]
        public void Members_ObjectInitializer_DerivedType()
        {
            var source =
@"#pragma warning disable 0649
class A
{
    internal A? F;
}
class B : A
{
    internal object? G;
}
class Program
{
    static void Main()
    {
        A a;
        a = new B() { F = new A(), G = new object() };
        a.F.ToString(); // 1
        a = new A();
        a.F.ToString(); // 2
        a = new B() { F = new B() { F = new A() } };
        a.F.ToString(); // 3
        a.F.F.ToString(); // 3
        a = new B() { G = new object() };
        a.F.ToString(); // 4
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         a.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.F").WithLocation(18, 9),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         a.F.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.F").WithLocation(20, 9),
                // (23,9): warning CS8602: Possible dereference of a null reference.
                //         a.F.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.F").WithLocation(23, 9));
        }

        // https://github.com/dotnet/roslyn/issues/29977: Support assignment of derived type instances.
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/29977")]
        [WorkItem(29977, "https://github.com/dotnet/roslyn/issues/29977")]
        public void Members_Assignment()
        {
            var source =
@"#pragma warning disable 0649
class A
{
    internal A? F;
}
class B : A
{
    internal object? G;
}
class Program
{
    static void Main()
    {
        B b = new B();
        A a;
        a = b;
        a.F.ToString(); // 1
        b.F = new A();
        a = b;
        a.F.ToString(); // 2
        b = new B() { F = new B() { F = new A() } };
        a = b;
        a.F.ToString(); // 3
        a.F.F.ToString(); // 3
        b = new B() { G = new object() };
        a = b;
        a.F.ToString(); // 4
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         a.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.F").WithLocation(17, 9),
                // (27,9): warning CS8602: Possible dereference of a null reference.
                //         a.F.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.F").WithLocation(27, 9));
        }

        [Fact]
        public void Members_FieldCycle_01()
        {
            var source =
@"class C
{
    C? F;
    void M()
    {
        F = this;
        F.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         F.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F.F").WithLocation(7, 9));
        }

        [Fact]
        public void Members_FieldCycle_02()
        {
            var source =
@"class C
{
    C? F;
    void M()
    {
        F = new C() { F = this };
        F.F.ToString();
        F.F.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         F.F.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "F.F.F").WithLocation(8, 9));
        }

        [Fact]
        public void Members_FieldCycle_03()
        {
            var source =
@"class C
{
    C? F;
    static void M()
    {
        var x = new C();
        x.F = x;
        var y = new C() { F = x };
        y.F.F.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.F.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F.F").WithLocation(9, 9));
        }

        [Fact]
        public void Members_FieldCycle_Struct()
        {
            var source =
@"struct S
{
    internal C F;
    internal C? G;
}
class C
{
    internal S S;
    static void Main()
    {
        var s = new S() { F = new C(), G = new C() };
        s.F.S = s;
        s.G.S = s;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        // Valid struct since the property is not backed by a field.
        // https://github.com/dotnet/roslyn/issues/29619: Handle struct properties that are not auto-properties.
        [Fact(Skip = "Struct property not auto-property")]
        public void Members_PropertyCycle_Struct()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    internal S(object? f)
    {
        F = f;
    }
    internal object? F;
    internal S P
    {
        get { return new S(F); }
        set { F = value.F; }
    }
}
class C
{
    static void M(S s)
    {
        s.P.F.ToString(); // 1
        if (s.P.F == null) return;
        s.P.F.ToString(); // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         s.P.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s.P.F").WithLocation(19, 9));
        }

        [Fact]
        public void Members_DefaultConstructor_Class()
        {
            var source =
@"#pragma warning disable 649
#pragma warning disable 8618
class A
{
    internal object? A1;
    internal object A2;
}
class B
{
    internal B()
    {
        B2 = null!;
    }
    internal object? B1;
    internal object B2;
}
class Program
{
    static void Main()
    {
        A a = new A();
        a.A1.ToString(); // 1
        a.A2.ToString();
        B b = new B();
        b.B1.ToString(); // 2
        b.B2.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (22,9): warning CS8602: Possible dereference of a null reference.
                //         a.A1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.A1").WithLocation(22, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         b.B1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.B1").WithLocation(25, 9));
        }

        [Fact]
        public void SelectAnonymousType()
        {
            var source =
@"using System.Collections.Generic;
using System.Linq;
class C
{
    int? E;
    static void F(IEnumerable<C> c)
    {
        const int F = 0;
        c.Select(o => new { E = o.E ?? F });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,10): warning CS0649: Field 'C.E' is never assigned to, and will always have its default value
                //     int? E;
                Diagnostic(ErrorCode.WRN_UnassignedInternalField, "E").WithArguments("C.E", "").WithLocation(5, 10));
        }

        [Fact]
        public void Constraints_01()
        {
            var source =
@"interface I<T>
{
    T P { get; set; }
}
class A { }
class B
{
    static void F1<T>(T t1) where T : A
    {
        t1.ToString();
        t1 = default; // 1
    }
    static void F2<T>(T t2) where T : A?
    {
        t2.ToString(); // 2
        t2 = default; // 3
    }
    static void F3<T>(T t3) where T : I<T>
    {
        t3.P.ToString();
        t3 = default; // 6
    }
    static void F4<T>(T t4) where T : I<T>?
    {
        t4.P.ToString(); // 7 and 8
        t4.P = default; // 9
        t4 = default; // 10
    }
    static void F5<T>(T t5) where T : I<T?>
    {
        t5.P.ToString(); // 11 and 12
        t5.P = default;
        t5 = default; // 15
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29978: Various differences from expected warnings.
            comp.VerifyDiagnostics(
                // (29,41): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void F5<T>(T t5) where T : I<T?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(29, 41),
                // (11,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t1 = default; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(11, 14),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         t2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2").WithLocation(15, 9),
                // (16,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t2 = default; // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(16, 14),
                // (21,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t3 = default; // 6
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(21, 14),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         t4.P.ToString(); // 7 and 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t4").WithLocation(25, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         t4.P.ToString(); // 7 and 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t4.P").WithLocation(25, 9),
                // (26,16): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         t4.P = default; // 9
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(26, 16),
                // (27,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t4 = default; // 10
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(27, 14),
                // (31,9): warning CS8602: Possible dereference of a null reference.
                //         t5.P.ToString(); // 11 and 12
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t5.P").WithLocation(31, 9),
                // (33,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t5 = default; // 15
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(33, 14)
            );
        }

        [Fact]
        public void Constraints_02()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : class
    {
    }

    public static void F2<T2>(T2 t2) where T2 : class?
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T1>(T1? t1) where T1 : class", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = f1.TypeParameters[0];
                Assert.False(t1.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t1.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t1.GetAttributes().Single().ToString());
                }

                var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T2>(T2 t2) where T2 : class?", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                Assert.Equal("void B.F2<T2>(T2 t2) where T2 : class", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints.
                                                                                                WithMiscellaneousOptions(SymbolDisplayFormat.TestFormatWithConstraints.MiscellaneousOptions &
                                                                                                                            (~SymbolDisplayMiscellaneousOptions.IncludeNullableReferenceTypeModifier))));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.True(t2.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t2.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t2.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_03()
        {
            var source =
@"
class A<T1> where T1 : class
{
    public static void F1(T1? t1)
    {
    }
}
class B<T2> where T2 : class?
{
    public static void F2(T2 t2)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var a = (NamedTypeSymbol)m.GlobalNamespace.GetMember("A");
                Assert.Equal("A<T1> where T1 : class", a.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = a.TypeParameters[0];
                Assert.False(t1.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t1.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t1.GetAttributes().Single().ToString());
                }

                var b = (NamedTypeSymbol)m.GlobalNamespace.GetMember("B");
                Assert.Equal("B<T2> where T2 : class?", b.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = b.TypeParameters[0];
                Assert.True(t2.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t2.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t2.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_04()
        {
            var source =
@"
#pragma warning disable CS8321

class B
{
    public static void Test()
    {
        void F1<T1>(T1? t1) where T1 : class
        {
        }

        void F2<T2>(T2 t2) where T2 : class?
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp);

            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);

            var localSyntaxes = tree.GetRoot().DescendantNodes().OfType<LocalFunctionStatementSyntax>().ToArray();
            Assert.Equal(2, localSyntaxes.Length);

            var f1 = (LocalFunctionSymbol)model.GetDeclaredSymbol(localSyntaxes[0]);
            Assert.Equal("void F1<T1>(T1? t1) where T1 : class", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.False(t1.ReferenceTypeConstraintIsNullable);
            Assert.Empty(t1.GetAttributes());

            var f2 = (LocalFunctionSymbol)model.GetDeclaredSymbol(localSyntaxes[1]);
            Assert.Equal("void F2<T2>(T2 t2) where T2 : class?", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t2 = f2.TypeParameters[0];
            Assert.True(t2.ReferenceTypeConstraintIsNullable);
            Assert.Empty(t2.GetAttributes());
        }

        [Fact]
        public void Constraints_05()
        {
            var source =
@"
#pragma warning disable CS8321

class B<T1> where T1 : class?
{
    public static void F2<T2>(T2 t2) where T2 : class?
    {
        void F3<T3>(T3 t3) where T3 : class?
        {
        }
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics(
                // (4,29): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B<T1> where T1 : class?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 29),
                // (6,54): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public static void F2<T2>(T2 t2) where T2 : class?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(6, 54),
                // (8,44): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void F3<T3>(T3 t3) where T3 : class?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 44)
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var b = (NamedTypeSymbol)m.GlobalNamespace.GetMember("B");
                Assert.Equal("B<T1> where T1 : class?", b.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = b.TypeParameters[0];
                Assert.True(t1.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t1.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t1.GetAttributes().Single().ToString());
                }

                var f2 = (MethodSymbol)b.GetMember("F2");
                Assert.Equal("void B<T1>.F2<T2>(T2 t2) where T2 : class?", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.True(t2.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t2.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t2.GetAttributes().Single().ToString());
                }
            }

            comp = CreateCompilation(source, parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);
            var expected = new[] {
                // (4,29): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                // class B<T1> where T1 : class?
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(4, 29),
                // (6,54): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //     public static void F2<T2>(T2 t2) where T2 : class?
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(6, 54),
                // (8,44): error CS8652: The feature 'nullable reference types' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //         void F3<T3>(T3 t3) where T3 : class?
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "?").WithArguments("nullable reference types").WithLocation(8, 44)
            };
            comp.VerifyDiagnostics(expected);

            comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.RegularDefault, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(expected);

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(expected
                .Concat(new[] {
                // error CS8630: Invalid 'NullableContextOptions' value: 'Enable' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("NullableContextOptions", "Enable", "7.3", "8.0").WithLocation(1, 1),
                }).ToArray()
                );

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.RegularDefault, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(expected
                .Concat(new[] {
                // error CS8630: Invalid 'NullableContextOptions' value: 'Enable' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("NullableContextOptions", "Enable", "7.3", "8.0").WithLocation(1, 1),
                }).ToArray()
                );

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.RegularPreview, skipUsesIsNullable: true);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Constraints_06()
        {
            var source =
@"
#pragma warning disable CS8321

class B<T1> where T1 : class?
{
    public static void F1(T1? t1)
    {}

    public static void F2<T2>(T2? t2) where T2 : class?
    {
        void F3<T3>(T3? t3) where T3 : class?
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T2>(T2? t2) where T2 : class?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(9, 31),
                // (6,27): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1(T1? t1)
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(6, 27),
                // (11,21): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void F3<T3>(T3? t3) where T3 : class?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T3?").WithLocation(11, 21)
            );
        }

        [Fact]
        public void Constraints_07()
        {
            var source =
@"
class B
{
    public static void F1<T11, T12>(T12? t1) where T11 : class where T12 : T11
    {}

    public static void F2<T21, T22>(T22? t1) where T21 : class where T22 : class, T21
    {}

    public static void F3<T31, T32>(T32? t1) where T31 : B where T32 : T31
    {}

    public static void F4<T41, T42>(T42? t1) where T41 : B where T42 : T41?
    {}
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,37): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T11, T12>(T12? t1) where T11 : class where T12 : T11
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T12?").WithLocation(4, 37),
                // (13,37): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F4<T41, T42>(T42? t1) where T41 : B where T42 : T41?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T42?").WithLocation(13, 37)
            );
        }

        [Fact]
        public void Constraints_08()
        {
            var source =
@"
#pragma warning disable CS8321

class B<T11, T12> where T12 : T11?
{
    public static void F2<T21, T22>() where T22 : T21?
    {
        void F3<T31, T32>() where T32 : T31?
        {
        }
    }

    public static void F4<T4>() where T4 : T4?
    {}
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class B<T11, T12> where T12 : T11?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T11?").WithLocation(4, 31),
                // (6,51): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T21, T22>() where T22 : T21?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T21?").WithLocation(6, 51),
                // (8,41): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void F3<T31, T32>() where T32 : T31?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T31?").WithLocation(8, 41),
                // (13,27): error CS0454: Circular constraint dependency involving 'T4' and 'T4'
                //     public static void F4<T4>() where T4 : T4?
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T4").WithArguments("T4", "T4").WithLocation(13, 27),
                // (13,44): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F4<T4>() where T4 : T4?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T4?").WithLocation(13, 44)
            );
        }

        [Fact]
        public void Constraints_09()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : Node<T1>?
    {}

    public static void F2<T2>() where T2 : Node<T2?>
    {}

    public static void F3<T3>() where T3 : Node<T3?>?
    {}
}

class Node<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,49): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T3>() where T3 : Node<T3?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T3?").WithLocation(10, 49)
            );
        }

        [Fact]
        public void Constraints_10()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : class, Node<T1>?
    {}

    public static void F2<T2>() where T2 : class, Node<T2?>
    {}

    public static void F3<T3>() where T3 : class, Node<T3?>?
    {}
}

class Node<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,51): error CS0450: 'Node<T2?>': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F2<T2>() where T2 : class, Node<T2?>
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "Node<T2?>").WithArguments("Node<T2?>").WithLocation(7, 51),
                // (10,51): error CS0450: 'Node<T3?>': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F3<T3>() where T3 : class, Node<T3?>?
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "Node<T3?>?").WithArguments("Node<T3?>").WithLocation(10, 51),
                // (4,51): error CS0450: 'Node<T1>': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F1<T1>() where T1 : class, Node<T1>?
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "Node<T1>?").WithArguments("Node<T1>").WithLocation(4, 51)
            );
        }

        [Fact]
        public void Constraints_11()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : class?, Node<T1>?
    {}

    public static void F2<T2>() where T2 : class?, Node<T2?>
    {}

    public static void F3<T3>() where T3 : class?, Node<T3?>?
    {}
}

class Node<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,52): error CS0450: 'Node<T2?>': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F2<T2>() where T2 : class?, Node<T2?>
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "Node<T2?>").WithArguments("Node<T2?>").WithLocation(7, 52),
                // (7,57): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T2>() where T2 : class?, Node<T2?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(7, 57),
                // (10,52): error CS0450: 'Node<T3?>': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F3<T3>() where T3 : class?, Node<T3?>?
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "Node<T3?>?").WithArguments("Node<T3?>").WithLocation(10, 52),
                // (10,57): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T3>() where T3 : class?, Node<T3?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T3?").WithLocation(10, 57),
                // (4,52): error CS0450: 'Node<T1>': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F1<T1>() where T1 : class?, Node<T1>?
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "Node<T1>?").WithArguments("Node<T1>").WithLocation(4, 52)
            );
        }

        [Fact]
        public void Constraints_12()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : INode<T1>?
    {}

    public static void F2<T2>() where T2 : INode<T2?>
    {}

    public static void F3<T3>() where T3 : INode<T3?>?
    {}
}

interface INode<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,50): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T2>() where T2 : INode<T2?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(7, 50),
                // (10,50): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T3>() where T3 : INode<T3?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T3?").WithLocation(10, 50)
            );
        }

        [Fact]
        public void Constraints_13()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : class, INode<T1>?
    {}

    public static void F2<T2>() where T2 : class, INode<T2?>
    {}

    public static void F3<T3>() where T3 : class, INode<T3?>?
    {}
}

interface INode<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );
        }

        [Fact]
        public void Constraints_14()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : class?, INode<T1>?
    {}

    public static void F2<T2>() where T2 : class?, INode<T2?>
    {}

    public static void F3<T3>() where T3 : class?, INode<T3?>?
    {}
}

interface INode<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,58): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T3>() where T3 : class?, INode<T3?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T3?").WithLocation(10, 58)
            );
        }

        [Fact]
        public void Constraints_15()
        {
            var source =
@"
class B
{
    public static void F1<T11, T12>() where T11 : INode where T12 : class?, T11, INode<T12?>
    {}

    public static void F2<T21, T22>() where T21 : INode? where T22 : class?, T21, INode<T22?>
    {}

    public static void F3<T31, T32>() where T31 : INode? where T32 : class?, T31, INode<T32?>?
    {}

    public static void F4<T41, T42>() where T41 : INode? where T42 : class?, T41?, INode<T42?>?
    {}
}

interface INode
{}

interface INode<T>
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,89): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T31, T32>() where T31 : INode? where T32 : class?, T31, INode<T32?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T32?").WithLocation(10, 89),
                // (13,78): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F4<T41, T42>() where T41 : INode? where T42 : class?, T41?, INode<T42?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T41?").WithLocation(13, 78),
                // (13,90): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F4<T41, T42>() where T41 : INode? where T42 : class?, T41?, INode<T42?>?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T42?").WithLocation(13, 90)
            );
        }

        [Fact]
        public void Constraints_16()
        {
            var source =
@"
class B
{
    public static void F1<T11, T12>(T12? t1) where T11 : INode where T12 : class?, T11
    {}

    public static void F2<T21, T22>(T22? t2) where T21 : INode? where T22 : class?, T21
    {}

    public static void F3<T31, T32>(T32? t1) where T31 : INode where T32 : class?, T31?
    {}
}

interface INode
{}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,37): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T21, T22>(T22? t2) where T21 : INode? where T22 : class?, T21
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T22?").WithLocation(7, 37),
                // (10,37): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T31, T32>(T32? t1) where T31 : INode where T32 : class?, T31?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T32?").WithLocation(10, 37),
                // (10,84): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F3<T31, T32>(T32? t1) where T31 : INode where T32 : class?, T31?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T31?").WithLocation(10, 84)
            );
        }

        [Fact]
        public void Constraints_17()
        {
            var source =
@"
#pragma warning disable CS8321

class B<[System.Runtime.CompilerServices.Nullable(0)] T1>
{
    public static void F2<[System.Runtime.CompilerServices.Nullable(1)] T2>(T2 t2)
    {
        void F3<[System.Runtime.CompilerServices.Nullable(2)] T3>(T3 t3)
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source, NullableAttributeDefinition });
            comp.VerifyDiagnostics(
                // (4,10): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                // class B<[System.Runtime.CompilerServices.Nullable(0)] T1>
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "System.Runtime.CompilerServices.Nullable(0)").WithLocation(4, 10),
                // (6,28): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //     public static void F2<[System.Runtime.CompilerServices.Nullable(1)] T2>(T2 t2)
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "System.Runtime.CompilerServices.Nullable(1)").WithLocation(6, 28),
                // (8,17): error CS8205: Attributes are not allowed on local function parameters or type parameters
                //         void F3<[System.Runtime.CompilerServices.Nullable(2)] T3>(T3 t3)
                Diagnostic(ErrorCode.ERR_AttributesInLocalFuncDecl, "[System.Runtime.CompilerServices.Nullable(2)]").WithLocation(8, 17),
                // (8,18): error CS8623: Explicit application of 'System.Runtime.CompilerServices.NullableAttribute' is not allowed.
                //         void F3<[System.Runtime.CompilerServices.Nullable(2)] T3>(T3 t3)
                Diagnostic(ErrorCode.ERR_ExplicitNullableAttribute, "System.Runtime.CompilerServices.Nullable(2)").WithLocation(8, 18)
            );
        }

        [Fact]
        public void Constraints_18()
        {
            var source =
@"
class A<T>
{
    public virtual void F1<T1>(T1? t1) where T1 : class
    {
    }

    public virtual void F2<T2>(T2 t2) where T2 : class?
    {
    }
}

class B : A<int>
{
    public override void F1<T11>(T11? t1)
    {
    }

    public override void F2<T22>(T22 t2)
    {
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T11>(T11? t1) where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t11.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t11.GetAttributes().Single().ToString());
                }

                var af1 = bf1.OverriddenMethod;
                Assert.Equal("void A<System.Int32>.F1<T1>(T1? t1) where T1 : class", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = af1.TypeParameters[0];
                Assert.False(t1.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t1.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t1.GetAttributes().Single().ToString());
                }

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T22>(T22 t2) where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t22.GetAttributes().Single().ToString());
                }

                var af2 = bf2.OverriddenMethod;
                Assert.Equal("void A<System.Int32>.F2<T2>(T2 t2) where T2 : class?", af2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t2 = af2.TypeParameters[0];
                Assert.True(t2.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t2.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t2.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_19()
        {
            var source1 =
@"
public class A<T>
{
    public virtual void F1<T1>(T1? t1) where T1 : class
    {
    }

    public virtual void F2<T2>(T2 t2) where T2 : class?
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var source2 =
@"
class B : A<int>
{
    public override void F1<T11>(T11? t1)
    {
    }

    public override void F2<T22>(T22 t2)
    {
    }
}
";

            var comp2 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });

            CompileAndVerify(comp2, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T11>(T11? t1) where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t11.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t11.GetAttributes().Single().ToString());
                }

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T22>(T22 t2) where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    CSharpAttributeData nullableAttribute = t22.GetAttributes().Single();
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", nullableAttribute.ToString());
                    Assert.Same(m, nullableAttribute.AttributeClass.ContainingModule);
                    Assert.Equal(Accessibility.Internal, nullableAttribute.AttributeClass.DeclaredAccessibility);
                }
            }
        }

        [Fact]
        public void Constraints_20()
        {
            var source1 =
@"
public class A<T>
{
    public virtual void F1<T1>(T1? t1) where T1 : class
    {
    }

    public virtual void F2<T2>(T2 t2) where T2 : class?
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var comp2 = CreateCompilation(NullableAttributeDefinition);

            var source3 =
@"
class B : A<int>
{
    public override void F1<T11>(T11? t1)
    {
    }

    public override void F2<T22>(T22 t2)
    {
    }
}
";

            var comp3 = CreateCompilation(new[] { source3 }, options: WithNonNullTypesTrue(),
                                          references: new[] { comp1.EmitToImageReference(), comp2.EmitToImageReference() },
                                          parseOptions: TestOptions.Regular8);

            CompileAndVerify(comp3, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T11>(T11? t1) where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t11.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t11.GetAttributes().Single().ToString());
                }

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T22>(T22 t2) where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    CSharpAttributeData nullableAttribute = t22.GetAttributes().Single();
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", nullableAttribute.ToString());
                    Assert.NotEqual(m, nullableAttribute.AttributeClass.ContainingModule);
                }
            }
        }

        [Fact]
        public void Constraints_21()
        {
            var source1 =
@"
public class A<T>
{
    public virtual void F1<T1>() where T1 : class
    {
    }

    public virtual void F2<T2>() where T2 : class?
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var source2 =
@"
class B : A<int>
{
    public override void F1<T11>()
    {
    }

    public override void F2<T22>()
    {
    }
}
";

            var comp2 = CreateCompilation(new[] { source2 }, references: new[] { comp1.EmitToImageReference() });

            comp2.VerifyDiagnostics();

            CompileAndVerify(comp2, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t11.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t11.GetAttributes().Single().ToString());
                }

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t22.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_22()
        {
            var source =
@"
class A<T>
{
    public virtual void F1<T1>(T1? t1) where T1 : class
    {
    }

    public virtual void F2<T2>(T2 t2) where T2 : class?
    {
    }
}

class B : A<int>
{
    public override void F1<T11>(T11? t1) where T11 : class?
    {
    }

    public override void F2<T22>(T22 t2) where T22 : class
    {
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,43): error CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly
                //     public override void F1<T11>(T11? t1) where T11 : class?
                Diagnostic(ErrorCode.ERR_OverrideWithConstraints, "where").WithLocation(15, 43),
                // (19,42): error CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly
                //     public override void F2<T22>(T22 t2) where T22 : class
                Diagnostic(ErrorCode.ERR_OverrideWithConstraints, "where").WithLocation(19, 42)
            );

            var bf1 = (MethodSymbol)comp.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T11>(T11? t1) where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t11 = bf1.TypeParameters[0];
            Assert.False(t11.ReferenceTypeConstraintIsNullable);

            var af1 = bf1.OverriddenMethod;
            Assert.Equal("void A<System.Int32>.F1<T1>(T1? t1) where T1 : class", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = af1.TypeParameters[0];
            Assert.False(t1.ReferenceTypeConstraintIsNullable);

            var bf2 = (MethodSymbol)comp.GlobalNamespace.GetMember("B.F2");
            Assert.Equal("void B.F2<T22>(T22 t2) where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

            TypeParameterSymbol t22 = bf2.TypeParameters[0];
            Assert.True(t22.ReferenceTypeConstraintIsNullable);

            var af2 = bf2.OverriddenMethod;
            Assert.Equal("void A<System.Int32>.F2<T2>(T2 t2) where T2 : class?", af2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

            TypeParameterSymbol t2 = af2.TypeParameters[0];
            Assert.True(t2.ReferenceTypeConstraintIsNullable);
        }

        [Fact]
        public void Constraints_23()
        {
            var source1 =
@"
public interface IA
{
    void F1<T1>() where T1 : class?;
    void F2<T2>() where T2 : class;
    void F3<T3>() where T3 : C1<C2>;
    void F4<T4>() where T4 : C1<C2>;
    void F5<T51, T52>() where T51 : class where T52 : C1<T51>;
    void F6<T61, T62>() where T61 : class where T62 : C1<T61?>;
}

public class C1<T>
{}

public class C2
{}
";
            var source2 =
@"
class B : IA
{
    public void F1<T11>() where T11 : class
    {
    }

    public void F2<T22>() where T22 : class?
    {
    }

    public void F3<T33>() where T33 : C1<C2?>
    {
    }

    public void F4<T44>() where T44 : C1<C2>?
    {
    }

    public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
    {
    }

    public void F6<T661, T662>() where T661 : class where T662 : C1<T661>
    {
    }
}

class D : IA
{
    public void F1<T111>() where T111 : class?
    {
    }

    public void F2<T222>() where T222 : class
    {
    }

    public void F3<T333>() where T333 : C1<C2>
    {
    }

    public void F4<T444>() where T444 : C1<C2>
    {
    }

    public void F5<T5551, T5552>() where T5551 : class where T5552 : C1<T5551>
    {
    }

    public void F6<T6661, T6662>() where T6661 : class where T6662 : C1<T6661?>
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source2, source1 }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T11' of method 'B.F1<T11>()' doesn't match the constraints for type parameter 'T1' of interface method 'IA.F1<T1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<T11>() where T11 : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("T11", "B.F1<T11>()", "T1", "IA.F1<T1>()").WithLocation(4, 17),
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA.F2<T2>()").WithLocation(8, 17),
                // (12,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1<C2?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA.F3<T3>()").WithLocation(12, 17),
                // (16,17): warning CS8633: Nullability in constraints for type parameter 'T44' of method 'B.F4<T44>()' doesn't match the constraints for type parameter 'T4' of interface method 'IA.F4<T4>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T44>() where T44 : C1<C2>?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T44", "B.F4<T44>()", "T4", "IA.F4<T4>()").WithLocation(16, 17),
                // (20,17): warning CS8633: Nullability in constraints for type parameter 'T552' of method 'B.F5<T551, T552>()' doesn't match the constraints for type parameter 'T52' of interface method 'IA.F5<T51, T52>()'. Consider using an explicit interface implementation instead.
                //     public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F5").WithArguments("T552", "B.F5<T551, T552>()", "T52", "IA.F5<T51, T52>()").WithLocation(20, 17),
                // (24,17): warning CS8633: Nullability in constraints for type parameter 'T662' of method 'B.F6<T661, T662>()' doesn't match the constraints for type parameter 'T62' of interface method 'IA.F6<T61, T62>()'. Consider using an explicit interface implementation instead.
                //     public void F6<T661, T662>() where T661 : class where T662 : C1<T661>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F6").WithArguments("T662", "B.F6<T661, T662>()", "T62", "IA.F6<T61, T62>()").WithLocation(24, 17)
            );

            CompileAndVerify(comp1, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t11.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t11.GetAttributes().Single().ToString());
                }

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t22.GetAttributes().Single().ToString());
                }

                var bf3 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F3");
                Assert.Equal("void B.F3<T33>() where T33 : C1<C2?>", bf3.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                var bf4 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F4");
                Assert.Equal("void B.F4<T44>() where T44 : C1<C2>?", bf4.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            }

            var comp2 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());
            comp2.VerifyDiagnostics(
            );

            var comp3 = CreateCompilation(new[] { source2 }, references: new[] { comp2.ToMetadataReference() });
            comp3.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA.F2<T2>()").WithLocation(8, 17),
                // (12,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1<C2?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA.F3<T3>()").WithLocation(12, 17),
                // (16,17): warning CS8633: Nullability in constraints for type parameter 'T44' of method 'B.F4<T44>()' doesn't match the constraints for type parameter 'T4' of interface method 'IA.F4<T4>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T44>() where T44 : C1<C2>?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T44", "B.F4<T44>()", "T4", "IA.F4<T4>()").WithLocation(16, 17),
                // (20,17): warning CS8633: Nullability in constraints for type parameter 'T552' of method 'B.F5<T551, T552>()' doesn't match the constraints for type parameter 'T52' of interface method 'IA.F5<T51, T52>()'. Consider using an explicit interface implementation instead.
                //     public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F5").WithArguments("T552", "B.F5<T551, T552>()", "T52", "IA.F5<T51, T52>()").WithLocation(20, 17),
                // (20,69): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T551?").WithLocation(20, 69),
                // (51,73): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F6<T6661, T6662>() where T6661 : class where T6662 : C1<T6661?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T6661?").WithLocation(51, 73)
            );

            var comp4 = CreateCompilation(new[] { source1 });

            var comp5 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp4.ToMetadataReference() });
            comp5.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T11' of method 'B.F1<T11>()' doesn't match the constraints for type parameter 'T1' of interface method 'IA.F1<T1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<T11>() where T11 : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("T11", "B.F1<T11>()", "T1", "IA.F1<T1>()").WithLocation(4, 17),
                // (24,17): warning CS8633: Nullability in constraints for type parameter 'T662' of method 'B.F6<T661, T662>()' doesn't match the constraints for type parameter 'T62' of interface method 'IA.F6<T61, T62>()'. Consider using an explicit interface implementation instead.
                //     public void F6<T661, T662>() where T661 : class where T662 : C1<T661>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F6").WithArguments("T662", "B.F6<T661, T662>()", "T62", "IA.F6<T61, T62>()").WithLocation(24, 17)
                );
        }

        [Fact]
        public void Constraints_24()
        {
            var source =
@"
interface IA
{
    void F1<T1>() where T1 : class;
    void F2<T2>() where T2 : class?;
}

class B : IA
{
    void IA.F1<T11>()
    {
    }

    void IA.F2<T22>()
    {
    }
}
";
            var comp = CreateCompilation(new[] { source },
                                         options: WithNonNullTypesTrue(TestOptions.ReleaseDll.WithMetadataImportOptions(MetadataImportOptions.All)));
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F1");
                Assert.Equal("void B.IA.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t11.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t11.GetAttributes().Single().ToString());
                }

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F2");
                Assert.Equal("void B.IA.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t22.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_25()
        {
            var source1 =
@"
public interface IA
{
    void F1<T1>() where T1 : class;
    void F2<T2>() where T2 : class?;
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var source2 =
@"
class B : IA
{
    void IA.F1<T11>()
    {
    }

    void IA.F2<T22>()
    {
    }
}
";
            var comp2 = CreateCompilation(new[] { source2 },
                                          options: WithNonNullTypesTrue(TestOptions.ReleaseDll.WithMetadataImportOptions(MetadataImportOptions.All)),
                                          references: new[] { comp1.EmitToImageReference() });

            CompileAndVerify(comp2, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F1");
                Assert.Equal("void B.IA.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t11.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t11.GetAttributes().Single().ToString());
                }

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F2");
                Assert.Equal("void B.IA.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    CSharpAttributeData nullableAttribute = t22.GetAttributes().Single();
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", nullableAttribute.ToString());
                    Assert.Same(m, nullableAttribute.AttributeClass.ContainingModule);
                    Assert.Equal(Accessibility.Internal, nullableAttribute.AttributeClass.DeclaredAccessibility);
                }
            }
        }

        [Fact]
        public void Constraints_26()
        {
            var source1 =
@"
public interface IA
{
    void F1<T1>() where T1 : class;
    void F2<T2>() where T2 : class?;
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var comp2 = CreateCompilation(NullableAttributeDefinition);

            var source3 =
@"
class B : IA
{
    void IA.F1<T11>()
    {
    }

    void IA.F2<T22>()
    {
    }
}
";
            var comp3 = CreateCompilation(new[] { source3 },
                                          options: WithNonNullTypesTrue(TestOptions.ReleaseDll.WithMetadataImportOptions(MetadataImportOptions.All)),
                                          references: new[] { comp1.EmitToImageReference(), comp2.EmitToImageReference() });
            comp3.VerifyDiagnostics(
            );

            CompileAndVerify(comp3, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F1");
                Assert.Equal("void B.IA.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t11.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t11.GetAttributes().Single().ToString());
                }

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F2");
                Assert.Equal("void B.IA.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    CSharpAttributeData nullableAttribute = t22.GetAttributes().Single();
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", nullableAttribute.ToString());
                    Assert.NotEqual(m, nullableAttribute.AttributeClass.ContainingModule);
                }
            }
        }

        [Fact]
        public void Constraints_27()
        {
            var source1 =
@"
public interface IA
{
    void F1<T1>() where T1 : class;
    void F2<T2>() where T2 : class?;
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var source2 =
@"
class B : IA
{
    void IA.F1<T11>()
    {
    }

    void IA.F2<T22>()
    {
    }
}
";

            var comp2 = CreateCompilation(new[] { source2 }, references: new[] { comp1.EmitToImageReference() });

            comp2.VerifyDiagnostics();

            CompileAndVerify(comp2, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F1");
                Assert.Equal("void B.IA.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t11.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t11.GetAttributes().Single().ToString());
                }

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.IA.F2");
                Assert.Equal("void B.IA.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t22.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_28()
        {
            var source =
@"
interface IA
{
    void F1<T1>(T1? t1) where T1 : class;
    void F2<T2>(T2 t2) where T2 : class?;
}

class B : IA
{
    void IA.F1<T11>(T11? t1) where T11 : class?
    {
    }

    void IA.F2<T22>(T22 t2) where T22 : class
    {
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,30): error CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly
                //     void IA.F1<T11>(T11? t1) where T11 : class?
                Diagnostic(ErrorCode.ERR_OverrideWithConstraints, "where").WithLocation(10, 30),
                // (14,29): error CS0460: Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly
                //     void IA.F2<T22>(T22 t2) where T22 : class
                Diagnostic(ErrorCode.ERR_OverrideWithConstraints, "where").WithLocation(14, 29)
            );

            var bf1 = (MethodSymbol)comp.GlobalNamespace.GetMember("B.IA.F1");
            Assert.Equal("void B.IA.F1<T11>(T11? t1) where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t11 = bf1.TypeParameters[0];
            Assert.False(t11.ReferenceTypeConstraintIsNullable);

            var bf2 = (MethodSymbol)comp.GlobalNamespace.GetMember("B.IA.F2");
            Assert.Equal("void B.IA.F2<T22>(T22 t2) where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t22 = bf2.TypeParameters[0];
            Assert.True(t22.ReferenceTypeConstraintIsNullable);
        }

        [Fact]
        public void Constraints_29()
        {
            var source =
@"
class B
{
    public static void F2<T2>() where T2 : class?
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T2>() where T2 : class?", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.True(t2.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t2.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t2.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_30()
        {
            var source =
@"
class B<T2> where T2 : class?
{
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var b = (NamedTypeSymbol)m.GlobalNamespace.GetMember("B");
                Assert.Equal("B<T2> where T2 : class?", b.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = b.TypeParameters[0];
                Assert.True(t2.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t2.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t2.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void Constraints_31()
        {
            var source =
@"
#pragma warning disable CS8321

class B
{
    public static void Test()
    {
        void F2<T2>() where T2 : class?
        {
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp);

            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);

            var localSyntaxes = tree.GetRoot().DescendantNodes().OfType<LocalFunctionStatementSyntax>().ToArray();
            Assert.Equal(1, localSyntaxes.Length);

            var f2 = (LocalFunctionSymbol)model.GetDeclaredSymbol(localSyntaxes[0]);
            Assert.Equal("void F2<T2>() where T2 : class?", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t2 = f2.TypeParameters[0];
            Assert.True(t2.ReferenceTypeConstraintIsNullable);
            Assert.Empty(t2.GetAttributes());
        }

        [Fact]
        public void Constraints_32()
        {
            var source =
@"
#pragma warning disable CS8321

class B<T1> where T1 : struct?
{
    public static void F2<T2>(T2 t2) where T2 : struct?
    {
        void F3<T3>(T3 t3) where T3 : struct?
        {
        }
    }
}";
            var comp = CreateCompilation(source);

            var expected = new[] {
                // (4,30): error CS1073: Unexpected token '?'
                // class B<T1> where T1 : struct?
                Diagnostic(ErrorCode.ERR_UnexpectedToken, "?").WithArguments("?").WithLocation(4, 30),
                // (6,55): error CS1073: Unexpected token '?'
                //     public static void F2<T2>(T2 t2) where T2 : struct?
                Diagnostic(ErrorCode.ERR_UnexpectedToken, "?").WithArguments("?").WithLocation(6, 55),
                // (8,45): error CS1073: Unexpected token '?'
                //         void F3<T3>(T3 t3) where T3 : struct?
                Diagnostic(ErrorCode.ERR_UnexpectedToken, "?").WithArguments("?").WithLocation(8, 45)
            };

            comp.VerifyDiagnostics(expected);

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(expected);

            comp = CreateCompilation(source, parseOptions: TestOptions.Regular7_3);
            comp.VerifyDiagnostics(expected);

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);
            comp.VerifyDiagnostics(expected
                .Concat(new[] {
                // error CS8630: Invalid 'NullableContextOptions' value: 'Enable' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("NullableContextOptions", "Enable", "7.3", "8.0").WithLocation(1, 1)
                }).ToArray()
                );
        }

        [Fact]
        public void Constraints_33()
        {
            var source =
@"
interface IA<TA>
{ }

class C<TC> where TC : IA<object>, IA<object?>
{ }

class B<TB> where TB : IA<object?>, IA<object>
{ }
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,36): error CS0405: Duplicate constraint 'IA<object>' for type parameter 'TC'
                // class C<TC> where TC : IA<object>, IA<object?>
                Diagnostic(ErrorCode.ERR_DuplicateBound, "IA<object?>").WithArguments("IA<object>", "TC").WithLocation(5, 36),
                // (8,37): error CS0405: Duplicate constraint 'IA<object>' for type parameter 'TB'
                // class B<TB> where TB : IA<object?>, IA<object>
                Diagnostic(ErrorCode.ERR_DuplicateBound, "IA<object>").WithArguments("IA<object>", "TB").WithLocation(8, 37)
            );
        }

        [Fact]
        public void Constraints_34()
        {
            var source =
@"
interface IA<TA>
{ }

class B<TB> where TB : IA<object>?, IA<object>
{ }

class C<TC> where TC : IA<object>, IA<object>?
{ }
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,37): error CS0405: Duplicate constraint 'IA<object>' for type parameter 'TB'
                // class B<TB> where TB : IA<object>?, IA<object>
                Diagnostic(ErrorCode.ERR_DuplicateBound, "IA<object>").WithArguments("IA<object>", "TB").WithLocation(5, 37),
                // (8,36): error CS0405: Duplicate constraint 'IA<object>' for type parameter 'TC'
                // class C<TC> where TC : IA<object>, IA<object>?
                Diagnostic(ErrorCode.ERR_DuplicateBound, "IA<object>?").WithArguments("IA<object>", "TC").WithLocation(8, 36)
            );
        }

        [Fact]
        public void Constraints_35()
        {
            var source1 =
@"
public interface IA<S>
{
    void F1<T1>() where T1 : class?;
    void F2<T2>() where T2 : class;
    void F3<T3>() where T3 : C1<C2>;
    void F4<T4>() where T4 : C1<C2>;
    void F5<T51, T52>() where T51 : class where T52 : C1<T51>;
    void F6<T61, T62>() where T61 : class where T62 : C1<T61?>;
}

public class C1<T>
{}

public class C2
{}
";
            var source2 =
@"
class B : IA<string>
{
    public void F1<T11>() where T11 : class
    {
    }

    public void F2<T22>() where T22 : class?
    {
    }

    public void F3<T33>() where T33 : C1<C2?>
    {
    }

    public void F4<T44>() where T44 : C1<C2>?
    {
    }

    public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
    {
    }

    public void F6<T661, T662>() where T661 : class where T662 : C1<T661>
    {
    }
}

class D : IA<string>
{
    public void F1<T111>() where T111 : class?
    {
    }

    public void F2<T222>() where T222 : class
    {
    }

    public void F3<T333>() where T333 : C1<C2>
    {
    }

    public void F4<T444>() where T444 : C1<C2>
    {
    }

    public void F5<T5551, T5552>() where T5551 : class where T5552 : C1<T5551>
    {
    }

    public void F6<T6661, T6662>() where T6661 : class where T6662 : C1<T6661?>
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source2, source1 }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T11' of method 'B.F1<T11>()' doesn't match the constraints for type parameter 'T1' of interface method 'IA<string>.F1<T1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<T11>() where T11 : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("T11", "B.F1<T11>()", "T1", "IA<string>.F1<T1>()").WithLocation(4, 17),
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA<string>.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA<string>.F2<T2>()").WithLocation(8, 17),
                // (12,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA<string>.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1<C2?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA<string>.F3<T3>()").WithLocation(12, 17),
                // (16,17): warning CS8633: Nullability in constraints for type parameter 'T44' of method 'B.F4<T44>()' doesn't match the constraints for type parameter 'T4' of interface method 'IA<string>.F4<T4>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T44>() where T44 : C1<C2>?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T44", "B.F4<T44>()", "T4", "IA<string>.F4<T4>()").WithLocation(16, 17),
                // (20,17): warning CS8633: Nullability in constraints for type parameter 'T552' of method 'B.F5<T551, T552>()' doesn't match the constraints for type parameter 'T52' of interface method 'IA<string>.F5<T51, T52>()'. Consider using an explicit interface implementation instead.
                //     public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F5").WithArguments("T552", "B.F5<T551, T552>()", "T52", "IA<string>.F5<T51, T52>()").WithLocation(20, 17),
                // (24,17): warning CS8633: Nullability in constraints for type parameter 'T662' of method 'B.F6<T661, T662>()' doesn't match the constraints for type parameter 'T62' of interface method 'IA<string>.F6<T61, T62>()'. Consider using an explicit interface implementation instead.
                //     public void F6<T661, T662>() where T661 : class where T662 : C1<T661>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F6").WithArguments("T662", "B.F6<T661, T662>()", "T62", "IA<string>.F6<T61, T62>()").WithLocation(24, 17)
            );

            CompileAndVerify(comp1, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T11>() where T11 : class", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.False(t11.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t11.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(1)", t11.GetAttributes().Single().ToString());
                }

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T22>() where T22 : class?", bf2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.True(t22.ReferenceTypeConstraintIsNullable);
                if (isSource)
                {
                    Assert.Empty(t22.GetAttributes());
                }
                else
                {
                    Assert.Equal("System.Runtime.CompilerServices.NullableAttribute(2)", t22.GetAttributes().Single().ToString());
                }

                var bf3 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F3");
                Assert.Equal("void B.F3<T33>() where T33 : C1<C2?>", bf3.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                var bf4 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F4");
                Assert.Equal("void B.F4<T44>() where T44 : C1<C2>?", bf4.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            }

            var comp2 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());
            comp2.VerifyDiagnostics(
            );

            var comp3 = CreateCompilation(new[] { source2 }, references: new[] { comp2.ToMetadataReference() });
            comp3.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA<string>.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA<string>.F2<T2>()").WithLocation(8, 17),
                // (12,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA<string>.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1<C2?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA<string>.F3<T3>()").WithLocation(12, 17),
                // (16,17): warning CS8633: Nullability in constraints for type parameter 'T44' of method 'B.F4<T44>()' doesn't match the constraints for type parameter 'T4' of interface method 'IA<string>.F4<T4>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T44>() where T44 : C1<C2>?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T44", "B.F4<T44>()", "T4", "IA<string>.F4<T4>()").WithLocation(16, 17),
                // (20,17): warning CS8633: Nullability in constraints for type parameter 'T552' of method 'B.F5<T551, T552>()' doesn't match the constraints for type parameter 'T52' of interface method 'IA<string>.F5<T51, T52>()'. Consider using an explicit interface implementation instead.
                //     public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F5").WithArguments("T552", "B.F5<T551, T552>()", "T52", "IA<string>.F5<T51, T52>()").WithLocation(20, 17),
                // (20,69): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F5<T551, T552>() where T551 : class where T552 : C1<T551?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T551?").WithLocation(20, 69),
                // (51,73): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F6<T6661, T6662>() where T6661 : class where T6662 : C1<T6661?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T6661?").WithLocation(51, 73)
            );

            var comp4 = CreateCompilation(new[] { source1 });

            var comp5 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp4.ToMetadataReference() });
            comp5.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T11' of method 'B.F1<T11>()' doesn't match the constraints for type parameter 'T1' of interface method 'IA<string>.F1<T1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<T11>() where T11 : class
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("T11", "B.F1<T11>()", "T1", "IA<string>.F1<T1>()").WithLocation(4, 17),
                // (24,17): warning CS8633: Nullability in constraints for type parameter 'T662' of method 'B.F6<T661, T662>()' doesn't match the constraints for type parameter 'T62' of interface method 'IA<string>.F6<T61, T62>()'. Consider using an explicit interface implementation instead.
                //     public void F6<T661, T662>() where T661 : class where T662 : C1<T661>
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F6").WithArguments("T662", "B.F6<T661, T662>()", "T62", "IA<string>.F6<T61, T62>()").WithLocation(24, 17)
                );
        }

        [Fact]
        public void Constraints_36()
        {
            var source1 =
@"
public interface IA
{
    void F1<T1>() where T1 : class?, IB, IC?;
    void F2<T2>() where T2 : class, IB?, IC?;
    void F3<T3>() where T3 : class?, IB?, IC;
    void F4<T41, T42>() where T41 : class where T42 : T41?, IB, IC?;
    void F5<T51, T52>() where T51 : class where T52 : T51, IB?, IC?;
    void F6<T61, T62>() where T61 : class where T62 : T61?, IB?, IC;
    void F7<T71, T72>() where T71 : class? where T72 : T71, IB, IC?;
    void F8<T81, T82>() where T81 : class where T82 : T81, IB?, IC?;
    void F9<T91, T92>() where T91 : class? where T92 : T91, IB?, IC;
}

public interface IB
{}

public interface IC
{}
";
            var source2 =
@"
class B : IA
{
    public void F1<T11>() where T11 : class, IB, IC 
    {
    }

    public void F2<T22>() where T22 : class, IB, IC
    {
    }

    public void F3<T33>() where T33 : class, IB, IC
    {
    }

    public void F4<T441, T442>() where T441 : class where T442 : T441, IB, IC
    {
    }

    public void F5<T551, T552>() where T551 : class where T552 : T551, IB, IC
    {
    }

    public void F6<T661, T662>() where T661 : class where T662 : T661, IB, IC
    {
    }

    public void F7<T771, T772>() where T771 : class where T772 : T771, IB, IC
    {
    }

    public void F8<T881, T882>() where T881 : class where T882 : T881, IB, IC
    {
    }

    public void F9<T991, T992>() where T991 : class where T992 : T991, IB, IC
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());

            var comp2 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp1.ToMetadataReference() });

            var expected = new[]
            {
                // (36,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : class where T992 : T991, IB, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(36, 17),
                // (28,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : class where T772 : T771, IB, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(28, 17)
            };

            comp2.VerifyDiagnostics(expected);

            var comp3 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });
            comp3.VerifyDiagnostics(expected);

            var comp4 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesFalse(), references: new[] { comp1.ToMetadataReference() });
            comp4.VerifyDiagnostics();

            var comp5 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesFalse(), references: new[] { comp1.EmitToImageReference() });
            comp5.VerifyDiagnostics();

            var comp6 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesFalse());
            comp6.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (7,55): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     void F4<T41, T42>() where T41 : class where T42 : T41?, IB, IC?;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T41?").WithLocation(7, 55),
                // (9,55): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     void F6<T61, T62>() where T61 : class where T62 : T61?, IB?, IC;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T61?").WithLocation(9, 55)
                );

            var comp7 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp6.ToMetadataReference() });
            comp7.VerifyDiagnostics(expected);

            var comp9 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesFalse(), references: new[] { comp6.ToMetadataReference() });
            comp9.VerifyDiagnostics();
        }

        [Fact]
        public void Constraints_37()
        {
            var source =
@"
public interface IA
{
    void F1<T1>() where T1 : class, IB, IC;
    void F2<T2>() where T2 : class, IB, IC;
    void F3<T3>() where T3 : class, IB, IC;
    void F4<T41, T42>() where T41 : class where T42 : T41, IB, IC;
    void F5<T51, T52>() where T51 : class where T52 : T51, IB, IC;
    void F6<T61, T62>() where T61 : class where T62 : T61, IB, IC;
    void F7<T71, T72>() where T71 : class where T72 : T71, IB, IC;
    void F8<T81, T82>() where T81 : class where T82 : T81, IB, IC;
    void F9<T91, T92>() where T91 : class where T92 : T91, IB, IC;
}

public interface IB
{}

public interface IC
{}

class B : IA
{
    public void F1<T11>() where T11 : class?, IB, IC? 
    {
    }

    public void F2<T22>() where T22 : class, IB?, IC?
    {
    }

    public void F3<T33>() where T33 : class?, IB?, IC
    {
    }

    public void F4<T441, T442>() where T441 : class where T442 : T441?, IB, IC?
    {
    }

    public void F5<T551, T552>() where T551 : class where T552 : T551, IB?, IC?
    {
    }

    public void F6<T661, T662>() where T661 : class where T662 : T661?, IB?, IC
    {
    }

    public void F7<T771, T772>() where T771 : class? where T772 : T771, IB, IC?
    {
    }

    public void F8<T881, T882>() where T881 : class where T882 : T881, IB?, IC?
    {
    }

    public void F9<T991, T992>() where T991 : class? where T992 : T991, IB?, IC
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (55,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : class? where T992 : T991, IB?, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(55, 17),
                // (47,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : class? where T772 : T771, IB, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(47, 17)
            );
        }

        [Fact]
        public void Constraints_38()
        {
            var source =
@"
public interface IA
{
    void F1<T1>() where T1 : ID?, IB, IC?;
    void F2<T2>() where T2 : ID, IB?, IC?;
    void F3<T3>() where T3 : ID?, IB?, IC;
    void F4<T41, T42>() where T41 : ID where T42 : T41?, IB, IC?;
    void F5<T51, T52>() where T51 : ID where T52 : T51, IB?, IC?;
    void F6<T61, T62>() where T61 : ID where T62 : T61?, IB?, IC;
    void F7<T71, T72>() where T71 : ID? where T72 : T71, IB, IC?;
    void F8<T81, T82>() where T81 : ID where T82 : T81, IB?, IC?;
    void F9<T91, T92>() where T91 : ID? where T92 : T91, IB?, IC;
}

public interface IB
{}

public interface IC
{}

public interface ID
{}

class B : IA
{
    public void F1<T11>() where T11 : ID, IB, IC 
    {
    }

    public void F2<T22>() where T22 : ID, IB, IC
    {
    }

    public void F3<T33>() where T33 : ID, IB, IC
    {
    }

    public void F4<T441, T442>() where T441 : ID where T442 : T441, IB, IC
    {
    }

    public void F5<T551, T552>() where T551 : ID where T552 : T551, IB, IC
    {
    }

    public void F6<T661, T662>() where T661 : ID where T662 : T661, IB, IC
    {
    }

    public void F7<T771, T772>() where T771 : ID where T772 : T771, IB, IC
    {
    }

    public void F8<T881, T882>() where T881 : ID where T882 : T881, IB, IC
    {
    }

    public void F9<T991, T992>() where T991 : ID where T992 : T991, IB, IC
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (7,52): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     void F4<T41, T42>() where T41 : ID where T42 : T41?, IB, IC?;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T41?").WithLocation(7, 52),
                // (9,52): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     void F6<T61, T62>() where T61 : ID where T62 : T61?, IB?, IC;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T61?").WithLocation(9, 52),
                // (58,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : ID where T992 : T991, IB, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(58, 17),
                // (50,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : ID where T772 : T771, IB, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(50, 17)
            );
        }

        [Fact]
        public void Constraints_39()
        {
            var source =
@"
public interface IA
{
    void F1<T1>() where T1 : ID, IB, IC;
    void F2<T2>() where T2 : ID, IB, IC;
    void F3<T3>() where T3 : ID, IB, IC;
    void F4<T41, T42>() where T41 : ID where T42 : T41, IB, IC;
    void F5<T51, T52>() where T51 : ID where T52 : T51, IB, IC;
    void F6<T61, T62>() where T61 : ID where T62 : T61, IB, IC;
    void F7<T71, T72>() where T71 : ID where T72 : T71, IB, IC;
    void F8<T81, T82>() where T81 : ID where T82 : T81, IB, IC;
    void F9<T91, T92>() where T91 : ID where T92 : T91, IB, IC;
}

public interface IB
{}

public interface IC
{}

public interface ID
{}

class B : IA
{
    public void F1<T11>() where T11 : ID?, IB, IC? 
    {
    }

    public void F2<T22>() where T22 : ID, IB?, IC?
    {
    }

    public void F3<T33>() where T33 : ID?, IB?, IC
    {
    }

    public void F4<T441, T442>() where T441 : ID where T442 : T441?, IB, IC?
    {
    }

    public void F5<T551, T552>() where T551 : ID where T552 : T551, IB?, IC?
    {
    }

    public void F6<T661, T662>() where T661 : ID where T662 : T661?, IB?, IC
    {
    }

    public void F7<T771, T772>() where T771 : ID? where T772 : T771, IB, IC?
    {
    }

    public void F8<T881, T882>() where T881 : ID where T882 : T881, IB?, IC?
    {
    }

    public void F9<T991, T992>() where T991 : ID? where T992 : T991, IB?, IC
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (38,63): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F4<T441, T442>() where T441 : ID where T442 : T441?, IB, IC?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T441?").WithLocation(38, 63),
                // (46,63): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F6<T661, T662>() where T661 : ID where T662 : T661?, IB?, IC
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T661?").WithLocation(46, 63),
                // (58,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : ID? where T992 : T991, IB?, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(58, 17),
                // (50,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : ID? where T772 : T771, IB, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(50, 17)
            );
        }

        [Fact]
        public void Constraints_40()
        {
            var source =
@"
public interface IA
{
    void F1<T1>() where T1 : D?, IB, IC?;
    void F2<T2>() where T2 : D, IB?, IC?;
    void F3<T3>() where T3 : D?, IB?, IC;
    void F4<T41, T42>() where T41 : D where T42 : T41?, IB, IC?;
    void F5<T51, T52>() where T51 : D where T52 : T51, IB?, IC?;
    void F6<T61, T62>() where T61 : D where T62 : T61?, IB?, IC;
    void F7<T71, T72>() where T71 : D? where T72 : T71, IB, IC?;
    void F8<T81, T82>() where T81 : D where T82 : T81, IB?, IC?;
    void F9<T91, T92>() where T91 : D? where T92 : T91, IB?, IC;
}

public interface IB
{}

public interface IC
{}

public class D
{}

class B : IA
{
    public void F1<T11>() where T11 : D, IB, IC 
    {
    }

    public void F2<T22>() where T22 : D, IB, IC
    {
    }

    public void F3<T33>() where T33 : D, IB, IC
    {
    }

    public void F4<T441, T442>() where T441 : D where T442 : T441, IB, IC
    {
    }

    public void F5<T551, T552>() where T551 : D where T552 : T551, IB, IC
    {
    }

    public void F6<T661, T662>() where T661 : D where T662 : T661, IB, IC
    {
    }

    public void F7<T771, T772>() where T771 : D where T772 : T771, IB, IC
    {
    }

    public void F8<T881, T882>() where T881 : D where T882 : T881, IB, IC
    {
    }

    public void F9<T991, T992>() where T991 : D where T992 : T991, IB, IC
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (58,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : D where T992 : T991, IB, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(58, 17),
                // (50,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : D where T772 : T771, IB, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(50, 17)
            );
        }

        [Fact]
        public void Constraints_41()
        {
            var source =
@"
public interface IA
{
    void F1<T1>() where T1 : D, IB, IC;
    void F2<T2>() where T2 : D, IB, IC;
    void F3<T3>() where T3 : D, IB, IC;
    void F4<T41, T42>() where T41 : D where T42 : T41, IB, IC;
    void F5<T51, T52>() where T51 : D where T52 : T51, IB, IC;
    void F6<T61, T62>() where T61 : D where T62 : T61, IB, IC;
    void F7<T71, T72>() where T71 : D where T72 : T71, IB, IC;
    void F8<T81, T82>() where T81 : D where T82 : T81, IB, IC;
    void F9<T91, T92>() where T91 : D where T92 : T91, IB, IC;
}

public interface IB
{}

public interface IC
{}

public class D
{}

class B : IA
{
    public void F1<T11>() where T11 : D?, IB, IC? 
    {
    }

    public void F2<T22>() where T22 : D, IB?, IC?
    {
    }

    public void F3<T33>() where T33 : D?, IB?, IC
    {
    }

    public void F4<T441, T442>() where T441 : D where T442 : T441?, IB, IC?
    {
    }

    public void F5<T551, T552>() where T551 : D where T552 : T551, IB?, IC?
    {
    }

    public void F6<T661, T662>() where T661 : D where T662 : T661?, IB?, IC
    {
    }

    public void F7<T771, T772>() where T771 : D? where T772 : T771, IB, IC?
    {
    }

    public void F8<T881, T882>() where T881 : D where T882 : T881, IB?, IC?
    {
    }

    public void F9<T991, T992>() where T991 : D? where T992 : T991, IB?, IC
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (58,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : D? where T992 : T991, IB?, IC
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(58, 17),
                // (50,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : D? where T772 : T771, IB, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(50, 17)
            );
        }

        [Fact]
        public void Constraints_42()
        {
            var source =
@"
public interface IA
{
    void F1<T1>() where T1 : class?, IB?, IC?;
    void F2<T2>() where T2 : class?, IB?, IC?;
    void F3<T3>() where T3 : class?, IB?, IC?;
    void F4<T41, T42>() where T41 : class? where T42 : T41, IB?, IC?;
    void F5<T51, T52>() where T51 : class? where T52 : T51, IB?, IC?;
    void F6<T61, T62>() where T61 : class? where T62 : T61, IB?, IC?;
    void F7<T71, T72>() where T71 : class where T72 : T71?, IB?, IC?;
    void F8<T81, T82>() where T81 : class where T82 : T81?, IB?, IC?;
    void F9<T91, T92>() where T91 : class where T92 : T91?, IB?, IC?;
}

public interface IB
{}

public interface IC
{}

class B : IA
{
    public void F1<T11>() where T11 : class?, IB?, IC? 
    {
    }

    public void F2<T22>() where T22 : class?, IB?, IC?
    {
    }

    public void F3<T33>() where T33 : class?, IB?, IC?
    {
    }

    public void F4<T441, T442>() where T441 : class where T442 : T441?, IB?, IC?
    {
    }

    public void F5<T551, T552>() where T551 : class where T552 : T551?, IB?, IC?
    {
    }

    public void F6<T661, T662>() where T661 : class where T662 : T661?, IB?, IC?
    {
    }

    public void F7<T771, T772>() where T771 : class? where T772 : T771, IB?, IC?
    {
    }

    public void F8<T881, T882>() where T881 : class? where T882 : T881, IB?, IC?
    {
    }

    public void F9<T991, T992>() where T991 : class? where T992 : T991, IB?, IC?
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (55,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : class? where T992 : T991, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(55, 17),
                // (35,17): warning CS8633: Nullability in constraints for type parameter 'T441' of method 'B.F4<T441, T442>()' doesn't match the constraints for type parameter 'T41' of interface method 'IA.F4<T41, T42>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T441, T442>() where T441 : class where T442 : T441?, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T441", "B.F4<T441, T442>()", "T41", "IA.F4<T41, T42>()").WithLocation(35, 17),
                // (39,17): warning CS8633: Nullability in constraints for type parameter 'T551' of method 'B.F5<T551, T552>()' doesn't match the constraints for type parameter 'T51' of interface method 'IA.F5<T51, T52>()'. Consider using an explicit interface implementation instead.
                //     public void F5<T551, T552>() where T551 : class where T552 : T551?, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F5").WithArguments("T551", "B.F5<T551, T552>()", "T51", "IA.F5<T51, T52>()").WithLocation(39, 17),
                // (43,17): warning CS8633: Nullability in constraints for type parameter 'T661' of method 'B.F6<T661, T662>()' doesn't match the constraints for type parameter 'T61' of interface method 'IA.F6<T61, T62>()'. Consider using an explicit interface implementation instead.
                //     public void F6<T661, T662>() where T661 : class where T662 : T661?, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F6").WithArguments("T661", "B.F6<T661, T662>()", "T61", "IA.F6<T61, T62>()").WithLocation(43, 17),
                // (47,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : class? where T772 : T771, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(47, 17),
                // (51,17): warning CS8633: Nullability in constraints for type parameter 'T881' of method 'B.F8<T881, T882>()' doesn't match the constraints for type parameter 'T81' of interface method 'IA.F8<T81, T82>()'. Consider using an explicit interface implementation instead.
                //     public void F8<T881, T882>() where T881 : class? where T882 : T881, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F8").WithArguments("T881", "B.F8<T881, T882>()", "T81", "IA.F8<T81, T82>()").WithLocation(51, 17)
            );
        }

        [Fact]
        public void Constraints_43()
        {
            var source =
@"
public interface IA
{
    void F7<T71, T72>() where T71 : class where T72 : T71?, IB?, IC?;
    void F8<T81, T82>() where T81 : class where T82 : T81?, IB?, IC?;
    void F9<T91, T92>() where T91 : class where T92 : T91?, IB?, IC?;
}

public interface IB
{}

public interface IC
{}

class B : IA
{
    public void F7<T771, T772>() where T771 : class? where T772 : T771?, IB?, IC?
    {
    }

    public void F8<T881, T882>() where T881 : class? where T882 : T881?, IB?, IC?
    {
    }

    public void F9<T991, T992>() where T991 : class? where T992 : T991?, IB?, IC?
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (25,67): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F9<T991, T992>() where T991 : class? where T992 : T991?, IB?, IC?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T991?").WithLocation(25, 67),
                // (21,67): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F8<T881, T882>() where T881 : class? where T882 : T881?, IB?, IC?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T881?").WithLocation(21, 67),
                // (17,67): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public void F7<T771, T772>() where T771 : class? where T772 : T771?, IB?, IC?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T771?").WithLocation(17, 67),
                // (25,17): warning CS8633: Nullability in constraints for type parameter 'T991' of method 'B.F9<T991, T992>()' doesn't match the constraints for type parameter 'T91' of interface method 'IA.F9<T91, T92>()'. Consider using an explicit interface implementation instead.
                //     public void F9<T991, T992>() where T991 : class? where T992 : T991?, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F9").WithArguments("T991", "B.F9<T991, T992>()", "T91", "IA.F9<T91, T92>()").WithLocation(25, 17),
                // (21,17): warning CS8633: Nullability in constraints for type parameter 'T881' of method 'B.F8<T881, T882>()' doesn't match the constraints for type parameter 'T81' of interface method 'IA.F8<T81, T82>()'. Consider using an explicit interface implementation instead.
                //     public void F8<T881, T882>() where T881 : class? where T882 : T881?, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F8").WithArguments("T881", "B.F8<T881, T882>()", "T81", "IA.F8<T81, T82>()").WithLocation(21, 17),
                // (17,17): warning CS8633: Nullability in constraints for type parameter 'T771' of method 'B.F7<T771, T772>()' doesn't match the constraints for type parameter 'T71' of interface method 'IA.F7<T71, T72>()'. Consider using an explicit interface implementation instead.
                //     public void F7<T771, T772>() where T771 : class? where T772 : T771?, IB?, IC?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F7").WithArguments("T771", "B.F7<T771, T772>()", "T71", "IA.F7<T71, T72>()").WithLocation(17, 17)
            );
        }

        [Fact]
        public void Constraints_44()
        {
            var source1 =
@"
public interface IA
{
    void F1<T1>() where T1 : class?, IB?;
    void F2<T2>() where T2 : class, IB?;
    void F3<T3>() where T3 : C1, IB?;
    void F4<T4>() where T4 : C1?, IB?;
}

public class C1
{}

public interface IB
{}
";
            var source2 =
@"
class B : IA
{
    public void F1<T11>() where T11 : class, IB?
    {
    }

    public void F2<T22>() where T22 : class?, IB?
    {
    }

    public void F3<T33>() where T33 : C1?, IB?
    {
    }

    public void F4<T44>() where T44 : C1, IB?
    {
    }
}

class D : IA
{
    public void F1<T111>() where T111 : class?, IB?
    {
    }

    public void F2<T222>() where T222 : class, IB?
    {
    }

    public void F3<T333>() where T333 : C1, IB?
    {
    }

    public void F4<T444>() where T444 : C1?, IB?
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source2, source1 }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T11' of method 'B.F1<T11>()' doesn't match the constraints for type parameter 'T1' of interface method 'IA.F1<T1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<T11>() where T11 : class, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("T11", "B.F1<T11>()", "T1", "IA.F1<T1>()").WithLocation(4, 17),
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA.F2<T2>()").WithLocation(8, 17),
                // (12,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA.F3<T3>()").WithLocation(12, 17),
                // (16,17): warning CS8633: Nullability in constraints for type parameter 'T44' of method 'B.F4<T44>()' doesn't match the constraints for type parameter 'T4' of interface method 'IA.F4<T4>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T44>() where T44 : C1, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T44", "B.F4<T44>()", "T4", "IA.F4<T4>()").WithLocation(16, 17)
            );

            CompileAndVerify(comp1, sourceSymbolValidator: symbolValidator1, symbolValidator: symbolValidator1);
            void symbolValidator1(ModuleSymbol m)
            {
                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.True(t11.IsNotNullableIfReferenceType);

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.False(t22.IsNotNullableIfReferenceType);

                var bf3 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F3");
                TypeParameterSymbol t33 = bf3.TypeParameters[0];
                Assert.False(t33.IsNotNullableIfReferenceType);

                var bf4 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F4");
                TypeParameterSymbol t44 = bf4.TypeParameters[0];
                Assert.True(t44.IsNotNullableIfReferenceType);
            }

            var comp2 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());
            comp2.VerifyDiagnostics(
            );

            var comp3 = CreateCompilation(new[] { source2 }, references: new[] { comp2.ToMetadataReference() });
            comp3.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA.F2<T2>()").WithLocation(8, 17),
                // (12,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA.F3<T3>()").WithLocation(12, 17)
            );

            symbolValidator2(comp3.SourceModule);

            void symbolValidator2(ModuleSymbol m)
            {
                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                TypeParameterSymbol t11 = bf1.TypeParameters[0];
                Assert.Null(t11.IsNotNullableIfReferenceType);

                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                TypeParameterSymbol t22 = bf2.TypeParameters[0];
                Assert.False(t22.IsNotNullableIfReferenceType);

                var bf3 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F3");
                TypeParameterSymbol t33 = bf3.TypeParameters[0];
                Assert.False(t33.IsNotNullableIfReferenceType);

                var bf4 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F4");
                TypeParameterSymbol t44 = bf4.TypeParameters[0];
                Assert.Null(t44.IsNotNullableIfReferenceType);
            }

            var comp4 = CreateCompilation(new[] { source1 });

            var comp5 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp4.ToMetadataReference() });
            comp5.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T11' of method 'B.F1<T11>()' doesn't match the constraints for type parameter 'T1' of interface method 'IA.F1<T1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<T11>() where T11 : class, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("T11", "B.F1<T11>()", "T1", "IA.F1<T1>()").WithLocation(4, 17),
                // (16,17): warning CS8633: Nullability in constraints for type parameter 'T44' of method 'B.F4<T44>()' doesn't match the constraints for type parameter 'T4' of interface method 'IA.F4<T4>()'. Consider using an explicit interface implementation instead.
                //     public void F4<T44>() where T44 : C1, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F4").WithArguments("T44", "B.F4<T44>()", "T4", "IA.F4<T4>()").WithLocation(16, 17)
            );

            symbolValidator1(comp5.SourceModule);

            var comp6 = CreateCompilation(new[] { source2 }, references: new[] { comp4.ToMetadataReference() });
            comp6.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
            );

            symbolValidator2(comp6.SourceModule);
        }

        [Fact]
        public void Constraints_45()
        {
            var source1 =
@"
public interface IA
{
    void F2<T2>() where T2 : class?, IB;
    void F3<T3>() where T3 : C1?, IB;
}

public class C1
{}

public interface IB
{}
";
            var source2 =
@"
class B : IA
{
    public void F2<T22>() where T22 : class?, IB?
    {
    }

    public void F3<T33>() where T33 : C1?, IB?
    {
    }
}

class D : IA
{
    public void F2<T222>() where T222 : class?, IB
    {
    }

    public void F3<T333>() where T333 : C1?, IB
    {
    }
}
";
            var comp1 = CreateCompilation(new[] { source2, source1 }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA.F2<T2>()").WithLocation(4, 17),
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA.F3<T3>()").WithLocation(8, 17)
            );

            CompileAndVerify(comp1, sourceSymbolValidator: symbolValidator1, symbolValidator: symbolValidator1);
            void symbolValidator1(ModuleSymbol m)
            {
                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("D.F2");
                TypeParameterSymbol t222 = bf2.TypeParameters[0];
                Assert.True(t222.IsNotNullableIfReferenceType);

                var bf3 = (MethodSymbol)m.GlobalNamespace.GetMember("D.F3");
                TypeParameterSymbol t333 = bf3.TypeParameters[0];
                Assert.True(t333.IsNotNullableIfReferenceType);
            }

            var comp2 = CreateCompilation(new[] { source1 }, options: WithNonNullTypesTrue());
            comp2.VerifyDiagnostics(
            );

            var comp3 = CreateCompilation(new[] { source2 }, references: new[] { comp2.ToMetadataReference() });
            comp3.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (4,17): warning CS8633: Nullability in constraints for type parameter 'T22' of method 'B.F2<T22>()' doesn't match the constraints for type parameter 'T2' of interface method 'IA.F2<T2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<T22>() where T22 : class?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("T22", "B.F2<T22>()", "T2", "IA.F2<T2>()").WithLocation(4, 17),
                // (8,17): warning CS8633: Nullability in constraints for type parameter 'T33' of method 'B.F3<T33>()' doesn't match the constraints for type parameter 'T3' of interface method 'IA.F3<T3>()'. Consider using an explicit interface implementation instead.
                //     public void F3<T33>() where T33 : C1?, IB?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F3").WithArguments("T33", "B.F3<T33>()", "T3", "IA.F3<T3>()").WithLocation(8, 17)
            );

            symbolValidator2(comp3.SourceModule);

            void symbolValidator2(ModuleSymbol m)
            {
                var bf2 = (MethodSymbol)m.GlobalNamespace.GetMember("D.F2");
                TypeParameterSymbol t222 = bf2.TypeParameters[0];
                Assert.Null(t222.IsNotNullableIfReferenceType);

                var bf3 = (MethodSymbol)m.GlobalNamespace.GetMember("D.F3");
                TypeParameterSymbol t333 = bf3.TypeParameters[0];
                Assert.Null(t333.IsNotNullableIfReferenceType);
            }

            var comp4 = CreateCompilation(new[] { source1 });

            var comp5 = CreateCompilation(new[] { source2 }, options: WithNonNullTypesTrue(), references: new[] { comp4.ToMetadataReference() });
            comp5.VerifyDiagnostics(
            );

            symbolValidator1(comp5.SourceModule);

            var comp6 = CreateCompilation(new[] { source2 }, references: new[] { comp4.ToMetadataReference() });
            comp6.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
            );

            symbolValidator2(comp6.SourceModule);
        }

        [Fact]
        public void Constraints_46()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : object
    {
    }

    public static void F2<T2>() where T2 : System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T1>() where T1 : System.Object", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = f1.TypeParameters[0];
                Assert.False(t1.IsReferenceType);
                Assert.True(t1.IsNotNullableIfReferenceType);
                Assert.Empty(t1.GetAttributes());

                var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T2>() where T2 : System.Object", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.False(t2.IsReferenceType);
                Assert.True(t2.IsNotNullableIfReferenceType);
                Assert.Empty(t2.GetAttributes());
            }
        }

        [Fact]
        public void Constraints_47()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : object
    {
    }

    public static void F2<T2>() where T2 : System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T1>() where T1 : System.Object", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = f1.TypeParameters[0];
                Assert.False(t1.IsReferenceType);
                Assert.Null(t1.IsNotNullableIfReferenceType);
                Assert.Empty(t1.GetAttributes());

                var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T2>() where T2 : System.Object", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.False(t2.IsReferenceType);
                Assert.Null(t2.IsNotNullableIfReferenceType);
                Assert.Empty(t2.GetAttributes());
            }
        }

        [Fact]
        public void Constraints_48()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : object?
    {
    }

    public static void F2<T2>(T2? t2) where T2 : System.Object?
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T1>(T1? t1) where T1 : object?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(4, 31),
                // (4,50): error CS0702: Constraint cannot be special class 'object?'
                //     public static void F1<T1>(T1? t1) where T1 : object?
                Diagnostic(ErrorCode.ERR_SpecialTypeAsBound, "object?").WithArguments("object?").WithLocation(4, 50),
                // (8,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T2>(T2? t2) where T2 : System.Object?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(8, 31),
                // (8,50): error CS0702: Constraint cannot be special class 'object?'
                //     public static void F2<T2>(T2? t2) where T2 : System.Object?
                Diagnostic(ErrorCode.ERR_SpecialTypeAsBound, "System.Object?").WithArguments("object?").WithLocation(8, 50)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1)", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.False(t1.IsReferenceType);
            Assert.False(t1.IsNotNullableIfReferenceType);
            Assert.Empty(t1.GetAttributes());

            var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
            Assert.Equal("void B.F2<T2>(T2? t2)", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t2 = f2.TypeParameters[0];
            Assert.False(t2.IsReferenceType);
            Assert.False(t2.IsNotNullableIfReferenceType);
            Assert.Empty(t2.GetAttributes());
        }

        [Fact]
        public void Constraints_49()
        {
            var source =
@"
class B
{
    public static void F1<T1>() where T1 : object
    {
    }

    public static void F2<T2>() where T2 : System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7_3);
            var expected = new[]
            {
                // (4,44): error CS8652: The feature 'object generic type constraint' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //     public static void F1<T1>() where T1 : object
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "object").WithArguments("object generic type constraint").WithLocation(4, 44),
                // (8,44): error CS8652: The feature 'object generic type constraint' is currently in Preview and *unsupported*. To use Preview features, use the 'preview' language version.
                //     public static void F2<T2>() where T2 : System.Object
                Diagnostic(ErrorCode.ERR_FeatureInPreview, "System.Object").WithArguments("object generic type constraint").WithLocation(8, 44)
            };

            comp.VerifyDiagnostics(expected);

            {
                var m = comp.SourceModule;

                var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T1>() where T1 : System.Object", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = f1.TypeParameters[0];
                Assert.False(t1.IsReferenceType);
                Assert.Null(t1.IsNotNullableIfReferenceType);
                Assert.Empty(t1.GetAttributes());

                var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T2>() where T2 : System.Object", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.False(t2.IsReferenceType);
                Assert.Null(t2.IsNotNullableIfReferenceType);
                Assert.Empty(t2.GetAttributes());
            }

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), parseOptions: TestOptions.Regular7_3, skipUsesIsNullable: true);

            comp.VerifyDiagnostics(expected
            .Concat(new[] {
                // error CS8630: Invalid 'NullableContextOptions' value: 'Enable' for C# 7.3. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("NullableContextOptions", "Enable", "7.3", "8.0").WithLocation(1, 1),
            }).ToArray()
            );

            {
                var m = comp.SourceModule;

                var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
                Assert.Equal("void B.F1<T1>() where T1 : System.Object", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t1 = f1.TypeParameters[0];
                Assert.False(t1.IsReferenceType);
                Assert.True(t1.IsNotNullableIfReferenceType);
                Assert.Empty(t1.GetAttributes());

                var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
                Assert.Equal("void B.F2<T2>() where T2 : System.Object", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol t2 = f2.TypeParameters[0];
                Assert.False(t2.IsReferenceType);
                Assert.True(t2.IsNotNullableIfReferenceType);
                Assert.Empty(t2.GetAttributes());
            }
        }

        [Fact]
        public void Constraints_50()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : object
    {
    }

    public static void F2<T2>(T2? t2) where T2 : System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T1>(T1? t1) where T1 : object
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(4, 31),
                // (8,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T2>(T2? t2) where T2 : System.Object
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(8, 31)
            );
        }

        [Fact]
        public void Constraints_51()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : struct, object
    {
    }

    public static void F2<T2>(T2? t2) where T2 : struct, System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,58): error CS0450: 'object': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F2<T2>(T2? t2) where T2 : struct, System.Object
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "System.Object").WithArguments("object").WithLocation(8, 58),
                // (4,58): error CS0450: 'object': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F1<T1>(T1? t1) where T1 : struct, object
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "object").WithArguments("object").WithLocation(4, 58)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : struct", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsValueType);
            Assert.False(t1.IsNotNullableIfReferenceType);
            Assert.Empty(t1.GetAttributes());

            var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
            Assert.Equal("void B.F2<T2>(T2? t2) where T2 : struct", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t2 = f2.TypeParameters[0];
            Assert.True(t2.IsValueType);
            Assert.False(t2.IsNotNullableIfReferenceType);
            Assert.Empty(t2.GetAttributes());
        }

        [Fact]
        public void Constraints_52()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : class, object
    {
    }

    public static void F2<T2>(T2? t2) where T2 : class, System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,57): error CS0450: 'object': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F1<T1>(T1? t1) where T1 : class, object
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "object").WithArguments("object").WithLocation(4, 57),
                // (8,57): error CS0450: 'object': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F2<T2>(T2? t2) where T2 : class, System.Object
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "System.Object").WithArguments("object").WithLocation(8, 57)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : class", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsReferenceType);
            Assert.True(t1.IsNotNullableIfReferenceType);
            Assert.Empty(t1.GetAttributes());

            var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
            Assert.Equal("void B.F2<T2>(T2? t2) where T2 : class", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t2 = f2.TypeParameters[0];
            Assert.True(t2.IsReferenceType);
            Assert.True(t2.IsNotNullableIfReferenceType);
            Assert.Empty(t2.GetAttributes());
        }

        [Fact]
        public void Constraints_53()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : class?, object
    {
    }

    public static void F2<T2>(T2? t2) where T2 : class?, System.Object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            Assert.False(((MethodSymbol)comp.SourceModule.GlobalNamespace.GetMember("B.F1")).TypeParameters[0].IsNotNullableIfReferenceType);

            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T1>(T1? t1) where T1 : class?, object
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(4, 31),
                // (4,58): error CS0450: 'object': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F1<T1>(T1? t1) where T1 : class?, object
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "object").WithArguments("object").WithLocation(4, 58),
                // (8,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F2<T2>(T2? t2) where T2 : class?, System.Object
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(8, 31),
                // (8,58): error CS0450: 'object': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F2<T2>(T2? t2) where T2 : class?, System.Object
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "System.Object").WithArguments("object").WithLocation(8, 58)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : class?", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsReferenceType);
            Assert.False(t1.IsNotNullableIfReferenceType);
            Assert.Empty(t1.GetAttributes());

            var f2 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F2");
            Assert.Equal("void B.F2<T2>(T2? t2) where T2 : class?", f2.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t2 = f2.TypeParameters[0];
            Assert.True(t2.IsReferenceType);
            Assert.False(t2.IsNotNullableIfReferenceType);
            Assert.Empty(t2.GetAttributes());
        }

        [Fact]
        public void Constraints_54()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : class?, B
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T1>(T1? t1) where T1 : class?, B
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(4, 31),
                // (4,58): error CS0450: 'B': cannot specify both a constraint class and the 'class' or 'struct' constraint
                //     public static void F1<T1>(T1? t1) where T1 : class?, B
                Diagnostic(ErrorCode.ERR_RefValBoundWithClass, "B").WithArguments("B").WithLocation(4, 58)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : class?", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsReferenceType);
            Assert.False(t1.IsNotNullableIfReferenceType);
        }

        [Fact]
        public void Constraints_55()
        {
            var source =
@"
interface I<TI> 
{
    void F1<TF1>(TF1 x) where TF1 : TI;
}

class A : I<object>
{
    void I<object>.F1<TF1A>(TF1A x)
    {}
}

class B : I<object?>
{
    void I<object?>.F1<TF1B>(TF1B x)
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var af1 = (MethodSymbol)m.GlobalNamespace.GetMember("A.I<System.Object>.F1");
                Assert.Equal("I<System.Object>.F1", af1.Name);
                Assert.Equal("I<System.Object>.F1", af1.MetadataName);
                Assert.Equal("void A.I<System.Object>.F1<TF1A>(TF1A x) where TF1A : System.Object", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol at1 = af1.TypeParameters[0];
                Assert.False(at1.IsReferenceType);
                Assert.True(at1.IsNotNullableIfReferenceType);
                Assert.Empty(at1.GetAttributes());

                Assert.Equal("void I<System.Object>.F1<TF1>(TF1 x) where TF1 : System.Object", af1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.I<System.Object>.F1");
                Assert.Equal("I<System.Object>.F1", bf1.Name);
                Assert.Equal("I<System.Object>.F1", bf1.MetadataName);
                if (isSource)
                {
                    Assert.Equal("void B.I<System.Object?>.F1<TF1B>(TF1B x)", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void B.I<System.Object>.F1<TF1B>(TF1B x)", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                TypeParameterSymbol tf1 = bf1.TypeParameters[0];
                Assert.False(tf1.IsReferenceType);
                Assert.False(tf1.IsNotNullableIfReferenceType);
                Assert.Empty(tf1.GetAttributes());
                if (isSource)
                {
                    Assert.Equal("void I<System.Object?>.F1<TF1>(TF1 x)", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void I<System.Object>.F1<TF1>(TF1 x) where TF1 : System.Object", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
            }
        }

        [Fact]
        public void Constraints_56()
        {
            var source =
@"
interface I<TI> 
{
    void F1<TF1>(TF1 x) where TF1 : TI;
}

class A : I<A>
{
    void I<A>.F1<TF1A>(TF1A x)
    {}
}

class B : I<A?>
{
    void I<A?>.F1<TF1B>(TF1B x)
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var af1 = (MethodSymbol)m.GlobalNamespace.GetMember("A.I<A>.F1");
                Assert.Equal("I<A>.F1", af1.Name);
                Assert.Equal("I<A>.F1", af1.MetadataName);
                Assert.Equal("void A.I<A>.F1<TF1A>(TF1A x) where TF1A : A", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol at1 = af1.TypeParameters[0];
                Assert.True(at1.IsReferenceType);
                Assert.True(at1.IsNotNullableIfReferenceType);
                Assert.Empty(at1.GetAttributes());

                Assert.Equal("void I<A>.F1<TF1>(TF1 x) where TF1 : A", af1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.I<A>.F1");
                Assert.Equal("I<A>.F1", bf1.Name);
                Assert.Equal("I<A>.F1", bf1.MetadataName);
                if (isSource)
                {
                    Assert.Equal("void B.I<A?>.F1<TF1B>(TF1B x) where TF1B : A?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void B.I<A>.F1<TF1B>(TF1B x) where TF1B : A?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                TypeParameterSymbol tf1 = bf1.TypeParameters[0];
                Assert.True(tf1.IsReferenceType);
                Assert.False(tf1.IsNotNullableIfReferenceType);
                Assert.Empty(tf1.GetAttributes());
                if (isSource)
                {
                    Assert.Equal("void I<A?>.F1<TF1>(TF1 x) where TF1 : A?", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void I<A>.F1<TF1>(TF1 x) where TF1 : A", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
            }
        }

        [Fact]
        public void Constraints_57()
        {
            var source =
@"
interface I<TI> 
{
    void F1<TF1>(TF1 x) where TF1 : class?, TI;
}

class A : I<object>
{
    void I<object>.F1<TF1A>(TF1A x)
    {}
}

class B : I<object?>
{
    void I<object?>.F1<TF1B>(TF1B x)
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var af1 = (MethodSymbol)m.GlobalNamespace.GetMember("A.I<System.Object>.F1");
                Assert.Equal("I<System.Object>.F1", af1.Name);
                Assert.Equal("I<System.Object>.F1", af1.MetadataName);
                Assert.Equal("void A.I<System.Object>.F1<TF1A>(TF1A x) where TF1A : class?, System.Object", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol at1 = af1.TypeParameters[0];
                Assert.True(at1.IsReferenceType);
                Assert.True(at1.IsNotNullableIfReferenceType);

                Assert.Equal("void I<System.Object>.F1<TF1>(TF1 x) where TF1 : class?, System.Object", af1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.I<System.Object>.F1");
                Assert.Equal("I<System.Object>.F1", bf1.Name);
                Assert.Equal("I<System.Object>.F1", bf1.MetadataName);
                if (isSource)
                {
                    Assert.Equal("void B.I<System.Object?>.F1<TF1B>(TF1B x) where TF1B : class?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void B.I<System.Object>.F1<TF1B>(TF1B x) where TF1B : class?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                TypeParameterSymbol tf1 = bf1.TypeParameters[0];
                Assert.True(tf1.IsReferenceType);
                Assert.False(tf1.IsNotNullableIfReferenceType);
                if (isSource)
                {
                    Assert.Equal("void I<System.Object?>.F1<TF1>(TF1 x) where TF1 : class?", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void I<System.Object>.F1<TF1>(TF1 x) where TF1 : class?, System.Object", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
            }
        }

        [Fact]
        public void Constraints_58()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : B, object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,53): error CS0406: The class type constraint 'object' must come before any other constraints
                //     public static void F1<T1>(T1? t1) where T1 : B, object
                Diagnostic(ErrorCode.ERR_ClassBoundNotFirst, "object").WithArguments("object").WithLocation(4, 53)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : B", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsReferenceType);
            Assert.True(t1.IsNotNullableIfReferenceType);
        }

        [Fact]
        public void Constraints_59()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : B?, object
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T1>(T1? t1) where T1 : B?, object
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(4, 31),
                // (4,54): error CS0406: The class type constraint 'object' must come before any other constraints
                //     public static void F1<T1>(T1? t1) where T1 : B?, object
                Diagnostic(ErrorCode.ERR_ClassBoundNotFirst, "object").WithArguments("object").WithLocation(4, 54)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : B?", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsReferenceType);
            Assert.False(t1.IsNotNullableIfReferenceType);
        }

        [Fact]
        public void Constraints_60()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : object, B
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,31): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static void F1<T1>(T1? t1) where T1 : object, B
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(4, 31),
                // (4,58): error CS0406: The class type constraint 'B' must come before any other constraints
                //     public static void F1<T1>(T1? t1) where T1 : object, B
                Diagnostic(ErrorCode.ERR_ClassBoundNotFirst, "B").WithArguments("B").WithLocation(4, 58)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : System.Object", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.False(t1.IsReferenceType);
            Assert.True(t1.IsNotNullableIfReferenceType);
        }

        [Fact]
        public void Constraints_61()
        {
            var source =
@"
class B
{
    public static void F1<T1>(T1? t1) where T1 : object?, B
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,50): error CS0702: Constraint cannot be special class 'object?'
                //     public static void F1<T1>(T1? t1) where T1 : object?, B
                Diagnostic(ErrorCode.ERR_SpecialTypeAsBound, "object?").WithArguments("object?").WithLocation(4, 50)
            );

            var m = comp.SourceModule;

            var f1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.F1");
            Assert.Equal("void B.F1<T1>(T1? t1) where T1 : B", f1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
            TypeParameterSymbol t1 = f1.TypeParameters[0];
            Assert.True(t1.IsReferenceType);
            Assert.True(t1.IsNotNullableIfReferenceType);
        }

        [Fact]
        public void Constraints_62()
        {
            var source =
@"
interface I<TI> 
{
    void F1<TF1>(TF1 x) where TF1 : B?, TI;
}

class A : I<object>
{
    void I<object>.F1<TF1A>(TF1A x)
    {}
}

class B : I<object?>
{
    void I<object?>.F1<TF1B>(TF1B x)
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var af1 = (MethodSymbol)m.GlobalNamespace.GetMember("A.I<System.Object>.F1");
                Assert.Equal("I<System.Object>.F1", af1.Name);
                Assert.Equal("I<System.Object>.F1", af1.MetadataName);
                Assert.Equal("void A.I<System.Object>.F1<TF1A>(TF1A x) where TF1A : B?, System.Object", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol at1 = af1.TypeParameters[0];
                Assert.True(at1.IsReferenceType);
                Assert.True(at1.IsNotNullableIfReferenceType);

                Assert.Equal("void I<System.Object>.F1<TF1>(TF1 x) where TF1 : B?, System.Object", af1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.I<System.Object>.F1");
                Assert.Equal("I<System.Object>.F1", bf1.Name);
                Assert.Equal("I<System.Object>.F1", bf1.MetadataName);
                if (isSource)
                {
                    Assert.Equal("void B.I<System.Object?>.F1<TF1B>(TF1B x) where TF1B : B?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void B.I<System.Object>.F1<TF1B>(TF1B x) where TF1B : B?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                TypeParameterSymbol tf1 = bf1.TypeParameters[0];
                Assert.True(tf1.IsReferenceType);
                Assert.False(tf1.IsNotNullableIfReferenceType);
                if (isSource)
                {
                    Assert.Equal("void I<System.Object?>.F1<TF1>(TF1 x) where TF1 : B?", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void I<System.Object>.F1<TF1>(TF1 x) where TF1 : B?, System.Object", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
            }
        }

        [Fact]
        public void Constraints_63()
        {
            var source =
@"
interface I<TI1, TI2> 
{
    void F1<TF1>(TF1 x) where TF1 : TI1, TI2;
}

class A : I<object, B?>
{
    void I<object, B?>.F1<TF1A>(TF1A x)
    {}
}

class B : I<object?, B?>
{
    void I<object?, B?>.F1<TF1B>(TF1B x)
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
            );

            CompileAndVerify(comp, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                bool isSource = !(m is PEModuleSymbol);

                var af1 = (MethodSymbol)m.GlobalNamespace.GetMember("A.I<System.Object,B>.F1");
                Assert.Equal("I<System.Object,B>.F1", af1.Name);
                Assert.Equal("I<System.Object,B>.F1", af1.MetadataName);
                if (isSource)
                {
                    Assert.Equal("void A.I<System.Object, B?>.F1<TF1A>(TF1A x) where TF1A : System.Object, B?", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void A.I<System.Object, B>.F1<TF1A>(TF1A x) where TF1A : System.Object, B?", af1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                TypeParameterSymbol at1 = af1.TypeParameters[0];
                Assert.True(at1.IsReferenceType);
                Assert.True(at1.IsNotNullableIfReferenceType);

                if (isSource)
                {
                    Assert.Equal("void I<System.Object, B?>.F1<TF1>(TF1 x) where TF1 : System.Object, B?", af1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void I<System.Object, B>.F1<TF1>(TF1 x) where TF1 : System.Object, B", af1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                var bf1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.I<System.Object,B>.F1");
                Assert.Equal("I<System.Object,B>.F1", bf1.Name);
                Assert.Equal("I<System.Object,B>.F1", bf1.MetadataName);
                if (isSource)
                {
                    Assert.Equal("void B.I<System.Object?, B?>.F1<TF1B>(TF1B x) where TF1B : B?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void B.I<System.Object, B>.F1<TF1B>(TF1B x) where TF1B : B?", bf1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }

                TypeParameterSymbol tf1 = bf1.TypeParameters[0];
                Assert.True(tf1.IsReferenceType);
                Assert.False(tf1.IsNotNullableIfReferenceType);
                if (isSource)
                {
                    Assert.Equal("void I<System.Object?, B?>.F1<TF1>(TF1 x) where TF1 : B?", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
                else
                {
                    Assert.Equal("void I<System.Object, B>.F1<TF1>(TF1 x) where TF1 : System.Object, B", bf1.ExplicitInterfaceImplementations.Single().ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                }
            }
        }

        [Fact]
        public void Constraints_64()
        {
            var source =
@"
interface I1
{
    void F1<TF1>();
    void F2<TF2>() where TF2 : object;
    void F3<TF3>() where TF3 : object;
    void F4<TF4>() where TF4 : I3;
    void F5<TF5>() where TF5 : I3;
    void F6<TF6>() where TF6 : I3?;
    void F7<TF7>() where TF7 : object, I3;
    void F8<TF8>() where TF8 : object, I3;
    void F9<TF9>() where TF9 : object, I3;
    void F10<TF10>() where TF10 : object, I3?;
    void F11<TF11>() where TF11 : object, I3?;
    void F12<TF12>() where TF12 : object, I3?;
    void F13<TF13>() where TF13 : object, I3?;
}

public interface I3
{
}

class A : I1
{
    public void F1<TF1A>() where TF1A : object
    {}
    public void F2<TF2A>()
    {}
    public void F3<TF3A>() where TF3A : object
    {}
    public void F4<TF4A>() where TF4A : object, I3
    {}
    public void F5<TF5A>() where TF5A : object, I3?
    {}
    public void F6<TF6A>() where TF6A : object, I3?
    {}
    public void F7<TF7A>() where TF7A : I3
    {}
    public void F8<TF8A>() where TF8A : I3?
    {}
    public void F9<TF9A>() where TF9A : object, I3
    {}
    public void F10<TF10A>() where TF10A : I3
    {}
    public void F11<TF11A>() where TF11A : I3?
    {}
    public void F12<TF12A>() where TF12A : object, I3
    {}
    public void F13<TF13A>() where TF13A : object, I3?
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (25,17): warning CS8633: Nullability in constraints for type parameter 'TF1A' of method 'A.F1<TF1A>()' doesn't match the constraints for type parameter 'TF1' of interface method 'I1.F1<TF1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<TF1A>() where TF1A : object
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("TF1A", "A.F1<TF1A>()", "TF1", "I1.F1<TF1>()").WithLocation(25, 17),
                // (27,17): warning CS8633: Nullability in constraints for type parameter 'TF2A' of method 'A.F2<TF2A>()' doesn't match the constraints for type parameter 'TF2' of interface method 'I1.F2<TF2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<TF2A>()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("TF2A", "A.F2<TF2A>()", "TF2", "I1.F2<TF2>()").WithLocation(27, 17),
                // (35,17): warning CS8633: Nullability in constraints for type parameter 'TF6A' of method 'A.F6<TF6A>()' doesn't match the constraints for type parameter 'TF6' of interface method 'I1.F6<TF6>()'. Consider using an explicit interface implementation instead.
                //     public void F6<TF6A>() where TF6A : object, I3?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F6").WithArguments("TF6A", "A.F6<TF6A>()", "TF6", "I1.F6<TF6>()").WithLocation(35, 17),
                // (39,17): warning CS8633: Nullability in constraints for type parameter 'TF8A' of method 'A.F8<TF8A>()' doesn't match the constraints for type parameter 'TF8' of interface method 'I1.F8<TF8>()'. Consider using an explicit interface implementation instead.
                //     public void F8<TF8A>() where TF8A : I3?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F8").WithArguments("TF8A", "A.F8<TF8A>()", "TF8", "I1.F8<TF8>()").WithLocation(39, 17),
                // (45,17): warning CS8633: Nullability in constraints for type parameter 'TF11A' of method 'A.F11<TF11A>()' doesn't match the constraints for type parameter 'TF11' of interface method 'I1.F11<TF11>()'. Consider using an explicit interface implementation instead.
                //     public void F11<TF11A>() where TF11A : I3?
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F11").WithArguments("TF11A", "A.F11<TF11A>()", "TF11", "I1.F11<TF11>()").WithLocation(45, 17)
            );
        }

        [Fact]
        public void Constraints_65()
        {
            var source =
@"
" + NonNullTypesOff() + @"
interface I1
{
    void F1<TF1>();
    void F2<TF2>() where TF2 : object;
    void F3<TF3>() where TF3 : object;
    void F4<TF4>() where TF4 : I3;
    void F5<TF5>() where TF5 : I3;
    void F7<TF7>() where TF7 : object, I3;
    void F8<TF8>() where TF8 : object, I3;
    void F9<TF9>() where TF9 : object, I3;
}
" + NonNullTypesOn() + @"
public interface I3
{
}
" + NonNullTypesOn() + @"
class A : I1
{
    public void F1<TF1A>() where TF1A : object
    {}
    public void F2<TF2A>()
    {}
    public void F3<TF3A>() where TF3A : object
    {}
    public void F4<TF4A>() where TF4A : object, I3
    {}
    public void F5<TF5A>() where TF5A : object, I3?
    {}
    public void F7<TF7A>() where TF7A : I3
    {}
    public void F8<TF8A>() where TF8A : I3?
    {}
    public void F9<TF9A>() where TF9A : object, I3
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29980: unexpected warning
            comp.VerifyDiagnostics(
                // (21,17): warning CS8633: Nullability in constraints for type parameter 'TF1A' of method 'A.F1<TF1A>()' doesn't match the constraints for type parameter 'TF1' of interface method 'I1.F1<TF1>()'. Consider using an explicit interface implementation instead.
                //     public void F1<TF1A>() where TF1A : object
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F1").WithArguments("TF1A", "A.F1<TF1A>()", "TF1", "I1.F1<TF1>()").WithLocation(21, 17)
                );
        }

        [Fact]
        public void Constraints_66()
        {
            var source =
@"
interface I1
{
    void F1<TF1>();
    void F2<TF2>() where TF2 : object;
    void F3<TF3>() where TF3 : object;
    void F4<TF4>() where TF4 : I3;
    void F7<TF7>() where TF7 : object, I3;
    void F9<TF9>() where TF9 : object, I3;
    void F10<TF10>() where TF10 : object, I3?;
    void F12<TF12>() where TF12 : object, I3?;
}

public interface I3
{
}

" + NonNullTypesOff() + @"
class A : I1
{
    public void F1<TF1A>() where TF1A : object
    {}
    public void F2<TF2A>()
    {}
    public void F3<TF3A>() where TF3A : object
    {}
    public void F4<TF4A>() where TF4A : object, I3
    {}
    public void F7<TF7A>() where TF7A : I3
    {}
    public void F9<TF9A>() where TF9A : object, I3
    {}
    public void F10<TF10A>() where TF10A : I3
    {}
    public void F12<TF12A>() where TF12A : object, I3
    {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29980: unexpected warning
            comp.VerifyDiagnostics(
                // (23,17): warning CS8633: Nullability in constraints for type parameter 'TF2A' of method 'A.F2<TF2A>()' doesn't match the constraints for type parameter 'TF2' of interface method 'I1.F2<TF2>()'. Consider using an explicit interface implementation instead.
                //     public void F2<TF2A>()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInConstraintsOnImplicitImplementation, "F2").WithArguments("TF2A", "A.F2<TF2A>()", "TF2", "I1.F2<TF2>()").WithLocation(23, 17)
                );
        }

        [Fact]
        public void Constraints_67()
        {
            var source =
@"
class A
{
    public void F1<TF1>(object x1, TF1 y1, TF1 z1 ) where TF1 : object
    {
        y1.ToString();
        x1 = z1;
    }

    public void F2<TF2>(object x2, TF2 y2, TF2 z2 ) where TF2 : class
    {
        y2.ToString();
        x2 = z2;
    }

    public void F3<TF3>(object x3, TF3 y3, TF3 z3 ) where TF3 : class?
    {
        y3.ToString();
        x3 = z3;
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         y3.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y3").WithLocation(18, 9),
                // (19,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x3 = z3;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "z3").WithLocation(19, 14)
                );
        }

        [Fact]
        public void UnconstrainedTypeParameter_Local()
        {
            var source =
@"
#pragma warning disable CS0168
class B
{
    public static void F1<T1>()
    {
        T1? x;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp.VerifyDiagnostics(
                // (7,9): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         T1? x;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(7, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_01()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : ID<string>
{
}

public interface IB : IA<ID<string?>> // 1
{}

public interface IC : IA<ID<string>?> // 2
{}

public interface IE : IA<ID<string>>
{}

public interface ID<T>
{}

class B
{
    public void Test1()
    {
        IA<ID<string?>> x1; // 3
        IA<ID<string>?> y1; // 4
        IA<ID<string>> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: ID<string>
    {}

    public void Test2(ID<string?> a2, ID<string> b2, ID<string>? c2)
    {
        M1(a2); // 5
        M1(b2); 
        M1(c2); // 6
        M1<ID<string?>>(a2); // 7
        M1<ID<string?>>(b2); // 8
        M1<ID<string>?>(b2); // 9
        M1<ID<string>>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (24,12): warning CS8631: The type 'ID<string?>' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'ID<string?>' doesn't match constraint type 'ID<string>'.
                //         IA<ID<string?>> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "ID<string?>").WithArguments("IA<TA>", "ID<string>", "TA", "ID<string?>").WithLocation(24, 12),
                // (25,12): warning CS8631: The type 'ID<string>?' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'ID<string>?' doesn't match constraint type 'ID<string>'.
                //         IA<ID<string>?> y1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "ID<string>?").WithArguments("IA<TA>", "ID<string>", "TA", "ID<string>?").WithLocation(25, 12),
                // (34,9): warning CS8631: The type 'ID<string?>' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'ID<string?>' doesn't match constraint type 'ID<string>'.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B.M1<TM1>(TM1)", "ID<string>", "TM1", "ID<string?>").WithLocation(34, 9),
                // (36,9): warning CS8631: The type 'ID<string>?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'ID<string>?' doesn't match constraint type 'ID<string>'.
                //         M1(c2); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B.M1<TM1>(TM1)", "ID<string>", "TM1", "ID<string>?").WithLocation(36, 9),
                // (37,9): warning CS8631: The type 'ID<string?>' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'ID<string?>' doesn't match constraint type 'ID<string>'.
                //         M1<ID<string?>>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<ID<string?>>").WithArguments("B.M1<TM1>(TM1)", "ID<string>", "TM1", "ID<string?>").WithLocation(37, 9),
                // (38,9): warning CS8631: The type 'ID<string?>' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'ID<string?>' doesn't match constraint type 'ID<string>'.
                //         M1<ID<string?>>(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<ID<string?>>").WithArguments("B.M1<TM1>(TM1)", "ID<string>", "TM1", "ID<string?>").WithLocation(38, 9),
                // (38,25): warning CS8620: Nullability of reference types in argument of type 'ID<string>' doesn't match target type 'ID<string?>' for parameter 'x' in 'void B.M1<ID<string?>>(ID<string?> x)'.
                //         M1<ID<string?>>(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "b2").WithArguments("ID<string>", "ID<string?>", "x", "void B.M1<ID<string?>>(ID<string?> x)").WithLocation(38, 25),
                // (39,9): warning CS8631: The type 'ID<string>?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'ID<string>?' doesn't match constraint type 'ID<string>'.
                //         M1<ID<string>?>(b2); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<ID<string>?>").WithArguments("B.M1<TM1>(TM1)", "ID<string>", "TM1", "ID<string>?").WithLocation(39, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_02()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class
{
}

public interface IB : IA<string?> // 1
{}

public interface IC : IA<string>
{}

class B
{
    public void Test1()
    {
        IA<string?> x1; // 2
        IA<string> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: class
    {}

    public void Test2(string? a2, string b2)
    {
        M1(a2); // 3
        M1(b2); 
        M1<string?>(a2); // 4
        M1<string?>(b2); // 5
        M1<string>(b2);
    }
    
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (18,12): warning CS8634: The type 'string?' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         IA<string?> x1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("IA<TA>", "TA", "string?").WithLocation(18, 12),
                // (27,9): warning CS8634: The type 'string?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         M1(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B.M1<TM1>(TM1)", "TM1", "string?").WithLocation(27, 9),
                // (29,9): warning CS8634: The type 'string?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         M1<string?>(a2); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<string?>").WithArguments("B.M1<TM1>(TM1)", "TM1", "string?").WithLocation(29, 9),
                // (30,9): warning CS8634: The type 'string?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         M1<string?>(b2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<string?>").WithArguments("B.M1<TM1>(TM1)", "TM1", "string?").WithLocation(30, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_03()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : ID<string>?
{
}

public interface IC : IA<ID<string>?> 
{}

public interface IE : IA<ID<string>> 
{}

public interface ID<T>
{}

class B
{
    public void Test1()
    {
        IA<ID<string>?> y1;
        IA<ID<string>> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: ID<string>?
    {}

    public void Test2(ID<string> b2, ID<string>? c2)
    {
        M1(b2); 
        M1(c2);
        M1<ID<string>?>(c2);
        M1<ID<string>>(b2);
    }
    
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
            );
        }

        [Fact]
        public void ConstraintsChecks_04()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class?
{
}

public interface IB : IA<string?>
{}

public interface IC : IA<string>
{}

class B
{
    public void Test1()
    {
        IA<string?> x1;
        IA<string> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: class?
    {}

    public void Test2(string? a2, string b2)
    {
        M1(a2);
        M1(b2); 
        M1<string?>(a2);
        M1<string>(b2);
    }
    
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
            );
        }

        [Fact]
        public void ConstraintsChecks_05()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : ID<string>
{
}

public interface IB<TIB> : IA<TIB> where TIB : ID<string?> // 1
{}

public interface IC<TIC> : IA<TIC> where TIC : ID<string>? // 2
{}

public interface IE<TIE> : IA<TIE> where TIE : ID<string>
{}

public interface ID<T>
{}

class B<TB1, TB2, TB3> where TB1 : ID<string?> where TB2 : ID<string>? where TB3 : ID<string>
{
    public void Test1()
    {
        IA<TB1> x1; // 3
        IA<TB2> y1; // 4
        IA<TB3> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: ID<string>
    {}

    public void Test2(TB1 a2, TB3 b2, TB2 c2)
    {
        M1(a2); // 5
        M1(b2); 
        M1(c2); // 6
        M1<TB1>(a2); // 7
        M1<TB2>(c2); // 8
        M1<TB3>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (24,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         IA<TB1> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "ID<string>", "TA", "TB1").WithLocation(24, 12),
                // (25,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         IA<TB2> y1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB2").WithArguments("IA<TA>", "ID<string>", "TA", "TB2").WithLocation(25, 12),
                // (34,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(34, 9),
                // (36,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1(c2); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(36, 9),
                // (37,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1<TB1>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(37, 9),
                // (38,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1<TB2>(c2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB2>").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(38, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_06()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class
{
}

public interface IB<TIB> : IA<TIB> where TIB : C? // 1
{}

public interface IC<TIC> : IA<TIC> where TIC : C
{}

public class C
{}

class B<TB1, TB2> where TB1 : C? where TB2 : C
{
    public void Test1()
    {
        IA<TB1> x1; // 2
        IA<TB2> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: class
    {}

    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 3
        M1(b2); 
        M1<TB1>(a2); // 4
        M1<TB2>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (21,12): warning CS8634: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         IA<TB1> x1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB1").WithArguments("IA<TA>", "TA", "TB1").WithLocation(21, 12),
                // (30,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(30, 9),
                // (32,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1<TB1>(a2); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(32, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_07()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : ID<string>?
{
}

public interface IC<TIC> : IA<TIC> where TIC : ID<string>?
{}

public interface IE<TIE> : IA<TIE> where TIE : ID<string>
{}

public interface ID<T>
{}

class B<TB2, TB3> where TB2 : ID<string>? where TB3 : ID<string>
{
    public void Test1()
    {
        IA<TB2> y1;
        IA<TB3> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: ID<string>?
    {}

    public void Test2(TB3 b2, TB2 c2)
    {
        M1(b2); 
        M1(c2);
        M1<TB2>(c2);
        M1<TB3>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics();
        }

        [Fact]
        public void ConstraintsChecks_08()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class?
{
}

public interface IB<TIB> : IA<TIB> where TIB : C?
{}

public interface IC<TIC> : IA<TIC> where TIC : C
{}

public class C
{}

class B<TB1, TB2> where TB1 : C? where TB2 : C
{
    public void Test1()
    {
        IA<TB1> x1;
        IA<TB2> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: class?
    {}

    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2);
        M1(b2); 
        M1<TB1>(a2);
        M1<TB2>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics();
        }

        [Fact]
        public void ConstraintsChecks_09()
        {
            var source =
@"
#pragma warning disable CS0168
" + NonNullTypesOff() + @"
public interface IA<TA> where TA : ID<string>
{
}
" + NonNullTypesOn() + @"
public interface IC : IA<ID<string>?>
{}

public interface IE : IA<ID<string>>
{}

public interface ID<T>
{}

class B
{
    public void Test1()
    {
        IA<ID<string>?> y1;
        IA<ID<string>> z1;
    }
" + NonNullTypesOff() + @"
    public void M1<TM1>(TM1 x) where TM1: ID<string>
    {}
" + NonNullTypesOn() + @"
    public void Test2(ID<string> b2, ID<string>? c2)
    {
        M1(b2);
        M1(c2);
        M1<ID<string>?>(c2);
        M1<ID<string>>(b2);
    }

}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
            );
        }

        [Fact]
        public void ConstraintsChecks_10()
        {
            var source =
@"
#pragma warning disable CS0168
" + NonNullTypesOff() + @"
public interface IA<TA> where TA : class
{
}
" + NonNullTypesOn() + @"
public interface IB : IA<string?>
{}

public interface IC : IA<string>
{}

class B
{
    public void Test1()
    {
        IA<string?> x1;
        IA<string> z1;
    }
" + NonNullTypesOff() + @"
    public void M1<TM1>(TM1 x) where TM1: class
    {}
" + NonNullTypesOn() + @"
    public void Test2(string? a2, string b2)
    {
        M1(a2);
        M1(b2);
        M1<string?>(a2);
        M1<string?>(b2);
        M1<string>(b2);
    }

}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            CompileAndVerify(comp1, sourceSymbolValidator: symbolValidator, symbolValidator: symbolValidator);
            void symbolValidator(ModuleSymbol m)
            {
                var m1 = (MethodSymbol)m.GlobalNamespace.GetMember("B.M1");
                Assert.Equal("void B.M1<TM1>(TM1 x) where TM1 : class", m1.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));
                TypeParameterSymbol tm1 = m1.TypeParameters[0];
                Assert.Null(tm1.ReferenceTypeConstraintIsNullable);
                Assert.Empty(tm1.GetAttributes());
            }
        }

        [Fact]
        public void ConstraintsChecks_11()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : ID<string>
{
}
" + NonNullTypesOff() + @"
public interface IB<TIB> : IA<TIB> where TIB : ID<string?> // 1
{}
" + NonNullTypesOff() + @"
public interface IC<TIC> : IA<TIC> where TIC : ID<string>? // 2
{}
" + NonNullTypesOff() + @"
public interface IE<TIE> : IA<TIE> where TIE : ID<string> // 3
{}
" + NonNullTypesOn() + @"
public interface ID<T>
{}
" + NonNullTypesOff() + @"
class B<TB1, TB2, TB3> where TB1 : ID<string?> where TB2 : ID<string>? where TB3 : ID<string> {
" + NonNullTypesOn() + @"
    public void Test1()
    {
        IA<TB1> x1; // 4
        IA<TB2> y1; // 5
        IA<TB3> z1; // 6
    }
" + NonNullTypesOn() + @"
    public void M1<TM1>(TM1 x) where TM1: ID<string>
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB3 b2, TB2 c2)
    {
        M1(a2); // 7
        M1(b2); // 8
        M1(c2); // 9
        M1<TB1>(a2); // 10
        M1<TB2>(c2); // 11
        M1<TB3>(b2); // 12
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (24,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         IA<TB1> x1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "ID<string>", "TA", "TB1").WithLocation(24, 12),
                // (25,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         IA<TB2> y1; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB2").WithArguments("IA<TA>", "ID<string>", "TA", "TB2").WithLocation(25, 12),
                // (26,12): warning CS8631: The type 'TB3' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB3' doesn't match constraint type 'ID<string>'.
                //         IA<TB3> z1; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB3").WithArguments("IA<TA>", "ID<string>", "TA", "TB3").WithLocation(26, 12),
                // (34,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(34, 9),
                // (35,9): warning CS8631: The type 'TB3' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB3' doesn't match constraint type 'ID<string>'.
                //         M1(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB3").WithLocation(35, 9),
                // (36,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1(c2); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(36, 9),
                // (37,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1<TB1>(a2); // 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(37, 9),
                // (38,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1<TB2>(c2); // 11
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB2>").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(38, 9),
                // (39,9): warning CS8631: The type 'TB3' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3>.M1<TM1>(TM1)'. Nullability of type argument 'TB3' doesn't match constraint type 'ID<string>'.
                //         M1<TB3>(b2); // 12
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB3>").WithArguments("B<TB1, TB2, TB3>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB3").WithLocation(39, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_12()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class
{
}
" + NonNullTypesOff() + @"
public interface IB<TIB> : IA<TIB> where TIB : C? // 1
{}
" + NonNullTypesOff() + @"
public interface IC<TIC> : IA<TIC> where TIC : C // 2
{}
" + NonNullTypesOn() + @"
public class C
{}
" + NonNullTypesOff() + @"
class B<TB1, TB2> where TB1 : C? where TB2 : C {
" + NonNullTypesOn() + @"
    public void Test1()
    {
        IA<TB1> x1; // 3
        IA<TB2> z1; // 4
    }
" + NonNullTypesOn() + @"
    public void M1<TM1>(TM1 x) where TM1: class
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 5
        M1(b2); // 6
        M1<TB1>(a2); // 7
        M1<TB2>(b2); // 8
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (21,12): warning CS8634: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         IA<TB1> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB1").WithArguments("IA<TA>", "TA", "TB1").WithLocation(21, 12),
                // (22,12): warning CS8634: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match 'class' constraint.
                //         IA<TB2> z1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB2").WithArguments("IA<TA>", "TA", "TB2").WithLocation(22, 12),
                // (30,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(30, 9),
                // (31,9): warning CS8634: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match 'class' constraint.
                //         M1(b2); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB2").WithLocation(31, 9),
                // (32,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1<TB1>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(32, 9),
                // (33,9): warning CS8634: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match 'class' constraint.
                //         M1<TB2>(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB2>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB2").WithLocation(33, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_13()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class
{
}

public interface IB<TIB> : IA<TIB> where TIB : class? // 1
{}

public interface IC<TIC> : IA<TIC> where TIC : class
{}

class B<TB1, TB2> where TB1 : class? where TB2 : class
{
    public void Test1()
    {
        IA<TB1> x1; // 2
        IA<TB2> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: class
    {}

    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 3
        M1(b2); 
        M1<TB1>(a2); // 4
        M1<TB2>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (18,12): warning CS8634: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         IA<TB1> x1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB1").WithArguments("IA<TA>", "TA", "TB1").WithLocation(18, 12),
                // (27,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(27, 9),
                // (29,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1<TB1>(a2); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(29, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_14()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class?
{
}

public interface IB<TIB> : IA<TIB> where TIB : class?
{}

public interface IC<TIC> : IA<TIC> where TIC : class
{}

class B<TB1, TB2> where TB1 : class? where TB2 : class
{
    public void Test1()
    {
        IA<TB1> x1;
        IA<TB2> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: class?
    {}

    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2);
        M1(b2); 
        M1<TB1>(a2);
        M1<TB2>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics();
        }

        [Fact]
        public void ConstraintsChecks_15()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class
{
}
" + NonNullTypesOff() + @"
public interface IB<TIB> : IA<TIB> where TIB : class? // 1
{}
" + NonNullTypesOff() + @"
public interface IC<TIC> : IA<TIC> where TIC : class // 2
{}
" + NonNullTypesOff() + @"
class B<TB1, TB2> where TB1 : class? where TB2 : class {
" + NonNullTypesOn() + @"
    public void Test1()
    {
        IA<TB1> x1; // 3
        IA<TB2> z1; // 4
    }
" + NonNullTypesOn() + @"
    public void M1<TM1>(TM1 x) where TM1: class
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 5
        M1(b2); // 6
        M1<TB1>(a2); // 7
        M1<TB2>(b2); // 8
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (18,12): warning CS8634: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         IA<TB1> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB1").WithArguments("IA<TA>", "TA", "TB1").WithLocation(18, 12),
                // (19,12): warning CS8634: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match 'class' constraint.
                //         IA<TB2> z1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB2").WithArguments("IA<TA>", "TA", "TB2").WithLocation(19, 12),
                // (27,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(27, 9),
                // (28,9): warning CS8634: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match 'class' constraint.
                //         M1(b2); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB2").WithLocation(28, 9),
                // (29,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1<TB1>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(29, 9),
                // (30,9): warning CS8634: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match 'class' constraint.
                //         M1<TB2>(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB2>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "TM1", "TB2").WithLocation(30, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_16()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : IE?, ID<string>, IF?
{
}

public interface IB<TIB> : IA<TIB> where TIB : IE?, ID<string?>, IF? // 1
{}

public interface IC<TIC> : IA<TIC> where TIC : IE?, ID<string>?, IF? // 2
{}

public interface IE<TIE> : IA<TIE> where TIE : IE?, ID<string>, IF?
{}

public interface ID<T>
{}

class B<TB1, TB2, TB3, TB4> 
    where TB1 : IE?, ID<string?>, IF? 
    where TB2 : IE?, ID<string>?, IF? 
    where TB3 : IE?, ID<string>, IF?
    where TB4 : IE, ID<string>?, IF?
{
    public void Test1()
    {
        IA<TB1> x1; // 3
        IA<TB2> y1; // 4
        IA<TB3> z1;
        IA<TB4> u1;
    }

    public void M1<TM1>(TM1 x) where TM1: IE?, ID<string>, IF?
    {}

    public void Test2(TB1 a2, TB3 b2, TB2 c2, TB4 d2)
    {
        M1(a2); // 5
        M1(b2); 
        M1(c2); // 6
        M1(d2);
        M1<TB1>(a2); // 7
        M1<TB2>(c2); // 8
        M1<TB3>(b2);
        M1<TB4>(d2);
    }
}

public interface IE
{}
public interface IF
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (28,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         IA<TB1> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "ID<string>", "TA", "TB1").WithLocation(28, 12),
                // (29,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         IA<TB2> y1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB2").WithArguments("IA<TA>", "ID<string>", "TA", "TB2").WithLocation(29, 12),
                // (39,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(39, 9),
                // (41,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1(c2); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(41, 9),
                // (43,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1<TB1>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(43, 9),
                // (44,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1<TB2>(c2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB2>").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(44, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_17()
        {
            var source =
@"
#pragma warning disable CS0168
" + NonNullTypesOff() + @"
public interface IA<TA> where TA : IE?, ID<string>, IF?
{
}
" + NonNullTypesOn() + @"
public interface IB<TIB> : IA<TIB> where TIB : IE?, ID<string?>, IF?
{}

public interface IC<TIC> : IA<TIC> where TIC : IE?, ID<string>?, IF?
{}

public interface IE<TIE> : IA<TIE> where TIE : IE?, ID<string>, IF?
{}

public interface ID<T>
{}

class B<TB1, TB2, TB3, TB4>
    where TB1 : IE?, ID<string?>, IF?
    where TB2 : IE?, ID<string>?, IF?
    where TB3 : IE?, ID<string>, IF?
    where TB4 : IE, ID<string>?, IF?
{
    public void Test1()
    {
        IA<TB1> x1;
        IA<TB2> y1;
        IA<TB3> z1;
        IA<TB4> u1;
    }

" + NonNullTypesOff() + @"
    public void M1<TM1>(TM1 x) where TM1: IE?, ID<string>, IF?
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB3 b2, TB2 c2, TB4 d2)
    {
        M1(a2);
        M1(b2);
        M1(c2);
        M1(d2);
        M1<TB1>(a2);
        M1<TB2>(c2);
        M1<TB3>(b2);
        M1<TB4>(d2);
    }
}

public interface IE
{}
public interface IF
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify();
        }

        [Fact]
        public void ConstraintsChecks_18()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : IE?, ID<string>, IF?
{
}

" + NonNullTypesOff() + @"
public interface IB<TIB> : IA<TIB> where TIB : IE?, ID<string?>, IF? // 1
{}

" + NonNullTypesOff() + @"
public interface IC<TIC> : IA<TIC> where TIC : IE?, ID<string>?, IF? // 2
{}

" + NonNullTypesOff() + @"
public interface IE<TIE> : IA<TIE> where TIE : IE?, ID<string>, IF? // 3
{}
" + NonNullTypesOn() + @"
public interface ID<T>
{}

" + NonNullTypesOff() + @"
class B<TB1, TB2, TB3, TB4>
    where TB1 : IE?, ID<string?>, IF?
    where TB2 : IE?, ID<string>?, IF?
    where TB3 : IE?, ID<string>, IF?
    where TB4 : IE, ID<string>?, IF?
{
" + NonNullTypesOn() + @"
    public void Test1()
    {
        IA<TB1> x1; // 4
        IA<TB2> y1; // 5
        IA<TB3> z1; // 6
        IA<TB4> u1; // 7
    }

" + NonNullTypesOn() + @"
    public void M1<TM1>(TM1 x) where TM1: IE?, ID<string>, IF?
    {}

" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB3 b2, TB2 c2, TB4 d2)
    {
        M1(a2); // 8
        M1(b2); // 9
        M1(c2); // 10
        M1(d2); // 11
        M1<TB1>(a2); // 12
        M1<TB2>(c2); // 13
        M1<TB3>(b2); // 14
        M1<TB4>(d2); // 15
    }
}

public interface IE
{}
public interface IF
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (33,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         IA<TB1> x1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "ID<string>", "TA", "TB1").WithLocation(33, 12),
                // (34,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         IA<TB2> y1; // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB2").WithArguments("IA<TA>", "ID<string>", "TA", "TB2").WithLocation(34, 12),
                // (35,12): warning CS8631: The type 'TB3' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB3' doesn't match constraint type 'ID<string>'.
                //         IA<TB3> z1; // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB3").WithArguments("IA<TA>", "ID<string>", "TA", "TB3").WithLocation(35, 12),
                // (36,12): warning CS8631: The type 'TB4' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB4' doesn't match constraint type 'ID<string>'.
                //         IA<TB4> u1; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB4").WithArguments("IA<TA>", "ID<string>", "TA", "TB4").WithLocation(36, 12),
                // (46,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1(a2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(46, 9),
                // (47,9): warning CS8631: The type 'TB3' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB3' doesn't match constraint type 'ID<string>'.
                //         M1(b2); // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB3").WithLocation(47, 9),
                // (48,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1(c2); // 10
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(48, 9),
                // (49,9): warning CS8631: The type 'TB4' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB4' doesn't match constraint type 'ID<string>'.
                //         M1(d2); // 11
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB4").WithLocation(49, 9),
                // (50,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'ID<string>'.
                //         M1<TB1>(a2); // 12
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB1").WithLocation(50, 9),
                // (51,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'ID<string>'.
                //         M1<TB2>(c2); // 13
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB2>").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB2").WithLocation(51, 9),
                // (52,9): warning CS8631: The type 'TB3' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB3' doesn't match constraint type 'ID<string>'.
                //         M1<TB3>(b2); // 14
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB3>").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB3").WithLocation(52, 9),
                // (53,9): warning CS8631: The type 'TB4' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)'. Nullability of type argument 'TB4' doesn't match constraint type 'ID<string>'.
                //         M1<TB4>(d2); // 15
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB4>").WithArguments("B<TB1, TB2, TB3, TB4>.M1<TM1>(TM1)", "ID<string>", "TM1", "TB4").WithLocation(53, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_19()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : class, IB, IC
{
}

class B<TB1> where TB1 : class?, IB?, IC? 
{
    public void Test1()
    {
        IA<TB1> x1; // 1
    }

    public void M1<TM1>(TM1 x) where TM1: class, IB, IC
    {}

    public void Test2(TB1 a2)
    {
        M1(a2); // 2
        M1<TB1>(a2); // 3
    }
}

public interface IB
{}

public interface IC
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (12,12): warning CS8634: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         IA<TB1> x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "TB1").WithArguments("IA<TA>", "TA", "TB1").WithLocation(12, 12),
                // (12,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'IB'.
                //         IA<TB1> x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "IB", "TA", "TB1").WithLocation(12, 12),
                // (12,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'IC'.
                //         IA<TB1> x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "IC", "TA", "TB1").WithLocation(12, 12),
                // (20,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1(a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("B<TB1>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(20, 9),
                // (20,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IB'.
                //         M1(a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1>(TM1)", "IB", "TM1", "TB1").WithLocation(20, 9),
                // (20,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IC'.
                //         M1(a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1>(TM1)", "IC", "TM1", "TB1").WithLocation(20, 9),
                // (21,9): warning CS8634: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match 'class' constraint.
                //         M1<TB1>(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<TB1>").WithArguments("B<TB1>.M1<TM1>(TM1)", "TM1", "TB1").WithLocation(21, 9),
                // (21,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IB'.
                //         M1<TB1>(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1>.M1<TM1>(TM1)", "IB", "TM1", "TB1").WithLocation(21, 9),
                // (21,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IC'.
                //         M1<TB1>(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1>.M1<TM1>(TM1)", "IC", "TM1", "TB1").WithLocation(21, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_20()
        {
            var source =
@"
class B<TB1> where TB1 : class, IB? 
{
    public void M1<TM1, TM2>(TM1 x, TM2 y) where TM2 : TM1
    {}

    public void Test2(TB1? a2, TB1 b2)
    {
        M1(b2, a2); // 1
        M1<TB1, TB1?>(b2, a2); // 2
    }
}

public interface IB
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (9,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1(b2, a2); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(9, 9),
                // (10,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1<TB1, TB1?>(b2, a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1, TB1?>").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(10, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_21()
        {
            var source =
@"
class B<TB1> where TB1 : class?, IB 
{
    public void M1<TM1, TM2>(TM1 x, TM2 y) where TM2 : TM1
    {}

    public void Test2(TB1? a2, TB1 b2)
    {
        M1(b2, a2); // 1
        M1<TB1, TB1?>(b2, a2); // 2
    }
}

public interface IB
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (9,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1(b2, a2); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(9, 9),
                // (10,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1<TB1, TB1?>(b2, a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1, TB1?>").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(10, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_22()
        {
            var source =
@"
class B<TB1> where TB1 : class, IB? {
" + NonNullTypesOff() + @"
    public void M1<TM1, TM2>(TM1 x, TM2 y) where TM2 : TM1
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1? a2, TB1 b2)
    {
        M1(b2, a2); // 1
        M1<TB1, TB1?>(b2, a2); // 2
    }
}

public interface IB
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (9,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1(b2, a2); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(9, 9),
                // (10,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1<TB1, TB1?>(b2, a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1, TB1?>").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(10, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_23()
        {
            var source =
@"
class B<TB1> where TB1 : A?, IB, IC? 
{
    public void M1<TM1, TM2>(TM1 x, TM2 y) where TM2 : TM1
    {}

    public void Test2(TB1? a2, TB1 b2)
    {
        M1(b2, a2); // 1
        M1<TB1, TB1?>(b2, a2); // 2
    }
}

public class A
{}

public interface IB
{}

public interface IC
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (9,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1(b2, a2); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(9, 9),
                // (10,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1<TB1, TB1?>(b2, a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1, TB1?>").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(10, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_24()
        {
            var source =
@"
class B<TB1> where TB1 : A?, IB, IC? {
" + NonNullTypesOff() + @"
    public void M1<TM1, TM2>(TM1 x, TM2 y) where TM2 : TM1
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1? a2, TB1 b2)
    {
        M1(b2, a2); // 1
        M1<TB1, TB1?>(b2, a2); // 2
    }
}

public class A
{}

public interface IB
{}

public interface IC
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (9,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1(b2, a2); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(9, 9),
                // (10,9): warning CS8631: The type 'TB1?' cannot be used as type parameter 'TM2' in the generic type or method 'B<TB1>.M1<TM1, TM2>(TM1, TM2)'. Nullability of type argument 'TB1?' doesn't match constraint type 'TB1'.
                //         M1<TB1, TB1?>(b2, a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1, TB1?>").WithArguments("B<TB1>.M1<TM1, TM2>(TM1, TM2)", "TB1", "TM2", "TB1?").WithLocation(10, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_25()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : object
{
}

public interface IB : IA<string?> // 1
{}

public interface IC : IA<string>
{}

class B
{
    public void Test1()
    {
        IA<string?> x1; // 2
        IA<string> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: object
    {}

    public void Test2(string? a2, string b2)
    {
        M1(a2); // 3
        M1(b2); 
        M1<string?>(a2); // 4
        M1<string?>(b2); // 5
        M1<string>(b2);
    }
    
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (18,12): warning CS8631: The type 'string?' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'string?' doesn't match constraint type 'object'.
                //         IA<string?> x1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "string?").WithArguments("IA<TA>", "object", "TA", "string?").WithLocation(18, 12),
                // (27,9): warning CS8631: The type 'string?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'string?' doesn't match constraint type 'object'.
                //         M1(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B.M1<TM1>(TM1)", "object", "TM1", "string?").WithLocation(27, 9),
                // (29,9): warning CS8631: The type 'string?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'string?' doesn't match constraint type 'object'.
                //         M1<string?>(a2); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<string?>").WithArguments("B.M1<TM1>(TM1)", "object", "TM1", "string?").WithLocation(29, 9),
                // (30,9): warning CS8631: The type 'string?' cannot be used as type parameter 'TM1' in the generic type or method 'B.M1<TM1>(TM1)'. Nullability of type argument 'string?' doesn't match constraint type 'object'.
                //         M1<string?>(b2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<string?>").WithArguments("B.M1<TM1>(TM1)", "object", "TM1", "string?").WithLocation(30, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_26()
        {
            var source =
@"
#pragma warning disable CS0168
" + NonNullTypesOff() + @"
public interface IA<TA> where TA : object
{
}
" + NonNullTypesOn() + @"
public interface IB : IA<string?>
{}

public interface IC : IA<string>
{}

class B
{
    public void Test1()
    {
        IA<string?> x1;
        IA<string> z1;
    }
" + NonNullTypesOff() + @"
    public void M1<TM1>(TM1 x) where TM1: object
    {}
" + NonNullTypesOn() + @"
    public void Test2(string? a2, string b2)
    {
        M1(a2);
        M1(b2);
        M1<string?>(a2);
        M1<string?>(b2);
        M1<string>(b2);
    }

}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp1.VerifyDiagnostics(
            );
        }

        [Fact]
        [WorkItem(30214, "https://github.com/dotnet/roslyn/issues/30214")]
        public void ConstraintsChecks_27()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : object
{
}
" + NonNullTypesOff() + @"
public interface IB<TIB> : IA<TIB> where TIB : C? // 1
{}
" + NonNullTypesOff() + @"
public interface IC<TIC> : IA<TIC> where TIC : C // 2
{}

public class C
{}
" + NonNullTypesOff() + @"
class B<TB1, TB2> where TB1 : C? where TB2 : C {
" + NonNullTypesOn() + @"
    public void Test1()
    {
        IA<TB1> x1; // 3
        IA<TB2> z1; // 4
    }
" + NonNullTypesOn() + @"
    public void M1<TM1>(TM1 x) where TM1: object
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 5
        M1(b2); // 6
        M1<TB1>(a2); // 7
        M1<TB2>(b2); // 8
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            // https://github.com/dotnet/roslyn/issues/30214 The following warning is unexpected:
            // (22,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
            //         IA<TB2> z1; // 4
            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (21,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         IA<TB1> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "object", "TA", "TB1").WithLocation(21, 12),
                // (22,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
                //         IA<TB2> z1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB2").WithArguments("IA<TA>", "object", "TA", "TB2").WithLocation(22, 12),
                // (30,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(30, 9),
                // (31,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
                //         M1(b2); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB2").WithLocation(31, 9),
                // (32,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1<TB1>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(32, 9),
                // (33,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
                //         M1<TB2>(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB2>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB2").WithLocation(33, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_28()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : object
{
}

public interface IB<TIB> : IA<TIB> // 1
{}

public interface IC<TIC> : IA<TIC> where TIC : object
{}

class B<TB1, TB2> where TB2 : object
{
    public void Test1()
    {
        IA<TB1> x1; // 2
        IA<TB2> z1;
    }

    public void M1<TM1>(TM1 x) where TM1: object
    {}

    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 3
        M1(b2); 
        M1<TB1>(a2); // 4
        M1<TB2>(b2);
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.VerifyDiagnostics(
                // (18,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         IA<TB1> x1; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "object", "TA", "TB1").WithLocation(18, 12),
                // (27,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(27, 9),
                // (29,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1<TB1>(a2); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(29, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_29()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : object
{
}
" + NonNullTypesOff() + @"
public interface IB<TIB> : IA<TIB> // 1
{}
" + NonNullTypesOff() + @"
public interface IC<TIC> : IA<TIC> where TIC : object // 2
{}
" + NonNullTypesOff() + @"
class B<TB1, TB2> where TB2 : object {
" + NonNullTypesOn() + @"
    public void Test1()
    {
        IA<TB1> x1; // 3
        IA<TB2> z1; // 4
    }
" + NonNullTypesOn() + @"
    public void M1<TM1>(TM1 x) where TM1: object
    {}
" + NonNullTypesOn() + @"
    public void Test2(TB1 a2, TB2 b2)
    {
        M1(a2); // 5
        M1(b2); // 6
        M1<TB1>(a2); // 7
        M1<TB2>(b2); // 8
    }
}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Constraint violations are not reported for type references outside of method bodies.
            comp1.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_MissingNonNullTypesContextForAnnotation).Verify(
                // (18,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         IA<TB1> x1; // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "object", "TA", "TB1").WithLocation(18, 12),
                // (19,12): warning CS8631: The type 'TB2' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
                //         IA<TB2> z1; // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB2").WithArguments("IA<TA>", "object", "TA", "TB2").WithLocation(19, 12),
                // (27,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1(a2); // 5
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(27, 9),
                // (28,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
                //         M1(b2); // 6
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB2").WithLocation(28, 9),
                // (29,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1<TB1>(a2); // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(29, 9),
                // (30,9): warning CS8631: The type 'TB2' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1, TB2>.M1<TM1>(TM1)'. Nullability of type argument 'TB2' doesn't match constraint type 'object'.
                //         M1<TB2>(b2); // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB2>").WithArguments("B<TB1, TB2>.M1<TM1>(TM1)", "object", "TM1", "TB2").WithLocation(30, 9)
            );
        }

        [Fact]
        public void ConstraintsChecks_30()
        {
            var source =
@"
#pragma warning disable CS0168

public interface IA<TA> where TA : object, IB, IC
{
}

class B<TB1> where TB1 : IB?, IC? 
{
    public void Test1()
    {
        IA<TB1> x1; // 1
    }

    public void M1<TM1>(TM1 x) where TM1: object, IB, IC
    {}

    public void Test2(TB1 a2)
    {
        M1(a2); // 2
        M1<TB1>(a2); // 3
    }
}

public interface IB
{}

public interface IC
{}
";
            var comp1 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp1.VerifyDiagnostics(
                // (12,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         IA<TB1> x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "object", "TA", "TB1").WithLocation(12, 12),
                // (12,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'IB'.
                //         IA<TB1> x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "IB", "TA", "TB1").WithLocation(12, 12),
                // (12,12): warning CS8631: The type 'TB1' cannot be used as type parameter 'TA' in the generic type or method 'IA<TA>'. Nullability of type argument 'TB1' doesn't match constraint type 'IC'.
                //         IA<TB1> x1; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "TB1").WithArguments("IA<TA>", "IC", "TA", "TB1").WithLocation(12, 12),
                // (20,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1(a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(20, 9),
                // (20,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IB'.
                //         M1(a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1>(TM1)", "IB", "TM1", "TB1").WithLocation(20, 9),
                // (20,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IC'.
                //         M1(a2); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("B<TB1>.M1<TM1>(TM1)", "IC", "TM1", "TB1").WithLocation(20, 9),
                // (21,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'object'.
                //         M1<TB1>(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1>.M1<TM1>(TM1)", "object", "TM1", "TB1").WithLocation(21, 9),
                // (21,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IB'.
                //         M1<TB1>(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1>.M1<TM1>(TM1)", "IB", "TM1", "TB1").WithLocation(21, 9),
                // (21,9): warning CS8631: The type 'TB1' cannot be used as type parameter 'TM1' in the generic type or method 'B<TB1>.M1<TM1>(TM1)'. Nullability of type argument 'TB1' doesn't match constraint type 'IC'.
                //         M1<TB1>(a2); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<TB1>").WithArguments("B<TB1>.M1<TM1>(TM1)", "IC", "TM1", "TB1").WithLocation(21, 9)
            );
        }

        // https://github.com/dotnet/roslyn/issues/29981: Should report CS8600 for `T1 t = (T1)NullableObject();`
        // and `T3 t = (T3)NullableObject();`. (See VisitConversion which skips reporting because the
        // `object?` has an Unboxing conversion. Should report warning on unconverted operand
        // when Unboxing.)
        [Fact]
        [WorkItem(29981, "https://github.com/dotnet/roslyn/issues/29981")]
        public void UnconstrainedTypeParameter_MayBeNonNullable()
        {
            var source =
@"class C1<T1>
{
    static object? NullableObject() => null;
    static T1 F1() => default; // warn: return type T1 may be non-null
    static T1 F2() => default(T1); // warn: return type T1 may be non-null
    static void F4()
    {
        T1 t1 = (T1)NullableObject(); // warn: T1 may be non-null
    }
}
class C2<T2> where T2 : class
{
    static object? NullableObject() => null;
    static T2 F1() => default; // warn: return type T2 may be non-null
    static T2 F2() => default(T2); // warn: return type T2 may be non-null
    static void F4()
    {
        T2 t2 = (T2)NullableObject(); // warn: T2 may be non-null
    }
}
class C3<T3> where T3 : new()
{
    static object? NullableObject() => null;
    static T3 F1() => default; // warn: return type T3 may be non-null
    static T3 F2() => default(T3); // warn: return type T3 may be non-null
    static T3 F3() => new T3();
    static void F4()
    {
        T3 t = (T3)NullableObject(); // warn: T3 may be non-null
    }
}
class C4<T4> where T4 : I
{
    static object? NullableObject() => null;
    static T4 F1() => default; // warn: return type T4 may be non-null
    static T4 F2() => default(T4); // warn: return type T4 may be non-null
    static void F4()
    {
        T4 t4 = (T4)NullableObject(); // warn: T4 may be non-null
    }
}
class C5<T5> where T5 : A
{
    static object? NullableObject() => null;
    static T5 F1() => default; // warn: return type T5 may be non-null
    static T5 F2() => default(T5); // warn: return type T5 may be non-null
    static void F4()
    {
        T5 t5 = (T5)NullableObject(); // warn: T5 may be non-null
    }
}
interface I
{
}
class A
{
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29981: missing warnings
            comp.VerifyDiagnostics(
                // (45,23): warning CS8603: Possible null reference return.
                //     static T5 F1() => default; // warn: return type T5 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(45, 23),
                // (29,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T3 t = (T3)NullableObject(); // warn: T3 may be non-null
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T3)NullableObject()").WithLocation(29, 16),
                // (35,23): warning CS8603: Possible null reference return.
                //     static T4 F1() => default; // warn: return type T4 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(35, 23),
                // (24,23): warning CS8603: Possible null reference return.
                //     static T3 F1() => default; // warn: return type T3 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(24, 23),
                // (14,23): warning CS8603: Possible null reference return.
                //     static T2 F1() => default; // warn: return type T2 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(14, 23),
                // (4,23): warning CS8603: Possible null reference return.
                //     static T1 F1() => default; // warn: return type T1 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default").WithLocation(4, 23),
                // (39,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T4 t4 = (T4)NullableObject(); // warn: T4 may be non-null
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T4)NullableObject()").WithLocation(39, 17),
                // (46,23): warning CS8603: Possible null reference return.
                //     static T5 F2() => default(T5); // warn: return type T5 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(T5)").WithLocation(46, 23),
                // (25,23): warning CS8603: Possible null reference return.
                //     static T3 F2() => default(T3); // warn: return type T3 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(T3)").WithLocation(25, 23),
                // (36,23): warning CS8603: Possible null reference return.
                //     static T4 F2() => default(T4); // warn: return type T4 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(T4)").WithLocation(36, 23),
                // (5,23): warning CS8603: Possible null reference return.
                //     static T1 F2() => default(T1); // warn: return type T1 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(T1)").WithLocation(5, 23),
                // (15,23): warning CS8603: Possible null reference return.
                //     static T2 F2() => default(T2); // warn: return type T2 may be non-null
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "default(T2)").WithLocation(15, 23),
                // (49,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T5 t5 = (T5)NullableObject(); // warn: T5 may be non-null
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T5)NullableObject()").WithLocation(49, 17),
                // (8,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T1 t1 = (T1)NullableObject(); // warn: T1 may be non-null
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T1)NullableObject()").WithLocation(8, 17),
                // (18,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T2 t2 = (T2)NullableObject(); // warn: T2 may be non-null
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T2)NullableObject()").WithLocation(18, 17)
            );
        }

        [Fact]
        public void UnconstrainedTypeParameter_MayBeNullable_01()
        {
            var source =
@"class C
{
    static void F(object o)
    {
    }
    static void F1<T1>(T1 t1)
    {
        F(t1);
        F((object)t1);
        t1.ToString();
    }
    static void F2<T2>(T2 t2) where T2 : struct
    {
        F(t2);
        F((object)t2);
        t2.ToString();
    }
    static void F3<T3>(T3 t3) where T3 : class
    {
        F(t3);
        F((object)t3);
        t3.ToString();
    }
    static void F4<T4>(T4 t4) where T4 : new()
    {
        F(t4);
        F((object)t4);
        t4.ToString();
    }
    static void F5<T5>(T5 t5) where T5 : I
    {
        F(t5);
        F((object)t5);
        t5.ToString();
    }
    static void F6<T6>(T6 t6) where T6 : A
    {
        F(t6);
        F((object)t6);
        t6.ToString();
    }
}
interface I
{
}
class A
{
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //         F(t1);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "t1").WithArguments("o", "void C.F(object o)").WithLocation(8, 11),
                // (9,11): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F((object)t1);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t1").WithLocation(9, 11),
                // (9,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //         F((object)t1);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "(object)t1").WithArguments("o", "void C.F(object o)").WithLocation(9, 11),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         t1.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(10, 9),
                // (26,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //         F(t4);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "t4").WithArguments("o", "void C.F(object o)").WithLocation(26, 11),
                // (27,11): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F((object)t4);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t4").WithLocation(27, 11),
                // (27,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //         F((object)t4);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "(object)t4").WithArguments("o", "void C.F(object o)").WithLocation(27, 11),
                // (28,9): warning CS8602: Possible dereference of a null reference.
                //         t4.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t4").WithLocation(28, 9)
            );
        }

        [Fact]
        public void UnconstrainedTypeParameter_MayBeNullable_02()
        {
            var source =
@"class C
{
    static void F1<T1>(T1 x1)
    {
        object? y1;
        y1 = (object?)x1;
        y1 = (object)x1; // warn: T1 may be null
    }
    static void F2<T2>(T2 x2) where T2 : class
    {
        object? y2;
        y2 = (object?)x2;
        y2 = (object)x2;
    }
    static void F3<T3>(T3 x3) where T3 : new()
    {
        object? y3;
        y3 = (object?)x3;
        y3 = (object)x3; // warn unless new() constraint implies non-nullable
        y3 = (object)new T3();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y1 = (object)x1; // warn: T1 may be null
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)x1").WithLocation(7, 14),
                // (19,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y3 = (object)x3; // warn unless new() constraint implies non-nullable
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)x3").WithLocation(19, 14)
            );
        }

        [Fact]
        public void UnconstrainedTypeParameter_Return_01()
        {
            var source =
@"class C
{
    static object? F01<T>(T t) => t;
    static object? F02<T>(T t) where T : class => t;
    static object? F03<T>(T t) where T : struct => t;
    static object? F04<T>(T t) where T : new() => t;
    static object? F05<T, U>(U u) where U : T => u;
    static object? F06<T, U>(U u) where U : class, T => u;
    static object? F07<T, U>(U u) where U : struct, T => u;
    static object? F08<T, U>(U u) where U : T, new() => u;
    static object? F09<T>(T t) => (object?)t;
    static object? F10<T>(T t) where T : class => (object?)t;
    static object? F11<T>(T t) where T : struct => (object?)t;
    static object? F12<T>(T t) where T : new() => (object?)t;
    static object? F13<T, U>(U u) where U : T => (object?)u;
    static object? F14<T, U>(U u) where U : class, T => (object?)u;
    static object? F15<T, U>(U u) where U : struct, T => (object?)u;
    static object? F16<T, U>(U u) where U : T, new() => (object?)u;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void UnconstrainedTypeParameter_Return_02()
        {
            var source =
@"class C
{
    static object F01<T>(T t) => t;
    static object F02<T>(T t) where T : class => t;
    static object F03<T>(T t) where T : struct => t;
    static object F04<T>(T t) where T : new() => t;
    static object F05<T, U>(U u) where U : T => u;
    static object F06<T, U>(U u) where U : class, T => u;
    static object F07<T, U>(U u) where U : struct, T => u;
    static object F08<T, U>(U u) where U : T, new() => u;
    static object F09<T>(T t) => (object)t;
    static object F10<T>(T t) where T : class => (object)t;
    static object F11<T>(T t) where T : struct => (object)t;
    static object F12<T>(T t) where T : new() => (object)t;
    static object F13<T, U>(U u) where U : T => (object)u;
    static object F14<T, U>(U u) where U : class, T => (object)u;
    static object F15<T, U>(U u) where U : struct, T => (object)u;
    static object F16<T, U>(U u) where U : T, new() => (object)u;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,34): warning CS8603: Possible null reference return.
                //     static object F01<T>(T t) => t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "t").WithLocation(3, 34),
                // (6,50): warning CS8603: Possible null reference return.
                //     static object F04<T>(T t) where T : new() => t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "t").WithLocation(6, 50),
                // (7,49): warning CS8603: Possible null reference return.
                //     static object F05<T, U>(U u) where U : T => u;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "u").WithLocation(7, 49),
                // (10,56): warning CS8603: Possible null reference return.
                //     static object F08<T, U>(U u) where U : T, new() => u;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "u").WithLocation(10, 56),
                // (11,34): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static object F09<T>(T t) => (object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t").WithLocation(11, 34),
                // (11,34): warning CS8603: Possible null reference return.
                //     static object F09<T>(T t) => (object)t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(object)t").WithLocation(11, 34),
                // (14,50): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static object F12<T>(T t) where T : new() => (object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t").WithLocation(14, 50),
                // (14,50): warning CS8603: Possible null reference return.
                //     static object F12<T>(T t) where T : new() => (object)t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(object)t").WithLocation(14, 50),
                // (15,49): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static object F13<T, U>(U u) where U : T => (object)u;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)u").WithLocation(15, 49),
                // (15,49): warning CS8603: Possible null reference return.
                //     static object F13<T, U>(U u) where U : T => (object)u;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(object)u").WithLocation(15, 49),
                // (18,56): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static object F16<T, U>(U u) where U : T, new() => (object)u;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)u").WithLocation(18, 56),
                // (18,56): warning CS8603: Possible null reference return.
                //     static object F16<T, U>(U u) where U : T, new() => (object)u;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(object)u").WithLocation(18, 56));
        }

        [Fact]
        public void UnconstrainedTypeParameter_Return_03()
        {
            var source =
@"class C
{
    static T F01<T>(T t) => t;
    static T F02<T>(T t) where T : class => t;
    static T F03<T>(T t) where T : struct => t;
    static T F04<T>(T t) where T : new() => t;
    static T F05<T, U>(U u) where U : T => u;
    static T F06<T, U>(U u) where U : class, T => u;
    static T F07<T, U>(U u) where U : struct, T => u;
    static T F08<T, U>(U u) where U : T, new() => u;
    static T F09<T>(T t) => (T)t;
    static T F10<T>(T t) where T : class => (T)t;
    static T F11<T>(T t) where T : struct => (T)t;
    static T F12<T>(T t) where T : new() => (T)t;
    static T F13<T, U>(U u) where U : T => (T)u;
    static T F14<T, U>(U u) where U : class, T => (T)u;
    static T F15<T, U>(U u) where U : struct, T => (T)u;
    static T F16<T, U>(U u) where U : T, new() => (T)u;
    static U F17<T, U>(T t) where U : T => (U)t;
    static U F18<T, U>(T t) where U : class, T => (U)t;
    static U F19<T, U>(T t) where U : struct, T => (U)t;
    static U F20<T, U>(T t) where U : T, new() => (U)t;
    static U F21<T, U>(T t) => (U)(object)t;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            comp.VerifyDiagnostics(
                // (19,44): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F17<T, U>(T t) where U : T => (U)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)t").WithLocation(19, 44),
                // (19,44): warning CS8603: Possible null reference return.
                //     static U F17<T, U>(T t) where U : T => (U)t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(U)t").WithLocation(19, 44),
                // (20,51): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F18<T, U>(T t) where U : class, T => (U)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)t").WithLocation(20, 51),
                // (20,51): warning CS8603: Possible null reference return.
                //     static U F18<T, U>(T t) where U : class, T => (U)t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(U)t").WithLocation(20, 51),
                // (22,51): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F20<T, U>(T t) where U : T, new() => (U)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)t").WithLocation(22, 51),
                // (22,51): warning CS8603: Possible null reference return.
                //     static U F20<T, U>(T t) where U : T, new() => (U)t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(U)t").WithLocation(22, 51),
                // (23,32): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F21<T, U>(T t) => (U)(object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)(object)t").WithLocation(23, 32),
                // (23,32): warning CS8603: Possible null reference return.
                //     static U F21<T, U>(T t) => (U)(object)t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(U)(object)t").WithLocation(23, 32),
                // (23,35): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F21<T, U>(T t) => (U)(object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t").WithLocation(23, 35)
            );
        }

        [Fact]
        public void UnconstrainedTypeParameter_Uninitialized()
        {
            var source =
@"
class C
{
    static void F1<T>()
    {
        T t;
        t.ToString(); // 1
    }
}
";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): error CS0165: Use of unassigned local variable 't'
                //         t.ToString(); // 1
                Diagnostic(ErrorCode.ERR_UseDefViolation, "t").WithArguments("t").WithLocation(7, 9)
            );
        }

        [Fact]
        [WorkItem(29981, "https://github.com/dotnet/roslyn/issues/29981")]
        public void UnconstrainedTypeParameter_OutVariable()
        {
            var source =
@"
class C
{
    static void F1<T>(out T t) => t = default; // 1
    static void F2<T>(out T t) => t = default(T); // 2
    static void F3<T>(T t1, out T t2) => t2 = t1;
    static void F4<T, U>(U u, out T t) where U : T => t = u;
    static void F5<T, U>(U u, out T t) where T : U => t = (T)u; // 3
    static void F6<T, U>(U u, out T t) => t = (T)(object)u; // 4
}
";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,39): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F1<T>(out T t) => t = default; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(4, 39),
                // (5,39): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static void F2<T>(out T t) => t = default(T); // 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default(T)").WithLocation(5, 39),
                // (8,59): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static void F5<T, U>(U u, out T t) where T : U => t = (T)u; // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)u").WithLocation(8, 59),
                // (8,59): warning CS8601: Possible null reference assignment.
                //     static void F5<T, U>(U u, out T t) where T : U => t = (T)u; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "(T)u").WithLocation(8, 59),
                // (9,47): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static void F6<T, U>(U u, out T t) => t = (T)(object)u; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)(object)u").WithLocation(9, 47),
                // (9,47): warning CS8601: Possible null reference assignment.
                //     static void F6<T, U>(U u, out T t) => t = (T)(object)u; // 4
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "(T)(object)u").WithLocation(9, 47),
                // (9,50): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static void F6<T, U>(U u, out T t) => t = (T)(object)u; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)u").WithLocation(9, 50)
            );
        }

        [Fact]
        public void UnconstrainedTypeParameter_PatternMatching()
        {
            var source =
@"
class C
{
    static void F1<T>(object o, T tin)
    {
        if (o is T t1)
        {
            t1.ToString();
        }
        else
        {
            t1 = default; // 1
        }

        t1.ToString(); // 2

        if (!(o is T t2))
        {
            t2 = tin;
        }
        else
        {
            t2.ToString();
        }
        t2.ToString(); // 3

        if (!(o is T t3)) return;
        t3.ToString();
    }
}
";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         t1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(15, 9),
                // (25,9): warning CS8602: Possible dereference of a null reference.
                //         t2.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2").WithLocation(25, 9)
            );
        }

        [Fact]
        [WorkItem(29983, "https://github.com/dotnet/roslyn/issues/29983")]
        public void UnconstrainedTypeParameter_TypeInferenceThroughCall()
        {
            var source =
@"
class C
{
    static T Copy<T>(T t) => t;
    static void CopyOut<T>(T t1, out T t2) => t2 = t1;
    static void CopyOutInherit<T1, T2>(T1 t1, out T2 t2) where T1 : T2 => t2 = t1;
    static void M<U>(U u)
    {
        var x1 = Copy(u);
        x1.ToString(); // 1

        CopyOut(u, out var x2);
        x2.ToString(); // 2

        CopyOut(u, out U x3);
        x3.ToString(); // 3

        if (u == null) throw null;

        var x4 = Copy(u);
        x4.ToString();

        CopyOut(u, out var x5);
        x5.ToString();

        CopyOut(u, out U x6);
        x6.ToString();

        CopyOutInherit(u, out var x7);
        x7.ToString();
    }
}
";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29983: Should not report warning for `x6.ToString()`.
            comp.VerifyDiagnostics(
                // (29,9): error CS0411: The type arguments for method 'C.CopyOutInherit<T1, T2>(T1, out T2)' cannot be inferred from the usage. Try specifying the type arguments explicitly.
                //         CopyOutInherit(u, out var x7);
                Diagnostic(ErrorCode.ERR_CantInferMethTypeArgs, "CopyOutInherit").WithArguments("C.CopyOutInherit<T1, T2>(T1, out T2)").WithLocation(29, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         x1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(10, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         x2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(13, 9),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         x3.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x3").WithLocation(16, 9),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         x4.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x4").WithLocation(21, 9),
                // (24,9): warning CS8602: Possible dereference of a null reference.
                //         x5.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x5").WithLocation(24, 9),
                // (27,9): warning CS8602: Possible dereference of a null reference.
                //         x6.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x6").WithLocation(27, 9));
        }

        [Fact]
        [WorkItem(29993, "https://github.com/dotnet/roslyn/issues/29993")]
        public void TypeParameter_Return_01()
        {
            var source =
@"
class C
{
    static U F1<T, U>(T t) => (U)(object)t; // 1 and 2
    static U F2<T, U>(T t) where U : class => (U)(object)t; // 3, 4 and 5
    static U F3<T, U>(T t) where U : struct => (U)(object)t; // 5
    static U F4<T, U>(T t) where T : class => (U)(object)t;
    static U F5<T, U>(T t) where T : struct => (U)(object)t;
}";

            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29993: Errors are different than expected.
            comp.VerifyDiagnostics(
                // (4,34): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F1<T, U>(T t) => (U)(object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t").WithLocation(4, 34),
                // (4,31): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F1<T, U>(T t) => (U)(object)t; // 1 and 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)(object)t").WithLocation(4, 31),
                // (4,31): warning CS8603: Possible null reference return.
                //     static U F1<T, U>(T t) => (U)(object)t; // 1 and 2
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(U)(object)t").WithLocation(4, 31),
                // (5,50): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F2<T, U>(T t) where U : class => (U)(object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t").WithLocation(5, 50),
                // (5,47): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F2<T, U>(T t) where U : class => (U)(object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)(object)t").WithLocation(5, 47),
                // (5,47): warning CS8603: Possible null reference return.
                //     static U F2<T, U>(T t) where U : class => (U)(object)t;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "(U)(object)t").WithLocation(5, 47),
                // (6,51): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //     static U F3<T, U>(T t) where U : struct => (U)(object)t;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t").WithLocation(6, 51)
            );
        }

        [Fact]
        public void TrackUnconstrainedTypeParameter_LocalsAndParameters()
        {
            var source =
@"class C
{
    static void F0<T>()
    {
        default(T).ToString(); // warn 1
        default(T)?.ToString();
    }
    static void F1<T>()
    {
        T x1 = default; // warn 2
        x1.ToString(); // warn 3
        x1!.ToString();
        x1?.ToString();
        if (x1 != null) x1.ToString();
        T y1 = x1;
        y1.ToString();
    }
    static void F2<T>(T x2, T[] a2)
    {
        x2.ToString(); // warn 4
        x2!.ToString();
        x2?.ToString();
        if (x2 != null) x2.ToString();
        T y2 = x2;
        y2.ToString();
        a2[0].ToString(); // warn 5
    }
    static void F3<T>() where T : new()
    {
        T x3 = new T();
        x3.ToString();
        x3!.ToString();
        var a3 = new[] { new T() };
        a3[0].ToString(); // warn 6
    }
    static T F4<T>(T x4)
    {
        T y4 = x4;
        return y4;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         default(T).ToString(); // warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "default(T)").WithLocation(5, 9),
                // (10,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T x1 = default; // warn 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(10, 16),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x1.ToString(); // warn 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(11, 9),
                // (13,9): hidden CS8607: Expression is probably never null.
                //         x1?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x1").WithLocation(13, 9),
                // (14,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (x1 != null) x1.ToString();
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "x1 != null").WithLocation(14, 13),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         x2.ToString(); // warn 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(20, 9),
                // (22,9): hidden CS8607: Expression is probably never null.
                //         x2?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x2").WithLocation(22, 9),
                // (23,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (x2 != null) x2.ToString();
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "x2 != null").WithLocation(23, 13),
                // (26,9): warning CS8602: Possible dereference of a null reference.
                //         a2[0].ToString(); // warn 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a2[0]").WithLocation(26, 9),
                // (34,9): warning CS8602: Possible dereference of a null reference.
                //         a3[0].ToString(); // warn 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a3[0]").WithLocation(34, 9));
        }

        [Fact]
        public void TrackUnconstrainedTypeParameter_ExplicitCast()
        {
            var source =
@"class C
{
    static void F(object o)
    {
    }
    static void F1<T1>(T1 t1)
    {
        F((object)t1);
        if (t1 != null) F((object)t1);
    }
    static void F2<T2>(T2 t2) where T2 : class
    {
        F((object)t2);
        if (t2 != null) F((object)t2);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,11): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         F((object)t1);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t1").WithLocation(8, 11),
                // (8,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void C.F(object o)'.
                //         F((object)t1);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "(object)t1").WithArguments("o", "void C.F(object o)").WithLocation(8, 11),
                // (14,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (t2 != null) F((object)t2);
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "t2 != null").WithLocation(14, 13));
        }

        [Fact]
        public void NullableT_BaseAndInterfaces()
        {
            var source =
@"interface IA<T> { }
interface IB<T> : IA<T?> { }
interface IC<T> { }
class A<T> { }
class B<T> : A<(T, T?)> { }
class C<T, U, V> : A<T?>, IA<U>, IC<V> { }
class D<T, U, V> : A<T>, IA<U?>, IC<V> { }
class E<T, U, V> : A<T>, IA<U>, IC<V?> { }
class P
{
    static void F1(IB<object> o) { }
    static void F2(B<object> o) { }
    static void F3(C<object, object, object> o) { }
    static void F4(D<object, object, object> o) { }
    static void F5(E<object, object, object> o) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // interface IB<T> : IA<T?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(2, 22),
                // (5,20): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class B<T> : A<(T, T?)> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 20),
                // (6,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C<T, U, V> : A<T?>, IA<U>, IC<V> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(6, 22),
                // (7,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class D<T, U, V> : A<T>, IA<U?>, IC<V> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(7, 29),
                // (8,36): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class E<T, U, V> : A<T>, IA<U>, IC<V?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "V?").WithLocation(8, 36)
                );
        }

        [Fact]
        public void NullableT_Constraints()
        {
            var source =
@"interface I<T, U> where U : T? { }
class A<T> { }
class B
{
    static void F<T, U>() where U : A<T?> { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (1,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // interface I<T, U> where U : T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(1, 29),
                // (5,39): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void F<T, U>() where U : A<T?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 39)
                );
        }

        [Fact]
        [WorkItem(29995, "https://github.com/dotnet/roslyn/issues/29995")]
        public void NullableT_Members()
        {
            var source =
@"using System;
#pragma warning disable 0067
#pragma warning disable 0169
#pragma warning disable 8618
delegate T? D<T>();
class A<T>
{
}
class B<T>
{
    const object c = default(T?[]);
    T? F;
    B(T? t) { }
    static void M<U>(T? t, U? u) { }
    static B<T?> P { get; set; }
    event EventHandler<T?> E;
    public static explicit operator A<T?>(B<T> t) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29995: Report error for `const object c = default(T?[]);`.
            comp.VerifyDiagnostics(
                // (5,10): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // delegate T? D<T>();
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 10),
                // (11,30): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     const object c = default(T?[]);
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(11, 30),
                // (12,5): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     T? F;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(12, 5),
                // (13,7): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     B(T? t) { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(13, 7),
                // (14,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void M<U>(T? t, U? u) { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(14, 22),
                // (14,28): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void M<U>(T? t, U? u) { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(14, 28),
                // (15,14): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static B<T?> P { get; set; }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(15, 14),
                // (16,24): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     event EventHandler<T?> E;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(16, 24),
                // (17,39): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public static explicit operator A<T?>(B<T> t) => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(17, 39)
                );
        }

        [Fact]
        public void NullableT_ReturnType()
        {
            var source =
@"interface I { }
class A { }
class B
{
    static T? F1<T>() => throw null; // error
    static T? F2<T>() where T : class => throw null;
    static T? F3<T>() where T : struct => throw null;
    static T? F4<T>() where T : new() => throw null; // error
    static T? F5<T>() where T : unmanaged => throw null;
    static T? F6<T>() where T : I => throw null; // error
    static T? F7<T>() where T : A => throw null;
}
class C
{
    static U?[] F1<T, U>() where U : T => throw null; // error
    static U?[] F2<T, U>() where T : class where U : T => throw null;
    static U?[] F3<T, U>() where T : struct where U : T => throw null;
    static U?[] F4<T, U>() where T : new() where U : T => throw null; // error
    static U?[] F5<T, U>() where T : unmanaged where U : T => throw null;
    static U?[] F6<T, U>() where T : I where U : T => throw null; // error
    static U?[] F7<T, U>() where T : A where U : T => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (16,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static U?[] F2<T, U>() where T : class where U : T => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(16, 12),
                // (18,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static U?[] F4<T, U>() where T : new() where U : T => throw null; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(18, 12),
                // (20,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static U?[] F6<T, U>() where T : I where U : T => throw null; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(20, 12),
                // (15,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static U?[] F1<T, U>() where U : T => throw null; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(15, 12),
                // (17,23): error CS0456: Type parameter 'T' has the 'struct' constraint so 'T' cannot be used as a constraint for 'U'
                //     static U?[] F3<T, U>() where T : struct where U : T => throw null;
                Diagnostic(ErrorCode.ERR_ConWithValCon, "U").WithArguments("U", "T").WithLocation(17, 23),
                // (19,23): error CS8379: Type parameter 'T' has the 'unmanaged' constraint so 'T' cannot be used as a constraint for 'U'
                //     static U?[] F5<T, U>() where T : unmanaged where U : T => throw null;
                Diagnostic(ErrorCode.ERR_ConWithUnmanagedCon, "U").WithArguments("U", "T").WithLocation(19, 23),
                // (8,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static T? F4<T>() where T : new() => throw null; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 12),
                // (10,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static T? F6<T>() where T : I => throw null; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(10, 12),
                // (5,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static T? F1<T>() => throw null; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 12));
        }

        [Fact]
        public void NullableT_Parameters()
        {
            var source =
@"interface I { }
abstract class A
{
    internal abstract void F1<T>(T? t); // error
    internal abstract void F2<T>(T? t) where T : class;
    internal abstract void F3<T>(T? t) where T : struct;
    internal abstract void F4<T>(T? t) where T : new(); // error
    internal abstract void F5<T>(T? t) where T : unmanaged;
    internal abstract void F6<T>(T? t) where T : I; // error
    internal abstract void F7<T>(T? t) where T : A;
}
class B : A
{
    internal override void F1<U>(U? u) { } // error
    internal override void F2<U>(U? u) { }
    internal override void F3<U>(U? u) { }
    internal override void F4<U>(U? u) { } // error
    internal override void F5<U>(U? u) { }
    internal override void F6<U>(U? u) { } // error
    internal override void F7<U>(U? u) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,34): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     internal abstract void F1<T>(T? t); // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 34),
                // (7,34): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     internal abstract void F4<T>(T? t) where T : new(); // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 34),
                // (9,34): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     internal abstract void F6<T>(T? t) where T : I; // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(9, 34),
                // (14,34): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     internal override void F1<U>(U? u) { } // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(14, 34),
                // (17,34): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     internal override void F4<U>(U? u) { } // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(17, 34),
                // (19,34): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     internal override void F6<U>(U? u) { } // error
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(19, 34));
        }

        [Fact]
        public void NullableT_ContainingType()
        {
            var source =
@"class A<T>
{
    internal interface I { }
    internal enum E { }
}
class C
{
    static void F1<T>(A<T?>.I  i) { }
    static void F2<T>(A<T?>.E[] e) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,25): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void F2<T>(A<T?>.E[] e) { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(9, 25),
                // (8,25): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void F1<T>(A<T?>.I  i) { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 25)
                );
        }

        [Fact]
        public void NullableT_MethodBody()
        {
            var source =
@"#pragma warning disable 0168
class C<T>
{
    static void M<U>()
    {
        T? t;
        var u = typeof(U?);
        object? o = default(T?);
        o = new U?[0];
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         T? t;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(6, 9),
                // (7,24): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         var u = typeof(U?);
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(7, 24),
                // (8,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         object? o = default(T?);
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 29),
                // (9,17): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         o = new U?[0];
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(9, 17)
                );
        }

        [Fact]
        public void NullableT_Lambda()
        {
            var source =
@"delegate void D<T>(T t);
class C
{
    static void F<T>(D<T> d) { }
    static void G<T>()
    {
        F((T? t) => { });
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,12): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         F((T? t) => { });
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 12));
        }

        [Fact]
        public void NullableT_LocalFunction()
        {
            var source =
@"#pragma warning disable 8321
class C
{
    static void F1<T>()
    {
        T? L1() => throw null;
    }
    static void F2()
    {
        void L2<T>(T?[] t) { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         T? L1() => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(6, 9),
                // (10,20): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void L2<T>(T?[] t) { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(10, 20));
        }

        [Fact]
        [WorkItem(29996, "https://github.com/dotnet/roslyn/issues/29996")]
        public void NullableT_FromMetadata_BaseAndInterfaces()
        {
            var source0 =
@".class public System.Runtime.CompilerServices.NullableAttribute extends [mscorlib]System.Attribute
{
  .method public hidebysig specialname rtspecialname instance void .ctor(bool[] b) cil managed { ret }
}
.class interface public abstract IA`1<T>
{
}
.class interface public abstract IB`1<T>
    implements class IA`1<!T>
{
  .interfaceimpl type class IA`1<!T>
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(bool[]) = ( 01 00 02 00 00 00 00 01 00 00 ) 
}
.class public A`1<T>
{
}
.class public B`1<T>
    extends class A`1<!T>
{
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(bool[]) = ( 01 00 02 00 00 00 00 01 00 00 ) 
}";
            var ref0 = CompileIL(source0);
            var source1 =
@"class C
{
    static void F(IB<object> b) { }
    static void G(B<object> b) { }
}";
            var comp = CreateCompilation(source1, new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/29996: Report errors for T? in metadata?
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(29996, "https://github.com/dotnet/roslyn/issues/29996")]
        public void NullableT_FromMetadata_Methods()
        {
            var source0 =
@".class public System.Runtime.CompilerServices.NullableAttribute extends [mscorlib]System.Attribute
{
  .method public hidebysig specialname rtspecialname instance void .ctor() cil managed { ret }
}
.class interface public abstract I
{
}
.class public A
{
}
.class public C
{
  .method public static !!T F1<T>()
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 )
    ldnull
    throw
  }
  .method public static !!T F2<class T>()
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 )
    ldnull
    throw
  }
  .method public static !!T F3<valuetype .ctor ([mscorlib]System.ValueType) T>()
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 )
    ldnull
    throw
  }
  .method public static !!T F4<.ctor T>()
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 )
    ldnull
    throw
  }
  .method public static !!T F5<(I) T>()
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 )
    ldnull
    throw
  }
  .method public static !!T F6<(A) T>()
  {
    .param [0]
    .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 )
    ldnull
    throw
  }
}";
            var ref0 = CompileIL(source0);
            var source1 =
@"class P
{
    static void Main()
    {
        C.F1<int>(); // error
        C.F1<object>();
        C.F2<object>();
        C.F3<int>();
        C.F4<object>(); // error
        C.F5<I>(); // error
        C.F6<A>();
    }
}";
            var comp = CreateCompilation(source1, new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/29996: Report errors for T? in metadata?
            comp.VerifyDiagnostics();
        }

        [WorkItem(27289, "https://github.com/dotnet/roslyn/issues/27289")]
        [Fact]
        public void NullableTInConstraint_01()
        {
            var source =
@"class A { }
class B<T> where T : T? { }
class C<T> where T : class, T? { }
class D<T> where T : struct, T? { }
class E<T> where T : A, T? { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,30): error CS0701: 'T?' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
                // class D<T> where T : struct, T? { }
                Diagnostic(ErrorCode.ERR_BadBoundType, "T?").WithArguments("T?").WithLocation(4, 30),
                // (2,9): error CS0454: Circular constraint dependency involving 'T' and 'T'
                // class B<T> where T : T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(2, 9),
                // (2,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class B<T> where T : T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(2, 22),
                // (3,9): error CS0454: Circular constraint dependency involving 'T' and 'T'
                // class C<T> where T : class, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(3, 9),
                // (5,9): error CS0454: Circular constraint dependency involving 'T' and 'T'
                // class E<T> where T : A, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(5, 9));
        }

        [WorkItem(27289, "https://github.com/dotnet/roslyn/issues/27289")]
        [Fact]
        public void NullableTInConstraint_02()
        {
            var source =
@"class A<T, U>
    where U : T?
{
}
class B<T, U>
    where T : class
    where U : T?
{
}
class C<T, U>
    where T : U?
    where U : T?
{
}
class D<T, U>
    where T : class, U?
    where U : class, T?
{
}
class E<T, U>
    where T : class, U
    where U : T?
{
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,15): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     where U : T?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(2, 15),
                // (11,15): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     where T : U?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(11, 15),
                // (12,15): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     where U : T?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(12, 15),
                // (10,9): error CS0454: Circular constraint dependency involving 'T' and 'U'
                // class C<T, U>
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "U").WithLocation(10, 9),
                // (15,9): error CS0454: Circular constraint dependency involving 'T' and 'U'
                // class D<T, U>
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "U").WithLocation(15, 9),
                // (20,9): error CS0454: Circular constraint dependency involving 'T' and 'U'
                // class E<T, U>
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "U").WithLocation(20, 9));
        }

        [WorkItem(27289, "https://github.com/dotnet/roslyn/issues/27289")]
        [Fact]
        public void NullableTInConstraint_03()
        {
            var source =
@"class A<T> where T : T, T? { }
class B<U> where U : U?, U { }
class C<V> where V : V?, V? { }
delegate void D1<T1, U1>()
    where U1 : T1, T1?;
delegate void D2<T2, U2>()
    where U2 : class, T2?, T2;
delegate void D3<T3, U3>()
    where T3 : class
    where U3 : T3, T3?;";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (1,25): error CS0405: Duplicate constraint 'T' for type parameter 'T'
                // class A<T> where T : T, T? { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T?").WithArguments("T", "T").WithLocation(1, 25),
                // (1,25): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class A<T> where T : T, T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(1, 25),
                // (1,9): error CS0454: Circular constraint dependency involving 'T' and 'T'
                // class A<T> where T : T, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(1, 9),
                // (2,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class B<U> where U : U?, U { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(2, 22),
                // (2,26): error CS0405: Duplicate constraint 'U' for type parameter 'U'
                // class B<U> where U : U?, U { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "U").WithArguments("U", "U").WithLocation(2, 26),
                // (2,9): error CS0454: Circular constraint dependency involving 'U' and 'U'
                // class B<U> where U : U?, U { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "U").WithArguments("U", "U").WithLocation(2, 9),
                // (3,22): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C<V> where V : V?, V? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "V?").WithLocation(3, 22),
                // (3,26): error CS0405: Duplicate constraint 'V' for type parameter 'V'
                // class C<V> where V : V?, V? { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "V?").WithArguments("V", "V").WithLocation(3, 26),
                // (3,26): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C<V> where V : V?, V? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "V?").WithLocation(3, 26),
                // (3,9): error CS0454: Circular constraint dependency involving 'V' and 'V'
                // class C<V> where V : V?, V? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "V").WithArguments("V", "V").WithLocation(3, 9),
                // (5,20): error CS0405: Duplicate constraint 'T1' for type parameter 'U1'
                //     where U1 : T1, T1?;
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T1?").WithArguments("T1", "U1").WithLocation(5, 20),
                // (5,20): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     where U1 : T1, T1?;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T1?").WithLocation(5, 20),
                // (7,23): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     where U2 : class, T2?, T2;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T2?").WithLocation(7, 23),
                // (7,28): error CS0405: Duplicate constraint 'T2' for type parameter 'U2'
                //     where U2 : class, T2?, T2;
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T2").WithArguments("T2", "U2").WithLocation(7, 28),
                // (10,20): error CS0405: Duplicate constraint 'T3' for type parameter 'U3'
                //     where U3 : T3, T3?;
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T3?").WithArguments("T3", "U3").WithLocation(10, 20));
        }

        [Fact]
        public void NullableTInConstraint_04()
        {
            var source =
@"class A { }
class B
{
    static void F1<T>() where T : T? { }
    static void F2<T>() where T : class, T? { }
    static void F3<T>() where T : struct, T? { }
    static void F4<T>() where T : A, T? { }
    static void F5<T, U>() where U : T? { }
    static void F6<T, U>() where T : class where U : T? { }
    static void F7<T, U>() where T : struct where U : T? { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,20): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //     static void F2<T>() where T : class, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(5, 20),
                // (6,43): error CS0701: 'T?' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
                //     static void F3<T>() where T : struct, T? { }
                Diagnostic(ErrorCode.ERR_BadBoundType, "T?").WithArguments("T?").WithLocation(6, 43),
                // (7,20): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //     static void F4<T>() where T : A, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(7, 20),
                // (8,38): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void F5<T, U>() where U : T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 38),
                // (10,55): error CS0701: 'T?' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
                //     static void F7<T, U>() where T : struct where U : T? { }
                Diagnostic(ErrorCode.ERR_BadBoundType, "T?").WithArguments("T?").WithLocation(10, 55),
                // (4,35): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     static void F1<T>() where T : T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 35),
                // (4,20): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //     static void F1<T>() where T : T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(4, 20));
        }

        [Fact]
        public void NullableTInConstraint_05()
        {
            var source =
@"#pragma warning disable 8321
class A { }
class B
{
    static void M()
    {
        void F1<T>() where T : T? { }
        void F2<T>() where T : class, T? { }
        void F3<T>() where T : struct, T? { }
        void F4<T>() where T : A, T? { }
        void F5<T, U>() where U : T? { }
        void F6<T, U>() where T : class where U : T? { }
        void F7<T, U>() where T : struct where U : T? { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,32): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void F1<T>() where T : T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 32),
                // (7,17): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //         void F1<T>() where T : T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(7, 17),
                // (8,17): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //         void F2<T>() where T : class, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(8, 17),
                // (9,40): error CS0701: 'T?' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
                //         void F3<T>() where T : struct, T? { }
                Diagnostic(ErrorCode.ERR_BadBoundType, "T?").WithArguments("T?").WithLocation(9, 40),
                // (10,17): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //         void F4<T>() where T : A, T? { }
                Diagnostic(ErrorCode.ERR_CircularConstraint, "T").WithArguments("T", "T").WithLocation(10, 17),
                // (11,35): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void F5<T, U>() where U : T? { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(11, 35),
                // (13,52): error CS0701: 'T?' is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter.
                //         void F7<T, U>() where T : struct where U : T? { }
                Diagnostic(ErrorCode.ERR_BadBoundType, "T?").WithArguments("T?").WithLocation(13, 52));
        }

        [Fact]
        public void NullableTInConstraint_06()
        {
            var source =
@"#pragma warning disable 8321
class A<T> where T : class
{
    static void F1<U>() where U : T?
    {
    }
    static void F2()
    {
        void F3<U>() where U : T? { }
    }
}
class B
{
    static void F4<T>() where T : class
    {
        void F5<U>() where U : T? { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableTInConstraint_07()
        {
            var source =
@"interface I<T, U>
    where T : class
    where U : T
{
}
class A<T, U>
    where T : class
    where U : T?
{
}
class B1<T> : A<T, T>, I<T, T>
    where T : class
{
}
class B2<T> : A<T, T?>, I<T, T?>
    where T : class
{
} 
class B3<T> : A<T?, T>, I<T?, T>
    where T : class
{
}
class B4<T> : A<T?, T?>, I<T?, T?>
    where T : class
{
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/29678: Should report warnings that `T?`
            // does not satisfy `where T : class` constraint or `where U : T` constraint.
            comp.VerifyDiagnostics();
        }

        // `class C<T> where T : class, T?` from metadata.
        [Fact]
        public void NullableTInConstraint_08()
        {
            // https://github.com/dotnet/roslyn/issues/29997: `where T : class, T?` is not valid in C#,
            // so the class needs to be defined in IL. How and where should the custom
            // attribute be declared for the constraint type in the following?
            var source0 =
@".class public System.Runtime.CompilerServices.NullableAttribute extends [mscorlib]System.Attribute
{
  .method public hidebysig specialname rtspecialname instance void .ctor() cil managed { ret }
}
.custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor() = ( 01 00 00 00 ) 
.class public C<class (!T) T>
{
  .method public hidebysig specialname rtspecialname instance void .ctor() cil managed { ret }
}";
            var ref0 = CompileIL(source0);
            var source1 =
@"class Program
{
    static void Main()
    {
        object o;
        o = new C<object?>(); // 1
        o = new C<object>(); // 2
    }
}";
            var comp = CreateCompilation(new[] { source1 }, new[] { ref0 }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,19): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //         o = new C<object?>(); // 1
                Diagnostic(ErrorCode.ERR_CircularConstraint, "object?").WithArguments("T", "T").WithLocation(6, 19),
                // (7,19): error CS0454: Circular constraint dependency involving 'T' and 'T'
                //         o = new C<object>(); // 2
                Diagnostic(ErrorCode.ERR_CircularConstraint, "object").WithArguments("T", "T").WithLocation(7, 19));
        }

        // `class C<T, U> where U : T?` from metadata.
        [Fact]
        public void NullableTInConstraint_09()
        {
            var source0 =
@"public class C<T, U>
    where T : class
    where U : T?
{
}";
            var source1 =
@"class Program
{
    static void Main()
    {
        object o;
        o = new C<object?, object?>(); // 1
        o = new C<object?, object>(); // 2
        o = new C<object, object?>(); // 3
        o = new C<object, object>(); // 4
    }
}";

            var comp = CreateCompilation(source0);

            comp.VerifyDiagnostics(
                // (3,15): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     where U : T?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(3, 15),
                // (3,16): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     where U : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(3, 16)
                );

            MetadataReference ref0 = comp.ToMetadataReference();

            comp = CreateCompilation(new[] { source1 }, new[] { ref0 }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();

            comp = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            ref0 = comp.EmitToImageReference();

            comp = CreateCompilation(new[] { source1 }, new[] { ref0 }, options: WithNonNullTypesTrue());

            var c = comp.GetTypeByMetadataName("C`2");
            Assert.IsAssignableFrom<PENamedTypeSymbol>(c);
            Assert.Equal("C<T, U> where T : class where U : T?", c.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints));

            comp.VerifyDiagnostics(
                // (6,19): warning CS8634: The type 'object?' cannot be used as type parameter 'T' in the generic type or method 'C<T, U>'. Nullability of type argument 'object?' doesn't match 'class' constraint.
                //         o = new C<object?, object?>(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "object?").WithArguments("C<T, U>", "T", "object?").WithLocation(6, 19),
                // (7,19): warning CS8634: The type 'object?' cannot be used as type parameter 'T' in the generic type or method 'C<T, U>'. Nullability of type argument 'object?' doesn't match 'class' constraint.
                //         o = new C<object?, object>(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "object?").WithArguments("C<T, U>", "T", "object?").WithLocation(7, 19)
                );
        }

        [WorkItem(26294, "https://github.com/dotnet/roslyn/issues/26294")]
        [Fact]
        public void NullableTInConstraint_10()
        {
            var source =
@"interface I<T> { }
class C
{
    static void F1<T>() where T : class, I<T?> { }
    static void F2<T>() where T : I<dynamic?> { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,35): error CS1968: Constraint cannot be a dynamic type 'I<dynamic>'
                //     static void F2<T>() where T : I<dynamic?> { }
                Diagnostic(ErrorCode.ERR_ConstructedDynamicTypeAsBound, "I<dynamic?>").WithArguments("I<dynamic?>").WithLocation(5, 35));
        }

        [Fact]
        public void DuplicateConstraints()
        {
            var source =
@"interface I<T> where T : class { }
class C<T> where T : class
{
    static void F1<U>() where U : T, T { }
    static void F2<U>() where U : T, T? { }
    static void F3<U>() where U : T?, T { }
    static void F4<U>() where U : T?, T? { }
    static void F5<U>() where U : I<T>, I<T> { }
    static void F6<U>() where U : I<T>, I<T?> { }
    static void F7<U>() where U : I<T?>, I<T> { }
    static void F8<U>() where U : I<T?>, I<T?> { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,38): error CS0405: Duplicate constraint 'T' for type parameter 'U'
                //     static void F1<U>() where U : T, T { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T").WithArguments("T", "U").WithLocation(4, 38),
                // (5,38): error CS0405: Duplicate constraint 'T' for type parameter 'U'
                //     static void F2<U>() where U : T, T? { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T?").WithArguments("T", "U").WithLocation(5, 38),
                // (6,39): error CS0405: Duplicate constraint 'T' for type parameter 'U'
                //     static void F3<U>() where U : T?, T { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T").WithArguments("T", "U").WithLocation(6, 39),
                // (7,39): error CS0405: Duplicate constraint 'T' for type parameter 'U'
                //     static void F4<U>() where U : T?, T? { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "T?").WithArguments("T", "U").WithLocation(7, 39),
                // (8,41): error CS0405: Duplicate constraint 'I<T>' for type parameter 'U'
                //     static void F5<U>() where U : I<T>, I<T> { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "I<T>").WithArguments("I<T>", "U").WithLocation(8, 41),
                // (9,41): error CS0405: Duplicate constraint 'I<T>' for type parameter 'U'
                //     static void F6<U>() where U : I<T>, I<T?> { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "I<T?>").WithArguments("I<T>", "U").WithLocation(9, 41),
                // (10,42): error CS0405: Duplicate constraint 'I<T>' for type parameter 'U'
                //     static void F7<U>() where U : I<T?>, I<T> { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "I<T>").WithArguments("I<T>", "U").WithLocation(10, 42),
                // (11,42): error CS0405: Duplicate constraint 'I<T>' for type parameter 'U'
                //     static void F8<U>() where U : I<T?>, I<T?> { }
                Diagnostic(ErrorCode.ERR_DuplicateBound, "I<T?>").WithArguments("I<T>", "U").WithLocation(11, 42));
        }

        [Fact]
        public void PartialClassConstraints()
        {
            var source =
@"class A<T, U>
    where T : A<T, U>
    where U : B<T, U>
{
}
partial class B<T, U>
    where T : A<T, U>
    where U : B<T, U>
{
}
partial class B<T, U>
    where T : A<T, U>
    where U : B<T, U>
{
}";
            var comp = CreateCompilation(new[] { source }, parseOptions: TestOptions.Regular7);
            comp.VerifyDiagnostics();
            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void PartialClassConstraintMismatch()
        {
            var source =
@"class A { }
partial class B<T> where T : A { }
partial class B<T> where T : A? { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,15): error CS0265: Partial declarations of 'B<T>' have inconsistent constraints for type parameter 'T'
                // partial class B<T> where T : A { }
                Diagnostic(ErrorCode.ERR_PartialWrongConstraints, "B").WithArguments("B<T>", "T").WithLocation(2, 15));
        }

        [Fact]
        public void TypeUnification_01()
        {
            var source =
@"interface I<T> { }
class C1<T, U> : I<T>, I<U> { }
class C2<T, U> : I<T>, I<U?> { }
class C3<T, U> : I<T?>, I<U> { }
class C4<T, U> : I<T?>, I<U?> { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,7): error CS0695: 'C1<T, U>' cannot implement both 'I<T>' and 'I<U>' because they may unify for some type parameter substitutions
                // class C1<T, U> : I<T>, I<U> { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C1").WithArguments("C1<T, U>", "I<T>", "I<U>").WithLocation(2, 7),
                // (3,7): error CS0695: 'C2<T, U>' cannot implement both 'I<T>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C2<T, U> : I<T>, I<U?> { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C2").WithArguments("C2<T, U>", "I<T>", "I<U?>").WithLocation(3, 7),
                // (4,7): error CS0695: 'C3<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C3<T, U> : I<T?>, I<U> { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C3").WithArguments("C3<T, U>", "I<T?>", "I<U>").WithLocation(4, 7),
                // (5,7): error CS0695: 'C4<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C4<T, U> : I<T?>, I<U?> { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C4").WithArguments("C4<T, U>", "I<T?>", "I<U?>").WithLocation(5, 7),
                // (4,20): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C3<T, U> : I<T?>, I<U> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 20),
                // (5,20): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C4<T, U> : I<T?>, I<U?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(5, 20),
                // (5,27): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C4<T, U> : I<T?>, I<U?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(5, 27),
                // (3,26): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C2<T, U> : I<T>, I<U?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(3, 26)
                );
        }

        [Fact]
        public void TypeUnification_02()
        {
            var source =
@"interface I<T> { }
class C1<T, U> : I<T>, I<U> where T : struct { }
class C2<T, U> : I<T>, I<U?> where T : struct { }
class C3<T, U> : I<T?>, I<U> where T : struct { }
class C4<T, U> : I<T?>, I<U?> where T : struct { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,7): error CS0695: 'C1<T, U>' cannot implement both 'I<T>' and 'I<U>' because they may unify for some type parameter substitutions
                // class C1<T, U> : I<T>, I<U> where T : struct { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C1").WithArguments("C1<T, U>", "I<T>", "I<U>").WithLocation(2, 7),
                // (3,7): error CS0695: 'C2<T, U>' cannot implement both 'I<T>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C2<T, U> : I<T>, I<U?> where T : struct { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C2").WithArguments("C2<T, U>", "I<T>", "I<U?>").WithLocation(3, 7),
                // (3,26): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C2<T, U> : I<T>, I<U?> where T : class { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(3, 26),
                // (4,7): error CS0695: 'C3<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C3<T, U> : I<T?>, I<U> where T : struct { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C3").WithArguments("C3<T, U>", "I<T?>", "I<U>").WithLocation(4, 7),
                // (5,7): error CS0695: 'C4<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C4<T, U> : I<T?>, I<U?> where T : struct { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C4").WithArguments("C4<T, U>", "I<T?>", "I<U?>").WithLocation(5, 7),
                // (5,27): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C4<T, U> : I<T?>, I<U?> where T : class { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(5, 27)
                );
        }

        [Fact]
        public void TypeUnification_03()
        {
            var source =
@"interface I<T> { }
class C1<T, U> : I<T>, I<U> where T : class { }
class C2<T, U> : I<T>, I<U?> where T : class { }
class C3<T, U> : I<T?>, I<U> where T : class { }
class C4<T, U> : I<T?>, I<U?> where T : class { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,7): error CS0695: 'C1<T, U>' cannot implement both 'I<T>' and 'I<U>' because they may unify for some type parameter substitutions
                // class C1<T, U> : I<T>, I<U> where T : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C1").WithArguments("C1<T, U>", "I<T>", "I<U>").WithLocation(2, 7),
                // (3,7): error CS0695: 'C2<T, U>' cannot implement both 'I<T>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C2<T, U> : I<T>, I<U?> where T : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C2").WithArguments("C2<T, U>", "I<T>", "I<U?>").WithLocation(3, 7),
                // (3,26): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C2<T, U> : I<T>, I<U?> where T : class { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(3, 26),
                // (4,7): error CS0695: 'C3<T, U>' cannot implement both 'I<T?>' and 'I<U>' because they may unify for some type parameter substitutions
                // class C3<T, U> : I<T?>, I<U> where T : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C3").WithArguments("C3<T, U>", "I<T?>", "I<U>").WithLocation(4, 7),
                // (5,7): error CS0695: 'C4<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C4<T, U> : I<T?>, I<U?> where T : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C4").WithArguments("C4<T, U>", "I<T?>", "I<U?>").WithLocation(5, 7),
                // (5,27): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class C4<T, U> : I<T?>, I<U?> where T : class { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "U?").WithLocation(5, 27)
                );
        }

        [Fact]
        public void TypeUnification_04()
        {
            var source =
@"interface I<T> { }
class C1<T, U> : I<T>, I<U> where T : struct where U : class { }
class C2<T, U> : I<T>, I<U?> where T : struct where U : class { }
class C3<T, U> : I<T?>, I<U> where T : struct where U : class { }
class C4<T, U> : I<T?>, I<U?> where T : struct where U : class { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // Constraints are ignored when unifying types.
            comp.VerifyDiagnostics(
                // (2,7): error CS0695: 'C1<T, U>' cannot implement both 'I<T>' and 'I<U>' because they may unify for some type parameter substitutions
                // class C1<T, U> : I<T>, I<U> where T : struct where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C1").WithArguments("C1<T, U>", "I<T>", "I<U>").WithLocation(2, 7),
                // (3,7): error CS0695: 'C2<T, U>' cannot implement both 'I<T>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C2<T, U> : I<T>, I<U?> where T : struct where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C2").WithArguments("C2<T, U>", "I<T>", "I<U?>").WithLocation(3, 7),
                // (4,7): error CS0695: 'C3<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C3<T, U> : I<T?>, I<U> where T : struct where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C3").WithArguments("C3<T, U>", "I<T?>", "I<U>").WithLocation(4, 7),
                // (5,7): error CS0695: 'C4<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C4<T, U> : I<T?>, I<U?> where T : struct where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C4").WithArguments("C4<T, U>", "I<T?>", "I<U?>").WithLocation(5, 7));
        }

        [Fact]
        public void TypeUnification_05()
        {
            var source =
@"interface I<T> where T : class { }
class C1<T, U> : I<T>, I<U> where T : class where U : class { }
class C2<T, U> : I<T>, I<U?> where T : class where U : class { }
class C3<T, U> : I<T?>, I<U> where T : class where U : class { }
class C4<T, U> : I<T?>, I<U?> where T : class where U : class { }";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (2,7): error CS0695: 'C1<T, U>' cannot implement both 'I<T>' and 'I<U>' because they may unify for some type parameter substitutions
                // class C1<T, U> : I<T>, I<U> where T : class where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C1").WithArguments("C1<T, U>", "I<T>", "I<U>").WithLocation(2, 7),
                // (3,7): error CS0695: 'C2<T, U>' cannot implement both 'I<T>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C2<T, U> : I<T>, I<U?> where T : class where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C2").WithArguments("C2<T, U>", "I<T>", "I<U?>").WithLocation(3, 7),
                // (4,7): error CS0695: 'C3<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C3<T, U> : I<T?>, I<U> where T : class where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C3").WithArguments("C3<T, U>", "I<T?>", "I<U>").WithLocation(4, 7),
                // (5,7): error CS0695: 'C4<T, U>' cannot implement both 'I<T?>' and 'I<U?>' because they may unify for some type parameter substitutions
                // class C4<T, U> : I<T?>, I<U?> where T : class where U : class { }
                Diagnostic(ErrorCode.ERR_UnifyingInterfaceInstantiations, "C4").WithArguments("C4<T, U>", "I<T?>", "I<U?>").WithLocation(5, 7));
        }

        [Fact]
        public void AssignmentNullability()
        {
            var source =
@"class C
{
    static void F1(string? x1, string y1)
    {
        object? z1;
        (z1 = x1).ToString();
        (z1 = y1).ToString();
    }
    static void F2(string? x2, string y2)
    {
        object z2;
        (z2 = x2).ToString();
        (z2 = y2).ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (z1 = x1).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z1 = x1").WithLocation(6, 10),
                // (12,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (z2 = x2).ToString();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x2").WithLocation(12, 15),
                // (12,10): warning CS8602: Possible dereference of a null reference.
                //         (z2 = x2).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z2 = x2").WithLocation(12, 10));
        }

        [WorkItem(27008, "https://github.com/dotnet/roslyn/issues/27008")]
        [Fact]
        public void OverriddenMethodNullableValueTypeParameter_01()
        {
            var source0 =
@"public abstract class A
{
    public abstract void F(int? i);
}";
            var comp0 = CreateCompilation(source0);
            var ref0 = comp0.EmitToImageReference();
            var source =
@"class B : A
{
    public override void F(int? i) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void OverriddenMethodNullableValueTypeParameter_02()
        {
            var source0 =
@"public abstract class A<T> where T : struct
{
    public abstract void F(T? t);
}";
            var comp0 = CreateCompilation(source0);
            var ref0 = comp0.EmitToImageReference();
            var source =
@"class B1<T> : A<T> where T : struct
{
    public override void F(T? t) { }
}
class B2 : A<int>
{
    public override void F(int? t) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
        }

        [WorkItem(27967, "https://github.com/dotnet/roslyn/issues/27967")]
        [Fact]
        public void UnannotatedTypeArgument_Interface()
        {
            var source0 =
@"public interface I<T>
{
}
public class B : I<object[]>
{
}
public class C : I<C>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class Program
{
    static void F(B x)
    {
        I<object[]?> a = x;
        I<object[]> b = x;
    }
    static void F(C y)
    {
        I<C?> a = y;
        I<C> b = y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
        }

        [WorkItem(27967, "https://github.com/dotnet/roslyn/issues/27967")]
        [Fact]
        public void UnannotatedTypeArgument_BaseType()
        {
            var source0 =
@"public class A<T>
{
}
public class B : A<object[]>
{
}
public class C : A<C>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class Program
{
    static void F(B x)
    {
        A<object[]?> a = x;
        A<object[]> b = x;
    }
    static void F(C y)
    {
        A<C?> a = y;
        A<C> b = y;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void UnannotatedTypeArgument_Interface_Lookup()
        {
            var source0 =
@"public interface I<T>
{
    void F(T t);
}
public interface I1 : I<object>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"interface I2 : I<object>
{
}
class Program
{
    static void F(I1 i1, I2 i2, object x, object? y)
    {
        i1.F(x);
        i1.F(y);
        i2.F(x);
        i2.F(y); // warn
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,14): warning CS8604: Possible null reference argument for parameter 't' in 'void I<object>.F(object t)'.
                //         i2.F(y); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("t", "void I<object>.F(object t)").WithLocation(11, 14));
        }

        [Fact]
        public void UnannotatedTypeArgument_BaseType_Lookup()
        {
            var source0 =
@"public class A<T>
{
    public static void F(T t) { }
}
public class B1 : A<object>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B2 : A<object>
{
}
class Program
{
    static void F(object x, object? y)
    {
        B1.F(x);
        B1.F(y);
        B2.F(x);
        B2.F(y); // warn
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,14): warning CS8604: Possible null reference argument for parameter 't' in 'void A<object>.F(object t)'.
                //         B2.F(y); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("t", "void A<object>.F(object t)").WithLocation(11, 14));
        }

        [Fact]
        public void UnannotatedConstraint_01()
        {
            var source0 =
@"public class A1 { }
public class A2<T> { }
public class B1<T> where T : A1 { }
public class B2<T> where T : A2<object> { }";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class Program
{
    static void Main()
    {
        new B1<A1?>();
        new B1<A1>();
        new B2<A2<object?>>();
        new B2<A2<object>>();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
            var typeParameters = comp.GetMember<NamedTypeSymbol>("B1").TypeParameters;
            Assert.Equal("A1", typeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0].ToTestDisplayString(true));
            typeParameters = comp.GetMember<NamedTypeSymbol>("B2").TypeParameters;
            Assert.Equal("A2<System.Object>", typeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0].ToTestDisplayString(true));
        }

        [Fact]
        public void UnannotatedConstraint_02()
        {
            var source0 =
@"
public class A1 { }
public class A2<T> { }
" + NonNullTypesOff() + @"
public class B1<T, U> where T : A1 where U : A1? { }
" + NonNullTypesOff() + @"
public class B2<T, U> where T : A2<object> where U : A2<object?> { }";
            var comp0 = CreateCompilation(new[] { source0 });
            comp0.VerifyDiagnostics(
                // (5,48): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // public class B1<T, U> where T : A1 where U : A1? { }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 48),
                // (7,63): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // public class B2<T, U> where T : A2<object> where U : A2<object?> { }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(7, 63)
                );
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class Program
{
    static void Main()
    {
        new B1<A1, A1?>();
        new B1<A1?, A1>();
        new B2<A2<object>, A2<object?>>();
        new B2<A2<object?>, A2<object>>();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (8,29): warning CS8631: The type 'A2<object>' cannot be used as type parameter 'U' in the generic type or method 'B2<T, U>'. Nullability of type argument 'A2<object>' doesn't match constraint type 'A2<object?>'.
                //         new B2<A2<object?>, A2<object>>();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "A2<object>").WithArguments("B2<T, U>", "A2<object?>", "U", "A2<object>").WithLocation(8, 29));
            var typeParameters = comp.GetMember<NamedTypeSymbol>("B1").TypeParameters;
            Assert.Equal("A1", typeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0].ToTestDisplayString(true));
            Assert.Equal("A1?", typeParameters[1].ConstraintTypesNoUseSiteDiagnostics[0].ToTestDisplayString(true));
            typeParameters = comp.GetMember<NamedTypeSymbol>("B2").TypeParameters;
            Assert.Equal("A2<System.Object>", typeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0].ToTestDisplayString(true));
            Assert.Equal("A2<System.Object?>", typeParameters[1].ConstraintTypesNoUseSiteDiagnostics[0].ToTestDisplayString(true));
        }

        [Fact]
        public void UnannotatedConstraint_Override()
        {
            var source0 =
@"
public interface I<T> { }
public abstract class A<T> where T : class
{
" + NonNullTypesOff() + @"
    public abstract void F1<U>() where U : T, I<T>;
" + NonNullTypesOff() + @"
    public abstract void F2<U>() where U : T?, I<T?>;
" + NonNullTypesOn() + @"
    public abstract void F3<U>() where U : T, I<T>;
" + NonNullTypesOn() + @"
    public abstract void F4<U>() where U : T?, I<T?>;
}";
            var comp0 = CreateCompilation(new[] { source0 });
            comp0.VerifyDiagnostics(
                // (8,45): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract void F2<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 45),
                // (8,44): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public abstract void F2<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 44),
                // (8,51): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract void F2<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 51),
                // (8,50): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public abstract void F2<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 50),
                // (12,44): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public abstract void F4<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(12, 44),
                // (12,50): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public abstract void F4<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(12, 50)
                );

            var source =
@"
" + NonNullTypesOff() + @"
class B1 : A<string>
{
    public override void F1<U>() { }
    public override void F2<U>() { }
    public override void F3<U>() { }
    public override void F4<U>() { }
}
" + NonNullTypesOff() + @"
class B2 : A<string?>
{
    public override void F1<U>() { }
    public override void F2<U>() { }
    public override void F3<U>() { }
    public override void F4<U>() { }
}
" + NonNullTypesOn() + @"
class B3 : A<string>
{
    public override void F1<U>() { }
    public override void F2<U>() { }
    public override void F3<U>() { }
    public override void F4<U>() { }
}
" + NonNullTypesOn() + @"
class B4 : A<string?>
{
    public override void F1<U>() { }
    public override void F2<U>() { }
    public override void F3<U>() { }
    public override void F4<U>() { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { new CSharpCompilationReference(comp0) });
            comp.VerifyDiagnostics(
                // (11,20): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B2 : A<string?>
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 20)
                );
            verifyAllConstraintTypes();

            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            comp0.VerifyDiagnostics(
                // (8,45): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract void F2<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 45),
                // (8,51): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     public abstract void F2<U>() where U : T?, I<T?>;
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 51)
                );

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { new CSharpCompilationReference(comp0) });
            comp.VerifyDiagnostics(
                // (11,20): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B2 : A<string?>
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 20)
                );
            verifyAllConstraintTypes();

            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { comp0.EmitToImageReference() });
            comp.VerifyDiagnostics(
                // (11,20): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B2 : A<string?>
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(11, 20)
                );
            verifyAllConstraintTypes();

            void verifyAllConstraintTypes()
            {
                string bangOrEmpty = comp0.Options.NullableContextOptions == NullableContextOptions.Disable ? "" : "!";
                verifyConstraintTypes("B1.F1", "System.String", "I<System.String>");
                verifyConstraintTypes("B1.F2", "System.String?", "I<System.String?>");
                verifyConstraintTypes("B1.F3", "System.String" + bangOrEmpty, "I<System.String" + bangOrEmpty + ">!");
                verifyConstraintTypes("B1.F4", "System.String?", "I<System.String?>!");
                verifyConstraintTypes("B2.F1", "System.String?", "I<System.String?>");
                verifyConstraintTypes("B2.F2", "System.String?", "I<System.String?>");
                verifyConstraintTypes("B2.F3", "System.String?", "I<System.String?>!");
                verifyConstraintTypes("B2.F4", "System.String?", "I<System.String?>!");
                verifyConstraintTypes("B3.F1", "System.String!", "I<System.String!>");
                verifyConstraintTypes("B3.F2", "System.String?", "I<System.String?>");
                verifyConstraintTypes("B3.F3", "System.String!", "I<System.String!>!");
                verifyConstraintTypes("B3.F4", "System.String?", "I<System.String?>!");
                verifyConstraintTypes("B4.F1", "System.String?", "I<System.String?>");
                verifyConstraintTypes("B4.F2", "System.String?", "I<System.String?>");
                verifyConstraintTypes("B4.F3", "System.String?", "I<System.String?>!");
                verifyConstraintTypes("B4.F4", "System.String?", "I<System.String?>!");
            }

            void verifyConstraintTypes(string methodName, params string[] expectedTypes)
            {
                var constraintTypes = comp.GetMember<MethodSymbol>(methodName).TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics;
                AssertEx.Equal(expectedTypes, constraintTypes.SelectAsArray(t => t.ToTestDisplayString(true)));
            }
        }

        [Fact]
        public void Constraint_LocalFunction_01()
        {
            var source = @"
class C
{
" + NonNullTypesOn() + @"
    void M1()
    {
        local(new C(), new C(), new C(), null);
        void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
        {
            T? x = t;
            x!.ToString();
        }
    }
" + NonNullTypesOff() + @"
    void M2()
    {
        local(new C(), new C(), new C(), null);
        void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
        {
            T? x = t; // warn 1
            x!.ToString();
        }
    }
}";
            var comp = CreateCompilation(new[] { source });

            comp.VerifyDiagnostics(
                // (18,56): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 56),
                // (18,85): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 85),
                // (18,99): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(18, 99),
                // (18,98): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(18, 98),
                // (20,13): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //             T? x = t; // warn 1
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(20, 13),
                // (20,14): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //             T? x = t; // warn 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(20, 14)
                );
            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);

            var localSyntaxes = tree.GetRoot().DescendantNodes().OfType<LocalFunctionStatementSyntax>();

            verifyLocalFunction(localSyntaxes.ElementAt(0), "C.M1.local", new[] { "C!" });
            verifyLocalFunction(localSyntaxes.ElementAt(1), "C.M2.local", new[] { "C" });

            void verifyLocalFunction(LocalFunctionStatementSyntax localSyntax, string expectedName, string[] expectedConstraintTypes)
            {
                var localSymbol = (LocalFunctionSymbol)model.GetDeclaredSymbol(localSyntax);
                var constraintTypes = localSymbol.TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics;
                AssertEx.Equal(expectedConstraintTypes, constraintTypes.SelectAsArray(t => t.ToTestDisplayString(true)));
            }
        }

        [Fact]
        public void Constraint_LocalFunction_02()
        {
            var source = @"
class C
{
    void M3()
    {
        local(new C(), new C(), new C(), null);
        void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
        {
            T? x = t; // warn 2
            x!.ToString(); // warn 3
        }
    }
}";
            var comp = CreateCompilation(new[] { source });

            comp.VerifyDiagnostics(
                // (7,56): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(7, 56),
                // (7,85): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(7, 85),
                // (7,99): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(7, 99),
                // (7,98): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //         void local<T, T2, T3>(T t, T2 t2, T3 t3, string? s) where T : C where T2 : C? where T3 : T?
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(7, 98),
                // (9,14): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //             T? x = t; // warn 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 14),
                // (9,13): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //             T? x = t; // warn 2
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(9, 13)
                );
            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);

            var localSyntaxes = tree.GetRoot().DescendantNodes().OfType<LocalFunctionStatementSyntax>();

            verifyLocalFunction(localSyntaxes.ElementAt(0), "C.M3.local", new[] { "C" });

            void verifyLocalFunction(LocalFunctionStatementSyntax localSyntax, string expectedName, string[] expectedConstraintTypes)
            {
                var localSymbol = (LocalFunctionSymbol)model.GetDeclaredSymbol(localSyntax);
                var constraintTypes = localSymbol.TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics;
                AssertEx.Equal(expectedConstraintTypes, constraintTypes.SelectAsArray(t => t.ToTestDisplayString(true)));
            }
        }

        [Fact]
        public void Constraint_Oblivious_01()
        {
            var source0 =
@"public interface I<T>
{
}
public class A<T> where T : I<T>
{
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            var ref0 = comp0.EmitToImageReference();

            var source =
@"using System;
class B1 : I<B1> { }
class B2 : I<B2?> { }
class C
{
    static void Main()
    {
        Type t;
        t = typeof(A<B1>);
        t = typeof(A<B2>); // 1
        t = typeof(A<B1?>); // 2
        t = typeof(A<B2?>);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (10,22): warning CS8631: The type 'B2' cannot be used as type parameter 'T' in the generic type or method 'A<T>'. Nullability of type argument 'B2' doesn't match constraint type 'I<B2>'.
                //         t = typeof(A<B2>); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "B2").WithArguments("A<T>", "I<B2>", "T", "B2").WithLocation(10, 22),
                // (11,22): warning CS8631: The type 'B1?' cannot be used as type parameter 'T' in the generic type or method 'A<T>'. Nullability of type argument 'B1?' doesn't match constraint type 'I<B1?>'.
                //         t = typeof(A<B1?>); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "B1?").WithArguments("A<T>", "I<B1?>", "T", "B1?").WithLocation(11, 22));

            var constraintTypes = comp.GetMember<NamedTypeSymbol>("A").TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics;
            Assert.Equal("I<T>", constraintTypes[0].ToTestDisplayString(true));
        }

        [Fact]
        public void Constraint_Oblivious_02()
        {
            var source0 =
@"public class A<T, U, V>
    where T : A<T, U, V>
    where V : U
{
    protected interface I { }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B : A<B, object, object>
{
    static void F(I i)
    {
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Constraint_Oblivious_03()
        {
            var source0 =
@"public class A { }
public class B0<T> where T : A { }";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"#pragma warning disable 0169


class B1<T> where T : A? { }
class B2<T> where T : A { }
" + NonNullTypesOn() + @"
class B3<T> where T : A? { }
" + NonNullTypesOn() + @"
class B4<T> where T : A { }
" + NonNullTypesOff() + @"
class C
{
    B0<A?> F1; // 1
    B0<A> F2;
    B1<A?> F3; // 2
    B1<A> F4;
    B2<A?> F5; // 3
    B2<A> F6;
    B3<A?> F7; // 4
    B3<A> F8;
    B4<A?> F9; // 5 and 6
    B4<A> F10;
}
" + NonNullTypesOn() + @"
class D
{
    B0<A?> G1;
    B0<A> G2;
    B1<A?> G3;
    B1<A> G4;
    B2<A?> G5;
    B2<A> G6;
    B3<A?> G7;
    B3<A> G8;
    B4<A?> G9; // 7
    B4<A> G10;
}";
            var comp = CreateCompilation(new[] { source }, references: new[] { ref0 });
            comp.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_UninitializedNonNullableField).Verify(
                // (15,9): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B1<A?> F3; // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(15, 9),
                // (4,24): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B1<T> where T : A? { }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 24),
                // (17,9): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B2<A?> F5; // 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 9),
                // (19,9): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B3<A?> F7; // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(19, 9),
                // (35,12): warning CS8631: The type 'A?' cannot be used as type parameter 'T' in the generic type or method 'B4<T>'. Nullability of type argument 'A?' doesn't match constraint type 'A'.
                //     B4<A?> G9; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "G9").WithArguments("B4<T>", "A", "T", "A?").WithLocation(35, 12),
                // (21,9): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B4<A?> F9; // 5 and 6
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(21, 9),
                // (13,9): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B0<A?> F1; // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 9)
                );
        }

        [Fact]
        public void Constraint_Oblivious_04()
        {
            var source0 =
@"public class A<T> { }
public class B0<T> where T : A<object> { }";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"#pragma warning disable 0169


class B1<T> where T : A<object?> { }
class B2<T> where T : A<object> { }
" + NonNullTypesOn() + @"
class B3<T> where T : A<object?> { }
" + NonNullTypesOn() + @"
class B4<T> where T : A<object> { }
" + NonNullTypesOff() + @"
class C
{
    B0<A<object?>> F1; // 1
    B0<A<object>> F2;
    B1<A<object?>> F3; // 2
    B1<A<object>> F4;
    B2<A<object?>> F5; // 3
    B2<A<object>> F6;
    B3<A<object?>> F7; // 4
    B3<A<object>> F8;
    B4<A<object?>> F9; // 5 and 6
    B4<A<object>> F10;
}
" + NonNullTypesOn() + @"
class D
{
    B0<A<object?>> G1;
    B0<A<object>> G2;
    B1<A<object?>> G3;
    B1<A<object>> G4; // 7
    B2<A<object?>> G5;
    B2<A<object>> G6;
    B3<A<object?>> G7;
    B3<A<object>> G8; // 8
    B4<A<object?>> G9; // 9
    B4<A<object>> G10;
}";
            var comp = CreateCompilation(new[] { source }, references: new[] { ref0 });
            comp.GetDiagnostics().Where(d => d.Code != (int)ErrorCode.WRN_UninitializedNonNullableField).Verify(
                // (4,31): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B1<T> where T : A<object?> { }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 31),
                // (15,16): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B1<A<object?>> F3; // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(15, 16),
                // (17,16): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B2<A<object?>> F5; // 3
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(17, 16),
                // (19,16): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B3<A<object?>> F7; // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(19, 16),
                // (21,16): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B4<A<object?>> F9; // 5 and 6
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(21, 16),
                // (13,16): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     B0<A<object?>> F1; // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(13, 16),
                // (30,19): warning CS8631: The type 'A<object>' cannot be used as type parameter 'T' in the generic type or method 'B1<T>'. Nullability of type argument 'A<object>' doesn't match constraint type 'A<object?>'.
                //     B1<A<object>> G4; // 7
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "G4").WithArguments("B1<T>", "A<object?>", "T", "A<object>").WithLocation(30, 19),
                // (34,19): warning CS8631: The type 'A<object>' cannot be used as type parameter 'T' in the generic type or method 'B3<T>'. Nullability of type argument 'A<object>' doesn't match constraint type 'A<object?>'.
                //     B3<A<object>> G8; // 8
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "G8").WithArguments("B3<T>", "A<object?>", "T", "A<object>").WithLocation(34, 19),
                // (35,20): warning CS8631: The type 'A<object?>' cannot be used as type parameter 'T' in the generic type or method 'B4<T>'. Nullability of type argument 'A<object?>' doesn't match constraint type 'A<object>'.
                //     B4<A<object?>> G9; // 9
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "G9").WithArguments("B4<T>", "A<object>", "T", "A<object?>").WithLocation(35, 20)
                );
        }

        [Fact]
        public void Constraint_TypeParameterConstraint()
        {
            var source0 =
@"public class A1<T, U>
    where T : class
    where U : class, T
{
}
public class A2<T, U>
    where T : class
    where U : class, T?
{
}";
            var comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"
class B1<T> where T : A1<T, T?> { } // 1
class B2<T> where T : A2<T?, T> { } // 2
" + NonNullTypesOn() + @"
class B3<T> where T : A1<T, T?> { }
" + NonNullTypesOn() + @"
class B4<T> where T : A2<T?, T> { }";
            var comp = CreateCompilation(new[] { source }, references: new[] { ref0 });

            comp.VerifyDiagnostics(
                // (2,30): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B1<T> where T : A1<T, T?> { } // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(2, 30),
                // (2,29): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class B1<T> where T : A1<T, T?> { } // 1
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(2, 29),
                // (3,27): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // class B2<T> where T : A2<T?, T> { } // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(3, 27),
                // (3,26): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // class B2<T> where T : A2<T?, T> { } // 2
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(3, 26)
                );
        }

        // Boxing conversion.
        [Fact]
        public void Constraint_BoxingConversion()
        {
            var source0 =
@"public interface I<T> { }
public interface IIn<in T> { }
public interface IOut<out T> { }
public struct S0 : I<object> { }
public struct SIn0 : IIn<object> { }
public struct SOut0 : IOut<object> { }
public class A
{
    public static void F0<T>() where T : I<object> { }
    public static void FIn0<T>() where T : IIn<object> { }
    public static void FOut0<T>() where T : IOut<object> { }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"struct S1 : I<object?> { }
struct S2 : I<object> { }
struct SIn1 : IIn<object?> { }
struct SIn2 : IIn<object> { }
struct SOut1 : IOut<object?> { }
struct SOut2 : IOut<object> { }
class B : A
{
    static void F1<T>() where T : I<object?> { }
    static void F2<T>() where T : I<object> { }
    static void FIn1<T>() where T : IIn<object?> { }
    static void FIn2<T>() where T : IIn<object> { }
    static void FOut1<T>() where T : IOut<object?> { }
    static void FOut2<T>() where T : IOut<object> { }
    static void F()
    {
        F0<S0>();
        F0<S1>();
        F0<S2>();
        F1<S0>();
        F1<S1>();
        F1<S2>(); // 1
        F2<S0>();
        F2<S1>(); // 2
        F2<S2>();
    }
    static void FIn()
    {
        FIn0<SIn0>();
        FIn0<SIn1>();
        FIn0<SIn2>();
        FIn1<SIn0>();
        FIn1<SIn1>();
        FIn1<SIn2>(); // 3
        FIn2<SIn0>();
        FIn2<SIn1>();
        FIn2<SIn2>();
    }
    static void FOut()
    {
        FOut0<SOut0>();
        FOut0<SOut1>();
        FOut0<SOut2>();
        FOut1<SOut0>();
        FOut1<SOut1>();
        FOut1<SOut2>();
        FOut2<SOut0>();
        FOut2<SOut1>(); // 4
        FOut2<SOut2>();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (22,9): warning CS8627: The type 'S2' cannot be used as type parameter 'T' in the generic type or method 'B.F1<T>()'. Nullability of type argument 'S2' doesn't match constraint type 'I<object?>'.
                //         F1<S2>(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F1<S2>").WithArguments("B.F1<T>()", "I<object?>", "T", "S2").WithLocation(22, 9),
                // (24,9): warning CS8627: The type 'S1' cannot be used as type parameter 'T' in the generic type or method 'B.F2<T>()'. Nullability of type argument 'S1' doesn't match constraint type 'I<object>'.
                //         F2<S1>(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F2<S1>").WithArguments("B.F2<T>()", "I<object>", "T", "S1").WithLocation(24, 9),
                // (34,9): warning CS8627: The type 'SIn2' cannot be used as type parameter 'T' in the generic type or method 'B.FIn1<T>()'. Nullability of type argument 'SIn2' doesn't match constraint type 'IIn<object?>'.
                //         FIn1<SIn2>(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "FIn1<SIn2>").WithArguments("B.FIn1<T>()", "IIn<object?>", "T", "SIn2").WithLocation(34, 9),
                // (48,9): warning CS8627: The type 'SOut1' cannot be used as type parameter 'T' in the generic type or method 'B.FOut2<T>()'. Nullability of type argument 'SOut1' doesn't match constraint type 'IOut<object>'.
                //         FOut2<SOut1>(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "FOut2<SOut1>").WithArguments("B.FOut2<T>()", "IOut<object>", "T", "SOut1").WithLocation(48, 9));
        }

        [Fact]
        public void Constraint_ImplicitTypeParameterConversion()
        {
            var source0 =
@"public interface I<T> { }
public interface IIn<in T> { }
public interface IOut<out T> { }
public class A
{
    public static void F0<T>() where T : I<object> { }
    public static void FIn0<T>() where T : IIn<object> { }
    public static void FOut0<T>() where T : IOut<object> { }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class B : A
{
    static void F1<T>() where T : I<object?> { }
    static void F2<T>() where T : I<object> { }
    static void FIn1<T>() where T : IIn<object?> { }
    static void FIn2<T>() where T : IIn<object> { }
    static void FOut1<T>() where T : IOut<object?> { }
    static void FOut2<T>() where T : IOut<object> { }
    static void F<T, U>() where T : I<object?> where U : I<object>
    {
        F0<T>();
        F0<U>();
        F1<T>();
        F1<U>(); // 1
        F2<T>(); // 2
        F2<U>();
    }
    static void FIn<T, U>() where T : IIn<object?> where U : IIn<object>
    {
        FIn0<T>();
        FIn0<U>();
        FIn1<T>();
        FIn1<U>(); // 3
        FIn2<T>();
        FIn2<U>();
    }
    static void FOut<T, U>() where T : IOut<object?> where U : IOut<object>
    {
        FOut0<T>();
        FOut0<U>();
        FOut1<T>();
        FOut1<U>();
        FOut2<T>(); // 4
        FOut2<U>();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (14,9): warning CS8627: The type 'U' cannot be used as type parameter 'T' in the generic type or method 'B.F1<T>()'. Nullability of type argument 'U' doesn't match constraint type 'I<object?>'.
                //         F1<U>(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F1<U>").WithArguments("B.F1<T>()", "I<object?>", "T", "U").WithLocation(14, 9),
                // (15,9): warning CS8627: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'B.F2<T>()'. Nullability of type argument 'T' doesn't match constraint type 'I<object>'.
                //         F2<T>(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F2<T>").WithArguments("B.F2<T>()", "I<object>", "T", "T").WithLocation(15, 9),
                // (23,9): warning CS8627: The type 'U' cannot be used as type parameter 'T' in the generic type or method 'B.FIn1<T>()'. Nullability of type argument 'U' doesn't match constraint type 'IIn<object?>'.
                //         FIn1<U>(); // 3
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "FIn1<U>").WithArguments("B.FIn1<T>()", "IIn<object?>", "T", "U").WithLocation(23, 9),
                // (33,9): warning CS8627: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'B.FOut2<T>()'. Nullability of type argument 'T' doesn't match constraint type 'IOut<object>'.
                //         FOut2<T>(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "FOut2<T>").WithArguments("B.FOut2<T>()", "IOut<object>", "T", "T").WithLocation(33, 9));
        }

        [Fact]
        public void Constraint_MethodTypeInference()
        {
            var source0 =
@"public class A { }
public class B
{
    public static void F0<T>(T t) where T : A
    {
    }
}";
            var comp0 = CreateCompilation(source0, parseOptions: TestOptions.Regular7);
            comp0.VerifyDiagnostics();
            var ref0 = comp0.EmitToImageReference();

            var source =
@"class C : B
{
    static void F1<T>(T t) where T : A
    {
    }
    static void G(A x, A? y)
    {
        F0(x);
        F1(x);
        F0(y);
        F1(y); // 1
        x = y;
        F0(x);
        F1(x); // 2
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue(), references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (11,9): warning CS8631: The type 'A?' cannot be used as type parameter 'T' in the generic type or method 'C.F1<T>(T)'. Nullability of type argument 'A?' doesn't match constraint type 'A'.
                //         F1(y); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F1").WithArguments("C.F1<T>(T)", "A", "T", "A?").WithLocation(11, 9),
                // (12,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = y;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(12, 13),
                // (14,9): warning CS8631: The type 'A?' cannot be used as type parameter 'T' in the generic type or method 'C.F1<T>(T)'. Nullability of type argument 'A?' doesn't match constraint type 'A'.
                //         F1(x); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "F1").WithArguments("C.F1<T>(T)", "A", "T", "A?").WithLocation(14, 9));
        }

        [Fact]
        [WorkItem(29999, "https://github.com/dotnet/roslyn/issues/29999")]
        public void ThisAndBaseMemberInLambda()
        {
            var source =
@"delegate void D();
class A
{
    internal string? F;
}
class B : A
{
    void M()
    {
        D d;
        d = () =>
        {
            int n = this.F.Length; // 1
            this.F = string.Empty;
            n = this.F.Length;
        };
        d = () =>
        {
            int n = base.F.Length; // 2
            base.F = string.Empty;
            n = base.F.Length;
        };
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,21): warning CS8602: Possible dereference of a null reference.
                //             int n = this.F.Length; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "this.F").WithLocation(13, 21),
                // (19,21): warning CS8602: Possible dereference of a null reference.
                //             int n = base.F.Length; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "base.F").WithLocation(19, 21));
        }

        [Fact]
        [WorkItem(29999, "https://github.com/dotnet/roslyn/issues/29999")]
        public void ThisAndBaseMemberInLocalFunction()
        {
            var source =
@"#pragma warning disable 8321
class A
{
    internal string? F;
}
class B : A
{
    void M()
    {
        void f()
        {
            int n = this.F.Length; // 1
            this.F = string.Empty;
            n = this.F.Length;
        }
        void g()
        {
            int n = base.F.Length; // 2
            base.F = string.Empty;
            n = base.F.Length;
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,21): warning CS8602: Possible dereference of a null reference.
                //             int n = this.F.Length; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "this.F").WithLocation(12, 21),
                // (18,21): warning CS8602: Possible dereference of a null reference.
                //             int n = base.F.Length; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "base.F").WithLocation(18, 21));
        }

        [WorkItem(31620, "https://github.com/dotnet/roslyn/issues/31620")]
        [Fact]
        public void InstanceMemberInLambda()
        {
            var source =
@"using System;
class Program
{
    private object? _f;
    private object _g = null!;
    private void F()
    {
        Func<bool, object> f = (bool b1) =>
        {
            Func<bool, object> g = (bool b2) =>
            {
                if (b2)
                {
                    _g = null; // 1
                    return _g; // 2
                }
                return _g;
            };
            if (b1) return _f; // 3
            _f = new object();
            return _f;
        };
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,26): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //                     _g = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(14, 26),
                // (15,28): warning CS8603: Possible null reference return.
                //                     return _g; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "_g").WithLocation(15, 28),
                // (19,28): warning CS8603: Possible null reference return.
                //             if (b1) return _f; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "_f").WithLocation(19, 28));
        }

        [WorkItem(31620, "https://github.com/dotnet/roslyn/issues/31620")]
        [Fact]
        public void InstanceMemberInLocalFunction()
        {
            var source =
@"#pragma warning disable 8321
class Program
{
    private object? _f;
    private object _g = null!;
    private void F()
    {
        object f(bool b1)
        {
            if (b1) return _f; // 1
            _f = new object();
            return _f;
            object g(bool b2)
            {
                if (b2)
                {
                    _g = null; // 2
                    return _g; // 3
                }
                return _g;
            }
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,28): warning CS8603: Possible null reference return.
                //             if (b1) return _f; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "_f").WithLocation(10, 28),
                // (17,26): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //                     _g = null; // 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(17, 26),
                // (18,28): warning CS8603: Possible null reference return.
                //                     return _g; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "_g").WithLocation(18, 28));
        }

        [WorkItem(29049, "https://github.com/dotnet/roslyn/issues/29049")]
        [Fact]
        public void TypeSymbolWithAnnotations_GetHashCode()
        {
            var source =
@"interface I<T> { }
class A : I<A> { }
class B<T> where T : I<A?> { }
class Program
{
    static void Main()
    {
        new B<A>();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            var diagnostics = comp.GetDiagnostics();
            diagnostics.Verify(
                // (8,15): warning CS8631: The type 'A' cannot be used as type parameter 'T' in the generic type or method 'B<T>'. Nullability of type argument 'A' doesn't match constraint type 'I<A?>'.
                //         new B<A>();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "A").WithArguments("B<T>", "I<A?>", "T", "A").WithLocation(8, 15));
            // Diagnostics must support GetHashCode() and Equals(), to allow removing
            // duplicates (see CommonCompiler.ReportErrors).
            foreach (var diagnostic in diagnostics)
            {
                diagnostic.GetHashCode();
                Assert.True(diagnostic.Equals(diagnostic));
            }
        }

        [WorkItem(29041, "https://github.com/dotnet/roslyn/issues/29041")]
        [WorkItem(29048, "https://github.com/dotnet/roslyn/issues/29048")]
        [WorkItem(30001, "https://github.com/dotnet/roslyn/issues/30001")]
        [Fact]
        public void ConstraintCyclesFromMetadata_01()
        {
            var source0 =
@"using System;
public class A0<T> where T : IEquatable<T> { }
public class A1<T> where T : class, IEquatable<T> { }

public class A3<T> where T : struct, IEquatable<T> { }
public class A4<T> where T : struct, IEquatable<T?> { }
public class A5<T> where T : IEquatable<string?> { }
public class A6<T> where T : IEquatable<int?> { }";
            var source =
@"class B
{
    static void Main()
    {
        new A0<string?>(); // 1
        new A0<string>();


        new A5<string?>(); // 4
        new A5<string>(); // 5
    }
}";
            // No [NullNullTypes]
            var comp0 = CreateCompilation(source0);
            var ref0 = comp0.EmitToImageReference();
            var comp = CreateCompilation(source, references: new[] { ref0 });

            var expectedDiagnostics = new[]
            {
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A0<string?>(); // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22),
                // (9,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A5<string?>(); // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 22)
            };

            comp.VerifyDiagnostics(expectedDiagnostics);
            verifyTypeParameterConstraint("A0", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A1", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A3", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A4", "System.IEquatable<T?>");
            verifyTypeParameterConstraint("A5", "System.IEquatable<System.String?>");
            verifyTypeParameterConstraint("A6", "System.IEquatable<System.Int32?>");

            // [NullNullTypes(false)]
            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesFalse());
            ref0 = comp0.EmitToImageReference();
            comp = CreateCompilation(source, references: new[] { ref0 });
            comp.VerifyDiagnostics(expectedDiagnostics);
            verifyTypeParameterConstraint("A0", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A1", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A3", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A4", "System.IEquatable<T?>");
            verifyTypeParameterConstraint("A5", "System.IEquatable<System.String?>");
            verifyTypeParameterConstraint("A6", "System.IEquatable<System.Int32?>");

            // [NullNullTypes(true)]
            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            ref0 = comp0.EmitToImageReference();

            comp = CreateCompilation(source, references: new[] { ref0 });
            comp.VerifyDiagnostics(
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A0<string?>(); // 1
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22),
                // (9,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A5<string?>(); // 4
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(9, 22)
                );
            verifyTypeParameterConstraint("A0", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A1", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A3", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A4", "System.IEquatable<T?>");
            verifyTypeParameterConstraint("A5", "System.IEquatable<System.String?>");
            verifyTypeParameterConstraint("A6", "System.IEquatable<System.Int32?>");

            comp = CreateCompilation(source, references: new[] { ref0 }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,16): warning CS8631: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'A0<T>'. Nullability of type argument 'string?' doesn't match constraint type 'System.IEquatable<string?>'.
                //         new A0<string?>(); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "string?").WithArguments("A0<T>", "System.IEquatable<string?>", "T", "string?").WithLocation(5, 16),
                // (9,16): warning CS8631: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'A5<T>'. Nullability of type argument 'string?' doesn't match constraint type 'System.IEquatable<string?>'.
                //         new A5<string?>(); // 4
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "string?").WithArguments("A5<T>", "System.IEquatable<string?>", "T", "string?").WithLocation(9, 16)
                );
            verifyTypeParameterConstraint("A0", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A1", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A3", "System.IEquatable<T>");
            verifyTypeParameterConstraint("A4", "System.IEquatable<T?>");
            verifyTypeParameterConstraint("A5", "System.IEquatable<System.String?>");
            verifyTypeParameterConstraint("A6", "System.IEquatable<System.Int32?>");

            void verifyTypeParameterConstraint(string typeName, string expected)
            {
                var type = comp.GetMember<NamedTypeSymbol>(typeName);
                var constraintType = type.TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0];
                Assert.Equal(expected, constraintType.ToTestDisplayString());
            }
        }

        [WorkItem(29041, "https://github.com/dotnet/roslyn/issues/29041")]
        [WorkItem(29048, "https://github.com/dotnet/roslyn/issues/29048")]
        [WorkItem(30003, "https://github.com/dotnet/roslyn/issues/30003")]
        [Fact]
        public void ConstraintCyclesFromMetadata_02()
        {
            var source0 =
@"using System;
public class A2<T> where T : class, IEquatable<T?> { }
";
            var source =
@"class B
{
    static void Main()
    {
        new A2<string?>(); // 2
        new A2<string>(); // 3
    }
}";
            // No [NullNullTypes]
            var comp0 = CreateCompilation(source0);
            comp0.VerifyDiagnostics(
                // (2,48): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // public class A2<T> where T : class, IEquatable<T?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(2, 48),
                // (2,49): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // public class A2<T> where T : class, IEquatable<T?> { }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(2, 49)
                );

            MetadataReference ref0 = comp0.ToMetadataReference();
            var comp = CreateCompilation(source, references: new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/30003: Should report a nullability mismatch warning for A2<string>().
            comp.VerifyDiagnostics(
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A2<string?>(); // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22)
                );
            verifyTypeParameterConstraint("A2", "System.IEquatable<T?>");

            // [NullNullTypes(false)]
            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesFalse());
            comp0.VerifyDiagnostics(
                // (2,48): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                // public class A2<T> where T : class, IEquatable<T?> { }
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(2, 48),
                // (2,49): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                // public class A2<T> where T : class, IEquatable<T?> { }
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(2, 49)
                );
            ref0 = comp0.ToMetadataReference();
            comp = CreateCompilation(source, references: new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/30003: Should report same warnings as other two cases.
            comp.VerifyDiagnostics(
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A2<string?>(); // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22)
                );
            verifyTypeParameterConstraint("A2", "System.IEquatable<T?>");

            // [NullNullTypes(true)]
            comp0 = CreateCompilation(new[] { source0 }, options: WithNonNullTypesTrue());
            ref0 = comp0.EmitToImageReference();

            comp = CreateCompilation(source, references: new[] { ref0 });
            // https://github.com/dotnet/roslyn/issues/30003: Should report a nullability mismatch warning for A2<string>().
            comp.VerifyDiagnostics(
                // (5,22): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //         new A2<string?>(); // 2
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(5, 22)
                );
            verifyTypeParameterConstraint("A2", "System.IEquatable<T?>");

            comp = CreateCompilation(source, references: new[] { ref0 }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,16): warning CS8634: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'A2<T>'. Nullability of type argument 'string?' doesn't match 'class' constraint.
                //         new A2<string?>(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "string?").WithArguments("A2<T>", "T", "string?").WithLocation(5, 16),
                // (5,16): warning CS8631: The type 'string?' cannot be used as type parameter 'T' in the generic type or method 'A2<T>'. Nullability of type argument 'string?' doesn't match constraint type 'System.IEquatable<string?>'.
                //         new A2<string?>(); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "string?").WithArguments("A2<T>", "System.IEquatable<string?>", "T", "string?").WithLocation(5, 16)
                );
            verifyTypeParameterConstraint("A2", "System.IEquatable<T?>");

            void verifyTypeParameterConstraint(string typeName, string expected)
            {
                var type = comp.GetMember<NamedTypeSymbol>(typeName);
                var constraintType = type.TypeParameters[0].ConstraintTypesNoUseSiteDiagnostics[0];
                Assert.Equal(expected, constraintType.ToTestDisplayString());
            }
        }

        [WorkItem(29186, "https://github.com/dotnet/roslyn/issues/29186")]
        [Fact]
        public void AttributeArgumentCycle_OtherAttribute()
        {
            var source =
@"using System;
class AAttribute : Attribute
{
    internal AAttribute(object o) { }
}
interface IA { }
interface IB<T> where T : IA { }
[A(typeof(IB<IA>))]
class C
{
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics();
            comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(30178, "https://github.com/dotnet/roslyn/issues/30178")]
        public void GenericSubstitution_01()
        {
            var source =
@"


" + NonNullTypesOn() + @"
class A<T1, T2> where T1 : class where T2 : class
{
    T1 F;

" + NonNullTypesOff() + @"
    class B : A<T1, T2>
    {
" + NonNullTypesOn() + @"
        void M1()
        {
            F = null; // 1
        }
    }

    void M2()
    {
        F = null; // 2
    }

" + NonNullTypesOff() + @"
    class C : A<C, C>
    {
" + NonNullTypesOn() + @"
        void M3()
        {
            F = null; // 3
        }
    }

" + NonNullTypesOff() + @"
    class D : A<T1, D>
    {
" + NonNullTypesOn() + @"
        void M4()
        {
            F = null; // 4
        }
    }

" + NonNullTypesOff() + @"
    class E : A<T2, T2>
    {
" + NonNullTypesOn() + @"
        void M5()
        {
            F = null; // 5
        }
    }
}
";
            var comp = CreateCompilation(new[] { source });

            comp.VerifyDiagnostics(
                // (5,7): warning CS8618: Non-nullable field 'F' is uninitialized.
                // class A<T1, T2> where T1 : class where T2 : class
                Diagnostic(ErrorCode.WRN_UninitializedNonNullableField, "A").WithArguments("field", "F").WithLocation(5, 7),
                // (7,8): warning CS0414: The field 'A<T1, T2>.F' is assigned but its value is never used
                //     T1 F;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "F").WithArguments("A<T1, T2>.F").WithLocation(7, 8),
                // (15,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(15, 17),
                // (21,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F = null; // 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(21, 13),
                // (30,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(30, 17),
                // (40,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(40, 17),
                // (50,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(50, 17)
                );

            var b = comp.GetTypeByMetadataName("A`2+B");
            Assert.NotNull(b);
            Assert.True(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        [WorkItem(30177, "https://github.com/dotnet/roslyn/issues/30177")]
        [WorkItem(30178, "https://github.com/dotnet/roslyn/issues/30178")]
        public void GenericSubstitution_02()
        {
            var source =
@"


" + NonNullTypesOff() + @"
class A<T1, T2> where T1 : class where T2 : class
{
" + NonNullTypesOn() + @"
    T1 F;

" + NonNullTypesOn() + @"
    class B : A<T1, T2>
    {
        void M1()
        {
            F = null; // 1
        }
    }

" + NonNullTypesOn() + @"
    void M2()
    {
        F = null; // 2
    }

" + NonNullTypesOn() + @"
    class C : A<C, C>
    {
        void M3()
        {
            F = null; // 3
        }
    }

" + NonNullTypesOn() + @"
    class D : A<T1, D>
    {
        void M4()
        {
            F = null; // 4
        }
    }

" + NonNullTypesOn() + @"
    class E : A<T2, T2>
    {
        void M5()
        {
            F = null; // 5
        }
    }
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (8,8): warning CS0414: The field 'A<T1, T2>.F' is assigned but its value is never used
                //     T1 F;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "F").WithArguments("A<T1, T2>.F").WithLocation(8, 8),
                // (15,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(15, 17),
                // (22,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         F = null; // 2
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(22, 13),
                // (30,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(30, 17),
                // (39,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(39, 17),
                // (48,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(48, 17)
                );

            var b = comp.GetTypeByMetadataName("A`2+B");
            Assert.NotNull(b);
            Assert.False(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        public void GenericSubstitution_03()
        {
            var source =
NonNullTypesOff() + @"
class A<T> where T : class
{
    class B : A<T>
    {}
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();

            var b = comp.GetTypeByMetadataName("A`1+B");
            Assert.NotNull(b);
            Assert.True(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        [WorkItem(30178, "https://github.com/dotnet/roslyn/issues/30178")]
        public void GenericSubstitution_04()
        {
            var source =
NonNullTypesOn() + @"
class A<T> where T : class
{
    class B : A<T>
    {}
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics();

            var b = comp.GetTypeByMetadataName("A`1+B");
            Assert.NotNull(b);
            Assert.False(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        [WorkItem(30178, "https://github.com/dotnet/roslyn/issues/30178")]
        public void GenericSubstitution_05()
        {
            var source =
@"


" + NonNullTypesOn() + @"
class A<T1, T2> where T1 : class where T2 : class
{
" + NonNullTypesOff() + @"
    T1 F;
" + NonNullTypesOn() + @"
    class B : A<T1, T2>
    {
        void M1()
        {
            F = null; // 1
        }
    }

    void M2()
    {
        F = null; // 2
    }

    class C : A<C, C>
    {
        void M3()
        {
            F = null; // 3
        }
    }

    class D : A<T1, D>
    {
        void M1()
        {
            F = null; // 4
        }
    }

    class E : A<T2, T2>
    {
        void M1()
        {
            F = null; // 5
        }
    }
}
";
            var comp = CreateCompilation(new[] { source });

            comp.VerifyDiagnostics(
                // (8,8): warning CS0414: The field 'A<T1, T2>.F' is assigned but its value is never used
                //     T1 F;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "F").WithArguments("A<T1, T2>.F").WithLocation(8, 8),
                // (14,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(14, 17),
                // (27,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(27, 17),
                // (35,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(35, 17),
                // (43,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(43, 17)
                );

            var b = comp.GetTypeByMetadataName("A`2+B");
            Assert.NotNull(b);
            Assert.False(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        [WorkItem(30177, "https://github.com/dotnet/roslyn/issues/30177")]
        [WorkItem(30178, "https://github.com/dotnet/roslyn/issues/30178")]
        public void GenericSubstitution_06()
        {
            var source =
@"


" + NonNullTypesOff() + @"
class A<T1, T2> where T1 : class where T2 : class
{
    T1 F;

" + NonNullTypesOn() + @"
    class B : A<T1, T2>
    {
        void M1()
        {
            F = null; // 1
        }
    }

" + NonNullTypesOn() + @"
    void M2()
    {
        F = null; // 2
    }

" + NonNullTypesOn() + @"
    class C : A<C, C>
    {
        void M3()
        {
            F = null; // 3
        }
    }

" + NonNullTypesOn() + @"
    class D : A<T1, D>
    {
        void M3()
        {
            F = null; // 4
        }
    }

" + NonNullTypesOn() + @"
    class E : A<T2, T2>
    {
        void M3()
        {
            F = null; // 5
        }
    }
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (7,8): warning CS0414: The field 'A<T1, T2>.F' is assigned but its value is never used
                //     T1 F;
                Diagnostic(ErrorCode.WRN_UnreferencedFieldAssg, "F").WithArguments("A<T1, T2>.F").WithLocation(7, 8),
                // (14,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(14, 17),
                // (29,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(29, 17),
                // (38,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 4
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(38, 17),
                // (47,17): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //             F = null; // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(47, 17)
                );

            var b = comp.GetTypeByMetadataName("A`2+B");
            Assert.NotNull(b);
            Assert.False(b.BaseTypeNoUseSiteDiagnostics.IsDefinition);
        }

        [Fact]
        [WorkItem(30171, "https://github.com/dotnet/roslyn/issues/30171")]
        public void NonNullTypesContext_01()
        {
            var source =
@"
using System.Runtime.CompilerServices;

class A
{
" + NonNullTypesOff() + @"
    B[] F1;

" + NonNullTypesOn() + @"
    C[] F2;
}

class B {}
class C {}
";
            var comp = CreateCompilation(new[] { source });


            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("B[]", f1.Type.ToTestDisplayString(includeNonNullable: true));

            var f2 = comp.GetMember<FieldSymbol>("A.F2");
            Assert.Equal("C![]!", f2.Type.ToTestDisplayString(includeNonNullable: true));

            var tree = comp.SyntaxTrees.First();
            var model = comp.GetSemanticModel(tree);
            var arrays = tree.GetRoot().DescendantNodes().OfType<ArrayTypeSyntax>().ToArray();

            Assert.Equal(2, arrays.Length);

            Assert.Equal("B[]", model.GetTypeInfo(arrays[0]).Type.ToTestDisplayString(includeNonNullable: true));
            Assert.Equal("C![]", model.GetTypeInfo(arrays[1]).Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_02()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
#nullable enable
    B
#nullable disable
      F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B!", f1.Type.ToTestDisplayString(includeNonNullable: true));
            }
        }

        [Fact]
        public void NonNullTypesContext_03()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
#nullable disable
    B
#nullable enable
      F1;
}

class B {}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("B", f1.Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_04()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    B
#nullable enable
     ?
       F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B?", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void NonNullTypesContext_05()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    B
#nullable disable
     ?
       F1;
}

class B {}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("B?", f1.Type.ToTestDisplayString(includeNonNullable: true));

            comp.VerifyDiagnostics(
                // (8,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //      ?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 6)
                );
        }

        [Fact]
        public void NonNullTypesContext_06()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
#nullable enable
    string
#nullable disable
      F1;
}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("System.String!", f1.Type.ToTestDisplayString(includeNonNullable: true));
            }
        }

        [Fact]
        public void NonNullTypesContext_07()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
#nullable disable
    string
#nullable enable
      F1;
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("System.String", f1.Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_08()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    B[
#nullable enable
      ]
#nullable disable
        F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B[]!", f1.Type.ToTestDisplayString(includeNonNullable: true));
            }
        }

        [Fact]
        public void NonNullTypesContext_09()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    B[
#nullable disable
      ]
#nullable enable
        F1;
}

class B {}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("B![]", f1.Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_10()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    (B, B
#nullable enable
         )
#nullable disable
           F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal(NullableAnnotation.NotAnnotated, f1.Type.NullableAnnotation);
            }
        }

        [Fact]
        public void NonNullTypesContext_11()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    (B, B
#nullable disable
         )
#nullable enable
           F1;
}

class B {}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal(NullableAnnotation.Unknown, f1.Type.NullableAnnotation);
        }

        [Fact]
        public void NonNullTypesContext_12()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    B<A
#nullable enable
       >
#nullable disable
         F1;
}

class B<T> {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B<A>!", f1.Type.ToTestDisplayString(includeNonNullable: true));
            }
        }

        [Fact]
        public void NonNullTypesContext_13()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    B<A
#nullable disable
       >
#nullable enable
         F1;
}

class B<T> {}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("B<A!>", f1.Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_14()
        {
            var source =
@"
class A
{
    void M<T>(out T x){}

    void Test()
    {
        M(out 
#nullable enable
              var
#nullable disable
                  local);
    }
}

class var {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var tree = comp.SyntaxTrees.Single();
                var model = comp.GetSemanticModel(tree);

                var decl = tree.GetRoot().DescendantNodes().OfType<DeclarationExpressionSyntax>().Single();
                Assert.Equal("var!", ((LocalSymbol)model.GetDeclaredSymbol(decl.Designation)).Type.ToTestDisplayString(includeNonNullable: true));
            }
        }

        [Fact]
        public void NonNullTypesContext_15()
        {
            var source =
@"
class A
{
    void M<T>(out T x){}

    void Test()
    {
        M(out 
#nullable disable
              var
#nullable enable
                  local);
    }
}

class var {}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            var decl = tree.GetRoot().DescendantNodes().OfType<DeclarationExpressionSyntax>().Single();
            Assert.Equal("var", ((LocalSymbol)model.GetDeclaredSymbol(decl.Designation)).Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_16()
        {
            var source =
@"
class A<T> where T :
#nullable enable
    class
#nullable disable
{
}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var a = comp.GetTypeByMetadataName("A`1");
                Assert.Equal("A<T> where T : class!", a.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints.WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.IncludeNonNullableTypeModifier)));
            }
        }

        [Fact]
        public void NonNullTypesContext_17()
        {
            var source =
@"
class A<T> where T :
#nullable disable
    class
#nullable enable
{
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var a = comp.GetTypeByMetadataName("A`1");
            Assert.Equal("A<T> where T : class", a.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints.WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.IncludeNonNullableTypeModifier)));
        }

        [Fact]
        public void NonNullTypesContext_18()
        {
            var source =
@"
class A<T> where T : class
#nullable enable
    ?
#nullable disable
{
}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var a = comp.GetTypeByMetadataName("A`1");
                Assert.Equal("A<T> where T : class?", a.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints.WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.IncludeNonNullableTypeModifier)));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void NonNullTypesContext_19()
        {
            var source =
@"
class A<T> where T : class
#nullable disable
    ?
#nullable enable
{
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var a = comp.GetTypeByMetadataName("A`1");
            Assert.Equal("A<T> where T : class?", a.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints.WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.IncludeNonNullableTypeModifier)));

            comp.VerifyDiagnostics(
                // (4,5): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                //     ?
                Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(4, 5)
                );
        }

        [Fact]
        public void NonNullTypesContext_20()
        {
            var source =
@"
class A<T> where T :
#nullable enable
    unmanaged
#nullable disable
{
}

class unmanaged {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var a = comp.GetTypeByMetadataName("A`1");
                Assert.Equal("A<T> where T : unmanaged!", a.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints.WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.IncludeNonNullableTypeModifier)));
            }
        }

        [Fact]
        public void NonNullTypesContext_21()
        {
            var source =
@"
class A<T> where T :
#nullable disable
    unmanaged
#nullable enable
{
}

class unmanaged {}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var a = comp.GetTypeByMetadataName("A`1");
            Assert.Equal("A<T> where T : unmanaged", a.ToDisplayString(SymbolDisplayFormat.TestFormatWithConstraints.WithCompilerInternalOptions(SymbolDisplayCompilerInternalOptions.IncludeNonNullableTypeModifier)));
        }

        [Fact]
        public void NonNullTypesContext_22()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string b;
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
A<string>
"
            );

            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.Enable, type, "A<System.String!>");
            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.SafeOnly, type, "A<System.String!>");
        }

        private static void AssertGetSpeculativeTypeInfo(string source, NullableContextOptions nullableContextOptions, TypeSyntax type, string expected)
        {
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypes(nullableContextOptions));

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            var decl = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();

            Assert.Equal(expected,
                         model.GetSpeculativeTypeInfo(decl.Identifier.SpanStart, type, SpeculativeBindingOption.BindAsTypeOrNamespace).Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_23()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string b;
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
A<string>
"
            );

            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.Disable, type, "A<System.String>");
            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.Warnings, type, "A<System.String>");
            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.SafeOnlyWarnings, type, "A<System.String>");
        }

        [Fact]
        public void NonNullTypesContext_24()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string b;
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
#nullable disable
A<string>
"
            );

            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.Enable, type, "A<System.String>");
            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.SafeOnly, type, "A<System.String>");
        }

        [Fact]
        public void NonNullTypesContext_25()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string b;
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
#nullable enable
A<string>
"
            );

            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.Disable, type, "A<System.String!>");
            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.Warnings, type, "A<System.String!>");
            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.SafeOnlyWarnings, type, "A<System.String!>");
        }

        [Fact]
        public void NonNullTypesContext_26()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string 
#nullable disable
               b;
#nullable enable
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
A<string>
"
            );

            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.Enable, type, "A<System.String>");
            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.SafeOnly, type, "A<System.String>");
        }

        [Fact]
        public void NonNullTypesContext_27()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string 
#nullable enable
               b;
#nullable disable
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
A<string>
"
            );

            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.Disable, type, "A<System.String!>");
            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.Warnings, type, "A<System.String!>");
            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.SafeOnlyWarnings, type, "A<System.String!>");
        }

        [Fact]
        public void NonNullTypesContext_28()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string 
#nullable disable
               b;
#nullable enable
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
#nullable enable
A<string>
"
            );

            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.Enable, type, "A<System.String!>");
            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.SafeOnly, type, "A<System.String!>");
        }

        [Fact]
        public void NonNullTypesContext_29()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string 
#nullable enable
               b;
#nullable disable
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
#nullable disable
A<string>
"
            );

            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.Disable, type, "A<System.String>");
            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.Warnings, type, "A<System.String>");
            AssertGetSpeculativeTypeInfo(source, NullableContextOptions.SafeOnlyWarnings, type, "A<System.String>");
        }

        [Fact]
        public void NonNullTypesContext_30()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string b;
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
A<string>
"
            );

            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.Enable, type, "A<System.String!>");
            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.SafeOnly, type, "A<System.String!>");
        }

        private static void AssertTryGetSpeculativeSemanticModel(string source, NullableContextOptions nullableContextOptions, TypeSyntax type, string expected)
        {
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypes(nullableContextOptions));

            var tree = comp.SyntaxTrees.Single();
            var model = comp.GetSemanticModel(tree);

            var decl = tree.GetRoot().DescendantNodes().OfType<VariableDeclaratorSyntax>().Single();

            Assert.True(model.TryGetSpeculativeSemanticModel(decl.Identifier.SpanStart, type, out model, SpeculativeBindingOption.BindAsTypeOrNamespace));
            Assert.Equal(expected,
                         model.GetTypeInfo(type).Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_31()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string b;
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
A<string>
"
            );

            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.Disable, type, "A<System.String>");
            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.Warnings, type, "A<System.String>");
            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.SafeOnlyWarnings, type, "A<System.String>");
        }

        [Fact]
        public void NonNullTypesContext_32()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string b;
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
#nullable disable
A<string>
"
            );

            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.Enable, type, "A<System.String>");
            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.SafeOnly, type, "A<System.String>");
        }

        [Fact]
        public void NonNullTypesContext_33()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string b;
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
#nullable enable
A<string>
"
            );

            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.Disable, type, "A<System.String!>");
            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.Warnings, type, "A<System.String!>");
            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.SafeOnlyWarnings, type, "A<System.String!>");
        }

        [Fact]
        public void NonNullTypesContext_34()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string 
#nullable disable
               b;
#nullable enable
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
A<string>
"
            );

            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.Enable, type, "A<System.String>");
            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.SafeOnly, type, "A<System.String>");
        }

        [Fact]
        public void NonNullTypesContext_35()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string 
#nullable enable
               b;
#nullable disable
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
A<string>
"
            );

            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.Disable, type, "A<System.String!>");
            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.Warnings, type, "A<System.String!>");
            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.SafeOnlyWarnings, type, "A<System.String!>");
        }

        [Fact]
        public void NonNullTypesContext_36()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string 
#nullable disable
               b;
#nullable enable
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
#nullable enable
A<string>
"
            );

            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.Enable, type, "A<System.String!>");
            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.SafeOnly, type, "A<System.String!>");
        }

        [Fact]
        public void NonNullTypesContext_37()
        {
            var source =
@"
#pragma warning disable CS0169

class A<T>
{
    void Tests()
    {
        string 
#nullable enable
               b;
#nullable disable
    }
}
";
            TypeSyntax type = SyntaxFactory.ParseTypeName(
@"
#nullable disable
A<string>
"
            );

            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.Disable, type, "A<System.String>");
            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.Warnings, type, "A<System.String>");
            AssertTryGetSpeculativeSemanticModel(source, NullableContextOptions.SafeOnlyWarnings, type, "A<System.String>");
        }

        [Fact]
        public void NonNullTypesContext_38()
        {
            var source =
@"
using B = C;
#pragma warning disable CS0169

class A
{
#nullable enable
    B
#nullable disable
      F1;
}

class C {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("C!", f1.Type.ToTestDisplayString(includeNonNullable: true));
            }
        }

        [Fact]
        public void NonNullTypesContext_39()
        {
            var source =
@"
using B = C;
#pragma warning disable CS0169

class A
{
#nullable disable
    B
#nullable enable
      F1;
}

class C {}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("C", f1.Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_40()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    C.
#nullable enable
    B
#nullable disable
      F1;
}

namespace C
{
    class B {}
}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("C.B!", f1.Type.ToTestDisplayString(includeNonNullable: true));
            }
        }

        [Fact]
        public void NonNullTypesContext_41()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    C.
#nullable disable
    B
#nullable enable
      F1;
}

namespace C
{
    class B {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("C.B", f1.Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_42()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    C.B<A
#nullable enable
       >
#nullable disable
         F1;
}

namespace C
{
    class B<T> {}
}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("C.B<A>!", f1.Type.ToTestDisplayString(includeNonNullable: true));
            }
        }

        [Fact]
        public void NonNullTypesContext_43()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    C.B<A
#nullable disable
       >
#nullable enable
         F1;
}

namespace C
{
    class B<T> {}
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());

            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("C.B<A!>", f1.Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_44()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
#nullable safeonly
    B
#nullable disable
      F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B!", f1.Type.ToTestDisplayString(includeNonNullable: true));
            }
        }

        [Fact]
        public void NonNullTypesContext_45()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
#nullable disable
    B
#nullable safeonly
      F1;
}

class B {}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypes(NullableContextOptions.SafeOnly));

            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("B", f1.Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_46()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    B
#nullable safeonly
     ?
       F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B?", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void NonNullTypesContext_47()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    B F1;
}

class B {}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypes(NullableContextOptions.SafeOnly));

            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("B!", f1.Type.ToTestDisplayString(includeNonNullable: true));
        }

        [Fact]
        public void NonNullTypesContext_48()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    B? F1;
}

class B {}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypes(NullableContextOptions.SafeOnly));

            var f1 = comp.GetMember<FieldSymbol>("A.F1");
            Assert.Equal("B?", f1.Type.ToTestDisplayString(includeNonNullable: true));

            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NonNullTypesContext_49()
        {
            var source =
@"
#pragma warning disable CS0169
#nullable enable
class A
{
    B
#nullable restore
     ?
#nullable enable
       F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B?", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics(
                    // (8,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                    //      ?
                    Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 6)
                    );
            }
        }

        [Fact]
        public void NonNullTypesContext_50()
        {
            var source =
@"
#pragma warning disable CS0169
#nullable safeonly
class A
{
    B
#nullable restore
     ?
#nullable safeonly
       F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B?", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics(
                    // (8,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                    //      ?
                    Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 6)
                    );
            }
        }

        [Fact]
        public void NonNullTypesContext_51()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    B
#nullable restore
     ?
       F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B?", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics(
                    // (8,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                    //      ?
                    Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 6)
                    );
            }
        }

        [Fact]
        public void NonNullTypesContext_52()
        {
            var source =
@"
#pragma warning disable CS0169
#nullable disable
class A
{
    B
#nullable restore
     ?
#nullable enable
       F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B?", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics(
                    // (8,6): warning CS8632: The annotation for nullable reference types should only be used in code within a '#nullable' context.
                    //      ?
                    Diagnostic(ErrorCode.WRN_MissingNonNullTypesContextForAnnotation, "?").WithLocation(8, 6)
                    );
            }
        }

        [Fact]
        public void NonNullTypesContext_53()
        {
            var source =
@"
#pragma warning disable CS0169
#nullable enable
class A
{
#nullable restore
    B
#nullable enable
      F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void NonNullTypesContext_54()
        {
            var source =
@"
#pragma warning disable CS0169
#nullable safeonly
class A
{
#nullable restore
    B
#nullable safeonly
       F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void NonNullTypesContext_55()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
#nullable restore
    B F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void NonNullTypesContext_56()
        {
            var source =
@"
#pragma warning disable CS0169
#nullable disable
class A
{
#nullable restore
    B
#nullable enable
       F1;
}

class B {}
";
            assertNonNullTypesContext(NullableContextOptions.Disable);
            assertNonNullTypesContext(NullableContextOptions.Warnings);
            assertNonNullTypesContext(NullableContextOptions.SafeOnlyWarnings);

            void assertNonNullTypesContext(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);
                var comp = CreateCompilation(new[] { source }, options: compilationOptions);

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void NonNullTypesContext_57()
        {
            var source =
@"
#pragma warning disable CS0169
#nullable disable
class A
{
    B
#nullable restore
     ?
#nullable disable
       F1;
}

class B {}
";
            assertType(NullableContextOptions.Enable);
            assertType(NullableContextOptions.SafeOnly);

            void assertType(NullableContextOptions nullableContextOptions)
            {
                var comp = CreateCompilation(new[] { source }, options: WithNonNullTypes(nullableContextOptions));

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B?", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void NonNullTypesContext_58()
        {
            var source =
@"
#pragma warning disable CS0169
#nullable disable
class A
{
    B
#nullable restore
     ?
#nullable disable
       F1;
}

class B {}
";
            assertType(NullableContextOptions.Enable);
            assertType(NullableContextOptions.SafeOnly);

            void assertType(NullableContextOptions nullableContextOptions)
            {
                var comp = CreateCompilation(new[] { source }, options: WithNonNullTypes(nullableContextOptions));

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B?", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void NonNullTypesContext_59()
        {
            var source =
@"
#pragma warning disable CS0169

class A
{
    B
#nullable restore
     ?
       F1;
}

class B {}
";
            assertType(NullableContextOptions.Enable);
            assertType(NullableContextOptions.SafeOnly);

            void assertType(NullableContextOptions nullableContextOptions)
            {
                var comp = CreateCompilation(new[] { source }, options: WithNonNullTypes(nullableContextOptions));

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B?", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void NonNullTypesContext_60()
        {
            var source =
@"
#pragma warning disable CS0169
#nullable enable
class A
{
    B
#nullable restore
     ?
#nullable disable
       F1;
}

class B {}
";
            assertType(NullableContextOptions.Enable);
            assertType(NullableContextOptions.SafeOnly);

            void assertType(NullableContextOptions nullableContextOptions)
            {
                var comp = CreateCompilation(new[] { source }, options: WithNonNullTypes(nullableContextOptions));

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B?", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void NonNullTypesContext_61()
        {
            var source =
@"
#pragma warning disable CS0169
#nullable disable
class A
{
#nullable restore
    B
#nullable disable
      F1;
}

class B {}
";
            assertType(NullableContextOptions.Enable);
            assertType(NullableContextOptions.SafeOnly);

            void assertType(NullableContextOptions nullableContextOptions)
            {
                var comp = CreateCompilation(new[] { source }, options: WithNonNullTypes(nullableContextOptions));

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B!", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void NonNullTypesContext_62()
        {
            var source =
@"
#pragma warning disable CS0169
#pragma warning disable CS8618

class A
{
#nullable restore
    B F1;
}

class B {}
";
            assertType(NullableContextOptions.Enable);
            assertType(NullableContextOptions.SafeOnly);

            void assertType(NullableContextOptions nullableContextOptions)
            {
                var comp = CreateCompilation(new[] { source }, options: WithNonNullTypes(nullableContextOptions));

                var f1 = comp.GetMember<FieldSymbol>("A.F1");
                Assert.Equal("B!", f1.Type.ToTestDisplayString(includeNonNullable: true));

                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        [WorkItem(30214, "https://github.com/dotnet/roslyn/issues/30214")]
        public void ObliviousTypeParameter_01()
        {
            var source =
$@"
#pragma warning disable {(int)ErrorCode.WRN_UninitializedNonNullableField}
#pragma warning disable {(int)ErrorCode.WRN_UnreferencedField}
#pragma warning disable {(int)ErrorCode.WRN_UnreferencedFieldAssg}
#pragma warning disable {(int)ErrorCode.WRN_UnreferencedVarAssg}
"
+
@"


" + NonNullTypesOff() + @"
class A<T1, T2, T3> where T2 : class where T3 : object
{
    T1 F1;
    T2 F2;
    T3 F3;
    B F4;

" + NonNullTypesOn() + @"
    void M1()
    {
        F1 = default;
        F2 = default;
        F3 = default;
        F4 = default;
    }

" + NonNullTypesOn() + @"
    void M2()
    {
        T1 x2 = default;
        T2 y2 = default;
        T3 z2 = default;
    }

" + NonNullTypesOn() + @"
    void M3()
    {
        C.Test<T1>();
        C.Test<T2>();
        C.Test<T3>();
    }

" + NonNullTypesOn() + @"
    void M4()
    {
        D.Test(F1);
        D.Test(F2);
        D.Test(F3);
        D.Test(F4);
    }
}

class B {}

" + NonNullTypesOn() + @"
class C
{
    public static void Test<T>() where T : object
    {}
}

" + NonNullTypesOn() + @"
class D
{
    public static void Test<T>(T x) where T : object
    {}
}
";
            var comp = CreateCompilation(new[] { source });
            comp.VerifyDiagnostics(
                // (29,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T1 x2 = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(29, 17),
                // (30,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T2 y2 = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(30, 17),
                // (31,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T3 z2 = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(31, 17),
                // (37,9): warning CS8631: The type 'T1' cannot be used as type parameter 'T' in the generic type or method 'C.Test<T>()'. Nullability of type argument 'T1' doesn't match constraint type 'object'.
                //         C.Test<T1>();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "C.Test<T1>").WithArguments("C.Test<T>()", "object", "T", "T1").WithLocation(37, 9),
                // (38,9): warning CS8631: The type 'T2' cannot be used as type parameter 'T' in the generic type or method 'C.Test<T>()'. Nullability of type argument 'T2' doesn't match constraint type 'object'.
                //         C.Test<T2>();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "C.Test<T2>").WithArguments("C.Test<T>()", "object", "T", "T2").WithLocation(38, 9),
                // (39,9): warning CS8631: The type 'T3' cannot be used as type parameter 'T' in the generic type or method 'C.Test<T>()'. Nullability of type argument 'T3' doesn't match constraint type 'object'.
                //         C.Test<T3>();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "C.Test<T3>").WithArguments("C.Test<T>()", "object", "T", "T3").WithLocation(39, 9)
                );
        }

        [Fact]
        [WorkItem(30220, "https://github.com/dotnet/roslyn/issues/30220")]
        public void ObliviousTypeParameter_02()
        {
            var source =
$@"
#pragma warning disable {(int)ErrorCode.WRN_UnreferencedVar}
"
+
@"


" + NonNullTypesOn() + @"
class A<T1> where T1 : class
{
" + NonNullTypesOff() + @"
    class B<T2> where T2 : T1
    {
    }

" + NonNullTypesOn() + @"
    void M1()
    {
        B<T1> a1;
        B<T1?> b1;
        A<T1>.B<T1> c1;
        A<T1>.B<T1?> d1;
        A<C>.B<C> e1;
        A<C>.B<C?> f1;
    }
}

class C {}
";
            var comp = CreateCompilation(new[] { source });

            comp.VerifyDiagnostics(
                // (20,17): warning CS8631: The type 'T1?' cannot be used as type parameter 'T2' in the generic type or method 'A<T1>.B<T2>'. Nullability of type argument 'T1?' doesn't match constraint type 'T1'.
                //         A<T1>.B<T1?> d1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "T1?").WithArguments("A<T1>.B<T2>", "T1", "T2", "T1?").WithLocation(20, 17),
                // (22,16): warning CS8631: The type 'C?' cannot be used as type parameter 'T2' in the generic type or method 'A<C>.B<T2>'. Nullability of type argument 'C?' doesn't match constraint type 'C'.
                //         A<C>.B<C?> f1;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "C?").WithArguments("A<C>.B<T2>", "C", "T2", "C?").WithLocation(22, 16)
                );
        }

        [WorkItem(23270, "https://github.com/dotnet/roslyn/issues/23270")]
        [Fact]
        public void NotNullAfterDereference_00()
        {
            var source =
@"class Program
{
    static void M(object? obj)
    {
        obj.F();
        obj.ToString(); // 1
        obj.ToString();
    }
}
static class E
{
    internal static void F(this object? obj) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         obj.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "obj").WithLocation(6, 9));
        }

        [WorkItem(23270, "https://github.com/dotnet/roslyn/issues/23270")]
        [Fact]
        public void NotNullAfterDereference_01()
        {
            var source =
@"class Program
{
    static void F(object? x)
    {
        x.ToString(); // 1
        object? y;
        y.ToString();
        y = null;
        y.ToString(); // 2
        x.ToString();
        y.ToString();
        x = y;
        if (y != null)
        {
            x.ToString();
        }
        x.ToString();
        y.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(5, 9),
                // (7,9): error CS0165: Use of unassigned local variable 'y'
                //         y.ToString();
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y").WithArguments("y").WithLocation(7, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 9),
                // (13,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (y != null)
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "y != null").WithLocation(13, 13));
        }

        [Fact]
        public void NotNullAfterDereference_02()
        {
            var source =
@"class Program
{
    static void F<T>(T x)
    {
        x.ToString(); // 1
        T y;
        y.ToString();
        y = default;
        y.ToString(); // 2
        x.ToString();
        y.ToString();
        x = y;
        if (y != null)
        {
            x.ToString();
        }
        x.ToString();
        y.ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(5, 9),
                // (7,9): error CS0165: Use of unassigned local variable 'y'
                //         y.ToString();
                Diagnostic(ErrorCode.ERR_UseDefViolation, "y").WithArguments("y").WithLocation(7, 9),
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(8, 13),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 9),
                // (13,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (y != null)
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "y != null").WithLocation(13, 13));
        }

        [Fact]
        public void NotNullAfterDereference_03()
        {
            var source =
@"class C
{
    void F1(C x) { }
    static void G1(C? x)
    {
        x?.F1(x);
        x!.F1(x);
        x.F1(x);
    }
    static void G2(C? y)
    {
        y?.F2(y);
        y!.F2(y); // 3
        y.F2(y); // 4, 5
    }
}
static class E
{
    internal static void F2(this C x, C y) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,15): warning CS8604: Possible null reference argument for parameter 'y' in 'void E.F2(C x, C y)'.
                //         y!.F2(y); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("y", "void E.F2(C x, C y)").WithLocation(13, 15),
                // (14,9): warning CS8604: Possible null reference argument for parameter 'x' in 'void E.F2(C x, C y)'.
                //         y.F2(y); // 4, 5
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("x", "void E.F2(C x, C y)").WithLocation(14, 9),
                // (14,14): warning CS8604: Possible null reference argument for parameter 'y' in 'void E.F2(C x, C y)'.
                //         y.F2(y); // 4, 5
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("y", "void E.F2(C x, C y)").WithLocation(14, 14));
        }

        [Fact]
        public void NotNullAfterDereference_04()
        {
            var source =
@"class Program
{
    static void F<T>(bool b, string? s)
    {
        int n;
        if (b)
        {
            n = s/*T:string?*/.Length; // 1
            n = s/*T:string!*/.Length;
            
        }
        n = b ? s/*T:string?*/.Length + // 2
            s/*T:string!*/.Length : 0;
        n = s/*T:string?*/.Length; // 3
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,17): warning CS8602: Possible dereference of a null reference.
                //             n = s/*T:string?*/.Length; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 17),
                // (12,17): warning CS8602: Possible dereference of a null reference.
                //         n = b ? s/*T:string?*/.Length + // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(12, 17),
                // (14,13): warning CS8602: Possible dereference of a null reference.
                //         n = s/*T:string?*/.Length; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(14, 13));
            comp.VerifyTypes();
        }

        [Fact]
        public void NotNullAfterDereference_05()
        {
            var source =
@"class Program
{
    static void F(string? s)
    {
        int n;
        try
        {
            n = s/*T:string?*/.Length; // 1
            try
            {
                n = s/*T:string!*/.Length;
            }
            finally
            {
                n = s/*T:string!*/.Length;
            }
        }
        catch (System.IO.IOException)
        {
            n = s/*T:string?*/.Length; // 2
        }
        catch
        {
            n = s/*T:string?*/.Length; // 3
        }
        finally
        {
            n = s/*T:string?*/.Length; // 4
        }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,17): warning CS8602: Possible dereference of a null reference.
                //             n = s/*T:string?*/.Length; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(8, 17),
                // (20,17): warning CS8602: Possible dereference of a null reference.
                //             n = s/*T:string?*/.Length; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(20, 17),
                // (24,17): warning CS8602: Possible dereference of a null reference.
                //             n = s/*T:string?*/.Length; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(24, 17),
                // (28,17): warning CS8602: Possible dereference of a null reference.
                //             n = s/*T:string?*/.Length; // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(28, 17));
            comp.VerifyTypes();
        }

        [Fact]
        public void NotNullAfterDereference_06()
        {
            var source =
@"class C
{
    object F = default!;
    static void G(C? c)
    {
        c.F = c;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // One warning only, rather than one warning for dereference of c.F
            // and another warning for assignment c.F = c.
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         c.F = c;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(6, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Call()
        {
            var source =
@"#pragma warning disable 0649
class C
{
    object? y;
    void F(object? o)
    {
    }
    static void G(C? x)
    {
        x.F(x = null); // 1
        x.F(x.y); // 2, 3
        x.F(x.y);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for x.F(x.y).
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         x.F(x = null); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x.F(x.y); // 2, 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(11, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Array()
        {
            var source =
@"class Program
{
    static int F(object? o) => 0;
    static void G(object[]? x, object[] y)
    {
        object z;
        z = x[F(x = null)]; // 1
        z = x[x.Length]; // 2, 3
        z = x[x.Length];
        y[F(y = null)] = 1;
        y[y.Length] = 2; // 4, 5
        y[y.Length] = 3;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for x[x.Length] and y[y.Length].
            comp.VerifyDiagnostics(
                // (7,13): warning CS8602: Possible dereference of a null reference.
                //         z = x[F(x = null)]; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 13),
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //         z = x[x.Length]; // 2, 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13),
                // (10,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y[F(y = null)] = 1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(10, 17),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         y[y.Length] = 2; // 4, 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(11, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Indexer()
        {
            var source =
@"#pragma warning disable 0649
class C
{
    object? F;
    object this[object? o]
    {
        get { return 1; }
        set { }
    }
    static void G(C? x, C y)
    {
        object z;
        z = x[x = null]; // 1
        z = x[x.F]; // 2, 3
        z = x[x.F];
        y[y = null] = 1;
        y[y.F] = 2; // 4, 5
        y[y.F] = 3;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for x[x.F] and y[y.F].
            comp.VerifyDiagnostics(
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //         z = x[x = null]; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(13, 13),
                // (14,13): warning CS8602: Possible dereference of a null reference.
                //         z = x[x.F]; // 2, 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(14, 13),
                // (16,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y[y = null] = 1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(16, 15),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         y[y.F] = 2; // 4, 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(17, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Field()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class C
{
    object? F;
    static object? G(object? o) => o;
    static void M(C? x, C? y)
    {
        object? o;
        o = x.F; // 1
        o = x.F;
        y.F = G(y = null); // 2
        y.F = G(y.F); // 3, 4
        y.F = G(y.F);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for y.F = G(y.F).
            comp.VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //         o = x.F; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 13),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         y.F = G(y = null); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.F = G(y.F); // 3, 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(13, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Property()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class C
{
    object? P { get; set; }
    static object? F(object? o) => o;
    static void M(C? x, C? y)
    {
        object? o;
        o = x.P; // 1
        o = x.P;
        y.P = F(y = null); // 2
        y.P = F(y.P); // 3, 4
        y.P = F(y.P);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for y.P = F(y.P).
            comp.VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //         o = x.F; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 13),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         y.F = G(y = null); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.F = G(y.F); // 3, 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(13, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Event()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
delegate void D();
class C
{
    event D E;
    D F;
    static D G(C? c) => throw null;
    static void M(C? x, C? y, C? z)
    {
        x.E(); // 1
        x.E();
        y.E += G(y = null); // 2
        y.E += y.F; // 3, 4
        y.E += y.F;
        y.E();
        z.E = null; // 5
        z.E();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for y.E += y.F.
            comp.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x.E(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(11, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.E += G(y = null); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(13, 9),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         y.E += y.F; // 3, 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(14, 9),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         z.E = null; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(17, 9),
                // (17,15): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         z.E = null; // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(17, 15),
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         z.E();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z.E").WithLocation(18, 9));
        }

        [Fact]
        public void NotNullAfterDereference_Dynamic()
        {
            var source =
@"class Program
{
    static void F(dynamic? d)
    {
        d.ToString(); // 1
        d.ToString();
    }
    static void G(dynamic? x, dynamic? y)
    {
        object z;
        z = x[x = null]; // 2
        z = x[x.F]; // 3, 4
        z = x[x.F];
        y[y = null] = 1;
        y[y.F] = 2; // 5, 6
        y[y.F] = 3;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30598: Should report two warnings for x[x.F] and y[y.F].
            comp.VerifyDiagnostics(
                // (5,9): warning CS8602: Possible dereference of a null reference.
                //         d.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "d").WithLocation(5, 9),
                // (11,13): warning CS8602: Possible dereference of a null reference.
                //         z = x[x = null]; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(11, 13),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //         z = x[x.F]; // 3, 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(12, 13),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         y[y = null] = 1;
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(14, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         y[y.F] = 2; // 5, 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(15, 9));
        }

        [WorkItem(30563, "https://github.com/dotnet/roslyn/issues/30563")]
        [Fact]
        public void NotNullAfterDereference_MethodGroup_01()
        {
            var source =
@"delegate void D();
class C
{
    void F1() { }
    static void F(C? x, C? y)
    {
        D d;
        d = x.F1; // warning
        d = y.F2; // ok
    }
}
static class E
{
    internal static void F2(this C? c) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30563: Should not report "CS8602: Possible dereference" for y.F2.
            comp.VerifyDiagnostics(
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //         d = x.F1; // warning
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(8, 13),
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //         d = y.F2; // ok
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 13));
        }

        [WorkItem(30563, "https://github.com/dotnet/roslyn/issues/30563")]
        [Fact]
        public void NotNullAfterDereference_MethodGroup_02()
        {
            var source =
@"delegate void D1(int i);
delegate void D2();
class C
{
    void F(int i) { }
    static void F1(D1 d) { }
    static void F2(D2 d) { }
    static void G(C? x, C? y)
    {
        F1(x.F); // 1
        F1(x.F);
        F2(y.F); // 2
        F2(y.F); // 3
    }
}
static class E
{
    internal static void F(this C x) { }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30563: Should not report "CS8602: Possible dereference"
            // for F2(y.F). Should report "CS8604: Possible null reference argument" instead.
            comp.VerifyDiagnostics(
                // (10,12): warning CS8602: Possible dereference of a null reference.
                //         F1(x.F); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(10, 12),
                // (12,12): warning CS8602: Possible dereference of a null reference.
                //         F2(y.F); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(12, 12));
        }

        [WorkItem(30562, "https://github.com/dotnet/roslyn/issues/30562")]
        [Fact]
        public void NotNullAfterDereference_ForEach()
        {
            var source =
@"class Enumerable
{
    public System.Collections.IEnumerator GetEnumerator() => throw null;
}
class Program
{
    static void F1(object[]? x1, object[]? y1)
    {
        foreach (var x in x1) { } // 1
    }
    static void F2(object[]? x1, object[]? y1)
    {
        foreach (var x in x1) { }
    }
    static void F3(object[]? x1, object[]? y1)
    {
        foreach (var y in y1) { } // 2
    }
    static void F4(object[]? x1, object[]? y1)
    {
        y1.GetEnumerator();
    }
    static void F5(Enumerable? x2, Enumerable? y2)
    {
        foreach (var x in x2) { } // 3
    }
    static void F6(Enumerable? x2, Enumerable? y2)
    {
        foreach (var x in x2) { }
    }
    static void F7(Enumerable? x2, Enumerable? y2)
    {
        y2.GetEnumerator(); // 4
        foreach (var y in y2) { }
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/30562: Should not report second warning in each case.
            comp.VerifyDiagnostics(
                // (9,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in x1) { } // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(9, 27),
                // (13,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in x1) { }
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(13, 27),
                // (17,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var y in y1) { } // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y1").WithLocation(17, 27),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         y1.GetEnumerator();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y1").WithLocation(21, 9),
                // (25,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in x2) { } // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(25, 27),
                // (29,27): warning CS8602: Possible dereference of a null reference.
                //         foreach (var x in x2) { }
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(29, 27),
                // (33,9): warning CS8602: Possible dereference of a null reference.
                //         y2.GetEnumerator(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y2").WithLocation(33, 9));
        }

        [Fact]
        public void SpecialAndWellKnownMemberLookup()
        {
            var source0 =
@"
namespace System
{
    public class Object { }
    public abstract class ValueType { }
    public struct Void { }
    public struct Int32 { }
    public class Type { }
    public struct Boolean { }
    public struct Enum { }
    public class Attribute { }

    public struct Nullable<T>
    {
        public static implicit operator Nullable<T>(T x)
        {
            throw null;
        }
        public static explicit operator T(Nullable<T> x)
        {
            throw null;
        }
    }

    namespace Collections.Generic
    {
        public class EqualityComparer<T>
        {
            public static EqualityComparer<T> Default => throw null;
        }
    }
}
";
            var comp = CreateEmptyCompilation(new[] { source0 }, options: WithNonNullTypesTrue());

            var implicitOp = comp.GetSpecialTypeMember(SpecialMember.System_Nullable_T__op_Implicit_FromT);
            var explicitOp = comp.GetSpecialTypeMember(SpecialMember.System_Nullable_T__op_Explicit_ToT);
            var getDefault = comp.GetWellKnownTypeMember(WellKnownMember.System_Collections_Generic_EqualityComparer_T__get_Default);

            Assert.NotNull(implicitOp);
            Assert.NotNull(explicitOp);
            Assert.NotNull(getDefault);

            Assert.True(implicitOp.IsDefinition);
            Assert.True(explicitOp.IsDefinition);
            Assert.True(getDefault.IsDefinition);
        }

        [Fact]
        public void ExpressionTrees_ByRefDynamic()
        {
            string source = @"
using System;
using System.Linq.Expressions;
 
class Program
{
    static void Main()
    {
        Expression<Action<dynamic>> e = x => Goo(ref x);
    }
 
    static void Goo<T>(ref T x) { }
}
";
            CompileAndVerify(source, targetFramework: TargetFramework.StandardAndCSharp, options: WithNonNullTypesTrue());
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        public void TestErrorsImplementingGenericNestedInterfaces_Explicit()
        {
            var text = @"
using System.Collections.Generic;
class Outer<T>
{
    internal class Inner<U>
    {
        protected internal interface Interface<V, W>
        {
            T Property { set; }
            void Method<Z>(T a, U[] b, List<V> c, Dictionary<W, Z> d);
        }
        internal class Derived4
        {
            internal class Derived5 : Outer<T>.Inner<U>.Interface<U, T>
            {
                T Outer<T>.Inner<U>.Interface<U, T>.Property
                {
                    set { }
                }
                void Inner<U>.Interface<U, T>.Method<K>(T a, U[] b, List<U> c, Dictionary<K, T> D)
                {
                }
            }
            internal class Derived6 : Outer<T>.Inner<U>.Interface<U, T>
            {
                T Outer<T>.Inner<U>.Interface<U, T>.Property
                {
                    set { }
                }
                void Inner<U>.Interface<U, T>.Method<K>(T a, U[] b, List<U> c, Dictionary<T, K> D)
                {
                }
            }
        }
    }
}
";

            // https://github.com/dotnet/roslyn/issues/30677, https://github.com/dotnet/roslyn/issues/30673 - The following errors are unexpected:
            // (20,22): error CS0540: 'Outer<T>.Inner<U>.Derived4.Derived5.Method<K>(T, U[], List<U>, Dictionary<K, T>)': containing type does not implement interface 'Outer<T>.Inner<U>.Interface<U, T>'
            // (30,22): error CS0540: 'Outer<T>.Inner<U>.Derived4.Derived6.Outer<T>.Inner<U>.Interface<U, T>.Method<K>(T, U[], List<U>, Dictionary<T, K>)': containing type does not implement interface 'Outer<T>.Inner<U>.Interface<U, T>'
            CreateCompilation(text, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (14,39): error CS0535: 'Outer<T>.Inner<U>.Derived4.Derived5' does not implement interface member 'Outer<T>.Inner<U>.Interface<U, T>.Method<Z>(T, U[], List<U>, Dictionary<T, Z>)'
                //             internal class Derived5 : Outer<T>.Inner<U>.Interface<U, T>
                Diagnostic(ErrorCode.ERR_UnimplementedInterfaceMember, "Outer<T>.Inner<U>.Interface<U, T>").WithArguments("Outer<T>.Inner<U>.Derived4.Derived5", "Outer<T>.Inner<U>.Interface<U, T>.Method<Z>(T, U[], System.Collections.Generic.List<U>, System.Collections.Generic.Dictionary<T, Z>)").WithLocation(14, 39),
                // (20,22): error CS0540: 'Outer<T>.Inner<U>.Derived4.Derived5.Method<K>(T, U[], List<U>, Dictionary<K, T>)': containing type does not implement interface 'Outer<T>.Inner<U>.Interface<U, T>'
                //                 void Inner<U>.Interface<U, T>.Method<K>(T a, U[] b, List<U> c, Dictionary<K, T> D)
                Diagnostic(ErrorCode.ERR_ClassDoesntImplementInterface, "Inner<U>.Interface<U, T>").WithArguments("Outer<T>.Inner<U>.Derived4.Derived5.Method<K>(T, U[], System.Collections.Generic.List<U>, System.Collections.Generic.Dictionary<K, T>)", "Outer<T>.Inner<U>.Interface<U, T>").WithLocation(20, 22),
                // (20,47): error CS0539: 'Outer<T>.Inner<U>.Derived4.Derived5.Method<K>(T, U[], List<U>, Dictionary<K, T>)' in explicit interface declaration is not a member of interface
                //                 void Inner<U>.Interface<U, T>.Method<K>(T a, U[] b, List<U> c, Dictionary<K, T> D)
                Diagnostic(ErrorCode.ERR_InterfaceMemberNotFound, "Method").WithArguments("Outer<T>.Inner<U>.Derived4.Derived5.Method<K>(T, U[], System.Collections.Generic.List<U>, System.Collections.Generic.Dictionary<K, T>)").WithLocation(20, 47),
                // (30,22): error CS0540: 'Outer<T>.Inner<U>.Derived4.Derived6.Outer<T>.Inner<U>.Interface<U, T>.Method<K>(T, U[], List<U>, Dictionary<T, K>)': containing type does not implement interface 'Outer<T>.Inner<U>.Interface<U, T>'
                //                 void Inner<U>.Interface<U, T>.Method<K>(T a, U[] b, List<U> c, Dictionary<T, K> D)
                Diagnostic(ErrorCode.ERR_ClassDoesntImplementInterface, "Inner<U>.Interface<U, T>").WithArguments("Outer<T>.Inner<U>.Derived4.Derived6.Outer<T>.Inner<U>.Interface<U, T>.Method<K>(T, U[], System.Collections.Generic.List<U>, System.Collections.Generic.Dictionary<T, K>)", "Outer<T>.Inner<U>.Interface<U, T>").WithLocation(30, 22)
                );
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        public void TestErrorsImplementingGenericNestedInterfaces_Explicit_IncorrectPartialQualification()
        {
            var source = @"
using System.Collections.Generic;
class Outer<T>
{
    internal class Inner<U>
    {
        protected internal interface Interface<V, W>
        {
            T Property { set; }
            void Method<Z>(T a, U[] b, List<V> c, Dictionary<W, Z> d);
        }
        internal class Derived3 : Interface<long, string>
        {
            T Interface<long, string>.Property
            {
                set { }
            }
            void Inner<U>.Interface<long, string>.Method<K>(T a, U[] B, List<long> C, Dictionary<string, K> d)
            {
            }
        }
    }
}
";

            // https://github.com/dotnet/roslyn/issues/30677, https://github.com/dotnet/roslyn/issues/30673 - Expect no errors
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (18,18): error CS0540: 'Outer<T>.Inner<U>.Derived3.Outer<T>.Inner<U>.Interface<long, string>.Method<K>(T, U[], List<long>, Dictionary<string, K>)': containing type does not implement interface 'Outer<T>.Inner<U>.Interface<long, string>'
                //             void Inner<U>.Interface<long, string>.Method<K>(T a, U[] B, List<long> C, Dictionary<string, K> d)
                Diagnostic(ErrorCode.ERR_ClassDoesntImplementInterface, "Inner<U>.Interface<long, string>").WithArguments("Outer<T>.Inner<U>.Derived3.Outer<T>.Inner<U>.Interface<long, string>.Method<K>(T, U[], System.Collections.Generic.List<long>, System.Collections.Generic.Dictionary<string, K>)", "Outer<T>.Inner<U>.Interface<long, string>").WithLocation(18, 18)
                );
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        [WorkItem(31858, "https://github.com/dotnet/roslyn/issues/31858")]
        public void ExplictInterfaceImplementation_01()
        {
            var source1 = @"
public interface I1<I1T1, I1T2>
{
    void M();
}

public interface I2<I2T1, I2T2> : I1<I2T1, I2T2>
{
}
";

            var comp1 = CreateCompilation(source1, options: WithNonNullTypesFalse());
            comp1.VerifyDiagnostics();

            var source2 = @"
class C<CT1, CT2> : I2<CT1, CT2>
{
    void I1<CT1, CT2>.M()
    {
    }
}";

            var comp2 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });
            comp2.VerifyDiagnostics();

            var comp3 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.ToMetadataReference() });
            comp3.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        [WorkItem(31858, "https://github.com/dotnet/roslyn/issues/31858")]
        public void ExplictInterfaceImplementation_02()
        {
            var source1 = @"
public interface I1<I1T1>
{
    void M();
}

public struct S<ST1, ST2>
{ }

public interface I2<I2T1, I2T2> : I1<S<I2T1, I2T2>>
{
}
";

            var comp1 = CreateCompilation(source1, options: WithNonNullTypesFalse());
            comp1.VerifyDiagnostics();

            var source2 = @"
class C<CT1, CT2> : I2<CT1, CT2>
{
    void I1<S<CT1, CT2>>.M()
    {
    }
}
";

            var comp2 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });
            comp2.VerifyDiagnostics();

            var comp3 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.ToMetadataReference() });
            comp3.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        [WorkItem(31858, "https://github.com/dotnet/roslyn/issues/31858")]
        public void ExplictInterfaceImplementation_03()
        {
            var source1 = @"
public interface I1<I1T1>
{
    void M();
}

public class C1<ST1, ST2>
{ }

public interface I2<I2T1, I2T2> : I1<C1<I2T1, I2T2>>
{
}
";

            var comp1 = CreateCompilation(source1, options: WithNonNullTypesFalse());
            comp1.VerifyDiagnostics();

            var source2 = @"
class C<CT1, CT2> : I2<CT1, CT2>
{
    void I1<C1<CT1, CT2>>.M()
    {
    }
}
";
            var expected = new DiagnosticDescription[] {
                // (4,10): warning CS8643: Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.
                //     void I1<C1<CT1, CT2>>.M()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInExplicitlyImplementedInterface, "I1<C1<CT1, CT2>>").WithLocation(4, 10)
            };

            var comp2 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });
            comp2.VerifyDiagnostics(expected);

            var comp3 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.ToMetadataReference() });
            comp3.VerifyDiagnostics(expected);
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        [WorkItem(31858, "https://github.com/dotnet/roslyn/issues/31858")]
        public void ExplictInterfaceImplementation_04()
        {
            var source1 = @"
public interface I1<I1T1>
{
    void M();
}

public class C1<ST1, ST2>
{ }

public interface I2<I2T1, I2T2> : I1<C1<I2T1, I2T2>>
{
}
";

            var comp1 = CreateCompilation(source1, options: WithNonNullTypesFalse());
            comp1.VerifyDiagnostics();

            var source2 = @"
class C<CT1, CT2> : I2<CT1, CT2>, I1<C1<CT1, CT2>>
{
    void I1<C1<CT1, CT2>>.M()
    {
    }
}
";
            var expected = new DiagnosticDescription[] {
                // (2,7): warning CS8645: 'I1<C1<CT1, CT2>>' is already listed in the interface list on type 'C<CT1, CT2>' with different nullability of reference types.
                // class C<CT1, CT2> : I2<CT1, CT2>, I1<C1<CT1, CT2>>
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C").WithArguments("I1<C1<CT1, CT2>>", "C<CT1, CT2>").WithLocation(2, 7)
            };

            var comp2 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });
            comp2.VerifyDiagnostics(expected);

            var comp3 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.ToMetadataReference() });
            comp3.VerifyDiagnostics(expected);
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        [WorkItem(31858, "https://github.com/dotnet/roslyn/issues/31858")]
        public void ExplictInterfaceImplementation_05()
        {
            var source1 = @"
public interface I1<I1T1>
{
    void M();
}

public struct S<ST1, ST2>
{ }

public interface I2<I2T1, I2T2> : I1<S<I2T1, I2T2>>
{
}
";

            var comp1 = CreateCompilation(source1, options: WithNonNullTypesFalse());
            comp1.VerifyDiagnostics();

            var source2 = @"
class C<CT1, CT2> : I2<CT1, CT2>
{
    void I1<S<CT1, CT2
#nullable disable
>
#nullable enable
>.M()
    {
    }
}
";

            var comp2 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });
            comp2.VerifyDiagnostics();

            var comp3 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.ToMetadataReference() });
            comp3.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        [WorkItem(31858, "https://github.com/dotnet/roslyn/issues/31858")]
        public void ExplictInterfaceImplementation_06()
        {
            var source1 = @"
public interface I1<I1T1>
{
    void M();
}

public class C1<ST1, ST2>
{ }

public interface I2<I2T1, I2T2> : I1<C1<I2T1, I2T2>>
{
}
";

            var comp1 = CreateCompilation(source1, options: WithNonNullTypesFalse());
            comp1.VerifyDiagnostics();

            var source2 = @"
class C<CT1, CT2> : I2<CT1, CT2>
{
    void I1<C1<CT1, CT2
#nullable disable
>
#nullable enable
>.M()
    {
    }
}
";

            var comp2 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });
            comp2.VerifyDiagnostics();

            var comp3 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.ToMetadataReference() });
            comp3.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        [WorkItem(31858, "https://github.com/dotnet/roslyn/issues/31858")]
        public void ExplictInterfaceImplementation_07()
        {
            var source1 = @"
public interface I1<I1T1>
{
    void M();
}

public interface I2<I2T1, I2T2> : I1<(I2T1, I2T2)>
{
}
";

            var comp1 = CreateCompilation(source1, options: WithNonNullTypesFalse());
            comp1.VerifyDiagnostics();

            var source2 = @"
class C<CT1, CT2> : I2<CT1, CT2>
{
    void I1<(CT1 a, CT2 b)>.M()
    {
    }
}
";

            var expected = new DiagnosticDescription[] {
                // (4,10): error CS0540: 'C<CT1, CT2>.I1<(CT1 a, CT2 b)>.M()': containing type does not implement interface 'I1<(CT1 a, CT2 b)>'
                //     void I1<(CT1 a, CT2 b)>.M()
                Diagnostic(ErrorCode.ERR_ClassDoesntImplementInterface, "I1<(CT1 a, CT2 b)>").WithArguments("C<CT1, CT2>.I1<(CT1 a, CT2 b)>.M()", "I1<(CT1 a, CT2 b)>").WithLocation(4, 10)
            };

            var comp2 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });
            comp2.VerifyDiagnostics(expected);

            var comp3 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.ToMetadataReference() });
            comp3.VerifyDiagnostics(expected);
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        [WorkItem(31858, "https://github.com/dotnet/roslyn/issues/31858")]
        public void ExplictInterfaceImplementation_08()
        {
            var source1 = @"
public interface I1<I1T1>
{
    void M();
}

public interface I2<I2T1, I2T2> : I1<(I2T1, I2T2)>
{
}
";

            var comp1 = CreateCompilation(source1, options: WithNonNullTypesFalse());
            comp1.VerifyDiagnostics();

            var source2 = @"
class C<CT1, CT2> : I2<CT1, CT2>, I1<(CT1 a, CT2 b)>
{
    void I1<(CT1 c, CT2 d)>.M()
    {
    }
}
";

            var expected = new DiagnosticDescription[] {
                // (2,7): error CS8140: 'I1<(CT1 a, CT2 b)>' is already listed in the interface list on type 'C<CT1, CT2>' with different tuple element names, as 'I1<(CT1, CT2)>'.
                // class C<CT1, CT2> : I2<CT1, CT2>, I1<(CT1 a, CT2 b)>
                Diagnostic(ErrorCode.ERR_DuplicateInterfaceWithTupleNamesInBaseList, "C").WithArguments("I1<(CT1 a, CT2 b)>", "I1<(CT1, CT2)>", "C<CT1, CT2>").WithLocation(2, 7),
                // (4,10): error CS0540: 'C<CT1, CT2>.I1<(CT1 c, CT2 d)>.M()': containing type does not implement interface 'I1<(CT1 c, CT2 d)>'
                //     void I1<(CT1 c, CT2 d)>.M()
                Diagnostic(ErrorCode.ERR_ClassDoesntImplementInterface, "I1<(CT1 c, CT2 d)>").WithArguments("C<CT1, CT2>.I1<(CT1 c, CT2 d)>.M()", "I1<(CT1 c, CT2 d)>").WithLocation(4, 10)
            };

            var comp2 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });
            comp2.VerifyDiagnostics(expected);

            var comp3 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.ToMetadataReference() });
            comp3.VerifyDiagnostics(expected);
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        [WorkItem(31858, "https://github.com/dotnet/roslyn/issues/31858")]
        public void ExplictInterfaceImplementation_09()
        {
            var source1 = @"
public interface I1<I1T1>
{
    void M();
}

public class C1<ST1, ST2>
{ }

public interface I2<I2T1, I2T2> : I1<C1<I2T1, I2T2>>
{
}
";

            var comp1 = CreateCompilation(source1, options: WithNonNullTypesFalse());
            comp1.VerifyDiagnostics();

            var source2 = @"
class C<CT1, CT2> : I2<CT1, CT2>, 
#nullable disable
I1<C1<CT1, CT2>>
#nullable enable
{
    void I1<C1<CT1, CT2>>.M()
    {
    }
}
";

            var expected = new DiagnosticDescription[] {
                // (2,7): warning CS8645: 'I1<C1<CT1, CT2>>' is already listed in the interface list on type 'C<CT1, CT2>' with different nullability of reference types.
                // class C<CT1, CT2> : I2<CT1, CT2>,
                Diagnostic(ErrorCode.WRN_DuplicateInterfaceWithNullabilityMismatchInBaseList, "C").WithArguments("I1<C1<CT1, CT2>>", "C<CT1, CT2>").WithLocation(2, 7),
                // (7,10): warning CS8643: Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.
                //     void I1<C1<CT1, CT2>>.M()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInExplicitlyImplementedInterface, "I1<C1<CT1, CT2>>").WithLocation(7, 10)
            };

            var comp2 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });
            comp2.VerifyDiagnostics(expected);

            var comp3 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.ToMetadataReference() });
            comp3.VerifyDiagnostics(expected);
        }

        [Fact]
        [WorkItem(30677, "https://github.com/dotnet/roslyn/issues/30677")]
        [WorkItem(31858, "https://github.com/dotnet/roslyn/issues/31858")]
        public void ExplictInterfaceImplementation_10()
        {
            var source1 = @"
public interface I1<I1T1>
{
    void M();
}

public class C1<ST1, ST2>
{ }

public interface I2<I2T1, I2T2> : I1<C1<I2T1, I2T2>>
{
}
";

            var comp1 = CreateCompilation(source1, options: WithNonNullTypesFalse());
            comp1.VerifyDiagnostics();

            var source2 = @"
class C<CT1, CT2> : I2<CT1, CT2>, 
I1<C1<CT1, CT2
#nullable disable
              >
#nullable enable
               >
{
    void I1<C1<CT1, CT2>>.M()
    {
    }
}
";
            var expected = new DiagnosticDescription[] {
                // (9,10): warning CS8643: Nullability of reference types in explicit interface specifier doesn't match interface implemented by the type.
                //     void I1<C1<CT1, CT2>>.M()
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInExplicitlyImplementedInterface, "I1<C1<CT1, CT2>>").WithLocation(9, 10)
            };

            var comp2 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.EmitToImageReference() });
            comp2.VerifyDiagnostics(expected);

            var comp3 = CreateCompilation(source2, options: WithNonNullTypesTrue(), references: new[] { comp1.ToMetadataReference() });
            comp3.VerifyDiagnostics(expected);
        }

        [Fact]
        public void WriteOfReadonlyStaticMemberOfAnotherInstantiation01()
        {
            var text =
@"public static class Goo<T>
{
    static Goo()
    {
        Goo<T>.Y = 3;
    }

    public static int Y { get; }
}";
            CreateCompilation(text, options: WithNonNullTypesTrue(TestOptions.ReleaseDll)).VerifyDiagnostics();
            CreateCompilation(text, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), parseOptions: TestOptions.Regular.WithStrictFeature()).VerifyDiagnostics();
        }

        [Fact]
        public void TestOverrideGenericMethodWithTypeParamDiffNameWithCustomModifiers()
        {
            var text = @"
namespace Metadata
{
    using System;
    public class GD : Outer<string>.Inner<ulong>
    {
        public override void Method<X>(string[] x, ulong[] y, X[] z) { Console.Write(""Hello {0}"", z.Length); }

        static void Main()
        {
            new GD().Method<byte>(null, null, new byte[] { 0, 127, 255 });
        }
    }
}
";
            var verifier = CompileAndVerify(
                text,
                new[] { TestReferences.SymbolsTests.CustomModifiers.Modifiers.dll },
                options: WithNonNullTypesTrue(TestOptions.ReleaseExe),
                expectedOutput: @"Hello 3",
                expectedSignatures: new[]
                {
                    // The ILDASM output is following,and Roslyn handles it correctly.
                    // Verifier tool gives different output due to the limitation of Reflection
                    // @".method public hidebysig virtual instance System.Void Method<X>(" +
                    // @"System.String modopt([mscorlib]System.Runtime.CompilerServices.IsConst)[] modopt([mscorlib]System.Runtime.CompilerServices.IsConst) x," +
                    // @"UInt64 modopt([mscorlib]System.Runtime.CompilerServices.IsConst)[] modopt([mscorlib]System.Runtime.CompilerServices.IsConst) y," +
                    // @"!!X modopt([mscorlib]System.Runtime.CompilerServices.IsConst)[] modopt([mscorlib]System.Runtime.CompilerServices.IsConst) z) cil managed")
                    Signature("Metadata.GD", "Method",
                              @".method public hidebysig virtual instance System.Void Method<X>(" +
                              @"[System.Runtime.CompilerServices.NullableAttribute(1)] " +
                              @"modopt(System.Runtime.CompilerServices.IsConst) System.String[] x, " +
                              @"[System.Runtime.CompilerServices.NullableAttribute(System.Collections.ObjectModel.ReadOnlyCollection`1[System.Reflection.CustomAttributeTypedArgument])] " +
                              @"modopt(System.Runtime.CompilerServices.IsConst) System.UInt64[] y, "+
                              @"[System.Runtime.CompilerServices.NullableAttribute(1)] " +
                              @"modopt(System.Runtime.CompilerServices.IsConst) X[] z) cil managed"),
                });
        }

        [Fact]
        [WorkItem(30747, "https://github.com/dotnet/roslyn/issues/30747")]
        public void MissingTypeKindBasisTypes()
        {
            var source1 = @"
public struct A {}

public enum B {}

public class C {}
public delegate void D();

public interface I1 {}
";
            var compilation1 = CreateEmptyCompilation(source1, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { MinCorlibRef });
            compilation1.VerifyEmitDiagnostics();

            Assert.Equal(TypeKind.Struct, compilation1.GetTypeByMetadataName("A").TypeKind);
            Assert.Equal(TypeKind.Enum, compilation1.GetTypeByMetadataName("B").TypeKind);
            Assert.Equal(TypeKind.Class, compilation1.GetTypeByMetadataName("C").TypeKind);
            Assert.Equal(TypeKind.Delegate, compilation1.GetTypeByMetadataName("D").TypeKind);
            Assert.Equal(TypeKind.Interface, compilation1.GetTypeByMetadataName("I1").TypeKind);

            var source2 = @"
interface I2
{
    I1 M(A a, B b, C c, D d); 
}
";

            var compilation2 = CreateEmptyCompilation(source2, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { compilation1.EmitToImageReference(), MinCorlibRef });

            compilation2.VerifyEmitDiagnostics();

            // Verification against a corlib not named exactly mscorlib is expected to fail.
            CompileAndVerify(compilation2, verify: Verification.Fails);

            Assert.Equal(TypeKind.Struct, compilation2.GetTypeByMetadataName("A").TypeKind);
            Assert.Equal(TypeKind.Enum, compilation2.GetTypeByMetadataName("B").TypeKind);
            Assert.Equal(TypeKind.Class, compilation2.GetTypeByMetadataName("C").TypeKind);
            Assert.Equal(TypeKind.Delegate, compilation2.GetTypeByMetadataName("D").TypeKind);
            Assert.Equal(TypeKind.Interface, compilation2.GetTypeByMetadataName("I1").TypeKind);

            var compilation3 = CreateEmptyCompilation(source2, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { compilation1.ToMetadataReference(), MinCorlibRef });

            compilation3.VerifyEmitDiagnostics();
            CompileAndVerify(compilation3, verify: Verification.Fails);

            Assert.Equal(TypeKind.Struct, compilation3.GetTypeByMetadataName("A").TypeKind);
            Assert.Equal(TypeKind.Enum, compilation3.GetTypeByMetadataName("B").TypeKind);
            Assert.Equal(TypeKind.Class, compilation3.GetTypeByMetadataName("C").TypeKind);
            Assert.Equal(TypeKind.Delegate, compilation3.GetTypeByMetadataName("D").TypeKind);
            Assert.Equal(TypeKind.Interface, compilation3.GetTypeByMetadataName("I1").TypeKind);

            var compilation4 = CreateEmptyCompilation(source2, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { compilation1.EmitToImageReference() });

            compilation4.VerifyDiagnostics(
                // (4,10): error CS0012: The type 'ValueType' is defined in an assembly that is not referenced. You must add a reference to assembly 'mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2'.
                //     I1 M(A a, B b, C c, D d);
                Diagnostic(ErrorCode.ERR_NoTypeDef, "A").WithArguments("System.ValueType", "mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2").WithLocation(4, 10),
                // (4,15): error CS0012: The type 'Enum' is defined in an assembly that is not referenced. You must add a reference to assembly 'mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2'.
                //     I1 M(A a, B b, C c, D d);
                Diagnostic(ErrorCode.ERR_NoTypeDef, "B").WithArguments("System.Enum", "mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2").WithLocation(4, 15),
                // (4,25): error CS0012: The type 'MulticastDelegate' is defined in an assembly that is not referenced. You must add a reference to assembly 'mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2'.
                //     I1 M(A a, B b, C c, D d);
                Diagnostic(ErrorCode.ERR_NoTypeDef, "D").WithArguments("System.MulticastDelegate", "mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2").WithLocation(4, 25)
                );

            var a = compilation4.GetTypeByMetadataName("A");
            var b = compilation4.GetTypeByMetadataName("B");
            var c = compilation4.GetTypeByMetadataName("C");
            var d = compilation4.GetTypeByMetadataName("D");
            var i1 = compilation4.GetTypeByMetadataName("I1");
            Assert.Equal(TypeKind.Class, a.TypeKind);
            Assert.NotNull(a.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Class, b.TypeKind);
            Assert.NotNull(b.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Class, c.TypeKind);
            Assert.Null(c.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Class, d.TypeKind);
            Assert.NotNull(d.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Interface, i1.TypeKind);
            Assert.Null(i1.GetUseSiteDiagnostic());

            var compilation5 = CreateEmptyCompilation(source2, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { compilation1.ToMetadataReference() });

            compilation5.VerifyEmitDiagnostics(
                // warning CS8021: No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options.
                Diagnostic(ErrorCode.WRN_NoRuntimeMetadataVersion).WithLocation(1, 1),
                // error CS0518: Predefined type 'System.Attribute' is not defined or imported
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound).WithArguments("System.Attribute").WithLocation(1, 1),
                // error CS0518: Predefined type 'System.Attribute' is not defined or imported
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound).WithArguments("System.Attribute").WithLocation(1, 1),
                // error CS0518: Predefined type 'System.Byte' is not defined or imported
                Diagnostic(ErrorCode.ERR_PredefinedTypeNotFound).WithArguments("System.Byte").WithLocation(1, 1));

            var compilation6 = CreateEmptyCompilation(source2, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { compilation1.EmitToImageReference(), MscorlibRef });

            compilation6.VerifyDiagnostics(
                // (4,10): error CS0012: The type 'ValueType' is defined in an assembly that is not referenced. You must add a reference to assembly 'mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2'.
                //     I1 M(A a, B b, C c, D d);
                Diagnostic(ErrorCode.ERR_NoTypeDef, "A").WithArguments("System.ValueType", "mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2").WithLocation(4, 10),
                // (4,15): error CS0012: The type 'Enum' is defined in an assembly that is not referenced. You must add a reference to assembly 'mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2'.
                //     I1 M(A a, B b, C c, D d);
                Diagnostic(ErrorCode.ERR_NoTypeDef, "B").WithArguments("System.Enum", "mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2").WithLocation(4, 15),
                // (4,25): error CS0012: The type 'MulticastDelegate' is defined in an assembly that is not referenced. You must add a reference to assembly 'mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2'.
                //     I1 M(A a, B b, C c, D d);
                Diagnostic(ErrorCode.ERR_NoTypeDef, "D").WithArguments("System.MulticastDelegate", "mincorlib, Version=0.0.0.0, Culture=neutral, PublicKeyToken=ce65828c82a341f2").WithLocation(4, 25)
                );

            a = compilation6.GetTypeByMetadataName("A");
            b = compilation6.GetTypeByMetadataName("B");
            c = compilation6.GetTypeByMetadataName("C");
            d = compilation6.GetTypeByMetadataName("D");
            i1 = compilation6.GetTypeByMetadataName("I1");
            Assert.Equal(TypeKind.Class, a.TypeKind);
            Assert.NotNull(a.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Class, b.TypeKind);
            Assert.NotNull(b.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Class, c.TypeKind);
            Assert.Null(c.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Class, d.TypeKind);
            Assert.NotNull(d.GetUseSiteDiagnostic());
            Assert.Equal(TypeKind.Interface, i1.TypeKind);
            Assert.Null(i1.GetUseSiteDiagnostic());

            var compilation7 = CreateEmptyCompilation(source2, options: WithNonNullTypesTrue(TestOptions.ReleaseDll), references: new[] { compilation1.ToMetadataReference(), MscorlibRef });

            compilation7.VerifyEmitDiagnostics();
            CompileAndVerify(compilation7);

            Assert.Equal(TypeKind.Struct, compilation7.GetTypeByMetadataName("A").TypeKind);
            Assert.Equal(TypeKind.Enum, compilation7.GetTypeByMetadataName("B").TypeKind);
            Assert.Equal(TypeKind.Class, compilation7.GetTypeByMetadataName("C").TypeKind);
            Assert.Equal(TypeKind.Delegate, compilation7.GetTypeByMetadataName("D").TypeKind);
            Assert.Equal(TypeKind.Interface, compilation7.GetTypeByMetadataName("I1").TypeKind);
        }

        [Fact]
        public void AccessPropertyWithoutArguments()
        {
            var source1 =
@"Imports System
Imports System.Runtime.InteropServices
<Assembly: PrimaryInteropAssembly(0, 0)> 
<Assembly: Guid(""165F752D-E9C4-4F7E-B0D0-CDFD7A36E210"")>
<ComImport()>
<Guid(""165F752D-E9C4-4F7E-B0D0-CDFD7A36E211"")>
Public Interface I
    Property Value(Optional index As Object = Nothing) As Object
End Interface";
            var ref1 = BasicCompilationUtils.CompileToMetadata(source1);

            var source2 =
@"class C : I
{
    public dynamic get_Value(object index = null) => ""Test"";
    public void set_Value(object index = null, object value = null) { }
}
class Test
{
    static void Main()
    {
        I x = new C();
        System.Console.WriteLine(x.Value.Length);
    }
}";
            var comp = CreateCompilation(source2, new[] { ref1.WithEmbedInteropTypes(true), CSharpRef }, options: WithNonNullTypesTrue(TestOptions.ReleaseExe));
            CompileAndVerify(comp, expectedOutput: "4");
        }

        [Fact]
        public void NullabilityOfTypeParameters_001()
        {
            var source = @"
class Outer
{
    void M<T>(T x)
    {
        object y;
        y = x;
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_002()
        {
            var source = @"
class Outer
{
    void M<T>(T x)
    {
        dynamic y;
        y = x;
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_003()
        {
            var source = @"
class Outer
{
    void M<T>(T x) where T : I1
    {
        object y;
        y = x;
        dynamic z;
        z = x;
    }
}

interface I1{}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_004()
        {
            var source = @"
class Outer
{
    void M<T, U>(U x) where U : T
    {
        T y;
        y = x;
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_005()
        {
            var source = @"
class Outer
{
    void M<T>(T x)
    {
        if (x == null) return;
        object y;
        y = x;
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_006()
        {
            var source = @"
class Outer
{
    void M<T>(T x)
    {
        if (x == null) return;
        dynamic y;
        y = x;
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_007()
        {
            var source = @"
class Outer
{
    T M0<T>(T x0, T y0)
    {
        if (x0 == null) throw null;
        M2(x0) = x0;
        M2<T>(x0) = y0;

        M2(x0).ToString();
        M2<T>(x0).ToString();
        throw null;
    }

    void M1(object? x1, object? y1)
    {
        if (x1 == null) return;
        M2(x1) = x1;
        M2(x1) = y1;
    }

    ref U M2<U>(U a) where U : object => throw null;
}
";
            // Note: you cannot pass a `T` to a `U : object` even if the `T` was null-tested
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): warning CS8631: The type 'T' cannot be used as type parameter 'U' in the generic type or method 'Outer.M2<U>(U)'. Nullability of type argument 'T' doesn't match constraint type 'object'.
                //         M2(x0) = x0;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M2").WithArguments("Outer.M2<U>(U)", "object", "U", "T").WithLocation(7, 9),
                // (8,9): warning CS8631: The type 'T' cannot be used as type parameter 'U' in the generic type or method 'Outer.M2<U>(U)'. Nullability of type argument 'T' doesn't match constraint type 'object'.
                //         M2<T>(x0) = y0;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M2<T>").WithArguments("Outer.M2<U>(U)", "object", "U", "T").WithLocation(8, 9),
                // (10,9): warning CS8631: The type 'T' cannot be used as type parameter 'U' in the generic type or method 'Outer.M2<U>(U)'. Nullability of type argument 'T' doesn't match constraint type 'object'.
                //         M2(x0).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M2").WithArguments("Outer.M2<U>(U)", "object", "U", "T").WithLocation(10, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         M2(x0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(x0)").WithLocation(10, 9),
                // (11,9): warning CS8631: The type 'T' cannot be used as type parameter 'U' in the generic type or method 'Outer.M2<U>(U)'. Nullability of type argument 'T' doesn't match constraint type 'object'.
                //         M2<T>(x0).ToString();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M2<T>").WithArguments("Outer.M2<U>(U)", "object", "U", "T").WithLocation(11, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         M2<T>(x0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2<T>(x0)").WithLocation(11, 9),
                // (19,18): warning CS8601: Possible null reference assignment.
                //         M2(x1) = y1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y1").WithLocation(19, 18)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_008()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, U y0, U z0) where U : T
    {
        if (x0 == null) return;
        if (y0 == null) return;
        M2(x0) = y0;
        M2(x0) = z0;
        M2<T>(x0) = y0;
        M2<T>(x0) = z0;
        M2(x0).ToString();
        M2<T>(x0).ToString();
    }

    ref U M2<U>(U a) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         M2(x0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(x0)").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         M2<T>(x0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2<T>(x0)").WithLocation(13, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_009()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        x0 = y0;
    }

    void M1<T>(T y1)
    {
        T x1 = y1;
        x1 = y1;
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_010()
        {
            var source = @"
class Outer
{
    void M0<T>(Outer x0, T y0) where T : Outer?
    {
        x0 = y0;
    }

    void M1<T>(T y1) where T : Outer?
    {
        Outer x1 = y1;
        x1 = y1;
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x0 = y0;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y0").WithLocation(6, 14),
                // (11,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         Outer x1 = y1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1").WithLocation(11, 20),
                // (12,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x1 = y1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y1").WithLocation(12, 14)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_011()
        {
            var source = @"
class Outer
{
    void M0<T>(Outer x0, T y0) where T : Outer?
    {
        if (y0 == null) return;
        x0 = y0;
    }

    void M1<T>(T y1) where T : Outer?
    {
        if (y1 == null) return;
        Outer x1 = y1;
        x1 = y1;
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(30938, "https://github.com/dotnet/roslyn/issues/30938")]
        public void NullabilityOfTypeParameters_012()
        {
            var source = @"
class Outer
{
    void M<T>(object? x, object y)
    {
        T z;
        z = x;
        z = y;
        z = (T)x;
        z.ToString(); // 1
        z = (T)y;
        z.ToString();
    }
}
";
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): error CS0266: Cannot implicitly convert type 'object' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         z = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("object", "T").WithLocation(7, 13),
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13),
                // (8,13): error CS0266: Cannot implicitly convert type 'object' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         z = y;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "y").WithArguments("object", "T").WithLocation(8, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = (T)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)x").WithLocation(9, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(10, 9)
                );
        }

        [Fact]
        [WorkItem(30938, "https://github.com/dotnet/roslyn/issues/30938")]
        public void NullabilityOfTypeParameters_013()
        {
            var source = @"
class Outer
{
    void M<T>(dynamic? x, dynamic y)
    {
        T z;
        z = x;
        z = y;
        z = (T)x;
        z.ToString(); // 1
        z = (T)y;
        z.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = (T)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)x").WithLocation(9, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_014()
        {
            var source = @"
class Outer
{
    void M<T>(object? x, object y) where T : I1
    {
        T z;
        z = x;
        z = y;
        z = (T)x;
        z.ToString(); // 1
        z = (T)y;
        z.ToString();
    }
}

interface I1{}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): error CS0266: Cannot implicitly convert type 'object' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         z = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("object", "T").WithLocation(7, 13),
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13),
                // (8,13): error CS0266: Cannot implicitly convert type 'object' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         z = y;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "y").WithArguments("object", "T").WithLocation(8, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = (T)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)x").WithLocation(9, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_015()
        {
            var source = @"
class Outer
{
    void M<T>(dynamic? x, dynamic y) where T : I1
    {
        T z;
        z = x;
        z = y;
        z = (T)x;
        z.ToString(); // 1
        z = (T)y;
        z.ToString();
    }
}

interface I1{}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = (T)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)x").WithLocation(9, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_016()
        {
            var source = @"
class Outer
{
    void M<T>(object? x, object y) where T : I1?
    {
        T z;
        z = x;
        z = y;
        z = (T)x;
        z.ToString(); // 1
        z = (T)y;
        z.ToString();
    }
}

interface I1{}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): error CS0266: Cannot implicitly convert type 'object' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         z = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("object", "T").WithLocation(7, 13),
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13),
                // (8,13): error CS0266: Cannot implicitly convert type 'object' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         z = y;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "y").WithArguments("object", "T").WithLocation(8, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = (T)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)x").WithLocation(9, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_017()
        {
            var source = @"
class Outer
{
    void M<T>(dynamic? x, dynamic y) where T : I1?
    {
        T z;
        z = x;
        z = y;
        z = (T)x;
        z.ToString(); // 1
        z = (T)y;
        z.ToString();
    }
}

interface I1{}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = (T)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)x").WithLocation(9, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_018()
        {
            var source = @"
class Outer
{
    void M<T, U>(T x) where U : T
    {
        U y;
        y = x;
        y = (U)x;
        y.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): error CS0266: Cannot implicitly convert type 'T' to 'U'. An explicit conversion exists (are you missing a cast?)
                //         y = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("T", "U").WithLocation(7, 13),
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13),
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = (U)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)x").WithLocation(8, 13),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_019()
        {
            var source = @"
class Outer
{
    void M<T, U>(T x) where U : T, I1
    {
        U y;
        y = x;
        y = (U)x;
        y.ToString();
    }
}

interface I1 {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): error CS0266: Cannot implicitly convert type 'T' to 'U'. An explicit conversion exists (are you missing a cast?)
                //         y = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("T", "U").WithLocation(7, 13),
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13),
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = (U)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)x").WithLocation(8, 13),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_020()
        {
            var source = @"
class Outer
{
    void M<T, U>(T x) where U : T, I1?
    {
        U y;
        y = x;
        y = (U)x;
        y.ToString();
    }
}

interface I1 {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): error CS0266: Cannot implicitly convert type 'T' to 'U'. An explicit conversion exists (are you missing a cast?)
                //         y = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("T", "U").WithLocation(7, 13),
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13),
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = (U)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)x").WithLocation(8, 13),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_021()
        {
            var source = @"
class Outer
{
    void M<T, U>(T x) where U : T where T : I1
    {
        U y;
        y = x;
        y = (U)x;
        y.ToString();
    }
}

interface I1 {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): error CS0266: Cannot implicitly convert type 'T' to 'U'. An explicit conversion exists (are you missing a cast?)
                //         y = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("T", "U").WithLocation(7, 13)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_022()
        {
            var source = @"
class Outer
{
    void M<T>(object? x)
    {
        if (x == null) return;
        T y;
        y = x;
        y = (T)x;
        y.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,13): error CS0266: Cannot implicitly convert type 'object' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         y = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("object", "T").WithLocation(8, 13)
                );
        }

        [Fact]
        [WorkItem(30939, "https://github.com/dotnet/roslyn/issues/30939")]
        public void NullabilityOfTypeParameters_023()
        {
            var source = @"
class Outer
{
    void M<T>(dynamic? x)
    {
        if (x == null) return;
        T y;
        y = x;
        y = (T)x;
        y.ToString();
    }
}
";
            // https://github.com/dotnet/roslyn/issues/30939 - ErrorCode.WRN_ConvertingNullableToNonNullable/ErrorCode.WRN_NullReferenceReceiver warnings are not expected
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(8, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = (T)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)x").WithLocation(9, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(10, 9)
                );
        }

        [Fact]
        [WorkItem(30940, "https://github.com/dotnet/roslyn/issues/30940")]
        [WorkItem(30941, "https://github.com/dotnet/roslyn/issues/30941")]
        public void NullabilityOfTypeParameters_024()
        {
            var source = @"
class Outer
{
    void M<T>(Outer? x, Outer y) where T : Outer?
    {
        T z;
        z = x;
        z = y;
        z = (T)x;
        z.ToString(); // 1
        z = (T)y;
        z.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): error CS0266: Cannot implicitly convert type 'Outer' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         z = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("Outer", "T").WithLocation(7, 13),
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13),
                // (8,13): error CS0266: Cannot implicitly convert type 'Outer' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         z = y;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "y").WithArguments("Outer", "T").WithLocation(8, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = (T)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)x").WithLocation(9, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(10, 9)
                );
        }

        [Fact]
        [WorkItem(30940, "https://github.com/dotnet/roslyn/issues/30940")]
        public void NullabilityOfTypeParameters_025()
        {
            var source = @"
class Outer
{
    void M<T>(Outer? x) where T : Outer?
    {
        if (x == null) return;
        T y;
        y = x;
        y = (T)x;
        y.ToString();
    }
}
";
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,13): error CS0266: Cannot implicitly convert type 'Outer' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         y = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("Outer", "T").WithLocation(8, 13)
                );
        }

        [Fact]
        [WorkItem(30940, "https://github.com/dotnet/roslyn/issues/30940")]
        [WorkItem(30941, "https://github.com/dotnet/roslyn/issues/30941")]
        public void NullabilityOfTypeParameters_026()
        {
            var source = @"
class Outer
{
    void M<T>(Outer? x, Outer y) where T : Outer
    {
        T z;
        z = x;
        z = y;
        z = (T)x;
        z.ToString(); // 1
        z = (T)y;
        z.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,13): error CS0266: Cannot implicitly convert type 'Outer' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         z = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("Outer", "T").WithLocation(7, 13),
                // (7,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(7, 13),
                // (8,13): error CS0266: Cannot implicitly convert type 'Outer' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         z = y;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "y").WithArguments("Outer", "T").WithLocation(8, 13),
                // (9,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z = (T)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)x").WithLocation(9, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(10, 9)
                );
        }

        [Fact]
        [WorkItem(30940, "https://github.com/dotnet/roslyn/issues/30940")]
        public void NullabilityOfTypeParameters_027()
        {
            var source = @"
class Outer
{
    void M<T>(Outer? x) where T : Outer
    {
        if (x == null) return;
        T y;
        y = x;
        y = (T)x;
        y.ToString();
    }
}
";
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,13): error CS0266: Cannot implicitly convert type 'Outer' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         y = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("Outer", "T").WithLocation(8, 13)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_028()
        {
            var source = @"
class Outer
{
    void M0<T>(Outer x0, T y0) where T : Outer
    {
        x0 = y0;
    }

    void M1<T>(T y1) where T : Outer
    {
        Outer x1 = y1;
        x1 = y1;
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_029()
        {
            var source = @"
class Outer
{
    void M0<T>(T x)
    {
        x = default;
        x.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_030()
        {
            var source = @"
class Outer
{
    void M0<T>(T x)
    {
        x = default(T);
        x.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = default(T);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(T)").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_031()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : I1?
    {
        x = default;
        x.ToString();
    }
}

interface I1 {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_032()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : I1?
    {
        x = default(T);
        x.ToString();
    }
}

interface I1 {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = default(T);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(T)").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_033()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : Outer
    {
        x = default;
        x.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_034()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : Outer
    {
        x = default(T);
        x.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = default(T);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(T)").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_035()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : I1
    {
        x = default;
        x.ToString();
    }
}

interface I1 {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_036()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : I1
    {
        x = default(T);
        x.ToString();
    }
}

interface I1 {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = default(T);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default(T)").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_037()
        {
            var source = @"
class Outer
{
    void M0<T>(T x)
    {
        x.ToString();
        x.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_038()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : I1?
    {
        x.ToString();
        x.ToString();
    }
}

interface I1 {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_039()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : I1
    {
        x.ToString();
        x.ToString();
    }
}

interface I1 {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_040()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : Outer?
    {
        x.ToString();
        x.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_041()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : Outer
    {
        x.ToString();
        x.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_042()
        {
            var source = @"
class Outer
{
    void M0<T>(T x)
    {
        M1(x);
        M1<T>(x);
    }

    void M1<T>(T x) where T : object
    {}
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,9): warning CS8631: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'Outer.M1<T>(T)'. Nullability of type argument 'T' doesn't match constraint type 'object'.
                //         M1(x);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("Outer.M1<T>(T)", "object", "T", "T").WithLocation(6, 9),
                // (7,9): warning CS8631: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'Outer.M1<T>(T)'. Nullability of type argument 'T' doesn't match constraint type 'object'.
                //         M1<T>(x);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<T>").WithArguments("Outer.M1<T>(T)", "object", "T", "T").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_043()
        {
            var source = @"
class Outer
{
    void M0<T>(T x)
    {
        if (x == null) return;
        M1(x);
        M1<T>(x);
    }

    void M1<T>(T x) where T : object
    {}
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): warning CS8631: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'Outer.M1<T>(T)'. Nullability of type argument 'T' doesn't match constraint type 'object'.
                //         M1(x);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1").WithArguments("Outer.M1<T>(T)", "object", "T", "T").WithLocation(7, 9),
                // (8,9): warning CS8631: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'Outer.M1<T>(T)'. Nullability of type argument 'T' doesn't match constraint type 'object'.
                //         M1<T>(x);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M1<T>").WithArguments("Outer.M1<T>(T)", "object", "T", "T").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_044()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : class?
    {
        M1(x);
        M1<T>(x);
    }

    void M1<T>(T x) where T : class
    {}
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,9): warning CS8634: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'Outer.M1<T>(T)'. Nullability of type argument 'T' doesn't match 'class' constraint.
                //         M1(x);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("Outer.M1<T>(T)", "T", "T").WithLocation(6, 9),
                // (7,9): warning CS8634: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'Outer.M1<T>(T)'. Nullability of type argument 'T' doesn't match 'class' constraint.
                //         M1<T>(x);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<T>").WithArguments("Outer.M1<T>(T)", "T", "T").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_045()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : class?
    {
        if (x == null) return;
        M1(x);
        M1<T>(x);
    }

    void M1<T>(T x) where T : class
    {}
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): warning CS8634: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'Outer.M1<T>(T)'. Nullability of type argument 'T' doesn't match 'class' constraint.
                //         M1(x);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1").WithArguments("Outer.M1<T>(T)", "T", "T").WithLocation(7, 9),
                // (8,9): warning CS8634: The type 'T' cannot be used as type parameter 'T' in the generic type or method 'Outer.M1<T>(T)'. Nullability of type argument 'T' doesn't match 'class' constraint.
                //         M1<T>(x);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterReferenceTypeConstraint, "M1<T>").WithArguments("Outer.M1<T>(T)", "T", "T").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_046()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : class?
    {
        x = null;
        x.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_047()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : class
    {
        x = null;
        x.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_048()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : Outer?
    {
        x = null;
        x.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_049()
        {
            var source = @"
class Outer
{
    void M0<T>(T x) where T : Outer
    {
        x = null;
        x.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(6, 13),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_050()
        {
            var source = @"
class Outer
{
    void M0<T>(T x)
    {
        M1(x, x).ToString();
    }

    T M1<T>(T x, T y) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         M1(x, x).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(x, x)").WithLocation(6, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_051()
        {
            var source = @"
class Outer
{
    void M0<T>(T x, T y)
    {
        if (x == null) return;
        M1(x, y).ToString();
    }

    T M1<T>(T x, T y) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         M1(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(x, y)").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_052()
        {
            var source = @"
class Outer
{
    void M0<T>(T x, T y)
    {
        if (y == null) return;
        M1(x, y).ToString();
    }

    T M1<T>(T x, T y) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         M1(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(x, y)").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_053()
        {
            var source = @"
class Outer
{
    void M0<T>(T x, T y)
    {
        if (x == null) return;
        if (y == null) return;
        M1(x, y).ToString();
        M1<T>(x, y).ToString();
    }

    T M1<T>(T x, T y) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         M1(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(x, y)").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         M1<T>(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1<T>(x, y)").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_054()
        {
            var source = @"
class Outer
{
    void M0<T>(T x, object y)
    {
        M1(x, y).ToString();
    }

    T M1<T>(T x, T y) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,12): warning CS8604: Possible null reference argument for parameter 'x' in 'object Outer.M1<object>(object x, object y)'.
                //         M1(x, y).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x").WithArguments("x", "object Outer.M1<object>(object x, object y)").WithLocation(6, 12)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_055()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        M2(x0, y0) = z0;
    }

    ref U M2<U>(U a, U b) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_056()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        if (x0 == null) return;
        M2(x0, y0) = z0;
        M2(x0, y0).ToString();
    }

    ref U M2<U>(U a, U b) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         M2(x0, y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(x0, y0)").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_057()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        if (y0 == null) return;
        M2(x0, y0) = z0;
    }

    ref U M2<U>(U a, U b) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_058()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        if (x0 == null) return;
        if (y0 == null) return;
        M2(x0, y0) = z0;
        M2<T>(x0, y0) = z0;

        M2(x0, y0).ToString();
    }

    ref U M2<U>(U a, U b) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         M2(x0, y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(x0, y0)").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_059()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T, I1
    {
        if (x0 == null) return;
        if (y0 == null) return;
        M2(x0, y0) = z0;
    }

    ref U M2<U>(U a, U b) => throw null;
}

interface I1 {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_060()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : class, T
    {
        if (x0 == null) return;
        if (y0 == null) return;
        M2(x0, y0) = z0;
    }

    ref U M2<U>(U a, U b) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_061()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        if (x0 == null) return;
        if (y0 == null) return;
        if (z0 == null) return;
        M2(x0, y0) = z0;
    }

    ref U M2<U>(U a, U b) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_062()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        M2(out x0, out y0) = z0;
    }

    ref U M2<U>(out U a, out U b) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_063()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        if (x0 == null) return;
        M2(out M3(x0), out y0) = z0;
        M2(out M3<T>(x0), out y0);
        M2<T>(out M3(x0), out y0);
        M2<T>(out M3<T>(x0), out y0);

        M2(out M3(x0), out y0).ToString();
        M2<T>(out M3(x0), out y0).ToString();
    }

    ref U M2<U>(out U a, out U b) => throw null;
    ref U M3<U>(U a) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         M2(out M3(x0), out y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(out M3(x0), out y0)").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         M2<T>(out M3(x0), out y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2<T>(out M3(x0), out y0)").WithLocation(13, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_064()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        if (y0 == null) return;
        M2(out x0, out M3(y0)) = z0;
        M2(out x0, out M3<T>(y0));
        M2<T>(out x0, out M3(y0));
        M2<T>(out x0, out M3<T>(y0));

        M2(out x0, out M3(y0)).ToString(); // warn
        M2<T>(out x0, out M3(y0)).ToString(); // warn
    }

    ref U M2<U>(out U a, out U b) => throw null;
    ref U M3<U>(U a) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         M2(out x0, out M3(y0)).ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(out x0, out M3(y0))").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         M2<T>(out x0, out M3(y0)).ToString(); // warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2<T>(out x0, out M3(y0))").WithLocation(13, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_065()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        if (x0 == null) return;
        if (y0 == null) return;
        M2(out M3(x0), out M3(y0)) = z0;
        M2<T>(out M3(x0), out M3(y0)) = z0;
        M2(out M3<T>(x0), out M3(y0)) = z0;
        M2(out M3(x0), out M3<T>(y0)) = z0;
        M2(out M3(x0), out M3(y0)).ToString();
    }

    ref U M2<U>(out U a, out U b) => throw null;
    ref U M3<U>(U a) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         M2(out M3(x0), out M3(y0)).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(out M3(x0), out M3(y0))").WithLocation(12, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_066()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, object? y0)
    {
        object? z0 = new object();
        z0 = x0;
        M2(out y0, out M3(z0)).ToString();
    }

    ref U M2<U>(out U a, out U b) => throw null;
    ref U M3<U>(U a) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         M2(out y0, out M3(z0)).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(out y0, out M3(z0))").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_067()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, object? y0)
    {
        object? z0 = new object();
        z0 = x0;
        M2(y0, z0).ToString();
    }

    ref U M2<U>(U a, U b) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         M2(y0, z0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(y0, z0)").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_068()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T where T : class?
    {
        M2(M3(x0), M3(y0)) = z0;
    }

    ref U M2<U>(I1<U> a, I1<U> b) => throw null;
    I1<U> M3<U>(U a) => throw null;
}

interface I1<in T> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_069()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T where T : class?
    {
        if (x0 == null) return;
        M2(M3(x0), M3(y0)) = z0;
        M2<T>(M3<T>(x0), M3<T>(y0)) = z0;

        M2(M3(x0), M3(y0)).ToString();
    }

    ref U M2<U>(I1<U> a, I1<U> b) => throw null;
    I1<U> M3<U>(U a) => throw null;
}

interface I1<in T> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         M2(M3(x0), M3(y0)).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(M3(x0), M3(y0))").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_070()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T where T : class?
    {
        if (y0 == null) return;
        M2(M3(x0), M3(y0)) = z0;
        M2<T>(M3(x0), M3(y0)) = z0;

        M2(M3(x0), M3(y0)).ToString();
    }

    ref U M2<U>(I1<U> a, I1<U> b) => throw null;
    I1<U> M3<U>(U a) => throw null;
}

interface I1<in T> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         M2(M3(x0), M3(y0)).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(M3(x0), M3(y0))").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_071()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T where T : class?
    {
        if (x0 == null) return;
        if (y0 == null) return;
        M2(M3(x0), M3(y0)) = z0;
        M2<T>(M3(x0), M3(y0)) = z0;
        M2(M3<T>(x0), M3(y0)) = z0;

        M2(M3(x0), M3(y0)).ToString();
    }

    ref U M2<U>(I1<U> a, I1<U> b) => throw null;
    I1<U> M3<U>(U a) => throw null;
}

interface I1<in T> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         M2(M3(x0), M3(y0)).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(M3(x0), M3(y0))").WithLocation(12, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_072()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, I1<object?> y0)
    {
        object? z0 = new object();
        z0 = x0;
        M2(y0, M3(z0)).ToString();
    }

    ref U M2<U>(I1<U> a, I1<U> b) => throw null;
    I1<U> M3<U>(U a) => throw null;
}

interface I1<in T> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         M2(y0, M3(z0)).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(y0, M3(z0))").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_073()
        {
            var source = @"
class Outer
{
    void M0<T>(object x0, T y0)
    {
        if (y0 == null) return;
        object? z0 = new object();
        z0 = y0;
        M2(out x0, out M3(z0)).ToString();
    }

    ref U M2<U>(out U a, out U b) => throw null;
    ref U M3<U>(U a) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_074()
        {
            var source = @"
class Outer
{
    void M0<T>(object x0, T y0)
    {
        if (y0 == null) return;
        object? z0 = new object();
        z0 = y0;
        M2(out M3(z0), out x0).ToString();
    }

    ref U M2<U>(out U a, out U b) => throw null;
    ref U M3<U>(U a) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_075()
        {
            var source = @"
class Outer
{
    void M0<T>() where T : new()
    {
        T x0;
        x0 = new T();
        x0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_076()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        M2(ref x0, ref y0) = z0;
    }

    ref U M2<U>(ref U a, ref U b) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_077()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        if (x0 == null) return;
        M2(ref M3(x0), ref y0) = z0;
        M2<T>(ref M3(x0), ref y0);

        M2(ref M3(x0), ref y0).ToString();
    }

    ref U M2<U>(ref U a, ref U b) => throw null;
    ref U M3<U>(U a) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         M2(ref M3(x0), ref y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(ref M3(x0), ref y0)").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_078()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        if (y0 == null) return;
        M2(ref x0, ref M3(y0)) = z0;
        M2<T>(ref x0, ref M3(y0));

        M2(ref x0, ref M3(y0)).ToString();
    }

    ref U M2<U>(ref U a, ref U b) => throw null;
    ref U M3<U>(U a) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         M2(ref x0, ref M3(y0)).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(ref x0, ref M3(y0))").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_079()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, T y0, U z0) where U : T
    {
        if (x0 == null) return;
        if (y0 == null) return;
        M2(ref M3(x0), ref M3(y0)) = z0;
        M2<T>(ref M3(x0), ref M3(y0)) = z0;
    }

    ref U M2<U>(ref U a, ref U b) where U : object => throw null;
    ref U M3<U>(U a) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8631: The type 'T' cannot be used as type parameter 'U' in the generic type or method 'Outer.M2<U>(ref U, ref U)'. Nullability of type argument 'T' doesn't match constraint type 'object'.
                //         M2(ref M3(x0), ref M3(y0)) = z0;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M2").WithArguments("Outer.M2<U>(ref U, ref U)", "object", "U", "T").WithLocation(8, 9),
                // (9,9): warning CS8631: The type 'T' cannot be used as type parameter 'U' in the generic type or method 'Outer.M2<U>(ref U, ref U)'. Nullability of type argument 'T' doesn't match constraint type 'object'.
                //         M2<T>(ref M3(x0), ref M3(y0)) = z0;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M2<T>").WithArguments("Outer.M2<U>(ref U, ref U)", "object", "U", "T").WithLocation(9, 9)
                );
        }

        [Fact]
        [WorkItem(30946, "https://github.com/dotnet/roslyn/issues/30946")]
        public void NullabilityOfTypeParameters_080()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        if (x0 == null) return;
        M2(x0).M3(ref y0);
        M2<T>(x0).M3(ref y0);
    }

    Other<U> M2<U>(U a) where U : object => throw null;
}

class Other<U> where U : object
{
    public void M3(ref U a) => throw null;
}
";
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): warning CS8631: The type 'T' cannot be used as type parameter 'U' in the generic type or method 'Outer.M2<U>(U)'. Nullability of type argument 'T' doesn't match constraint type 'object'.
                //         M2(x0).M3(ref y0);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M2").WithArguments("Outer.M2<U>(U)", "object", "U", "T").WithLocation(7, 9),
                // (8,9): warning CS8631: The type 'T' cannot be used as type parameter 'U' in the generic type or method 'Outer.M2<U>(U)'. Nullability of type argument 'T' doesn't match constraint type 'object'.
                //         M2<T>(x0).M3(ref y0);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M2<T>").WithArguments("Outer.M2<U>(U)", "object", "U", "T").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_081()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0)
    {
        M2(x0);
    }

    void M2(object a) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,12): warning CS8604: Possible null reference argument for parameter 'a' in 'void Outer.M2(object a)'.
                //         M2(x0);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x0").WithArguments("a", "void Outer.M2(object a)").WithLocation(6, 12)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_082()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0)
    {
        M2(x0);
    }

    void M2(in object a) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,12): warning CS8604: Possible null reference argument for parameter 'a' in 'void Outer.M2(in object a)'.
                //         M2(x0);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x0").WithArguments("a", "void Outer.M2(in object a)").WithLocation(6, 12)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_083()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, I1<T> y0, I1<string?> z0) where T : class?
    {
        M3(M2(x0));
        M3<I1<T>>(y0);
        M3<I1<string?>>(z0);
    }

    I1<U> M2<U>(U a) => throw null;
    void M3<U>(U a) where U : I1<object> => throw null;
}

interface I1<out U> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,9): warning CS8631: The type 'I1<T>' cannot be used as type parameter 'U' in the generic type or method 'Outer.M3<U>(U)'. Nullability of type argument 'I1<T>' doesn't match constraint type 'I1<object>'.
                //         M3(M2(x0));
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M3").WithArguments("Outer.M3<U>(U)", "I1<object>", "U", "I1<T>").WithLocation(6, 9),
                // (7,9): warning CS8631: The type 'I1<T>' cannot be used as type parameter 'U' in the generic type or method 'Outer.M3<U>(U)'. Nullability of type argument 'I1<T>' doesn't match constraint type 'I1<object>'.
                //         M3<I1<T>>(y0);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M3<I1<T>>").WithArguments("Outer.M3<U>(U)", "I1<object>", "U", "I1<T>").WithLocation(7, 9),
                // (8,9): warning CS8631: The type 'I1<string?>' cannot be used as type parameter 'U' in the generic type or method 'Outer.M3<U>(U)'. Nullability of type argument 'I1<string?>' doesn't match constraint type 'I1<object>'.
                //         M3<I1<string?>>(z0);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M3<I1<string?>>").WithArguments("Outer.M3<U>(U)", "I1<object>", "U", "I1<string?>").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_084()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, I1<T> y0, I1<object> z0, U? a0) where T : class? where U : class, T
    {
        M3(M2(x0), a0);
        
        if (x0 == null) return;
        M3(M2(x0), a0);

        M3<I1<T>, U>(y0, null);
        M3<I1<object>, string>(z0, null);
    }

    I1<U> M2<U>(U a) => throw null;
    void M3<U, W>(U a, W? b) where U : I1<W?> where W : class => throw null;
}

interface I1<in U> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,9): warning CS8631: The type 'I1<T>' cannot be used as type parameter 'U' in the generic type or method 'Outer.M3<U, W>(U, W?)'. Nullability of type argument 'I1<T>' doesn't match constraint type 'I1<U?>'.
                //         M3(M2(x0), a0);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M3").WithArguments("Outer.M3<U, W>(U, W?)", "I1<U?>", "U", "I1<T>").WithLocation(6, 9),
                // (9,9): warning CS8631: The type 'I1<T>' cannot be used as type parameter 'U' in the generic type or method 'Outer.M3<U, W>(U, W?)'. Nullability of type argument 'I1<T>' doesn't match constraint type 'I1<U?>'.
                //         M3(M2(x0), a0);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M3").WithArguments("Outer.M3<U, W>(U, W?)", "I1<U?>", "U", "I1<T>").WithLocation(9, 9),
                // (11,9): warning CS8631: The type 'I1<T>' cannot be used as type parameter 'U' in the generic type or method 'Outer.M3<U, W>(U, W?)'. Nullability of type argument 'I1<T>' doesn't match constraint type 'I1<U?>'.
                //         M3<I1<T>, U>(y0, null);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M3<I1<T>, U>").WithArguments("Outer.M3<U, W>(U, W?)", "I1<U?>", "U", "I1<T>").WithLocation(11, 9),
                // (12,9): warning CS8631: The type 'I1<object>' cannot be used as type parameter 'U' in the generic type or method 'Outer.M3<U, W>(U, W?)'. Nullability of type argument 'I1<object>' doesn't match constraint type 'I1<string?>'.
                //         M3<I1<object>, string>(z0, null);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M3<I1<object>, string>").WithArguments("Outer.M3<U, W>(U, W?)", "I1<string?>", "U", "I1<object>").WithLocation(12, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_085()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, I1<T> y0, I1<object> z0, T a0)
    {
        if (x0 == null) return;
        M3(M2(x0), a0);
        M3(M2(a0), x0);
        M3<I1<object>, object?>(z0, null);
    }

    I1<U> M2<U>(U a) => throw null;
    void M3<U, W>(U a, W b) where U : I1<W> => throw null;
}

interface I1<U> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (9,9): warning CS8631: The type 'I1<object>' cannot be used as type parameter 'U' in the generic type or method 'Outer.M3<U, W>(U, W)'. Nullability of type argument 'I1<object>' doesn't match constraint type 'I1<object?>'.
                //         M3<I1<object>, object?>(z0, null);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M3<I1<object>, object?>").WithArguments("Outer.M3<U, W>(U, W)", "I1<object?>", "U", "I1<object>").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_086()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, I1<string> z0) where T : class?
    {
        if (x0 == null) return;
        M3(M2(x0));
        M3(M2<T>(x0));
        M3<I1<T>>(M2(x0));
        M3<I1<string>>(z0);
    }

    I1<U> M2<U>(U a) => throw null;
    void M3<U>(U a) where U : I1<object> => throw null;
}

interface I1<out U> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): warning CS8631: The type 'I1<T>' cannot be used as type parameter 'U' in the generic type or method 'Outer.M3<U>(U)'. Nullability of type argument 'I1<T>' doesn't match constraint type 'I1<object>'.
                //         M3(M2(x0));
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M3").WithArguments("Outer.M3<U>(U)", "I1<object>", "U", "I1<T>").WithLocation(7, 9),
                // (8,9): warning CS8631: The type 'I1<T>' cannot be used as type parameter 'U' in the generic type or method 'Outer.M3<U>(U)'. Nullability of type argument 'I1<T>' doesn't match constraint type 'I1<object>'.
                //         M3(M2<T>(x0));
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M3").WithArguments("Outer.M3<U>(U)", "I1<object>", "U", "I1<T>").WithLocation(8, 9),
                // (9,9): warning CS8631: The type 'I1<T>' cannot be used as type parameter 'U' in the generic type or method 'Outer.M3<U>(U)'. Nullability of type argument 'I1<T>' doesn't match constraint type 'I1<object>'.
                //         M3<I1<T>>(M2(x0));
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M3<I1<T>>").WithArguments("Outer.M3<U>(U)", "I1<object>", "U", "I1<T>").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_087()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, I1<T> y0, I1<object> z0, U? a0) where T : class? where U : class, T
    {
        M3(M2(x0), a0);
        
        if (x0 == null) return;
        M3(M2(x0), a0);

        M3<I1<T>, U>(y0, null);
        M3<I1<object>, string>(z0, null);
    }

    I1<U> M2<U>(U a) => throw null;
    void M3<U, W>(U a, W? b) where U : I1<W> where W : class => throw null;
}

interface I1<in U> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_088()
        {
            var source = @"
class Outer
{
    void M0<T, U>(T x0, I1<T> y0, I1<object> z0, U a0) where T : class? where U : class?, T
    {
        M3(M2(x0), a0);
        
        if (x0 == null) return;
        M3(M2(x0), a0); // 1

        M3<I1<T>, U>(y0, a0);
        M3<I1<object>, string?>(z0, null);
    }

    I1<U> M2<U>(U a) => throw null;
    void M3<U, W>(U a, W b) where U : I1<W> => throw null;
}

interface I1<in U> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (12,9): warning CS8631: The type 'I1<object>' cannot be used as type parameter 'U' in the generic type or method 'Outer.M3<U, W>(U, W)'. Nullability of type argument 'I1<object>' doesn't match constraint type 'I1<string?>'.
                //         M3<I1<object>, string?>(z0, null);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "M3<I1<object>, string?>").WithArguments("Outer.M3<U, W>(U, W)", "I1<string?>", "U", "I1<object>").WithLocation(12, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_089()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, I1<T> y0, I1<object> z0, T a0)
    {
        if (x0 == null) return;
        if (a0 == null) return;
        M3(M2(x0), a0);
        M3(M2(a0), x0);
        M3<I1<object>, object>(z0, new object());
    }

    I1<U> M2<U>(U a) => throw null;
    void M3<U, W>(U a, W b) where U : I1<W> => throw null;
}

interface I1<U> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_090()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, I1<T> y0, I1<object> z0, T a0)
    {
        M3(M2(x0), a0);
        M3<I1<T>,T>(y0, a0);
    }

    I1<U> M2<U>(U a) => throw null;
    void M3<U, W>(U a, W b) where U : I1<W> => throw null;
}

interface I1<U> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_091()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0) where T : I1?
    {
        x0?.ToString();
        x0?.M1(x0);
        x0.ToString();
    }
}

interface I1
{
    void M1(object x);
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         x0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_092()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0)
    {
        if (x0 is null) return;
        x0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_093()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        if (y0 == null) return;
        T z0 = x0 ?? y0;
        M1(z0) = x0;

        M1(z0).ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         M1(z0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(z0)").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_094()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        (x0 ?? y0).ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (x0 ?? y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x0 ?? y0").WithLocation(6, 10)
                );
        }

        [Fact]
        [WorkItem(30952, "https://github.com/dotnet/roslyn/issues/30952")]
        public void NullabilityOfTypeParameters_095()
        {
            var source = @"
class Outer
{
    void M0<T>(object? x0, T z0)
    {
        if (x0 is T y0)
        {
            M2(y0) = z0;
            x0.ToString();
            y0.ToString();
        }
    }

    ref T M2<T>(T x) => throw null;
}
";
            // https://github.com/dotnet/roslyn/issues/30952 - Expect WRN_NullReferenceAssignment for [M2(y0) = z0;]
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(30952, "https://github.com/dotnet/roslyn/issues/30952")]
        public void NullabilityOfTypeParameters_096()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, object? z0)
    {
        if (x0 is object y0)
        {
            M2(y0) = z0;
            x0.ToString();
            y0.ToString();
        }
    }

    ref T M2<T>(T x) => throw null;
}
";

            // https://github.com/dotnet/roslyn/issues/30952 - Expect WRN_NullReferenceAssignment for [M2(y0) = z0;]
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_097()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T z0)
    {
        if (x0 is var y0)
        {
            M2(y0) = z0;
            x0.ToString();
            y0.ToString();
        }
    }

    ref T M2<T>(T x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (9,13): warning CS8602: Possible dereference of a null reference.
                //             x0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x0").WithLocation(9, 13),
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(10, 13)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_098()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0)
    {
        if (x0 is default) return;
        x0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,19): error CS8505: A default literal 'default' is not valid as a pattern. Use another literal (e.g. '0' or 'null') as appropriate. To match everything, use a discard pattern '_'.
                //         if (x0 is default) return;
                Diagnostic(ErrorCode.ERR_DefaultPattern, "default").WithLocation(6, 19),
                // (6,19): error CS0150: A constant value is expected
                //         if (x0 is default) return;
                Diagnostic(ErrorCode.ERR_ConstantExpected, "default").WithLocation(6, 19),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x0").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_099()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0)
    {
        if (x0 is default(T)) return;
        x0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,19): error CS0150: A constant value is expected
                //         if (x0 is default(T)) return;
                Diagnostic(ErrorCode.ERR_ConstantExpected, "default(T)").WithLocation(6, 19),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x0").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_100()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0) where T : class?
    {
        if (x0 is null) return;
        M2(x0) = y0;

        M2(x0).ToString();
        x0.ToString();
    }

    ref T M2<T>(T x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         M2(x0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(x0)").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_101()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        if (y0 == null) return;
        (x0 ?? y0)?.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,10): hidden CS8607: Expression is probably never null.
                //         (x0 ?? y0)?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0 ?? y0").WithLocation(7, 10)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_102()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0) where T : class?
    {
        if (x0 == null) return;
        M2(x0) = y0;

        M2(x0).ToString();
        x0.ToString();
    }

    ref T M2<T>(T x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         M2(x0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(x0)").WithLocation(9, 9)
                );
        }

        [Fact]
        [WorkItem(30952, "https://github.com/dotnet/roslyn/issues/30952")]
        public void NullabilityOfTypeParameters_103()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T z0)
    {
        if (x0 is T y0)
        {
            M2(x0) = z0;
            M2(y0) = z0;
            M2(x0).ToString();
            M2(y0).ToString();
            x0.ToString();
            y0.ToString();
        }
    }

    ref T M2<T>(T x) => throw null;
}
";
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (10,13): warning CS8602: Possible dereference of a null reference.
                //             M2(x0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(x0)").WithLocation(10, 13)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_104()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0)
    {
        T y0;

        if (b)
        {
            y0 = M2();
        }
        else
        {
            y0 = x0;
        }

        y0.ToString();
    }

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(17, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_105()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0)
    {
        T y0;

        if (b)
        {
            y0 = x0;
        }
        else
        {
            y0 = M2();
        }

        y0.ToString();
    }

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(17, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_106()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0)
    {
        T y0;

        if (b || x0 == null)
        {
            y0 = M3();
        }
        else
        {
            y0 = x0;
        }

        M2(y0) = x0;
        y0.ToString();
    }

    ref T M2<U>(U x) => throw null;

#nullable disable
    T M3() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_107()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0)
    {
        T y0;

        if (b && x0 != null)
        {
            y0 = x0;
        }
        else
        {
            y0 = M3();
        }

        M2(y0) = x0;
        y0.ToString();
    }

    ref T M2<U>(U x) => throw null;

#nullable disable
    T M3() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_108()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0)
    {
        x0!.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_109()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0) where T : I1<T?>
    {
        x0 = default;
    }

    void M1<T>(T x1) where T : I1<T>
    {
        x1 = default;
    }
}

interface I1<T> {}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (4,35): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     void M0<T>(T x0) where T : I1<T?>
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(4, 35),
                // (6,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x0 = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(6, 14),
                // (11,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x1 = default;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(11, 14)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_110()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        if (x0 == null) return;
        T z0 = x0 ?? y0;
        M1(z0).ToString();
        M1(z0) = y0;
        z0.ToString();
        z0?.ToString();
    }

    ref S M1<S>(S x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): hidden CS8607: Expression is probably never null.
                //         T z0 = x0 ?? y0;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(7, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         M1(z0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(z0)").WithLocation(8, 9),
                // (11,9): hidden CS8607: Expression is probably never null.
                //         z0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z0").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_111()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0, T a0)
    {
        if (x0 == null) return;
        if (y0 == null) return;
        T z0 = x0 ?? y0;
        M1(z0) = a0;
        z0?.ToString();
        M1(z0).ToString();
    }

    ref S M1<S>(S x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,16): hidden CS8607: Expression is probably never null.
                //         T z0 = x0 ?? y0;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(8, 16),
                // (10,9): hidden CS8607: Expression is probably never null.
                //         z0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z0").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         M1(z0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(z0)").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_112()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        if (x0 == null) return;
        var z0 = x0;
        z0 = y0;
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         z0 = y0;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y0").WithLocation(8, 14)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_113()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0, T u0, T v0)
    {
        var a0 = new[] {x0, y0};
        a0[0] = u0;
        if (v0 == null) return;
        a0[0] = v0;
        M2(v0) = a0[1];
        M2(v0).ToString();
    }

    ref T M2<T>(T x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         M2(v0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(v0)").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_114()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0, T u0, T v0)
    {
        if (x0 == null) return;
        var a0 = new[] {x0, y0};
        a0[0] = u0;
        if (v0 == null) return;
        a0[0] = v0;
        M2(v0) = a0[1];
        M2<T>(v0) = a0[1];
        M2(v0).ToString();
    }

    ref T M2<T>(T x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         M2(v0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(v0)").WithLocation(13, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_115()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0, T u0, T v0)
    {
        if (y0 == null) return;
        var a0 = new[] {x0, y0};
        a0[0] = u0;
        if (v0 == null) return;
        a0[0] = v0;
        M2(v0) = a0[1];
        M2<T>(v0) = a0[1];
        M2(v0).ToString();
    }

    ref T M2<T>(T x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         M2(v0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(v0)").WithLocation(13, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_116()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0, T u0, T v0)
    {
        if (x0 == null) return;
        if (y0 == null) return;
        var a0 = new[] {x0, y0};
        a0[0] = u0;
        a0[0].ToString();
        if (v0 == null) return;
        a0[0] = v0;
        M2(v0) = a0[1];
    }

    ref T M2<T>(T x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         a0[0].ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a0[0]").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_117()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T u0, T v0)
    {
        var a0 = new[] {x0, M3()};
        a0[0] = u0;
        if (v0 == null) return;
        a0[0] = v0;
        M2(v0) = a0[1];
    }

    ref T M2<U>(U x) => throw null;

#nullable disable
    T M3() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_118()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T u0, T v0)
    {
        var a0 = new[] {M3(), x0};
        a0[0] = u0;
        if (v0 == null) return;
        a0[0] = v0;
        M2(v0) = a0[1];
    }

    ref T M2<U>(U x) => throw null;

#nullable disable
    T M3() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_119()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T u0, T v0)
    {
        if (x0 == null) return;
        var a0 = new[] {x0, M3()};
        a0[0] = u0;
        if (v0 == null) return;
        a0[0] = v0;
        M2(v0) = a0[1];
    }

    ref T M2<U>(U x) => throw null;

#nullable disable
    T M3() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_120()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T u0, T v0)
    {
        if (x0 == null) return;
        var a0 = new[] {M3(), x0};
        a0[0] = u0;
        if (v0 == null) return;
        a0[0] = v0;
        M2(v0) = a0[1];
    }

    ref T M2<U>(U x) => throw null;

#nullable disable
    T M3() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_121()
        {
            var source = @"
class Outer<T>
{
    void M0(T u0, T v0)
    {
        var a0 = new[] {M3(), M3()};
        a0[0] = u0;
        if (v0 == null) return;
        a0[0] = v0;
        M2(v0) = a0[1];
    }

    ref T M2<U>(U x) => throw null;

#nullable disable
    T M3() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_122()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0)
    {
        T y0;

        if (b)
        {
            y0 = M3();
        }
        else
        {
            y0 = M3();
        }

        M2(y0) = x0;
        y0.ToString();
    }

    ref T M2<U>(U x) => throw null;

#nullable disable
    T M3() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_123()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0, T a0, T b0)
    {
        if (a0 == null) return;
        if (b0 == null) return;

        T y0;

        if (b)
        {
            y0 = a0;
        }
        else
        {
            y0 = b0;
        }

        M2(y0) = x0;
        y0.ToString();
    }

    ref T M2<U>(U x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_124()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0, T a0, T b0)
    {
        T y0;

        if (b)
        {
            y0 = a0;
        }
        else
        {
            y0 = b0;
        }

        M2(y0) = x0;
        y0.ToString();
    }

    ref T M2<U>(U x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (18,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(18, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_125()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0, T a0, T b0)
    {
        if (a0 == null) return;

        T y0;

        if (b)
        {
            y0 = a0;
        }
        else
        {
            y0 = b0;
        }

        M2(y0) = x0;
        y0.ToString();
    }

    ref T M2<U>(U x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(20, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_126()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0, T a0, T b0)
    {
        if (b0 == null) return;

        T y0;

        if (b)
        {
            y0 = a0;
        }
        else
        {
            y0 = b0;
        }

        M2(y0) = x0;
        y0.ToString();
    }

    ref T M2<U>(U x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(20, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_127()
        {
            var source =
@"
class C<T>
{
    public C<object> X = null!;
    public C<object?> Y = null!;
    void F(object? y0)
    {
        if (y0 == null) return;
        object? x0;
        x0 = null;

        _ = new C<int>()
            {
                Y = M(x0),  
                X = M(y0)
            };
    }

    ref C<S> M<S>(S x) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_128()
        {
            var source =
@"
class C<T>
{
    void F(object? y0)
    {
        if (y0 == null) return;
        object? x0;
        x0 = null;
        
        M2(
            out M1(x0),  
            out M1(y0)
        );
    }

    ref C<S> M1<S>(S x) => throw null;
    void M2(out C<object?> x, out C<object> y) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_129()
        {
            var source =
@"
class C<T>
{
    void F(object? y0)
    {
        if (y0 == null) return;
        object? x0;
        x0 = null;
        
        M2(
            ref M1(x0),  
            ref M1(y0)
        );
    }

    ref C<S> M1<S>(S x) => throw null;
    void M2(ref C<object?> x, ref C<object> y) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_130()
        {
            var source =
@"
class C<T>
{
    void F(object? y0)
    {
        if (y0 == null) return;
        object? x0;
        x0 = null;
        
        M2(M1(x0), M1(y0)) = 
            (C<object?> a, C<object> b) => throw null;
    }

    C<S> M1<S>(S x) => throw null;
    ref System.Action<U, V> M2<U, V>(U x, V y) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_131()
        {
            var source =
@"
class C<T> where T : class?
{
    void F(T y0)
    {
        if (y0 == null) return;
        T x0;
        x0 = null;

        M2(M1(x0), M1(y0)) =
            (C<T> a, C<T> b) => throw null;
    }

    C<S> M1<S>(S x) where S : class? => throw null;
    ref System.Action<U, V> M2<U, V>(U x, V y) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,14): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x0 = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(8, 14),
                // (10,15): warning CS8604: Possible null reference argument for parameter 'x' in 'C<T> C<T>.M1<T>(T x)'.
                //         M2(M1(x0), M1(y0)) =
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "x0").WithArguments("x", "C<T> C<T>.M1<T>(T x)").WithLocation(10, 15)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_132()
        {
            var source =
@"
class C<T> where T : class?
{
    void F(T x0, T y0)
    {
        M2(M1(x0), M1(y0)) = 
            (C<T> a, C<T> b) => throw null;
    }

    C<S> M1<S>(S x) where S : class? => throw null;
    ref System.Action<U, V> M2<U, V>(U x, V y) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_133()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        if (y0 == null) return;
        T z0 = M2() ?? y0;
        M1(z0) = x0;
        M1<T>(z0) = x0;

        M1(z0).ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         M1(z0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(z0)").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_134()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        if (y0 == null) return;
        T z0 = y0 ?? M2();
        M1(z0) = x0;
        M1<T>(z0) = x0;

        M1(z0).ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): hidden CS8607: Expression is probably never null.
                //         T z0 = y0 ?? M2();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(7, 16),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         M1(z0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(z0)").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_135()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0)
    {
        T z0 = M2() ?? M2();
        M1(z0) = x0;
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_136()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        T z0 = M2() ?? y0;
        M1(z0) = x0;
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_137()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        T z0 = y0 ?? M2();
        M1(z0) = x0;
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_138()
        {
            var source =
@"
class C<T> where T : class?
{
    void F(T x0, T y0)
    {
        T z0 = x0 ?? y0;
        M2(M1(z0)) = 
            (C<T> a) => throw null;
    }

    C<S> M1<S>(S x) where S : class? => throw null;
    ref System.Action<U> M2<U>(U x) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_139()
        {
            var source =
@"
class C<T> where T : class?
{
    void F(T x0, T y0)
    {
        T z0 = x0 ?? y0;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_140()
        {
            var source =
@"
class C<T> where T : class?
{
    void F(T x0, T y0)
    {
        T z0 = new [] {x0, y0}[0];
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_141()
        {
            var source =
@"
struct C<T> where T : class?
{
    void F(T x0, object? y0)
    {
        F1 = x0;
        F2 = y0;

        x0 = F1;
        y0 = F2;
    }

#nullable disable
    T F1;
    object F2;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_142()
        {
            var source = @"
class Outer
{
    void M0<T>(bool b, T x0, T y0)
    {
        (b ? x0 : y0).ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x0 : y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x0 : y0").WithLocation(6, 10)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_143()
        {
            var source = @"
class Outer
{
    void M0<T>(bool b, T x0, T y0)
    {
        if (y0 == null) return;
        (b ? x0 : y0).ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x0 : y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x0 : y0").WithLocation(7, 10)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_144()
        {
            var source = @"
class Outer
{
    void M0<T>(bool b, T x0, T y0)
    {
        if (x0 == null) return;
        (b ? x0 : y0).ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         (b ? x0 : y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b ? x0 : y0").WithLocation(7, 10)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_145()
        {
            var source = @"
class Outer
{
    void M0<T>(bool b, T x0, T y0, T a0)
    {
        if (x0 == null) return;
        if (y0 == null) return;
        T z0 = b ? x0 : y0;
        M1(z0) = a0;
        z0?.ToString();
        M1(z0).ToString();
    }

    ref S M1<S>(S x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (10,9): hidden CS8607: Expression is probably never null.
                //         z0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z0").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         M1(z0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(z0)").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_146()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0, T y0)
    {
        if (y0 == null) return;
        T z0 = b ? M2() : y0;
        M1(z0) = x0;
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_147()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0, T y0)
    {
        if (y0 == null) return;
        T z0 = b ? y0 : M2();
        M1(z0) = x0;
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_148()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0)
    {
        T z0 = b ? M2() : M2();
        M1(z0) = x0;
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_149()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0, T y0)
    {
        T z0 = b ? M2() : y0;
        M1(z0) = x0;
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_150()
        {
            var source = @"
class Outer<T>
{
    void M0(bool b, T x0, T y0)
    {
        T z0 = b ? y0 : M2();
        M1(z0) = x0;
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_151()
        {
            var source =
@"
class C<T> where T : class?
{
    void F(bool b, T x0, T y0)
    {
        T z0 = b ? x0 : y0;
        M2(M1(z0)) = 
            (C<T> a) => throw null;
    }

    C<S> M1<S>(S x) where S : class? => throw null;
    ref System.Action<U> M2<U>(U x) => throw null;
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_153()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        (true ? x0 : y0).ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (true ? x0 : y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "true ? x0 : y0").WithLocation(6, 10)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_154()
        {
            var source = @"
class Outer
{
    void M0<T>(bool b, T x0, T y0)
    {
        if (y0 == null) return;
        (true ? x0 : y0).ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         (true ? x0 : y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "true ? x0 : y0").WithLocation(7, 10)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_155()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        if (x0 == null) return;
        (true ? x0 : y0).ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_156()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0, T a0)
    {
        if (x0 == null) return;
        if (y0 == null) return;
        T z0 = true ? x0 : y0;
        M1(z0) = a0;
        M1(z0).ToString();
        z0?.ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         M1(z0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(z0)").WithLocation(10, 9),
                // (11,9): hidden CS8607: Expression is probably never null.
                //         z0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z0").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_157()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        if (y0 == null) return;
        T z0 = true ? M2() : y0;
        M1(z0) = x0;
        z0?.ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_158()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        if (y0 == null) return;
        T z0 = true ? y0 : M2();
        M1(z0) = x0;
        M1(z0).ToString();
        z0?.ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         M1(z0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(z0)").WithLocation(9, 9),
                // (10,9): hidden CS8607: Expression is probably never null.
                //         z0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z0").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_159()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0)
    {
        T z0 = true ? M2() : M2();
        M1(z0) = x0;
        z0?.ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_160()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        T z0 = true ? M2() : y0;
        M1(z0) = x0;
        z0?.ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_161()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        T z0 = true ? y0 : M2();
        M1(z0) = x0;
        z0?.ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_162()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        (false ? x0 : y0).ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (false ? x0 : y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "false ? x0 : y0").WithLocation(6, 10)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_163()
        {
            var source = @"
class Outer
{
    void M0<T>(bool b, T x0, T y0)
    {
        if (y0 == null) return;
        (false ? x0 : y0).ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_164()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        if (x0 == null) return;
        (false ? x0 : y0).ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         (false ? x0 : y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "false ? x0 : y0").WithLocation(7, 10)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_165()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0, T a0)
    {
        if (x0 == null) return;
        if (y0 == null) return;
        T z0 = false ? x0 : y0;
        M1(z0) = a0;
        M1(z0).ToString();
        z0?.ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         M1(z0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(z0)").WithLocation(10, 9),
                // (11,9): hidden CS8607: Expression is probably never null.
                //         z0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z0").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_166()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        if (y0 == null) return;
        T z0 = false ? M2() : y0;
        M1(z0) = x0;
        M1(z0).ToString();
        z0?.ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         M1(z0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(z0)").WithLocation(9, 9),
                // (10,9): hidden CS8607: Expression is probably never null.
                //         z0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z0").WithLocation(10, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_167()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        if (y0 == null) return;
        T z0 = false ? y0 : M2();
        M1(z0) = x0;
        z0?.ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_168()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0)
    {
        T z0 = false ? M2() : M2();
        M1(z0) = x0;
        z0?.ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_169()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        T z0 = false ? M2() : y0;
        M1(z0) = x0;
        z0?.ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_170()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        T z0 = false ? y0 : M2();
        M1(z0) = x0;
        z0?.ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_171()
        {
            var source = @"
class Outer<T, U> where T : Outer<T, U>? where U : T
{
    void M0(T x0)
    {
        U y0 = (U)x0;
        U z0 = y0;
        y0?.ToString();
        y0.ToString();
        z0?.ToString();
        z0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         U y0 = (U)x0;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)x0").WithLocation(6, 16),
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         U z0 = y0;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y0").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_172()
        {
            var source = @"
class Outer<T, U> where T : class? where U : T
{
    void M0(T x0)
    {
        U y0 = (U)x0;
        U z0 = y0;
        y0?.ToString();
        y0.ToString();
        z0?.ToString();
        z0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         U y0 = (U)x0;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)x0").WithLocation(6, 16),
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         U z0 = y0;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y0").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_173()
        {
            var source = @"
class Outer<T, U> where T : Outer<T, U>?, U
{
    void M0(T x0)
    {
        T z0 = x0?.M1();
        U y0 = z0;
        y0?.ToString();
        y0.ToString();
        z0?.ToString();
        z0.ToString();
    }

    T M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_174()
        {
            var source = @"
class Outer<T, U> where T : Outer<T, U>? where U : T
{
    void M0(T x0)
    {
        T z0 = x0?.M1();
        U y0 = (U)z0;
        y0?.ToString();
        y0.ToString();
        z0?.ToString();
        z0.ToString();
    }

    T M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         U y0 = (U)z0;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(U)z0").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_175()
        {
            var source = @"
class Outer<T, U> where T : Outer<T, U>?, U
{
    void M0(T x0)
    {
        if (x0 == null) return;
        T z0 = x0?.M1();
        U y0 = z0;
        y0?.ToString();
        y0.ToString();
        z0?.ToString();
        z0.ToString();
    }

    T M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): hidden CS8607: Expression is probably never null.
                //         T z0 = x0?.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(7, 16),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(10, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(12, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_176()
        {
            var source = @"
class Outer<T, U> where T : Outer<T, U>?, U
{
    void M0(Outer<T, U>? x0)
    {
        T z0 = x0?.M1();
        U y0 = z0;
        y0?.ToString();
        y0.ToString();
        z0?.ToString();
        z0.ToString();
    }

    T M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T z0 = x0?.M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0?.M1()").WithLocation(6, 16),
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         U y0 = z0;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "z0").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_177()
        {
            var source = @"
class Outer<T, U> where T : Outer<T, U>?, U
{
    void M0(Outer<T, U> x0)
    {
        T z0 = x0?.M1();
        U y0 = z0;
        y0?.ToString();
        y0.ToString();
        z0?.ToString();
        z0.ToString();
    }

    T M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): hidden CS8607: Expression is probably never null.
                //         T z0 = x0?.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(6, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(11, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_178()
        {
            var source = @"
class Outer<T> where T : Outer<T>?
{
    void M0(T x0)
    {
        Outer<T> z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    Outer<T> M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         Outer<T> z0 = x0?.M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0?.M1()").WithLocation(6, 23),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_179()
        {
            var source = @"
class Outer<T> where T : Outer<T>?
{
    void M0(T x0)
    {
        if (x0 == null) return;
        Outer<T> z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    Outer<T> M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,23): hidden CS8607: Expression is probably never null.
                //         Outer<T> z0 = x0?.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(7, 23),
                // (8,9): hidden CS8607: Expression is probably never null.
                //         z0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_180()
        {
            var source = @"
class Outer<T> where T : Outer<T>?
{
    void M0(T x0)
    {
        Outer<T> z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    Outer<T>? M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         Outer<T> z0 = x0?.M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0?.M1()").WithLocation(6, 23),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_181()
        {
            var source = @"
class Outer<T> where T : Outer<T>?
{
    void M0(T x0)
    {
        if (x0 == null) return;
        Outer<T> z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    Outer<T>? M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,23): hidden CS8607: Expression is probably never null.
                //         Outer<T> z0 = x0?.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(7, 23),
                // (7,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         Outer<T> z0 = x0?.M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0?.M1()").WithLocation(7, 23),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_182()
        {
            var source = @"
class Outer<T, U> where T : Outer<T, U>?, U where U : class?
{
    void M0(T x0)
    {
        U z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    U M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_183()
        {
            var source = @"
class Outer<T, U> where T : Outer<T, U>?, U where U : class?
{
    void M0(T x0)
    {
        if (x0 == null) return;
        U z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    U M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): hidden CS8607: Expression is probably never null.
                //         U z0 = x0?.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_184()
        {
            var source = @"
class Outer<T, U> where T : U where U : Outer<T, U>?
{
    void M0(U x0)
    {
        U z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    T M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_185()
        {
            var source = @"
class Outer<T, U> where T : U where U : Outer<T, U>?
{
    void M0(U x0)
    {
        T z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    T M1() => throw null;
}
";
            // Strictly speaking, we should warn on assignment (“T z0 = x0?.M1();”) because T
            // could be not-nullable reference type and U can be nullable reference type at
            // the same time, making result of conditional access nullable of T. However,
            // assigning the same value to U (the previous unit-test) should not warn. If U is
            // not-nullable reference type, T is also not nullable, the result of conditional
            // access is not nullable T.
            // At the moment, we don’t have a way to track this complex dependency between nullable
            // state and possible target type. During implementation the preference is given to
            // suppression of incorrect warning for the scenario from the previous unit-test.
            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_186()
        {
            var source = @"
class Outer<T, U> where T : U where U : Outer<T, U>?
{
    void M0(U x0)
    {
        if (x0 == null) return;
        U z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    T M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): hidden CS8607: Expression is probably never null.
                //         U z0 = x0?.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_187()
        {
            var source = @"
class Outer<T, U> where T : U where U : Outer<T, U>?
{
    void M0(U x0)
    {
        if (x0 == null) return;
        T z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    T M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): hidden CS8607: Expression is probably never null.
                //         T z0 = x0?.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_188()
        {
            var source = @"
class Outer<T, U> where T : Outer<T, U>? where U : class?
{
    void M0(T x0)
    {
        U z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    U M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         U z0 = x0?.M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0?.M1()").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_189()
        {
            var source = @"
class Outer<T, U> where T : Outer<T, U>? where U : class?
{
    void M0(T x0)
    {
        if (x0 == null) return;
        U z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    U M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): hidden CS8607: Expression is probably never null.
                //         U z0 = x0?.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_190()
        {
            var source = @"
class Outer<T, U> where T : Outer<T, U>? where U : class
{
    void M0(T x0)
    {
        U z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    U M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         U z0 = x0?.M1();
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0?.M1()").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         z0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_191()
        {
            var source = @"
class Outer<T, U> where T : Outer<T, U>? where U : class
{
    void M0(T x0)
    {
        if (x0 == null) return;
        U z0 = x0?.M1();
        z0?.ToString();
        z0.ToString();
    }

    U M1() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): hidden CS8607: Expression is probably never null.
                //         U z0 = x0?.M1();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(7, 16),
                // (8,9): hidden CS8607: Expression is probably never null.
                //         z0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "z0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_192()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0)
    {
        object y0 = x0 as object;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,21): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object y0 = x0 as object;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as object").WithLocation(6, 21),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_193()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0)
    {
        if (x0 == null) return;
        object y0 = x0 as object;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_194()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0)
    {
        dynamic y0 = x0 as dynamic;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         dynamic y0 = x0 as dynamic;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as dynamic").WithLocation(6, 22),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_195()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0)
    {
        if (x0 == null) return;
        dynamic y0 = x0 as dynamic;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_196()
        {
            var source = @"
class Outer<T> where T : class?
{
    void M0(object x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_197()
        {
            var source = @"
class Outer<T> where T : class?
{
    void M0(object? x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_198()
        {
            var source = @"
class Outer<T> where T : class?
{
    void M0(object? x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_199()
        {
            var source = @"
class Outer<T> where T : class?
{
    void M0(dynamic x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_200()
        {
            var source = @"
class Outer<T> where T : class?
{
    void M0(dynamic? x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_201()
        {
            var source = @"
class Outer<T> where T : class?
{
    void M0(dynamic? x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_202()
        {
            var source = @"
class Outer<T> where T : object
{
    void M0(T x0)
    {
        object y0 = x0 as object;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_203()
        {
            var source = @"
class Outer<T> where T : object
{
    void M0(T x0)
    {
        dynamic y0 = x0 as dynamic;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_204()
        {
            var source = @"
class Outer<T> where T : class
{
    void M0(object x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_205()
        {
            var source = @"
class Outer<T> where T : class
{
    void M0(object? x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_206()
        {
            var source = @"
class Outer<T> where T : class
{
    void M0(object? x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_207()
        {
            var source = @"
class Outer<T> where T : class
{
    void M0(dynamic x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_208()
        {
            var source = @"
class Outer<T> where T : class
{
    void M0(dynamic? x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_209()
        {
            var source = @"
class Outer<T> where T : class
{
    void M0(dynamic? x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_210()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0)
    {
        Outer<T> y0 = x0 as Outer<T>;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         Outer<T> y0 = x0 as Outer<T>;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as Outer<T>").WithLocation(6, 23),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_211()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0)
    {
        if (x0 == null) return;
        Outer<T> y0 = x0 as Outer<T>;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         Outer<T> y0 = x0 as Outer<T>;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as Outer<T>").WithLocation(7, 23),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_212()
        {
            var source = @"
class Outer<T> where T : class?
{
    void M0(Outer<T>? x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_213()
        {
            var source = @"
class Outer<T> where T : class?
{
    void M0(Outer<T>? x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_214()
        {
            var source = @"
class Outer<T> where T : class?
{
    void M0(Outer<T> x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_215()
        {
            var source = @"
class Outer<T> where T : class
{
    void M0(T x0)
    {
        Outer<T> y0 = x0 as Outer<T>;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         Outer<T> y0 = x0 as Outer<T>;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as Outer<T>").WithLocation(6, 23),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_216()
        {
            var source = @"
class Outer<T> where T : class
{
    void M0(Outer<T>? x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_217()
        {
            var source = @"
class Outer<T> where T : class
{
    void M0(Outer<T>? x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_218()
        {
            var source = @"
class Outer<T> where T : class
{
    void M0(Outer<T> x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_219()
        {
            var source = @"
class Outer<T> where T : Outer<T>?
{
    void M0(T x0)
    {
        Outer<T> y0 = x0 as Outer<T>;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         Outer<T> y0 = x0 as Outer<T>;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as Outer<T>").WithLocation(6, 23),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_220()
        {
            var source = @"
class Outer<T> where T : Outer<T>?
{
    void M0(T x0)
    {
        if (x0 == null) return;
        Outer<T> y0 = x0 as Outer<T>;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_221()
        {
            var source = @"
class Outer<T> where T : Outer<T>?
{
    void M0(Outer<T> x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_222()
        {
            var source = @"
class Outer<T> where T : Outer<T>
{
    void M0(T x0)
    {
        Outer<T> y0 = x0 as Outer<T>;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_223()
        {
            var source = @"
class Outer<T> where T : Outer<T>
{
    void M0(Outer<T>? x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_224()
        {
            var source = @"
class Outer<T> where T : Outer<T>
{
    void M0(Outer<T>? x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_225()
        {
            var source = @"
class Outer<T> where T : Outer<T>
{
    void M0(Outer<T> x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_226()
        {
            var source = @"
class Outer<T> where T : I1?
{
    void M0(T x0)
    {
        I1 y0 = x0 as I1;
        y0?.ToString();
        y0.ToString();
    }
}

interface I1{}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,17): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         I1 y0 = x0 as I1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as I1").WithLocation(6, 17),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_227()
        {
            var source = @"
class Outer<T> where T : I1?
{
    void M0(T x0)
    {
        if (x0 == null) return;
        I1 y0 = x0 as I1;
        y0?.ToString();
        y0.ToString();
    }
}

interface I1{}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_228()
        {
            var source = @"
class Outer<T> where T : class?, I1?
{
    void M0(I1 x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}

interface I1{}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_229()
        {
            var source = @"
class Outer<T> where T : I1
{
    void M0(T x0)
    {
        I1 y0 = x0 as I1;
        y0?.ToString();
        y0.ToString();
    }
}

interface I1{}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_230()
        {
            var source = @"
class Outer<T> where T : class?, I1
{
    void M0(I1? x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}

interface I1{}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_231()
        {
            var source = @"
class Outer<T> where T : class?, I1
{
    void M0(I1? x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}

interface I1{}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_232()
        {
            var source = @"
class Outer<T> where T : class?, I1
{
    void M0(I1 x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}

interface I1{}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_233()
        {
            var source = @"
class Outer<T> where T : class?
{
    void M0(T x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_234()
        {
            var source = @"
class Outer<T> where T : class?
{
    void M0(T x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_235()
        {
            var source = @"
class Outer<T> where T : class
{
    void M0(T x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_237()
        {
            var source = @"
class Outer<T, U> where T : U where U : class?
{
    void M0(T x0)
    {
        U y0 = x0 as U;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_238()
        {
            var source = @"
class Outer<T, U> where T : U where U : class?
{
    void M0(T x0)
    {
        if (x0 == null) return;
        U y0 = x0 as U;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_239()
        {
            var source = @"
class Outer<T, U> where T : U where U : class
{
    void M0(T x0)
    {
        U y0 = x0 as U;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_240()
        {
            var source = @"
class Outer<T, U> where T : class, U where U : class?
{
    void M0(T x0)
    {
        U y0 = x0 as U;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_241()
        {
            var source = @"
class Outer<T, U> where T : class?, U where U : class?
{
    void M0(T x0)
    {
        U y0 = x0 as U;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_242()
        {
            var source = @"
class Outer<T, U> where T : class?, U where U : class?
{
    void M0(T x0)
    {
        if (x0 == null) return;
        U y0 = x0 as U;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_243()
        {
            var source = @"
class Outer<T, U> where T : class?, U where U : class
{
    void M0(T x0)
    {
        U y0 = x0 as U;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): hidden CS8607: Expression is probably never null.
                //         y0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(7, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_244()
        {
            var source = @"
class Outer<T, U> where T : class, U where U : class?
{
    void M0(U x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_245()
        {
            var source = @"
class Outer<T, U> where T : class, U where U : class?
{
    void M0(U x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_246()
        {
            var source = @"
class Outer<T, U> where T : class, U where U : class
{
    void M0(U x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_248()
        {
            var source = @"
class Outer<T, U> where T : class?, U where U : class?
{
    void M0(U x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_249()
        {
            var source = @"
class Outer<T, U> where T : class?, U where U : class?
{
    void M0(U x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_250()
        {
            var source = @"
class Outer<T, U> where T : class?, U where U : class
{
    void M0(U x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_251()
        {
            var source = @"
class Outer<T, U> where T : class?, U
{
    void M0(U x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_252()
        {
            var source = @"
class Outer<T, U> where T : class?, U
{
    void M0(U x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_253()
        {
            var source = @"
class Outer<T, U> where T : class, U
{
    void M0(U x0)
    {
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(6, 16),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(8, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_254()
        {
            var source = @"
class Outer<T, U> where T : class, U
{
    void M0(U x0)
    {
        if (x0 == null) return;
        T y0 = x0 as T;
        y0?.ToString();
        y0.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T y0 = x0 as T;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x0 as T").WithLocation(7, 16),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y0.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(9, 9)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_255()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0, T z0)
    {
        if (y0 == null) return;
        z0 ??= y0;
        M1(z0) = x0;

        M1(z0).ToString();
        z0.ToString();
    }

    ref S M1<S>(S x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         M1(z0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(z0)").WithLocation(10, 9));
        }

        [Fact]
        public void NullabilityOfTypeParameters_256()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        (x0 ??= y0).ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,10): warning CS8602: Possible dereference of a null reference.
                //         (x0 ??= y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x0 ??= y0").WithLocation(6, 10));
        }

        [Fact]
        public void NullabilityOfTypeParameters_257()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        if (y0 == null) return;
        (x0 ??= y0)?.ToString();
    }
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,10): hidden CS8607: Expression is probably never null.
                //         (x0 ??= y0)?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0 ??= y0").WithLocation(7, 10)
                );
        }

        [Fact]
        public void NullabilityOfTypeParameters_258()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0)
    {
        if (x0 == null) return;
        x0 ??= y0;
        M1(x0).ToString();
        M1(x0) = y0;
        x0?.ToString();
        x0.ToString();
    }

    ref S M1<S>(S x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): hidden CS8607: Expression is probably never null.
                //         x0 ??= y0;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(7, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         M1(x0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(x0)").WithLocation(8, 9),
                // (10,9): hidden CS8607: Expression is probably never null.
                //         x0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(10, 9));
        }

        [Fact]
        public void NullabilityOfTypeParameters_259()
        {
            var source = @"
class Outer
{
    void M0<T>(T x0, T y0, T a0)
    {
        if (x0 == null) return;
        if (y0 == null) return;
        x0 ??= y0;
        M1(x0) = a0;
        x0?.ToString();
        M1(x0).ToString();
    }

    ref S M1<S>(S x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (8,9): hidden CS8607: Expression is probably never null.
                //         x0 ??= y0;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(8, 9),
                // (10,9): hidden CS8607: Expression is probably never null.
                //         x0?.ToString();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "x0").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         M1(x0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(x0)").WithLocation(11, 9));
        }

        [Fact]
        public void NullabilityOfTypeParameters_260()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        if (y0 == null) return;
        y0 ??= M2();
        M1(y0) = x0;
        M1<T>(y0) = x0;

        M1(y0).ToString();
        y0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (7,9): hidden CS8607: Expression is probably never null.
                //         y0 ??= M2();
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "y0").WithLocation(7, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         M1(y0).ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M1(y0)").WithLocation(11, 9));
        }

        [Fact]
        public void NullabilityOfTypeParameters_261()
        {
            var source = @"
class Outer<T>
{
    void M0(T x0, T y0)
    {
        y0 ??= M2();
        M1(y0) = x0;
        y0.ToString();
    }

    ref S M1<S>(S x) => throw null;

#nullable disable
    T M2() => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics();
        }

        [Fact]
        public void NullabilityOfTypeParameters_262()
        {
            var source = @"
class Outer<T1, T2> where T1 : class, T2
{
    void M0(T1 t1, T2 t2)
    {
        t1 ??= t2 as T1;
        M1(t1) ??= t2 as T1;
    }

    ref S M1<S>(S x) => throw null;
}
";

            CreateCompilation(source, options: WithNonNullTypesTrue()).VerifyDiagnostics(
                // (6,9): hidden CS8607: Expression is probably never null.
                //         t1 ??= t2 as T1;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "t1").WithLocation(6, 9),
                // (6,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         t1 ??= t2 as T1;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t2 as T1").WithLocation(6, 16),
                // (7,9): hidden CS8607: Expression is probably never null.
                //         M1(t1) ??= t2 as T1;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M1(t1)").WithLocation(7, 9),
                // (7,20): warning CS8601: Possible null reference assignment.
                //         M1(t1) ??= t2 as T1;
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "t2 as T1").WithLocation(7, 20));
        }

        [Fact]
        public void UpdateFieldFromReceiverType()
        {
            var source =
@"class A<T> { }
class B<T>
{
    internal T F = default!;
}
class Program
{
    internal static B<T> Create<T>(T t) => throw null;
    static void M1(object x, object? y)
    {
        var b1 = Create(x);
        b1.F = x;
        b1.F = y; // 1
    }
    static void M2(A<object?> x, A<object> y, A<object?> z)
    {
        var b2 = Create(x);
        b2.F = y; // 2
        b2.F = z;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,16): warning CS8601: Possible null reference assignment.
                //         b1.F = y; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y").WithLocation(13, 16),
                // (18,16): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'A<object?>'.
                //         b2.F = y; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object>", "A<object?>").WithLocation(18, 16));
        }

        [Fact]
        public void UpdatePropertyFromReceiverType()
        {
            var source =
@"class A<T> { }
class B<T>
{
    internal T P { get; set; } = default!;
}
class Program
{
    internal static B<T> Create<T>(T t) => throw null;
    static void M1(object x, object? y)
    {
        var b1 = Create(x);
        b1.P = x;
        b1.P = y; // 1
    }
    static void M2(A<object?> x, A<object> y, A<object?> z)
    {
        var b2 = Create(x);
        b2.P = y; // 2
        b2.P = z;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,16): warning CS8601: Possible null reference assignment.
                //         b1.P = y; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "y").WithLocation(13, 16),
                // (18,16): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'A<object?>'.
                //         b2.P = y; // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "y").WithArguments("A<object>", "A<object?>").WithLocation(18, 16));
        }

        [WorkItem(31018, "https://github.com/dotnet/roslyn/issues/31018")]
        [Fact]
        public void UpdateEventFromReceiverType()
        {
            var source =
@"#pragma warning disable 0067
delegate void D<T>(T t);
class C<T>
{
    internal event D<T> E;
}
class Program
{
    internal static C<T> Create<T>(T t) => throw null;
    static void M1(object x, D<object> y, D<object?> z)
    {
        var c1 = Create(x);
        c1.E += y;
        c1.E += z; // 1
    }
    static void M2(object? x, D<object> y, D<object?> z)
    {
        var c2 = Create(x);
        c2.E += y; // 2
        c2.E += z;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/31018: Report warnings.
            comp.VerifyDiagnostics();
        }

        [WorkItem(29605, "https://github.com/dotnet/roslyn/issues/29605")]
        [Fact]
        public void UpdateMethodFromReceiverType_01()
        {
            var source =
@"class C<T>
{
    internal void F(T t) { }
}
class Program
{
    internal static C<T> Create<T>(T t) => throw null;
    static void M(object x, object? y, string? z)
    {
        var c = Create(x);
        c.F(x);
        c.F(y); // 1
        c.F(z); // 2
        c.F(null); // 3
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (12,13): warning CS8604: Possible null reference argument for parameter 't' in 'void C<object>.F(object t)'.
                //         c.F(y); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "y").WithArguments("t", "void C<object>.F(object t)").WithLocation(12, 13),
                // (13,13): warning CS8604: Possible null reference argument for parameter 't' in 'void C<object>.F(object t)'.
                //         c.F(z); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "z").WithArguments("t", "void C<object>.F(object t)").WithLocation(13, 13),
                // (14,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         c.F(null); // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(14, 13));
        }

        [WorkItem(29605, "https://github.com/dotnet/roslyn/issues/29605")]
        [Fact]
        public void UpdateMethodFromReceiverType_02()
        {
            var source =
@"class A<T> { }
class B<T>
{
    internal void F<U>(U u) where U : A<T> { }
}
class Program
{
    internal static B<T> Create<T>(T t) => throw null;
    static void M1(object x, A<object> y, A<object?> z)
    {
        var b1 = Create(x);
        b1.F(y);
        b1.F(z); // 1
    }
    static void M2(object? x, A<object> y, A<object?> z)
    {
        var b2 = Create(x);
        b2.F(y); // 2
        b2.F(z);
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,9): warning CS8631: The type 'A<object?>' cannot be used as type parameter 'U' in the generic type or method 'B<object>.F<U>(U)'. Nullability of type argument 'A<object?>' doesn't match constraint type 'A<object>'.
                //         b1.F(z); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "b1.F").WithArguments("B<object>.F<U>(U)", "A<object>", "U", "A<object?>").WithLocation(13, 9),
                // (18,9): warning CS8631: The type 'A<object>' cannot be used as type parameter 'U' in the generic type or method 'B<object?>.F<U>(U)'. Nullability of type argument 'A<object>' doesn't match constraint type 'A<object?>'.
                //         b2.F(y); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInTypeParameterConstraint, "b2.F").WithArguments("B<object?>.F<U>(U)", "A<object?>", "U", "A<object>").WithLocation(18, 9));
        }

        [WorkItem(29605, "https://github.com/dotnet/roslyn/issues/29605")]
        [Fact]
        public void UpdateMethodFromReceiverType_03()
        {
            var source =
@"class C<T>
{
    internal static T F() => throw null;
}
class Program
{
    internal static C<T> Create<T>(T t) => throw null;
    static void M(object x)
    {
        var c1 = Create(x);
        c1.F().ToString();
        x = null;
        var c2 = Create(x);
        c2.F().ToString();
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,9): error CS0176: Member 'C<object>.F()' cannot be accessed with an instance reference; qualify it with a type name instead
                //         c1.F().ToString();
                Diagnostic(ErrorCode.ERR_ObjectProhibited, "c1.F").WithArguments("C<object>.F()").WithLocation(11, 9),
                // (12,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         x = null;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(12, 13),
                // (14,9): error CS0176: Member 'C<object>.F()' cannot be accessed with an instance reference; qualify it with a type name instead
                //         c2.F().ToString();
                Diagnostic(ErrorCode.ERR_ObjectProhibited, "c2.F").WithArguments("C<object>.F()").WithLocation(14, 9),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         c2.F().ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2.F()").WithLocation(14, 9));
        }

        [Fact]
        public void AnnotationsInMetadata_01()
        {
            var source =
@"
using System.Collections.Generic;

class B
{
    public int F01;
    public int? F02;
    public string F03;
    public string? F04;
    public KeyValuePair<int, long> F05;
    public KeyValuePair<string, object> F06;
    public KeyValuePair<string?, object> F07;
    public KeyValuePair<string, object?> F08;
    public KeyValuePair<string?, object?> F09;
    public KeyValuePair<int, object> F10;
    public KeyValuePair<int, object?> F11;
    public KeyValuePair<object, int> F12;
    public KeyValuePair<object?, int> F13;
    public Dictionary<int, long> F14;
    public Dictionary<int, long>? F15;
    public Dictionary<string, object> F16;
    public Dictionary<string, object>? F17;
    public Dictionary<string?, object> F18;
    public Dictionary<string?, object>? F19;
    public Dictionary<string, object?> F20;
    public Dictionary<string, object?>? F21;
    public Dictionary<string?, object?> F22;
    public Dictionary<string?, object?>? F23;
    public Dictionary<int, object> F24;
    public Dictionary<int, object>? F25;
    public Dictionary<int, object?> F26;
    public Dictionary<int, object?>? F27;
    public Dictionary<object, int> F28;
    public Dictionary<object, int>? F29;
    public Dictionary<object?, int> F30;
    public Dictionary<object?, int>? F31;
}
";
            var comp1 = CreateCompilation(new[] { source });
            CompileAndVerify(comp1, symbolValidator:
            (ModuleSymbol m) =>
            {
                (string type, string attribute)[] baseline = new[]
                {
                    ("System.Int32", null),
                    ("System.Int32?", null),
                    ("System.String", null),
                    ("System.String?", "System.Runtime.CompilerServices.NullableAttribute(2)"),
                    ("System.Collections.Generic.KeyValuePair<System.Int32, System.Int64>", null),
                    ("System.Collections.Generic.KeyValuePair<System.String, System.Object>", null),
                    ("System.Collections.Generic.KeyValuePair<System.String?, System.Object>", "System.Runtime.CompilerServices.NullableAttribute({0, 2, 0})"),
                    ("System.Collections.Generic.KeyValuePair<System.String, System.Object?>", "System.Runtime.CompilerServices.NullableAttribute({0, 0, 2})"),
                    ("System.Collections.Generic.KeyValuePair<System.String?, System.Object?>", "System.Runtime.CompilerServices.NullableAttribute({0, 2, 2})"),
                    ("System.Collections.Generic.KeyValuePair<System.Int32, System.Object>", null),
                    ("System.Collections.Generic.KeyValuePair<System.Int32, System.Object?>", "System.Runtime.CompilerServices.NullableAttribute({0, 0, 2})"),
                    ("System.Collections.Generic.KeyValuePair<System.Object, System.Int32>", null),
                    ("System.Collections.Generic.KeyValuePair<System.Object?, System.Int32>", "System.Runtime.CompilerServices.NullableAttribute({0, 2, 0})"),
                    ("System.Collections.Generic.Dictionary<System.Int32, System.Int64>", null),
                    ("System.Collections.Generic.Dictionary<System.Int32, System.Int64>?", "System.Runtime.CompilerServices.NullableAttribute({2, 0, 0})"),
                    ("System.Collections.Generic.Dictionary<System.String, System.Object>", null),
                    ("System.Collections.Generic.Dictionary<System.String, System.Object>?", "System.Runtime.CompilerServices.NullableAttribute({2, 0, 0})"),
                    ("System.Collections.Generic.Dictionary<System.String?, System.Object>", "System.Runtime.CompilerServices.NullableAttribute({0, 2, 0})"),
                    ("System.Collections.Generic.Dictionary<System.String?, System.Object>?", "System.Runtime.CompilerServices.NullableAttribute({2, 2, 0})"),
                    ("System.Collections.Generic.Dictionary<System.String, System.Object?>", "System.Runtime.CompilerServices.NullableAttribute({0, 0, 2})"),
                    ("System.Collections.Generic.Dictionary<System.String, System.Object?>?", "System.Runtime.CompilerServices.NullableAttribute({2, 0, 2})"),
                    ("System.Collections.Generic.Dictionary<System.String?, System.Object?>", "System.Runtime.CompilerServices.NullableAttribute({0, 2, 2})"),
                    ("System.Collections.Generic.Dictionary<System.String?, System.Object?>?", "System.Runtime.CompilerServices.NullableAttribute(2)"),
                    ("System.Collections.Generic.Dictionary<System.Int32, System.Object>", null),
                    ("System.Collections.Generic.Dictionary<System.Int32, System.Object>?", "System.Runtime.CompilerServices.NullableAttribute({2, 0, 0})"),
                    ("System.Collections.Generic.Dictionary<System.Int32, System.Object?>", "System.Runtime.CompilerServices.NullableAttribute({0, 0, 2})"),
                    ("System.Collections.Generic.Dictionary<System.Int32, System.Object?>?", "System.Runtime.CompilerServices.NullableAttribute({2, 0, 2})"),
                    ("System.Collections.Generic.Dictionary<System.Object, System.Int32>", null),
                    ("System.Collections.Generic.Dictionary<System.Object, System.Int32>?", "System.Runtime.CompilerServices.NullableAttribute({2, 0, 0})"),
                    ("System.Collections.Generic.Dictionary<System.Object?, System.Int32>", "System.Runtime.CompilerServices.NullableAttribute({0, 2, 0})"),
                    ("System.Collections.Generic.Dictionary<System.Object?, System.Int32>?", "System.Runtime.CompilerServices.NullableAttribute({2, 2, 0})")
                };

                Assert.Equal(31, baseline.Length);
                AnnotationsInMetadataFieldSymbolValidator(m, baseline);
            });

            var comp2 = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            CompileAndVerify(comp2, symbolValidator:
            (ModuleSymbol m) =>
            {
                (string type, string attribute)[] baseline = new[]
                {
                    ("System.Int32", null),
                    ("System.Int32?", null),
                    ("System.String!", "System.Runtime.CompilerServices.NullableAttribute(1)"),
                    ("System.String?", "System.Runtime.CompilerServices.NullableAttribute(2)"),
                    ("System.Collections.Generic.KeyValuePair<System.Int32, System.Int64>", null),
                    ("System.Collections.Generic.KeyValuePair<System.String!, System.Object!>", "System.Runtime.CompilerServices.NullableAttribute({0, 1, 1})"),
                    ("System.Collections.Generic.KeyValuePair<System.String?, System.Object!>", "System.Runtime.CompilerServices.NullableAttribute({0, 2, 1})"),
                    ("System.Collections.Generic.KeyValuePair<System.String!, System.Object?>", "System.Runtime.CompilerServices.NullableAttribute({0, 1, 2})"),
                    ("System.Collections.Generic.KeyValuePair<System.String?, System.Object?>", "System.Runtime.CompilerServices.NullableAttribute({0, 2, 2})"),
                    ("System.Collections.Generic.KeyValuePair<System.Int32, System.Object!>", "System.Runtime.CompilerServices.NullableAttribute({0, 0, 1})"),
                    ("System.Collections.Generic.KeyValuePair<System.Int32, System.Object?>", "System.Runtime.CompilerServices.NullableAttribute({0, 0, 2})"),
                    ("System.Collections.Generic.KeyValuePair<System.Object!, System.Int32>", "System.Runtime.CompilerServices.NullableAttribute({0, 1, 0})"),
                    ("System.Collections.Generic.KeyValuePair<System.Object?, System.Int32>", "System.Runtime.CompilerServices.NullableAttribute({0, 2, 0})"),
                    ("System.Collections.Generic.Dictionary<System.Int32, System.Int64>!", "System.Runtime.CompilerServices.NullableAttribute({1, 0, 0})"),
                    ("System.Collections.Generic.Dictionary<System.Int32, System.Int64>?", "System.Runtime.CompilerServices.NullableAttribute({2, 0, 0})"),
                    ("System.Collections.Generic.Dictionary<System.String!, System.Object!>!", "System.Runtime.CompilerServices.NullableAttribute(1)"),
                    ("System.Collections.Generic.Dictionary<System.String!, System.Object!>?", "System.Runtime.CompilerServices.NullableAttribute({2, 1, 1})"),
                    ("System.Collections.Generic.Dictionary<System.String?, System.Object!>!", "System.Runtime.CompilerServices.NullableAttribute({1, 2, 1})"),
                    ("System.Collections.Generic.Dictionary<System.String?, System.Object!>?", "System.Runtime.CompilerServices.NullableAttribute({2, 2, 1})"),
                    ("System.Collections.Generic.Dictionary<System.String!, System.Object?>!", "System.Runtime.CompilerServices.NullableAttribute({1, 1, 2})"),
                    ("System.Collections.Generic.Dictionary<System.String!, System.Object?>?", "System.Runtime.CompilerServices.NullableAttribute({2, 1, 2})"),
                    ("System.Collections.Generic.Dictionary<System.String?, System.Object?>!", "System.Runtime.CompilerServices.NullableAttribute({1, 2, 2})"),
                    ("System.Collections.Generic.Dictionary<System.String?, System.Object?>?", "System.Runtime.CompilerServices.NullableAttribute(2)"),
                    ("System.Collections.Generic.Dictionary<System.Int32, System.Object!>!", "System.Runtime.CompilerServices.NullableAttribute({1, 0, 1})"),
                    ("System.Collections.Generic.Dictionary<System.Int32, System.Object!>?", "System.Runtime.CompilerServices.NullableAttribute({2, 0, 1})"),
                    ("System.Collections.Generic.Dictionary<System.Int32, System.Object?>!", "System.Runtime.CompilerServices.NullableAttribute({1, 0, 2})"),
                    ("System.Collections.Generic.Dictionary<System.Int32, System.Object?>?", "System.Runtime.CompilerServices.NullableAttribute({2, 0, 2})"),
                    ("System.Collections.Generic.Dictionary<System.Object!, System.Int32>!", "System.Runtime.CompilerServices.NullableAttribute({1, 1, 0})"),
                    ("System.Collections.Generic.Dictionary<System.Object!, System.Int32>?", "System.Runtime.CompilerServices.NullableAttribute({2, 1, 0})"),
                    ("System.Collections.Generic.Dictionary<System.Object?, System.Int32>!", "System.Runtime.CompilerServices.NullableAttribute({1, 2, 0})"),
                    ("System.Collections.Generic.Dictionary<System.Object?, System.Int32>?", "System.Runtime.CompilerServices.NullableAttribute({2, 2, 0})")
                };

                Assert.Equal(31, baseline.Length);
                AnnotationsInMetadataFieldSymbolValidator(m, baseline);
            });
        }

        private static void AnnotationsInMetadataFieldSymbolValidator(ModuleSymbol m, (string type, string attribute)[] baseline)
        {
            var b = m.GlobalNamespace.GetMember<NamedTypeSymbol>("B");

            for (int i = 0; i < baseline.Length; i++)
            {
                var name = "F" + (i + 1).ToString("00");
                var f = b.GetMember<FieldSymbol>(name);
                Assert.Equal(baseline[i].type, f.Type.ToTestDisplayString(true));

                if (baseline[i].attribute == null)
                {
                    Assert.Empty(f.GetAttributes());
                }
                else
                {
                    Assert.Equal(baseline[i].attribute, f.GetAttributes().Single().ToString());
                }
            }
        }

        [Fact]
        public void AnnotationsInMetadata_02()
        {
            var ilSource = @"
// =============== CLASS MEMBERS DECLARATION ===================

.class private auto ansi beforefieldinit B`12<class T01,class T02,class T03,class T04,
                                              class T05,class T06,class T07,class T08,
                                              class T09,class T10,class T11,class T12>
       extends [mscorlib]System.Object
{
  .param type T01 
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 00 00 00 ) 
  .param type T02 
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 01 00 00 ) 
  .param type T03 
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 02 00 00 ) 
  .param type T04 
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 03 00 00 ) 
  .param type T05 
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 04 00 00 ) 
  .param type T06 
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 05 00 00 ) 
  .param type T07 
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 01 00 00 00 00 00 00 ) 
  .param type T08 
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 01 00 00 00 01 00 00 ) 
  .param type T09 
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 01 00 00 00 02 00 00 ) 
  .param type T10 
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 02 00 00 00 01 01 00 00 ) 
  .param type T11 
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 00 00 00 00 00 00 ) 
  .param type T12 
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 FF FF FF FF 00 00 ) 
  .field public int32 F01
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 00 00 00 ) 
  .field public int32 F02
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 01 00 00 ) 
  .field public int32 F03
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 02 00 00 ) 
  .field public int32 F04
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 03 00 00 ) 
  .field public int32 F05
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 01 00 00 00 00 00 00 ) 
  .field public int32 F06
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 01 00 00 00 01 00 00 ) 
  .field public int32 F07
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 01 00 00 00 02 00 00 ) 
  .field public int32 F08
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 01 00 00 00 04 00 00 ) 
  .field public int32 F09
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 FF FF FF FF 00 00 ) 
  .field public valuetype [mscorlib]System.Nullable`1<int32> F10
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 00 00 00 ) 
  .field public valuetype [mscorlib]System.Nullable`1<int32> F11
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 02 00 00 00 00 00 00 00 ) 
  .field public valuetype [mscorlib]System.Nullable`1<int32> F12
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 FF FF FF FF 00 00 ) 
  .field public string F13
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 00 00 00 ) 
  .field public string F14
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 03 00 00 ) 
  .field public string F15
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 01 00 00 00 00 00 00 ) 
  .field public string F16
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 01 00 00 00 01 00 00 ) 
  .field public string F17
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 01 00 00 00 02 00 00 ) 
  .field public string F18
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 01 00 00 00 04 00 00 ) 
  .field public string F19
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 FF FF FF FF 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F20
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 00 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F21
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8) = ( 01 00 03 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F22
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 FF FF FF FF 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F23
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 03 00 00 00 00 00 00 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F24
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 03 00 00 00 01 01 01 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F25
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 03 00 00 00 02 02 02 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F26
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 03 00 00 00 01 04 05 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F27
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 03 00 00 00 00 01 02 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F28
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 03 00 00 00 01 02 00 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F29
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 03 00 00 00 02 00 01 00 00 ) 
  .field public string F30
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 02 00 00 00 01 01 00 00 ) 
  .field public string F31
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 00 00 00 00 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F32
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 04 00 00 00 01 01 01 01 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F33
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 02 00 00 00 01 01 00 00 ) 
  .field public class [mscorlib]System.Collections.Generic.Dictionary`2<string,object> F34
  .custom instance void System.Runtime.CompilerServices.NullableAttribute::.ctor(uint8[]) = ( 01 00 00 00 00 00 00 00 ) 
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor() cil managed
  {
    // Code size       8 (0x8)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Object::.ctor()
    IL_0006:  nop
    IL_0007:  ret
  } // end of method B`12::.ctor

} // end of class B`12

.class public auto ansi beforefieldinit System.Runtime.CompilerServices.NullableAttribute
       extends [mscorlib]System.Attribute
{
  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(uint8 x) cil managed
  {
    // Code size       9 (0x9)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Attribute::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ret
  } // end of method NullableAttribute::.ctor

  .method public hidebysig specialname rtspecialname 
          instance void  .ctor(uint8[] x) cil managed
  {
    // Code size       9 (0x9)
    .maxstack  8
    IL_0000:  ldarg.0
    IL_0001:  call       instance void [mscorlib]System.Attribute::.ctor()
    IL_0006:  nop
    IL_0007:  nop
    IL_0008:  ret
  } // end of method NullableAttribute::.ctor

} // end of class System.Runtime.CompilerServices.NullableAttribute


// =============================================================

// *********** DISASSEMBLY COMPLETE ***********************
/*
class B<[Nullable(0)]T01,
        [Nullable(1)]T02,
        [Nullable(2)]T03,
        [Nullable(3)]T04,
        [Nullable(4)]T05,
        [Nullable(5)]T06,
        [Nullable(new byte[] { 0 })]T07,
        [Nullable(new byte[] { 1 })]T08,
        [Nullable(new byte[] { 2 })]T09,
        [Nullable(new byte[] { 1, 1 })]T10,
        [Nullable(new byte[] { })]T11,
        [Nullable(null)]T12>
    where T01 : class where T02 : class where T03 : class where T04 : class where T05 : class where T06 : class
    where T07 : class where T08 : class where T09 : class where T10 : class where T11 : class where T12 : class
{
    [Nullable(0)] public int F01;
    [Nullable(1)] public int F02;
    [Nullable(2)] public int F03;
    [Nullable(3)] public int F04;
    [Nullable(new byte[] { 0 })] public int F05;
    [Nullable(new byte[] { 1 })] public int F06;
    [Nullable(new byte[] { 2 })] public int F07;
    [Nullable(new byte[] { 4 })] public int F08;
    [Nullable(null)] public int F09;
    [Nullable(0)] public int? F10;
    [Nullable(new byte[] { 0, 0 })] public int? F11;
    [Nullable(null)] public int? F12;
    [Nullable(0)] public string F13;
    [Nullable(3)] public string F14;
    [Nullable(new byte[] { 0 })] public string F15;
    [Nullable(new byte[] { 1 })] public string F16;
    [Nullable(new byte[] { 2 })] public string F17;
    [Nullable(new byte[] { 4 })] public string F18;
    [Nullable(null)] public string F19;
    [Nullable(0)] public System.Collections.Generic.Dictionary<string, object> F20;
    [Nullable(3)] public System.Collections.Generic.Dictionary<string, object> F21;
    [Nullable(null)] public System.Collections.Generic.Dictionary<string, object> F22;
    [Nullable(new byte[] { 0, 0, 0 })] public System.Collections.Generic.Dictionary<string, object> F23;
    [Nullable(new byte[] { 1, 1, 1 })] public System.Collections.Generic.Dictionary<string, object> F24;
    [Nullable(new byte[] { 2, 2, 2 })] public System.Collections.Generic.Dictionary<string, object> F25;
    [Nullable(new byte[] { 1, 4, 5 })] public System.Collections.Generic.Dictionary<string, object> F26;
    [Nullable(new byte[] { 0, 1, 2 })] public System.Collections.Generic.Dictionary<string, object> F27;
    [Nullable(new byte[] { 1, 2, 0 })] public System.Collections.Generic.Dictionary<string, object> F28;
    [Nullable(new byte[] { 2, 0, 1 })] public System.Collections.Generic.Dictionary<string, object> F29;
    [Nullable(new byte[] { 1, 1 })] public string F30;
    [Nullable(new byte[] { })] public string F31;
    [Nullable(new byte[] { 1, 1, 1, 1 })] public System.Collections.Generic.Dictionary<string, object> F32;
    [Nullable(new byte[] { 1, 1 })] public System.Collections.Generic.Dictionary<string, object> F33;
    [Nullable(new byte[] { })] public System.Collections.Generic.Dictionary<string, object> F34;
}*/
";

            var source = @"";
            var compilation = CreateCompilation(new[] { source }, new[] { CompileIL(ilSource) });
            NamedTypeSymbol b = compilation.GetTypeByMetadataName("B`12");

            (string type, string attribute)[] fieldsBaseline = new[]
            {
                ("System.Int32", "System.Runtime.CompilerServices.NullableAttribute(0)"),
                ("System.Int32", "System.Runtime.CompilerServices.NullableAttribute(1)"),
                ("System.Int32", "System.Runtime.CompilerServices.NullableAttribute(2)"),
                ("System.Int32", "System.Runtime.CompilerServices.NullableAttribute(3)"),
                ("System.Int32", "System.Runtime.CompilerServices.NullableAttribute({0})"),
                ("System.Int32", "System.Runtime.CompilerServices.NullableAttribute({1})"),
                ("System.Int32", "System.Runtime.CompilerServices.NullableAttribute({2})"),
                ("System.Int32", "System.Runtime.CompilerServices.NullableAttribute({4})"),
                ("System.Int32", "System.Runtime.CompilerServices.NullableAttribute(null)"),
                ("System.Int32?", "System.Runtime.CompilerServices.NullableAttribute(0)"),
                ("System.Int32?", "System.Runtime.CompilerServices.NullableAttribute({0, 0})"),
                ("System.Int32?", "System.Runtime.CompilerServices.NullableAttribute(null)"),
                ("System.String", "System.Runtime.CompilerServices.NullableAttribute(0)"),
                ("System.String", "System.Runtime.CompilerServices.NullableAttribute(3)"),
                ("System.String", "System.Runtime.CompilerServices.NullableAttribute({0})"),
                ("System.String!", "System.Runtime.CompilerServices.NullableAttribute({1})"),
                ("System.String?", "System.Runtime.CompilerServices.NullableAttribute({2})"),
                ("System.String", "System.Runtime.CompilerServices.NullableAttribute({4})"),
                ("System.String", "System.Runtime.CompilerServices.NullableAttribute(null)"),
                ("System.Collections.Generic.Dictionary<System.String, System.Object>", "System.Runtime.CompilerServices.NullableAttribute(0)"),
                ("System.Collections.Generic.Dictionary<System.String, System.Object>", "System.Runtime.CompilerServices.NullableAttribute(3)"),
                ("System.Collections.Generic.Dictionary<System.String, System.Object>", "System.Runtime.CompilerServices.NullableAttribute(null)"),
                ("System.Collections.Generic.Dictionary<System.String, System.Object>", "System.Runtime.CompilerServices.NullableAttribute({0, 0, 0})"),
                ("System.Collections.Generic.Dictionary<System.String!, System.Object!>!", "System.Runtime.CompilerServices.NullableAttribute({1, 1, 1})"),
                ("System.Collections.Generic.Dictionary<System.String?, System.Object?>?", "System.Runtime.CompilerServices.NullableAttribute({2, 2, 2})"),
                ("System.Collections.Generic.Dictionary<System.String, System.Object>", "System.Runtime.CompilerServices.NullableAttribute({1, 4, 5})"),
                ("System.Collections.Generic.Dictionary<System.String!, System.Object?>", "System.Runtime.CompilerServices.NullableAttribute({0, 1, 2})"),
                ("System.Collections.Generic.Dictionary<System.String?, System.Object>!", "System.Runtime.CompilerServices.NullableAttribute({1, 2, 0})"),
                ("System.Collections.Generic.Dictionary<System.String, System.Object!>?", "System.Runtime.CompilerServices.NullableAttribute({2, 0, 1})"),
                ("System.String", "System.Runtime.CompilerServices.NullableAttribute({1, 1})"),
                ("System.String", "System.Runtime.CompilerServices.NullableAttribute({})"),
                ("System.Collections.Generic.Dictionary<System.String, System.Object>", "System.Runtime.CompilerServices.NullableAttribute({1, 1, 1, 1})"),
                ("System.Collections.Generic.Dictionary<System.String, System.Object>", "System.Runtime.CompilerServices.NullableAttribute({1, 1})"),
                ("System.Collections.Generic.Dictionary<System.String, System.Object>", "System.Runtime.CompilerServices.NullableAttribute({})"),
            };

            Assert.Equal(34, fieldsBaseline.Length);
            AnnotationsInMetadataFieldSymbolValidator(b.ContainingModule, fieldsBaseline);

            (bool? constraintIsNullable, string attribute)[] typeParametersBaseline = new[]
            {
                ((bool?)null, "System.Runtime.CompilerServices.NullableAttribute(0)"),
                (false, "System.Runtime.CompilerServices.NullableAttribute(1)"),
                (true, "System.Runtime.CompilerServices.NullableAttribute(2)"),
                (null, "System.Runtime.CompilerServices.NullableAttribute(3)"),
                (null, "System.Runtime.CompilerServices.NullableAttribute(4)"),
                (null, "System.Runtime.CompilerServices.NullableAttribute(5)"),
                (null, "System.Runtime.CompilerServices.NullableAttribute({0})"),
                (null, "System.Runtime.CompilerServices.NullableAttribute({1})"),
                (null, "System.Runtime.CompilerServices.NullableAttribute({2})"),
                (null, "System.Runtime.CompilerServices.NullableAttribute({1, 1})"),
                (null, "System.Runtime.CompilerServices.NullableAttribute({})"),
                (null, "System.Runtime.CompilerServices.NullableAttribute(null)"),
            };

            Assert.Equal(12, typeParametersBaseline.Length);

            for (int i = 0; i < typeParametersBaseline.Length; i++)
            {
                var t = b.TypeParameters[i];
                Assert.Equal(typeParametersBaseline[i].constraintIsNullable, t.ReferenceTypeConstraintIsNullable);
                Assert.Equal(typeParametersBaseline[i].attribute, t.GetAttributes().Single().ToString());
            }
        }

        [Fact, WorkItem(30561, "https://github.com/dotnet/roslyn/issues/30561")]
        public void SetNullableStateInFinally_01()
        {
            var source =
@"public static class Program
{
    public static void Main()
    {
        string? s = string.Empty;
        try
        {
        }
        finally
        {
            s = null;
        }

        _ = s.Length; // warning
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,13): warning CS8602: Possible dereference of a null reference.
                //         _ = s.Length; // warning
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(14, 13)
                );
        }

        [Fact, WorkItem(30561, "https://github.com/dotnet/roslyn/issues/30561")]
        public void SetNullableStateInTry_02()
        {
            var source =
@"public static class Program
{
    public static int Main()
    {
        string? s = string.Empty;
        try
        {
            s = null;
            MayThrow();
            s = string.Empty;
        }
        catch (System.Exception)
        {
        }

        return s.Length; // warning: possibly null
    }
    static void MayThrow()
    {
        throw null;
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (16,16): warning CS8602: Possible dereference of a null reference.
                //         return s.Length; // warning: possibly null
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(16, 16)
                );
        }

        [Fact, WorkItem(30561, "https://github.com/dotnet/roslyn/issues/30561")]
        public void SetNullableStateInTry_03()
        {
            var source =
@"public static class Program
{
    public static int Main()
    {
        string? s = string.Empty;
        try
        {
            s = null;
            MayThrow();
            s = string.Empty;
        }
        catch (System.Exception)
        {
            return s.Length; // warning: possibly null
        }

        return s.Length;
    }
    static void MayThrow()
    {
        throw null;
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,20): warning CS8602: Possible dereference of a null reference.
                //             return s.Length; // warning: possibly null
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(14, 20)
                );
        }

        [Fact, WorkItem(30561, "https://github.com/dotnet/roslyn/issues/30561")]
        public void SetNullableStateInTry_04()
        {
            var source =
@"public static class Program
{
    public static int Main()
    {
        string? s = string.Empty;
        try
        {
            s = null;
            MayThrow();
            s = string.Empty;
        }
        catch (System.Exception)
        {
            _ = s.Length; // warning 1
        }
        finally
        {
            _ = s.Length; // warning 2
        }

        return s.Length; // ok (previously dereferenced)
    }
    static void MayThrow()
    {
        throw null;
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(14, 17),
                // (18,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(18, 17)
                );
        }

        [Fact, WorkItem(30561, "https://github.com/dotnet/roslyn/issues/30561")]
        public void SetNullableStateInTry_05()
        {
            var source =
@"public static class Program
{
    public static int Main()
    {
        string? s = null;
        try
        {
            MayThrow();
            s = string.Empty;
            _ = s.Length; // ok
        }
        catch (System.Exception)
        {
            _ = s.Length; // warning 1
        }
        finally
        {
            _ = s.Length; // warning 2
        }

        return s.Length; // ok (previously dereferenced)
    }
    static void MayThrow()
    {
        throw null;
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(14, 17),
                // (18,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(18, 17)
                );
        }

        [Fact, WorkItem(30561, "https://github.com/dotnet/roslyn/issues/30561")]
        public void SetNullableStateInTry_06()
        {
            var source =
@"public static class Program
{
    public static int Main()
    {
        string? s = null;
        try
        {
            MayThrow();
            s = string.Empty;
            _ = s.Length; // ok
        }
        catch (System.NullReferenceException)
        {
            _ = s.Length; // warning 1
        }
        catch (System.Exception)
        {
            _ = s.Length; // warning 2
        }
        finally
        {
            _ = s.Length; // warning 3
        }

        return s.Length; // ok (previously dereferenced)
    }
    static void MayThrow()
    {
        throw null;
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(14, 17),
                // (18,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(18, 17),
                // (22,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(22, 17)
                );
        }

        [Fact, WorkItem(30561, "https://github.com/dotnet/roslyn/issues/30561")]
        public void SetNullableStateInTry_07()
        {
            var source =
@"public static class Program
{
    public static int Main()
    {
        string? s = null;
        try
        {
            MayThrow();
            s = string.Empty;
            _ = s.Length; // ok
        }
        catch (System.NullReferenceException)
        {
            _ = s.Length; // warning 1
        }
        catch (System.Exception)
        {
            _ = s.Length; // warning 2
        }

        return s.Length; // ok
    }
    static void MayThrow()
    {
        throw null;
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(14, 17),
                // (18,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(18, 17)
                );
        }

        [Fact, WorkItem(30561, "https://github.com/dotnet/roslyn/issues/30561")]
        public void SetNullableStateBeforeTry_08()
        {
            var source =
@"public static class Program
{
    public static int Main()
    {
        string? s = null;
        try
        {
            MayThrow();
            _ = s.Length; // warning 1
        }
        catch (System.NullReferenceException)
        {
            _ = s.Length; // warning 2
        }
        catch (System.Exception)
        {
            _ = s.Length; // warning 3
        }

        return s.Length; // ok (previously dereferenced)
    }
    static void MayThrow()
    {
        throw null;
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(9, 17),
                // (13,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(13, 17),
                // (17,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(17, 17)
                );
        }

        [Fact, WorkItem(30561, "https://github.com/dotnet/roslyn/issues/30561")]
        public void SetNullableStateInTry_09()
        {
            var source =
@"public static class Program
{
    public static int Main()
    {
        string? s = string.Empty;
        try
        {
            s = null;
            MayThrow();
            s = string.Empty;
        }
        finally
        {
            _ = s.Length; // warning
        }

        return s.Length; // ok
    }
    static void MayThrow()
    {
        throw null;
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(14, 17)
                );
        }

        [Fact, WorkItem(30561, "https://github.com/dotnet/roslyn/issues/30561")]
        public void SetNullableStateInCatch_10()
        {
            var source =
@"public static class Program
{
    public static int Main()
    {
        string? s = string.Empty;
        try
        {
            MayThrow();
        }
        catch (System.Exception)
        {
            s = null;
            MayThrow();
            s = string.Empty;
        }
        finally
        {
            _ = s.Length; // warning
        }

        return s.Length; // ok
    }
    static void MayThrow()
    {
        throw null;
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (18,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(18, 17)
                );
        }

        [Fact, WorkItem(30561, "https://github.com/dotnet/roslyn/issues/30561")]
        public void SetNullableStateInNestedTry_01()
        {
            var source =
@"public static class Program
{
    public static void Main()
    {
        {
            string? s = string.Empty;
            try
            {
                try
                {
                    s = null;
                }
                catch (System.Exception)
                {
                }
                finally
                {
                }
            }
            catch (System.Exception)
            {
            }
            finally
            {
            }

            _ = s.Length; // warning 1a
        }

        {
            string? s = string.Empty;
            try
            {
                try
                {
                }
                catch (System.Exception)
                {
                    s = null;
                }
                finally
                {
                }
            }
            catch (System.Exception)
            {
            }
            finally
            {
            }

            _ = s.Length; // warning 1b
        }

        {
            string? s = string.Empty;
            try
            {
                try
                {
                }
                catch (System.Exception)
                {
                }
                finally
                {
                    s = null;
                }
            }
            catch (System.Exception)
            {
            }
            finally
            {
            }

            _ = s.Length; // warning 1c
        }

        {
            string? s = string.Empty;
            try
            {
            }
            catch (System.Exception)
            {
                try
                {
                    s = null;
                }
                catch (System.Exception)
                {
                }
                finally
                {
                }
            }
            finally
            {
                _ = s.Length; // warning 2a
            }
        }

        {
            string? s = string.Empty;
            try
            {
            }
            catch (System.Exception)
            {
                try
                {
                }
                catch (System.Exception)
                {
                    s = null;
                }
                finally
                {
                }
            }
            finally
            {
                _ = s.Length; // warning 2b
            }
        }

        {
            string? s = string.Empty;
            try
            {
            }
            catch (System.Exception)
            {
                try
                {
                }
                catch (System.Exception)
                {
                }
                finally
                {
                    s = null;
                }
            }
            finally
            {
                _ = s.Length; // warning 2c
            }
        }

        {
            string? s = string.Empty;
            try
            {
            }
            catch (System.Exception)
            {
            }
            finally
            {
                try
                {
                    s = null;
                }
                catch (System.Exception)
                {
                }
                finally
                {
                }
            }

            _ = s.Length; // warning 3a
        }

        {
            string? s = string.Empty;
            try
            {
            }
            catch (System.Exception)
            {
            }
            finally
            {
                try
                {
                }
                catch (System.Exception)
                {
                    s = null;
                }
                finally
                {
                }
            }

            _ = s.Length; // warning 3b
        }

        {
            string? s = string.Empty;
            try
            {
            }
            catch (System.Exception)
            {
            }
            finally
            {
                try
                {
                }
                catch (System.Exception)
                {
                }
                finally
                {
                    s = null;
                }
            }

            _ = s.Length; // warning 3c
        }
    }
}
";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (27,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 1a
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(27, 17),
                // (52,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 1b
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(52, 17),
                // (77,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 1c
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(77, 17),
                // (100,21): warning CS8602: Possible dereference of a null reference.
                //                 _ = s.Length; // warning 2a
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(100, 21),
                // (124,21): warning CS8602: Possible dereference of a null reference.
                //                 _ = s.Length; // warning 2b
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(124, 21),
                // (148,21): warning CS8602: Possible dereference of a null reference.
                //                 _ = s.Length; // warning 2c
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(148, 21),
                // (174,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 3a
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(174, 17),
                // (199,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 3b
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(199, 17),
                // (224,17): warning CS8602: Possible dereference of a null reference.
                //             _ = s.Length; // warning 3c
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s").WithLocation(224, 17)
                );
        }

        [WorkItem(30938, "https://github.com/dotnet/roslyn/issues/30938")]
        [Fact]
        public void ExplicitCastAndInferredTargetType()
        {
            var source =
@"class Program
{
    static void F(object? x)
    {
        if (x == null) return;
        var y = x;
        x = null;
        y = (object)x;
    }
}";
            var comp = CreateCompilation(new[] { source }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = (object)x;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)x").WithLocation(8, 13));
        }

        [Fact]
        public void InheritNullabilityOfNonNullableClassMember()
        {
            var source =
@"#pragma warning disable 8618
class C<T>
{
    internal T F;
}
class Program
{
    static void F1(string? s)
    {
        var a1 = new C<string>() { F = s };
        F(a1.F/*T:string?*/); // 1
        var b1 = a1;
        F(b1.F/*T:string!*/);
    }
    static void F2<T>(T? t) where T : class
    {
        var a2 = new C<T>() { F = t };
        F(a2.F/*T:T?*/); // 2
        var b2 = a2;
        F(b2.F/*T:T!*/);
    }
    static void F(object o)
    {
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/31395: Nullability of class members should be copied on assignment.
            comp.VerifyDiagnostics(
                // (10,40): warning CS8601: Possible null reference assignment.
                //         var a1 = new C<string>() { F = s };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "s").WithLocation(10, 40),
                // (11,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void Program.F(object o)'.
                //         F(a1.F/*T:string?*/); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a1.F").WithArguments("o", "void Program.F(object o)").WithLocation(11, 11),
                // (17,35): warning CS8601: Possible null reference assignment.
                //         var a2 = new C<T>() { F = t };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "t").WithLocation(17, 35),
                // (18,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void Program.F(object o)'.
                //         F(a2.F/*T:T?*/); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a2.F").WithArguments("o", "void Program.F(object o)").WithLocation(18, 11));
            comp.VerifyTypes();
        }

        [Fact]
        public void InheritNullabilityOfNonNullableStructMember()
        {
            var source =
@"#pragma warning disable 8618
struct S<T>
{
    internal T F;
}
class Program
{
    static void F1(string? s)
    {
        var a1 = new S<string>() { F = s };
        F(a1.F/*T:string?*/); // 1
        var b1 = a1;
        F(b1.F/*T:string?*/); // 2
    }
    static void F2<T>(T? t) where T : class
    {
        var a2 = new S<T>() { F = t };
        F(a2.F/*T:T?*/); // 3
        var b2 = a2;
        F(b2.F/*T:T?*/); // 4
    }
    static void F(object o)
    {
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,40): warning CS8601: Possible null reference assignment.
                //         var a1 = new S<string>() { F = s };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "s").WithLocation(10, 40),
                // (11,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void Program.F(object o)'.
                //         F(a1.F/*T:string?*/); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a1.F").WithArguments("o", "void Program.F(object o)").WithLocation(11, 11),
                // (13,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void Program.F(object o)'.
                //         F(b1.F/*T:string?*/); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b1.F").WithArguments("o", "void Program.F(object o)").WithLocation(13, 11),
                // (17,35): warning CS8601: Possible null reference assignment.
                //         var a2 = new S<T>() { F = t };
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "t").WithLocation(17, 35),
                // (18,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void Program.F(object o)'.
                //         F(a2.F/*T:T?*/); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "a2.F").WithArguments("o", "void Program.F(object o)").WithLocation(18, 11),
                // (20,11): warning CS8604: Possible null reference argument for parameter 'o' in 'void Program.F(object o)'.
                //         F(b2.F/*T:T?*/); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "b2.F").WithArguments("o", "void Program.F(object o)").WithLocation(20, 11));
            comp.VerifyTypes();
        }

        [Fact]
        public void DiagnosticOptions_01()
        {
            var source =
@"
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        private static void AssertDiagnosticOptions_01(string source)
        {
            string id = MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable);

            var source2 =
@"
partial class Program
{
#nullable enable
    static void F(object o)
    {
    }
}";

            var comp = CreateCompilation(new[] { source, source2 }, options: WithNonNullTypesFalse());
            comp.VerifyDiagnostics();

            foreach (ReportDiagnostic option in Enum.GetValues(typeof(ReportDiagnostic)))
            {
                comp = CreateCompilation(new[] { source, source2 }, options: WithNonNullTypesFalse().WithSpecificDiagnosticOptions(id, option));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: WithNonNullTypesFalse().WithGeneralDiagnosticOption(option));
                comp.VerifyDiagnostics();
            }

            assertDiagnosticOptions(NullableContextOptions.Enable);
            assertDiagnosticOptions(NullableContextOptions.SafeOnly);
            assertDiagnosticOptions(NullableContextOptions.Warnings);
            assertDiagnosticOptions(NullableContextOptions.SafeOnlyWarnings);

            void assertDiagnosticOptions(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions);
                var diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.WithSpecificDiagnosticOptions(id, ReportDiagnostic.Default));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.WithGeneralDiagnosticOption(ReportDiagnostic.Default));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Default).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.WithSpecificDiagnosticOptions(id, ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): error CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithWarningAsError(true)
                    );
                Assert.Equal(DiagnosticSeverity.Error, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Error).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Default));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): error CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithWarningAsError(true)
                    );
                Assert.Equal(DiagnosticSeverity.Error, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): error CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithWarningAsError(true)
                    );
                Assert.Equal(DiagnosticSeverity.Error, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Suppress));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Suppress).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Suppress));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.WithSpecificDiagnosticOptions(id, ReportDiagnostic.Hidden));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): hidden CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Hidden, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Hidden).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): hidden CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Hidden, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Hidden));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Default).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Hidden));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);
            }
        }

        [Fact]
        public void DiagnosticOptions_02()
        {
            var source =
@"
#pragma warning disable
partial class Program
{
    static void Test()
    {
        F(null);
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        private static void AssertDiagnosticOptions_02(string source)
        {
            string id1 = MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable);
            string id2 = MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable);

            var source2 =
@"
partial class Program
{
#nullable enable
    static void F(object o)
    {
    }
    static object M()
    {
        return new object();
    }
}";

            var comp = CreateCompilation(new[] { source, source2 }, options: WithNonNullTypesFalse());
            comp.VerifyDiagnostics();

            foreach (ReportDiagnostic option in Enum.GetValues(typeof(ReportDiagnostic)))
            {
                comp = CreateCompilation(new[] { source, source2 }, options: WithNonNullTypesFalse().WithSpecificDiagnosticOptions(id1, id2, option));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: WithNonNullTypesFalse().WithGeneralDiagnosticOption(option));
                comp.VerifyDiagnostics();
            }

            assertDiagnosticOptions(NullableContextOptions.Enable);
            assertDiagnosticOptions(NullableContextOptions.SafeOnly);
            assertDiagnosticOptions(NullableContextOptions.Warnings);
            assertDiagnosticOptions(NullableContextOptions.SafeOnlyWarnings);

            void assertDiagnosticOptions(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions);
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.WithSpecificDiagnosticOptions(id1, id2, ReportDiagnostic.Default));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.WithGeneralDiagnosticOption(ReportDiagnostic.Default));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id1, id2, ReportDiagnostic.Default).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.WithSpecificDiagnosticOptions(id1, id2, ReportDiagnostic.Error));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id1, id2, ReportDiagnostic.Error).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Default));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id1, id2, ReportDiagnostic.Suppress));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id1, id2, ReportDiagnostic.Suppress).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Suppress));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.WithSpecificDiagnosticOptions(id1, id2, ReportDiagnostic.Hidden));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id1, id2, ReportDiagnostic.Hidden).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Hidden));
                comp.VerifyDiagnostics();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id1, id2, ReportDiagnostic.Default).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Hidden));
                comp.VerifyDiagnostics();
            }
        }

        [Fact]
        public void DiagnosticOptions_03()
        {
            var source =
@"
#pragma warning disable " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable) + @"
#pragma warning disable " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
partial class Program
{
    static void Test()
    {
        F(null);
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_04()
        {
            var source =
@"
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable) + @"
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_05()
        {
            var source =
@"
#nullable disable
partial class Program
{
    static void Test()
    {
        F(null);
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_06()
        {
            var source =
@"
#nullable enable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        private static void AssertDiagnosticOptions_06(string source)
        {

            var source2 =
@"
partial class Program
{
#nullable enable
    static void F(object o)
    {
    }
}";
            assertDiagnosticOptions(NullableContextOptions.Disable);
            assertDiagnosticOptions(NullableContextOptions.Enable);
            assertDiagnosticOptions(NullableContextOptions.SafeOnly);
            assertDiagnosticOptions(NullableContextOptions.Warnings);
            assertDiagnosticOptions(NullableContextOptions.SafeOnlyWarnings);

            void assertDiagnosticOptions(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions options = WithNonNullTypes(nullableContextOptions);

                string id = MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable);
                var comp = CreateCompilation(new[] { source, source2 }, options: options);
                var diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.WithSpecificDiagnosticOptions(id, ReportDiagnostic.Default));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.WithGeneralDiagnosticOption(ReportDiagnostic.Default));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Default).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.WithSpecificDiagnosticOptions(id, ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): error CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithWarningAsError(true)
                    );
                Assert.Equal(DiagnosticSeverity.Error, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Error).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Default));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): error CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithWarningAsError(true)
                    );
                Assert.Equal(DiagnosticSeverity.Error, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): error CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithWarningAsError(true)
                    );
                Assert.Equal(DiagnosticSeverity.Error, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Suppress));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Suppress).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Suppress));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.WithSpecificDiagnosticOptions(id, ReportDiagnostic.Hidden));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): hidden CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Hidden, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Hidden).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): hidden CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Hidden, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Hidden));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Default).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Hidden));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (6,11): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                    //         F(null);
                    Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);
            }
        }

        [Fact]
        public void DiagnosticOptions_07()
        {
            var source =
@"
#pragma warning disable
#nullable disable
partial class Program
{
    static void Test()
    {
        F(null);
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_08()
        {
            var source =
@"
#pragma warning disable
#nullable enable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_09()
        {
            var source =
@"
#pragma warning disable " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable) + @"
#pragma warning disable " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
#nullable disable
partial class Program
{
    static void Test()
    {
        F(null);
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_10()
        {
            var source =
@"
#pragma warning disable " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable) + @"
#nullable enable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_11()
        {
            var source =
@"
#nullable disable
#pragma warning disable " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable) + @"
#pragma warning disable " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
partial class Program
{
    static void Test()
    {
        F(null);
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_12()
        {
            var source =
@"
#nullable disable
#pragma warning disable
partial class Program
{
    static void Test()
    {
        F(null);
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_13()
        {
            var source =
@"
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable) + @"
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
#nullable disable
partial class Program
{
    static void Test()
    {
        F(null);
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_14()
        {
            var source =
@"
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable) + @"
#nullable enable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_15()
        {
            var source =
@"
#nullable disable
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable) + @"
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_16()
        {
            var source =
@"
#pragma warning restore
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_17()
        {
            var source =
@"
#nullable disable
#pragma warning restore
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_18()
        {
            var source =
@"
#pragma warning restore
#nullable disable
partial class Program
{
    static void Test()
    {
        F(null);
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_19()
        {
            var source =
@"
#nullable enable
#pragma warning restore
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_20()
        {
            var source =
@"
#pragma warning restore
#nullable enable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_21()
        {
            var source =
@"
#nullable enable
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable) + @"
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_22()
        {
            var source =
@"
#nullable restore
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_23()
        {
            var source =
@"
#nullable safeonly
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_24()
        {
            var source =
@"
#pragma warning disable
#nullable safeonly
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_25()
        {
            var source =
@"
#pragma warning disable " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable) + @"
#nullable safeonly
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_26()
        {
            var source =
@"
#nullable restore
#nullable disable
partial class Program
{
    static void Test()
    {
        F(null);
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_27()
        {
            var source =
@"
#nullable restore
#nullable enable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_28()
        {
            var source =
@"
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable) + @"
#nullable safeonly
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_29()
        {
            var source =
@"
#nullable restore
#nullable safeonly
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_30()
        {
            var source =
@"
#nullable disable
#nullable restore
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_31()
        {
            var source =
@"
#nullable safeonly
#pragma warning restore
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_32()
        {
            var source =
@"
#nullable enable
#nullable restore
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_33()
        {
            var source =
@"
#nullable safeonly
#nullable restore
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_34()
        {
            var source =
@"
#pragma warning restore
#nullable safeonly
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_35()
        {
            var source =
@"
#nullable safeonly
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_NullAsNonNullable) + @"
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_36()
        {
            var source =
@"
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        private static void AssertDiagnosticOptions_36(string source)
        {
            var source2 =
@"
partial class Program
{
#nullable enable
    static object M()
    {
        return new object();
    }
}";

            string id = MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable);

            assertDiagnosticOptions1(NullableContextOptions.Enable);
            assertDiagnosticOptions1(NullableContextOptions.Warnings);

            assertDiagnosticOptions2(NullableContextOptions.Disable);
            assertDiagnosticOptions2(NullableContextOptions.SafeOnly);
            assertDiagnosticOptions2(NullableContextOptions.SafeOnlyWarnings);

            void assertDiagnosticOptions1(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);

                var comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions);
                var diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.WithSpecificDiagnosticOptions(id, ReportDiagnostic.Default));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.WithGeneralDiagnosticOption(ReportDiagnostic.Default));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Default).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.WithSpecificDiagnosticOptions(id, ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): error CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithWarningAsError(true)
                    );
                Assert.Equal(DiagnosticSeverity.Error, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Error).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Default));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): error CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithWarningAsError(true)
                    );
                Assert.Equal(DiagnosticSeverity.Error, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): error CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithWarningAsError(true)
                    );
                Assert.Equal(DiagnosticSeverity.Error, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Suppress));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Suppress).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Suppress));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify();

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.WithSpecificDiagnosticOptions(id, ReportDiagnostic.Hidden));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): hidden CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Hidden, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Hidden).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): hidden CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Hidden, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Hidden));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Default).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Hidden));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);
            }

            void assertDiagnosticOptions2(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions compilationOptions = WithNonNullTypes(nullableContextOptions);

                var comp = CreateCompilation(new[] { source, source2 }, options: compilationOptions);
                comp.VerifyDiagnostics();

                foreach (ReportDiagnostic option in Enum.GetValues(typeof(ReportDiagnostic)))
                {
                    comp = CreateCompilation(new[] { source, source2 }, options: WithNonNullTypesFalse().WithSpecificDiagnosticOptions(id, option));
                    comp.VerifyDiagnostics();

                    comp = CreateCompilation(new[] { source, source2 }, options: WithNonNullTypesFalse().WithGeneralDiagnosticOption(option));
                    comp.VerifyDiagnostics();
                }
            }
        }

        [Fact]
        public void DiagnosticOptions_37()
        {
            var source =
@"
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_38()
        {
            var source =
@"
#nullable enable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_38(source);
        }

        private static void AssertDiagnosticOptions_38(string source)
        {

            var source2 =
@"
partial class Program
{
#nullable enable
    static object M()
    {
        return new object();
    }
}";
            assertDiagnosticOptions(NullableContextOptions.Disable);
            assertDiagnosticOptions(NullableContextOptions.Enable);
            assertDiagnosticOptions(NullableContextOptions.SafeOnly);
            assertDiagnosticOptions(NullableContextOptions.Warnings);
            assertDiagnosticOptions(NullableContextOptions.SafeOnlyWarnings);

            void assertDiagnosticOptions(NullableContextOptions nullableContextOptions)
            {
                CSharpCompilationOptions options = WithNonNullTypes(nullableContextOptions);

                string id = MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable);
                var comp = CreateCompilation(new[] { source, source2 }, options: options);
                var diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.WithSpecificDiagnosticOptions(id, ReportDiagnostic.Default));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.WithGeneralDiagnosticOption(ReportDiagnostic.Default));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Default).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.WithSpecificDiagnosticOptions(id, ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): error CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithWarningAsError(true)
                    );
                Assert.Equal(DiagnosticSeverity.Error, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Error).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Default));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): error CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithWarningAsError(true)
                    );
                Assert.Equal(DiagnosticSeverity.Error, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): error CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithWarningAsError(true)
                    );
                Assert.Equal(DiagnosticSeverity.Error, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Suppress));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Suppress).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Suppress));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.WithSpecificDiagnosticOptions(id, ReportDiagnostic.Hidden));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): hidden CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Hidden, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Hidden).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Error));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): hidden CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Hidden, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Hidden));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);

                comp = CreateCompilation(new[] { source, source2 }, options: options.
                                                          WithSpecificDiagnosticOptions(id, ReportDiagnostic.Default).
                                                          WithGeneralDiagnosticOption(ReportDiagnostic.Hidden));
                diagnostics = comp.GetDiagnostics();
                diagnostics.Verify(
                    // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                    //         x = null;
                    Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null")
                    );
                Assert.Equal(DiagnosticSeverity.Warning, diagnostics.Single().Severity);
            }
        }

        [Fact]
        public void DiagnosticOptions_39()
        {
            var source =
@"
#pragma warning disable
#nullable enable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_38(source);
        }

        [Fact]
        public void DiagnosticOptions_40()
        {
            var source =
@"
#pragma warning disable " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
#nullable enable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_38(source);
        }

        [Fact]
        public void DiagnosticOptions_41()
        {
            var source =
@"
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
#nullable enable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_38(source);
        }

        [Fact]
        public void DiagnosticOptions_42()
        {
            var source =
@"
#nullable disable
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_43()
        {
            var source =
@"
#pragma warning restore
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_44()
        {
            var source =
@"
#nullable disable
#pragma warning restore
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_45()
        {
            var source =
@"
#nullable enable
#pragma warning restore
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_46()
        {
            var source =
@"
#pragma warning restore
#nullable enable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_38(source);
        }

        [Fact]
        public void DiagnosticOptions_48()
        {
            var source =
@"
#nullable enable
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_49()
        {
            var source =
@"
#nullable restore
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_50()
        {
            var source =
@"
#nullable safeonly
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_51()
        {
            var source =
@"
#pragma warning disable
#nullable safeonly
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_52()
        {
            var source =
@"
#pragma warning disable " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
#nullable safeonly
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_53()
        {
            var source =
@"
#nullable restore
#nullable enable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_38(source);
        }

        [Fact]
        public void DiagnosticOptions_54()
        {
            var source =
@"
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
#nullable safeonly
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_55()
        {
            var source =
@"
#nullable restore
#nullable safeonly
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_56()
        {
            var source =
@"
#nullable disable
#nullable restore
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_57()
        {
            var source =
@"
#nullable safeonly
#pragma warning restore
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_58()
        {
            var source =
@"
#nullable enable
#nullable restore
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_59()
        {
            var source =
@"
#nullable safeonly
#nullable restore
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_60()
        {
            var source =
@"
#pragma warning restore
#nullable safeonly
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_61()
        {
            var source =
@"
#nullable safeonly
#pragma warning restore " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_62()
        {
            var source =
@"
#pragma warning disable nullable
partial class Program
{
    static void Test()
    {
        F(null);
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_63()
        {
            var source =
@"
#pragma warning enable nullable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_38(source);
        }

        [Fact]
        public void DiagnosticOptions_64()
        {
            var source =
@"
#pragma warning disable
#pragma warning enable nullable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_38(source);
        }

        [Fact]
        public void DiagnosticOptions_65()
        {
            var source =
@"
#pragma warning disable " + MessageProvider.Instance.GetIdForErrorCode((int)ErrorCode.WRN_ConvertingNullableToNonNullable) + @"
#pragma warning enable nullable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_38(source);
        }

        [Fact]
        public void DiagnosticOptions_66()
        {
            var source =
@"
#pragma warning restore
#pragma warning enable nullable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_38(source);
        }

        [Fact]
        public void DiagnosticOptions_67()
        {
            var source =
@"
#nullable restore
#pragma warning enable nullable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_38(source);
        }

        [Fact]
        public void DiagnosticOptions_68()
        {
            var source =
@"
#pragma warning restore nullable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_69()
        {
            var source =
@"
#nullable disable
#pragma warning restore nullable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_70()
        {
            var source =
@"
#nullable enable
#pragma warning restore nullable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_71()
        {
            var source =
@"
#nullable safeonly
#pragma warning restore nullable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_72()
        {
            var source =
@"
#pragma warning restore nullable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_73()
        {
            var source =
@"
#nullable disable
#pragma warning restore nullable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_74()
        {
            var source =
@"
#nullable enable
#pragma warning restore nullable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_75()
        {
            var source =
@"
#nullable safeonly
#pragma warning restore nullable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_36(source);
        }

        [Fact]
        public void DiagnosticOptions_76()
        {
            var source =
@"
#pragma warning safeonly nullable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_77()
        {
            var source =
@"
#pragma warning disable
#pragma warning safeonly nullable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_78()
        {
            var source =
@"
#nullable restore
#pragma warning safeonly nullable
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_06(source);
        }

        [Fact]
        public void DiagnosticOptions_79()
        {
            var source =
@"
#pragma warning safeonly nullable
#pragma warning restore
partial class Program
{
    static void Test()
    {
        F(null);
    }
}";
            AssertDiagnosticOptions_01(source);
        }

        [Fact]
        public void DiagnosticOptions_80()
        {
            var source =
@"
#pragma warning safeonly nullable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_81()
        {
            var source =
@"
#pragma warning restore
#pragma warning safeonly nullable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        public void DiagnosticOptions_82()
        {
            var source =
@"
#nullable restore
#pragma warning safeonly nullable
partial class Program
{
    static void Test()
    {
        var x = M();
        x = null;
    }
}";
            AssertDiagnosticOptions_02(source);
        }

        [Fact]
        [WorkItem(31394, "https://github.com/dotnet/roslyn/issues/31394")]
        public void InheritMemberNullability_Class()
        {
            var source =
@"#pragma warning disable 8618
class C<T>
{
    internal T F;
}
class Program
{
    static void F()
    {
        C<object> x = new C<object?>() { F = null };
        x.F/*T:object?*/.ToString(); // 1
        C<object?> y = new C<object>() { F = new object() };
        y.F/*T:object!*/.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,23): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         C<object> x = new C<object?>() { F = null };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new C<object?>() { F = null }").WithArguments("C<object?>", "C<object>").WithLocation(10, 23),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x.F/*T:object?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.F").WithLocation(11, 9),
                // (12,24): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         C<object?> y = new C<object>() { F = new object() };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new C<object>() { F = new object() }").WithArguments("C<object>", "C<object?>").WithLocation(12, 24));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(31394, "https://github.com/dotnet/roslyn/issues/31394")]
        public void InheritMemberNullability_Struct()
        {
            var source =
@"#pragma warning disable 8618
struct S<T>
{
    internal T F;
}
class Program
{
    static void F()
    {
        S<object> x = new S<object?>();
        x.F/*T:object?*/.ToString(); // 1
        S<object?> y = new S<object>() { F = new object() };
        y.F/*T:object!*/.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,23): warning CS8619: Nullability of reference types in value of type 'S<object?>' doesn't match target type 'S<object>'.
                //         S<object> x = new S<object?>();
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new S<object?>()").WithArguments("S<object?>", "S<object>").WithLocation(10, 23),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         x.F/*T:object?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.F").WithLocation(11, 9),
                // (12,24): warning CS8619: Nullability of reference types in value of type 'S<object>' doesn't match target type 'S<object?>'.
                //         S<object?> y = new S<object>() { F = new object() };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new S<object>() { F = new object() }").WithArguments("S<object>", "S<object?>").WithLocation(12, 24));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(31394, "https://github.com/dotnet/roslyn/issues/31394")]
        public void InheritMemberNullability_AnonymousTypeField()
        {
            var source =
@"class C<T> { }
class Program
{
    static void F1(C<object> x1, C<object?>? y1)
    {
        var a1 = new { F = x1 };
        a1.F/*T:C<object!>!*/.ToString();
        a1 = new { F = y1 };
        a1.F/*T:C<object!>?*/.ToString(); // 1
    }
    static void F2(C<object>? x2, C<object?> y2)
    {
        var a2 = new { F = x2 };
        a2.F/*T:C<object!>?*/.ToString(); // 2
        a2 = new { F = y2 };
        a2.F/*T:C<object!>?*/.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/31394: a2.F should be C<object!>! and should not result in a warning.
            comp.VerifyDiagnostics(
                // (8,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: C<object?> F>' doesn't match target type '<anonymous type: C<object> F>'.
                //         a1 = new { F = y1 };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new { F = y1 }").WithArguments("<anonymous type: C<object?> F>", "<anonymous type: C<object> F>").WithLocation(8, 14),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         a1.F/*T:C<object!>?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a1.F").WithLocation(9, 9),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         a2.F/*T:C<object!>?*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a2.F").WithLocation(14, 9),
                // (15,14): warning CS8619: Nullability of reference types in value of type '<anonymous type: C<object?> F>' doesn't match target type '<anonymous type: C<object> F>'.
                //         a2 = new { F = y2 };
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "new { F = y2 }").WithArguments("<anonymous type: C<object?> F>", "<anonymous type: C<object> F>").WithLocation(15, 14),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         a2.F/*T:C<object!>?*/.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a2.F").WithLocation(16, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(31394, "https://github.com/dotnet/roslyn/issues/31394")]
        public void InheritMemberNullability_TupleElement_01()
        {
            var source =
@"class C<T> { }
class Program
{
    static void F1(C<object> x1, C<object?>? y1)
    {
        var t1 = (x1, y1);
        t1.Item1/*T:C<object!>!*/.ToString();
        t1 = (y1, y1);
        t1.Item1/*T:C<object!>?*/.ToString(); // 1
    }
    static void F2(C<object>? x2, C<object?> y2)
    {
        var t2 = (x2, y2);
        t2.Item1/*T:C<object!>?*/.ToString(); // 2
        t2 = (y2, y2);
        t2.Item1/*T:C<object!>!*/.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,14): warning CS8619: Nullability of reference types in value of type '(C<object?>?, C<object?>?)' doesn't match target type '(C<object> x1, C<object?>? y1)'.
                //         t1 = (y1, y1);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(y1, y1)").WithArguments("(C<object?>?, C<object?>?)", "(C<object> x1, C<object?>? y1)").WithLocation(8, 14),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         t1.Item1/*T:C<object!>?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1.Item1").WithLocation(9, 9),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         t2.Item1/*T:C<object!>?*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2.Item1").WithLocation(14, 9),
                // (15,14): warning CS8619: Nullability of reference types in value of type '(C<object?>, C<object?>)' doesn't match target type '(C<object>? x2, C<object?> y2)'.
                //         t2 = (y2, y2);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(y2, y2)").WithArguments("(C<object?>, C<object?>)", "(C<object>? x2, C<object?> y2)").WithLocation(15, 14));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(31394, "https://github.com/dotnet/roslyn/issues/31394")]
        public void InheritMemberNullability_TupleElement_02()
        {
            var source =
@"class C<T> { }
class Program
{
    static void F(C<object> x, C<object?>? y)
    {
        (C<object?>? a, C<object> b) t = (x, y);
        t.a/*T:C<object?>!*/.ToString();
        t.b/*T:C<object!>?*/.ToString(); // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,42): warning CS8619: Nullability of reference types in value of type '(C<object> x, C<object?>? y)' doesn't match target type '(C<object?>? a, C<object> b)'.
                //         (C<object?>? a, C<object> b) t = (x, y);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, y)").WithArguments("(C<object> x, C<object?>? y)", "(C<object?>? a, C<object> b)").WithLocation(6, 42),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.b/*T:C<object!>?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.b").WithLocation(8, 9));
            comp.VerifyTypes();
        }

        private readonly static NullableAnnotation[] s_AllNullableAnnotations = (NullableAnnotation[])Enum.GetValues(typeof(NullableAnnotation));
        private readonly static NullableAnnotation[] s_AllSpeakableNullableAnnotations = new[] { NullableAnnotation.Unknown, NullableAnnotation.NotAnnotated, NullableAnnotation.Annotated };

        [Fact]
        public void TestJoinForFixingLowerBounds()
        {
            var inputs = new[] { NullableAnnotation.Annotated, NullableAnnotation.Unknown, NullableAnnotation.NotAnnotated };
            Func<int, int, NullableAnnotation> getResult = (i, j) => NullableAnnotationExtensions.JoinForFixingLowerBounds(inputs[i], inputs[j]);

            var expected = new NullableAnnotation[3, 3]
            {
                { NullableAnnotation.Annotated,    NullableAnnotation.Annotated,    NullableAnnotation.Annotated     },
                { NullableAnnotation.Annotated,    NullableAnnotation.Unknown,      NullableAnnotation.Unknown       },
                { NullableAnnotation.Annotated,    NullableAnnotation.Unknown,      NullableAnnotation.NotAnnotated  },
            };

            AssertEqual(expected, getResult, inputs.Length);
        }

        [Fact]
        public void TestJoinForFlowAnalysisBranches_IsPossiblyNullableReferenceTypeTypeParameterFalse()
        {
            var inputs = new[] { NullableAnnotation.Annotated, NullableAnnotation.Nullable, NullableAnnotation.Unknown, NullableAnnotation.NotNullable, NullableAnnotation.NotAnnotated };

            Func<int, int, NullableAnnotation> getResult =
                (i, j) => NullableAnnotationExtensions.JoinForFlowAnalysisBranches<string>(
                    inputs[i], inputs[j], type: null, isPossiblyNullableReferenceTypeTypeParameter: _ => false);

            var expected = new NullableAnnotation[5, 5]
            {
                { NullableAnnotation.Annotated,     NullableAnnotation.Annotated,     NullableAnnotation.Annotated,     NullableAnnotation.Annotated,     NullableAnnotation.Annotated    },
                { NullableAnnotation.Annotated,     NullableAnnotation.Nullable,      NullableAnnotation.Nullable,      NullableAnnotation.Nullable,      NullableAnnotation.Nullable     },
                { NullableAnnotation.Annotated,     NullableAnnotation.Nullable,      NullableAnnotation.Unknown,       NullableAnnotation.Unknown,       NullableAnnotation.Unknown      },
                { NullableAnnotation.Annotated,     NullableAnnotation.Nullable,      NullableAnnotation.Unknown,       NullableAnnotation.NotNullable,   NullableAnnotation.NotAnnotated },
                { NullableAnnotation.Annotated,     NullableAnnotation.Nullable,      NullableAnnotation.Unknown,       NullableAnnotation.NotAnnotated,  NullableAnnotation.NotAnnotated },
            };

            AssertEqual(expected, getResult, inputs.Length);
        }

        [Fact]
        public void TestJoinForFlowAnalysisBranches_IsPossiblyNullableReferenceTypeTypeParameterTrue()
        {
            var inputs = new[] { NullableAnnotation.Annotated, NullableAnnotation.Nullable, NullableAnnotation.Unknown, NullableAnnotation.NotNullable, NullableAnnotation.NotAnnotated };

            Func<int, int, NullableAnnotation> getResult =
                (i, j) => NullableAnnotationExtensions.JoinForFlowAnalysisBranches<string>(
                    inputs[i], inputs[j], type: null, isPossiblyNullableReferenceTypeTypeParameter: _ => true);

            var expected = new NullableAnnotation[5, 5]
            {
                { NullableAnnotation.Annotated,     NullableAnnotation.Annotated,     NullableAnnotation.Annotated,     NullableAnnotation.Annotated,     NullableAnnotation.Annotated    },
                { NullableAnnotation.Annotated,     NullableAnnotation.Nullable,      NullableAnnotation.Nullable,      NullableAnnotation.Nullable,      NullableAnnotation.Nullable     },
                { NullableAnnotation.Annotated,     NullableAnnotation.Nullable,      NullableAnnotation.Unknown,       NullableAnnotation.Unknown,       NullableAnnotation.NotAnnotated },
                { NullableAnnotation.Annotated,     NullableAnnotation.Nullable,      NullableAnnotation.Unknown,       NullableAnnotation.NotNullable,   NullableAnnotation.NotAnnotated },
                { NullableAnnotation.Annotated,     NullableAnnotation.Nullable,      NullableAnnotation.NotAnnotated,  NullableAnnotation.NotAnnotated,  NullableAnnotation.NotAnnotated },
            };

            AssertEqual(expected, getResult, inputs.Length);
        }

        [Fact]
        public void TestMeetForFixingUpperBounds()
        {
            var inputs = new[] { NullableAnnotation.Annotated, NullableAnnotation.Unknown, NullableAnnotation.NotAnnotated };
            Func<int, int, NullableAnnotation> getResult = (i, j) => NullableAnnotationExtensions.MeetForFixingUpperBounds(inputs[i], inputs[j]);

            var expected = new NullableAnnotation[3, 3]
            {
                { NullableAnnotation.Annotated,    NullableAnnotation.Unknown,      NullableAnnotation.NotAnnotated  },
                { NullableAnnotation.Unknown,      NullableAnnotation.Unknown,      NullableAnnotation.NotAnnotated  },
                { NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated  },
            };

            AssertEqual(expected, getResult, inputs.Length);
        }

        [Fact]
        public void TestJoinMeetForFlowAnalysisFinally()
        {
            var inputs = new[] { NullableAnnotation.Annotated, NullableAnnotation.Nullable, NullableAnnotation.Unknown, NullableAnnotation.NotNullable, NullableAnnotation.NotAnnotated };
            Func<int, int, NullableAnnotation> getResult = (i, j) => NullableAnnotationExtensions.MeetForFlowAnalysisFinally(inputs[i], inputs[j]);

            var expected = new NullableAnnotation[5, 5]
            {
                { NullableAnnotation.Annotated,    NullableAnnotation.Nullable,     NullableAnnotation.Unknown,      NullableAnnotation.NotNullable,  NullableAnnotation.NotAnnotated  },
                { NullableAnnotation.Nullable,     NullableAnnotation.Nullable,     NullableAnnotation.Unknown,      NullableAnnotation.NotNullable,  NullableAnnotation.NotAnnotated  },
                { NullableAnnotation.Unknown,      NullableAnnotation.Unknown,      NullableAnnotation.Unknown,      NullableAnnotation.NotNullable,  NullableAnnotation.NotAnnotated  },
                { NullableAnnotation.NotNullable,  NullableAnnotation.NotNullable,  NullableAnnotation.NotNullable,  NullableAnnotation.NotNullable,  NullableAnnotation.NotNullable   },
                { NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated, NullableAnnotation.NotNullable,  NullableAnnotation.NotAnnotated  },
            };

            AssertEqual(expected, getResult, inputs.Length);
        }

        [Fact]
        public void TestEnsureCompatible()
        {
            var inputs = new[] { NullableAnnotation.Annotated, NullableAnnotation.Unknown, NullableAnnotation.NotAnnotated };
            Func<int, int, NullableAnnotation> getResult = (i, j) => NullableAnnotationExtensions.EnsureCompatible(inputs[i], inputs[j]);

            var expected = new NullableAnnotation[3, 3]
            {
                { NullableAnnotation.Annotated,    NullableAnnotation.Annotated,    NullableAnnotation.NotAnnotated  },
                { NullableAnnotation.Annotated,    NullableAnnotation.Unknown,      NullableAnnotation.NotAnnotated  },
                { NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated  },
            };

            AssertEqual(expected, getResult, inputs.Length);
        }

        [Fact]
        public void TestEnsureCompatibleForTuples_IsPossiblyNullableReferenceTypeTypeParameterFalse()
        {
            var inputs = new[] { NullableAnnotation.Annotated, NullableAnnotation.Nullable, NullableAnnotation.Unknown, NullableAnnotation.NotNullable, NullableAnnotation.NotAnnotated };

            Func<int, int, NullableAnnotation> getResult =
                (i, j) => NullableAnnotationExtensions.EnsureCompatibleForTuples<string>(
                    inputs[i], inputs[j], type: null, isPossiblyNullableReferenceTypeTypeParameter: _ => false);

            var expected = new NullableAnnotation[5, 5]
            {
                { NullableAnnotation.Annotated,    NullableAnnotation.Annotated,    NullableAnnotation.Annotated,    NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated },
                { NullableAnnotation.Annotated,    NullableAnnotation.Nullable,     NullableAnnotation.Nullable,     NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated },
                { NullableAnnotation.Annotated,    NullableAnnotation.Nullable,     NullableAnnotation.Unknown,      NullableAnnotation.NotNullable,  NullableAnnotation.NotAnnotated },
                { NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated, NullableAnnotation.NotNullable,  NullableAnnotation.NotNullable,  NullableAnnotation.NotAnnotated },
                { NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated },
            };

            AssertEqual(expected, getResult, inputs.Length);
        }

        [Fact]
        public void TestEnsureCompatibleForTuples_IsPossiblyNullableReferenceTypeTypeParameterTrue()
        {
            var inputs = new[] { NullableAnnotation.Annotated, NullableAnnotation.Nullable, NullableAnnotation.Unknown, NullableAnnotation.NotNullable, NullableAnnotation.NotAnnotated };

            Func<int, int, NullableAnnotation> getResult =
                (i, j) => NullableAnnotationExtensions.EnsureCompatibleForTuples<string>(
                    inputs[i], inputs[j], type: null, isPossiblyNullableReferenceTypeTypeParameter: _ => true);

            var expected = new NullableAnnotation[5, 5]
            {
                { NullableAnnotation.Annotated,    NullableAnnotation.Annotated,    NullableAnnotation.Annotated,    NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated },
                { NullableAnnotation.Annotated,    NullableAnnotation.Nullable,     NullableAnnotation.Nullable,     NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated },
                { NullableAnnotation.Annotated,    NullableAnnotation.Nullable,     NullableAnnotation.Unknown,      NullableAnnotation.NotNullable,  NullableAnnotation.NotAnnotated },
                { NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated, NullableAnnotation.NotNullable,  NullableAnnotation.NotNullable,  NullableAnnotation.NotAnnotated },
                { NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated, NullableAnnotation.NotAnnotated },
            };

            AssertEqual(expected, getResult, inputs.Length);
        }

        private static void AssertEqual(NullableAnnotation[,] expected, Func<int, int, NullableAnnotation> getResult, int size)
        {
            AssertEx.Equal<NullableAnnotation>(expected, getResult, (na1, na2) => na1 == na2, na => $"NullableAnnotation.{na}", "{0,-32:G}", size);
        }

        [Fact]
        public void TestJoinForFixingLowerBoundsIsAssociative()
        {
            foreach (var a in s_AllSpeakableNullableAnnotations)
            {
                foreach (var b in s_AllSpeakableNullableAnnotations)
                {
                    foreach (var c in s_AllSpeakableNullableAnnotations)
                    {
                        var leftFirst = a.JoinForFixingLowerBounds(b).JoinForFixingLowerBounds(c);
                        var rightFirst = a.JoinForFixingLowerBounds(b.JoinForFixingLowerBounds(c));
                        Assert.Equal(leftFirst, rightFirst);
                    }
                }
            }
        }

        [Fact]
        public void TestJoinForFlowAnalysisBranchesIsAssociative()
        {
            Func<bool, bool> identity = x => x;
            foreach (var a in s_AllNullableAnnotations)
            {
                foreach (var b in s_AllNullableAnnotations)
                {
                    foreach (var c in s_AllNullableAnnotations)
                    {
                        foreach (bool isPossiblyNullableReferenceTypeTypeParameter in new[] { true, false })
                        {
                            var leftFirst = a.JoinForFlowAnalysisBranches(b, isPossiblyNullableReferenceTypeTypeParameter, identity).JoinForFlowAnalysisBranches(c, isPossiblyNullableReferenceTypeTypeParameter, identity);
                            var rightFirst = a.JoinForFlowAnalysisBranches(b.JoinForFlowAnalysisBranches(c, isPossiblyNullableReferenceTypeTypeParameter, identity), isPossiblyNullableReferenceTypeTypeParameter, identity);
                            Assert.Equal(leftFirst, rightFirst);
                        }
                    }
                }
            }
        }

        [Fact]
        public void TestMeetForFixingUpperBoundsIsAssociative()
        {
            foreach (var a in s_AllSpeakableNullableAnnotations)
            {
                foreach (var b in s_AllSpeakableNullableAnnotations)
                {
                    foreach (var c in s_AllSpeakableNullableAnnotations)
                    {
                        var leftFirst = a.MeetForFixingUpperBounds(b).MeetForFixingUpperBounds(c);
                        var rightFirst = a.MeetForFixingUpperBounds(b.MeetForFixingUpperBounds(c));
                        Assert.Equal(leftFirst, rightFirst);
                    }
                }
            }
        }

        [Fact]
        public void TestMeetForFlowAnalysisFinallyIsAssociative()
        {
            foreach (var a in s_AllNullableAnnotations)
            {
                foreach (var b in s_AllNullableAnnotations)
                {
                    foreach (var c in s_AllNullableAnnotations)
                    {
                        var leftFirst = a.MeetForFlowAnalysisFinally(b).MeetForFlowAnalysisFinally(c);
                        var rightFirst = a.MeetForFlowAnalysisFinally(b.MeetForFlowAnalysisFinally(c));
                        Assert.Equal(leftFirst, rightFirst);
                    }
                }
            }
        }

        [Fact]
        public void TestEnsureCompatibleIsAssociative()
        {
            Func<bool, bool> identity = x => x;
            foreach (var a in s_AllSpeakableNullableAnnotations)
            {
                foreach (var b in s_AllSpeakableNullableAnnotations)
                {
                    foreach (var c in s_AllSpeakableNullableAnnotations)
                    {
                        foreach (bool isPossiblyNullableReferenceTypeTypeParameter in new[] { true, false })
                        {
                            var leftFirst = a.EnsureCompatible(b).EnsureCompatible(c);
                            var rightFirst = a.EnsureCompatible(b.EnsureCompatible(c));
                            Assert.Equal(leftFirst, rightFirst);
                        }
                    }
                }
            }
        }

        [Fact]
        public void TestJoinForFixingLowerBoundsIsCommutative()
        {
            foreach (var a in s_AllSpeakableNullableAnnotations)
            {
                foreach (var b in s_AllSpeakableNullableAnnotations)
                {
                    var leftFirst = a.JoinForFixingLowerBounds(b);
                    var rightFirst = b.JoinForFixingLowerBounds(a);
                    Assert.Equal(leftFirst, rightFirst);
                }
            }
        }

        [Fact]
        public void TestJoinForFlowAnalysisBranchesIsCommutative()
        {
            Func<bool, bool> identity = x => x;
            foreach (var a in s_AllNullableAnnotations)
            {
                foreach (var b in s_AllNullableAnnotations)
                {
                    foreach (bool isPossiblyNullableReferenceTypeTypeParameter in new[] { true, false })
                    {
                        var leftFirst = a.JoinForFlowAnalysisBranches(b, isPossiblyNullableReferenceTypeTypeParameter, identity);
                        var rightFirst = b.JoinForFlowAnalysisBranches(a, isPossiblyNullableReferenceTypeTypeParameter, identity);
                        Assert.Equal(leftFirst, rightFirst);
                    }
                }
            }
        }

        [Fact]
        public void TestMeetForFixingUpperBoundsIsCommutative()
        {
            foreach (var a in s_AllSpeakableNullableAnnotations)
            {
                foreach (var b in s_AllSpeakableNullableAnnotations)
                {
                    var leftFirst = a.MeetForFixingUpperBounds(b);
                    var rightFirst = b.MeetForFixingUpperBounds(a);
                    Assert.Equal(leftFirst, rightFirst);
                }
            }
        }

        [Fact]
        public void TestMeetForFlowAnalysisFinallyIsCommutative()
        {
            foreach (var a in s_AllNullableAnnotations)
            {
                foreach (var b in s_AllNullableAnnotations)
                {
                    foreach (var c in s_AllNullableAnnotations)
                    {
                        var leftFirst = a.MeetForFlowAnalysisFinally(b);
                        var rightFirst = b.MeetForFlowAnalysisFinally(a);
                        Assert.Equal(leftFirst, rightFirst);
                    }
                }
            }
        }

        [Fact]
        public void TestEnsureCompatibleIsCommutative()
        {
            Func<bool, bool> identity = x => x;
            foreach (var a in s_AllSpeakableNullableAnnotations)
            {
                foreach (var b in s_AllSpeakableNullableAnnotations)
                {
                    foreach (bool isPossiblyNullableReferenceTypeTypeParameter in new[] { true, false })
                    {
                        var leftFirst = a.EnsureCompatible(b);
                        var rightFirst = b.EnsureCompatible(a);
                        Assert.Equal(leftFirst, rightFirst);
                    }
                }
            }
        }

        // Tracked by https://github.com/dotnet/roslyn/issues/31160
        [Fact(Skip = "Two different implementations of NullableAnnotation Join do not agree")]
        public void TestJoinsAgree()
        {
            Func<bool, bool> identity = x => x;
            foreach (var a in s_AllNullableAnnotations)
            {
                foreach (var b in s_AllNullableAnnotations)
                {
                    foreach (bool isPossiblyNullableReferenceTypeTypeParameter in new[] { true, false })
                    {
                        var result1 = a.JoinForFixingLowerBounds(b);
                        var result2 = a.JoinForFlowAnalysisBranches(b, isPossiblyNullableReferenceTypeTypeParameter, identity);
                        Assert.Equal(result1, result2);
                    }
                }
            }
        }

        // Tracked by https://github.com/dotnet/roslyn/issues/31160
        [Fact(Skip = "Two different implementations of NullableAnnotation Meet do not agree")]
        public void TestMeetsAgree()
        {
            foreach (var a in s_AllNullableAnnotations)
            {
                foreach (var b in s_AllNullableAnnotations)
                {
                    var result1 = a.MeetForFixingUpperBounds(b);
                    var result2 = a.MeetForFlowAnalysisFinally(b);
                    Assert.Equal(result1, result2);
                }
            }
        }

        [Fact]
        public void NullableT_CSharp7()
        {
            var source =
@"class Program
{
    static void F<T>(T? x) where T : struct
    {
        _ = x.Value;
    }
}";
            var comp = CreateCompilation(source, parseOptions: TestOptions.Regular7, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // error CS8630: Invalid 'NullableContextOptions' value: 'Enable' for C# 7.0. Please use language version 8.0 or greater.
                Diagnostic(ErrorCode.ERR_NullableOptionNotAvailable).WithArguments("NullableContextOptions", "Enable", "7.0", "8.0").WithLocation(1, 1)
                );
        }

        [Fact]
        public void NullableT_WarningDisabled()
        {
            var source =
@"#nullable disable
//#pragma warning disable nullable
class Program
{
    static void F<T>(T? x) where T : struct
    {
        _ = x.Value;
    }
}";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_01()
        {
            var source =
@"class Program
{
    static void F<T>(T? x) where T : struct
    {
        _ = x.Value; // 1
        _ = x.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,13): warning CS8629: Nullable value type may be null.
                //         _ = x.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "x.Value").WithLocation(5, 13));
        }

        [Fact]
        public void NullableT_02()
        {
            var source =
@"class Program
{
    static void F<T>(T x) where T : struct
    {
        T? y = x;
        _ = y.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_03()
        {
            var source =
@"class Program
{
    static void F<T>(T? x) where T : struct
    {
        T y = x;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,15): error CS0266: Cannot implicitly convert type 'T?' to 'T'. An explicit conversion exists (are you missing a cast?)
                //         T y = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConvCast, "x").WithArguments("T?", "T").WithLocation(5, 15),
                // (5,15): warning CS8629: Nullable value type may be null.
                //         T y = x;
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "x").WithLocation(5, 15));
        }

        [Fact]
        public void NullableT_04()
        {
            var source =
@"class Program
{
    static T F1<T>(T? x) where T : struct
    {
        return (T)x; // 1
    }
    static T F2<T>() where T : struct
    {
        return (T)default(T?); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,16): warning CS8629: Nullable value type may be null.
                //         return (T)x; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(T)x").WithLocation(5, 16),
                // (9,16): warning CS8629: Nullable value type may be null.
                //         return (T)default(T?); // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(T)default(T?)").WithLocation(9, 16));
        }

        [Fact]
        public void NullableT_05()
        {
            var source =
@"using System;
class Program
{
    static void F<T>() where T : struct
    {
        _ = nameof(Nullable<T>.HasValue);
        _ = nameof(Nullable<T>.Value);
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_06()
        {
            var source =
@"class Program
{
    static void F<T>(T? x, T? y) where T : struct
    {
        _ = (T)x; // 1
        _ = (T)x;
        x = y;
        _ = (T)x; // 2
        _ = (T)x;
        _ = (T)y; // 3
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,13): warning CS8629: Nullable value type may be null.
                //         _ = (T)x; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(T)x").WithLocation(5, 13),
                // (8,13): warning CS8629: Nullable value type may be null.
                //         _ = (T)x; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(T)x").WithLocation(8, 13),
                // (10,13): warning CS8629: Nullable value type may be null.
                //         _ = (T)y; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(T)y").WithLocation(10, 13));
        }

        [Fact]
        public void NullableT_07()
        {
            var source =
@"class Program
{
    static void F1((int, int) x)
    {
        (int, int)? y = x;
        _ = y.Value;
        var z = ((int, int))y;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_08()
        {
            var source =
@"class Program
{
    static void F1((int, int)? x)
    {
        var y = ((int, int))x; // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,17): warning CS8629: Nullable value type may be null.
                //         var y = ((int, int))x; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "((int, int))x").WithLocation(5, 17));
        }

        [Fact]
        public void NullableT_09()
        {
            var source =
@"class Program
{
    static void F<T>(T t) where T : struct
    {
        T? x = null;
        _ = x.Value; // 1
        T? y = default;
        _ = y.Value; // 2
        T? z = default(T);
        _ = z.Value;
        T? w = t;
        _ = w.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8629: Nullable value type may be null.
                //         _ = x.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "x.Value").WithLocation(6, 13),
                // (8,13): warning CS8629: Nullable value type may be null.
                //         _ = y.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Value").WithLocation(8, 13));
        }

        [WorkItem(31502, "https://github.com/dotnet/roslyn/issues/31502")]
        [Fact]
        public void NullableT_10()
        {
            var source =
@"class Program
{
    static void F<T>(T t) where T : struct
    {
        T? x = new System.Nullable<T>();
        _ = x.Value; // 1
        T? y = new System.Nullable<T>(t);
        _ = y.Value;
        T? z = new T?();
        _ = z.Value; // 2
        T? w = new T?(t);
        _ = w.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/31502: Recognize Nullable<T> constructors.
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_11()
        {
            var source =
@"class C<T> where T : struct
{
    static void F1(T? t1)
    {
        if (t1.HasValue)
            _ = t1.Value;
        else
            _ = t1.Value; // 1
    }
    static void F2(T? t2)
    {
        if (!t2.HasValue)
            _ = t2.Value; // 2
        else
            _ = t2.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,17): warning CS8629: Nullable value type may be null.
                //             _ = t1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t1.Value").WithLocation(8, 17),
                // (13,17): warning CS8629: Nullable value type may be null.
                //             _ = t2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t2.Value").WithLocation(13, 17));
        }

        [Fact]
        public void NullableT_12()
        {
            var source =
@"class C<T> where T : struct
{
    static void F1(T? t1)
    {
        if (t1 != null)
            _ = t1.Value;
        else
            _ = t1.Value; // 1
    }
    static void F2(T? t2)
    {
        if (t2 == null)
            _ = t2.Value; // 2
        else
            _ = t2.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,17): warning CS8629: Nullable value type may be null.
                //             _ = t1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t1.Value").WithLocation(8, 17),
                // (13,17): warning CS8629: Nullable value type may be null.
                //             _ = t2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t2.Value").WithLocation(13, 17));
        }

        [Fact]
        public void NullableT_13()
        {
            var source =
@"class C<T> where T : struct
{
    static void F1(T? t1)
    {
        if (null != t1)
            _ = (T)t1;
        else
            _ = (T)t1; // 1
    }
    static void F2(T? t2)
    {
        if (null == t2)
        {
            var o2 = (object)t2; // 2
            o2.ToString(); // 3
        }
        else
        {
            var o2 = (object)t2;
            o2.ToString();
        }
    }
    static void F3(T? t3)
    {
        if (null == t3)
        {
            var d3 = (dynamic)t3; // 4
            d3.ToString(); // 5
        }
        else
        {
            var d3 = (dynamic)t3;
            d3.ToString();
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,17): warning CS8629: Nullable value type may be null.
                //             _ = (T)t1; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(T)t1").WithLocation(8, 17),
                // (14,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             var o2 = (object)t2; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)t2").WithLocation(14, 22),
                // (15,13): warning CS8602: Possible dereference of a null reference.
                //             o2.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o2").WithLocation(15, 13),
                // (27,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             var d3 = (dynamic)t3; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(dynamic)t3").WithLocation(27, 22),
                // (28,13): warning CS8602: Possible dereference of a null reference.
                //             d3.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "d3").WithLocation(28, 13));
        }

        [Fact]
        public void NullableT_14()
        {
            var source =
@"class C<T> where T : struct
{
    static void F1(T? t1)
    {
        if (t1.HasValue)
        {
            if (t1.HasValue) _ = t1.Value;
            else _ = t1.Value;
        }
    }
    static void F2(T? t2)
    {
        if (t2 != null)
        {
            if (!t2.HasValue) _ = t2.Value;
            else _ = t2.Value;
        }
    }
    static void F3(T? t3)
    {
        if (!t3.HasValue)
        {
            if (t3 != null) _ = t3.Value;
            else _ = t3.Value; // 1
        }
    }
    static void F4(T? t4)
    {
        if (t4 == null)
        {
            if (t4 == null) _ = t4.Value; // 2
            else _ = t4.Value;
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (24,22): warning CS8629: Nullable value type may be null.
                //             else _ = t3.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t3.Value").WithLocation(24, 22),
                // (31,33): warning CS8629: Nullable value type may be null.
                //             if (t4 == null) _ = t4.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t4.Value").WithLocation(31, 33));
        }

        [Fact]
        public void NullableT_15()
        {
            var source =
@"class C<T> where T : struct
{
    static void F1(T? x1, T? y1)
    {
        _ = x1.HasValue ?
            x1.Value :
            y1.Value; // 1
    }
    static void F2(T? x2, T? y2)
    {
        _ = !x2.HasValue ?
            y2.Value : // 2
            x2.Value;
    }
    static void F3(T? x3, T? y3)
    {
        _ = x3.HasValue || y3.HasValue ?
            x3.Value : // 3
            y3.Value; // 4
    }
    static void F4(T? x4, T? y4)
    {
        _ = x4.HasValue && y4.HasValue ?
            (T)x4 :
            (T)y4; // 5
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): warning CS8629: Nullable value type may be null.
                //             y1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y1.Value").WithLocation(7, 13),
                // (12,13): warning CS8629: Nullable value type may be null.
                //             y2.Value : // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y2.Value").WithLocation(12, 13),
                // (18,13): warning CS8629: Nullable value type may be null.
                //             x3.Value : // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "x3.Value").WithLocation(18, 13),
                // (19,13): warning CS8629: Nullable value type may be null.
                //             y3.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y3.Value").WithLocation(19, 13),
                // (25,13): warning CS8629: Nullable value type may be null.
                //             (T)y4; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(T)y4").WithLocation(25, 13));
        }

        [Fact]
        public void NullableT_16()
        {
            var source =
@"class C<T> where T : struct
{
    static void F1(T? x1, T? y1)
    {
        _ = x1 != null ?
            x1.Value :
            y1.Value; // 1
    }
    static void F2(T? x2, T? y2)
    {
        _ = x2 == null ?
            y2.Value : // 2
            x2.Value;
    }
    static void F3(T? x3, T? y3)
    {
        _ = x3 != null || y3 != null ?
            x3.Value : // 3
            y3.Value; // 4
    }
    static void F4(T? x4, T? y4)
    {
        _ = x4 != null && y4 != null ?
            (T)x4 :
            (T)y4; // 5
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,13): warning CS8629: Nullable value type may be null.
                //             y1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y1.Value").WithLocation(7, 13),
                // (12,13): warning CS8629: Nullable value type may be null.
                //             y2.Value : // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y2.Value").WithLocation(12, 13),
                // (18,13): warning CS8629: Nullable value type may be null.
                //             x3.Value : // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "x3.Value").WithLocation(18, 13),
                // (19,13): warning CS8629: Nullable value type may be null.
                //             y3.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y3.Value").WithLocation(19, 13),
                // (25,13): warning CS8629: Nullable value type may be null.
                //             (T)y4; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(T)y4").WithLocation(25, 13));
        }

        [Fact]
        public void NullableT_17()
        {
            var source =
@"class C<T> where T : struct
{
    static void F1(T? x1, T? y1)
    {
        _ = (T)(x1 != null ? x1 : y1); // 1
    }
    static void F2(T? x2, T? y2)
    {
        if (y2 == null) return;
        _ = (T)(x2 != null ? x2 : y2);
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,13): warning CS8629: Nullable value type may be null.
                //         _ = (T)(x1 != null ? x1 : y1); // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(T)(x1 != null ? x1 : y1)").WithLocation(5, 13));
        }

        [Fact]
        public void NullableT_18()
        {
            var source =
@"class C<T> where T : struct
{
    static void F1(T? x1, T? y1)
    {
        object? z1 = x1 != null ? (object?)x1 : y1;
        _ = z1/*T:object?*/.ToString(); // 1
        dynamic? w1 = x1 != null ? (dynamic?)x1 : y1;
        _ = w1/*T:dynamic?*/.ToString(); // 2
    }
    static void F2(T? x2, T? y2)
    {
        if (y2 == null) return;
        object? z2 = x2 != null ? (object?)x2 : y2;
        _ = z2/*T:object!*/.ToString();
        dynamic? w2 = x2 != null ? (dynamic?)x2 : y2;
        _ = w2/*T:dynamic!*/.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8602: Possible dereference of a null reference.
                //         _ = z1/*T:object?*/.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z1").WithLocation(6, 13),
                // (8,13): warning CS8602: Possible dereference of a null reference.
                //         _ = w1/*T:dynamic?*/.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w1").WithLocation(8, 13));
            comp.VerifyTypes();
        }

        [Fact]
        public void NullableT_19()
        {
            var source =
@"#pragma warning disable 0649
struct A
{
    internal B? B;
}
struct B
{
    internal C? C;
}
struct C
{
}
class Program
{
    static void F1(A? na1)
    {
        if (na1?.B?.C != null)
        {
            _ = na1.Value.B.Value.C.Value;
        }
        else
        {
            A a1 = na1.Value; // 1
            B b1 = a1.B.Value; // 2
            C c1 = b1.C.Value; // 3
        }
    }
    static void F2(A? na2)
    {
        if (na2?.B?.C != null)
        {
            _ = (C)((B)((A)na2).B).C;
        }
        else
        {
            A a2 = (A)na2; // 4
            B b2 = (B)a2.B; // 5
            C c2 = (C)b2.C; // 6
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (23,20): warning CS8629: Nullable value type may be null.
                //             A a1 = na1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "na1.Value").WithLocation(23, 20),
                // (24,20): warning CS8629: Nullable value type may be null.
                //             B b1 = a1.B.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "a1.B.Value").WithLocation(24, 20),
                // (25,20): warning CS8629: Nullable value type may be null.
                //             C c1 = b1.C.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "b1.C.Value").WithLocation(25, 20),
                // (36,20): warning CS8629: Nullable value type may be null.
                //             A a2 = (A)na2; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(A)na2").WithLocation(36, 20),
                // (37,20): warning CS8629: Nullable value type may be null.
                //             B b2 = (B)a2.B; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(B)a2.B").WithLocation(37, 20),
                // (38,20): warning CS8629: Nullable value type may be null.
                //             C c2 = (C)b2.C; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(C)b2.C").WithLocation(38, 20));
        }

        [Fact]
        public void NullableT_20()
        {
            var source =
@"#pragma warning disable 0649
struct A
{
    internal B? B;
}
struct B
{
}
class Program
{
    static void F1(A? na1)
    {
        if (na1?.B != null)
        {
            var a1 = (object)na1;
            a1.ToString();
        }
        else
        {
            var a1 = (object)na1; // 1
            a1.ToString(); // 2
        }
    }
    static void F2(A? na2)
    {
        if (na2?.B != null)
        {
            var a2 = (System.ValueType)na2;
            a2.ToString();
        }
        else
        {
            var a2 = (System.ValueType)na2; // 3
            a2.ToString(); // 4
        }
    }
    static void F3(A? na3)
    {
        if (na3?.B != null)
        {
            var a3 = (A)na3;
            var b3 = (object)a3.B;
            b3.ToString();
        }
        else
        {
            var a3 = (A)na3; // 5
            var b3 = (object)a3.B; // 6
            b3.ToString(); // 7
        }
    }
    static void F4(A? na4)
    {
        if (na4?.B != null)
        {
            var a4 = (A)na4;
            var b4 = (System.ValueType)a4.B;
            b4.ToString();
        }
        else
        {
            var a4 = (A)na4; // 8
            var b4 = (System.ValueType)a4.B; // 9
            b4.ToString(); // 10
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (20,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             var a1 = (object)na1; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)na1").WithLocation(20, 22),
                // (21,13): warning CS8602: Possible dereference of a null reference.
                //             a1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a1").WithLocation(21, 13),
                // (33,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             var a2 = (System.ValueType)na2; // 3
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(System.ValueType)na2").WithLocation(33, 22),
                // (34,13): warning CS8602: Possible dereference of a null reference.
                //             a2.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a2").WithLocation(34, 13),
                // (47,22): warning CS8629: Nullable value type may be null.
                //             var a3 = (A)na3; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(A)na3").WithLocation(47, 22),
                // (48,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             var b3 = (object)a3.B; // 6
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)a3.B").WithLocation(48, 22),
                // (49,13): warning CS8602: Possible dereference of a null reference.
                //             b3.ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b3").WithLocation(49, 13),
                // (62,22): warning CS8629: Nullable value type may be null.
                //             var a4 = (A)na4; // 8
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(A)na4").WithLocation(62, 22),
                // (63,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             var b4 = (System.ValueType)a4.B; // 9
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(System.ValueType)a4.B").WithLocation(63, 22),
                // (64,13): warning CS8602: Possible dereference of a null reference.
                //             b4.ToString(); // 10
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b4").WithLocation(64, 13));
        }

        [Fact]
        public void NullableT_21()
        {
            var source =
@"#pragma warning disable 0649
struct A
{
    internal B? B;
    public static implicit operator C(A a) => new C();
}
struct B
{
    public static implicit operator C(B b) => new C();
}
class C
{
}
class Program
{
    static void F1(A? na1)
    {
        if (na1?.B != null)
        {
            var c1 = (C)na1;
            c1.ToString();
        }
        else
        {
            var c1 = (C)na1; // 1
            c1.ToString(); // 2
        }
    }
    static void F2(A? na2)
    {
        if (na2?.B != null)
        {
            var a2 = (A)na2;
            var c2 = (C)a2.B;
            c2.ToString();
        }
        else
        {
            var a2 = (A)na2; // 3
            var c2 = (C)a2.B; // 4
            c2.ToString(); // 5
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (25,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             var c1 = (C)na1; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)na1").WithLocation(25, 22),
                // (26,13): warning CS8602: Possible dereference of a null reference.
                //             c1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1").WithLocation(26, 13),
                // (39,22): warning CS8629: Nullable value type may be null.
                //             var a2 = (A)na2; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(A)na2").WithLocation(39, 22),
                // (40,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             var c2 = (C)a2.B; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(C)a2.B").WithLocation(40, 22),
                // (41,13): warning CS8602: Possible dereference of a null reference.
                //             c2.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(41, 13));
        }

        [Fact]
        public void NullableT_22()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    internal C? C;
}
class C
{
    internal S? S;
}
class Program
{
    static void F1(S? ns)
    {
        if (ns?.C != null)
        {
            _ = ns.Value.C.ToString();
        }
        else
        {
            var s = ns.Value; // 1
            var c = s.C;
            c.ToString(); // 2
        }
    }
    static void F2(C? nc)
    {
        if (nc?.S != null)
        {
            _ = nc.S.Value;
        }
        else
        {
            
            var ns = nc.S; // 3
            _ = ns.Value; // 4
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (20,21): warning CS8629: Nullable value type may be null.
                //             var s = ns.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "ns.Value").WithLocation(20, 21),
                // (22,13): warning CS8602: Possible dereference of a null reference.
                //             c.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(22, 13),
                // (34,22): warning CS8602: Possible dereference of a null reference.
                //             var ns = nc.S; // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "nc").WithLocation(34, 22),
                // (35,17): warning CS8629: Nullable value type may be null.
                //             _ = ns.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "ns.Value").WithLocation(35, 17));
        }

        [Fact]
        public void NullableT_IntToLong()
        {
            var source =
@"class Program
{
    // int -> long?
    static void F1(int i)
    {
        var nl1 = (long?)i;
        _ = nl1.Value;
        long? nl2 = i;
        _ = nl2.Value;
        int? ni = i;
        long? nl3 = ni;
        _ = nl3.Value;
    }
    // int? -> long?
    static void F2(int? ni)
    {
        if (ni.HasValue)
        {
            long? nl1 = ni;
            _ = nl1.Value;
            var nl2 = (long?)ni;
            _ = nl2.Value;
        }
        else
        {
            long? nl3 = ni;
            _ = nl3.Value; // 1
            var nl4 = (long?)ni;
            _ = nl4.Value; // 2
        }
    }
    // int? -> long
    static void F3(int? ni)
    {
        if (ni.HasValue)
        {
            _ = (long)ni;
        }
        else
        {
            _ = (long)ni; // 3
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (27,17): warning CS8629: Nullable value type may be null.
                //             _ = nl3.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl3.Value").WithLocation(27, 17),
                // (29,17): warning CS8629: Nullable value type may be null.
                //             _ = nl4.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl4.Value").WithLocation(29, 17),
                // (41,17): warning CS8629: Nullable value type may be null.
                //             _ = (long)ni; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(long)ni").WithLocation(41, 17));
        }

        [Fact]
        public void NullableT_LongToStruct()
        {
            var source =
@"struct S
{
    public static implicit operator S(long l) => new S();
}
class Program
{
    // int -> long -> S -> S?
    static void F1(int i)
    {
        var s1 = (S?)i;
        _ = s1.Value;
        S? s2 = i;
        _ = s2.Value;
        int? ni = i;
        S? s3 = ni;
        _ = s3.Value;
    }
    // int? -> long? -> S?
    static void F2(int? ni)
    {
        if (ni.HasValue)
        {
            var s1 = (S?)ni;
            _ = s1.Value;
            S? s2 = ni;
            _ = s2.Value;
        }
        else
        {
            var s3 = (S?)ni;
            _ = s3.Value; // 1
            S? s4 = ni;
            _ = s4.Value; // 2
        }
    }
    // int? -> long? -> S? -> S
    static void F3(int? ni)
    {
        if (ni.HasValue)
        {
            _ = (S)ni;
        }
        else
        {
            _ = (S)ni; // 1
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (31,17): warning CS8629: Nullable value type may be null.
                //             _ = s3.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s3.Value").WithLocation(31, 17),
                // (33,17): warning CS8629: Nullable value type may be null.
                //             _ = s4.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s4.Value").WithLocation(33, 17),
                // (45,20): warning CS8629: Nullable value type may be null.
                //             _ = (S)ni; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "ni").WithLocation(45, 20));
        }

        [Fact]
        public void NullableT_LongToNullableStruct()
        {
            var source =
@"struct S
{
    public static implicit operator S?(long l) => new S();
}
class Program
{
    // int -> long -> S?
    static void F1(int i)
    {
        var s1 = (S?)i;
        _ = s1.Value; // 1
        S? s2 = i;
        _ = s2.Value; // 2
        int? ni = i;
        S? s3 = ni;
        _ = s3.Value; // 3
    }
    // int? -> long? -> S?
    static void F2(int? ni)
    {
        if (ni.HasValue)
        {
            var s1 = (S?)ni;
            _ = s1.Value; // 4
            S? s2 = ni;
            _ = s2.Value; // 5
        }
        else
        {
            var s3 = (S?)ni;
            _ = s3.Value; // 6
            S? s4 = ni;
            _ = s4.Value; // 7
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = s1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(11, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = s2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(13, 13),
                // (16,13): warning CS8629: Nullable value type may be null.
                //         _ = s3.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s3.Value").WithLocation(16, 13),
                // (24,17): warning CS8629: Nullable value type may be null.
                //             _ = s1.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(24, 17),
                // (26,17): warning CS8629: Nullable value type may be null.
                //             _ = s2.Value; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(26, 17),
                // (31,17): warning CS8629: Nullable value type may be null.
                //             _ = s3.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s3.Value").WithLocation(31, 17),
                // (33,17): warning CS8629: Nullable value type may be null.
                //             _ = s4.Value; // 7
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s4.Value").WithLocation(33, 17));
        }

        [Fact]
        public void NullableT_NullableLongToStruct()
        {
            var source =
@"struct S
{
    public static implicit operator S(long? l) => new S();
}
class Program
{
    // int -> int? -> long? -> S
    static void F1(int i)
    {
        _ = (S)i;
        S s = i;
    }
    // int? -> long? -> S
    static void F2(int? ni)
    {
        _ = (S)ni;
        S s = ni;
    }
    // int? -> long? -> S -> S?
    static void F3(int? ni)
    {
        var ns1 = (S?)ni;
        _ = ns1.Value;
        S? ns2 = ni;
        _ = ns1.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_NullableLongToNullableStruct()
        {
            var source =
@"struct S
{
    public static implicit operator S?(long? l) => new S();
}
class Program
{
    // int -> int? -> long? -> S
    static void F1(int i)
    {
        _ = (S)i; // 1
    }
    // int? -> long? -> S?
    static void F2(int? ni)
    {
        if (ni.HasValue)
        {
            var ns1 = (S?)ni;
            _ = ns1.Value; // 2
            S? ns2 = ni;
            _ = ns2.Value; // 3
        }
        else
        {
            var ns3 = (S?)ni;
            _ = ns3.Value; // 4
            S? ns4 = ni;
            _ = ns4.Value; // 5
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8629: Nullable value type may be null.
                //         _ = (S)i; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(S)i").WithLocation(10, 13),
                // (18,17): warning CS8629: Nullable value type may be null.
                //             _ = ns1.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "ns1.Value").WithLocation(18, 17),
                // (20,17): warning CS8629: Nullable value type may be null.
                //             _ = ns2.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "ns2.Value").WithLocation(20, 17),
                // (25,17): warning CS8629: Nullable value type may be null.
                //             _ = ns3.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "ns3.Value").WithLocation(25, 17),
                // (27,17): warning CS8629: Nullable value type may be null.
                //             _ = ns4.Value; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "ns4.Value").WithLocation(27, 17));
        }

        [Fact]
        public void NullableT_StructToInt()
        {
            var source =
@"struct S
{
    public static implicit operator int(S s) => 0;
}
class Program
{
    // S -> int -> long?
    static void F1(S s)
    {
        var nl1 = (long?)s;
        _ = nl1.Value;
        long? nl2 = s;
        _ = nl2.Value;
    }
    // S? -> int? -> long?
    static void F2(S? ns)
    {
        if (ns.HasValue)
        {
            var nl1 = (long?)ns;
            _ = nl1.Value;
            long? nl2 = ns;
            _ = nl2.Value;
        }
        else
        {
            var nl1 = (long?)ns;
            _ = nl1.Value; // 1
            long? nl2 = ns;
            _ = nl2.Value; // 2
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (28,17): warning CS8629: Nullable value type may be null.
                //             _ = nl1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl1.Value").WithLocation(28, 17),
                // (30,17): warning CS8629: Nullable value type may be null.
                //             _ = nl2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl2.Value").WithLocation(30, 17));
        }

        [Fact]
        public void NullableT_StructToNullableInt()
        {
            var source =
@"struct S
{
    public static implicit operator int?(S s) => 0;
}
class Program
{
    // S -> int? -> long?
    static void F1(S s)
    {
        var nl1 = (long?)s;
        _ = nl1.Value; // 1
        long? nl2 = s;
        _ = nl2.Value; // 2
    }
    // S? -> int? -> long?
    static void F2(S? ns)
    {
        if (ns.HasValue)
        {
            var nl1 = (long?)ns;
            _ = nl1.Value; // 3
            long? nl2 = ns;
            _ = nl2.Value; // 4
        }
        else
        {
            var nl1 = (long?)ns;
            _ = nl1.Value; // 5
            long? nl2 = ns;
            _ = nl2.Value; // 6
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = nl1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl1.Value").WithLocation(11, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = nl2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl2.Value").WithLocation(13, 13),
                // (21,17): warning CS8629: Nullable value type may be null.
                //             _ = nl1.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl1.Value").WithLocation(21, 17),
                // (23,17): warning CS8629: Nullable value type may be null.
                //             _ = nl2.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl2.Value").WithLocation(23, 17),
                // (28,17): warning CS8629: Nullable value type may be null.
                //             _ = nl1.Value; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl1.Value").WithLocation(28, 17),
                // (30,17): warning CS8629: Nullable value type may be null.
                //             _ = nl2.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl2.Value").WithLocation(30, 17));
        }

        [Fact]
        public void NullableT_NullableStructToInt()
        {
            var source =
@"struct S
{
    public static implicit operator int(S? s) => 0;
}
class Program
{
    // S -> S? -> int -> long
    static void F1(S s)
    {
        _ = (long)s;
        long l2 = s;
    }
    // S? -> int -> long
    static void F2(S? ns)
    {
        if (ns.HasValue)
        {
            _ = (long)ns;
            long l2 = ns;
        }
        else
        {
            _ = (long)ns;
            long l2 = ns;
        }
    }
    // S? -> int -> long -> long?
    static void F3(S? ns)
    {
        if (ns.HasValue)
        {
            var nl1 = (long?)ns;
            _ = nl1.Value;
            long? nl2 = ns;
            _ = nl2.Value;
        }
        else
        {
            var nl1 = (long?)ns;
            _ = nl1.Value;
            long? nl2 = ns;
            _ = nl2.Value;
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_NullableStructToNullableInt()
        {
            var source =
@"struct S
{
    public static implicit operator int?(S? s) => 0;
}
class Program
{
    // S -> S? -> int? -> long?
    static void F1(S s)
    {
        var nl1 = (long?)s;
        _ = nl1.Value; // 1
        long? nl2 = s;
        _ = nl2.Value; // 2
    }
    // S? -> int? -> long?
    static void F2(S? ns)
    {
        if (ns.HasValue)
        {
            var nl1 = (long?)ns;
            _ = nl1.Value; // 3
            long? nl2 = ns;
            _ = nl2.Value; // 4
        }
        else
        {
            var nl3 = (long?)ns;
            _ = nl3.Value; // 5
            long? nl4 = ns;
            _ = nl4.Value; // 6
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = nl1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl1.Value").WithLocation(11, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = nl2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl2.Value").WithLocation(13, 13),
                // (21,17): warning CS8629: Nullable value type may be null.
                //             _ = nl1.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl1.Value").WithLocation(21, 17),
                // (23,17): warning CS8629: Nullable value type may be null.
                //             _ = nl2.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl2.Value").WithLocation(23, 17),
                // (28,17): warning CS8629: Nullable value type may be null.
                //             _ = nl3.Value; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl3.Value").WithLocation(28, 17),
                // (30,17): warning CS8629: Nullable value type may be null.
                //             _ = nl4.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "nl4.Value").WithLocation(30, 17));
        }

        [Fact]
        public void NullableT_StructToClass()
        {
            var source =
@"struct S
{
    public static implicit operator C(S s) => new C();
}
class C
{
}
class Program
{
    // S -> C
    static void F1(S s)
    {
        var c1 = (C)s;
        _ = c1.ToString();
        C c2 = s;
        _ = c2.ToString();
    }
    // S? -> C?
    static void F2(S? ns)
    {
        if (ns.HasValue)
        {
            var c1 = (C?)ns;
            _ = c1.ToString();
            C? c2 = ns;
            _ = c2.ToString();
        }
        else
        {
            var c3 = (C?)ns;
            _ = c3.ToString(); // 1
            C? c4 = ns;
            _ = c4.ToString(); // 2
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (31,17): warning CS8602: Possible dereference of a null reference.
                //             _ = c3.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c3").WithLocation(31, 17),
                // (33,17): warning CS8602: Possible dereference of a null reference.
                //             _ = c4.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c4").WithLocation(33, 17));
        }

        [Fact]
        public void NullableT_StructToNullableClass()
        {
            var source =
@"struct S
{
    public static implicit operator C?(S s) => new C();
}
class C
{
}
class Program
{
    // S -> C?
    static void F1(S s)
    {
        var c1 = (C?)s;
        _ = c1.ToString(); // 1
        C? c2 = s;
        _ = c2.ToString(); // 2
    }
    // S? -> C?
    static void F2(S? ns)
    {
        if (ns.HasValue)
        {
            var c1 = (C?)ns;
            _ = c1.ToString(); // 3
            C? c2 = ns;
            _ = c2.ToString(); // 4
        }
        else
        {
            var c3 = (C?)ns;
            _ = c3.ToString(); // 5
            C? c4 = ns;
            _ = c4.ToString(); // 6
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,13): warning CS8602: Possible dereference of a null reference.
                //         _ = c1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1").WithLocation(14, 13),
                // (16,13): warning CS8602: Possible dereference of a null reference.
                //         _ = c2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(16, 13),
                // (24,17): warning CS8602: Possible dereference of a null reference.
                //             _ = c1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1").WithLocation(24, 17),
                // (26,17): warning CS8602: Possible dereference of a null reference.
                //             _ = c2.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(26, 17),
                // (31,17): warning CS8602: Possible dereference of a null reference.
                //             _ = c3.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c3").WithLocation(31, 17),
                // (33,17): warning CS8602: Possible dereference of a null reference.
                //             _ = c4.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c4").WithLocation(33, 17));
        }

        [Fact]
        public void NullableT_NullableStructToClass()
        {
            var source =
@"struct S
{
    public static implicit operator C(S? s) => new C();
}
class C
{
}
class Program
{
    // S -> C
    static void F1(S s)
    {
        var c1 = (C)s;
        _ = c1.ToString();
        C c2 = s;
        _ = c2.ToString();
    }
    // S? -> C?
    static void F2(S? ns)
    {
        if (ns.HasValue)
        {
            var c1 = (C?)ns;
            _ = c1.ToString();
            C? c2 = ns;
            _ = c2.ToString();
        }
        else
        {
            var c3 = (C?)ns;
            _ = c3.ToString();
            C? c4 = ns;
            _ = c4.ToString();
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_NullableStructToNullableClass()
        {
            var source =
@"struct S
{
    public static implicit operator C?(S? s) => new C();
}
class C
{
}
class Program
{
    // S -> C?
    static void F1(S s)
    {
        var c1 = (C?)s;
        _ = c1.ToString(); // 1
        C? c2 = s;
        _ = c2.ToString(); // 2
    }
    // S? -> C?
    static void F2(S? ns)
    {
        if (ns.HasValue)
        {
            var c1 = (C?)ns;
            _ = c1.ToString(); // 3
            C? c2 = ns;
            _ = c2.ToString(); // 4
        }
        else
        {
            var c3 = (C?)ns;
            _ = c3.ToString(); // 5
            C? c4 = ns;
            _ = c4.ToString(); // 6
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,13): warning CS8602: Possible dereference of a null reference.
                //         _ = c1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1").WithLocation(14, 13),
                // (16,13): warning CS8602: Possible dereference of a null reference.
                //         _ = c2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(16, 13),
                // (24,17): warning CS8602: Possible dereference of a null reference.
                //             _ = c1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1").WithLocation(24, 17),
                // (26,17): warning CS8602: Possible dereference of a null reference.
                //             _ = c2.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(26, 17),
                // (31,17): warning CS8602: Possible dereference of a null reference.
                //             _ = c3.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c3").WithLocation(31, 17),
                // (33,17): warning CS8602: Possible dereference of a null reference.
                //             _ = c4.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c4").WithLocation(33, 17));
        }

        [Fact]
        public void NullableT_ClassToStruct()
        {
            var source =
@"struct S
{
    public static implicit operator S(C c) => new S();
}
class C
{
}
class Program
{
    // C -> S
    static void F1(C c)
    {
        _ = (S)c;
        S s2 = c;
    }
    // C? -> S?
    static void F2(C? nc)
    {
        if (nc != null)
        {
            var s1 = (S?)nc;
            _ = s1.Value;
            S? s2 = nc;
            _ = s2.Value;
        }
        else
        {
            var s3 = (S?)nc; // 1
            _ = s3.Value;
            S? s4 = nc; // 2
            _ = s4.Value;
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (28,26): warning CS8604: Possible null reference argument for parameter 'c' in 'S.implicit operator S(C c)'.
                //             var s3 = (S?)nc; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "nc").WithArguments("c", "S.implicit operator S(C c)").WithLocation(28, 26),
                // (30,21): warning CS8604: Possible null reference argument for parameter 'c' in 'S.implicit operator S(C c)'.
                //             S? s4 = nc; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "nc").WithArguments("c", "S.implicit operator S(C c)").WithLocation(30, 21));
        }

        [Fact]
        public void NullableT_ClassToNullableStruct()
        {
            var source =
@"struct S
{
    public static implicit operator S?(C c) => new S();
}
class C
{
}
class Program
{
    // C -> S?
    static void F1(C c)
    {
        var s1 = (S?)c;
        _ = s1.Value; // 1
        S? s2 = c;
        _ = s2.Value; // 2
    }
    // C? -> S?
    static void F2(C? nc)
    {
        if (nc != null)
        {
            var s1 = (S?)nc;
            _ = s1.Value; // 3
            S? s2 = nc;
            _ = s2.Value; // 4
        }
        else
        {
            var s3 = (S?)nc; // 5
            _ = s3.Value; // 6
            S? s4 = nc; // 7
            _ = s4.Value; // 8
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,13): warning CS8629: Nullable value type may be null.
                //         _ = s1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(14, 13),
                // (16,13): warning CS8629: Nullable value type may be null.
                //         _ = s2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(16, 13),
                // (24,17): warning CS8629: Nullable value type may be null.
                //             _ = s1.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(24, 17),
                // (26,17): warning CS8629: Nullable value type may be null.
                //             _ = s2.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(26, 17),
                // (30,26): warning CS8604: Possible null reference argument for parameter 'c' in 'S.implicit operator S?(C c)'.
                //             var s3 = (S?)nc; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "nc").WithArguments("c", "S.implicit operator S?(C c)").WithLocation(30, 26),
                // (31,17): warning CS8629: Nullable value type may be null.
                //             _ = s3.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s3.Value").WithLocation(31, 17),
                // (32,21): warning CS8604: Possible null reference argument for parameter 'c' in 'S.implicit operator S?(C c)'.
                //             S? s4 = nc; // 7
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "nc").WithArguments("c", "S.implicit operator S?(C c)").WithLocation(32, 21),
                // (33,17): warning CS8629: Nullable value type may be null.
                //             _ = s4.Value; // 8
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s4.Value").WithLocation(33, 17));
        }

        [Fact]
        public void NullableT_NullableClassToStruct()
        {
            var source =
@"struct S
{
    public static implicit operator S(C? c) => new S();
}
class C
{
}
class Program
{
    // C -> S
    static void F1(C c)
    {
        _ = (S)c;
        S s2 = c;
    }
    // C? -> S?
    static void F2(C? nc)
    {
        if (nc != null)
        {
            var s1 = (S?)nc;
            _ = s1.Value;
            S? s2 = nc;
            _ = s2.Value;
        }
        else
        {
            var s3 = (S?)nc;
            _ = s3.Value;
            S? s4 = nc;
            _ = s4.Value;
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_NullableClassToNullableStruct()
        {
            var source =
@"struct S
{
    public static implicit operator S?(C? c) => new S();
}
class C
{
}
class Program
{
    // C -> S?
    static void F1(C c)
    {
        var s1 = (S?)c;
        _ = s1.Value; // 1
        S? s2 = c;
        _ = s2.Value; // 2
    }
    // C? -> S?
    static void F2(C? nc)
    {
        if (nc != null)
        {
            var s1 = (S?)nc;
            _ = s1.Value; // 3
            S? s2 = nc;
            _ = s2.Value; // 4
        }
        else
        {
            var s3 = (S?)nc;
            _ = s3.Value; // 5
            S? s4 = nc;
            _ = s4.Value; // 6
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,13): warning CS8629: Nullable value type may be null.
                //         _ = s1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(14, 13),
                // (16,13): warning CS8629: Nullable value type may be null.
                //         _ = s2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(16, 13),
                // (24,17): warning CS8629: Nullable value type may be null.
                //             _ = s1.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(24, 17),
                // (26,17): warning CS8629: Nullable value type may be null.
                //             _ = s2.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(26, 17),
                // (31,17): warning CS8629: Nullable value type may be null.
                //             _ = s3.Value; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s3.Value").WithLocation(31, 17),
                // (33,17): warning CS8629: Nullable value type may be null.
                //             _ = s4.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s4.Value").WithLocation(33, 17));
        }

        // https://github.com/dotnet/roslyn/issues/31675: Add similar tests for
        // type parameters with `class?` constraint and Nullable<T> constraint.

        [Fact]
        public void NullableT_StructToTypeParameterUnconstrained()
        {
            var source =
@"struct S<T>
{
    public static implicit operator T(S<T> s) => throw null;
}
class C<T>
{
    // S<T> -> T
    static void F1(S<T> s)
    {
        var t1 = (T)s;
        _ = t1.ToString(); // 1
        T t2 = s;
        _ = t2.ToString(); // 2
    }
    // S<T>? -> T
    static void F2(S<T>? ns)
    {
        if (ns.HasValue)
        {
            var t1 = (T)ns;
            _ = t1.ToString(); // 3
        }
        else
        {
            var t2 = (T)ns; // 4
            _ = t2.ToString(); // 5
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8602: Possible dereference of a null reference.
                //         _ = t1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(11, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //         _ = t2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2").WithLocation(13, 13),
                // (21,17): warning CS8602: Possible dereference of a null reference.
                //             _ = t1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(21, 17),
                // (25,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //             var t2 = (T)ns; // 4
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(T)ns").WithLocation(25, 22),
                // (26,17): warning CS8602: Possible dereference of a null reference.
                //             _ = t2.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2").WithLocation(26, 17));
        }

        [Fact]
        public void NullableT_NullableStructToTypeParameterUnconstrained()
        {
            var source =
@"struct S<T>
{
    public static implicit operator T(S<T>? s) => throw null;
}
class C<T>
{
    // S<T> -> T
    static void F1(S<T> s)
    {
        var t1 = (T)s;
        _ = t1.ToString(); // 1
        T t2 = s;
        _ = t2.ToString(); // 2
    }
    // S<T>? -> T
    static void F2(S<T>? ns)
    {
        if (ns.HasValue)
        {
            var t1 = (T)ns;
            _ = t1.ToString(); // 3
        }
        else
        {
            var t2 = (T)ns;
            _ = t2.ToString(); // 4
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8602: Possible dereference of a null reference.
                //         _ = t1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(11, 13),
                // (13,13): warning CS8602: Possible dereference of a null reference.
                //         _ = t2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2").WithLocation(13, 13),
                // (21,17): warning CS8602: Possible dereference of a null reference.
                //             _ = t1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1").WithLocation(21, 17),
                // (26,17): warning CS8602: Possible dereference of a null reference.
                //             _ = t2.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t2").WithLocation(26, 17));
        }

        [Fact]
        public void NullableT_StructToTypeParameterClassConstraint()
        {
            var source =
@"struct S<T>
{
    public static implicit operator T(S<T> s) => throw null;
}
class C<T> where T : class
{
    // S<T> -> T
    static void F1(S<T> s)
    {
        var t1 = (T)s;
        _ = t1.ToString();
        T t2 = s;
        _ = t2.ToString();
    }
    // S<T>? -> T?
    static void F2(S<T>? ns)
    {
        if (ns.HasValue)
        {
            var t1 = (T?)ns;
            _ = t1.ToString();
            T? t2 = ns;
            _ = t2.ToString();
        }
        else
        {
            var t3 = (T?)ns;
            _ = t3.ToString(); // 1
            T? t4 = ns;
            _ = t4.ToString(); // 2
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (28,17): warning CS8602: Possible dereference of a null reference.
                //             _ = t3.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t3").WithLocation(28, 17),
                // (30,17): warning CS8602: Possible dereference of a null reference.
                //             _ = t4.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t4").WithLocation(30, 17));
        }

        [Fact]
        public void NullableT_NullableStructToTypeParameterClassConstraint()
        {
            var source =
@"struct S<T>
{
    public static implicit operator T(S<T>? s) => throw null;
}
class C<T> where T : class
{
    // S<T> -> T
    static void F1(S<T> s)
    {
        var t1 = (T)s;
        _ = t1.ToString();
        T t2 = s;
        _ = t2.ToString();
    }
    // S<T>? -> T?
    static void F2(S<T>? ns)
    {
        if (ns.HasValue)
        {
            var t1 = (T?)ns;
            _ = t1.ToString();
            T? t2 = ns;
            _ = t2.ToString();
        }
        else
        {
            var t3 = (T?)ns;
            _ = t3.ToString();
            T? t4 = ns;
            _ = t4.ToString();
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_StructToTypeParameterStructConstraint()
        {
            var source =
@"struct S<T>
{
    public static implicit operator T(S<T> s) => throw null;
}
class C<T> where T : struct
{
    // S<T> -> T
    static void F1(S<T> s)
    {
        var t1 = (T)s;
        _ = t1.ToString();
        T t2 = s;
        _ = t2.ToString();
    }
    // S<T>? -> T?
    static void F2(S<T>? ns)
    {
        if (ns.HasValue)
        {
            var t1 = (T?)ns;
            _ = t1.Value;
            T? t2 = ns;
            _ = t2.Value;
        }
        else
        {
            var t3 = (T?)ns;
            _ = t3.Value; // 1
            T? t4 = ns;
            _ = t4.Value; // 2
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (28,17): warning CS8629: Nullable value type may be null.
                //             _ = t3.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t3.Value").WithLocation(28, 17),
                // (30,17): warning CS8629: Nullable value type may be null.
                //             _ = t4.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t4.Value").WithLocation(30, 17));
        }

        [Fact]
        public void NullableT_NullableStructToTypeParameterStructConstraint()
        {
            var source =
@"struct S<T>
{
    public static implicit operator T(S<T>? s) => throw null;
}
class C<T> where T : struct
{
    // S<T> -> T
    static void F1(S<T> s)
    {
        var t1 = (T)s;
        _ = t1.ToString();
        T t2 = s;
        _ = t2.ToString();
    }
    // S<T>? -> T?
    static void F2(S<T>? ns)
    {
        if (ns.HasValue)
        {
            var t1 = (T?)ns;
            _ = t1.Value;
            T? t2 = ns;
            _ = t2.Value;
        }
        else
        {
            var t3 = (T?)ns;
            _ = t3.Value;
            T? t4 = ns;
            _ = t4.Value;
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_StructToNullableTypeParameterStructConstraint()
        {
            var source =
@"struct S<T> where T : struct
{
    public static implicit operator T?(S<T> s) => throw null;
}
class C<T> where T : struct
{
    // S<T> -> T?
    static void F1(S<T> s)
    {
        var t1 = (T?)s;
        _ = t1.Value; // 1
        T? t2 = s;
        _ = t2.Value; // 2
    }
    // S<T>? -> T?
    static void F2(S<T>? ns)
    {
        if (ns.HasValue)
        {
            var t1 = (T?)ns;
            _ = t1.Value; // 3
            T? t2 = ns;
            _ = t2.Value; // 4
        }
        else
        {
            var t3 = (T?)ns; // 5
            _ = t3.Value; // 6
            T? t4 = ns; // 7
            _ = t4.Value; // 8
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = t1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t1.Value").WithLocation(11, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = t2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t2.Value").WithLocation(13, 13),
                // (21,17): warning CS8629: Nullable value type may be null.
                //             _ = t1.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t1.Value").WithLocation(21, 17),
                // (23,17): warning CS8629: Nullable value type may be null.
                //             _ = t2.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t2.Value").WithLocation(23, 17),
                // (28,17): warning CS8629: Nullable value type may be null.
                //             _ = t3.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t3.Value").WithLocation(28, 17),
                // (30,17): warning CS8629: Nullable value type may be null.
                //             _ = t4.Value; // 8
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t4.Value").WithLocation(30, 17));
        }

        [Fact]
        public void NullableT_NullableStructToNullableTypeParameterStructConstraint()
        {
            var source =
@"struct S<T> where T : struct
{
    public static implicit operator T?(S<T>? s) => throw null;
}
class C<T> where T : struct
{
    // S<T> -> T?
    static void F1(S<T> s)
    {
        var t1 = (T?)s;
        _ = t1.Value; // 1
        T? t2 = s;
        _ = t2.Value; // 2
    }
    // S<T>? -> T?
    static void F2(S<T>? ns)
    {
        if (ns.HasValue)
        {
            var t1 = (T?)ns;
            _ = t1.Value; // 3
            T? t2 = ns;
            _ = t2.Value; // 4
        }
        else
        {
            var t3 = (T?)ns;
            _ = t3.Value; // 5
            T? t4 = ns;
            _ = t4.Value; // 6
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = t1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t1.Value").WithLocation(11, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = t2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t2.Value").WithLocation(13, 13),
                // (21,17): warning CS8629: Nullable value type may be null.
                //             _ = t1.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t1.Value").WithLocation(21, 17),
                // (23,17): warning CS8629: Nullable value type may be null.
                //             _ = t2.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t2.Value").WithLocation(23, 17),
                // (28,17): warning CS8629: Nullable value type may be null.
                //             _ = t3.Value; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t3.Value").WithLocation(28, 17),
                // (30,17): warning CS8629: Nullable value type may be null.
                //             _ = t4.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t4.Value").WithLocation(30, 17));
        }

        [Fact]
        public void NullableT_TypeParameterUnconstrainedToStruct()
        {
            var source =
@"struct S<T>
{
    public static implicit operator S<T>(T t) => throw null;
}
class C<T>
{
    // T -> S<T>
    static void F1(T t)
    {
        _ = (S<T>)t;
        S<T> s2 = t;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_TypeParameterUnconstrainedToNullableStruct()
        {
            var source =
@"struct S<T>
{
    public static implicit operator S<T>?(T t) => throw null;
}
class C<T>
{
    // T -> S<T>?
    static void F1(T t)
    {
        var s1 = (S<T>?)t;
        _ = s1.Value; // 1
        S<T>? s2 = t;
        _ = s2.Value; // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = s1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(11, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = s2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(13, 13));
        }

        [Fact]
        public void NullableT_TypeParameterClassConstraintToStruct()
        {
            var source =
@"struct S<T>
{
    public static implicit operator S<T>(T t) => throw null;
}
class C<T> where T : class
{
    // T -> S<T>
    static void F1(T t)
    {
        _ = (S<T>)t;
        S<T> s2 = t;
    }
    // T? -> S<T>?
    static void F2(T? nt)
    {
        if (nt != null)
        {
            var s1 = (S<T>?)nt;
            _ = s1.Value;
            S<T>? s2 = nt;
            _ = s2.Value;
        }
        else
        {
            var s3 = (S<T>?)nt; // 1
            _ = s3.Value;
            S<T>? s4 = nt; // 2
            _ = s4.Value;
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (25,29): warning CS8604: Possible null reference argument for parameter 't' in 'S<T>.implicit operator S<T>(T t)'.
                //             var s3 = (S<T>?)nt; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "nt").WithArguments("t", "S<T>.implicit operator S<T>(T t)").WithLocation(25, 29),
                // (27,24): warning CS8604: Possible null reference argument for parameter 't' in 'S<T>.implicit operator S<T>(T t)'.
                //             S<T>? s4 = nt; // 2
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "nt").WithArguments("t", "S<T>.implicit operator S<T>(T t)").WithLocation(27, 24));
        }

        [Fact]
        public void NullableT_TypeParameterClassConstraintToNullableStruct()
        {
            var source =
@"struct S<T>
{
    public static implicit operator S<T>?(T t) => throw null;
}
class C<T> where T : class
{
    // T -> S<T>?
    static void F1(T t)
    {
        var s1 = (S<T>?)t;
        _ = s1.Value; // 1
        S<T>? s2 = t;
        _ = s2.Value; // 2
    }
    // T? -> S<T>?
    static void F2(T? nt)
    {
        if (nt != null)
        {
            var s1 = (S<T>?)nt;
            _ = s1.Value; // 3
            S<T>? s2 = nt;
            _ = s2.Value; // 4
        }
        else
        {
            var s3 = (S<T>?)nt; // 5
            _ = s3.Value; // 6
            S<T>? s4 = nt; // 7
            _ = s4.Value; // 8
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = s1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(11, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = s2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(13, 13),
                // (21,17): warning CS8629: Nullable value type may be null.
                //             _ = s1.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(21, 17),
                // (23,17): warning CS8629: Nullable value type may be null.
                //             _ = s2.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(23, 17),
                // (27,29): warning CS8604: Possible null reference argument for parameter 't' in 'S<T>.implicit operator S<T>?(T t)'.
                //             var s3 = (S<T>?)nt; // 5
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "nt").WithArguments("t", "S<T>.implicit operator S<T>?(T t)").WithLocation(27, 29),
                // (28,17): warning CS8629: Nullable value type may be null.
                //             _ = s3.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s3.Value").WithLocation(28, 17),
                // (29,24): warning CS8604: Possible null reference argument for parameter 't' in 'S<T>.implicit operator S<T>?(T t)'.
                //             S<T>? s4 = nt; // 7
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "nt").WithArguments("t", "S<T>.implicit operator S<T>?(T t)").WithLocation(29, 24),
                // (30,17): warning CS8629: Nullable value type may be null.
                //             _ = s4.Value; // 8
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s4.Value").WithLocation(30, 17));
        }

        [Fact]
        public void NullableT_TypeParameterStructConstraintToStruct()
        {
            var source =
@"struct S<T>
{
    public static implicit operator S<T>(T t) => throw null;
}
class C<T> where T : struct
{
    // T -> S<T>
    static void F1(T t)
    {
        _ = (S<T>)t;
        S<T> s2 = t;
    }
    // T? -> S<T>?
    static void F2(T? nt)
    {
        if (nt != null)
        {
            var s1 = (S<T>?)nt;
            _ = s1.Value;
            S<T>? s2 = nt;
            _ = s2.Value;
        }
        else
        {
            var s3 = (S<T>?)nt;
            _ = s3.Value; // 1
            S<T>? s4 = nt;
            _ = s4.Value; // 2
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (26,17): warning CS8629: Nullable value type may be null.
                //             _ = s3.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s3.Value").WithLocation(26, 17),
                // (28,17): warning CS8629: Nullable value type may be null.
                //             _ = s4.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s4.Value").WithLocation(28, 17));
        }

        [Fact]
        public void NullableT_TypeParameterStructConstraintToNullableStruct()
        {
            var source =
@"struct S<T>
{
    public static implicit operator S<T>?(T t) => throw null;
}
class C<T> where T : struct
{
    // T -> S<T>?
    static void F1(T t)
    {
        var s1 = (S<T>?)t;
        _ = s1.Value; // 1
        S<T>? s2 = t;
        _ = s2.Value; // 2
    }
    // T? -> S<T>?
    static void F2(T? nt)
    {
        if (nt != null)
        {
            var s1 = (S<T>?)nt;
            _ = s1.Value; // 3
            S<T>? s2 = nt;
            _ = s2.Value; // 4
        }
        else
        {
            var s3 = (S<T>?)nt; // 5
            _ = s3.Value; // 6
            S<T>? s4 = nt; // 7
            _ = s4.Value; // 8
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = s1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(11, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = s2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(13, 13),
                // (21,17): warning CS8629: Nullable value type may be null.
                //             _ = s1.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(21, 17),
                // (23,17): warning CS8629: Nullable value type may be null.
                //             _ = s2.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(23, 17),
                // (28,17): warning CS8629: Nullable value type may be null.
                //             _ = s3.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s3.Value").WithLocation(28, 17),
                // (30,17): warning CS8629: Nullable value type may be null.
                //             _ = s4.Value; // 8
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s4.Value").WithLocation(30, 17));
        }

        [Fact]
        public void NullableT_NullableTypeParameterStructConstraintToStruct()
        {
            var source =
@"struct S<T> where T : struct
{
    public static implicit operator S<T>(T? t) => throw null;
}
class C<T> where T : struct
{
    // T -> S<T>
    static void F1(T t)
    {
        _ = (S<T>)t;
        S<T> s2 = t;
    }
    // T? -> S<T>?
    static void F2(T? nt)
    {
        if (nt != null)
        {
            var s1 = (S<T>?)nt;
            _ = s1.Value;
            S<T>? s2 = nt;
            _ = s2.Value;
        }
        else
        {
            var s3 = (S<T>?)nt;
            _ = s3.Value;
            S<T>? s4 = nt;
            _ = s4.Value;
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_NullableTypeParameterStructConstraintToNullableStruct()
        {
            var source =
@"struct S<T> where T : struct
{
    public static implicit operator S<T>?(T? t) => throw null;
}
class C<T> where T : struct
{
    // T -> S<T>?
    static void F1(T t)
    {
        var s1 = (S<T>?)t;
        _ = s1.Value; // 1
        S<T>? s2 = t;
        _ = s2.Value; // 2
    }
    // T? -> S<T>?
    static void F2(T? nt)
    {
        if (nt != null)
        {
            var s1 = (S<T>?)nt;
            _ = s1.Value; // 3
            S<T>? s2 = nt;
            _ = s2.Value; // 4
        }
        else
        {
            var s3 = (S<T>?)nt;
            _ = s3.Value; // 5
            S<T>? s4 = nt;
            _ = s4.Value; // 6
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = s1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(11, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = s2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(13, 13),
                // (21,17): warning CS8629: Nullable value type may be null.
                //             _ = s1.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s1.Value").WithLocation(21, 17),
                // (23,17): warning CS8629: Nullable value type may be null.
                //             _ = s2.Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s2.Value").WithLocation(23, 17),
                // (28,17): warning CS8629: Nullable value type may be null.
                //             _ = s3.Value; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s3.Value").WithLocation(28, 17),
                // (30,17): warning CS8629: Nullable value type may be null.
                //             _ = s4.Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s4.Value").WithLocation(30, 17));
        }

        [Fact]
        public void NullableT_ValueTypeConstraint_01()
        {
            var source =
@"abstract class A<T>
{
    internal abstract void F<U>(U x) where U : T;
}
class B1 : A<int>
{
    internal override void F<U>(U x)
    {
        int? y = x;
        _ = y.Value; // 1
        _ = ((int?)x).Value; // 2
    }
}
class B2 : A<int?>
{
    internal override void F<U>(U x)
    {
        int? y = x;
        _ = y.Value; // 3
        _ = ((int?)x).Value; // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // Conversions are not allowed from U to int in B1.F or from U to int? in B2.F,
            // so those conversions are not handled in NullableWalker either.
            comp.VerifyDiagnostics(
                // (9,18): error CS0029: Cannot implicitly convert type 'U' to 'int?'
                //         int? y = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConv, "x").WithArguments("U", "int?").WithLocation(9, 18),
                // (10,13): warning CS8629: Nullable value type may be null.
                //         _ = y.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Value").WithLocation(10, 13),
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = ((int?)x).Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "((int?)x).Value").WithLocation(11, 13),
                // (11,14): error CS0030: Cannot convert type 'U' to 'int?'
                //         _ = ((int?)x).Value; // 2
                Diagnostic(ErrorCode.ERR_NoExplicitConv, "(int?)x").WithArguments("U", "int?").WithLocation(11, 14),
                // (18,18): error CS0029: Cannot implicitly convert type 'U' to 'int?'
                //         int? y = x;
                Diagnostic(ErrorCode.ERR_NoImplicitConv, "x").WithArguments("U", "int?").WithLocation(18, 18),
                // (19,13): warning CS8629: Nullable value type may be null.
                //         _ = y.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Value").WithLocation(19, 13),
                // (20,13): warning CS8629: Nullable value type may be null.
                //         _ = ((int?)x).Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "((int?)x).Value").WithLocation(20, 13),
                // (20,14): error CS0030: Cannot convert type 'U' to 'int?'
                //         _ = ((int?)x).Value; // 4
                Diagnostic(ErrorCode.ERR_NoExplicitConv, "(int?)x").WithArguments("U", "int?").WithLocation(20, 14));
        }

        [Fact]
        public void NullableT_ValueTypeConstraint_02()
        {
            var source =
@"abstract class A<T>
{
    internal abstract void F<U>(T t) where U : T;
}
class B1 : A<int?>
{
    internal override void F<U>(int? t)
    {
        U u = t;
        object? o = u;
        o.ToString(); // 1
    }
}
class B2 : A<int?>
{
    internal override void F<U>(int? t)
    {
        if (t == null) return;
        U u = t;
        object? o = u;
        o.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,15): error CS0029: Cannot implicitly convert type 'int?' to 'U'
                //         U u = t;
                Diagnostic(ErrorCode.ERR_NoImplicitConv, "t").WithArguments("int?", "U").WithLocation(9, 15),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         o.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(11, 9),
                // (19,15): error CS0029: Cannot implicitly convert type 'int?' to 'U'
                //         U u = t;
                Diagnostic(ErrorCode.ERR_NoImplicitConv, "t").WithArguments("int?", "U").WithLocation(19, 15));
        }

        [Fact]
        public void NullableT_ValueTypeConstraint_03()
        {
            var source =
@"abstract class A<T>
{
    internal abstract void F<U>(T t) where U : T;
}
class B1 : A<int?>
{
    internal override void F<U>(int? t)
    {
        U u = (U)(object?)t;
        object? o = u;
        o.ToString(); // 1
    }
}
class B2 : A<int?>
{
    internal override void F<U>(int? t)
    {
        if (t == null) return;
        U u = (U)(object?)t;
        object? o = u;
        o.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         o.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "o").WithLocation(11, 9));
        }

        [Fact]
        public void NullableT_Box()
        {
            var source =
@"class Program
{
    static void F1<T>(T? x1, T? y1) where T : struct
    {
        if (x1 == null) return;
        ((object?)x1).ToString();
        ((object?)y1).ToString(); // 1
    }
    static void F2<T>(T? x2, T? y2) where T : struct
    {
        if (x2 == null) return;
        object? z2 = x2;
        z2.ToString();
        object? w2 = y2;
        w2.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,10): warning CS8602: Possible dereference of a null reference.
                //         ((object?)y1).ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(object?)y1").WithLocation(7, 10),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         w2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "w2").WithLocation(15, 9));
        }

        [Fact]
        public void NullableT_Box_ValueTypeConstraint()
        {
            var source =
@"abstract class A<T>
{
    internal abstract void F<U>(U x) where U : T;
}
class B1 : A<int>
{
    internal override void F<U>(U x)
    {
        ((object?)x).ToString();
        object y = x;
        y.ToString();
    }
}
class B2 : A<int?>
{
    internal override void F<U>(U x)
    {
        ((object?)x).ToString(); // 1
        object? y = x;
        y.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (18,10): warning CS8602: Possible dereference of a null reference.
                //         ((object?)x).ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(object?)x").WithLocation(18, 10),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(20, 9));
        }

        [Fact]
        public void NullableT_Unbox()
        {
            var source =
@"class Program
{
    static void F1<T>(object x1, object? y1) where T : struct
    {
        _ = ((T?)x1).Value;
        _ = ((T?)y1).Value; // 1
    }
    static void F2<T>(object x2, object? y2) where T : struct
    {
        var z2 = (T?)x2;
        _ = z2.Value;
        var w2 = (T?)y2;
        _ = w2.Value; // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8629: Nullable value type may be null.
                //         _ = ((T?)y1).Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "((T?)y1).Value").WithLocation(6, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = w2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "w2.Value").WithLocation(13, 13));
        }

        [Fact]
        public void NullableT_Unbox_ValueTypeConstraint()
        {
            var source =
@"abstract class A<T>
{
    internal abstract void F<U>(object? x) where U : T;
}
class B1 : A<int>
{
    internal override void F<U>(object? x)
    {
        int y = (U)x;
    }
}
class B2 : A<int?>
{
    internal override void F<U>(object? x)
    {
        _ = ((U)x).Value;
        _ = ((int?)(object)(U)x).Value; // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // Conversions are not allowed from U to int in B1.F or from U to int? in B2.F,
            // so those conversions are not handled in NullableWalker either.
            comp.VerifyDiagnostics(
                // (9,17): error CS0029: Cannot implicitly convert type 'U' to 'int'
                //         int y = (U)x;
                Diagnostic(ErrorCode.ERR_NoImplicitConv, "(U)x").WithArguments("U", "int").WithLocation(9, 17),
                // (16,20): error CS1061: 'U' does not contain a definition for 'Value' and no accessible extension method 'Value' accepting a first argument of type 'U' could be found (are you missing a using directive or an assembly reference?)
                //         _ = ((U)x).Value;
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "Value").WithArguments("U", "Value").WithLocation(16, 20),
                // (17,13): warning CS8629: Nullable value type may be null.
                //         _ = ((int?)(object)(U)x).Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "((int?)(object)(U)x).Value").WithLocation(17, 13),
                // (17,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         _ = ((int?)(object)(U)x).Value; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "(object)(U)x").WithLocation(17, 20));
        }

        [Fact]
        public void NullableT_Dynamic()
        {
            var source =
@"class Program
{
    static void F1<T>(dynamic x1, dynamic? y1) where T : struct
    {
        T? z1 = x1;
        _ = z1.Value;
        T? w1 = y1;
        _ = w1.Value; // 1
    }
    static void F2<T>(dynamic x2, dynamic? y2) where T : struct
    {
        var z2 = (T?)x2;
        _ = z2.Value;
        var w2 = (T?)y2;
        _ = w2.Value; // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8629: Nullable value type may be null.
                //         _ = w1.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "w1.Value").WithLocation(8, 13),
                // (15,13): warning CS8629: Nullable value type may be null.
                //         _ = w2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "w2.Value").WithLocation(15, 13));
        }

        [Fact]
        public void NullableT_23()
        {
            var source =
@"#pragma warning disable 649
struct S
{
    internal int F;
}
class Program
{
    static void F(S? x, S? y)
    {
        if (y == null) return;
        int? ni;
        ni = x?.F;
        _ = ni.Value; // 1
        ni = y?.F;
        _ = ni.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = ni.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "ni.Value").WithLocation(13, 13));
        }

        [Fact]
        public void NullableT_24()
        {
            var source =
@"class Program
{
    static void F(bool b, int? x, int? y)
    {
        if ((b ? x : y).HasValue)
        {
            _ = x.Value; // 1
            _ = y.Value; // 2
        }
        if ((b ? x : x).HasValue)
        {
            _ = x.Value; // 3
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,17): warning CS8629: Nullable value type may be null.
                //             _ = x.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "x.Value").WithLocation(7, 17),
                // (8,17): warning CS8629: Nullable value type may be null.
                //             _ = y.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Value").WithLocation(8, 17),
                // (12,17): warning CS8629: Nullable value type may be null.
                //             _ = x.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "x.Value").WithLocation(12, 17));
        }

        [Fact]
        public void NullableT_25()
        {
            var source =
@"class Program
{
    static void F1(int? x)
    {
        var y = ~x;
        _ = y.Value; // 1
    }
    static void F2(int x, int? y)
    {
        var z = x + y;
        _ = z.Value; // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8629: Nullable value type may be null.
                //         _ = y.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Value").WithLocation(6, 13),
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = z.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "z.Value").WithLocation(11, 13));
        }

        [WorkItem(31500, "https://github.com/dotnet/roslyn/issues/31500")]
        [Fact]
        public void NullableT_26()
        {
            var source =
@"class Program
{
    static void F1(int? x)
    {
        if (x == null) return;
        var y = ~x;
        _ = y.Value;
    }
    static void F2(int x, int? y)
    {
        if (y == null) return;
        var z = x + y;
        _ = z.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/31500: Track nullable state across lifted conversions.
            comp.VerifyDiagnostics(
                // (7,13): warning CS8629: Nullable value type may be null.
                //         _ = y.Value;
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Value").WithLocation(7, 13),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = z.Value;
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "z.Value").WithLocation(13, 13));
        }

        [WorkItem(31500, "https://github.com/dotnet/roslyn/issues/31500")]
        [Fact]
        public void NullableT_27()
        {
            var source =
@"struct A
{
    public static implicit operator B(A a) => new B();
}
struct B
{
}
class Program
{
    static void F1(A? a)
    {
        B? b = a;
        _ = b.Value; // 1
    }
    static void F2(A? a)
    {
        if (a != null)
        {
            B? b1 = a;
            _ = b1.Value;
        }
        else
        {
            B? b2 = a;
            _ = b2.Value; // 2
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = b.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "b.Value").WithLocation(13, 13),
                // (25,17): warning CS8629: Nullable value type may be null.
                //             _ = b2.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "b2.Value").WithLocation(25, 17));
        }

        [Fact]
        public void NullableT_28()
        {
            var source =
@"class Program
{
    static void F<T>(T? x, T? y) where T : struct
    {
        object z = x ?? y;
        object? w = x ?? y;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,20): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         object z = x ?? y;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x ?? y").WithLocation(5, 20));
        }

        [Fact]
        public void NullableT_29()
        {
            var source =
@"class Program
{
    static void F<T>(T? t) where T : struct
    {
        if (!t.HasValue) return;
        _ = t ?? default(T);
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): hidden CS8607: Expression is probably never null.
                //         _ = t ?? default(T);
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "t").WithLocation(6, 13));
        }

        [Fact]
        public void NullableT_30()
        {
            var source =
@"class Program
{
    static void F<T>(T? t) where T : struct
    {
        t.HasValue = true;
        t.Value = default(T);
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): error CS0200: Property or indexer 'T?.HasValue' cannot be assigned to -- it is read only
                //         t.HasValue = true;
                Diagnostic(ErrorCode.ERR_AssgReadonlyProp, "t.HasValue").WithArguments("T?.HasValue").WithLocation(5, 9),
                // (6,9): error CS0200: Property or indexer 'T?.Value' cannot be assigned to -- it is read only
                //         t.Value = default(T);
                Diagnostic(ErrorCode.ERR_AssgReadonlyProp, "t.Value").WithArguments("T?.Value").WithLocation(6, 9),
                // (6,9): warning CS8629: Nullable value type may be null.
                //         t.Value = default(T);
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t.Value").WithLocation(6, 9));
        }

        [Fact]
        public void NullableT_31()
        {
            var source =
@"struct S { }
class Program
{
    static void F()
    {
        var s =  (S?)F;
        _ = s.Value; // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,18): error CS0030: Cannot convert type 'method' to 'S?'
                //         var s =  (S?)F;
                Diagnostic(ErrorCode.ERR_NoExplicitConv, "(S?)F").WithArguments("method", "S?").WithLocation(6, 18),
                // (7,13): warning CS8629: Nullable value type may be null.
                //         _ = s.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s.Value").WithLocation(7, 13));
        }

        [Fact]
        public void NullableT_AlwaysTrueOrFalse()
        {
            var source =
@"class Program
{
    static void F1<T>(T? t1) where T : struct
    {
        if (!t1.HasValue) return;
        if (t1.HasValue) { } // always false
        if (!t1.HasValue) { } // always true
        if (t1 != null) { } // always false
        if (t1 == null) { } // always true
    }
    static void F2<T>(T? t2) where T : struct
    {
        if (!t2.HasValue) return;
        if (t2 == null) { } // always false
        if (t2 != null) { } // always true
        if (!t2.HasValue) { } // always false
        if (t2.HasValue) { } // always true
    }
    static void F3<T>(T? t3) where T : struct
    {
        if (t3 == null) return;
        if (!t3.HasValue) { } // always true
        if (t3.HasValue) { } // always false
        if (t3 == null) { } // always true
        if (t3 != null) { } // always false
    }
    static void F4<T>(T? t4) where T : struct
    {
        if (t4 == null) return;
        if (t4 != null) { } // always true
        if (t4 == null) { } // always false
        if (t4.HasValue) { } // always true
        if (!t4.HasValue) { } // always false
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/31516: Report HDN_NullCheckIsProbablyAlwaysTrue/False
            // when HasValue check is unnecessary.
            comp.VerifyDiagnostics(
                // (8,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (t1 != null) { } // always false
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "t1 != null").WithLocation(8, 13),
                // (9,13): hidden CS8606: Result of the comparison is possibly always false.
                //         if (t1 == null) { } // always true
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "t1 == null").WithLocation(9, 13),
                // (14,13): hidden CS8606: Result of the comparison is possibly always false.
                //         if (t2 == null) { } // always false
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "t2 == null").WithLocation(14, 13),
                // (15,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (t2 != null) { } // always true
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "t2 != null").WithLocation(15, 13),
                // (24,13): hidden CS8606: Result of the comparison is possibly always false.
                //         if (t3 == null) { } // always true
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "t3 == null").WithLocation(24, 13),
                // (25,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (t3 != null) { } // always false
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "t3 != null").WithLocation(25, 13),
                // (30,13): hidden CS8605: Result of the comparison is possibly always true.
                //         if (t4 != null) { } // always true
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysTrue, "t4 != null").WithLocation(30, 13),
                // (31,13): hidden CS8606: Result of the comparison is possibly always false.
                //         if (t4 == null) { } // always false
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "t4 == null").WithLocation(31, 13));
        }

        [Fact]
        public void NullableT_As_01()
        {
            var source =
@"class Program
{
    static void F1<T>(object x1, object? y1) where T : struct
    {
        _ = (x1 as T?).Value; // 1
        _ = (y1 as T?).Value; // 2
    }
    static void F2<T>(T x2, T? y2) where T : struct
    {
        _ = (x2 as T?).Value;
        _ = (y2 as T?).Value; // 3
    }
    static void F3<T, U>(U x3) where T : struct
    {
        _ = (x3 as T?).Value; // 4
    }
    static void F4<T, U>(U x4, U? y4) where T : struct where U : class
    {
        _ = (x4 as T?).Value; // 5
        _ = (y4 as T?).Value; // 6
    }
    static void F5<T, U>(U x5, U? y5) where T : struct where U : struct
    {
        _ = (x5 as T?).Value; // 7
        _ = (y5 as T?).Value; // 8
    }
    static void F6<T, U>(U x6) where T : struct, U
    {
        _ = (x6 as T?).Value; // 9
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,13): warning CS8629: Nullable value type may be null.
                //         _ = (x1 as T?).Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(x1 as T?).Value").WithLocation(5, 13),
                // (6,13): warning CS8629: Nullable value type may be null.
                //         _ = (y1 as T?).Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(y1 as T?).Value").WithLocation(6, 13),
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = (y2 as T?).Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(y2 as T?).Value").WithLocation(11, 13),
                // (15,13): warning CS8629: Nullable value type may be null.
                //         _ = (x3 as T?).Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(x3 as T?).Value").WithLocation(15, 13),
                // (19,13): warning CS8629: Nullable value type may be null.
                //         _ = (x4 as T?).Value; // 5
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(x4 as T?).Value").WithLocation(19, 13),
                // (20,13): warning CS8629: Nullable value type may be null.
                //         _ = (y4 as T?).Value; // 6
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(y4 as T?).Value").WithLocation(20, 13),
                // (24,13): warning CS8629: Nullable value type may be null.
                //         _ = (x5 as T?).Value; // 7
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(x5 as T?).Value").WithLocation(24, 13),
                // (25,13): warning CS8629: Nullable value type may be null.
                //         _ = (y5 as T?).Value; // 8
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(y5 as T?).Value").WithLocation(25, 13),
                // (29,13): warning CS8629: Nullable value type may be null.
                //         _ = (x6 as T?).Value; // 9
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(x6 as T?).Value").WithLocation(29, 13));
        }

        [Fact]
        public void NullableT_As_02()
        {
            var source =
@"class Program
{
    static void F1<T>(T? t1) where T : struct
    {
        _ = (t1 as object).ToString(); // 1
        if (t1.HasValue)
            _ = (t1 as object).ToString();
        else
            _ = (t1 as object).ToString(); // 2
    }
    static void F2<T>(T? t2) where T : struct
    {
        _ = (t2 as T?).Value; // 3
        if (t2.HasValue)
            _ = (t2 as T?).Value;
        else
            _ = (t2 as T?).Value; // 4
    }
    static void F3<T, U>(T? t3) where T : struct where U : class
    {
        _ = (t3 as U).ToString(); // 5
        if (t3.HasValue)
            _ = (t3 as U).ToString(); // 6
        else
            _ = (t3 as U).ToString(); // 7
    }
    static void F4<T, U>(T? t4) where T : struct where U : struct
    {
        _ = (t4 as U?).Value; // 8
        if (t4.HasValue)
            _ = (t4 as U?).Value; // 9
        else
            _ = (t4 as U?).Value; // 10
    }
    static void F5<T>(T? t5) where T : struct
    {
        _ = (t5 as dynamic).ToString(); // 11
        if (t5.HasValue)
            _ = (t5 as dynamic).ToString();
        else
            _ = (t5 as dynamic).ToString(); // 12
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,14): warning CS8602: Possible dereference of a null reference.
                //         _ = (t1 as object).ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1 as object").WithLocation(5, 14),
                // (9,18): warning CS8602: Possible dereference of a null reference.
                //             _ = (t1 as object).ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t1 as object").WithLocation(9, 18),
                // (13,13): warning CS8629: Nullable value type may be null.
                //         _ = (t2 as T?).Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(t2 as T?).Value").WithLocation(13, 13),
                // (17,17): warning CS8629: Nullable value type may be null.
                //             _ = (t2 as T?).Value; // 4
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(t2 as T?).Value").WithLocation(17, 17),
                // (21,14): warning CS8602: Possible dereference of a null reference.
                //         _ = (t3 as U).ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t3 as U").WithLocation(21, 14),
                // (23,18): warning CS8602: Possible dereference of a null reference.
                //             _ = (t3 as U).ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t3 as U").WithLocation(23, 18),
                // (25,18): warning CS8602: Possible dereference of a null reference.
                //             _ = (t3 as U).ToString(); // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t3 as U").WithLocation(25, 18),
                // (29,13): warning CS8629: Nullable value type may be null.
                //         _ = (t4 as U?).Value; // 8
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(t4 as U?).Value").WithLocation(29, 13),
                // (31,17): warning CS8629: Nullable value type may be null.
                //             _ = (t4 as U?).Value; // 9
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(t4 as U?).Value").WithLocation(31, 17),
                // (33,17): warning CS8629: Nullable value type may be null.
                //             _ = (t4 as U?).Value; // 10
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(t4 as U?).Value").WithLocation(33, 17),
                // (37,14): warning CS8602: Possible dereference of a null reference.
                //         _ = (t5 as dynamic).ToString(); // 11
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t5 as dynamic").WithLocation(37, 14),
                // (41,18): warning CS8602: Possible dereference of a null reference.
                //             _ = (t5 as dynamic).ToString(); // 12
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t5 as dynamic").WithLocation(41, 18));
        }

        [Fact]
        public void NullableT_As_ValueTypeConstraint_01()
        {
            var source =
@"abstract class A<T>
{
    internal abstract void F<U>(U u) where U : T;
}
class B1 : A<int>
{
    internal override void F<U>(U u)
    {
        _ = (u as U?).Value;
        _ = (u as int?).Value; // 1
    }
}
class B2 : A<int?>
{
    internal override void F<U>(U u)
    {
        _ = (u as int?).Value; // 2
    }
}";
            // Implicit conversions are not allowed from U to int in B1.F or from U to int? in B2.F,
            // so those conversions are not handled in NullableWalker either.
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8629: Nullable value type may be null.
                //         _ = (u as int?).Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(u as int?).Value").WithLocation(10, 13),
                // (17,13): warning CS8629: Nullable value type may be null.
                //         _ = (u as int?).Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(u as int?).Value").WithLocation(17, 13));
        }

        [Fact]
        public void NullableT_As_ValueTypeConstraint_02()
        {
            var source =
@"abstract class A<T>
{
    internal abstract void F<U>(T t) where U : T;
}
class B1 : A<int>
{
    internal override void F<U>(int t)
    {
        _ = (t as U?).Value; // 1
    }
}
class B2 : A<int?>
{
    internal override void F<U>(int? t)
    {
        _ = (t as U).Value; // 2
        _ = (t as U?).Value; // 3
    }
}";
            // Implicit conversions are not allowed from int to U in B1.F or from int? to U in B2.F,
            // so those conversions are not handled in NullableWalker either.
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8629: Nullable value type may be null.
                //         _ = (t as U?).Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(t as U?).Value").WithLocation(9, 13),
                // (16,14): error CS0413: The type parameter 'U' cannot be used with the 'as' operator because it does not have a class type constraint nor a 'class' constraint
                //         _ = (t as U).Value; // 2
                Diagnostic(ErrorCode.ERR_AsWithTypeVar, "t as U").WithArguments("U").WithLocation(16, 14),
                // (17,13): warning CS8629: Nullable value type may be null.
                //         _ = (t as U?).Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(t as U?).Value").WithLocation(17, 13),
                // (17,19): error CS0453: The type 'U' must be a non-nullable value type in order to use it as parameter 'T' in the generic type or method 'Nullable<T>'
                //         _ = (t as U?).Value; // 3
                Diagnostic(ErrorCode.ERR_ValConstraintNotSatisfied, "U?").WithArguments("System.Nullable<T>", "T", "U").WithLocation(17, 19));
        }

        [WorkItem(31501, "https://github.com/dotnet/roslyn/issues/31501")]
        [Fact]
        public void NullableT_Suppress_01()
        {
            var source =
@"class Program
{
    static void F<T>(T x, T? y, T? z) where T : struct
    {
        _ = (T)((T?)null)!;
        _ = (T)((T?)default)!;
        _ = (T)default(T?)!;
        _ = (T)((T?)x)!;
        _ = (T)y!;
        _ = (T)y!!;
        _ = ((T)z)!; // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,14): warning CS8629: Nullable value type may be null.
                //         _ = ((T)z)!; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "(T)z").WithLocation(11, 14));
        }

        [WorkItem(31501, "https://github.com/dotnet/roslyn/issues/31501")]
        [Fact]
        public void NullableT_Suppress_02()
        {
            var source =
@"class Program
{
    static void F<T>(T x, T? y, T? z) where T : struct
    {
        _ = ((T?)null)!.Value;
        _ = ((T?)default)!.Value;
        _ = default(T?)!.Value;
        _ = ((T?)x)!.Value;
        _ = y!.Value;
        _ = y!!.Value;
        _ = z.Value!; // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = z.Value!; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "z.Value").WithLocation(11, 13));
        }

        [Fact]
        public void NullableT_NotNullWhenTrue()
        {
            var source =
@"using System.Runtime.CompilerServices;
class Program
{
    static bool F<T>([NotNullWhenTrue]T? t) where T : struct
    {
        return true;
    }
    static void G<T>(T? t) where T : struct
    {
        if (F(t))
            _ = t.Value;
        else
            _ = t.Value; // 1
    }
}";
            var comp = CreateCompilation(new[] { source, NotNullWhenTrueAttributeDefinition }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,17): warning CS8629: Nullable value type may be null.
                //             _ = t.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t.Value").WithLocation(13, 17));
        }

        [Fact]
        public void NullableT_AssertsTrue()
        {
            var source =
@"using System.Runtime.CompilerServices;
class Program
{
    static void F([AssertsTrue] bool b)
    {
    }
    static void G<T>(T? x, T? y) where T : struct
    {
        F(x != null);
        _ = x.Value;
        F(y.HasValue);
        _ = y.Value;
    }
}";
            var comp = CreateCompilation(new[] { source, AssertsTrueAttributeDefinition }, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_AllMembers()
        {
            var source =
@"class C<T> where T : struct
{
    static void F1(T? t1)
    {
        _ = t1.HasValue;
    }
    static void F2(T? t2)
    {
        _ = t2.Value; // 1
    }
    static void F3(T? t3)
    {
        _ = t3.GetValueOrDefault();
    }
    static void F4(T? t4)
    {
        _ = t4.GetHashCode();
    }
    static void F5(T? t5)
    {
        _ = t5.ToString();
    }
    static void F6(T? t6)
    {
        _ = t6.Equals(t6);
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,13): warning CS8629: Nullable value type may be null.
                //         _ = t2.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t2.Value").WithLocation(9, 13));
        }

        [Fact]
        public void NullableT_Using()
        {
            var source =
@"using System;
struct S : IDisposable
{
    void IDisposable.Dispose() { }
}
class Program
{
    static void F1(S? s)
    {
        using (s) { }
        _ = s.Value; // 1
    }
    static void F2<T>(T? t) where T : struct, IDisposable
    {
        using (t) { }
        _ = t.Value; // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,13): warning CS8629: Nullable value type may be null.
                //         _ = s.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "s.Value").WithLocation(11, 13),
                // (16,13): warning CS8629: Nullable value type may be null.
                //         _ = t.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t.Value").WithLocation(16, 13));
        }

        [WorkItem(31503, "https://github.com/dotnet/roslyn/issues/31503")]
        [Fact]
        public void NullableT_ForEach()
        {
            var source =
@"using System.Collections;
using System.Collections.Generic;
struct S : IEnumerable
{
    public IEnumerator GetEnumerator() => throw null;
}
class Program
{
    static void F1(S? s)
    {
        foreach (var i in s) // 1
            ;
        foreach (var i in s)
            ;
    }
    static void F2<T, U>(T? t) where T : struct, IEnumerable<U>
    {
        foreach (var i in t) // 2
            ;
        foreach (var i in t)
            ;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/31503: Report warning for `.Value.GetEnumerator()` calls.
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void NullableT_IndexAndRange()
        {
            var source =
@"class Program
{
    static void F1(int? x)
    {
        _ = ^x;
    }
    static void F2(int? y)
    {
        _ = ..y;
        _ = ^y..;
    }
    static void F3(int? z, int? w)
    {
        _ = z..^w;
    }
}";
            var comp = CreateCompilationWithIndexAndRange(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [WorkItem(31770, "https://github.com/dotnet/roslyn/issues/31770")]
        [Fact]
        public void UserDefinedConversion_NestedNullability_01()
        {
            var source =
@"class A<T> { }
class B
{
    public static implicit operator B(A<object> a) => throw null;
}
class Program
{
    static void F(B b) { }
    static void Main()
    {
        A<object?> a = new A<object?>();
        B b = a; // 1
        F(a); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/31798: Consider improving warning to reference user-defined operator.
            comp.VerifyDiagnostics(
                // (12,15): warning CS8619: Nullability of reference types in value of type 'A<object?>' doesn't match target type 'A<object>'.
                //         B b = a; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "a").WithArguments("A<object?>", "A<object>").WithLocation(12, 15),
                // (13,11): warning CS8620: Nullability of reference types in argument of type 'A<object?>' doesn't match target type 'A<object>' for parameter 'b' in 'void Program.F(B b)'.
                //         F(a); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "a").WithArguments("A<object?>", "A<object>", "b", "void Program.F(B b)").WithLocation(13, 11));
        }

        [Fact]
        public void UserDefinedConversion_NestedNullability_02()
        {
            var source =
@"class A<T> { }
class B
{
    public static implicit operator A<object>(B b) => throw null;
}
class Program
{
    static void F(A<object?> a) { }
    static void Main()
    {
        B b = new B();
        A<object?> a = b; // 1
        F(b); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/31798: Consider improving warning to reference user-defined operator.
            comp.VerifyDiagnostics(
                // (12,24): warning CS8619: Nullability of reference types in value of type 'A<object>' doesn't match target type 'A<object?>'.
                //         A<object?> a = b; // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "b").WithArguments("A<object>", "A<object?>").WithLocation(12, 24),
                // (13,11): warning CS8620: Nullability of reference types in argument of type 'A<object>' doesn't match target type 'A<object?>' for parameter 'a' in 'void Program.F(A<object?> a)'.
                //         F(b); // 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInArgument, "b").WithArguments("A<object>", "A<object?>", "a", "void Program.F(A<object?> a)").WithLocation(13, 11));
        }

        [WorkItem(31864, "https://github.com/dotnet/roslyn/issues/31864")]
        [Fact]
        public void BestType_DifferentTupleNullability_01()
        {
            var source =
@"using System;
class Program
{
    static void F(bool b)
    {
        DateTime? x = DateTime.MaxValue;
        string? y = null;
        _ = (b ? (x, y) : (null, null))/*T:(System.DateTime?, string?)*/;
        _ = (b ? (null, null) : (x, y))/*T:(System.DateTime?, string?)*/;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [WorkItem(31864, "https://github.com/dotnet/roslyn/issues/31864")]
        [Fact]
        public void BestType_DifferentTupleNullability_02()
        {
            var source =
@"class Program
{
    static void F<T, U>(bool b)
        where T : class, new()
        where U : struct
    {
        T? t1 = null;
        T? t2 = new T();
        U? u1 = null;
        U? u2 = new U();
        _ = (b ? (t1, t2) : (null, null))/*T:(T?, T?)*/;
        _ = (b ? (null, null) : (u1, u2))/*T:(U?, U?)*/;
        _ = (b ? (t1, u2) : (null, null))/*T:(T?, U?)*/;
        _ = (b ? (null, null) : (t2, u1))/*T:(T?, U?)*/;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [WorkItem(31864, "https://github.com/dotnet/roslyn/issues/31864")]
        [Fact]
        public void BestType_DifferentTupleNullability_03()
        {
            var source =
@"class Program
{
    static void F<T, U>()
        where T : class, new()
        where U : struct
    {
        T? t1 = null;
        T? t2 = new T();
        U? u1 = null;
        U? u2 = new U();
        _ = new[] { (t1, t2), (null, null) }[0]/*T:(T?, T?)*/;
        _ = new[] { (null, null), (u1, u2) }[0]/*T:(U?, U?)*/;
        _ = new[] { (t1, u2), (null, null) }[0]/*T:(T?, U?)*/;
        _ = new[] { (null, null), (t2, u1) }[0]/*T:(T?, U?)*/;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        public void BestType_DifferentTupleNullability_04()
        {
            var source =
@"class Program
{
    static void F<T>(bool b)
        where T : class, new()
    {
        _ = (b ? (new T(), new T()) : (null, null))/*T:(T?, T?)*/;
        _ = (b ? (null, new T()) : (new T(), new T()))/*T:(T?, T!)*/;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        public void BestType_DifferentTupleNullability_05()
        {
            var source =
@"class Program
{
    static void F<T>()
        where T : class, new()
    {
        _ = new[] { (new T(), new T()), (null, null) }[0]/*T:(T?, T?)*/;
        _ = new[] { (null, new T()), (new T(), new T()) }[0]/*T:(T?, T!)*/;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        public void BestType_DifferentTupleNullability_06()
        {
            var source =
@"class Program
{
    static void F<T>(bool b, T x, T? y)
        where T : class
    {
        _ = (b ? (x, y) : (y, x))/*T:(T?, T?)*/;
        _ = (b ? (x, x) : (y, default))/*T:(T?, T?)*/;
        _ = (b ? (null, x) : (x, y))/*T:(T?, T?)*/;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        public void BestType_DifferentTupleNullability_07()
        {
            var source =
@"class Program
{
    static void F<T>(T x, T? y)
        where T : class
    {
        _ = new[] { (x, y), (y, x) }[0]/*T:(T?, T?)*/;
        _ = new[] { (x, x), (y, default) }[0]/*T:(T?, T?)*/;
        _ = new[] { (null, x), (x, y) }[0]/*T:(T?, T?)*/;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
            comp.VerifyTypes();
        }

        [Fact]
        public void BestType_DifferentTupleNullability_08()
        {
            var source =
@"class Program
{
    static void F<T>(bool b, T? x, object y)
        where T : class
    {
        var t = (b ? (x: y, y: y) : (x, null))/*T:(object? x, object?)*/;
        var u = (b ? (x: default, y: x) : (x, y))/*T:(T? x, object? y)*/;
        t.x.ToString(); // 1
        t.y.ToString(); // 2
        u.x.ToString(); // 3
        u.y.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.x.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.x").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         t.y.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.y").WithLocation(9, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         u.x.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.x").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         u.y.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.y").WithLocation(11, 9));
            comp.VerifyTypes();
        }

        [Fact]
        public void BestType_DifferentTupleNullability_09()
        {
            var source =
@"class Program
{
    static void F<T>(T? x, object y)
        where T : class
    {
        var t = new[] { (x: y, y: y), (x, null) }[0]/*T:(object? x, object?)*/;
        var u = new[] { (x: default, y: x), (x, y) }[0]/*T:(T? x, object? y)*/;
        t.x.ToString(); // 1
        t.y.ToString(); // 2
        u.x.ToString(); // 3
        u.y.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         t.x.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.x").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         t.y.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.y").WithLocation(9, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         u.x.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.x").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         u.y.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.y").WithLocation(11, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(32575, "https://github.com/dotnet/roslyn/issues/32575")]
        public void BestType_DifferentTupleNullability_10()
        {
            var source =
@"class Program
{
    static void F<T, U>(bool b, T t, U u)
        where U : class
    {
        var x = (b ? (t, u) : default)/*T:(T t, U u)*/;
        x.Item1.ToString(); // 1
        x.Item2.ToString(); // 2
        var y = (b ? default :  (t, u))/*T:(T t, U u)*/;
        y.Item1.ToString(); // 3
        y.Item2.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/32575: Not handling default for U.
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.Item1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.Item1").WithLocation(7, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         y.Item1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.Item1").WithLocation(10, 9));
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(32575, "https://github.com/dotnet/roslyn/issues/32575")]
        public void BestType_DifferentTupleNullability_11()
        {
            var source =
@"class Program
{
    static void F<T, U>(T t, U u)
        where U : class
    {
        var x = new[] { (t, u), default }[0]/*T:(T t, U u)*/;
        x.Item1.ToString(); // 1
        x.Item2.ToString(); // 2
        var y = new[] { default, (t, u) }[0]/*T:(T t, U u)*/;
        y.Item1.ToString(); // 3
        y.Item2.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/32575: Not handling default for U.
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.Item1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x.Item1").WithLocation(7, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         y.Item1.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.Item1").WithLocation(10, 9));
            comp.VerifyTypes();
        }

        [Fact]
        public void BestType_DifferentTupleNullability_12()
        {
            var source =
@"class Program
{
    static void F<U>(bool b, U? u)
        where U : struct
    {
        var t = b ? (t, u) : default;
        t.Item1.ToString();
        _ = t.Item2.Value; // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,22): error CS0841: Cannot use local variable 't' before it is declared
                //         var t = b ? (t, u) : default;
                Diagnostic(ErrorCode.ERR_VariableUsedBeforeDeclaration, "t").WithArguments("t").WithLocation(6, 22),
                // (6,22): error CS0165: Use of unassigned local variable 't'
                //         var t = b ? (t, u) : default;
                Diagnostic(ErrorCode.ERR_UseDefViolation, "t").WithArguments("t").WithLocation(6, 22),
                // (8,13): warning CS8629: Nullable value type may be null.
                //         _ = t.Item2.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t.Item2.Value").WithLocation(8, 13));
        }

        [Fact]
        public void BestType_DifferentTupleNullability_13()
        {
            var source =
@"class Program
{
    static void F<U>(U? u)
        where U : struct
    {
        var t = new[] { (t, u), default }[0];
        t.Item1.ToString();
        _ = t.Item2.Value; // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,26): error CS0841: Cannot use local variable 't' before it is declared
                //         var t = new[] { (t, u), default }[0];
                Diagnostic(ErrorCode.ERR_VariableUsedBeforeDeclaration, "t").WithArguments("t").WithLocation(6, 26),
                // (6,26): error CS0165: Use of unassigned local variable 't'
                //         var t = new[] { (t, u), default }[0];
                Diagnostic(ErrorCode.ERR_UseDefViolation, "t").WithArguments("t").WithLocation(6, 26),
                // (8,13): warning CS8629: Nullable value type may be null.
                //         _ = t.Item2.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "t.Item2.Value").WithLocation(8, 13));
        }

        [WorkItem(32006, "https://github.com/dotnet/roslyn/issues/32006")]
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/32006")]
        public void LambaReturnType_DifferentTupleNullability_01()
        {
            // See https://github.com/dotnet/roslyn/issues/32006
            // need to relax assertion in GetImplicitTupleLiteralConversion

            var source =
@"using System;
class Program
{
    static T F<T>(Func<bool, T> f)
    {
        return f(true);
    }
    static void G<T, U>()
        where T : class, new()
        where U : struct
    {
        F(b =>
            {
                if (b)
                {
                    T? t1 = null;
                    U? u2 = new U();
                    return (t1, u2);
                }
                return (null, null);
            })/*T:(T? t1, U? u2)*/;
        F(b =>
            {
                if (b) return (null, null);
                T? t2 = new T();
                U? u1 = null;
                return (t2, u1);
            })/*T:(T! t2, U? u1)*/;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/32006: Warning inferring return type.
            comp.VerifyDiagnostics(
                // (20,24): warning CS8619: Nullability of reference types in value of type '(T?, U?)' doesn't match target type '(T? t1, U? u2)'.
                //                 return (null, null);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(null, null)").WithArguments("(T?, U?)", "(T? t1, U? u2)").WithLocation(20, 24),
                // (24,31): warning CS8619: Nullability of reference types in value of type '(T?, U?)' doesn't match target type '(T t2, U? u1)'.
                //                 if (b) return (null, null);
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(null, null)").WithArguments("(T?, U?)", "(T t2, U? u1)").WithLocation(24, 31));
            comp.VerifyTypes();
        }

        [WorkItem(32006, "https://github.com/dotnet/roslyn/issues/32006")]
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/32006")]
        public void LambaReturnType_DifferentTupleNullability_02()
        {
            // See https://github.com/dotnet/roslyn/issues/32006
            // need to relax assertion in GetImplicitTupleLiteralConversion
            var source =
@"using System;
class Program
{
    static T F<T>(Func<bool, T> f)
    {
        return f(true);
    }
    static void G<T>()
        where T : class, new()
    {
        F(b => { if (b) return (new T(), new T()); return (null, null); })/*T:(T!, T!)*/;
        F(b => { if (b) return (null, new T()); return (new T(), new T()); })/*T:(T!, T!)*/;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/32006: Warning inferring return type.
            comp.VerifyDiagnostics(
                // (11,59): warning CS8619: Nullability of reference types in value of type '(T?, T?)' doesn't match target type '(T, T)'.
                //         F(b => { if (b) return (new T(), new T()); return (null, null); })/*T:(T!, T!)*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(null, null)").WithArguments("(T?, T?)", "(T, T)").WithLocation(11, 59),
                // (12,32): warning CS8619: Nullability of reference types in value of type '(T?, T)' doesn't match target type '(T, T)'.
                //         F(b => { if (b) return (null, new T()); return (new T(), new T()); })/*T:(T!, T!)*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(null, new T())").WithArguments("(T?, T)", "(T, T)").WithLocation(12, 32));
            comp.VerifyTypes();
        }

        [WorkItem(32006, "https://github.com/dotnet/roslyn/issues/32006")]
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/32006")]
        public void LambaReturnType_DifferentTupleNullability_03()
        {
            // See https://github.com/dotnet/roslyn/issues/32006
            // need to relax assertion in GetImplicitTupleLiteralConversion
            var source =
@"using System;
class Program
{
    static T F<T>(Func<bool, T> f)
    {
        return f(true);
    }
    static void G<T>(T x, T? y)
        where T : class
    {
        F(b => { if (b) return (x, y); return (y, x); })/*T:(T?, T?)*/;
        F(b => { if (b) return (x, x); return (y, default); })/*T:(T!, T!)*/;
        F(b => { if (b) return (null, x); return (x, y); })/*T:(T! x, T? y)*/;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/32006: Warning inferring return type.
            comp.VerifyDiagnostics(
                // (12,47): warning CS8619: Nullability of reference types in value of type '(T? y, T?)' doesn't match target type '(T, T)'.
                //         F(b => { if (b) return (x, x); return (y, default); })/*T:(T?, T?)*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(y, default)").WithArguments("(T? y, T?)", "(T, T)").WithLocation(12, 47),
                // (13,32): warning CS8619: Nullability of reference types in value of type '(T?, T x)' doesn't match target type '(T x, T? y)'.
                //         F(b => { if (b) return (null, x); return (x, y); })/*T:(T?, T?)*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(null, x)").WithArguments("(T?, T x)", "(T x, T? y)").WithLocation(13, 32));
            comp.VerifyTypes();
        }

        [WorkItem(32006, "https://github.com/dotnet/roslyn/issues/32006")]
        [Fact(Skip = "https://github.com/dotnet/roslyn/issues/32006")]
        public void LambaReturnType_DifferentTupleNullability_04()
        {
            // See https://github.com/dotnet/roslyn/issues/32006
            // need to relax assertion in GetImplicitTupleLiteralConversion
            var source =
@"using System;
class Program
{
    static T F<T>(Func<bool, T> f)
    {
        return f(true);
    }
    static void G<T>(T? x, object y)
        where T : class
    {
        F(b => { if (b) return (y, y); return (x, null); })/*T:(object!, object!)*/;
        F(b => { if (b) return (default, x); return (x, y); })/*T:(T? x, object! y)*/;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/32006: Warning inferring return type.
            comp.VerifyDiagnostics(
                // (11,47): warning CS8619: Nullability of reference types in value of type '(object? x, object?)' doesn't match target type '(object, object)'.
                //         F(b => { if (b) return (y, y); return (x, null); })/*T:(object?, object?)*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, null)").WithArguments("(object? x, object?)", "(object, object)").WithLocation(11, 47),
                // (12,32): warning CS8619: Nullability of reference types in value of type '(T?, object? x)' doesn't match target type '(T? x, object y)'.
                //         F(b => { if (b) return (default, x); return (x, y); })/*T:(T?, object?)*/;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(default, x)").WithArguments("(T?, object? x)", "(T? x, object y)").WithLocation(12, 32));
            comp.VerifyTypes();
        }

        [Fact]
        public void DisplayMultidimensionalArray()
        {
            var source = @"
class C
{
    void M(A<object> o, A<string[][][,]?> s)
    {
        o = s;
    }
}
interface A<out T> {}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8619: Nullability of reference types in value of type 'A<string[]?[][*,*]>' doesn't match target type 'A<object>'.
                //         o = s;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "s").WithArguments("A<string[][][*,*]?>", "A<object>").WithLocation(6, 13)
                );
            comp.VerifyTypes();
        }

        [Fact]
        [WorkItem(31862, "https://github.com/dotnet/roslyn/issues/31862")]
        public void Issue31862_01()
        {
            var source =
@"
using System;
using System.Collections;
using System.Collections.Generic;

public class Working<T> : IEnumerable<IEquatable<T>>
{
    public IEnumerator<IEquatable<T>> GetEnumerator() => null;

    IEnumerator IEnumerable.GetEnumerator() => throw null;
}

public class Broken<T> : IEnumerable<IEquatable<T>>
{
    IEnumerator<IEquatable<T>> IEnumerable<IEquatable<T>>.GetEnumerator() => null;

    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,58): warning CS8603: Possible null reference return.
                //     public IEnumerator<IEquatable<T>> GetEnumerator() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(8, 58),
                // (15,78): warning CS8603: Possible null reference return.
                //     IEnumerator<IEquatable<T>> IEnumerable<IEquatable<T>>.GetEnumerator() => null;
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "null").WithLocation(15, 78)
                );
        }

        [Fact]
        [WorkItem(31862, "https://github.com/dotnet/roslyn/issues/31862")]
        public void Issue31862_02()
        {
            var source =
@"
using System;
using System.Collections;
using System.Collections.Generic;

public class Working<T> : IEnumerable<IEquatable<T>>
{
    public IEnumerator<IEquatable<T>?> GetEnumerator() => throw null;

    IEnumerator IEnumerable.GetEnumerator() => throw null;
}

public class Broken<T> : IEnumerable<IEquatable<T>>
{
    IEnumerator<IEquatable<T>?> IEnumerable<IEquatable<T>>.GetEnumerator() => throw null;

    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,40): warning CS8613: Nullability of reference types in return type doesn't match implicitly implemented member 'IEnumerator<IEquatable<T>> IEnumerable<IEquatable<T>>.GetEnumerator()'.
                //     public IEnumerator<IEquatable<T>?> GetEnumerator() => throw null;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation, "GetEnumerator").WithArguments("IEnumerator<IEquatable<T>> IEnumerable<IEquatable<T>>.GetEnumerator()").WithLocation(8, 40),
                // (15,60): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'IEnumerator<IEquatable<T>> IEnumerable<IEquatable<T>>.GetEnumerator()'.
                //     IEnumerator<IEquatable<T>?> IEnumerable<IEquatable<T>>.GetEnumerator() => throw null;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "GetEnumerator").WithArguments("IEnumerator<IEquatable<T>> IEnumerable<IEquatable<T>>.GetEnumerator()").WithLocation(15, 60)
                );
        }

        [Fact]
        [WorkItem(31862, "https://github.com/dotnet/roslyn/issues/31862")]
        public void Issue31862_03()
        {
            var source =
@"
using System;
using System.Collections;
using System.Collections.Generic;

public class Working<T> : IEnumerable<IEquatable<T>>
{
    public IEnumerator<IEquatable<T?>> GetEnumerator() => throw null;

    IEnumerator IEnumerable.GetEnumerator() => throw null;
}

public class Broken<T> : IEnumerable<IEquatable<T>>
{
    IEnumerator<IEquatable<T?>> IEnumerable<IEquatable<T>>.GetEnumerator() => throw null;

    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,35): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     public IEnumerator<IEquatable<T?>> GetEnumerator() => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(8, 35),
                // (8,40): warning CS8613: Nullability of reference types in return type doesn't match implicitly implemented member 'IEnumerator<IEquatable<T>> IEnumerable<IEquatable<T>>.GetEnumerator()'.
                //     public IEnumerator<IEquatable<T?>> GetEnumerator() => throw null;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnImplicitImplementation, "GetEnumerator").WithArguments("IEnumerator<IEquatable<T>> IEnumerable<IEquatable<T>>.GetEnumerator()").WithLocation(8, 40),
                // (15,28): error CS8627: A nullable type parameter must be known to be a value type or non-nullable reference type. Consider adding a 'class', 'struct', or type constraint.
                //     IEnumerator<IEquatable<T?>> IEnumerable<IEquatable<T>>.GetEnumerator() => throw null;
                Diagnostic(ErrorCode.ERR_NullableUnconstrainedTypeParameter, "T?").WithLocation(15, 28),
                // (15,60): warning CS8616: Nullability of reference types in return type doesn't match implemented member 'IEnumerator<IEquatable<T>> IEnumerable<IEquatable<T>>.GetEnumerator()'.
                //     IEnumerator<IEquatable<T?>> IEnumerable<IEquatable<T>>.GetEnumerator() => throw null;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInReturnTypeOnExplicitImplementation, "GetEnumerator").WithArguments("IEnumerator<IEquatable<T>> IEnumerable<IEquatable<T>>.GetEnumerator()").WithLocation(15, 60)
                );
        }

        [Fact]
        [WorkItem(31862, "https://github.com/dotnet/roslyn/issues/31862")]
        public void Issue31862_04()
        {
            var source =
@"
using System;
using System.Collections;
using System.Collections.Generic;

public class Working<T> : IEnumerable<IEquatable<T>>
{
    public IEnumerator<IEquatable<T>>? GetEnumerator() => throw null;

    IEnumerator IEnumerable.GetEnumerator() => throw null;
}

public class Broken<T> : IEnumerable<IEquatable<T>>
{
    IEnumerator<IEquatable<T>>? IEnumerable<IEquatable<T>>.GetEnumerator() => throw null;

    IEnumerator IEnumerable.GetEnumerator() => throw null;
}
";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [WorkItem(30140, "https://github.com/dotnet/roslyn/issues/30140")]
        [Fact]
        public void NullCoalescingAssignment_UseInExpression()
        {
            var source = @"
class C
{
    void M(string? s1, string s2)
    {
        string s3 = (s1 ??= s2);
        string? s4 = null, s5 = null;
        string s6 = (s4 ??= s5); // Warn 1
        s4.ToString(); // Warn 2
    }
}";

            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         string s6 = (s4 ??= s5); // Warn 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "s4 ??= s5").WithLocation(8, 22),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         s4.ToString(); // Warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "s4").WithLocation(9, 9));
        }

        [WorkItem(30140, "https://github.com/dotnet/roslyn/issues/30140")]
        [Fact]
        public void NullCoalescingAssignment_AssignsState()
        {
            var source = @"
class C
{
    object? F = null;
    void M(C? c1, C c2, C c3)
    {
        c1 ??= c2;
        c1.ToString();

        if (c3.F == null) return;

        c1 = null;
        c1 ??= c3;
        c1.F.ToString(); // Warn 1

        c1 = null;
        c1 ??= c3;
        c1.ToString();
        c1.F.ToString(); // Warn 2

        if (c1.F == null) return; // Hidden 3
        c1 ??= c2; // Hidden 4
        c1.F.ToString(); // Warn 5

        // We could support this in the future if MakeSlot is made smarter to understand
        // that the slot of a ??= is the slot of the left-hand side. https://github.com/dotnet/roslyn/issues/32501
        (c1 ??= c3).F.ToString(); // Warn 6, Hidden 7
    }
}";

            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         c1.F.ToString(); // Warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1.F").WithLocation(14, 9),
                // (19,9): warning CS8602: Possible dereference of a null reference.
                //         c1.F.ToString(); // Warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1.F").WithLocation(19, 9),
                // (21,13): hidden CS8606: Result of the comparison is possibly always false.
                //         if (c1.F == null) return; // Hidden 3
                Diagnostic(ErrorCode.HDN_NullCheckIsProbablyAlwaysFalse, "c1.F == null").WithLocation(21, 13),
                // (22,9): hidden CS8607: Expression is probably never null.
                //         c1 ??= c2; // Hidden 4
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c1").WithLocation(22, 9),
                // (23,9): warning CS8602: Possible dereference of a null reference.
                //         c1.F.ToString(); // Warn 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1.F").WithLocation(23, 9),
                // (27,9): warning CS8602: Possible dereference of a null reference.
                //         (c1 ??= c3).F.ToString(); // Warn 6, Hidden 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "(c1 ??= c3).F").WithLocation(27, 9),
                // (27,10): hidden CS8607: Expression is probably never null.
                //         (c1 ??= c3).F.ToString(); // Warn 6, Hidden 7
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c1").WithLocation(27, 10));
        }

        [WorkItem(30140, "https://github.com/dotnet/roslyn/issues/30140")]
        [Fact]
        public void NullCoalescingAssignment_RightStateValidInRightOnly()
        {
            var source = @"
class C
{
    C GetC(C c) => c;
    void M(C? c1, C? c2, C c3)
    {
        c1 ??= (c2 = c3);
        c1.ToString();
        c2.ToString(); // Warn 1

        c1 = null;
        c2 = null;
        c1 ??= (c2 = c3).GetC(c2);
        c1.ToString();
        c2.ToString(); // Warn 2

        c1 = null;
        c2 = null;
        c1 ??= (c2 = c3).GetC(c1); // Warn 3
        c1.ToString();
    }
}";

            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         c2.ToString(); // Warn 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(9, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         c2.ToString(); // Warn 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c2").WithLocation(15, 9),
                // (19,31): warning CS8604: Possible null reference argument for parameter 'c' in 'C C.GetC(C c)'.
                //         c1 ??= (c2 = c3).GetC(c1); // Warn 3
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "c1").WithArguments("c", "C C.GetC(C c)").WithLocation(19, 31));
        }

        [WorkItem(30140, "https://github.com/dotnet/roslyn/issues/30140")]
        [Fact]
        public void NullCoalescingAssignment_Contravariant()
        {
            var source = @"
class C
{
#nullable disable
    C GetC() => null;
#nullable enable
    void M(C? c1, C c2)
    {
        // nullable + oblivious = oblivious
#nullable disable
        C c3
#nullable enable
                  = (c1 ??= GetC());
        _ = c1/*T:C*/;
        _ = c3/*T:C*/;

        // oblivious + nullable = nullable
        // This one is a little weirder. The ??= on c3 forces it into either nullable or not nullable, so we must
        // pick the nullable version, meaning the resulting expression is actually nullable + nullable = nullable.
        c1 = null;
        var c4 = (c3 ??= c1);
        _ = c3/*T:C?*/;
        _ = c4/*T:C?*/;

        // oblivious + not nullable = not nullable
        c3 = GetC();
        var c5 = (c3 ??= c2);
        _ = c3/*T:C!*/;
        _ = c5/*T:C!*/;

        // not nullable + oblivious = not nullable
        var c6 = (c2 ??= GetC());
        _ = c2/*T:C!*/;
        _ = c6/*T:C!*/;
    }
}";

            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (30,19): hidden CS8607: Expression is probably never null.
                //         var c6 = (c2 ??= GetC());
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c2").WithLocation(32, 19));
            comp.VerifyTypes();
        }

        [WorkItem(30140, "https://github.com/dotnet/roslyn/issues/30140")]
        [Fact]
        public void NullCoalescingAssignment_LeftNotTracked()
        {
            var source = @"
class C
{
    void M(C?[] c1, C c2)
    {
        c1[0] ??= c2;
        c1[0].ToString(); // Warn
    }
}";

            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         c1[0].ToString(); // Warn
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c1[0]").WithLocation(7, 9));
        }

        [WorkItem(30140, "https://github.com/dotnet/roslyn/issues/30140")]
        [Fact]
        public void NullCoalescingAssignment_RefReturn()
        {
            var source = @"
class C
{
    void M1(C c1, C? c2)
    {
        M2(c1) ??= c2; // Warn 1, 2
        M2(c1).ToString();

        M2(c2) ??= c1;
        M2(c2).ToString(); // Warn 3
    }

    ref T M2<T>(T t) => throw null;
}";

            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): hidden CS8607: Expression is probably never null.
                //         M2(c1) ??= c2; // Warn 1, 2
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "M2(c1)").WithLocation(6, 9),
                // (6,20): warning CS8601: Possible null reference assignment.
                //         M2(c1) ??= c2; // Warn 1, 2
                Diagnostic(ErrorCode.WRN_NullReferenceAssignment, "c2").WithLocation(6, 20),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         M2(c2).ToString(); // Warn 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "M2(c2)").WithLocation(10, 9));
        }

        [WorkItem(30140, "https://github.com/dotnet/roslyn/issues/30140")]
        [Fact]
        public void NullCoalescingAssignment_NestedLHS()
        {
            var source = @"
class C
{
    object? F = null;
    void M1(C c1, object f)
    {
        c1.F ??= f;
        c1.F.ToString();
    }
}";

            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [WorkItem(30140, "https://github.com/dotnet/roslyn/issues/30140")]
        [Fact]
        public void NullCoalescingAssignment_Conversions()
        {
            var source = @"
class C<T>
{
    void M1(C<object>? c1, C<object?> c2, C<object?> c3, C<object>? c4)
    {
        c1 ??= c2;
        c3 ??= c4;
    }
}";

            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,16): warning CS8619: Nullability of reference types in value of type 'C<object?>' doesn't match target type 'C<object>'.
                //         c1 ??= c2;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c2").WithArguments("C<object?>", "C<object>").WithLocation(6, 16),
                // (7,9): hidden CS8607: Expression is probably never null.
                //         c3 ??= c4;
                Diagnostic(ErrorCode.HDN_ExpressionIsProbablyNeverNull, "c3").WithLocation(7, 9),
                // (7,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         c3 ??= c4;
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "c4").WithLocation(7, 16),
                // (7,16): warning CS8619: Nullability of reference types in value of type 'C<object>' doesn't match target type 'C<object?>'.
                //         c3 ??= c4;
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "c4").WithArguments("C<object>", "C<object?>").WithLocation(7, 16));
        }

        [WorkItem(30140, "https://github.com/dotnet/roslyn/issues/30140")]
        [Fact]
        public void NullCoalescingAssignment_LeftStillNullableOnRight()
        {
            var source = @"
class C
{
    void M1(C? c1)
    {
        c1 ??= M2(c1);
        c1.ToString();
    }

    C M2(C c1) => throw null;
}";

            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,19): warning CS8604: Possible null reference argument for parameter 'c1' in 'C C.M2(C c1)'.
                //         c1 ??= M2(c1);
                Diagnostic(ErrorCode.WRN_NullReferenceArgument, "c1").WithArguments("c1", "C C.M2(C c1)").WithLocation(6, 19));
        }

        [WorkItem(32503, "https://github.com/dotnet/roslyn/issues/32503")]
        [Fact]
        public void PatternDeclarationBreaksNullableAnalysis()
        {
            var source = @"
#nullable enable
class A { }
class B : A
{
    A M()
    {
        var s = new A();
        if (s is B b) {}
        return s; 
    }
} 
";
            var comp = CreateCompilation(source);
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Deconstruction_01()
        {
            var source =
@"class Program
{
    static void F<T, U>() where U : class
    {
        (T x, U y) = default((T, U)); // 1
        x.ToString(); // 2
        y.ToString(); // 3
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (T x, U y) = default((T, U)); // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default((T, U))").WithLocation(5, 22),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(7, 9));
        }

        [Fact]
        public void Deconstruction_02()
        {
            var source =
@"class Program
{
    static void F<T, U>() where U : class
    {
        (T x, U y) = (default, default); // 1, 2
        x.ToString(); // 3
        y.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (T x, U y) = (default, default); // 1, 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(5, 23),
                // (5,32): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (T x, U y) = (default, default); // 1, 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(5, 32),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(7, 9));
        }

        [Fact]
        public void Deconstruction_03()
        {
            var source =
@"class Program
{
    static void F<T>() where T : class, new()
    {
        (T x, T? y) = (null, new T()); // 1
        x.ToString(); // 2
        y.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,24): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (T x, T? y) = (null, new T()); // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(5, 24),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 9));
        }

        [Fact]
        public void Deconstruction_04()
        {
            var source =
@"class Program
{
    static void F<T>(T x, T? y) where T : class
    {
        (T a, T? b) = (x, y);
        a.ToString();
        b.ToString(); // 1
        (a, b) = (y, x); // 2
        a.ToString(); // 3
        b.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         b.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b").WithLocation(7, 9),
                // (8,19): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (a, b) = (y, x); // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "y").WithLocation(8, 19),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(9, 9));
        }

        [Fact]
        public void Deconstruction_05()
        {
            var source =
@"class Program
{
    static void F<T>((T, T?) t) where T : class
    {
        (T a, T? b) = t;
        a.ToString();
        b.ToString(); // 1
        (b, a) = t; // 2
        a.ToString(); // 3
        b.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         b.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b").WithLocation(7, 9),
                // (8,18): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (b, a) = t; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(8, 18),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(9, 9));
        }

        [Fact]
        public void Deconstruction_06()
        {
            var source =
@"class Program
{
    static void F<T>() where T : class, new()
    {
        (T, T?) t = (default, new T()); // 1
        (T a, T? b) = t; // 2
        a.ToString(); // 3
        b.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,21): warning CS8619: Nullability of reference types in value of type '(T?, T)' doesn't match target type '(T, T?)'.
                //         (T, T?) t = (default, new T()); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(default, new T())").WithArguments("(T?, T)", "(T, T?)").WithLocation(5, 21),
                // (6,23): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (T a, T? b) = t; // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(6, 23),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(7, 9));
        }

        [Fact]
        public void Deconstruction_07()
        {
            var source =
@"class Program
{
    static void F<T, U>() where U : class
    {
        var (x, y) = default((T, U));
        x.ToString(); // 1
        y.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(6, 9),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(7, 9));
        }

        [Fact]
        public void Deconstruction_08()
        {
            var source =
@"class Program
{
    static void F<T>() where T : class, new()
    {
        T x = default; // 1
        T? y = new T();
        var (a, b) = (x, y);
        a.ToString(); // 2
        b.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,15): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         T x = default; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "default").WithLocation(5, 15),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(8, 9));
        }

        [Fact]
        public void Deconstruction_09()
        {
            var source =
@"class Program
{
    static void F<T>() where T : class, new()
    {
        (T, T?) t = (default, new T()); // 1
        var (a, b) = t;
        a.ToString(); // 2
        b.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,21): warning CS8619: Nullability of reference types in value of type '(T?, T)' doesn't match target type '(T, T?)'.
                //         (T, T?) t = (default, new T()); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(default, new T())").WithArguments("(T?, T)", "(T, T?)").WithLocation(5, 21),
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(7, 9));
        }

        [Fact]
        public void Deconstruction_10()
        {
            var source =
@"class Program
{
    static void F<T>((T, T?) t) where T : class
    {
        if (t.Item2 == null) return;
        t.Item1 = null; // 1
        var (a, b) = t;
        a.ToString(); // 2
        b.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         t.Item1 = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 19),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(8, 9));
        }

        [Fact]
        public void Deconstruction_11()
        {
            var source =
@"class Program
{
    static void F(object? x, object y, string? z)
    {
        ((object? a, object? b), string? c) = ((x, y), z);
        a.ToString(); // 1
        b.ToString();
        c.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(6, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(8, 9));
        }

        [Fact]
        public void Deconstruction_12()
        {
            var source =
@"class Program
{
    static void F((object?, object) x, string? y)
    {
        ((object? a, object? b), string? c) = (x, y);
        a.ToString(); // 1
        b.ToString();
        c.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(6, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(8, 9));
        }

        [Fact]
        public void Deconstruction_13()
        {
            var source =
@"class Program
{
    static void F(((object?, object), string?) t)
    {
        ((object? a, object? b), string? c) = t;
        a.ToString(); // 1
        b.ToString();
        c.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(6, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(8, 9));
        }

        [Fact]
        public void Deconstruction_14()
        {
            var source =
@"class Program
{
    static void F(object? x, string y, (object, string?) z)
    {
        ((object?, object?) a, (object? b, object? c)) = ((x, y), z);
        a.Item1.ToString(); // 1
        a.Item2.ToString();
        b.ToString();
        c.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         a.Item1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.Item1").WithLocation(6, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(9, 9));
        }

        [Fact]
        public void Deconstruction_15()
        {
            var source =
@"class Program
{
    static void F((object?, string) x, object y, string? z)
    {
        ((object a, object b), (object x, object y) c) = (x, (y, z)); // 1, 2
        a.ToString(); // 3
        b.ToString();
        c.x.ToString();
        c.y.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,59): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         ((object a, object b), (object x, object y) c) = (x, (y, z)); // 1, 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(5, 59),
                // (5,62): warning CS8619: Nullability of reference types in value of type '(object y, object? z)' doesn't match target type '(object x, object y)'.
                //         ((object a, object b), (object x, object y) c) = (x, (y, z)); // 1, 2
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(y, z)").WithArguments("(object y, object? z)", "(object x, object y)").WithLocation(5, 62),
                // (6,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(6, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         c.y.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c.y").WithLocation(9, 9));
        }

        [Fact]
        public void Deconstruction_16()
        {
            var source =
@"class Program
{
    static void F<T, U>(T t, U? u) where U : class
    {
        T x;
        U y;
        (x, _) = (t, u);
        (_, y) = (t, u); // 1
        (x, _, (_, y)) = (t, t, (u, u)); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,22): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (_, y) = (t, u); // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u").WithLocation(8, 22),
                // (9,37): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (x, _, (_, y)) = (t, t, (u, u)); // 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "u").WithLocation(9, 37));
        }

        [Fact]
        public void Deconstruction_17()
        {
            var source =
@"class Pair<T, U> where U : class
{
    internal void Deconstruct(out T t, out U? u) => throw null;
}
class Program
{
    static void F<T, U>() where U : class
    {
        var (t, u) = new Pair<T, U>();
        t.ToString(); // 1
        u.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         t.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         u.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u").WithLocation(11, 9));
        }

        [Fact]
        public void Deconstruction_18()
        {
            var source =
@"class Pair<T, U>
{
    internal void Deconstruct(out T t, out U u) => throw null;
}
class Program
{
    static void F<T>() where T : class
    {
        (T x1, T y1) = new Pair<T, T?>(); // 1
        x1.ToString();
        y1.ToString(); // 2
        (T? x2, T? y2) = new Pair<T, T?>();
        x2.ToString();
        y2.ToString(); // 3
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,16): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (T x1, T y1) = new Pair<T, T?>(); // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "T y1").WithLocation(9, 16),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         y1.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y1").WithLocation(11, 9),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         y2.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y2").WithLocation(14, 9));
        }

        [Fact]
        public void Deconstruction_19()
        {
            var source =
@"class Pair<T, U>
{
    internal void Deconstruct(out T t, out U u) => throw null;
}
class Program
{
    static void F<T, U>() where U : class
    {
        (T, U?) t = new Pair<T, U?>();
        t.Item1.ToString(); // 1
        t.Item2.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,21): error CS0029: Cannot implicitly convert type 'Pair<T, U?>' to '(T, U?)'
                //         (T, U?) t = new Pair<T, U?>();
                Diagnostic(ErrorCode.ERR_NoImplicitConv, "new Pair<T, U?>()").WithArguments("Pair<T, U?>", "(T, U?)").WithLocation(9, 21),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item1.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item1").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         t.Item2.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.Item2").WithLocation(11, 9));
        }

        [Fact]
        public void Deconstruction_TupleAndDeconstruct()
        {
            var source =
@"class Pair<T, U>
{
    internal void Deconstruct(out T t, out U u) => throw null;
}
class Program
{
    static void F<T>(T? x, Pair<T, T?> y) where T : class
    {
        (T a, (T? b, T? c)) = (x, y); // 1
        a.ToString(); // 2
        b.ToString();
        c.ToString(); // 3
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,32): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (T a, (T? b, T? c)) = (x, y); // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "x").WithLocation(9, 32),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(10, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(12, 9));
        }

        [Fact]
        [WorkItem(33005, "https://github.com/dotnet/roslyn/issues/33005")]
        public void Deconstruction_DeconstructAndTuple()
        {
            var source =
@"class Pair<T, U>
{
    internal void Deconstruct(out T t, out U u) => throw null;
}
class Program
{
    static void F<T>(Pair<T?, (T, T?)> p) where T : class
    {
        (T a, (T? b, T? c)) = p; // 1
        a.ToString(); // 2
        b.ToString();
        c.ToString(); // 3
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33005: Not handling deconstructing argument of Deconstruct.
            comp.VerifyDiagnostics(
                // (9,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (T a, (T? b, T? c)) = p; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "T a").WithLocation(9, 10),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(10, 9));
        }

        [Fact]
        [WorkItem(33005, "https://github.com/dotnet/roslyn/issues/33005")]
        public void Deconstruction_DeconstructAndDeconstruct()
        {
            var source =
@"class Pair<T, U>
{
    internal void Deconstruct(out T t, out U u) => throw null;
}
class Program
{
    static void F<T>(Pair<T?, Pair<T, T?>> p) where T : class
    {
        (T a, (T? b, T? c)) = p; // 1
        a.ToString(); // 2
        b.ToString();
        c.ToString(); // 3
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33005: Not handling deconstructing argument of Deconstruct.
            comp.VerifyDiagnostics(
                // (9,10): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (T a, (T? b, T? c)) = p; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "T a").WithLocation(9, 10),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(10, 9));
        }

        [Fact]
        public void Deconstruction_20()
        {
            var source =
@"class Pair<T, U>
{
    internal void Deconstruct(out T t, out U u) => throw null;
}
class Program
{
    static void F1(Pair<object, object>? p1)
    {
        var (x, y) = p1; // 1
        (x, y) = p1;
    }
    static void F2(Pair<object, object>? p2)
    {
        if (p2 == null) return;
        var (x, y) = p2;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,22): warning CS8602: Possible dereference of a null reference.
                //         var (x, y) = p1; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "p1").WithLocation(9, 22));
        }

        [Fact]
        [WorkItem(33011, "https://github.com/dotnet/roslyn/issues/33011")]
        public void Deconstruction_21()
        {
            var source =
@"class Program
{
    static void F<T, U>((T, U) t) where U : struct
    {
        object? x;
        object? y;
        var u = ((x, y) = t);
        u.x.ToString(); // 1
        u.y.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33011: Should warn for `u.x` only.
            comp.VerifyDiagnostics(
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         u.x.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.x").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         u.y.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "u.y").WithLocation(9, 9));
        }

        [Fact]
        [WorkItem(33011, "https://github.com/dotnet/roslyn/issues/33011")]
        public void Deconstruction_22()
        {
            var source =
@"class Pair<T, U>
{
    internal void Deconstruct(out T t, out U u) => throw null;
}
class Program
{
    static void F(Pair<object, object?> p)
    {
        object? x;
        object? y;
        var t = ((x, y) = p);
        t.x.ToString();
        t.y.ToString(); // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33011: Should warn for `t.y` only.
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         t.x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.x").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         t.y.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.y").WithLocation(13, 9));
        }

        // As above, but with struct type.
        [Fact]
        [WorkItem(33011, "https://github.com/dotnet/roslyn/issues/33011")]
        public void Deconstruction_23()
        {
            var source =
@"struct Pair<T, U>
{
    internal void Deconstruct(out T t, out U u) => throw null;
}
class Program
{
    static void F(Pair<object, object?> p)
    {
        object? x;
        object? y;
        var t = ((x, y) = p);
        t.x.ToString();
        t.y.ToString(); // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33011: Should warn for `t.y` only.
            comp.VerifyDiagnostics(
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         t.x.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.x").WithLocation(12, 9),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         t.y.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "t.y").WithLocation(13, 9));
        }

        [Fact]
        public void Deconstruction_24()
        {
            var source =
@"class Program
{
    static void F(bool b, object x, object? y)
    {
        (object?, object, object?, object, object?, (object, object?), object, object, object?, object) t = (x, x, x, y, y, (y, x), x, x, y, y); // 1
        var (_1, _2, _3, _4, _5, (_6a, _6b), _7, _8, _9, _10) = t;
        _1.ToString();
        _2.ToString();
        _3.ToString();
        _4.ToString(); // 2
        _5.ToString(); // 3
        _6a.ToString(); // 4
        _6b.ToString();
        _7.ToString();
        _8.ToString();
        _9.ToString(); // 5
        _10.ToString(); // 6
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,109): warning CS8619: Nullability of reference types in value of type '(object, object, object, object?, object?, (object? y, object x), object, object, object?, object?)' doesn't match target type '(object?, object, object?, object, object?, (object, object?), object, object, object?, object)'.
                //         (object?, object, object?, object, object?, (object, object?), object, object, object?, object) t = (x, x, x, y, y, (y, x), x, x, y, y); // 1
                Diagnostic(ErrorCode.WRN_NullabilityMismatchInAssignment, "(x, x, x, y, y, (y, x), x, x, y, y)").WithArguments("(object, object, object, object?, object?, (object? y, object x), object, object, object?, object?)", "(object?, object, object?, object, object?, (object, object?), object, object, object?, object)").WithLocation(5, 109),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         _4.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "_4").WithLocation(10, 9),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         _5.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "_5").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         _6a.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "_6a").WithLocation(12, 9),
                // (16,9): warning CS8602: Possible dereference of a null reference.
                //         _9.ToString(); // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "_9").WithLocation(16, 9),
                // (17,9): warning CS8602: Possible dereference of a null reference.
                //         _10.ToString(); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "_10").WithLocation(17, 9));
        }

        [Fact]
        [WorkItem(33017, "https://github.com/dotnet/roslyn/issues/33017")]
        public void Deconstruction_25()
        {
            var source =
@"using System.Collections.Generic;
class Program
{
    static void F1<T>(IEnumerable<(T, T)> e1)
    {
        foreach (var (x1, y1) in e1)
        {
            x1.ToString(); // 1
            y1.ToString(); // 2
        }
        foreach ((object? z1, object? w1) in e1)
        {
            z1.ToString(); // 3
            z1.ToString(); // 4
        }
    }
    static void F2<T>(IEnumerable<(T, T?)> e2) where T : class
    {
        foreach (var (x2, y2) in e2)
        {
            x2.ToString();
            y2.ToString(); // 5
        }
        foreach ((object? z2, object? w2) in e2)
        {
            z2.ToString();
            z2.ToString(); // 6
        }
    }
    static void F3<T>(IEnumerable<(T, T?)> e3) where T : struct
    {
        foreach (var (x3, y3) in e3)
        {
            x3.ToString();
            _ = y3.Value; // 7
        }
        foreach ((object? z3, object? w3) in e3)
        {
            z3.ToString();
            z3.ToString(); // 8
        }
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33017: Report warnings.
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Deconstruction_26()
        {
            var source =
@"class Program
{
    static void F(bool c, object? a, object? b)
    {
        if (b == null) return;
        var (x, y, z, w) = c ? (a, b, a, b) : (a, a, b, b);
        x.ToString(); // 1
        y.ToString(); // 2
        z.ToString(); // 3
        w.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         x.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x").WithLocation(7, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(8, 9),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         z.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z").WithLocation(9, 9));
        }

        [Fact]
        [WorkItem(33019, "https://github.com/dotnet/roslyn/issues/33019")]
        public void Deconstruction_27()
        {
            var source =
@"class Program
{
    static void F(object? x, object y)
    {
        if (x == null) return;
        y = null; // 1
        var t = (new[] { x }, new[] { y });
        var (ax, ay) = t;
        ax[0].ToString();
        ay[0].ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33019: Inferred nullability of implicitly-typed
            // deconstruction variables should be recorded in NullableWalker._variableTypes.
            comp.VerifyDiagnostics(
                // (6,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = null; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(6, 13));
        }

        [Fact]
        public void Deconstruction_ExtensionMethod_01()
        {
            var source =
@"class Pair<T, U>
{
}
static class E
{
    internal static void Deconstruct(this Pair<object?, object>? p, out object x, out object? y) => throw null;
}
class Program
{
    static void F(Pair<object, object?>? p)
    {
        (object? x, object? y) = p;
        x.ToString();
        y.ToString(); // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(14, 9));
        }

        [Fact]
        [WorkItem(33006, "https://github.com/dotnet/roslyn/issues/33006")]
        public void Deconstruction_ExtensionMethod_02()
        {
            var source =
@"struct Pair<T, U>
{
}
static class E
{
    internal static void Deconstruct<T, U>(this Pair<T, U> p, out T t, out U u) => throw null;
}
class Program
{
    static void F<T, U>(Pair<T, U> p) where U : class
    {
        var (x, y) = p;
        x.ToString(); // 1
        y.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33006: Infer nullability of type arguments.
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(33006, "https://github.com/dotnet/roslyn/issues/33006")]
        public void Deconstruction_ExtensionMethod_03()
        {
            var source =
@"class Pair<T, U>
{
}
static class E
{
    internal static void Deconstruct<T, U>(this Pair<T, U> p, out T t, out U u) => throw null;
}
class Program
{
    static void F(Pair<object?, object>? p)
    {
        (object? x, object? y) = p; // 1
        x.ToString(); // 2
        y.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33006: Check nullability of `this`
            // for generic `Deconstruct` method and infer nullability of type arguments.
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(33006, "https://github.com/dotnet/roslyn/issues/33006")]
        public void Deconstruction_ExtensionMethod_ConstraintWarning()
        {
            var source =
@"class Pair<T, U> where T : class?
{
}
static class E
{
    internal static void Deconstruct<T, U>(this Pair<T, U> p, out T t, out U u)
        where T : class
        => throw null;
}
class Program
{
    static void F(Pair<object, object?> p)
    {
        var (x, y) = p; // 1
        x.ToString();
        y.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33006: Check nullability constraints
            // for generic `Deconstruct` method.
            comp.VerifyDiagnostics();
        }

        [Fact]
        public void Deconstruction_EvaluationOrder_01()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class C
{
    internal object F;
}
class Program
{
    static void F0(C? x0, C? y0)
    {
        (x0.F, // 1
            x0.F) =
                (y0.F, // 2
                    y0.F);
    }
    static void F1(C? x1, C? y1)
    {
        (x1.F, // 3
            _) =
                (y1.F, // 4
                    x1.F);
    }
    static void F2(C? x2, C? y2)
    {
        (_,
            y2.F) = // 5
                (y2.F,
                    x2.F); // 6
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,10): warning CS8602: Possible dereference of a null reference.
                //         (x0.F, // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x0").WithLocation(11, 10),
                // (13,18): warning CS8602: Possible dereference of a null reference.
                //                 (y0.F, // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(13, 18),
                // (18,10): warning CS8602: Possible dereference of a null reference.
                //         (x1.F, // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(18, 10),
                // (20,18): warning CS8602: Possible dereference of a null reference.
                //                 (y1.F, // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y1").WithLocation(20, 18),
                // (26,13): warning CS8602: Possible dereference of a null reference.
                //             y2.F) = // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y2").WithLocation(26, 13),
                // (28,21): warning CS8602: Possible dereference of a null reference.
                //                     x2.F); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(28, 21));
        }

        [Fact]
        public void Deconstruction_EvaluationOrder_02()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class C
{
    internal object F;
}
class Program
{
    static void F0(C? x0, C? y0, C? z0)
    {
        ((x0.F, // 1
            y0.F), // 2
                z0.F) = // 3
                    ((y0.F,
                        z0.F),
                            x0.F);
    }
    static void F1(C? x1, C? y1, C? z1)
    {
        ((x1.F, // 4
             _),
                x1.F) =
                    ((y1.F, // 5
                        z1.F), // 6
                            z1.F);
    }
    static void F2(C? x2, C? y2, C? z2)
    {
        ((_,
            _),
                x2.F) = // 7
                    ((x2.F,
                        y2.F), // 8
                            z2.F); // 9
    }
    static void F3(C? x3, C? y3, C? z3)
    {
        (x3.F, // 10
            (x3.F,
                y3.F)) = // 11
                    (y3.F,
                        (z3.F, // 12
                            x3.F));
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,11): warning CS8602: Possible dereference of a null reference.
                //         ((x0.F, // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x0").WithLocation(11, 11),
                // (12,13): warning CS8602: Possible dereference of a null reference.
                //             y0.F), // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(12, 13),
                // (13,17): warning CS8602: Possible dereference of a null reference.
                //                 z0.F) = // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z0").WithLocation(13, 17),
                // (20,11): warning CS8602: Possible dereference of a null reference.
                //         ((x1.F, // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(20, 11),
                // (23,23): warning CS8602: Possible dereference of a null reference.
                //                     ((y1.F, // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y1").WithLocation(23, 23),
                // (24,25): warning CS8602: Possible dereference of a null reference.
                //                         z1.F), // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z1").WithLocation(24, 25),
                // (31,17): warning CS8602: Possible dereference of a null reference.
                //                 x2.F) = // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(31, 17),
                // (33,25): warning CS8602: Possible dereference of a null reference.
                //                         y2.F), // 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y2").WithLocation(33, 25),
                // (34,29): warning CS8602: Possible dereference of a null reference.
                //                             z2.F); // 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z2").WithLocation(34, 29),
                // (38,10): warning CS8602: Possible dereference of a null reference.
                //         (x3.F, // 10
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x3").WithLocation(38, 10),
                // (40,17): warning CS8602: Possible dereference of a null reference.
                //                 y3.F)) = // 11
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y3").WithLocation(40, 17),
                // (42,26): warning CS8602: Possible dereference of a null reference.
                //                         (z3.F, // 12
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "z3").WithLocation(42, 26));
        }

        [Fact]
        public void Deconstruction_EvaluationOrder_03()
        {
            var source =
@"#pragma warning disable 8618
class Pair<T, U>
{
    internal void Deconstruct(out T t, out U u) => throw null;
    internal T First;
    internal U Second;
}
class Program
{
    static void F0(Pair<object, object>? p0)
    {
        (_,
            _) =
                p0; // 1
    }
    static void F1(Pair<object, object>? p1)
    {
        (_,
            p1.Second) = // 2
                p1;
    }
    static void F2(Pair<object, object>? p2)
    {
        (p2.First, // 3
            _) =
                p2;
    }
    static void F3(Pair<object, object>? p3)
    {
        (p3.First, // 4
            p3.Second) =
                p3;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (14,17): warning CS8602: Possible dereference of a null reference.
                //                 p0; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "p0").WithLocation(14, 17),
                // (19,13): warning CS8602: Possible dereference of a null reference.
                //             p1.Second) = // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "p1").WithLocation(19, 13),
                // (24,10): warning CS8602: Possible dereference of a null reference.
                //         (p2.First, // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "p2").WithLocation(24, 10),
                // (30,10): warning CS8602: Possible dereference of a null reference.
                //         (p3.First, // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "p3").WithLocation(30, 10));
        }

        [Fact]
        public void Deconstruction_EvaluationOrder_04()
        {
            var source =
@"#pragma warning disable 0649
#pragma warning disable 8618
class Pair
{
    internal void Deconstruct(out object x, out object y) => throw null;
    internal object First;
    internal object Second;
}
class Program
{
    static void F0(Pair? x0, Pair? y0)
    {
        ((x0.First, // 1
            _),
                y0.First) = // 2
                    (x0,
                        y0.Second);
    }
    static void F1(Pair? x1, Pair? y1)
    {
        ((_,
            y1.First), // 3
                _) =
                    (x1, // 4
                        y1.Second);
    }
    static void F2(Pair? x2, Pair? y2)
    {
        ((_,
            _),
                x2.First) = // 5
                    (x2,
                        y2.Second); // 6
    }
    static void F3(Pair? x3, Pair? y3)
    {
        (x3.First, // 7
            (_,
                y3.First)) = // 8
                    (y3.Second,
                        x3);
    }
    static void F4(Pair? x4, Pair? y4)
    {
        (_,
            (x4.First, // 9
                _)) =
                    (x4.Second,
                        y4); // 10
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,11): warning CS8602: Possible dereference of a null reference.
                //         ((x0.First, // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x0").WithLocation(13, 11),
                // (15,17): warning CS8602: Possible dereference of a null reference.
                //                 y0.First) = // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y0").WithLocation(15, 17),
                // (22,13): warning CS8602: Possible dereference of a null reference.
                //             y1.First), // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y1").WithLocation(22, 13),
                // (24,22): warning CS8602: Possible dereference of a null reference.
                //                     (x1, // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x1").WithLocation(24, 22),
                // (31,17): warning CS8602: Possible dereference of a null reference.
                //                 x2.First) = // 5
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x2").WithLocation(31, 17),
                // (33,25): warning CS8602: Possible dereference of a null reference.
                //                         y2.Second); // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y2").WithLocation(33, 25),
                // (37,10): warning CS8602: Possible dereference of a null reference.
                //         (x3.First, // 7
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x3").WithLocation(37, 10),
                // (39,17): warning CS8602: Possible dereference of a null reference.
                //                 y3.First)) = // 8
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y3").WithLocation(39, 17),
                // (46,14): warning CS8602: Possible dereference of a null reference.
                //             (x4.First, // 9
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "x4").WithLocation(46, 14),
                // (49,25): warning CS8602: Possible dereference of a null reference.
                //                         y4); // 10
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y4").WithLocation(49, 25));
        }

        [Fact]
        public void Deconstruction_ImplicitBoxingConversion_01()
        {
            var source =
@"class Program
{
    static void F<T, U, V>((T, U, V?) t)
        where U : struct
        where V : struct
    {
        (object a, object b, object c) = t; // 1, 2
        a.ToString(); // 3
        b.ToString();
        c.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,42): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (object a, object b, object c) = t; // 1, 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(7, 42),
                // (7,42): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (object a, object b, object c) = t; // 1, 2
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "t").WithLocation(7, 42),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString(); // 3
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(8, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         c.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(10, 9));
        }

        [Fact]
        [WorkItem(33011, "https://github.com/dotnet/roslyn/issues/33011")]
        public void Deconstruction_ImplicitBoxingConversion_02()
        {
            var source =
@"class Program
{
    static void F<T>(T x, T? y) where T : struct
    {
        (T?, T?) t = (x, y);
        (object? a, object? b) = t;
        a.ToString();
        b.ToString(); // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33011: Should warn for `b` only.
            comp.VerifyDiagnostics(
                // (7,9): warning CS8602: Possible dereference of a null reference.
                //         a.ToString();
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a").WithLocation(7, 9),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         b.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b").WithLocation(8, 9));
        }

        [Fact]
        public void Deconstruction_ImplicitNullableConversion_01()
        {
            var source =
@"struct S
{
    internal object F;
}
class Program
{
    static void F(S s)
    {
        (S? x, S? y, S? z) = (s, new S(), default);
        _ = x.Value;
        x.Value.F.ToString();
        _ = y.Value;
        y.Value.F.ToString(); // 1
        _ = z.Value; // 2
        z.Value.F.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (3,21): warning CS0649: Field 'S.F' is never assigned to, and will always have its default value null
                //     internal object F;
                Diagnostic(ErrorCode.WRN_UnassignedInternalField, "F").WithArguments("S.F", "null").WithLocation(3, 21),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.Value.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.Value.F").WithLocation(13, 9),
                // (14,13): warning CS8629: Nullable value type may be null.
                //         _ = z.Value; // 2
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "z.Value").WithLocation(14, 13));
        }

        [Fact]
        [WorkItem(33011, "https://github.com/dotnet/roslyn/issues/33011")]
        public void Deconstruction_ImplicitNullableConversion_02()
        {
            var source =
@"#pragma warning disable 0649
struct S
{
    internal object F;
}
class Program
{
    static void F(S s)
    {
        (S, S) t = (s, new S());
        (S? x, S? y) = t;
        _ = x.Value;
        x.Value.F.ToString();
        _ = y.Value;
        y.Value.F.ToString(); // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33011: Should warn for `y.Value.F` only.
            comp.VerifyDiagnostics(
                // (12,13): warning CS8629: Nullable value type may be null.
                //         _ = x.Value;
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "x.Value").WithLocation(12, 13),
                // (14,13): warning CS8629: Nullable value type may be null.
                //         _ = y.Value;
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Value").WithLocation(14, 13));
        }

        [Fact]
        public void Deconstruction_TooFewVariables()
        {
            var source =
@"class Program
{
    static void F(object x, object y, object? z)
    {
        (object? a, object? b) = (x, y, z = 3);
        a.ToString();
        b.ToString();
        z.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): error CS8132: Cannot deconstruct a tuple of '3' elements into '2' variables.
                //         (object? a, object? b) = (x, y, z = 3);
                Diagnostic(ErrorCode.ERR_DeconstructWrongCardinality, "(object? a, object? b) = (x, y, z = 3)").WithArguments("3", "2").WithLocation(5, 9));
        }

        [Fact]
        public void Deconstruction_TooManyVariables()
        {
            var source =
@"class Program
{
    static void F(object x, object y)
    {
        (object? a, object? b, object? c) = (x, y = null);
        a.ToString();
        b.ToString();
        c.ToString();
        y.ToString(); // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (5,9): error CS8132: Cannot deconstruct a tuple of '2' elements into '3' variables.
                //         (object? a, object? b, object? c) = (x, y = null);
                Diagnostic(ErrorCode.ERR_DeconstructWrongCardinality, "(object? a, object? b, object? c) = (x, y = null)").WithArguments("2", "3").WithLocation(5, 9),
                // (5,53): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         (object? a, object? b, object? c) = (x, y = null);
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(5, 53),
                // (9,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(9, 9));
        }

        [Fact]
        public void Deconstruction_NoDeconstruct_01()
        {
            var source =
@"class C
{
    C(object o) { }
    static void F()
    {
        object? z = null;
        var (x, y) = new C(z = 1);
        x.ToString();
        y.ToString();
        z.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,14): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'x'.
                //         var (x, y) = new C(z = 1);
                Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "x").WithArguments("x").WithLocation(7, 14),
                // (7,17): error CS8130: Cannot infer the type of implicitly-typed deconstruction variable 'y'.
                //         var (x, y) = new C(z = 1);
                Diagnostic(ErrorCode.ERR_TypeInferenceFailedForImplicitlyTypedDeconstructionVariable, "y").WithArguments("y").WithLocation(7, 17),
                // (7,22): error CS1061: 'C' does not contain a definition for 'Deconstruct' and no accessible extension method 'Deconstruct' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
                //         var (x, y) = new C(z = 1);
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "new C(z = 1)").WithArguments("C", "Deconstruct").WithLocation(7, 22),
                // (7,22): error CS8129: No suitable 'Deconstruct' instance or extension method was found for type 'C', with 2 out parameters and a void return type.
                //         var (x, y) = new C(z = 1);
                Diagnostic(ErrorCode.ERR_MissingDeconstruct, "new C(z = 1)").WithArguments("C", "2").WithLocation(7, 22));
        }

        [Fact]
        public void Deconstruction_NoDeconstruct_02()
        {
            var source =
@"class C
{
    C(object o) { }
    static void F()
    {
        object? z = null;
        (object? x, object? y) = new C(z = 1);
        x.ToString();
        y.ToString();
        z.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (7,34): error CS1061: 'C' does not contain a definition for 'Deconstruct' and no accessible extension method 'Deconstruct' accepting a first argument of type 'C' could be found (are you missing a using directive or an assembly reference?)
                //         (object? x, object? y) = new C(z = 1);
                Diagnostic(ErrorCode.ERR_NoSuchMemberOrExtension, "new C(z = 1)").WithArguments("C", "Deconstruct").WithLocation(7, 34),
                // (7,34): error CS8129: No suitable 'Deconstruct' instance or extension method was found for type 'C', with 2 out parameters and a void return type.
                //         (object? x, object? y) = new C(z = 1);
                Diagnostic(ErrorCode.ERR_MissingDeconstruct, "new C(z = 1)").WithArguments("C", "2").WithLocation(7, 34));
        }

        [Fact]
        public void Deconstruction_TooFewDeconstructArguments()
        {
            var source =
@"class C
{
    internal void Deconstruct(out object x, out object y, out object z) => throw null;
}
class Program
{
    static void F()
    {
        (object? x, object? y) = new C();
        x.ToString();
        y.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,34): error CS7036: There is no argument given that corresponds to the required formal parameter 'z' of 'C.Deconstruct(out object, out object, out object)'
                //         (object? x, object? y) = new C();
                Diagnostic(ErrorCode.ERR_NoCorrespondingArgument, "new C()").WithArguments("z", "C.Deconstruct(out object, out object, out object)").WithLocation(9, 34),
                // (9,34): error CS8129: No suitable 'Deconstruct' instance or extension method was found for type 'C', with 2 out parameters and a void return type.
                //         (object? x, object? y) = new C();
                Diagnostic(ErrorCode.ERR_MissingDeconstruct, "new C()").WithArguments("C", "2").WithLocation(9, 34));
        }

        [Fact]
        public void Deconstruction_TooManyDeconstructArguments()
        {
            var source =
@"class C
{
    internal void Deconstruct(out object x, out object y) => throw null;
}
class Program
{
    static void F()
    {
        (object? x, object? y, object? z) = new C();
        x.ToString();
        y.ToString();
        z.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,45): error CS1501: No overload for method 'Deconstruct' takes 3 arguments
                //         (object? x, object? y, object? z) = new C();
                Diagnostic(ErrorCode.ERR_BadArgCount, "new C()").WithArguments("Deconstruct", "3").WithLocation(9, 45),
                // (9,45): error CS8129: No suitable 'Deconstruct' instance or extension method was found for type 'C', with 3 out parameters and a void return type.
                //         (object? x, object? y, object? z) = new C();
                Diagnostic(ErrorCode.ERR_MissingDeconstruct, "new C()").WithArguments("C", "3").WithLocation(9, 45));
        }

        [Fact]
        [WorkItem(26628, "https://github.com/dotnet/roslyn/issues/26628")]
        public void ImplicitConstructor_01()
        {
            var source =
@"#pragma warning disable 414
class Program
{
    object F = null; // warning
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,16): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     object F = null; // warning
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(4, 16));
        }

        [Fact]
        [WorkItem(26628, "https://github.com/dotnet/roslyn/issues/26628")]
        public void ImplicitConstructor_02()
        {
            var source =
@"#pragma warning disable 414
class Program
{
    static object F = null; // warning
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (4,23): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //     static object F = null; // warning
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(4, 23));
        }

        [Fact]
        [WorkItem(25868, "https://github.com/dotnet/roslyn/issues/25868")]
        public void ByRefTarget_01()
        {
            var source =
@"class Program
{
    static void F(ref object? x, ref object y)
    {
        x = 1;
        y = null; // 1
        x.ToString();
        y.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (6,13): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         y = null; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(6, 13),
                // (8,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(8, 9));
        }

        [Fact]
        [WorkItem(25868, "https://github.com/dotnet/roslyn/issues/25868")]
        public void ByRefTarget_02()
        {
            var source =
@"class Program
{
    static void F(object? px, object py)
    {
        ref object? x = ref px;
        ref object y = ref py;
        x = 1;
        y = null; // 1
        x.ToString();
        y.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8600: Converting null literal or possible null value to non-nullable type.
                //         y = null; // 1
                Diagnostic(ErrorCode.WRN_ConvertingNullableToNonNullable, "null").WithLocation(8, 13),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         y.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y").WithLocation(10, 9));
        }

        [Fact]
        [WorkItem(25868, "https://github.com/dotnet/roslyn/issues/25868")]
        public void ByRefTarget_03()
        {
            var source =
@"class Program
{
    static void F(ref int? x, ref int? y)
    {
        x = 1;
        y = null;
        _ = x.Value;
        _ = y.Value; // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (8,13): warning CS8629: Nullable value type may be null.
                //         _ = y.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Value").WithLocation(8, 13));
        }

        [Fact]
        [WorkItem(25868, "https://github.com/dotnet/roslyn/issues/25868")]
        public void ByRefTarget_04()
        {
            var source =
@"class Program
{
    static void F(int? px, int? py)
    {
        ref int? x = ref px;
        ref int? y = ref py;
        x = 1;
        y = null;
        _ = x.Value;
        _ = y.Value; // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,13): warning CS8629: Nullable value type may be null.
                //         _ = y.Value; // 1
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "y.Value").WithLocation(10, 13));
        }

        [Fact]
        [WorkItem(25868, "https://github.com/dotnet/roslyn/issues/25868")]
        public void ByRefTarget_05()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    internal object F;
}
class Program
{
    static void F(ref C x, ref C y)
    {
        x = new C() { F = 1 };
        y = new C() { F = null }; // 1
        x.F.ToString();
        y.F.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (11,27): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         y = new C() { F = null }; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(11, 27),
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(13, 9));
        }

        [Fact]
        [WorkItem(25868, "https://github.com/dotnet/roslyn/issues/25868")]
        public void ByRefTarget_06()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    internal object? F;
}
class Program
{
    static void F(ref C x, ref C y)
    {
        x = new C() { F = 1 };
        y = new C() { F = null };
        x.F.ToString();
        y.F.ToString(); // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(13, 9));
        }

        [Fact]
        [WorkItem(25868, "https://github.com/dotnet/roslyn/issues/25868")]
        public void ByRefTarget_07()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    internal object F;
}
class Program
{
    static void F(C px, C py)
    {
        ref C x = ref px;
        ref C y = ref py;
        x = new C() { F = 1 };
        y = new C() { F = null }; // 1
        x.F.ToString();
        y.F.ToString(); // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,27): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         y = new C() { F = null }; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(13, 27),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(15, 9));
        }

        [Fact]
        [WorkItem(25868, "https://github.com/dotnet/roslyn/issues/25868")]
        public void ByRefTarget_08()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    internal object? F;
}
class Program
{
    static void F(C px, C py)
    {
        ref C x = ref px;
        ref C y = ref py;
        x = new C() { F = 1 };
        y = new C() { F = null };
        x.F.ToString();
        y.F.ToString(); // 1
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         y.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "y.F").WithLocation(15, 9));
        }

        [Fact]
        [WorkItem(33095, "https://github.com/dotnet/roslyn/issues/33095")]
        public void ByRefTarget_09()
        {
            var source =
@"class Program
{
    static void F(ref string x)
    {
        ref string? y = ref x; // 1
        y = null;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33095: Missing warning.
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(33095, "https://github.com/dotnet/roslyn/issues/33095")]
        public void ByRefTarget_10()
        {
            var source =
@"class Program
{
    static ref string F1(ref string? x)
    {
        return ref x; // 1
    }
    static ref string? F2(ref string y)
    {
        return ref y; // 2
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            // https://github.com/dotnet/roslyn/issues/33095: Missing warning.
            comp.VerifyDiagnostics(
                // (5,20): warning CS8603: Possible null reference return.
                //         return ref x; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReturn, "x").WithLocation(5, 20));
        }

        [Fact]
        public void AssignmentToSameVariable_01()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    internal C F;
}
class Program
{
    static void F()
    {
        C a = new C() { F = null }; // 1
        a = a;
        a.F.ToString(); // 2
        C b = new C() { F = new C() { F = null } }; // 3
        b.F = b.F;
        b.F.F.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,29): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         C a = new C() { F = null }; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(10, 29),
                // (11,9): warning CS1717: Assignment made to same variable; did you mean to assign something else?
                //         a = a;
                Diagnostic(ErrorCode.WRN_AssignmentToSelf, "a = a").WithLocation(11, 9),
                // (12,9): warning CS8602: Possible dereference of a null reference.
                //         a.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "a.F").WithLocation(12, 9),
                // (13,43): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         C b = new C() { F = new C() { F = null } }; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(13, 43),
                // (14,9): warning CS1717: Assignment made to same variable; did you mean to assign something else?
                //         b.F = b.F;
                Diagnostic(ErrorCode.WRN_AssignmentToSelf, "b.F = b.F").WithLocation(14, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         b.F.F.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "b.F.F").WithLocation(15, 9));
        }

        [Fact]
        public void AssignmentToSameVariable_02()
        {
            var source =
@"#pragma warning disable 8618
struct A
{
    internal int? F;
}
struct B
{
    internal A A;
}
class Program
{
    static void F()
    {
        A a = new A() { F = 1 };
        a = a;
        _ = a.F.Value;
        B b = new B() { A = new A() { F = 2 } };
        b.A = b.A;
        _ = b.A.F.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (15,9): warning CS1717: Assignment made to same variable; did you mean to assign something else?
                //         a = a;
                Diagnostic(ErrorCode.WRN_AssignmentToSelf, "a = a").WithLocation(15, 9),
                // (18,9): warning CS1717: Assignment made to same variable; did you mean to assign something else?
                //         b.A = b.A;
                Diagnostic(ErrorCode.WRN_AssignmentToSelf, "b.A = b.A").WithLocation(18, 9));
        }

        [Fact]
        public void AssignmentToSameVariable_03()
        {
            var source =
@"#pragma warning disable 8618
class C
{
    internal object F;
}
class Program
{
    static void F(C? c)
    {
        c.F = c.F; // 1
        c.F.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS1717: Assignment made to same variable; did you mean to assign something else?
                //         c.F = c.F; // 1
                Diagnostic(ErrorCode.WRN_AssignmentToSelf, "c.F = c.F").WithLocation(10, 9),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         c.F = c.F; // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "c").WithLocation(10, 9));
        }

        [Fact]
        [WorkItem(26651, "https://github.com/dotnet/roslyn/issues/26651")]
        public void StaticMember_01()
        {
            var source =
@"class Program
{
    static readonly string? F = null;
    static readonly int? G = null;
    static void Main()
    {
        if (F != null)
            F.ToString();
        if (G != null)
            _ = G.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(26651, "https://github.com/dotnet/roslyn/issues/26651")]
        public void StaticMember_02()
        {
            var source =
@"#pragma warning disable 0649
class C<T>
{
    static T F;
    static void M()
    {
        if (F == null) return;
        F.ToString();
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics();
        }

        [Fact]
        [WorkItem(26651, "https://github.com/dotnet/roslyn/issues/26651")]
        public void StaticMember_03()
        {
            var source =
@"#pragma warning disable 0649
class C<T>
{
    internal static T F;
}
class Program
{
    static void F1<T1>()
    {
        C<T1>.F.ToString(); // 1
        C<T1>.F.ToString();
    }
    static void F2<T2>() where T2 : class
    {
        C<T2?>.F.ToString(); // 2
        C<T2>.F.ToString();
    }
    static void F3<T3>() where T3 : class
    {
        C<T3>.F.ToString();
        C<T3?>.F.ToString();
    }
    static void F4<T4>() where T4 : struct
    {
        _ = C<T4?>.F.Value; // 3
        _ = C<T4?>.F.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         C<T1>.F.ToString(); // 1
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "C<T1>.F").WithLocation(10, 9),
                // (15,9): warning CS8602: Possible dereference of a null reference.
                //         C<T2?>.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "C<T2?>.F").WithLocation(15, 9),
                // (25,13): warning CS8629: Nullable value type may be null.
                //         _ = C<T4?>.F.Value; // 3
                Diagnostic(ErrorCode.WRN_NullableValueTypeMayBeNull, "C<T4?>.F.Value").WithLocation(25, 13));
        }

        [Fact]
        [WorkItem(26651, "https://github.com/dotnet/roslyn/issues/26651")]
        public void StaticMember_04()
        {
            var source =
@"#pragma warning disable 0649
class C<T>
{
    internal static T F;
}
class Program
{
    static void F1<T1>()
    {
        C<T1>.F = default; // 1
        C<T1>.F.ToString(); // 2
    }
    static void F2<T2>() where T2 : class, new()
    {
        C<T2?>.F = new T2();
        C<T2?>.F.ToString();
    }
    static void F3<T3>() where T3 : class, new()
    {
        C<T3>.F = new T3();
        C<T3>.F.ToString();
    }
    static void F4<T4>() where T4 : class
    {
        C<T4>.F = null; // 3
        C<T4>.F.ToString(); // 4
    }
    static void F5<T5>() where T5 : struct
    {
        C<T5?>.F = default(T5);
        _ = C<T5?>.F.Value;
    }
    static void F6<T6>() where T6 : new()
    {
        C<T6>.F = new T6();
        C<T6>.F.ToString();
    }
    static void F7()
    {
        C<string>.F = null; // 5
        _ = C<string>.F.Length; // 6
    }
    static void F8()
    {
        C<int?>.F = 3;
        _ = C<int?>.F.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         C<T1>.F = default; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(10, 19),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         C<T1>.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "C<T1>.F").WithLocation(11, 9),
                // (25,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         C<T4>.F = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(25, 19),
                // (26,9): warning CS8602: Possible dereference of a null reference.
                //         C<T4>.F.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "C<T4>.F").WithLocation(26, 9),
                // (40,23): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         C<string>.F = null; // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(40, 23),
                // (41,13): warning CS8602: Possible dereference of a null reference.
                //         _ = C<string>.F.Length; // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "C<string>.F").WithLocation(41, 13));
        }

        [Fact]
        [WorkItem(26651, "https://github.com/dotnet/roslyn/issues/26651")]
        public void StaticMember_05()
        {
            var source =
@"class C<T>
{
    internal static T P
    {
        get => throw null;
        set { }
    }
}
class Program
{
    static void F1<T1>()
    {
        C<T1>.P = default; // 1
        C<T1>.P.ToString(); // 2
    }
    static void F2<T2>() where T2 : class, new()
    {
        C<T2?>.P = new T2();
        C<T2?>.P.ToString();
    }
    static void F3<T3>() where T3 : class, new()
    {
        C<T3>.P = new T3();
        C<T3>.P.ToString();
    }
    static void F4<T4>() where T4 : class
    {
        C<T4>.P = null; // 3
        C<T4>.P.ToString(); // 4
    }
    static void F5<T5>() where T5 : struct
    {
        C<T5?>.P = default(T5);
        _ = C<T5?>.P.Value;
    }
    static void F6<T6>() where T6 : new()
    {
        C<T6>.P = new T6();
        C<T6>.P.ToString();
    }
    static void F7()
    {
        C<string>.P = null; // 5
        _ = C<string>.P.Length; // 6
    }
    static void F8()
    {
        C<int?>.P = 3;
        _ = C<int?>.P.Value;
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (13,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         C<T1>.P = default; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(13, 19),
                // (14,9): warning CS8602: Possible dereference of a null reference.
                //         C<T1>.P.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "C<T1>.P").WithLocation(14, 9),
                // (28,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         C<T4>.P = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(28, 19),
                // (29,9): warning CS8602: Possible dereference of a null reference.
                //         C<T4>.P.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "C<T4>.P").WithLocation(29, 9),
                // (43,23): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         C<string>.P = null; // 5
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(43, 23),
                // (44,13): warning CS8602: Possible dereference of a null reference.
                //         _ = C<string>.P.Length; // 6
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "C<string>.P").WithLocation(44, 13));
        }

        [Fact]
        [WorkItem(26651, "https://github.com/dotnet/roslyn/issues/26651")]
        public void StaticMember_06()
        {
            var source =
@"#pragma warning disable 0649
struct S<T>
{
    internal static T F;
}
class Program
{
    static void F1<T1>()
    {
        S<T1>.F = default; // 1
        S<T1>.F.ToString(); // 2
    }
    static void F2<T2>() where T2 : class, new()
    {
        S<T2?>.F = new T2();
        S<T2?>.F.ToString();
    }
    static void F3<T3>() where T3 : class
    {
        S<T3>.F = null; // 3
        S<T3>.F.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (10,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         S<T1>.F = default; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(10, 19),
                // (11,9): warning CS8602: Possible dereference of a null reference.
                //         S<T1>.F.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "S<T1>.F").WithLocation(11, 9),
                // (20,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         S<T3>.F = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(20, 19),
                // (21,9): warning CS8602: Possible dereference of a null reference.
                //         S<T3>.F.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "S<T3>.F").WithLocation(21, 9));
        }

        [Fact]
        [WorkItem(26651, "https://github.com/dotnet/roslyn/issues/26651")]
        public void StaticMember_07()
        {
            var source =
@"struct S<T>
{
    internal static T P { get; set; }
}
class Program
{
    static void F1<T1>()
    {
        S<T1>.P = default; // 1
        S<T1>.P.ToString(); // 2
    }
    static void F2<T2>() where T2 : class, new()
    {
        S<T2?>.P = new T2();
        S<T2?>.P.ToString();
    }
    static void F3<T3>() where T3 : class
    {
        S<T3>.P = null; // 3
        S<T3>.P.ToString(); // 4
    }
}";
            var comp = CreateCompilation(source, options: WithNonNullTypesTrue());
            comp.VerifyDiagnostics(
                // (9,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         S<T1>.P = default; // 1
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "default").WithLocation(9, 19),
                // (10,9): warning CS8602: Possible dereference of a null reference.
                //         S<T1>.P.ToString(); // 2
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "S<T1>.P").WithLocation(10, 9),
                // (19,19): warning CS8625: Cannot convert null literal to non-nullable reference or unconstrained type parameter.
                //         S<T3>.P = null; // 3
                Diagnostic(ErrorCode.WRN_NullAsNonNullable, "null").WithLocation(19, 19),
                // (20,9): warning CS8602: Possible dereference of a null reference.
                //         S<T3>.P.ToString(); // 4
                Diagnostic(ErrorCode.WRN_NullReferenceReceiver, "S<T3>.P").WithLocation(20, 9));
        }
    }
}
